Node.js Best Practices

  



    


 Follow us on Twitter! @nodepractices

Read in a different language: CN, FR, BR, RU, PL, JA, EU (ES, HE, KR and TR in progress! )

🎊 2024 edition is here!


🛰 Modernized to 2024: Tons of text edits, new recommended libraries, and some new best practices


✨ Easily focus on new content: Already visited before? Search for #new or #updated tags for new content only


🔖 Curious to see examples? We have a starter: Visit Practica.js, our application example and boilerplate (beta) to see some practices in action



Welcome! 3 Things You Ought To Know First
1. You are reading dozens of the best Node.js articles - this repository is a summary and curation of the top-ranked content on Node.js best practices, as well as content written here by collaborators
2. It is the largest compilation, and it is growing every week - currently, more than 80 best practices, style guides, and architectural tips are presented. New issues and pull requests are created every day to keep this live book updated. We'd love to see you contributing here, whether that is fixing code mistakes, helping with translations, or suggesting brilliant new ideas. See our writing guidelines here
3. Best practices have additional info - most bullets include a 🔗Read More link that expands on the practice with code examples, quotes from selected blogs, and more information

By Yoni Goldberg
Learn with me: As a consultant, I engage with worldwide teams on various activities like workshops and code reviews. 🎉AND... Hold on, I've just launched my beyond-the-basics testing course, which is on a 🎁 limited-time sale until August 7th

Table of Contents

  
    1. Project Architecture Practices (6)
  
  1.1 Structure your solution by components #strategic #updated
  1.2 Layer your components, keep the web layer within its boundaries #strategic #updated
  1.3 Wrap common utilities as packages, consider publishing
  1.4 Use environment aware, secure and hierarchical config #updated
  1.5 Consider all the consequences when choosing the main framework #new
  1.6 Use TypeScript sparingly and thoughtfully #new


  
    2. Error Handling Practices (12)
  
  2.1 Use Async-Await or promises for async error handling
  2.2 Extend the built-in Error object #strategic #updated
  2.3 Distinguish operational vs programmer errors #strategic #updated
  2.4 Handle errors centrally, not within a middleware #strategic
  2.5 Document API errors using OpenAPI or GraphQL
  2.6 Exit the process gracefully when a stranger comes to town #strategic
  2.7 Use a mature logger to increase errors visibility #updated
  2.8 Test error flows using your favorite test framework #updated
  2.9 Discover errors and downtime using APM products
  2.10 Catch unhandled promise rejections #updated
  2.11 Fail fast, validate arguments using a dedicated library
  2.12 Always await promises before returning to avoid a partial stacktrace #new
  2.13 Subscribe to event emitters 'error' event #new


  
    3. Code Style Practices (12)
  
  3.1 Use ESLint #strategic
  3.2 Use Node.js eslint extension plugins #updated
  3.3 Start a Codeblock's Curly Braces on the Same Line
  3.4 Separate your statements properly
  3.5 Name your functions
  3.6 Use naming conventions for variables, constants, functions and classes
  3.7 Prefer const over let. Ditch the var
  3.8 Require modules first, not inside functions
  3.9 Set an explicit entry point to a module/folder #updated
  3.10 Use the === operator
  3.11 Use Async Await, avoid callbacks #strategic
  3.12 Use arrow function expressions (=>)
  3.13 Avoid effects outside of functions #new


  
    4. Testing And Overall Quality Practices (13)
  
  4.1 At the very least, write API (component) testing #strategic
  4.2 Include 3 parts in each test name #new
  4.3 Structure tests by the AAA pattern #strategic
  4.4 Ensure Node version is unified #new
  4.5 Avoid global test fixtures and seeds, add data per-test #strategic
  4.6 Tag your tests #advanced
  4.7 Check your test coverage, it helps to identify wrong test patterns
  4.8 Use production-like environment for e2e testing
  4.9 Refactor regularly using static analysis tools
  4.10 Mock responses of external HTTP services #advanced #new #advanced
  4.11 Test your middlewares in isolation
  4.12 Specify a port in production, randomize in testing #new
  4.13 Test the five possible outcomes #strategic #new


  
    5. Going To Production Practices (19)
  
  5.1. Monitoring #strategic
  5.2. Increase the observability using smart logging #strategic
  5.3. Delegate anything possible (e.g. gzip, SSL) to a reverse proxy #strategic
  5.4. Lock dependencies
  5.5. Guard process uptime using the right tool
  5.6. Utilize all CPU cores
  5.7. Create a ‘maintenance endpoint’
  5.8. Discover the unknowns using APM products #advanced #updated
  5.9. Make your code production-ready
  5.10. Measure and guard the memory usage #advanced
  5.11. Get your frontend assets out of Node
  5.12. Strive to be stateless #strategic
  5.13. Use tools that automatically detect vulnerabilities
  5.14. Assign a transaction id to each log statement #advanced
  5.15. Set NODE_ENV=production
  5.16. Design automated, atomic and zero-downtime deployments #advanced
  5.17. Use an LTS release of Node.js
  5.18. Log to stdout, avoid specifying log destination within the app #updated
  5.19. Install your packages with npm ci #new


  
    6. Security Practices (25)
  
  6.1. Embrace linter security rules
  6.2. Limit concurrent requests using a middleware
  6.3 Extract secrets from config files or use packages to encrypt them #strategic
  6.4. Prevent query injection vulnerabilities with ORM/ODM libraries #strategic
  6.5. Collection of generic security best practices
  6.6. Adjust the HTTP response headers for enhanced security
  6.7. Constantly and automatically inspect for vulnerable dependencies #strategic
  6.8. Protect Users' Passwords/Secrets using bcrypt or scrypt #strategic
  6.9. Escape HTML, JS and CSS output
  6.10. Validate incoming JSON schemas #strategic
  6.11. Support blocklisting JWTs
  6.12. Prevent brute-force attacks against authorization #advanced
  6.13. Run Node.js as non-root user
  6.14. Limit payload size using a reverse-proxy or a middleware
  6.15. Avoid JavaScript eval statements
  6.16. Prevent evil RegEx from overloading your single thread execution
  6.17. Avoid module loading using a variable
  6.18. Run unsafe code in a sandbox
  6.19. Take extra care when working with child processes #advanced
  6.20. Hide error details from clients
  6.21. Configure 2FA for npm or Yarn #strategic
  6.22. Modify session middleware settings
  6.23. Avoid DOS attacks by explicitly setting when a process should crash #advanced
  6.24. Prevent unsafe redirects
  6.25. Avoid publishing secrets to the npm registry
  6.26. 6.26 Inspect for outdated packages
  6.27. Import built-in modules using the 'node:' protocol #new


  
    7. Performance Practices (2) (Work In Progress️ ✍️)
  
  7.1. Don't block the event loop
  7.2. Prefer native JS methods over user-land utils like Lodash


  
    8. Docker Practices (15)
  
  8.1 Use multi-stage builds for leaner and more secure Docker images #strategic
  8.2. Bootstrap using node command, avoid npm start
  8.3. Let the Docker runtime handle replication and uptime #strategic
  8.4. Use .dockerignore to prevent leaking secrets
  8.5. Clean-up dependencies before production
  8.6. Shutdown smartly and gracefully #advanced
  8.7. Set memory limits using both Docker and v8 #advanced #strategic
  8.8. Plan for efficient caching
  8.9. Use explicit image reference, avoid latest tag
  8.10. Prefer smaller Docker base images
  8.11. Clean-out build-time secrets, avoid secrets in args #strategic #new
  8.12. Scan images for multi layers of vulnerabilities #advanced
  8.13 Clean NODE_MODULE cache
  8.14. Generic Docker practices
  8.15. Lint your Dockerfile #new


1. Project Architecture Practices
 1.1 Structure your solution by business components
📝 #updated
TL;DR: The root of a system should contain folders or repositories that represent reasonably sized business modules. Each component represents a product domain (i.e., bounded context), like 'user-component', 'order-component', etc. Each component has its own API, logic, and logical database. What is the significant merit? With an autonomous component, every change is performed over a granular and smaller scope - the mental overload, development friction, and deployment fear are much smaller and better. As a result, developers can move much faster. This does not necessarily demand physical separation and can be achieved using a Monorepo or with a multi-repo
my-system
├─ apps (components)
│  ├─ orders
│  ├─ users
│  ├─ payments
├─ libraries (generic cross-component functionality)
│  ├─ logger
│  ├─ authenticator
Otherwise: when artifacts from various modules/topics are mixed together, there are great chances of a tightly-coupled 'spaghetti' system. For example, in an architecture where 'module-a controller' might call 'module-b service', there are no clear modularity borders - every code change might affect anything else. With this approach, developers who code new features struggle to realize the scope and impact of their change. Consequently, they fear breaking other modules, and each deployment becomes slower and riskier
🔗 Read More: structure by components

 1.2 Layer your components with 3-tiers, keep the web layer within its boundaries
📝 #updated
TL;DR: Each component should contain 'layers' - a dedicated folder for common concerns: 'entry-point' where controller lives, 'domain' where the logic lives, and 'data-access'. The primary principle of the most popular architectures is to separate the technical concerns (e.g., HTTP, DB, etc) from the pure logic of the app so a developer can code more features without worrying about infrastructural concerns. Putting each concern in a dedicated folder, also known as the 3-Tier pattern, is the simplest way to meet this goal
my-system
├─ apps (components)
│  ├─ component-a
   │  ├─ entry-points
   │  │  ├─ api # controller comes here
   │  │  ├─ message-queue # message consumer comes here
   │  ├─ domain # features and flows: DTO, services, logic
   │  ├─ data-access # DB calls w/o ORM
Otherwise: It's often seen that developer pass web objects like request/response to functions in the domain/logic layer - this violates the separation principle and makes it harder to access later the logic code by other clients like testing code, scheduled jobs, message queues, etc
🔗 Read More: layer your app

 1.3 Wrap common utilities as packages, consider publishing
TL;DR: Place all reusable modules in a dedicated folder, e.g., "libraries", and underneath each module in its own folder, e.g., "/libraries/logger". Make the module an independent package with its own package.json file to increase the module encapsulation, and allows future publishing to a repository. In a Monorepo setup, modules can be consumed by 'npm linking' to their physical paths, using ts-paths or by publishing and installing from a package manager repository like the npm registry
my-system
├─ apps (components)
  │  ├─ component-a
├─ libraries (generic cross-component functionality)
│  ├─ logger
│  │  ├─ package.json
│  │  ├─ src
│  │  │ ├─ index.js

Otherwise: Clients of a module might import and get coupled to internal functionality of a module. With a package.json at the root, one can set a package.json.main or package.json.exports to explicitly tell which files and functions are part of the public interface
🔗 Read More: Structure by feature

 1.4 Use environment aware, secure and hierarchical config
📝 #updated
TL;DR: A flawless configuration setup should ensure (a) keys can be read from file AND from environment variable (b) secrets are kept outside committed code (c) config is hierarchical for easier findability (d) typing support (e) validation for failing fast (f) Specify default for each key. There are a few packages that can help tick most of those boxes like convict, env-var, zod, and others
Otherwise: Consider a mandatory environment variable that wasn't provided. The app starts successfully and serve requests, some information is already persisted to DB. Then, it's realized that without this mandatory key the request can't complete, leaving the app in a dirty state
🔗 Read More: configuration best practices

 1.5 Consider all the consequences when choosing the main framework
🌟 #new
TL;DR: When building apps and APIs, using a framework is mandatory. It's easy to overlook alternative frameworks or important considerations and then finally land on a sub optimal option. As of 2023/2024, we believe that these four frameworks are worth considering: Nest.js, Fastify, express, and Koa. Click read more below for a detailed pros/cons of each framework. Simplistically, we believe that Nest.js is the best match for teams who wish to go OOP and/or build large-scale apps that can't get partitioned into smaller autonomous components. Fastify is our recommendation for apps with reasonably-sized components (e.g., Microservices) that are built around simple Node.js mechanics. Read our full considerations guide here
Otherwise: Due to the overwhelming amount of considerations, it's easy to make decisions based on partial information and compare apples with oranges. For example, it's believed that Fastify is a minimal web-server that should get compared with express only. In reality, it's a rich framework with many official plugins that cover many concerns
🔗 Read More: Choosing the right framework
 1.6 Use TypeScript sparingly and thoughtfully
🌟 #new
TL;DR: Coding without type safety is no longer an option, TypeScript is the most popular option for this mission. Use it to define variables and functions return types. With that, it is also a double edge sword that can greatly encourage complexity with its additional ~ 50 keywords and sophisticated features. Consider using it sparingly, mostly with simple types, and utilize advanced features only when a real need arises
Otherwise: Researches show that using TypeScript can help in detecting ~20% bugs earlier. Without it, also the developer experience in the IDE is intolerable. On the flip side, 80% of other bugs were not discovered using types. Consequently, typed syntax is valuable but limited. Only efficient tests can discover the whole spectrum of bugs, including type-related bugs. It might also defeat its purpose: sophisticated code features are likely to increase the code complexity, which by itself increases both the amount of bugs and the average bug fix time
🔗 Read More: TypeScript considerations

⬆ Return to top
2. Error Handling Practices
 2.1 Use Async-Await or promises for async error handling
TL;DR: Handling async errors in callback style is probably the fastest way to hell (a.k.a the pyramid of doom). The best gift you can give to your code is using Promises with async-await which enables a much more compact and familiar code syntax like try-catch
Otherwise: Node.js callback style, function(err, response), is a promising way to un-maintainable code due to the mix of error handling with casual code, excessive nesting, and awkward coding patterns
🔗 Read More: avoiding callbacks

 2.2 Extend the built-in Error object
📝 #updated
TL;DR: Some libraries throw errors as a string or as some custom type – this complicates the error handling logic and the interoperability between modules. Instead, create app error object/class that extends the built-in Error object and use it whenever rejecting, throwing or emitting an error. The app error should add useful imperative properties like the error name/code and isCatastrophic. By doing so, all errors have a unified structure and support better error handling. There is no-throw-literal ESLint rule that strictly checks that (although it has some limitations which can be solved when using TypeScript and setting the @typescript-eslint/no-throw-literal rule)
Otherwise: When invoking some component, being uncertain which type of errors come in return – it makes proper error handling much harder. Even worse, using custom types to describe errors might lead to loss of critical error information like the stack trace!
🔗 Read More: using the built-in error object

 2.3 Distinguish catastrophic errors from operational errors
📝 #updated
TL;DR: Operational errors (e.g. API received an invalid input) refer to known cases where the error impact is fully understood and can be handled thoughtfully. On the other hand, catastrophic error (also known as programmer errors) refers to unusual code failures that dictate to gracefully restart the application
Otherwise: You may always restart the application when an error appears, but why let ~5000 online users down because of a minor, predicted, operational error? The opposite is also not ideal – keeping the application up when an unknown catastrophic issue (programmer error) occurred might lead to an unpredicted behavior. Differentiating the two allows acting tactfully and applying a balanced approach based on the given context
🔗 Read More: operational vs programmer error

 2.4 Handle errors centrally, not within a middleware
TL;DR: Error handling logic such as logging, deciding whether to crash and monitoring metrics should be encapsulated in a dedicated and centralized object that all entry-points (e.g. APIs, cron jobs, scheduled jobs) call when an error comes in
Otherwise: Not handling errors within a single place will lead to code duplication and probably to improperly handled errors
🔗 Read More: handling errors in a centralized place

 2.5 Document API errors using OpenAPI or GraphQL
TL;DR: Let your API callers know which errors might come in return so they can handle these thoughtfully without crashing. For RESTful APIs, this is usually done with documentation frameworks like OpenAPI. If you're using GraphQL, you can utilize your schema and comments as well
Otherwise: An API client might decide to crash and restart only because it received back an error it couldn’t understand. Note: the caller of your API might be you (very typical in a microservice environment)
🔗 Read More: documenting API errors in Swagger or GraphQL

 2.6 Exit the process gracefully when a stranger comes to town
TL;DR: When an unknown error occurs (catastrophic error, see best practice 2.3) - there is uncertainty about the application healthiness. In this case, there is no escape from making the error observable, shutting off connections and exiting the process. Any reputable runtime framework like Dockerized services or cloud serverless solutions will take care to restart
Otherwise: When an unfamiliar exception occurs, some object might be in a faulty state (e.g. an event emitter which is used globally and not firing events anymore due to some internal failure) and all future requests might fail or behave crazily
🔗 Read More: shutting the process

 2.7 Use a mature logger to increase errors visibility
📝 #updated
TL;DR: A robust logging tools like Pino or Winston increases the errors visibility using features like log-levels, pretty print coloring and more. Console.log lacks these imperative features and should be avoided. The best in class logger allows attaching custom useful properties to log entries with minimized serialization performance penalty. Developers should write logs to stdout and let the infrastructure pipe the stream to the appropriate log aggregator
Otherwise: Skimming through console.logs or manually through messy text file without querying tools or a decent log viewer might keep you busy at work until late
🔗 Read More: using a mature logger

 2.8 Test error flows using your favorite test framework
📝 #updated
TL;DR: Whether professional automated QA or plain manual developer testing – Ensure that your code not only satisfies positive scenarios but also handles and returns the right errors. On top of this, simulate deeper error flows like uncaught exceptions and ensure that the error handler treat these properly (see code examples within the "read more" section)
Otherwise: Without testing, whether automatically or manually, you can’t rely on your code to return the right errors. Without meaningful errors – there’s no error handling
🔗 Read More: testing error flows

 2.9 Discover errors and downtime using APM products
TL;DR: Monitoring and performance products (a.k.a APM) proactively gauge your codebase or API so they can automagically highlight errors, crashes, and slow parts that you were missing
Otherwise: You might spend great effort on measuring API performance and downtimes, probably you’ll never be aware which are your slowest code parts under real-world scenario and how these affect the UX
🔗 Read More: using APM products

 2.10 Catch unhandled promise rejections
📝 #updated
TL;DR: Any exception thrown within a promise will get swallowed and discarded unless a developer didn’t forget to explicitly handle it. Even if your code is subscribed to process.uncaughtException! Overcome this by registering to the event process.unhandledRejection
Otherwise: Your errors will get swallowed and leave no trace. Nothing to worry about
🔗 Read More: catching unhandled promise rejection

 2.11 Fail fast, validate arguments using a dedicated library
TL;DR: Assert API input to avoid nasty bugs that are much harder to track later. The validation code is usually tedious unless you are using a modern validation library like ajv, zod, or typebox
Otherwise: Consider this – your function expects a numeric argument “Discount” which the caller forgets to pass, later on, your code checks if Discount!=0 (amount of allowed discount is greater than zero), then it will allow the user to enjoy a discount. OMG, what a nasty bug. Can you see it?
🔗 Read More: failing fast

 2.12 Always await promises before returning to avoid a partial stacktrace
🌟 #new
TL;DR: Always do return await when returning a promise to benefit full error stacktrace. If a
function returns a promise, that function must be declared as async function and explicitly
await the promise before returning it
Otherwise: The function that returns a promise without awaiting won't appear in the stacktrace.
Such missing frames would probably complicate the understanding of the flow that leads to the error,
especially if the cause of the abnormal behavior is inside of the missing function
🔗 Read More: returning promises

 2.13 Subscribe to event emitters and streams 'error' event
🌟 #new
TL;DR: Unlike typical functions, a try-catch clause won't get errors that originate from Event Emitters and anything inherited from it (e.g., streams). Instead of try-catch, subscribe to an event emitter's 'error' event so your code can handle the error in context. When dealing with EventTargets (the web standard version of Event Emitters) there are no 'error' event and all errors end in the process.on('error) global event - in this case, at least ensure that the process crash or not based on the desired context. Also, mind that error originating from asynchronous event handlers are not get caught unless the event emitter is initialized with {captureRejections: true}
Otherwise: Event emitters are commonly used for global and key application functionality such as DB or message queue connection. When this kind of crucial objects throw an error, at best the process will crash due to unhandled exception. Even worst, it will stay alive as a zombie while a key functionality is turned off

⬆ Return to top
3. Code Patterns And Style Practices
 3.1 Use ESLint
TL;DR: ESLint is the de-facto standard for checking possible code errors and fixing code style, not only to identify nitty-gritty spacing issues but also to detect serious code anti-patterns like developers throwing errors without classification. Though ESLint can automatically fix code styles, other tools like prettier are more powerful in formatting the fix and work in conjunction with ESLint
Otherwise: Developers will focus on tedious spacing and line-width concerns and time might be wasted overthinking the project's code style
🔗 Read More: Using ESLint and Prettier

 3.2 Use Node.js eslint extension plugins
📝 #updated
TL;DR: On top of ESLint standard rules that cover vanilla JavaScript, add Node.js specific plugins like eslint-plugin-node, eslint-plugin-mocha and eslint-plugin-node-security, eslint-plugin-require, /eslint-plugin-jest and other useful rules
Otherwise: Many faulty Node.js code patterns might escape under the radar. For example, developers might require(variableAsPath) files with a variable given as a path which allows attackers to execute any JS script. Node.js linters can detect such patterns and complain early

 3.3 Start a Codeblock's Curly Braces on the Same Line
TL;DR: The opening curly braces of a code block should be on the same line as the opening statement
Code Example
// Do
function someFunction() {
  // code block
}

// Avoid
function someFunction()
{
  // code block
}
Otherwise: Deferring from this best practice might lead to unexpected results, as seen in the StackOverflow thread below:
🔗 Read more: "Why do results vary based on curly brace placement?" (StackOverflow)

 3.4 Separate your statements properly
No matter if you use semicolons or not to separate your statements, knowing the common pitfalls of improper linebreaks or automatic semicolon insertion, will help you to eliminate regular syntax errors.
TL;DR: Use ESLint to gain awareness about separation concerns. Prettier or Standardjs can automatically resolve these issues.
Otherwise: As seen in the previous section, JavaScript's interpreter automatically adds a semicolon at the end of a statement if there isn't one, or considers a statement as not ended where it should, which might lead to some undesired results. You can use assignments and avoid using immediately invoked function expressions to prevent most of the unexpected errors.
Code example
// Do
function doThing() {
    // ...
}

doThing()

// Do

const items = [1, 2, 3]
items.forEach(console.log)

// Avoid — throws exception
const m = new Map()
const a = [1,2,3]
[...m.values()].forEach(console.log)
> [...m.values()].forEach(console.log)
>  ^^^
> SyntaxError: Unexpected token ...

// Avoid — throws exception
const count = 2 // it tries to run 2(), but 2 is not a function
(function doSomething() {
  // do something amazing
}())
// put a semicolon before the immediate invoked function, after the const definition, save the return value of the anonymous function to a variable or avoid IIFEs altogether
🔗 Read more: "Semi ESLint rule"
🔗 Read more: "No unexpected multiline ESLint rule"

 3.5 Name your functions
TL;DR: Name all functions, including closures and callbacks. Avoid anonymous functions. This is especially useful when profiling a node app. Naming all functions will allow you to easily understand what you're looking at when checking a memory snapshot
Otherwise: Debugging production issues using a core dump (memory snapshot) might become challenging as you notice significant memory consumption from anonymous functions

 3.6 Use naming conventions for variables, constants, functions and classes
TL;DR: Use lowerCamelCase when naming constants, variables and functions, UpperCamelCase (capital first letter as well) when naming classes and UPPER_SNAKE_CASE when naming global or static variables. This will help you to easily distinguish between plain variables, functions, classes that require instantiation and variables declared at global module scope. Use descriptive names, but try to keep them short
Otherwise: JavaScript is the only language in the world that allows invoking a constructor ("Class") directly without instantiating it first. Consequently, Classes and function-constructors are differentiated by starting with UpperCamelCase
3.6 Code Example
// for global variables names we use the const/let keyword and UPPER_SNAKE_CASE
let MUTABLE_GLOBAL = "mutable value";
const GLOBAL_CONSTANT = "immutable value";
const CONFIG = {
  key: "value",
};

// examples of UPPER_SNAKE_CASE convention in nodejs/javascript ecosystem
// in javascript Math.PI module
const PI = 3.141592653589793;

// https://github.com/nodejs/node/blob/b9f36062d7b5c5039498e98d2f2c180dca2a7065/lib/internal/http2/core.js#L303
// in nodejs http2 module
const HTTP_STATUS_OK = 200;
const HTTP_STATUS_CREATED = 201;

// for class name we use UpperCamelCase
class SomeClassExample {
  // for static class properties we use UPPER_SNAKE_CASE
  static STATIC_PROPERTY = "value";
}

// for functions names we use lowerCamelCase
function doSomething() {
  // for scoped variable names we use the const/let keyword and lowerCamelCase
  const someConstExample = "immutable value";
  let someMutableExample = "mutable value";
}

 3.7 Prefer const over let. Ditch the var
TL;DR: Using const means that once a variable is assigned, it cannot be reassigned. Preferring const will help you to not be tempted to use the same variable for different uses, and make your code clearer. If a variable needs to be reassigned, in a for loop, for example, use let to declare it. Another important aspect of let is that a variable declared using it is only available in the block scope in which it was defined. var is function scoped, not block-scoped, and shouldn't be used in ES6 now that you have const and let at your disposal
Otherwise: Debugging becomes way more cumbersome when following a variable that frequently changes
🔗 Read more: JavaScript ES6+: var, let, or const? 

 3.8 Require modules first, not inside functions
TL;DR: Require modules at the beginning of each file, before and outside of any functions. This simple best practice will not only help you easily and quickly tell the dependencies of a file right at the top but also avoids a couple of potential problems
Otherwise: Requires are run synchronously by Node.js. If they are called from within a function, it may block other requests from being handled at a more critical time. Also, if a required module or any of its dependencies throw an error and crash the server, it is best to find out about it as soon as possible, which might not be the case if that module is required from within a function

 3.9 Set an explicit entry point to a module/folder
📝 #updated
TL;DR: When developing a module/library, set an explicit root file that exports the public and interesting code. Discourage the client code from importing deep files and becoming familiar with the internal structure. With commonjs (require), this can be done with an index.js file at the folder's root or the package.json.main field. With ESM (import), if a package.json exists on the root, the field "exports" allow specifying the module's root file. If no package.json exists, you may put an index.js file on the root which re-exports all the public functionality
Otherwise: Having an explicit root file acts like a public 'interface' that encapsulates the internal, directs the caller to the public code and facilitates future changes without breaking the contract
3.9 Code example - avoid coupling the client to the module structure
// Avoid: client has deep familiarity with the internals

// Client code
const SMSWithMedia = require("./SMSProvider/providers/media/media-provider.js");

// Better: explicitly export the public functions

//index.js, module code
module.exports.SMSWithMedia = require("./SMSProvider/providers/media/media-provider.js");

// Client code
const { SMSWithMedia } = require("./SMSProvider");

 3.10 Use the === operator
TL;DR: Prefer the strict equality operator === over the weaker abstract equality operator ==. == will compare two variables after converting them to a common type. There is no type conversion in ===, and both variables must be of the same type to be equal
Otherwise: Unequal variables might return true when compared with the == operator
3.10 Code example
"" == "0"; // false
0 == ""; // true
0 == "0"; // true

false == "false"; // false
false == "0"; // true

false == undefined; // false
false == null; // false
null == undefined; // true

" \t\r\n " == 0; // true
All statements above will return false if used with ===

 3.11 Use Async Await, avoid callbacks
TL;DR: Async-await is the simplest way to express an asynchronous flow as it makes asynchronous code look synchronous. Async-await will also result in much more compact code and support for try-catch. This technique now supersedes callbacks and promises in most cases. Using it in your code is probably the best gift one can give to the code reader
Otherwise: Handling async errors in callback style are probably the fastest way to hell - this style forces to check errors all over, deal with awkward code nesting, and makes it difficult to reason about the code flow
🔗Read more: Guide to async-await 1.0

 3.12 Use arrow function expressions (=>)
TL;DR: Though it's recommended to use async-await and avoid function parameters when dealing with older APIs that accept promises or callbacks - arrow functions make the code structure more compact and keep the lexical context of the root function (i.e. this)
Otherwise: Longer code (in ES5 functions) is more prone to bugs and cumbersome to read
🔗 Read more: It’s Time to Embrace Arrow Functions

 3.13 Avoid effects outside of functions
🌟 #new
TL;DR: Avoid putting code with effects like network or DB calls outside of functions. Such a code will be executed immediately when another file requires the file. This 'floating' code might get executed when the underlying system is not ready yet. It also comes with a performance penalty even when this module's functions will finally not be used in runtime. Last, mocking these DB/network calls for testing is harder outside of functions. Instead, put this code inside functions that should get called explicitly. If some DB/network code must get executed right when the module loads, consider using the factory or revealing module patterns
Otherwise: A typical web framework sets error handler, environment variables and monitoring. When DB/network calls are made before the web framework is initialized, they won't be monitored or fail due to a lack of configuration data

⬆ Return to top
4. Testing And Overall Quality Practices
_We have dedicated guides for testing, see below. The best practices list here is a brief summary of these guides
a. JavaScript testing best practices
b. Node.js testing - beyond the basics
_
 4.1 At the very least, write API (component) testing
TL;DR: Most projects just don't have any automated testing due to short timetables or often the 'testing project' ran out of control and was abandoned. For that reason, prioritize and start with API testing which is the easiest way to write and provides more coverage than unit testing (you may even craft API tests without code using tools like Postman). Afterwards, should you have more resources and time, continue with advanced test types like unit testing, DB testing, performance testing, etc
Otherwise: You may spend long days on writing unit tests to find out that you got only 20% system coverage

 4.2 Include 3 parts in each test name
🌟 #new
TL;DR: Make the test speak at the requirements level so it's self-explanatory also to QA engineers and developers who are not familiar with the code internals. State in the test name what is being tested (unit under test), under what circumstances, and what is the expected result
Otherwise: A deployment just failed, a test named “Add product” failed. Does this tell you what exactly is malfunctioning?
🔗 Read More: Include 3 parts in each test name

 4.3 Structure tests by the AAA pattern
🌟 #new
TL;DR: Structure your tests with 3 well-separated sections: Arrange, Act & Assert (AAA). The first part includes the test setup, then the execution of the unit under test, and finally the assertion phase. Following this structure guarantees that the reader spends no brain CPU on understanding the test plan
Otherwise: Not only you spend long daily hours on understanding the main code, but now also what should have been the simple part of the day (testing) stretches your brain
🔗 Read More: Structure tests by the AAA pattern

 4.4 Ensure Node version is unified
🌟 #new
TL;DR: Use tools that encourage or enforce the same Node.js version across different environments and developers. Tools like nvm, and Volta allow specifying the project's version in a file so each team member can run a single command to conform with the project's version. Optionally, this definition can be replicated to CI and the production runtime (e.g., copy the specified value to .Dockerfile build and to the CI declaration file)
Otherwise: A developer might face or miss an error because she uses a different Node.js version than her teammates. Even worse - the production runtime might be different than the environment where tests were executed

 4.5 Avoid global test fixtures and seeds, add data per-test
TL;DR: To prevent test coupling and easily reason about the test flow, each test should add and act on its own set of DB rows. Whenever a test needs to pull or assume the existence of some DB data - it must explicitly add that data and avoid mutating any other records
Otherwise: Consider a scenario where deployment is aborted due to failing tests, team is now going to spend precious investigation time that ends in a sad conclusion: the system works well, the tests however interfere with each other and break the build
🔗 Read More: Avoid global test fixtures

 4.6 Tag your tests
TL;DR: Different tests must run on different scenarios: quick smoke, IO-less, tests should run when a developer saves or commits a file, full end-to-end tests usually run when a new pull request is submitted, etc. This can be achieved by tagging tests with keywords like #cold #api #sanity so you can grep with your testing harness and invoke the desired subset. For example, this is how you would invoke only the sanity test group with Mocha: mocha --grep 'sanity'
Otherwise: Running all the tests, including tests that perform dozens of DB queries, any time a developer makes a small change can be extremely slow and keeps developers away from running tests

 4.7 Check your test coverage, it helps to identify wrong test patterns
TL;DR: Code coverage tools like Istanbul/NYC are great for 3 reasons: it comes for free (no effort is required to benefit this reports), it helps to identify a decrease in testing coverage, and last but not least it highlights testing mismatches: by looking at colored code coverage reports you may notice, for example, code areas that are never tested like catch clauses (meaning that tests only invoke the happy paths and not how the app behaves on errors). Set it to fail builds if the coverage falls under a certain threshold
Otherwise: There won't be any automated metric telling you when a large portion of your code is not covered by testing

 4.8 Use production-like environment for e2e testing
TL;DR: End to end (e2e) testing which includes live data used to be the weakest link of the CI process as it depends on multiple heavy services like DB. Use an environment which is as close to your real production environment as possible like a-continue (Missed -continue here, needs content. Judging by the Otherwise clause, this should mention docker-compose)
Otherwise: Without docker-compose, teams must maintain a testing DB for each testing environment including developers' machines, keep all those DBs in sync so test results won't vary across environments

 4.9 Refactor regularly using static analysis tools
TL;DR: Using static analysis tools helps by giving objective ways to improve code quality and keeps your code maintainable. You can add static analysis tools to your CI build to fail when it finds code smells. Its main selling points over plain linting are the ability to inspect quality in the context of multiple files (e.g. detect duplications), perform advanced analysis (e.g. code complexity), and follow the history and progress of code issues. Two examples of tools you can use are Sonarqube (2,600+ stars) and Code Climate (1,500+ stars).
Otherwise: With poor code quality, bugs and performance will always be an issue that no shiny new library or state of the art features can fix
🔗 Read More: Refactoring!

 4.10 Mock responses of external HTTP services
🌟 #new
TL;DR: Use network mocking tools to simulate responses of external collaborators' services that are approached over the network (e.g., REST, Graph). This is imperative not only to isolate the component under test but mostly to simulate non-happy path flows. Tools like nock (in-process) or Mock-Server allow defining a specific response of external service in a single line of code. Remember to simulate also errors, delays, timeouts, and any other event that is likely to happen in production
Otherwise: Allowing your component to reach real external services instances will likely result in naive tests that mostly cover happy paths. The tests might also be flaky and slow
🔗 Read More: Mock external services
 4.11 Test your middlewares in isolation
TL;DR: When a middleware holds some immense logic that spans many requests, it is worth testing it in isolation without waking up the entire web framework. This can be easily achieved by stubbing and spying on the {req, res, next} objects
Otherwise: A bug in Express middleware === a bug in all or most requests
🔗 Read More: Test middlewares in isolation
 4.12 Specify a port in production, randomize in testing
🌟 #new
TL;DR: When testing against the API, it's common and desirable to initialize the web server inside the tests. Let the server randomize the web server port in testing to prevent collisions. If you're using Node.js http server (used by most frameworks), doing so demands nothing but passing a port number zero - this will randomize an available port
Otherwise: Specifying a fixed port will prevent two testing processes from running at the same time. Most of the modern test runners run with multiple processes by default
🔗 Read More: Randomize a port for testing
 4.13 Test the five possible outcomes
🌟 #new
TL;DR: When testing a flow, ensure to cover five potential categories. Any time some action is triggered (e.g., API call), a reaction occurs, a meaningful outcome is produced and calls for testing. There are five possible outcome types for every flow: a response, a visible state change (e.g., DB), an outgoing API call, a new message in a queue, and an observability call (e.g., logging, metric). See a checklist here. Each type of outcome comes with unique challenges and techniques to mitigate those challenges - we have a dedicated guide about this topic: Node.js testing - beyond the basics
Otherwise: Consider a case when testing the addition of a new product to the system. It's common to see tests that assert on a valid response only. What if the product was failed to persist regardless of the positive response? what if when adding a new product demands calling some external service, or putting a message in the queue - shouldn't the test assert these outcomes as well? It's easy to overlook various paths, this is where a checklist comes handy
🔗 Read More: Test five outcomes

⬆ Return to top
5. Going To Production Practices
 5.1. Monitoring
TL;DR: Monitoring is a game of finding out issues before customers do – obviously this should be assigned unprecedented importance. The market is overwhelmed with offers thus consider starting with defining the basic metrics you must follow (my suggestions inside), then go over additional fancy features and choose the solution that ticks all boxes. In any case, the 4 layers of observability must be covered: uptime, metrics with focus on user-facing symptoms and Node.js technical metrics like event loop lag, distributed flows measurement with Open Telemetry and logging. Click ‘Read More’ below for an overview of the solutions
Otherwise: Failure === disappointed customers. Simple
🔗 Read More: Monitoring!

 5.2. Increase the observability using smart logging
TL;DR: Logs can be a dumb warehouse of debug statements or the enabler of a beautiful dashboard that tells the story of your app. Plan your logging platform from day 1: how logs are collected, stored and analyzed to ensure that the desired information (e.g. error rate, following an entire transaction through services and servers, etc) can really be extracted
Otherwise: You end up with a black box that is hard to reason about, then you start re-writing all logging statements to add additional information
🔗 Read More: Increase transparency using smart logging

 5.3. Delegate anything possible (e.g. gzip, SSL) to a reverse proxy
TL;DR: Node is quite bad at doing CPU intensive tasks like gzipping, SSL termination, etc. You should use specialized infrastructure like nginx, HAproxy or cloud vendor services instead
Otherwise: Your poor single thread will stay busy doing infrastructural tasks instead of dealing with your application core and performance will degrade accordingly
🔗 Read More: Delegate anything possible (e.g. gzip, SSL) to a reverse proxy

 5.4. Lock dependencies
TL;DR: Your code must be identical across all environments, but without a special lockfile npm lets dependencies drift across environments. Ensure to commit your package-lock.json so all the environments will be identical
Otherwise: QA will thoroughly test the code and approve a version that will behave differently in production. Even worse, different servers in the same production cluster might run different code
🔗 Read More: Lock dependencies

 5.5. Guard process uptime using the right tool
TL;DR: The process must go on and get restarted upon failures. Modern runtime platforms like Docker-ized platforms (e.g. Kubernetes), and Serverless take care for this automatically. When the app is hosted on a bare metal server, one must take care for a process management tools like systemd. Avoid including a custom process management tool in a modern platform that monitors an app instance (e.g., Kubernetes) - doing so will hide failures from the infrastructure. When the underlying infrastructure is not aware of errors, it can't perform useful mitigation steps like re-placing the instance in a different location
Otherwise: Running dozens of instances without a clear strategy and too many tools together (cluster management, docker, PM2) might lead to DevOps chaos
🔗 Read More: Guard process uptime using the right tool

 5.6. Utilize all CPU cores
TL;DR: At its basic form, a Node app runs on a single CPU core while all others are left idling. It’s your duty to replicate the Node process and utilize all CPUs. Most of the modern run-times platform (e.g., Kubernetes) allow replicating instances of the app but they won't verify that all cores are utilized - this is your duty. If the app is hosted on a bare server, it's also your duty to use some process replication solution (e.g. systemd)
Otherwise: Your app will likely utilize only 25% of its available resources(!) or even less. Note that a typical server has 4 CPU cores or more, naive deployment of Node.js utilizes only 1 (even using PaaS services like AWS beanstalk!)
🔗 Read More: Utilize all CPU cores

 5.7. Create a ‘maintenance endpoint’
TL;DR: Expose a set of system-related information, like memory usage and REPL, etc in a secured API. Although it’s highly recommended to rely on standard and battle-tested tools, some valuable information and operations are easier done using code
Otherwise: You’ll find that you’re performing many “diagnostic deploys” – shipping code to production only to extract some information for diagnostic purposes
🔗 Read More: Create a ‘maintenance endpoint’

 5.8. Discover the unknowns using APM products
📝 #updated
TL;DR: Consider adding another safety layer to the production stack - APM. While the majority of symptoms and causes can be detected using traditional monitoring techniques, in a distributed system there is more than meets the eye. Application monitoring and performance products (a.k.a. APM) can auto-magically go beyond traditional monitoring and provide additional layer of discovery and developer-experience. For example, some APM products can highlight a transaction that loads too slow on the end-user's side while suggesting the root cause. APMs also provide more context for developers who try to troubleshoot a log error by showing what was the server busy with when the error occurred. To name a few example
Otherwise: You might spend great effort on measuring API performance and downtimes, probably you’ll never be aware which is your slowest code parts under real-world scenario and how these affect the UX
🔗 Read More: Discover errors and downtime using APM products

 5.9. Make your code production-ready
TL;DR: Code with the end in mind, plan for production from day 1. This sounds a bit vague so I’ve compiled a few development tips that are closely related to production maintenance (click 'Read More')
Otherwise: A world champion IT/DevOps guy won’t save a system that is badly written
🔗 Read More: Make your code production-ready

 5.10. Measure and guard the memory usage
TL;DR: Node.js has controversial relationships with memory: the v8 engine has soft limits on memory usage (1.4GB) and there are known paths to leak memory in Node’s code – thus watching Node’s process memory is a must. In small apps, you may gauge memory periodically using shell commands but in medium-large apps consider baking your memory watch into a robust monitoring system
Otherwise: Your process memory might leak a hundred megabytes a day like how it happened at Walmart
🔗 Read More: Measure and guard the memory usage

 5.11. Get your frontend assets out of Node
TL;DR: Serve frontend content using a specialized infrastructure (nginx, S3, CDN) because Node performance gets hurt when dealing with many static files due to its single-threaded model. One exception to this guideline is when doing server-side rendering
Otherwise: Your single Node thread will be busy streaming hundreds of html/images/angular/react files instead of allocating all its resources for the task it was born for – serving dynamic content
🔗 Read More: Get your frontend assets out of Node

 5.12. Strive to be stateless
TL;DR: Store any type of data (e.g. user sessions, cache, uploaded files) within external data stores. When the app holds data in-process this adds additional layer of maintenance complexity like routing users to the same instance and higher cost of restarting a process. To enforce and encourage a stateless approach, most modern runtime platforms allows 'reapp-ing' instances periodically
Otherwise: Failure at a given server will result in application downtime instead of just killing a faulty machine. Moreover, scaling-out elasticity will get more challenging due to the reliance on a specific server
🔗 Read More: Be stateless, kill your Servers almost every day

 5.13. Use tools that automatically detect vulnerabilities
TL;DR: Even the most reputable dependencies such as Express have known vulnerabilities (from time to time) that can put a system at risk. This can be easily tamed using community and commercial tools that constantly check for vulnerabilities and warn (locally or at GitHub), some can even patch them immediately
Otherwise: Keeping your code clean from vulnerabilities without dedicated tools will require you to constantly follow online publications about new threats. Quite tedious
🔗 Read More: Use tools that automatically detect vulnerabilities

 5.14. Assign a transaction id to each log statement
TL;DR: Assign the same identifier, transaction-id: uuid(), to each log entry within a single request (also known as correlation-id/tracing-id/request-context). Then when inspecting errors in logs, easily conclude what happened before and after. Node has a built-in mechanism, AsyncLocalStorage, for keeping the same context across asynchronous calls. see code examples inside
Otherwise: Looking at a production error log without the context – what happened before – makes it much harder and slower to reason about the issue
🔗 Read More: Assign ‘TransactionId’ to each log statement

 5.15. Set NODE_ENV=production
TL;DR: Set the environment variable NODE_ENV to ‘production’ or ‘development’ to flag whether production optimizations should get activated – some npm packages determine the current environment and optimize their code for production
Otherwise: Omitting this simple property might greatly degrade performance when dealing with some specific libraries like Express server-side rendering
🔗 Read More: Set NODE_ENV=production

 5.16. Design automated, atomic and zero-downtime deployments
TL;DR: Research shows that teams who perform many deployments lower the probability of severe production issues. Fast and automated deployments that don’t require risky manual steps and service downtime significantly improve the deployment process. You should probably achieve this using Docker combined with CI tools as they became the industry standard for streamlined deployment
Otherwise: Long deployments -> production downtime & human-related error -> team unconfident in making deployment -> fewer deployments and features

 5.17. Use an LTS release of Node.js
TL;DR: Ensure you are using an LTS version of Node.js to receive critical bug fixes, security updates and performance improvements
Otherwise: Newly discovered bugs or vulnerabilities could be used to exploit an application running in production, and your application may become unsupported by various modules and harder to maintain
🔗 Read More: Use an LTS release of Node.js

 5.18. Log to stdout, avoid specifying log destination within the app
📝 #updated
TL;DR: Log destinations should not be hard-coded by developers within the application code, but instead should be defined by the execution environment the application runs in. Developers should write logs to stdout using a logger utility and then let the execution environment (container, server, etc.) pipe the stdout stream to the appropriate destination (i.e. Splunk, Graylog, ElasticSearch, etc.).
Otherwise: If developers set the log routing, less flexibility is left for the ops professional who wishes to customize it. Beyond this, if the app tries to log directly to a remote location (e.g., Elastic Search), in case of panic or crash - further logs that might explain the problem won't arrive
🔗 Read More: Log Routing

 5.19. Install your packages with npm ci
TL;DR: Run npm ci to strictly do a clean install of your dependencies matching package.json and package-lock.json. Obviously production code must use the exact version of the packages that were used for testing. While package-lock.json file sets strict version for dependencies, in case of mismatch with the file package.json, the command 'npm install' will treat package.json as the source of truth. On the other hand, the command 'npm ci' will exit with error in case of mismatch between these files
Otherwise: QA will thoroughly test the code and approve a version that will behave differently in production. Even worse, different servers in the same production cluster might run different code.
🔗 Read More: Use npm ci

⬆ Return to top
6. Security Best Practices



 6.1. Embrace linter security rules
 
TL;DR: Make use of security-related linter plugins such as eslint-plugin-security to catch security vulnerabilities and issues as early as possible, preferably while they're being coded. This can help catching security weaknesses like using eval, invoking a child process or importing a module with a string literal (e.g. user input). Click 'Read more' below to see code examples that will get caught by a security linter
Otherwise: What could have been a straightforward security weakness during development becomes a major issue in production. Also, the project may not follow consistent code security practices, leading to vulnerabilities being introduced, or sensitive secrets committed into remote repositories
🔗 Read More: Lint rules

 6.2. Limit concurrent requests using a middleware

TL;DR: DOS attacks are very popular and relatively easy to conduct. Implement rate limiting using an external service such as cloud load balancers, cloud firewalls, nginx, rate-limiter-flexible package, or (for smaller and less critical apps) a rate-limiting middleware (e.g. express-rate-limit)
Otherwise: An application could be subject to an attack resulting in a denial of service where real users receive a degraded or unavailable service.
🔗 Read More: Implement rate limiting

 6.3 Extract secrets from config files or use packages to encrypt them
 
TL;DR: Never store plain-text secrets in configuration files or source code. Instead, make use of secret-management systems like Vault products, Kubernetes/Docker Secrets, or using environment variables. As a last resort, secrets stored in source control must be encrypted and managed (rolling keys, expiring, auditing, etc). Make use of pre-commit/push hooks to prevent committing secrets accidentally
Otherwise: Source control, even for private repositories, can mistakenly be made public, at which point all secrets are exposed. Access to source control for an external party will inadvertently provide access to related systems (databases, apis, services, etc).
🔗 Read More: Secret management

 6.4. Prevent query injection vulnerabilities with ORM/ODM libraries

TL;DR: To prevent SQL/NoSQL injection and other malicious attacks, always make use of an ORM/ODM or a database library that escapes data or supports named or indexed parameterized queries, and takes care of validating user input for expected types. Never just use JavaScript template strings or string concatenation to inject values into queries as this opens your application to a wide spectrum of vulnerabilities. All the reputable Node.js data access libraries (e.g. Sequelize, Knex, mongoose) have built-in protection against injection attacks.
Otherwise: Unvalidated or unsanitized user input could lead to operator injection when working with MongoDB for NoSQL, and not using a proper sanitization system or ORM will easily allow SQL injection attacks, creating a giant vulnerability.
🔗 Read More: Query injection prevention using ORM/ODM libraries

 6.5. Collection of generic security best practices
TL;DR: This is a collection of security advice that is not related directly to Node.js - the Node implementation is not much different than any other language. Click read more to skim through.
🔗 Read More: Common security best practices

 6.6. Adjust the HTTP response headers for enhanced security

TL;DR: Your application should be using secure headers to prevent attackers from using common attacks like cross-site scripting (XSS), clickjacking and other malicious attacks. These can be configured easily using modules like helmet.
Otherwise: Attackers could perform direct attacks on your application's users, leading to huge security vulnerabilities
🔗 Read More: Using secure headers in your application

 6.7. Constantly and automatically inspect for vulnerable dependencies

TL;DR: With the npm ecosystem it is common to have many dependencies for a project. Dependencies should always be kept in check as new vulnerabilities are found. Use tools like npm audit or snyk to track, monitor and patch vulnerable dependencies. Integrate these tools with your CI setup so you catch a vulnerable dependency before it makes it to production.
Otherwise: An attacker could detect your web framework and attack all its known vulnerabilities.
🔗 Read More: Dependency security

 6.8. Protect Users' Passwords/Secrets using bcrypt or scrypt

TL;DR: Passwords or secrets (e.g. API keys) should be stored using a secure hash + salt function like bcrypt,scrypt, or worst case pbkdf2.
Otherwise: Passwords and secrets that are stored without using a secure function are vulnerable to brute forcing and dictionary attacks that will lead to their disclosure eventually.
🔗 Read More: User Passwords

 6.9. Escape HTML, JS and CSS output

TL;DR: Untrusted data that is sent down to the browser might get executed instead of just being displayed, this is commonly referred as a cross-site-scripting (XSS) attack. Mitigate this by using dedicated libraries that explicitly mark the data as pure content that should never get executed (i.e. encoding, escaping)
Otherwise: An attacker might store malicious JavaScript code in your DB which will then be sent as-is to the poor clients
🔗 Read More: Escape output

 6.10. Validate incoming JSON schemas
 
TL;DR: Validate the incoming requests' body payload and ensure it meets expectations, fail fast if it doesn't. To avoid tedious validation coding within each route you may use lightweight JSON-based validation schemas such as jsonschema or joi
Otherwise: Your generosity and permissive approach greatly increases the attack surface and encourages the attacker to try out many inputs until they find some combination to crash the application
🔗 Read More: Validate incoming JSON schemas

 6.11. Support blocklisting JWTs

TL;DR: When using JSON Web Tokens (for example, with Passport.js), by default there's no mechanism to revoke access from issued tokens. Once you discover some malicious user activity, there's no way to stop them from accessing the system as long as they hold a valid token. Mitigate this by implementing a blocklist of untrusted tokens that are validated on each request.
Otherwise: Expired, or misplaced tokens could be used maliciously by a third party to access an application and impersonate the owner of the token.
🔗 Read More: Blocklist JSON Web Tokens

 6.12. Prevent brute-force attacks against authorization

TL;DR: A simple and powerful technique is to limit authorization attempts using two metrics:

The first is number of consecutive failed attempts by the same user unique ID/name and IP address.
The second is number of failed attempts from an IP address over some long period of time. For example, block an IP address if it makes 100 failed attempts in one day.

Otherwise: An attacker can issue unlimited automated password attempts to gain access to privileged accounts on an application
🔗 Read More: Login rate limiting

 6.13. Run Node.js as non-root user

TL;DR: There is a common scenario where Node.js runs as a root user with unlimited permissions. For example, this is the default behaviour in Docker containers. It's recommended to create a non-root user and either bake it into the Docker image (examples given below) or run the process on this user's behalf by invoking the container with the flag "-u username"
Otherwise: An attacker who manages to run a script on the server gets unlimited power over the local machine (e.g. change iptable and re-route traffic to their server)
🔗 Read More: Run Node.js as non-root user

 6.14. Limit payload size using a reverse-proxy or a middleware
 
TL;DR: The bigger the body payload is, the harder your single thread works in processing it. This is an opportunity for attackers to bring servers to their knees without tremendous amount of requests (DOS/DDOS attacks). Mitigate this limiting the body size of incoming requests on the edge (e.g. firewall, ELB) or by configuring express body parser to accept only small-size payloads
Otherwise: Your application will have to deal with large requests, unable to process the other important work it has to accomplish, leading to performance implications and vulnerability towards DOS attacks
🔗 Read More: Limit payload size

 6.15. Avoid JavaScript eval statements
  
TL;DR: eval is evil as it allows executing custom JavaScript code during run time. This is not just a performance concern but also an important security concern due to malicious JavaScript code that may be sourced from user input. Another language feature that should be avoided is new Function constructor. setTimeout and setInterval should never be passed dynamic JavaScript code either.
Otherwise: Malicious JavaScript code finds a way into text passed into eval or other real-time evaluating JavaScript language functions, and will gain complete access to JavaScript permissions on the page. This vulnerability is often manifested as an XSS attack.
🔗 Read More: Avoid JavaScript eval statements

 6.16. Prevent evil RegEx from overloading your single thread execution

TL;DR: Regular Expressions, while being handy, pose a real threat to JavaScript applications at large, and the Node.js platform in particular. A user input for text to match might require an outstanding amount of CPU cycles to process. RegEx processing might be inefficient to an extent that a single request that validates 10 words can block the entire event loop for 6 seconds and set the CPU on 🔥. For that reason, prefer third-party validation packages like validator.js instead of writing your own Regex patterns, or make use of safe-regex to detect vulnerable regex patterns
Otherwise: Poorly written regexes could be susceptible to Regular Expression DoS attacks that will block the event loop completely. For example, the popular moment package was found vulnerable with malicious RegEx usage in November of 2017
🔗 Read More: Prevent malicious RegEx

 6.17. Avoid module loading using a variable
  
TL;DR: Avoid requiring/importing another file with a path that was given as parameter due to the concern that it could have originated from user input. This rule can be extended for accessing files in general (i.e. fs.readFile()) or other sensitive resource access with dynamic variables originating from user input. Eslint-plugin-security linter can catch such patterns and warn early enough
Otherwise: Malicious user input could find its way to a parameter that is used to require tampered files, for example, a previously uploaded file on the file system, or access already existing system files.
🔗 Read More: Safe module loading

 6.18. Run unsafe code in a sandbox
  
TL;DR: When tasked to run external code that is given at run-time (e.g. plugin), use any sort of 'sandbox' execution environment that isolates and guards the main code against the plugin. This can be achieved using a dedicated process (e.g. cluster.fork()), serverless environment or dedicated npm packages that act as a sandbox
Otherwise: A plugin can attack through an endless variety of options like infinite loops, memory overloading, and access to sensitive process environment variables
🔗 Read More: Run unsafe code in a sandbox

 6.19. Take extra care when working with child processes
  
TL;DR: Avoid using child processes when possible and validate and sanitize input to mitigate shell injection attacks if you still have to. Prefer using child_process.execFile which by definition will only execute a single command with a set of attributes and will not allow shell parameter expansion.
Otherwise: Naive use of child processes could result in remote command execution or shell injection attacks due to malicious user input passed to an unsanitized system command.
🔗 Read More: Be cautious when working with child processes

 6.20. Hide error details from clients

TL;DR: An integrated express error handler hides the error details by default. However, great are the chances that you implement your own error handling logic with custom Error objects (considered by many as a best practice). If you do so, ensure not to return the entire Error object to the client, which might contain some sensitive application details
Otherwise: Sensitive application details such as server file paths, third party modules in use, and other internal workflows of the application which could be exploited by an attacker, could be leaked from information found in a stack trace
🔗 Read More: Hide error details from client

 6.21. Configure 2FA for npm or Yarn

TL;DR: Any step in the development chain should be protected with MFA (multi-factor authentication), npm/Yarn are a sweet opportunity for attackers who can get their hands on some developer's password. Using developer credentials, attackers can inject malicious code into libraries that are widely installed across projects and services. Maybe even across the web if published in public. Enabling 2-factor-authentication in npm leaves almost zero chances for attackers to alter your package code.
Otherwise: Have you heard about the eslint developer whose password was hijacked?

 6.22. Modify session middleware settings

TL;DR: Each web framework and technology has its known weaknesses - telling an attacker which web framework we use is a great help for them. Using the default settings for session middlewares can expose your app to module- and framework-specific hijacking attacks in a similar way to the X-Powered-By header. Try hiding anything that identifies and reveals your tech stack (E.g. Node.js, express)
Otherwise: Cookies could be sent over insecure connections, and an attacker might use session identification to identify the underlying framework of the web application, as well as module-specific vulnerabilities
🔗 Read More: Cookie and session security

 6.23. Avoid DOS attacks by explicitly setting when a process should crash

TL;DR: The Node process will crash when errors are not handled. Many best practices even recommend to exit even though an error was caught and got handled. Express, for example, will crash on any asynchronous error - unless you wrap routes with a catch clause. This opens a very sweet attack spot for attackers who recognize what input makes the process crash and repeatedly send the same request. There's no instant remedy for this but a few techniques can mitigate the pain: Alert with critical severity anytime a process crashes due to an unhandled error, validate the input and avoid crashing the process due to invalid user input, wrap all routes with a catch and consider not to crash when an error originated within a request (as opposed to what happens globally)
Otherwise: This is just an educated guess: given many Node.js applications, if we try passing an empty JSON body to all POST requests - a handful of applications will crash. At that point, we can just repeat sending the same request to take down the applications with ease

 6.24. Prevent unsafe redirects

TL;DR: Redirects that do not validate user input can enable attackers to launch phishing scams, steal user credentials, and perform other malicious actions.
Otherwise: If an attacker discovers that you are not validating external, user-supplied input, they may exploit this vulnerability by posting specially-crafted links on forums, social media, and other public places to get users to click it.
🔗 Read More: Prevent unsafe redirects

 6.25. Avoid publishing secrets to the npm registry

TL;DR: Precautions should be taken to avoid the risk of accidentally publishing secrets to public npm registries. An .npmignore file can be used to ignore specific files or folders, or the files array in package.json can act as an allow list.
Otherwise: Your project's API keys, passwords or other secrets are open to be abused by anyone who comes across them, which may result in financial loss, impersonation, and other risks.
🔗 Read More: Avoid publishing secrets

 6.26 Inspect for outdated packages
TL;DR: Use your preferred tool (e.g. npm outdated or npm-check-updates) to detect installed outdated packages, inject this check into your CI pipeline and even make a build fail in a severe scenario. For example, a severe scenario might be when an installed package is 5 patch commits behind (e.g. local version is 1.3.1 and repository version is 1.3.8) or it is tagged as deprecated by its author - kill the build and prevent deploying this version
Otherwise: Your production will run packages that have been explicitly tagged by their author as risky

 6.27. Import built-in modules using the 'node:' protocol
🌟 #new

TL;DR: Import or require built-in Node.js modules using the 'node protocol' syntax:
import { functionName } from "node:module"; // note that 'node:' prefix
For example:
import { createServer } from "node:http";
This style ensures that there is no ambiguity with global npm packages and makes it clear for the reader that the code refers to a well-trusted official module. This style can be enforced with the eslint rule 'prefer-node-protocol'
Otherwise: Using the import syntax without 'node:' prefix opens the door for typosquatting attacks where one could mistakenly mistype a module name (e.g., 'event' instead of 'events) and get a malicious package that was built only to trick users into installing them

⬆ Return to top
7. Draft: Performance Best Practices
Our contributors are working on this section. Would you like to join?

 7.1. Don't block the event loop
TL;DR: Avoid CPU intensive tasks as they will block the mostly single-threaded Event Loop and offload those to a dedicated thread, process or even a different technology based on the context.
Otherwise: As the Event Loop is blocked, Node.js will be unable to handle other request thus causing delays for concurrent users. 3000 users are waiting for a response, the content is ready to be served, but one single request blocks the server from dispatching the results back
🔗 Read More: Do not block the event loop

 7.2. Prefer native JS methods over user-land utils like Lodash
TL;DR: It's often more penalising to use utility libraries like lodash and underscore over native methods as it leads to unneeded dependencies and slower performance.
Bear in mind that with the introduction of the new V8 engine alongside the new ES standards, native methods were improved in such a way that it's now about 50% more performant than utility libraries.
Otherwise: You'll have to maintain less performant projects where you could have simply used what was already available or dealt with a few more lines in exchange of a few more files.
🔗 Read More: Native over user land utils

⬆ Return to top
8. Docker Best Practices
🏅 Many thanks to Bret Fisher from whom we learned many of the following practices

 8.1 Use multi-stage builds for leaner and more secure Docker images
TL;DR: Use multi-stage build to copy only necessary production artifacts. A lot of build-time dependencies and files are not needed for running your application. With multi-stage builds these resources can be used during build while the runtime environment contains only what's necessary. Multi-stage builds are an easy way to get rid of overweight and security threats.
Otherwise: Larger images will take longer to build and ship, build-only tools might contain vulnerabilities and secrets only meant for the build phase might be leaked.
Example Dockerfile for multi-stage builds
FROM node:14.4.0 AS build

COPY . .
RUN npm ci && npm run build


FROM node:slim-14.4.0

USER node
EXPOSE 8080

COPY --from=build /home/node/app/dist /home/node/app/package.json /home/node/app/package-lock.json ./
RUN npm ci --production

CMD [ "node", "dist/app.js" ]
🔗 Read More: Use multi-stage builds

 8.2. Bootstrap using node command, avoid npm start
TL;DR: Use CMD ['node','server.js'] to start your app, avoid using npm scripts which don't pass OS signals to the code. This prevents problems with child-processes, signal handling, graceful shutdown and having zombie processes
Update: Starting from npm 7, npm claim to pass signals. We follow and will update accordingly
Otherwise: When no signals are passed, your code will never be notified about shutdowns. Without this, it will lose its chance to close properly possibly losing current requests and/or data
Read More: Bootstrap container using node command, avoid npm start

 8.3. Let the Docker runtime handle replication and uptime
TL;DR: When using a Docker run time orchestrator (e.g., Kubernetes), invoke the Node.js process directly without intermediate process managers or custom code that replicate the process (e.g. PM2, Cluster module). The runtime platform has the highest amount of data and visibility for making placement decision - It knows best how many processes are needed, how to spread them and what to do in case of crashes
Otherwise: Container keeps crashing due to lack of resources will get restarted indefinitely by the process manager. Should Kubernetes be aware of that, it could relocate it to a different roomy instance
🔗 Read More: Let the Docker orchestrator restart and replicate processes

 8.4. Use .dockerignore to prevent leaking secrets
TL;DR: Include a .dockerignore file that filters out common secret files and development artifacts. By doing so, you might prevent secrets from leaking into the image. As a bonus the build time will significantly decrease. Also, ensure not to copy all files recursively rather explicitly choose what should be copied to Docker
Otherwise: Common personal secret files like .env, .aws and .npmrc will be shared with anybody with access to the image (e.g. Docker repository)
🔗 Read More: Use .dockerignore

 8.5. Clean-up dependencies before production
TL;DR: Although Dev-Dependencies are sometimes needed during the build and test life-cycle, eventually the image that is shipped to production should be minimal and clean from development dependencies. Doing so guarantees that only necessary code is shipped and the amount of potential attacks (i.e. attack surface) is minimized. When using multi-stage build (see dedicated bullet) this can be achieved by installing all dependencies first and finally running npm ci --production
Otherwise: Many of the infamous npm security breaches were found within development packages (e.g. eslint-scope)
🔗 Read More: Remove development dependencies

 8.6. Shutdown smartly and gracefully
TL;DR: Handle the process SIGTERM event and clean-up all existing connection and resources. This should be done while responding to ongoing requests. In Dockerized runtimes, shutting down containers is not a rare event, rather a frequent occurrence that happen as part of routine work. Achieving this demands some thoughtful code to orchestrate several moving parts: The load balancer, keep-alive connections, the HTTP server and other resources
Otherwise: Dying immediately means not responding to thousands of disappointed users
🔗 Read More: Graceful shutdown

 8.7. Set memory limits using both Docker and v8
TL;DR: Always configure a memory limit using both Docker and the JavaScript runtime flags. The Docker limit is needed to make thoughtful container placement decision, the --v8's flag max-old-space is needed to kick off the GC on time and prevent under utilization of memory. Practically, set the v8's old space memory to be a just bit less than the container limit
Otherwise: The docker definition is needed to perform thoughtful scaling decision and prevent starving other citizens. Without also defining the v8's limits, it will under utilize the container resources - Without explicit instructions it crashes when utilizing ~50-60% of its host resources
🔗 Read More: Set memory limits using Docker only

 8.8. Plan for efficient caching
TL;DR: Rebuilding a whole docker image from cache can be nearly instantaneous if done correctly. The less updated instructions should be at the top of your Dockerfile and the ones constantly changing (like app code) should be at the bottom.
Otherwise: Docker build will be very long and consume lot of resources even when making tiny changes
🔗 Read More: Leverage caching to reduce build times

 8.9. Use explicit image reference, avoid latest tag
TL;DR: Specify an explicit image digest or versioned label, never refer to latest. Developers are often led to believe that specifying the latest tag will provide them with the most recent image in the repository however this is not the case. Using a digest guarantees that every instance of the service is running exactly the same code.
In addition, referring to an image tag means that the base image is subject to change, as image tags cannot be relied upon for a deterministic install. Instead, if a deterministic install is expected, a SHA256 digest can be used to reference an exact image.
Otherwise: A new version of a base image could be deployed into production with breaking changes, causing unintended application behaviour.
🔗 Read More: Understand image tags and use the "latest" tag with caution

 8.10. Prefer smaller Docker base images
TL;DR: Large images lead to higher exposure to vulnerabilities and increased resource consumption. Using leaner Docker images, such as Slim and Alpine Linux variants, mitigates this issue.
Otherwise: Building, pushing, and pulling images will take longer, unknown attack vectors can be used by malicious actors and more resources are consumed.
🔗 Read More: Prefer smaller images

 8.11. Clean-out build-time secrets, avoid secrets in args
🌟 #new
TL;DR: Avoid secrets leaking from the Docker build environment. A Docker image is typically shared in multiple environment like CI and a registry that are not as sanitized as production. A typical example is an npm token which is usually passed to a dockerfile as argument. This token stays within the image long after it is needed and allows the attacker indefinite access to a private npm registry. This can be avoided by coping a secret file like .npmrc and then removing it using multi-stage build (beware, build history should be deleted as well) or by using Docker build-kit secret feature which leaves zero traces
Otherwise: Everyone with access to the CI and docker registry will also get access to some precious organization secrets as a bonus
🔗 Read More: Clean-out build-time secrets

 8.12. Scan images for multi layers of vulnerabilities
TL;DR: Besides checking code dependencies vulnerabilities also scan the final image that is shipped to production. Docker image scanners check the code dependencies but also the OS binaries. This E2E security scan covers more ground and verifies that no bad guy injected bad things during the build. Consequently, it is recommended running this as the last step before deployment. There are a handful of free and commercial scanners that also provide CI/CD plugins
Otherwise: Your code might be entirely free from vulnerabilities. However it might still get hacked due to vulnerable version of OS-level binaries (e.g. OpenSSL, TarBall) that are commonly being used by applications
🔗 Read More: Scan the entire image before production

 8.13 Clean NODE_MODULE cache
TL;DR: After installing dependencies in a container remove the local cache. It doesn't make any sense to duplicate the dependencies for faster future installs since there won't be any further installs - A Docker image is immutable. Using a single line of code tens of MB (typically 10-50% of the image size) are shaved off
Otherwise: The image that will get shipped to production will weigh 30% more due to files that will never get used
🔗 Read More: Clean NODE_MODULE cache

 8.14. Generic Docker practices
TL;DR: This is a collection of Docker advice that is not related directly to Node.js - the Node implementation is not much different than any other language. Click read more to skim through.
🔗 Read More: Generic Docker practices

 8.15. Lint your Dockerfile
🌟 #new
TL;DR: Linting your Dockerfile is an important step to identify issues in your Dockerfile which differ from best practices. By checking for potential flaws using a specialised Docker linter, performance and security improvements can be easily identified, saving countless hours of wasted time or security issues in production code.
Otherwise: Mistakenly the Dockerfile creator left Root as the production user, and also used an image from unknown source repository. This could be avoided with with just a simple linter.
🔗 Read More: Lint your Dockerfile

⬆ Return to top
Milestones
To maintain this guide and keep it up to date, we are constantly updating and improving the guidelines and best practices with the help of the community. You can follow our milestones and join the working groups if you want to contribute to this project

Translations
All translations are contributed by the community. We will be happy to get any help with either completed, ongoing or new translations!
Completed translations

 Brazilian Portuguese - Courtesy of Marcelo Melo
 Chinese - Courtesy of Matt Jin
 Russian - Courtesy of Alex Ivanov
 Polish - Courtesy of Michal Biesiada
 Japanese - Courtesy of Yuki Ota, Yuta Azumi
 Basque - Courtesy of Ane Diaz de Tuesta & Joxefe Diaz de Tuesta

Translations in progress

 French (Discussion)
 Hebrew (Discussion)
 Korean - Courtesy of Sangbeom Han (Discussion)
 Spanish (Discussion)
 Turkish (Discussion)


Steering Committee
Meet the steering committee members - the people who work together to provide guidance and future direction to the project. In addition, each member of the committee leads a project tracked under our GitHub projects.

Yoni Goldberg


Independent Node.js consultant who works with customers in the USA, Europe, and Israel on building large-scale Node.js applications. Many of the best practices above were first published at goldbergyoni.com. Reach Yoni at @goldbergyoni or me@goldbergyoni.com


Josh Hemphill



Full Stack Software Engineer / Developer specializing in Security, DevOps/DevSecOps, and ERP Integrations.


Raz Luvaton


Full Stack Developer who knows how to exit from Vim and loves Architecture, Virtualization and Security.

Contributing
If you've ever wanted to contribute to open source, now is your chance! See the contributing docs for more information.
Contributors ✨
Thanks goes to these wonderful people who have contributed to this repository!




  
    
      Kevin Rambaud🖋
      Michael Fine🖋
      Shreya Dahal🖋
      Matheus Cruz Rocha🖋
      Yog Mehta🖋
      Kudakwashe Paradzayi🖋
      t1st3🖋
    
    
      mulijordan1976🖋
      Matan Kushner🖋
      Fabio Hiroki🖋
      James Sumners🖋
      Dan Gamble🖋
      PJ Trainor🖋
      Remek Ambroziak🖋
    
    
      Yoni Jah🖋
      Misha Khokhlov🖋
      Evgeny Orekhov🖋
      -🖋
      Isaac Halvorson🖋
      Vedran Karačić🖋
      lallenlowe🖋
    
    
      Nathan Wells🖋
      Paulo Reis🖋
      syzer🖋
      David Sancho🖋
      Robert Manolea🖋
      Xavier Ho🖋
      Aaron🖋
    
    
      Jan Charles Maghirang Adona🖋
      Allen🖋
      Leonardo Villela🖋
      Michał Załęcki🖋
      Chris Nicola🖋
      Alejandro Corredor🖋
      cwar🖋
    
    
      Yuwei🖋
      Utkarsh Bhatt🖋
      Duarte Mendes🖋
      Jason Kim🖋
      Mitja O.🖋
      Sandro Miguel Marques🖋
      Gabe🖋
    
    
      Ron Gross🖋
      Valeri Karpov🖋
      Sergio Bernal🖋
      Nikola Telkedzhiev🖋
      Vitor Godoy🖋
      Manish Saraan🖋
      Sangbeom Han🖋
    
    
      blackmatch🖋
      Joe Reeve🖋
      Ryan Busby🖋
      Iman Mohamadi🖋
      Sergii Paryzhskyi🖋
      Kapil Patel🖋
      迷渡🖋
    
    
      Hozefa🖋
      Ethan🖋
      Sam🖋
      Arlind🖋
      Teddy Toussaint🖋
      Lewis🖋
      Gabriel Lidenor 🖋
    
    
      Roman🖋
      Francozeira🖋
      Invvard🖋
      Rômulo Garofalo🖋
      Tho Q Luong🖋
      Burak Shen🖋
      Martin Muzatko🖋
    
    
      Jared Collier🖋
      Hilton Meyer🖋
      ChangJoo Park(박창주)🖋
      Masahiro Sakaguchi🖋
      Keith Holliday🖋
      coreyc🖋
      Maximilian Berkmann🖋
    
    
      Douglas Mariano Valero🖋
      Marcelo Melo🖋
      Mehmet Perk🖋
      ryan ouyang🖋
      Shabeer🖋
      Eduard Kyvenko🖋
      Deyvison Rocha🖋
    
    
      George Mamer🖋
      Konstantinos Leimonis🖋
      Oliver Lluberes🌍
      Tien Do🖋
      Ranvir Singh🖋
      Vadim Nicolaev🖋 🌍
      German Gamboa Gonzalez🖋
    
    
      Hafez🖋
      Chandiran🖋
      VinayaSathyanarayana🖋
      Kim Kern🖋
      Kenneth Freitas🖋
      songe🖋
      Kirill Shekhovtsov🖋
    
    
      Serge🖋
      keyrwinz🖋
      Dmitry Nikitenko🖋
      bushuai👀 🖋
      Benjamin Gruenbaum🖋
      Ezequiel🌍
      Juan José Rodríguez🌍
    
    
      Or Bin🖋
      Andreo Vieira🖋
      Michael Solomon🖋
      Jimmy Callin🖋
      Siddharth🖋
      Ryan Smith🖋
      Tom Boettger🖋
    
    
      Joaquín Ormaechea🌍
      dfrzuz🌍
      Victor Homyakov🖋
      Josh🖋 🛡️
      Alec Francis🖋
      arjun6610🖋
      Jan Osch🖋
    
    
      Thiago Rotondo Sampaio🌍
      Alexsey🖋
      Luis A. Acurero🌍
      Lucas Romano🌍
      Denise Case🖋
      Nick Ribal🖋 👀
      0xflotus🖋
    
    
      Jonathan Chen🖋
      Dilan Srilal🖋
      vladthelittleone🌍
      Nik Osvalds🖋
      Daniel Kiss📖
      Forresst🖋
      Jonathan Svenheden🖋
    
    
      AustrisC🖋
      kyeongtae kim🌍
      007🖋
      Ane Diaz de Tuesta🌍 🖋
      YukiOta🌍
      Frazer Smith🖋
      Raz Luvaton🖋
    
    
      Yuta Azumi🖋
      andrewjbarbour🖋
      mr🖋
      Aleksandar🖋
      Owl🖋
      Yedidya Schwartz🖋 💡
      ari🖋
    
    
      Thomas König🖋
      Kalle Lämsä🖋
      Wyatt🖋
      KHADIR Tayeb🖋
      Shankar Regmi🖋
      Shubham🖋
      Lucas Alves🖋
    
    
      Benjamin🖋
      Yeoh Joer🖋
      Miigon🖋
      Rostislav Bogorad🖋
      Flouse🖋
      Tarantini Pereira🖋
      Kazuki Matsuo🖋
    
    
      Adam Smith🖋
      Dohyeon Ko🖋
      Vladislav Legkov🖋
      Kerollos Magdy🖋
      Erez Lieberman🖋
      Breno Macedo🖋
      Fernando Flores🌍
    
    
      Rafael Brito🌍
      Emiliano Peralta🌍
      Shin, SJ🖋
      Benjamin Forster🖋
      Daniele Fedeli🖋
      djob195🖋
      antspk🖋
    
    
      정진영🖋
      kkk-cashwalk🖋
      apainintheneck🖋
      Fajar Budhi Iswanda🖋
      이주호🖋
      Singh🖋
      Alex Dumitru🖋
    
    
      Anton Lykhatskyi🖋
      sangwonlee🖋
      Eugenio Berretta🖋
      soranakk🖋
      고준영🖋 💻
      Guilherme Portella 🖋
      André Esser🖋
    
    
      Scc🌍
      Mauro Accornero🖋
      no-yan🖋
      hodbauer🌍
    
  




Steering Committee Emeriti
Bruno Scheufler

💻 full-stack web engineer, Node.js & GraphQL enthusiast


Kyle Martin


Full Stack Developer & Site Reliability Engineer based in New Zealand, interested in web application security, and architecting and building Node.js applications to perform at global scale.


Kevyn Bruyere

Independent full-stack developer with a taste for Ops and automation.


Sagir Khan



Deep specialist in JavaScript and its ecosystem — React, Node.js, TypeScript, GraphQL, MongoDB, pretty much anything that involves JS/JSON in any layer of the system — building products using the web platform for the world’s most recognized brands. Individual Member of the Node.js Foundation.\n\ngoldbergyoni
    
    /
    
      nodebestpractices
    

    Public
  


        

        
            
    
      

  
                Notifications
    You must be signed in to change notification settings

  

  
              Fork
    10.4k

  

  
        
            
          Star
          102k

  



        
      

        
      
      
        ✅ The Node.js best practices list (July 2024)
      
      
        
        
          twitter.com/nodepractices/
        
      

    
      License
  
    
      
     CC-BY-SA-4.0 license
    
  


    
        
          
          102k
          stars
        
          
          10.4k
          forks
        
          
          Branches
        
          
          Tags
        
          
          Activity
    

      
        
            
            
          Star


        
        
                    Notifications
    You must be signed in to change notification settings

        
        
          

        
      
  




          

  
      
  
    
              
        Code
          


    

      
  
    
              
        Issues
          44


    

      
  
    
              
        Pull requests
          36


    

      
  
    
              
        Actions
          


    

      
  
    
              
        Projects
          0


    

      
  
    
              
        Security
          

    

      
  
    
              
        Insights
          


    


          
  
      
Additional navigation options



  
    
                
  
    
        
    
    
    
        
          
        
      
        
          Code
      

  

        
    
    
    
        
          
        
      
        
          Issues
      

  

        
    
    
    
        
          
        
      
        
          Pull requests
      

  

        
    
    
    
        
          
        
      
        
          Actions
      

  

        
    
    
    
        
          
        
      
        
          Projects
      

  

        
    
    
    
        
          
        
      
        
          Security
      

  

        
    
    
    
        
          
        
      
        
          Insights
      

  

    




      
  



  

  




    
    



    
      
  goldbergyoni/nodebestpractices
  
    

  
        












  
  
      masterBranchesTagsGo to fileCodeFolders and filesNameNameLast commit messageLast commit dateLatest commit History3,916 Commits.github.github  .operations.operations  assetsassets  sectionssections  .all-contributorsrc.all-contributorsrc  .gitignore.gitignore  LICENSELICENSE  README.basque.mdREADME.basque.md  README.brazilian-portuguese.mdREADME.brazilian-portuguese.md  README.chinese.mdREADME.chinese.md  README.french.mdREADME.french.md  README.hebrew.mdREADME.hebrew.md  README.indonesian.mdREADME.indonesian.md  README.japanese.mdREADME.japanese.md  README.korean.mdREADME.korean.md  README.mdREADME.md  README.polish.mdREADME.polish.md  README.russian.mdREADME.russian.md  package.jsonpackage.json  View all filesRepository files navigationREADMECC-BY-SA-4.0 licenseNode.js Best Practices

  



    


 Follow us on Twitter! @nodepractices

Read in a different language: CN, FR, BR, RU, PL, JA, EU (ES, HE, KR and TR in progress! )

🎊 2024 edition is here!


🛰 Modernized to 2024: Tons of text edits, new recommended libraries, and some new best practices


✨ Easily focus on new content: Already visited before? Search for #new or #updated tags for new content only


🔖 Curious to see examples? We have a starter: Visit Practica.js, our application example and boilerplate (beta) to see some practices in action



Welcome! 3 Things You Ought To Know First
1. You are reading dozens of the best Node.js articles - this repository is a summary and curation of the top-ranked content on Node.js best practices, as well as content written here by collaborators
2. It is the largest compilation, and it is growing every week - currently, more than 80 best practices, style guides, and architectural tips are presented. New issues and pull requests are created every day to keep this live book updated. We'd love to see you contributing here, whether that is fixing code mistakes, helping with translations, or suggesting brilliant new ideas. See our writing guidelines here
3. Best practices have additional info - most bullets include a 🔗Read More link that expands on the practice with code examples, quotes from selected blogs, and more information

By Yoni Goldberg
Learn with me: As a consultant, I engage with worldwide teams on various activities like workshops and code reviews. 🎉AND... Hold on, I've just launched my beyond-the-basics testing course, which is on a 🎁 limited-time sale until August 7th

Table of Contents

  
    1. Project Architecture Practices (6)
  
  1.1 Structure your solution by components #strategic #updated
  1.2 Layer your components, keep the web layer within its boundaries #strategic #updated
  1.3 Wrap common utilities as packages, consider publishing
  1.4 Use environment aware, secure and hierarchical config #updated
  1.5 Consider all the consequences when choosing the main framework #new
  1.6 Use TypeScript sparingly and thoughtfully #new


  
    2. Error Handling Practices (12)
  
  2.1 Use Async-Await or promises for async error handling
  2.2 Extend the built-in Error object #strategic #updated
  2.3 Distinguish operational vs programmer errors #strategic #updated
  2.4 Handle errors centrally, not within a middleware #strategic
  2.5 Document API errors using OpenAPI or GraphQL
  2.6 Exit the process gracefully when a stranger comes to town #strategic
  2.7 Use a mature logger to increase errors visibility #updated
  2.8 Test error flows using your favorite test framework #updated
  2.9 Discover errors and downtime using APM products
  2.10 Catch unhandled promise rejections #updated
  2.11 Fail fast, validate arguments using a dedicated library
  2.12 Always await promises before returning to avoid a partial stacktrace #new
  2.13 Subscribe to event emitters 'error' event #new


  
    3. Code Style Practices (12)
  
  3.1 Use ESLint #strategic
  3.2 Use Node.js eslint extension plugins #updated
  3.3 Start a Codeblock's Curly Braces on the Same Line
  3.4 Separate your statements properly
  3.5 Name your functions
  3.6 Use naming conventions for variables, constants, functions and classes
  3.7 Prefer const over let. Ditch the var
  3.8 Require modules first, not inside functions
  3.9 Set an explicit entry point to a module/folder #updated
  3.10 Use the === operator
  3.11 Use Async Await, avoid callbacks #strategic
  3.12 Use arrow function expressions (=>)
  3.13 Avoid effects outside of functions #new


  
    4. Testing And Overall Quality Practices (13)
  
  4.1 At the very least, write API (component) testing #strategic
  4.2 Include 3 parts in each test name #new
  4.3 Structure tests by the AAA pattern #strategic
  4.4 Ensure Node version is unified #new
  4.5 Avoid global test fixtures and seeds, add data per-test #strategic
  4.6 Tag your tests #advanced
  4.7 Check your test coverage, it helps to identify wrong test patterns
  4.8 Use production-like environment for e2e testing
  4.9 Refactor regularly using static analysis tools
  4.10 Mock responses of external HTTP services #advanced #new #advanced
  4.11 Test your middlewares in isolation
  4.12 Specify a port in production, randomize in testing #new
  4.13 Test the five possible outcomes #strategic #new


  
    5. Going To Production Practices (19)
  
  5.1. Monitoring #strategic
  5.2. Increase the observability using smart logging #strategic
  5.3. Delegate anything possible (e.g. gzip, SSL) to a reverse proxy #strategic
  5.4. Lock dependencies
  5.5. Guard process uptime using the right tool
  5.6. Utilize all CPU cores
  5.7. Create a ‘maintenance endpoint’
  5.8. Discover the unknowns using APM products #advanced #updated
  5.9. Make your code production-ready
  5.10. Measure and guard the memory usage #advanced
  5.11. Get your frontend assets out of Node
  5.12. Strive to be stateless #strategic
  5.13. Use tools that automatically detect vulnerabilities
  5.14. Assign a transaction id to each log statement #advanced
  5.15. Set NODE_ENV=production
  5.16. Design automated, atomic and zero-downtime deployments #advanced
  5.17. Use an LTS release of Node.js
  5.18. Log to stdout, avoid specifying log destination within the app #updated
  5.19. Install your packages with npm ci #new


  
    6. Security Practices (25)
  
  6.1. Embrace linter security rules
  6.2. Limit concurrent requests using a middleware
  6.3 Extract secrets from config files or use packages to encrypt them #strategic
  6.4. Prevent query injection vulnerabilities with ORM/ODM libraries #strategic
  6.5. Collection of generic security best practices
  6.6. Adjust the HTTP response headers for enhanced security
  6.7. Constantly and automatically inspect for vulnerable dependencies #strategic
  6.8. Protect Users' Passwords/Secrets using bcrypt or scrypt #strategic
  6.9. Escape HTML, JS and CSS output
  6.10. Validate incoming JSON schemas #strategic
  6.11. Support blocklisting JWTs
  6.12. Prevent brute-force attacks against authorization #advanced
  6.13. Run Node.js as non-root user
  6.14. Limit payload size using a reverse-proxy or a middleware
  6.15. Avoid JavaScript eval statements
  6.16. Prevent evil RegEx from overloading your single thread execution
  6.17. Avoid module loading using a variable
  6.18. Run unsafe code in a sandbox
  6.19. Take extra care when working with child processes #advanced
  6.20. Hide error details from clients
  6.21. Configure 2FA for npm or Yarn #strategic
  6.22. Modify session middleware settings
  6.23. Avoid DOS attacks by explicitly setting when a process should crash #advanced
  6.24. Prevent unsafe redirects
  6.25. Avoid publishing secrets to the npm registry
  6.26. 6.26 Inspect for outdated packages
  6.27. Import built-in modules using the 'node:' protocol #new


  
    7. Performance Practices (2) (Work In Progress️ ✍️)
  
  7.1. Don't block the event loop
  7.2. Prefer native JS methods over user-land utils like Lodash


  
    8. Docker Practices (15)
  
  8.1 Use multi-stage builds for leaner and more secure Docker images #strategic
  8.2. Bootstrap using node command, avoid npm start
  8.3. Let the Docker runtime handle replication and uptime #strategic
  8.4. Use .dockerignore to prevent leaking secrets
  8.5. Clean-up dependencies before production
  8.6. Shutdown smartly and gracefully #advanced
  8.7. Set memory limits using both Docker and v8 #advanced #strategic
  8.8. Plan for efficient caching
  8.9. Use explicit image reference, avoid latest tag
  8.10. Prefer smaller Docker base images
  8.11. Clean-out build-time secrets, avoid secrets in args #strategic #new
  8.12. Scan images for multi layers of vulnerabilities #advanced
  8.13 Clean NODE_MODULE cache
  8.14. Generic Docker practices
  8.15. Lint your Dockerfile #new


1. Project Architecture Practices
 1.1 Structure your solution by business components
📝 #updated
TL;DR: The root of a system should contain folders or repositories that represent reasonably sized business modules. Each component represents a product domain (i.e., bounded context), like 'user-component', 'order-component', etc. Each component has its own API, logic, and logical database. What is the significant merit? With an autonomous component, every change is performed over a granular and smaller scope - the mental overload, development friction, and deployment fear are much smaller and better. As a result, developers can move much faster. This does not necessarily demand physical separation and can be achieved using a Monorepo or with a multi-repo
my-system
├─ apps (components)
│  ├─ orders
│  ├─ users
│  ├─ payments
├─ libraries (generic cross-component functionality)
│  ├─ logger
│  ├─ authenticator
Otherwise: when artifacts from various modules/topics are mixed together, there are great chances of a tightly-coupled 'spaghetti' system. For example, in an architecture where 'module-a controller' might call 'module-b service', there are no clear modularity borders - every code change might affect anything else. With this approach, developers who code new features struggle to realize the scope and impact of their change. Consequently, they fear breaking other modules, and each deployment becomes slower and riskier
🔗 Read More: structure by components

 1.2 Layer your components with 3-tiers, keep the web layer within its boundaries
📝 #updated
TL;DR: Each component should contain 'layers' - a dedicated folder for common concerns: 'entry-point' where controller lives, 'domain' where the logic lives, and 'data-access'. The primary principle of the most popular architectures is to separate the technical concerns (e.g., HTTP, DB, etc) from the pure logic of the app so a developer can code more features without worrying about infrastructural concerns. Putting each concern in a dedicated folder, also known as the 3-Tier pattern, is the simplest way to meet this goal
my-system
├─ apps (components)
│  ├─ component-a
   │  ├─ entry-points
   │  │  ├─ api # controller comes here
   │  │  ├─ message-queue # message consumer comes here
   │  ├─ domain # features and flows: DTO, services, logic
   │  ├─ data-access # DB calls w/o ORM
Otherwise: It's often seen that developer pass web objects like request/response to functions in the domain/logic layer - this violates the separation principle and makes it harder to access later the logic code by other clients like testing code, scheduled jobs, message queues, etc
🔗 Read More: layer your app

 1.3 Wrap common utilities as packages, consider publishing
TL;DR: Place all reusable modules in a dedicated folder, e.g., "libraries", and underneath each module in its own folder, e.g., "/libraries/logger". Make the module an independent package with its own package.json file to increase the module encapsulation, and allows future publishing to a repository. In a Monorepo setup, modules can be consumed by 'npm linking' to their physical paths, using ts-paths or by publishing and installing from a package manager repository like the npm registry
my-system
├─ apps (components)
  │  ├─ component-a
├─ libraries (generic cross-component functionality)
│  ├─ logger
│  │  ├─ package.json
│  │  ├─ src
│  │  │ ├─ index.js

Otherwise: Clients of a module might import and get coupled to internal functionality of a module. With a package.json at the root, one can set a package.json.main or package.json.exports to explicitly tell which files and functions are part of the public interface
🔗 Read More: Structure by feature

 1.4 Use environment aware, secure and hierarchical config
📝 #updated
TL;DR: A flawless configuration setup should ensure (a) keys can be read from file AND from environment variable (b) secrets are kept outside committed code (c) config is hierarchical for easier findability (d) typing support (e) validation for failing fast (f) Specify default for each key. There are a few packages that can help tick most of those boxes like convict, env-var, zod, and others
Otherwise: Consider a mandatory environment variable that wasn't provided. The app starts successfully and serve requests, some information is already persisted to DB. Then, it's realized that without this mandatory key the request can't complete, leaving the app in a dirty state
🔗 Read More: configuration best practices

 1.5 Consider all the consequences when choosing the main framework
🌟 #new
TL;DR: When building apps and APIs, using a framework is mandatory. It's easy to overlook alternative frameworks or important considerations and then finally land on a sub optimal option. As of 2023/2024, we believe that these four frameworks are worth considering: Nest.js, Fastify, express, and Koa. Click read more below for a detailed pros/cons of each framework. Simplistically, we believe that Nest.js is the best match for teams who wish to go OOP and/or build large-scale apps that can't get partitioned into smaller autonomous components. Fastify is our recommendation for apps with reasonably-sized components (e.g., Microservices) that are built around simple Node.js mechanics. Read our full considerations guide here
Otherwise: Due to the overwhelming amount of considerations, it's easy to make decisions based on partial information and compare apples with oranges. For example, it's believed that Fastify is a minimal web-server that should get compared with express only. In reality, it's a rich framework with many official plugins that cover many concerns
🔗 Read More: Choosing the right framework
 1.6 Use TypeScript sparingly and thoughtfully
🌟 #new
TL;DR: Coding without type safety is no longer an option, TypeScript is the most popular option for this mission. Use it to define variables and functions return types. With that, it is also a double edge sword that can greatly encourage complexity with its additional ~ 50 keywords and sophisticated features. Consider using it sparingly, mostly with simple types, and utilize advanced features only when a real need arises
Otherwise: Researches show that using TypeScript can help in detecting ~20% bugs earlier. Without it, also the developer experience in the IDE is intolerable. On the flip side, 80% of other bugs were not discovered using types. Consequently, typed syntax is valuable but limited. Only efficient tests can discover the whole spectrum of bugs, including type-related bugs. It might also defeat its purpose: sophisticated code features are likely to increase the code complexity, which by itself increases both the amount of bugs and the average bug fix time
🔗 Read More: TypeScript considerations

⬆ Return to top
2. Error Handling Practices
 2.1 Use Async-Await or promises for async error handling
TL;DR: Handling async errors in callback style is probably the fastest way to hell (a.k.a the pyramid of doom). The best gift you can give to your code is using Promises with async-await which enables a much more compact and familiar code syntax like try-catch
Otherwise: Node.js callback style, function(err, response), is a promising way to un-maintainable code due to the mix of error handling with casual code, excessive nesting, and awkward coding patterns
🔗 Read More: avoiding callbacks

 2.2 Extend the built-in Error object
📝 #updated
TL;DR: Some libraries throw errors as a string or as some custom type – this complicates the error handling logic and the interoperability between modules. Instead, create app error object/class that extends the built-in Error object and use it whenever rejecting, throwing or emitting an error. The app error should add useful imperative properties like the error name/code and isCatastrophic. By doing so, all errors have a unified structure and support better error handling. There is no-throw-literal ESLint rule that strictly checks that (although it has some limitations which can be solved when using TypeScript and setting the @typescript-eslint/no-throw-literal rule)
Otherwise: When invoking some component, being uncertain which type of errors come in return – it makes proper error handling much harder. Even worse, using custom types to describe errors might lead to loss of critical error information like the stack trace!
🔗 Read More: using the built-in error object

 2.3 Distinguish catastrophic errors from operational errors
📝 #updated
TL;DR: Operational errors (e.g. API received an invalid input) refer to known cases where the error impact is fully understood and can be handled thoughtfully. On the other hand, catastrophic error (also known as programmer errors) refers to unusual code failures that dictate to gracefully restart the application
Otherwise: You may always restart the application when an error appears, but why let ~5000 online users down because of a minor, predicted, operational error? The opposite is also not ideal – keeping the application up when an unknown catastrophic issue (programmer error) occurred might lead to an unpredicted behavior. Differentiating the two allows acting tactfully and applying a balanced approach based on the given context
🔗 Read More: operational vs programmer error

 2.4 Handle errors centrally, not within a middleware
TL;DR: Error handling logic such as logging, deciding whether to crash and monitoring metrics should be encapsulated in a dedicated and centralized object that all entry-points (e.g. APIs, cron jobs, scheduled jobs) call when an error comes in
Otherwise: Not handling errors within a single place will lead to code duplication and probably to improperly handled errors
🔗 Read More: handling errors in a centralized place

 2.5 Document API errors using OpenAPI or GraphQL
TL;DR: Let your API callers know which errors might come in return so they can handle these thoughtfully without crashing. For RESTful APIs, this is usually done with documentation frameworks like OpenAPI. If you're using GraphQL, you can utilize your schema and comments as well
Otherwise: An API client might decide to crash and restart only because it received back an error it couldn’t understand. Note: the caller of your API might be you (very typical in a microservice environment)
🔗 Read More: documenting API errors in Swagger or GraphQL

 2.6 Exit the process gracefully when a stranger comes to town
TL;DR: When an unknown error occurs (catastrophic error, see best practice 2.3) - there is uncertainty about the application healthiness. In this case, there is no escape from making the error observable, shutting off connections and exiting the process. Any reputable runtime framework like Dockerized services or cloud serverless solutions will take care to restart
Otherwise: When an unfamiliar exception occurs, some object might be in a faulty state (e.g. an event emitter which is used globally and not firing events anymore due to some internal failure) and all future requests might fail or behave crazily
🔗 Read More: shutting the process

 2.7 Use a mature logger to increase errors visibility
📝 #updated
TL;DR: A robust logging tools like Pino or Winston increases the errors visibility using features like log-levels, pretty print coloring and more. Console.log lacks these imperative features and should be avoided. The best in class logger allows attaching custom useful properties to log entries with minimized serialization performance penalty. Developers should write logs to stdout and let the infrastructure pipe the stream to the appropriate log aggregator
Otherwise: Skimming through console.logs or manually through messy text file without querying tools or a decent log viewer might keep you busy at work until late
🔗 Read More: using a mature logger

 2.8 Test error flows using your favorite test framework
📝 #updated
TL;DR: Whether professional automated QA or plain manual developer testing – Ensure that your code not only satisfies positive scenarios but also handles and returns the right errors. On top of this, simulate deeper error flows like uncaught exceptions and ensure that the error handler treat these properly (see code examples within the "read more" section)
Otherwise: Without testing, whether automatically or manually, you can’t rely on your code to return the right errors. Without meaningful errors – there’s no error handling
🔗 Read More: testing error flows

 2.9 Discover errors and downtime using APM products
TL;DR: Monitoring and performance products (a.k.a APM) proactively gauge your codebase or API so they can automagically highlight errors, crashes, and slow parts that you were missing
Otherwise: You might spend great effort on measuring API performance and downtimes, probably you’ll never be aware which are your slowest code parts under real-world scenario and how these affect the UX
🔗 Read More: using APM products

 2.10 Catch unhandled promise rejections
📝 #updated
TL;DR: Any exception thrown within a promise will get swallowed and discarded unless a developer didn’t forget to explicitly handle it. Even if your code is subscribed to process.uncaughtException! Overcome this by registering to the event process.unhandledRejection
Otherwise: Your errors will get swallowed and leave no trace. Nothing to worry about
🔗 Read More: catching unhandled promise rejection

 2.11 Fail fast, validate arguments using a dedicated library
TL;DR: Assert API input to avoid nasty bugs that are much harder to track later. The validation code is usually tedious unless you are using a modern validation library like ajv, zod, or typebox
Otherwise: Consider this – your function expects a numeric argument “Discount” which the caller forgets to pass, later on, your code checks if Discount!=0 (amount of allowed discount is greater than zero), then it will allow the user to enjoy a discount. OMG, what a nasty bug. Can you see it?
🔗 Read More: failing fast

 2.12 Always await promises before returning to avoid a partial stacktrace
🌟 #new
TL;DR: Always do return await when returning a promise to benefit full error stacktrace. If a
function returns a promise, that function must be declared as async function and explicitly
await the promise before returning it
Otherwise: The function that returns a promise without awaiting won't appear in the stacktrace.
Such missing frames would probably complicate the understanding of the flow that leads to the error,
especially if the cause of the abnormal behavior is inside of the missing function
🔗 Read More: returning promises

 2.13 Subscribe to event emitters and streams 'error' event
🌟 #new
TL;DR: Unlike typical functions, a try-catch clause won't get errors that originate from Event Emitters and anything inherited from it (e.g., streams). Instead of try-catch, subscribe to an event emitter's 'error' event so your code can handle the error in context. When dealing with EventTargets (the web standard version of Event Emitters) there are no 'error' event and all errors end in the process.on('error) global event - in this case, at least ensure that the process crash or not based on the desired context. Also, mind that error originating from asynchronous event handlers are not get caught unless the event emitter is initialized with {captureRejections: true}
Otherwise: Event emitters are commonly used for global and key application functionality such as DB or message queue connection. When this kind of crucial objects throw an error, at best the process will crash due to unhandled exception. Even worst, it will stay alive as a zombie while a key functionality is turned off

⬆ Return to top
3. Code Patterns And Style Practices
 3.1 Use ESLint
TL;DR: ESLint is the de-facto standard for checking possible code errors and fixing code style, not only to identify nitty-gritty spacing issues but also to detect serious code anti-patterns like developers throwing errors without classification. Though ESLint can automatically fix code styles, other tools like prettier are more powerful in formatting the fix and work in conjunction with ESLint
Otherwise: Developers will focus on tedious spacing and line-width concerns and time might be wasted overthinking the project's code style
🔗 Read More: Using ESLint and Prettier

 3.2 Use Node.js eslint extension plugins
📝 #updated
TL;DR: On top of ESLint standard rules that cover vanilla JavaScript, add Node.js specific plugins like eslint-plugin-node, eslint-plugin-mocha and eslint-plugin-node-security, eslint-plugin-require, /eslint-plugin-jest and other useful rules
Otherwise: Many faulty Node.js code patterns might escape under the radar. For example, developers might require(variableAsPath) files with a variable given as a path which allows attackers to execute any JS script. Node.js linters can detect such patterns and complain early

 3.3 Start a Codeblock's Curly Braces on the Same Line
TL;DR: The opening curly braces of a code block should be on the same line as the opening statement
Code Example
// Do
function someFunction() {
  // code block
}

// Avoid
function someFunction()
{
  // code block
}
Otherwise: Deferring from this best practice might lead to unexpected results, as seen in the StackOverflow thread below:
🔗 Read more: "Why do results vary based on curly brace placement?" (StackOverflow)

 3.4 Separate your statements properly
No matter if you use semicolons or not to separate your statements, knowing the common pitfalls of improper linebreaks or automatic semicolon insertion, will help you to eliminate regular syntax errors.
TL;DR: Use ESLint to gain awareness about separation concerns. Prettier or Standardjs can automatically resolve these issues.
Otherwise: As seen in the previous section, JavaScript's interpreter automatically adds a semicolon at the end of a statement if there isn't one, or considers a statement as not ended where it should, which might lead to some undesired results. You can use assignments and avoid using immediately invoked function expressions to prevent most of the unexpected errors.
Code example
// Do
function doThing() {
    // ...
}

doThing()

// Do

const items = [1, 2, 3]
items.forEach(console.log)

// Avoid — throws exception
const m = new Map()
const a = [1,2,3]
[...m.values()].forEach(console.log)
> [...m.values()].forEach(console.log)
>  ^^^
> SyntaxError: Unexpected token ...

// Avoid — throws exception
const count = 2 // it tries to run 2(), but 2 is not a function
(function doSomething() {
  // do something amazing
}())
// put a semicolon before the immediate invoked function, after the const definition, save the return value of the anonymous function to a variable or avoid IIFEs altogether
🔗 Read more: "Semi ESLint rule"
🔗 Read more: "No unexpected multiline ESLint rule"

 3.5 Name your functions
TL;DR: Name all functions, including closures and callbacks. Avoid anonymous functions. This is especially useful when profiling a node app. Naming all functions will allow you to easily understand what you're looking at when checking a memory snapshot
Otherwise: Debugging production issues using a core dump (memory snapshot) might become challenging as you notice significant memory consumption from anonymous functions

 3.6 Use naming conventions for variables, constants, functions and classes
TL;DR: Use lowerCamelCase when naming constants, variables and functions, UpperCamelCase (capital first letter as well) when naming classes and UPPER_SNAKE_CASE when naming global or static variables. This will help you to easily distinguish between plain variables, functions, classes that require instantiation and variables declared at global module scope. Use descriptive names, but try to keep them short
Otherwise: JavaScript is the only language in the world that allows invoking a constructor ("Class") directly without instantiating it first. Consequently, Classes and function-constructors are differentiated by starting with UpperCamelCase
3.6 Code Example
// for global variables names we use the const/let keyword and UPPER_SNAKE_CASE
let MUTABLE_GLOBAL = "mutable value";
const GLOBAL_CONSTANT = "immutable value";
const CONFIG = {
  key: "value",
};

// examples of UPPER_SNAKE_CASE convention in nodejs/javascript ecosystem
// in javascript Math.PI module
const PI = 3.141592653589793;

// https://github.com/nodejs/node/blob/b9f36062d7b5c5039498e98d2f2c180dca2a7065/lib/internal/http2/core.js#L303
// in nodejs http2 module
const HTTP_STATUS_OK = 200;
const HTTP_STATUS_CREATED = 201;

// for class name we use UpperCamelCase
class SomeClassExample {
  // for static class properties we use UPPER_SNAKE_CASE
  static STATIC_PROPERTY = "value";
}

// for functions names we use lowerCamelCase
function doSomething() {
  // for scoped variable names we use the const/let keyword and lowerCamelCase
  const someConstExample = "immutable value";
  let someMutableExample = "mutable value";
}

 3.7 Prefer const over let. Ditch the var
TL;DR: Using const means that once a variable is assigned, it cannot be reassigned. Preferring const will help you to not be tempted to use the same variable for different uses, and make your code clearer. If a variable needs to be reassigned, in a for loop, for example, use let to declare it. Another important aspect of let is that a variable declared using it is only available in the block scope in which it was defined. var is function scoped, not block-scoped, and shouldn't be used in ES6 now that you have const and let at your disposal
Otherwise: Debugging becomes way more cumbersome when following a variable that frequently changes
🔗 Read more: JavaScript ES6+: var, let, or const? 

 3.8 Require modules first, not inside functions
TL;DR: Require modules at the beginning of each file, before and outside of any functions. This simple best practice will not only help you easily and quickly tell the dependencies of a file right at the top but also avoids a couple of potential problems
Otherwise: Requires are run synchronously by Node.js. If they are called from within a function, it may block other requests from being handled at a more critical time. Also, if a required module or any of its dependencies throw an error and crash the server, it is best to find out about it as soon as possible, which might not be the case if that module is required from within a function

 3.9 Set an explicit entry point to a module/folder
📝 #updated
TL;DR: When developing a module/library, set an explicit root file that exports the public and interesting code. Discourage the client code from importing deep files and becoming familiar with the internal structure. With commonjs (require), this can be done with an index.js file at the folder's root or the package.json.main field. With ESM (import), if a package.json exists on the root, the field "exports" allow specifying the module's root file. If no package.json exists, you may put an index.js file on the root which re-exports all the public functionality
Otherwise: Having an explicit root file acts like a public 'interface' that encapsulates the internal, directs the caller to the public code and facilitates future changes without breaking the contract
3.9 Code example - avoid coupling the client to the module structure
// Avoid: client has deep familiarity with the internals

// Client code
const SMSWithMedia = require("./SMSProvider/providers/media/media-provider.js");

// Better: explicitly export the public functions

//index.js, module code
module.exports.SMSWithMedia = require("./SMSProvider/providers/media/media-provider.js");

// Client code
const { SMSWithMedia } = require("./SMSProvider");

 3.10 Use the === operator
TL;DR: Prefer the strict equality operator === over the weaker abstract equality operator ==. == will compare two variables after converting them to a common type. There is no type conversion in ===, and both variables must be of the same type to be equal
Otherwise: Unequal variables might return true when compared with the == operator
3.10 Code example
"" == "0"; // false
0 == ""; // true
0 == "0"; // true

false == "false"; // false
false == "0"; // true

false == undefined; // false
false == null; // false
null == undefined; // true

" \t\r\n " == 0; // true
All statements above will return false if used with ===

 3.11 Use Async Await, avoid callbacks
TL;DR: Async-await is the simplest way to express an asynchronous flow as it makes asynchronous code look synchronous. Async-await will also result in much more compact code and support for try-catch. This technique now supersedes callbacks and promises in most cases. Using it in your code is probably the best gift one can give to the code reader
Otherwise: Handling async errors in callback style are probably the fastest way to hell - this style forces to check errors all over, deal with awkward code nesting, and makes it difficult to reason about the code flow
🔗Read more: Guide to async-await 1.0

 3.12 Use arrow function expressions (=>)
TL;DR: Though it's recommended to use async-await and avoid function parameters when dealing with older APIs that accept promises or callbacks - arrow functions make the code structure more compact and keep the lexical context of the root function (i.e. this)
Otherwise: Longer code (in ES5 functions) is more prone to bugs and cumbersome to read
🔗 Read more: It’s Time to Embrace Arrow Functions

 3.13 Avoid effects outside of functions
🌟 #new
TL;DR: Avoid putting code with effects like network or DB calls outside of functions. Such a code will be executed immediately when another file requires the file. This 'floating' code might get executed when the underlying system is not ready yet. It also comes with a performance penalty even when this module's functions will finally not be used in runtime. Last, mocking these DB/network calls for testing is harder outside of functions. Instead, put this code inside functions that should get called explicitly. If some DB/network code must get executed right when the module loads, consider using the factory or revealing module patterns
Otherwise: A typical web framework sets error handler, environment variables and monitoring. When DB/network calls are made before the web framework is initialized, they won't be monitored or fail due to a lack of configuration data

⬆ Return to top
4. Testing And Overall Quality Practices
_We have dedicated guides for testing, see below. The best practices list here is a brief summary of these guides
a. JavaScript testing best practices
b. Node.js testing - beyond the basics
_
 4.1 At the very least, write API (component) testing
TL;DR: Most projects just don't have any automated testing due to short timetables or often the 'testing project' ran out of control and was abandoned. For that reason, prioritize and start with API testing which is the easiest way to write and provides more coverage than unit testing (you may even craft API tests without code using tools like Postman). Afterwards, should you have more resources and time, continue with advanced test types like unit testing, DB testing, performance testing, etc
Otherwise: You may spend long days on writing unit tests to find out that you got only 20% system coverage

 4.2 Include 3 parts in each test name
🌟 #new
TL;DR: Make the test speak at the requirements level so it's self-explanatory also to QA engineers and developers who are not familiar with the code internals. State in the test name what is being tested (unit under test), under what circumstances, and what is the expected result
Otherwise: A deployment just failed, a test named “Add product” failed. Does this tell you what exactly is malfunctioning?
🔗 Read More: Include 3 parts in each test name

 4.3 Structure tests by the AAA pattern
🌟 #new
TL;DR: Structure your tests with 3 well-separated sections: Arrange, Act & Assert (AAA). The first part includes the test setup, then the execution of the unit under test, and finally the assertion phase. Following this structure guarantees that the reader spends no brain CPU on understanding the test plan
Otherwise: Not only you spend long daily hours on understanding the main code, but now also what should have been the simple part of the day (testing) stretches your brain
🔗 Read More: Structure tests by the AAA pattern

 4.4 Ensure Node version is unified
🌟 #new
TL;DR: Use tools that encourage or enforce the same Node.js version across different environments and developers. Tools like nvm, and Volta allow specifying the project's version in a file so each team member can run a single command to conform with the project's version. Optionally, this definition can be replicated to CI and the production runtime (e.g., copy the specified value to .Dockerfile build and to the CI declaration file)
Otherwise: A developer might face or miss an error because she uses a different Node.js version than her teammates. Even worse - the production runtime might be different than the environment where tests were executed

 4.5 Avoid global test fixtures and seeds, add data per-test
TL;DR: To prevent test coupling and easily reason about the test flow, each test should add and act on its own set of DB rows. Whenever a test needs to pull or assume the existence of some DB data - it must explicitly add that data and avoid mutating any other records
Otherwise: Consider a scenario where deployment is aborted due to failing tests, team is now going to spend precious investigation time that ends in a sad conclusion: the system works well, the tests however interfere with each other and break the build
🔗 Read More: Avoid global test fixtures

 4.6 Tag your tests
TL;DR: Different tests must run on different scenarios: quick smoke, IO-less, tests should run when a developer saves or commits a file, full end-to-end tests usually run when a new pull request is submitted, etc. This can be achieved by tagging tests with keywords like #cold #api #sanity so you can grep with your testing harness and invoke the desired subset. For example, this is how you would invoke only the sanity test group with Mocha: mocha --grep 'sanity'
Otherwise: Running all the tests, including tests that perform dozens of DB queries, any time a developer makes a small change can be extremely slow and keeps developers away from running tests

 4.7 Check your test coverage, it helps to identify wrong test patterns
TL;DR: Code coverage tools like Istanbul/NYC are great for 3 reasons: it comes for free (no effort is required to benefit this reports), it helps to identify a decrease in testing coverage, and last but not least it highlights testing mismatches: by looking at colored code coverage reports you may notice, for example, code areas that are never tested like catch clauses (meaning that tests only invoke the happy paths and not how the app behaves on errors). Set it to fail builds if the coverage falls under a certain threshold
Otherwise: There won't be any automated metric telling you when a large portion of your code is not covered by testing

 4.8 Use production-like environment for e2e testing
TL;DR: End to end (e2e) testing which includes live data used to be the weakest link of the CI process as it depends on multiple heavy services like DB. Use an environment which is as close to your real production environment as possible like a-continue (Missed -continue here, needs content. Judging by the Otherwise clause, this should mention docker-compose)
Otherwise: Without docker-compose, teams must maintain a testing DB for each testing environment including developers' machines, keep all those DBs in sync so test results won't vary across environments

 4.9 Refactor regularly using static analysis tools
TL;DR: Using static analysis tools helps by giving objective ways to improve code quality and keeps your code maintainable. You can add static analysis tools to your CI build to fail when it finds code smells. Its main selling points over plain linting are the ability to inspect quality in the context of multiple files (e.g. detect duplications), perform advanced analysis (e.g. code complexity), and follow the history and progress of code issues. Two examples of tools you can use are Sonarqube (2,600+ stars) and Code Climate (1,500+ stars).
Otherwise: With poor code quality, bugs and performance will always be an issue that no shiny new library or state of the art features can fix
🔗 Read More: Refactoring!

 4.10 Mock responses of external HTTP services
🌟 #new
TL;DR: Use network mocking tools to simulate responses of external collaborators' services that are approached over the network (e.g., REST, Graph). This is imperative not only to isolate the component under test but mostly to simulate non-happy path flows. Tools like nock (in-process) or Mock-Server allow defining a specific response of external service in a single line of code. Remember to simulate also errors, delays, timeouts, and any other event that is likely to happen in production
Otherwise: Allowing your component to reach real external services instances will likely result in naive tests that mostly cover happy paths. The tests might also be flaky and slow
🔗 Read More: Mock external services
 4.11 Test your middlewares in isolation
TL;DR: When a middleware holds some immense logic that spans many requests, it is worth testing it in isolation without waking up the entire web framework. This can be easily achieved by stubbing and spying on the {req, res, next} objects
Otherwise: A bug in Express middleware === a bug in all or most requests
🔗 Read More: Test middlewares in isolation
 4.12 Specify a port in production, randomize in testing
🌟 #new
TL;DR: When testing against the API, it's common and desirable to initialize the web server inside the tests. Let the server randomize the web server port in testing to prevent collisions. If you're using Node.js http server (used by most frameworks), doing so demands nothing but passing a port number zero - this will randomize an available port
Otherwise: Specifying a fixed port will prevent two testing processes from running at the same time. Most of the modern test runners run with multiple processes by default
🔗 Read More: Randomize a port for testing
 4.13 Test the five possible outcomes
🌟 #new
TL;DR: When testing a flow, ensure to cover five potential categories. Any time some action is triggered (e.g., API call), a reaction occurs, a meaningful outcome is produced and calls for testing. There are five possible outcome types for every flow: a response, a visible state change (e.g., DB), an outgoing API call, a new message in a queue, and an observability call (e.g., logging, metric). See a checklist here. Each type of outcome comes with unique challenges and techniques to mitigate those challenges - we have a dedicated guide about this topic: Node.js testing - beyond the basics
Otherwise: Consider a case when testing the addition of a new product to the system. It's common to see tests that assert on a valid response only. What if the product was failed to persist regardless of the positive response? what if when adding a new product demands calling some external service, or putting a message in the queue - shouldn't the test assert these outcomes as well? It's easy to overlook various paths, this is where a checklist comes handy
🔗 Read More: Test five outcomes

⬆ Return to top
5. Going To Production Practices
 5.1. Monitoring
TL;DR: Monitoring is a game of finding out issues before customers do – obviously this should be assigned unprecedented importance. The market is overwhelmed with offers thus consider starting with defining the basic metrics you must follow (my suggestions inside), then go over additional fancy features and choose the solution that ticks all boxes. In any case, the 4 layers of observability must be covered: uptime, metrics with focus on user-facing symptoms and Node.js technical metrics like event loop lag, distributed flows measurement with Open Telemetry and logging. Click ‘Read More’ below for an overview of the solutions
Otherwise: Failure === disappointed customers. Simple
🔗 Read More: Monitoring!

 5.2. Increase the observability using smart logging
TL;DR: Logs can be a dumb warehouse of debug statements or the enabler of a beautiful dashboard that tells the story of your app. Plan your logging platform from day 1: how logs are collected, stored and analyzed to ensure that the desired information (e.g. error rate, following an entire transaction through services and servers, etc) can really be extracted
Otherwise: You end up with a black box that is hard to reason about, then you start re-writing all logging statements to add additional information
🔗 Read More: Increase transparency using smart logging

 5.3. Delegate anything possible (e.g. gzip, SSL) to a reverse proxy
TL;DR: Node is quite bad at doing CPU intensive tasks like gzipping, SSL termination, etc. You should use specialized infrastructure like nginx, HAproxy or cloud vendor services instead
Otherwise: Your poor single thread will stay busy doing infrastructural tasks instead of dealing with your application core and performance will degrade accordingly
🔗 Read More: Delegate anything possible (e.g. gzip, SSL) to a reverse proxy

 5.4. Lock dependencies
TL;DR: Your code must be identical across all environments, but without a special lockfile npm lets dependencies drift across environments. Ensure to commit your package-lock.json so all the environments will be identical
Otherwise: QA will thoroughly test the code and approve a version that will behave differently in production. Even worse, different servers in the same production cluster might run different code
🔗 Read More: Lock dependencies

 5.5. Guard process uptime using the right tool
TL;DR: The process must go on and get restarted upon failures. Modern runtime platforms like Docker-ized platforms (e.g. Kubernetes), and Serverless take care for this automatically. When the app is hosted on a bare metal server, one must take care for a process management tools like systemd. Avoid including a custom process management tool in a modern platform that monitors an app instance (e.g., Kubernetes) - doing so will hide failures from the infrastructure. When the underlying infrastructure is not aware of errors, it can't perform useful mitigation steps like re-placing the instance in a different location
Otherwise: Running dozens of instances without a clear strategy and too many tools together (cluster management, docker, PM2) might lead to DevOps chaos
🔗 Read More: Guard process uptime using the right tool

 5.6. Utilize all CPU cores
TL;DR: At its basic form, a Node app runs on a single CPU core while all others are left idling. It’s your duty to replicate the Node process and utilize all CPUs. Most of the modern run-times platform (e.g., Kubernetes) allow replicating instances of the app but they won't verify that all cores are utilized - this is your duty. If the app is hosted on a bare server, it's also your duty to use some process replication solution (e.g. systemd)
Otherwise: Your app will likely utilize only 25% of its available resources(!) or even less. Note that a typical server has 4 CPU cores or more, naive deployment of Node.js utilizes only 1 (even using PaaS services like AWS beanstalk!)
🔗 Read More: Utilize all CPU cores

 5.7. Create a ‘maintenance endpoint’
TL;DR: Expose a set of system-related information, like memory usage and REPL, etc in a secured API. Although it’s highly recommended to rely on standard and battle-tested tools, some valuable information and operations are easier done using code
Otherwise: You’ll find that you’re performing many “diagnostic deploys” – shipping code to production only to extract some information for diagnostic purposes
🔗 Read More: Create a ‘maintenance endpoint’

 5.8. Discover the unknowns using APM products
📝 #updated
TL;DR: Consider adding another safety layer to the production stack - APM. While the majority of symptoms and causes can be detected using traditional monitoring techniques, in a distributed system there is more than meets the eye. Application monitoring and performance products (a.k.a. APM) can auto-magically go beyond traditional monitoring and provide additional layer of discovery and developer-experience. For example, some APM products can highlight a transaction that loads too slow on the end-user's side while suggesting the root cause. APMs also provide more context for developers who try to troubleshoot a log error by showing what was the server busy with when the error occurred. To name a few example
Otherwise: You might spend great effort on measuring API performance and downtimes, probably you’ll never be aware which is your slowest code parts under real-world scenario and how these affect the UX
🔗 Read More: Discover errors and downtime using APM products

 5.9. Make your code production-ready
TL;DR: Code with the end in mind, plan for production from day 1. This sounds a bit vague so I’ve compiled a few development tips that are closely related to production maintenance (click 'Read More')
Otherwise: A world champion IT/DevOps guy won’t save a system that is badly written
🔗 Read More: Make your code production-ready

 5.10. Measure and guard the memory usage
TL;DR: Node.js has controversial relationships with memory: the v8 engine has soft limits on memory usage (1.4GB) and there are known paths to leak memory in Node’s code – thus watching Node’s process memory is a must. In small apps, you may gauge memory periodically using shell commands but in medium-large apps consider baking your memory watch into a robust monitoring system
Otherwise: Your process memory might leak a hundred megabytes a day like how it happened at Walmart
🔗 Read More: Measure and guard the memory usage

 5.11. Get your frontend assets out of Node
TL;DR: Serve frontend content using a specialized infrastructure (nginx, S3, CDN) because Node performance gets hurt when dealing with many static files due to its single-threaded model. One exception to this guideline is when doing server-side rendering
Otherwise: Your single Node thread will be busy streaming hundreds of html/images/angular/react files instead of allocating all its resources for the task it was born for – serving dynamic content
🔗 Read More: Get your frontend assets out of Node

 5.12. Strive to be stateless
TL;DR: Store any type of data (e.g. user sessions, cache, uploaded files) within external data stores. When the app holds data in-process this adds additional layer of maintenance complexity like routing users to the same instance and higher cost of restarting a process. To enforce and encourage a stateless approach, most modern runtime platforms allows 'reapp-ing' instances periodically
Otherwise: Failure at a given server will result in application downtime instead of just killing a faulty machine. Moreover, scaling-out elasticity will get more challenging due to the reliance on a specific server
🔗 Read More: Be stateless, kill your Servers almost every day

 5.13. Use tools that automatically detect vulnerabilities
TL;DR: Even the most reputable dependencies such as Express have known vulnerabilities (from time to time) that can put a system at risk. This can be easily tamed using community and commercial tools that constantly check for vulnerabilities and warn (locally or at GitHub), some can even patch them immediately
Otherwise: Keeping your code clean from vulnerabilities without dedicated tools will require you to constantly follow online publications about new threats. Quite tedious
🔗 Read More: Use tools that automatically detect vulnerabilities

 5.14. Assign a transaction id to each log statement
TL;DR: Assign the same identifier, transaction-id: uuid(), to each log entry within a single request (also known as correlation-id/tracing-id/request-context). Then when inspecting errors in logs, easily conclude what happened before and after. Node has a built-in mechanism, AsyncLocalStorage, for keeping the same context across asynchronous calls. see code examples inside
Otherwise: Looking at a production error log without the context – what happened before – makes it much harder and slower to reason about the issue
🔗 Read More: Assign ‘TransactionId’ to each log statement

 5.15. Set NODE_ENV=production
TL;DR: Set the environment variable NODE_ENV to ‘production’ or ‘development’ to flag whether production optimizations should get activated – some npm packages determine the current environment and optimize their code for production
Otherwise: Omitting this simple property might greatly degrade performance when dealing with some specific libraries like Express server-side rendering
🔗 Read More: Set NODE_ENV=production

 5.16. Design automated, atomic and zero-downtime deployments
TL;DR: Research shows that teams who perform many deployments lower the probability of severe production issues. Fast and automated deployments that don’t require risky manual steps and service downtime significantly improve the deployment process. You should probably achieve this using Docker combined with CI tools as they became the industry standard for streamlined deployment
Otherwise: Long deployments -> production downtime & human-related error -> team unconfident in making deployment -> fewer deployments and features

 5.17. Use an LTS release of Node.js
TL;DR: Ensure you are using an LTS version of Node.js to receive critical bug fixes, security updates and performance improvements
Otherwise: Newly discovered bugs or vulnerabilities could be used to exploit an application running in production, and your application may become unsupported by various modules and harder to maintain
🔗 Read More: Use an LTS release of Node.js

 5.18. Log to stdout, avoid specifying log destination within the app
📝 #updated
TL;DR: Log destinations should not be hard-coded by developers within the application code, but instead should be defined by the execution environment the application runs in. Developers should write logs to stdout using a logger utility and then let the execution environment (container, server, etc.) pipe the stdout stream to the appropriate destination (i.e. Splunk, Graylog, ElasticSearch, etc.).
Otherwise: If developers set the log routing, less flexibility is left for the ops professional who wishes to customize it. Beyond this, if the app tries to log directly to a remote location (e.g., Elastic Search), in case of panic or crash - further logs that might explain the problem won't arrive
🔗 Read More: Log Routing

 5.19. Install your packages with npm ci
TL;DR: Run npm ci to strictly do a clean install of your dependencies matching package.json and package-lock.json. Obviously production code must use the exact version of the packages that were used for testing. While package-lock.json file sets strict version for dependencies, in case of mismatch with the file package.json, the command 'npm install' will treat package.json as the source of truth. On the other hand, the command 'npm ci' will exit with error in case of mismatch between these files
Otherwise: QA will thoroughly test the code and approve a version that will behave differently in production. Even worse, different servers in the same production cluster might run different code.
🔗 Read More: Use npm ci

⬆ Return to top
6. Security Best Practices



 6.1. Embrace linter security rules
 
TL;DR: Make use of security-related linter plugins such as eslint-plugin-security to catch security vulnerabilities and issues as early as possible, preferably while they're being coded. This can help catching security weaknesses like using eval, invoking a child process or importing a module with a string literal (e.g. user input). Click 'Read more' below to see code examples that will get caught by a security linter
Otherwise: What could have been a straightforward security weakness during development becomes a major issue in production. Also, the project may not follow consistent code security practices, leading to vulnerabilities being introduced, or sensitive secrets committed into remote repositories
🔗 Read More: Lint rules

 6.2. Limit concurrent requests using a middleware

TL;DR: DOS attacks are very popular and relatively easy to conduct. Implement rate limiting using an external service such as cloud load balancers, cloud firewalls, nginx, rate-limiter-flexible package, or (for smaller and less critical apps) a rate-limiting middleware (e.g. express-rate-limit)
Otherwise: An application could be subject to an attack resulting in a denial of service where real users receive a degraded or unavailable service.
🔗 Read More: Implement rate limiting

 6.3 Extract secrets from config files or use packages to encrypt them
 
TL;DR: Never store plain-text secrets in configuration files or source code. Instead, make use of secret-management systems like Vault products, Kubernetes/Docker Secrets, or using environment variables. As a last resort, secrets stored in source control must be encrypted and managed (rolling keys, expiring, auditing, etc). Make use of pre-commit/push hooks to prevent committing secrets accidentally
Otherwise: Source control, even for private repositories, can mistakenly be made public, at which point all secrets are exposed. Access to source control for an external party will inadvertently provide access to related systems (databases, apis, services, etc).
🔗 Read More: Secret management

 6.4. Prevent query injection vulnerabilities with ORM/ODM libraries

TL;DR: To prevent SQL/NoSQL injection and other malicious attacks, always make use of an ORM/ODM or a database library that escapes data or supports named or indexed parameterized queries, and takes care of validating user input for expected types. Never just use JavaScript template strings or string concatenation to inject values into queries as this opens your application to a wide spectrum of vulnerabilities. All the reputable Node.js data access libraries (e.g. Sequelize, Knex, mongoose) have built-in protection against injection attacks.
Otherwise: Unvalidated or unsanitized user input could lead to operator injection when working with MongoDB for NoSQL, and not using a proper sanitization system or ORM will easily allow SQL injection attacks, creating a giant vulnerability.
🔗 Read More: Query injection prevention using ORM/ODM libraries

 6.5. Collection of generic security best practices
TL;DR: This is a collection of security advice that is not related directly to Node.js - the Node implementation is not much different than any other language. Click read more to skim through.
🔗 Read More: Common security best practices

 6.6. Adjust the HTTP response headers for enhanced security

TL;DR: Your application should be using secure headers to prevent attackers from using common attacks like cross-site scripting (XSS), clickjacking and other malicious attacks. These can be configured easily using modules like helmet.
Otherwise: Attackers could perform direct attacks on your application's users, leading to huge security vulnerabilities
🔗 Read More: Using secure headers in your application

 6.7. Constantly and automatically inspect for vulnerable dependencies

TL;DR: With the npm ecosystem it is common to have many dependencies for a project. Dependencies should always be kept in check as new vulnerabilities are found. Use tools like npm audit or snyk to track, monitor and patch vulnerable dependencies. Integrate these tools with your CI setup so you catch a vulnerable dependency before it makes it to production.
Otherwise: An attacker could detect your web framework and attack all its known vulnerabilities.
🔗 Read More: Dependency security

 6.8. Protect Users' Passwords/Secrets using bcrypt or scrypt

TL;DR: Passwords or secrets (e.g. API keys) should be stored using a secure hash + salt function like bcrypt,scrypt, or worst case pbkdf2.
Otherwise: Passwords and secrets that are stored without using a secure function are vulnerable to brute forcing and dictionary attacks that will lead to their disclosure eventually.
🔗 Read More: User Passwords

 6.9. Escape HTML, JS and CSS output

TL;DR: Untrusted data that is sent down to the browser might get executed instead of just being displayed, this is commonly referred as a cross-site-scripting (XSS) attack. Mitigate this by using dedicated libraries that explicitly mark the data as pure content that should never get executed (i.e. encoding, escaping)
Otherwise: An attacker might store malicious JavaScript code in your DB which will then be sent as-is to the poor clients
🔗 Read More: Escape output

 6.10. Validate incoming JSON schemas
 
TL;DR: Validate the incoming requests' body payload and ensure it meets expectations, fail fast if it doesn't. To avoid tedious validation coding within each route you may use lightweight JSON-based validation schemas such as jsonschema or joi
Otherwise: Your generosity and permissive approach greatly increases the attack surface and encourages the attacker to try out many inputs until they find some combination to crash the application
🔗 Read More: Validate incoming JSON schemas

 6.11. Support blocklisting JWTs

TL;DR: When using JSON Web Tokens (for example, with Passport.js), by default there's no mechanism to revoke access from issued tokens. Once you discover some malicious user activity, there's no way to stop them from accessing the system as long as they hold a valid token. Mitigate this by implementing a blocklist of untrusted tokens that are validated on each request.
Otherwise: Expired, or misplaced tokens could be used maliciously by a third party to access an application and impersonate the owner of the token.
🔗 Read More: Blocklist JSON Web Tokens

 6.12. Prevent brute-force attacks against authorization

TL;DR: A simple and powerful technique is to limit authorization attempts using two metrics:

The first is number of consecutive failed attempts by the same user unique ID/name and IP address.
The second is number of failed attempts from an IP address over some long period of time. For example, block an IP address if it makes 100 failed attempts in one day.

Otherwise: An attacker can issue unlimited automated password attempts to gain access to privileged accounts on an application
🔗 Read More: Login rate limiting

 6.13. Run Node.js as non-root user

TL;DR: There is a common scenario where Node.js runs as a root user with unlimited permissions. For example, this is the default behaviour in Docker containers. It's recommended to create a non-root user and either bake it into the Docker image (examples given below) or run the process on this user's behalf by invoking the container with the flag "-u username"
Otherwise: An attacker who manages to run a script on the server gets unlimited power over the local machine (e.g. change iptable and re-route traffic to their server)
🔗 Read More: Run Node.js as non-root user

 6.14. Limit payload size using a reverse-proxy or a middleware
 
TL;DR: The bigger the body payload is, the harder your single thread works in processing it. This is an opportunity for attackers to bring servers to their knees without tremendous amount of requests (DOS/DDOS attacks). Mitigate this limiting the body size of incoming requests on the edge (e.g. firewall, ELB) or by configuring express body parser to accept only small-size payloads
Otherwise: Your application will have to deal with large requests, unable to process the other important work it has to accomplish, leading to performance implications and vulnerability towards DOS attacks
🔗 Read More: Limit payload size

 6.15. Avoid JavaScript eval statements
  
TL;DR: eval is evil as it allows executing custom JavaScript code during run time. This is not just a performance concern but also an important security concern due to malicious JavaScript code that may be sourced from user input. Another language feature that should be avoided is new Function constructor. setTimeout and setInterval should never be passed dynamic JavaScript code either.
Otherwise: Malicious JavaScript code finds a way into text passed into eval or other real-time evaluating JavaScript language functions, and will gain complete access to JavaScript permissions on the page. This vulnerability is often manifested as an XSS attack.
🔗 Read More: Avoid JavaScript eval statements

 6.16. Prevent evil RegEx from overloading your single thread execution

TL;DR: Regular Expressions, while being handy, pose a real threat to JavaScript applications at large, and the Node.js platform in particular. A user input for text to match might require an outstanding amount of CPU cycles to process. RegEx processing might be inefficient to an extent that a single request that validates 10 words can block the entire event loop for 6 seconds and set the CPU on 🔥. For that reason, prefer third-party validation packages like validator.js instead of writing your own Regex patterns, or make use of safe-regex to detect vulnerable regex patterns
Otherwise: Poorly written regexes could be susceptible to Regular Expression DoS attacks that will block the event loop completely. For example, the popular moment package was found vulnerable with malicious RegEx usage in November of 2017
🔗 Read More: Prevent malicious RegEx

 6.17. Avoid module loading using a variable
  
TL;DR: Avoid requiring/importing another file with a path that was given as parameter due to the concern that it could have originated from user input. This rule can be extended for accessing files in general (i.e. fs.readFile()) or other sensitive resource access with dynamic variables originating from user input. Eslint-plugin-security linter can catch such patterns and warn early enough
Otherwise: Malicious user input could find its way to a parameter that is used to require tampered files, for example, a previously uploaded file on the file system, or access already existing system files.
🔗 Read More: Safe module loading

 6.18. Run unsafe code in a sandbox
  
TL;DR: When tasked to run external code that is given at run-time (e.g. plugin), use any sort of 'sandbox' execution environment that isolates and guards the main code against the plugin. This can be achieved using a dedicated process (e.g. cluster.fork()), serverless environment or dedicated npm packages that act as a sandbox
Otherwise: A plugin can attack through an endless variety of options like infinite loops, memory overloading, and access to sensitive process environment variables
🔗 Read More: Run unsafe code in a sandbox

 6.19. Take extra care when working with child processes
  
TL;DR: Avoid using child processes when possible and validate and sanitize input to mitigate shell injection attacks if you still have to. Prefer using child_process.execFile which by definition will only execute a single command with a set of attributes and will not allow shell parameter expansion.
Otherwise: Naive use of child processes could result in remote command execution or shell injection attacks due to malicious user input passed to an unsanitized system command.
🔗 Read More: Be cautious when working with child processes

 6.20. Hide error details from clients

TL;DR: An integrated express error handler hides the error details by default. However, great are the chances that you implement your own error handling logic with custom Error objects (considered by many as a best practice). If you do so, ensure not to return the entire Error object to the client, which might contain some sensitive application details
Otherwise: Sensitive application details such as server file paths, third party modules in use, and other internal workflows of the application which could be exploited by an attacker, could be leaked from information found in a stack trace
🔗 Read More: Hide error details from client

 6.21. Configure 2FA for npm or Yarn

TL;DR: Any step in the development chain should be protected with MFA (multi-factor authentication), npm/Yarn are a sweet opportunity for attackers who can get their hands on some developer's password. Using developer credentials, attackers can inject malicious code into libraries that are widely installed across projects and services. Maybe even across the web if published in public. Enabling 2-factor-authentication in npm leaves almost zero chances for attackers to alter your package code.
Otherwise: Have you heard about the eslint developer whose password was hijacked?

 6.22. Modify session middleware settings

TL;DR: Each web framework and technology has its known weaknesses - telling an attacker which web framework we use is a great help for them. Using the default settings for session middlewares can expose your app to module- and framework-specific hijacking attacks in a similar way to the X-Powered-By header. Try hiding anything that identifies and reveals your tech stack (E.g. Node.js, express)
Otherwise: Cookies could be sent over insecure connections, and an attacker might use session identification to identify the underlying framework of the web application, as well as module-specific vulnerabilities
🔗 Read More: Cookie and session security

 6.23. Avoid DOS attacks by explicitly setting when a process should crash

TL;DR: The Node process will crash when errors are not handled. Many best practices even recommend to exit even though an error was caught and got handled. Express, for example, will crash on any asynchronous error - unless you wrap routes with a catch clause. This opens a very sweet attack spot for attackers who recognize what input makes the process crash and repeatedly send the same request. There's no instant remedy for this but a few techniques can mitigate the pain: Alert with critical severity anytime a process crashes due to an unhandled error, validate the input and avoid crashing the process due to invalid user input, wrap all routes with a catch and consider not to crash when an error originated within a request (as opposed to what happens globally)
Otherwise: This is just an educated guess: given many Node.js applications, if we try passing an empty JSON body to all POST requests - a handful of applications will crash. At that point, we can just repeat sending the same request to take down the applications with ease

 6.24. Prevent unsafe redirects

TL;DR: Redirects that do not validate user input can enable attackers to launch phishing scams, steal user credentials, and perform other malicious actions.
Otherwise: If an attacker discovers that you are not validating external, user-supplied input, they may exploit this vulnerability by posting specially-crafted links on forums, social media, and other public places to get users to click it.
🔗 Read More: Prevent unsafe redirects

 6.25. Avoid publishing secrets to the npm registry

TL;DR: Precautions should be taken to avoid the risk of accidentally publishing secrets to public npm registries. An .npmignore file can be used to ignore specific files or folders, or the files array in package.json can act as an allow list.
Otherwise: Your project's API keys, passwords or other secrets are open to be abused by anyone who comes across them, which may result in financial loss, impersonation, and other risks.
🔗 Read More: Avoid publishing secrets

 6.26 Inspect for outdated packages
TL;DR: Use your preferred tool (e.g. npm outdated or npm-check-updates) to detect installed outdated packages, inject this check into your CI pipeline and even make a build fail in a severe scenario. For example, a severe scenario might be when an installed package is 5 patch commits behind (e.g. local version is 1.3.1 and repository version is 1.3.8) or it is tagged as deprecated by its author - kill the build and prevent deploying this version
Otherwise: Your production will run packages that have been explicitly tagged by their author as risky

 6.27. Import built-in modules using the 'node:' protocol
🌟 #new

TL;DR: Import or require built-in Node.js modules using the 'node protocol' syntax:
import { functionName } from "node:module"; // note that 'node:' prefix
For example:
import { createServer } from "node:http";
This style ensures that there is no ambiguity with global npm packages and makes it clear for the reader that the code refers to a well-trusted official module. This style can be enforced with the eslint rule 'prefer-node-protocol'
Otherwise: Using the import syntax without 'node:' prefix opens the door for typosquatting attacks where one could mistakenly mistype a module name (e.g., 'event' instead of 'events) and get a malicious package that was built only to trick users into installing them

⬆ Return to top
7. Draft: Performance Best Practices
Our contributors are working on this section. Would you like to join?

 7.1. Don't block the event loop
TL;DR: Avoid CPU intensive tasks as they will block the mostly single-threaded Event Loop and offload those to a dedicated thread, process or even a different technology based on the context.
Otherwise: As the Event Loop is blocked, Node.js will be unable to handle other request thus causing delays for concurrent users. 3000 users are waiting for a response, the content is ready to be served, but one single request blocks the server from dispatching the results back
🔗 Read More: Do not block the event loop

 7.2. Prefer native JS methods over user-land utils like Lodash
TL;DR: It's often more penalising to use utility libraries like lodash and underscore over native methods as it leads to unneeded dependencies and slower performance.
Bear in mind that with the introduction of the new V8 engine alongside the new ES standards, native methods were improved in such a way that it's now about 50% more performant than utility libraries.
Otherwise: You'll have to maintain less performant projects where you could have simply used what was already available or dealt with a few more lines in exchange of a few more files.
🔗 Read More: Native over user land utils

⬆ Return to top
8. Docker Best Practices
🏅 Many thanks to Bret Fisher from whom we learned many of the following practices

 8.1 Use multi-stage builds for leaner and more secure Docker images
TL;DR: Use multi-stage build to copy only necessary production artifacts. A lot of build-time dependencies and files are not needed for running your application. With multi-stage builds these resources can be used during build while the runtime environment contains only what's necessary. Multi-stage builds are an easy way to get rid of overweight and security threats.
Otherwise: Larger images will take longer to build and ship, build-only tools might contain vulnerabilities and secrets only meant for the build phase might be leaked.
Example Dockerfile for multi-stage builds
FROM node:14.4.0 AS build

COPY . .
RUN npm ci && npm run build


FROM node:slim-14.4.0

USER node
EXPOSE 8080

COPY --from=build /home/node/app/dist /home/node/app/package.json /home/node/app/package-lock.json ./
RUN npm ci --production

CMD [ "node", "dist/app.js" ]
🔗 Read More: Use multi-stage builds

 8.2. Bootstrap using node command, avoid npm start
TL;DR: Use CMD ['node','server.js'] to start your app, avoid using npm scripts which don't pass OS signals to the code. This prevents problems with child-processes, signal handling, graceful shutdown and having zombie processes
Update: Starting from npm 7, npm claim to pass signals. We follow and will update accordingly
Otherwise: When no signals are passed, your code will never be notified about shutdowns. Without this, it will lose its chance to close properly possibly losing current requests and/or data
Read More: Bootstrap container using node command, avoid npm start

 8.3. Let the Docker runtime handle replication and uptime
TL;DR: When using a Docker run time orchestrator (e.g., Kubernetes), invoke the Node.js process directly without intermediate process managers or custom code that replicate the process (e.g. PM2, Cluster module). The runtime platform has the highest amount of data and visibility for making placement decision - It knows best how many processes are needed, how to spread them and what to do in case of crashes
Otherwise: Container keeps crashing due to lack of resources will get restarted indefinitely by the process manager. Should Kubernetes be aware of that, it could relocate it to a different roomy instance
🔗 Read More: Let the Docker orchestrator restart and replicate processes

 8.4. Use .dockerignore to prevent leaking secrets
TL;DR: Include a .dockerignore file that filters out common secret files and development artifacts. By doing so, you might prevent secrets from leaking into the image. As a bonus the build time will significantly decrease. Also, ensure not to copy all files recursively rather explicitly choose what should be copied to Docker
Otherwise: Common personal secret files like .env, .aws and .npmrc will be shared with anybody with access to the image (e.g. Docker repository)
🔗 Read More: Use .dockerignore

 8.5. Clean-up dependencies before production
TL;DR: Although Dev-Dependencies are sometimes needed during the build and test life-cycle, eventually the image that is shipped to production should be minimal and clean from development dependencies. Doing so guarantees that only necessary code is shipped and the amount of potential attacks (i.e. attack surface) is minimized. When using multi-stage build (see dedicated bullet) this can be achieved by installing all dependencies first and finally running npm ci --production
Otherwise: Many of the infamous npm security breaches were found within development packages (e.g. eslint-scope)
🔗 Read More: Remove development dependencies

 8.6. Shutdown smartly and gracefully
TL;DR: Handle the process SIGTERM event and clean-up all existing connection and resources. This should be done while responding to ongoing requests. In Dockerized runtimes, shutting down containers is not a rare event, rather a frequent occurrence that happen as part of routine work. Achieving this demands some thoughtful code to orchestrate several moving parts: The load balancer, keep-alive connections, the HTTP server and other resources
Otherwise: Dying immediately means not responding to thousands of disappointed users
🔗 Read More: Graceful shutdown

 8.7. Set memory limits using both Docker and v8
TL;DR: Always configure a memory limit using both Docker and the JavaScript runtime flags. The Docker limit is needed to make thoughtful container placement decision, the --v8's flag max-old-space is needed to kick off the GC on time and prevent under utilization of memory. Practically, set the v8's old space memory to be a just bit less than the container limit
Otherwise: The docker definition is needed to perform thoughtful scaling decision and prevent starving other citizens. Without also defining the v8's limits, it will under utilize the container resources - Without explicit instructions it crashes when utilizing ~50-60% of its host resources
🔗 Read More: Set memory limits using Docker only

 8.8. Plan for efficient caching
TL;DR: Rebuilding a whole docker image from cache can be nearly instantaneous if done correctly. The less updated instructions should be at the top of your Dockerfile and the ones constantly changing (like app code) should be at the bottom.
Otherwise: Docker build will be very long and consume lot of resources even when making tiny changes
🔗 Read More: Leverage caching to reduce build times

 8.9. Use explicit image reference, avoid latest tag
TL;DR: Specify an explicit image digest or versioned label, never refer to latest. Developers are often led to believe that specifying the latest tag will provide them with the most recent image in the repository however this is not the case. Using a digest guarantees that every instance of the service is running exactly the same code.
In addition, referring to an image tag means that the base image is subject to change, as image tags cannot be relied upon for a deterministic install. Instead, if a deterministic install is expected, a SHA256 digest can be used to reference an exact image.
Otherwise: A new version of a base image could be deployed into production with breaking changes, causing unintended application behaviour.
🔗 Read More: Understand image tags and use the "latest" tag with caution

 8.10. Prefer smaller Docker base images
TL;DR: Large images lead to higher exposure to vulnerabilities and increased resource consumption. Using leaner Docker images, such as Slim and Alpine Linux variants, mitigates this issue.
Otherwise: Building, pushing, and pulling images will take longer, unknown attack vectors can be used by malicious actors and more resources are consumed.
🔗 Read More: Prefer smaller images

 8.11. Clean-out build-time secrets, avoid secrets in args
🌟 #new
TL;DR: Avoid secrets leaking from the Docker build environment. A Docker image is typically shared in multiple environment like CI and a registry that are not as sanitized as production. A typical example is an npm token which is usually passed to a dockerfile as argument. This token stays within the image long after it is needed and allows the attacker indefinite access to a private npm registry. This can be avoided by coping a secret file like .npmrc and then removing it using multi-stage build (beware, build history should be deleted as well) or by using Docker build-kit secret feature which leaves zero traces
Otherwise: Everyone with access to the CI and docker registry will also get access to some precious organization secrets as a bonus
🔗 Read More: Clean-out build-time secrets

 8.12. Scan images for multi layers of vulnerabilities
TL;DR: Besides checking code dependencies vulnerabilities also scan the final image that is shipped to production. Docker image scanners check the code dependencies but also the OS binaries. This E2E security scan covers more ground and verifies that no bad guy injected bad things during the build. Consequently, it is recommended running this as the last step before deployment. There are a handful of free and commercial scanners that also provide CI/CD plugins
Otherwise: Your code might be entirely free from vulnerabilities. However it might still get hacked due to vulnerable version of OS-level binaries (e.g. OpenSSL, TarBall) that are commonly being used by applications
🔗 Read More: Scan the entire image before production

 8.13 Clean NODE_MODULE cache
TL;DR: After installing dependencies in a container remove the local cache. It doesn't make any sense to duplicate the dependencies for faster future installs since there won't be any further installs - A Docker image is immutable. Using a single line of code tens of MB (typically 10-50% of the image size) are shaved off
Otherwise: The image that will get shipped to production will weigh 30% more due to files that will never get used
🔗 Read More: Clean NODE_MODULE cache

 8.14. Generic Docker practices
TL;DR: This is a collection of Docker advice that is not related directly to Node.js - the Node implementation is not much different than any other language. Click read more to skim through.
🔗 Read More: Generic Docker practices

 8.15. Lint your Dockerfile
🌟 #new
TL;DR: Linting your Dockerfile is an important step to identify issues in your Dockerfile which differ from best practices. By checking for potential flaws using a specialised Docker linter, performance and security improvements can be easily identified, saving countless hours of wasted time or security issues in production code.
Otherwise: Mistakenly the Dockerfile creator left Root as the production user, and also used an image from unknown source repository. This could be avoided with with just a simple linter.
🔗 Read More: Lint your Dockerfile

⬆ Return to top
Milestones
To maintain this guide and keep it up to date, we are constantly updating and improving the guidelines and best practices with the help of the community. You can follow our milestones and join the working groups if you want to contribute to this project

Translations
All translations are contributed by the community. We will be happy to get any help with either completed, ongoing or new translations!
Completed translations

 Brazilian Portuguese - Courtesy of Marcelo Melo
 Chinese - Courtesy of Matt Jin
 Russian - Courtesy of Alex Ivanov
 Polish - Courtesy of Michal Biesiada
 Japanese - Courtesy of Yuki Ota, Yuta Azumi
 Basque - Courtesy of Ane Diaz de Tuesta & Joxefe Diaz de Tuesta

Translations in progress

 French (Discussion)
 Hebrew (Discussion)
 Korean - Courtesy of Sangbeom Han (Discussion)
 Spanish (Discussion)
 Turkish (Discussion)


Steering Committee
Meet the steering committee members - the people who work together to provide guidance and future direction to the project. In addition, each member of the committee leads a project tracked under our GitHub projects.

Yoni Goldberg


Independent Node.js consultant who works with customers in the USA, Europe, and Israel on building large-scale Node.js applications. Many of the best practices above were first published at goldbergyoni.com. Reach Yoni at @goldbergyoni or me@goldbergyoni.com


Josh Hemphill



Full Stack Software Engineer / Developer specializing in Security, DevOps/DevSecOps, and ERP Integrations.


Raz Luvaton


Full Stack Developer who knows how to exit from Vim and loves Architecture, Virtualization and Security.

Contributing
If you've ever wanted to contribute to open source, now is your chance! See the contributing docs for more information.
Contributors ✨
Thanks goes to these wonderful people who have contributed to this repository!




  
    
      Kevin Rambaud🖋
      Michael Fine🖋
      Shreya Dahal🖋
      Matheus Cruz Rocha🖋
      Yog Mehta🖋
      Kudakwashe Paradzayi🖋
      t1st3🖋
    
    
      mulijordan1976🖋
      Matan Kushner🖋
      Fabio Hiroki🖋
      James Sumners🖋
      Dan Gamble🖋
      PJ Trainor🖋
      Remek Ambroziak🖋
    
    
      Yoni Jah🖋
      Misha Khokhlov🖋
      Evgeny Orekhov🖋
      -🖋
      Isaac Halvorson🖋
      Vedran Karačić🖋
      lallenlowe🖋
    
    
      Nathan Wells🖋
      Paulo Reis🖋
      syzer🖋
      David Sancho🖋
      Robert Manolea🖋
      Xavier Ho🖋
      Aaron🖋
    
    
      Jan Charles Maghirang Adona🖋
      Allen🖋
      Leonardo Villela🖋
      Michał Załęcki🖋
      Chris Nicola🖋
      Alejandro Corredor🖋
      cwar🖋
    
    
      Yuwei🖋
      Utkarsh Bhatt🖋
      Duarte Mendes🖋
      Jason Kim🖋
      Mitja O.🖋
      Sandro Miguel Marques🖋
      Gabe🖋
    
    
      Ron Gross🖋
      Valeri Karpov🖋
      Sergio Bernal🖋
      Nikola Telkedzhiev🖋
      Vitor Godoy🖋
      Manish Saraan🖋
      Sangbeom Han🖋
    
    
      blackmatch🖋
      Joe Reeve🖋
      Ryan Busby🖋
      Iman Mohamadi🖋
      Sergii Paryzhskyi🖋
      Kapil Patel🖋
      迷渡🖋
    
    
      Hozefa🖋
      Ethan🖋
      Sam🖋
      Arlind🖋
      Teddy Toussaint🖋
      Lewis🖋
      Gabriel Lidenor 🖋
    
    
      Roman🖋
      Francozeira🖋
      Invvard🖋
      Rômulo Garofalo🖋
      Tho Q Luong🖋
      Burak Shen🖋
      Martin Muzatko🖋
    
    
      Jared Collier🖋
      Hilton Meyer🖋
      ChangJoo Park(박창주)🖋
      Masahiro Sakaguchi🖋
      Keith Holliday🖋
      coreyc🖋
      Maximilian Berkmann🖋
    
    
      Douglas Mariano Valero🖋
      Marcelo Melo🖋
      Mehmet Perk🖋
      ryan ouyang🖋
      Shabeer🖋
      Eduard Kyvenko🖋
      Deyvison Rocha🖋
    
    
      George Mamer🖋
      Konstantinos Leimonis🖋
      Oliver Lluberes🌍
      Tien Do🖋
      Ranvir Singh🖋
      Vadim Nicolaev🖋 🌍
      German Gamboa Gonzalez🖋
    
    
      Hafez🖋
      Chandiran🖋
      VinayaSathyanarayana🖋
      Kim Kern🖋
      Kenneth Freitas🖋
      songe🖋
      Kirill Shekhovtsov🖋
    
    
      Serge🖋
      keyrwinz🖋
      Dmitry Nikitenko🖋
      bushuai👀 🖋
      Benjamin Gruenbaum🖋
      Ezequiel🌍
      Juan José Rodríguez🌍
    
    
      Or Bin🖋
      Andreo Vieira🖋
      Michael Solomon🖋
      Jimmy Callin🖋
      Siddharth🖋
      Ryan Smith🖋
      Tom Boettger🖋
    
    
      Joaquín Ormaechea🌍
      dfrzuz🌍
      Victor Homyakov🖋
      Josh🖋 🛡️
      Alec Francis🖋
      arjun6610🖋
      Jan Osch🖋
    
    
      Thiago Rotondo Sampaio🌍
      Alexsey🖋
      Luis A. Acurero🌍
      Lucas Romano🌍
      Denise Case🖋
      Nick Ribal🖋 👀
      0xflotus🖋
    
    
      Jonathan Chen🖋
      Dilan Srilal🖋
      vladthelittleone🌍
      Nik Osvalds🖋
      Daniel Kiss📖
      Forresst🖋
      Jonathan Svenheden🖋
    
    
      AustrisC🖋
      kyeongtae kim🌍
      007🖋
      Ane Diaz de Tuesta🌍 🖋
      YukiOta🌍
      Frazer Smith🖋
      Raz Luvaton🖋
    
    
      Yuta Azumi🖋
      andrewjbarbour🖋
      mr🖋
      Aleksandar🖋
      Owl🖋
      Yedidya Schwartz🖋 💡
      ari🖋
    
    
      Thomas König🖋
      Kalle Lämsä🖋
      Wyatt🖋
      KHADIR Tayeb🖋
      Shankar Regmi🖋
      Shubham🖋
      Lucas Alves🖋
    
    
      Benjamin🖋
      Yeoh Joer🖋
      Miigon🖋
      Rostislav Bogorad🖋
      Flouse🖋
      Tarantini Pereira🖋
      Kazuki Matsuo🖋
    
    
      Adam Smith🖋
      Dohyeon Ko🖋
      Vladislav Legkov🖋
      Kerollos Magdy🖋
      Erez Lieberman🖋
      Breno Macedo🖋
      Fernando Flores🌍
    
    
      Rafael Brito🌍
      Emiliano Peralta🌍
      Shin, SJ🖋
      Benjamin Forster🖋
      Daniele Fedeli🖋
      djob195🖋
      antspk🖋
    
    
      정진영🖋
      kkk-cashwalk🖋
      apainintheneck🖋
      Fajar Budhi Iswanda🖋
      이주호🖋
      Singh🖋
      Alex Dumitru🖋
    
    
      Anton Lykhatskyi🖋
      sangwonlee🖋
      Eugenio Berretta🖋
      soranakk🖋
      고준영🖋 💻
      Guilherme Portella 🖋
      André Esser🖋
    
    
      Scc🌍
      Mauro Accornero🖋
      no-yan🖋
      hodbauer🌍
    
  




Steering Committee Emeriti
Bruno Scheufler

💻 full-stack web engineer, Node.js & GraphQL enthusiast


Kyle Martin


Full Stack Developer & Site Reliability Engineer based in New Zealand, interested in web application security, and architecting and building Node.js applications to perform at global scale.


Kevyn Bruyere

Independent full-stack developer with a taste for Ops and automation.


Sagir Khan



Deep specialist in JavaScript and its ecosystem — React, Node.js, TypeScript, GraphQL, MongoDB, pretty much anything that involves JS/JSON in any layer of the system — building products using the web platform for the world’s most recognized brands. Individual Member of the Node.js Foundation.
   


      

        

      
        
          
            
  About

      
        ✅ The Node.js best practices list (July 2024)
      
      
        
        
          twitter.com/nodepractices/
        
      

    Topics
    
        
      
  nodejs

      
  javascript

      
  testing

      
  npm

      
  styleguide

      
  express

      
  microservices

      
  rest

      
  mocha

      
  types

      
  eslint

      
  es6

      
  jest

      
  style-guide

      
  best-practices

      
  expressjs

      
  node-js

      
  nodejs-development

  

    

    Resources
    
      
        
        Readme
    

  
    License
  
    
      
     CC-BY-SA-4.0 license
    
  




  

  
    
      Activity  


  Stars
  
    
      102k
      stars  

  Watchers
  
    
      1.9k
      watching  

  Forks
  
    
      10.4k
      forks  


    
      
          Report repository
    


          
        

        
        
        
        
        
            
              
                
  Contributors
      230


    
      
          
            
          
          
            
          
          
            
          
          
            
          
          
            
          
          
            
          
          
            
          
          
            
          
          
            
          
          
            
          
          
            
          
          
            
          
          
            
          
          
            
          
      


  
    + 216 contributors
              
            

        
        
            
              
                Languages

  
    
    


    
        
          
          Dockerfile
          87.9%
        
    
    
        
          
          TypeScript
          12.1%\n\n\n\nNode.js Best Practices

  



    


 Follow us on Twitter! @nodepractices

Read in a different language: CN, FR, BR, RU, PL, JA, EU (ES, HE, KR and TR in progress! )

🎊 2024 edition is here!


🛰 Modernized to 2024: Tons of text edits, new recommended libraries, and some new best practices


✨ Easily focus on new content: Already visited before? Search for #new or #updated tags for new content only


🔖 Curious to see examples? We have a starter: Visit Practica.js, our application example and boilerplate (beta) to see some practices in action



Welcome! 3 Things You Ought To Know First
1. You are reading dozens of the best Node.js articles - this repository is a summary and curation of the top-ranked content on Node.js best practices, as well as content written here by collaborators
2. It is the largest compilation, and it is growing every week - currently, more than 80 best practices, style guides, and architectural tips are presented. New issues and pull requests are created every day to keep this live book updated. We'd love to see you contributing here, whether that is fixing code mistakes, helping with translations, or suggesting brilliant new ideas. See our writing guidelines here
3. Best practices have additional info - most bullets include a 🔗Read More link that expands on the practice with code examples, quotes from selected blogs, and more information

By Yoni Goldberg
Learn with me: As a consultant, I engage with worldwide teams on various activities like workshops and code reviews. 🎉AND... Hold on, I've just launched my beyond-the-basics testing course, which is on a 🎁 limited-time sale until August 7th

Table of Contents

  
    1. Project Architecture Practices (6)
  
  1.1 Structure your solution by components #strategic #updated
  1.2 Layer your components, keep the web layer within its boundaries #strategic #updated
  1.3 Wrap common utilities as packages, consider publishing
  1.4 Use environment aware, secure and hierarchical config #updated
  1.5 Consider all the consequences when choosing the main framework #new
  1.6 Use TypeScript sparingly and thoughtfully #new


  
    2. Error Handling Practices (12)
  
  2.1 Use Async-Await or promises for async error handling
  2.2 Extend the built-in Error object #strategic #updated
  2.3 Distinguish operational vs programmer errors #strategic #updated
  2.4 Handle errors centrally, not within a middleware #strategic
  2.5 Document API errors using OpenAPI or GraphQL
  2.6 Exit the process gracefully when a stranger comes to town #strategic
  2.7 Use a mature logger to increase errors visibility #updated
  2.8 Test error flows using your favorite test framework #updated
  2.9 Discover errors and downtime using APM products
  2.10 Catch unhandled promise rejections #updated
  2.11 Fail fast, validate arguments using a dedicated library
  2.12 Always await promises before returning to avoid a partial stacktrace #new
  2.13 Subscribe to event emitters 'error' event #new


  
    3. Code Style Practices (12)
  
  3.1 Use ESLint #strategic
  3.2 Use Node.js eslint extension plugins #updated
  3.3 Start a Codeblock's Curly Braces on the Same Line
  3.4 Separate your statements properly
  3.5 Name your functions
  3.6 Use naming conventions for variables, constants, functions and classes
  3.7 Prefer const over let. Ditch the var
  3.8 Require modules first, not inside functions
  3.9 Set an explicit entry point to a module/folder #updated
  3.10 Use the === operator
  3.11 Use Async Await, avoid callbacks #strategic
  3.12 Use arrow function expressions (=>)
  3.13 Avoid effects outside of functions #new


  
    4. Testing And Overall Quality Practices (13)
  
  4.1 At the very least, write API (component) testing #strategic
  4.2 Include 3 parts in each test name #new
  4.3 Structure tests by the AAA pattern #strategic
  4.4 Ensure Node version is unified #new
  4.5 Avoid global test fixtures and seeds, add data per-test #strategic
  4.6 Tag your tests #advanced
  4.7 Check your test coverage, it helps to identify wrong test patterns
  4.8 Use production-like environment for e2e testing
  4.9 Refactor regularly using static analysis tools
  4.10 Mock responses of external HTTP services #advanced #new #advanced
  4.11 Test your middlewares in isolation
  4.12 Specify a port in production, randomize in testing #new
  4.13 Test the five possible outcomes #strategic #new


  
    5. Going To Production Practices (19)
  
  5.1. Monitoring #strategic
  5.2. Increase the observability using smart logging #strategic
  5.3. Delegate anything possible (e.g. gzip, SSL) to a reverse proxy #strategic
  5.4. Lock dependencies
  5.5. Guard process uptime using the right tool
  5.6. Utilize all CPU cores
  5.7. Create a ‘maintenance endpoint’
  5.8. Discover the unknowns using APM products #advanced #updated
  5.9. Make your code production-ready
  5.10. Measure and guard the memory usage #advanced
  5.11. Get your frontend assets out of Node
  5.12. Strive to be stateless #strategic
  5.13. Use tools that automatically detect vulnerabilities
  5.14. Assign a transaction id to each log statement #advanced
  5.15. Set NODE_ENV=production
  5.16. Design automated, atomic and zero-downtime deployments #advanced
  5.17. Use an LTS release of Node.js
  5.18. Log to stdout, avoid specifying log destination within the app #updated
  5.19. Install your packages with npm ci #new


  
    6. Security Practices (25)
  
  6.1. Embrace linter security rules
  6.2. Limit concurrent requests using a middleware
  6.3 Extract secrets from config files or use packages to encrypt them #strategic
  6.4. Prevent query injection vulnerabilities with ORM/ODM libraries #strategic
  6.5. Collection of generic security best practices
  6.6. Adjust the HTTP response headers for enhanced security
  6.7. Constantly and automatically inspect for vulnerable dependencies #strategic
  6.8. Protect Users' Passwords/Secrets using bcrypt or scrypt #strategic
  6.9. Escape HTML, JS and CSS output
  6.10. Validate incoming JSON schemas #strategic
  6.11. Support blocklisting JWTs
  6.12. Prevent brute-force attacks against authorization #advanced
  6.13. Run Node.js as non-root user
  6.14. Limit payload size using a reverse-proxy or a middleware
  6.15. Avoid JavaScript eval statements
  6.16. Prevent evil RegEx from overloading your single thread execution
  6.17. Avoid module loading using a variable
  6.18. Run unsafe code in a sandbox
  6.19. Take extra care when working with child processes #advanced
  6.20. Hide error details from clients
  6.21. Configure 2FA for npm or Yarn #strategic
  6.22. Modify session middleware settings
  6.23. Avoid DOS attacks by explicitly setting when a process should crash #advanced
  6.24. Prevent unsafe redirects
  6.25. Avoid publishing secrets to the npm registry
  6.26. 6.26 Inspect for outdated packages
  6.27. Import built-in modules using the 'node:' protocol #new


  
    7. Performance Practices (2) (Work In Progress️ ✍️)
  
  7.1. Don't block the event loop
  7.2. Prefer native JS methods over user-land utils like Lodash


  
    8. Docker Practices (15)
  
  8.1 Use multi-stage builds for leaner and more secure Docker images #strategic
  8.2. Bootstrap using node command, avoid npm start
  8.3. Let the Docker runtime handle replication and uptime #strategic
  8.4. Use .dockerignore to prevent leaking secrets
  8.5. Clean-up dependencies before production
  8.6. Shutdown smartly and gracefully #advanced
  8.7. Set memory limits using both Docker and v8 #advanced #strategic
  8.8. Plan for efficient caching
  8.9. Use explicit image reference, avoid latest tag
  8.10. Prefer smaller Docker base images
  8.11. Clean-out build-time secrets, avoid secrets in args #strategic #new
  8.12. Scan images for multi layers of vulnerabilities #advanced
  8.13 Clean NODE_MODULE cache
  8.14. Generic Docker practices
  8.15. Lint your Dockerfile #new


1. Project Architecture Practices
 1.1 Structure your solution by business components
📝 #updated
TL;DR: The root of a system should contain folders or repositories that represent reasonably sized business modules. Each component represents a product domain (i.e., bounded context), like 'user-component', 'order-component', etc. Each component has its own API, logic, and logical database. What is the significant merit? With an autonomous component, every change is performed over a granular and smaller scope - the mental overload, development friction, and deployment fear are much smaller and better. As a result, developers can move much faster. This does not necessarily demand physical separation and can be achieved using a Monorepo or with a multi-repo
my-system
├─ apps (components)
│  ├─ orders
│  ├─ users
│  ├─ payments
├─ libraries (generic cross-component functionality)
│  ├─ logger
│  ├─ authenticator
Otherwise: when artifacts from various modules/topics are mixed together, there are great chances of a tightly-coupled 'spaghetti' system. For example, in an architecture where 'module-a controller' might call 'module-b service', there are no clear modularity borders - every code change might affect anything else. With this approach, developers who code new features struggle to realize the scope and impact of their change. Consequently, they fear breaking other modules, and each deployment becomes slower and riskier
🔗 Read More: structure by components

 1.2 Layer your components with 3-tiers, keep the web layer within its boundaries
📝 #updated
TL;DR: Each component should contain 'layers' - a dedicated folder for common concerns: 'entry-point' where controller lives, 'domain' where the logic lives, and 'data-access'. The primary principle of the most popular architectures is to separate the technical concerns (e.g., HTTP, DB, etc) from the pure logic of the app so a developer can code more features without worrying about infrastructural concerns. Putting each concern in a dedicated folder, also known as the 3-Tier pattern, is the simplest way to meet this goal
my-system
├─ apps (components)
│  ├─ component-a
   │  ├─ entry-points
   │  │  ├─ api # controller comes here
   │  │  ├─ message-queue # message consumer comes here
   │  ├─ domain # features and flows: DTO, services, logic
   │  ├─ data-access # DB calls w/o ORM
Otherwise: It's often seen that developer pass web objects like request/response to functions in the domain/logic layer - this violates the separation principle and makes it harder to access later the logic code by other clients like testing code, scheduled jobs, message queues, etc
🔗 Read More: layer your app

 1.3 Wrap common utilities as packages, consider publishing
TL;DR: Place all reusable modules in a dedicated folder, e.g., "libraries", and underneath each module in its own folder, e.g., "/libraries/logger". Make the module an independent package with its own package.json file to increase the module encapsulation, and allows future publishing to a repository. In a Monorepo setup, modules can be consumed by 'npm linking' to their physical paths, using ts-paths or by publishing and installing from a package manager repository like the npm registry
my-system
├─ apps (components)
  │  ├─ component-a
├─ libraries (generic cross-component functionality)
│  ├─ logger
│  │  ├─ package.json
│  │  ├─ src
│  │  │ ├─ index.js

Otherwise: Clients of a module might import and get coupled to internal functionality of a module. With a package.json at the root, one can set a package.json.main or package.json.exports to explicitly tell which files and functions are part of the public interface
🔗 Read More: Structure by feature

 1.4 Use environment aware, secure and hierarchical config
📝 #updated
TL;DR: A flawless configuration setup should ensure (a) keys can be read from file AND from environment variable (b) secrets are kept outside committed code (c) config is hierarchical for easier findability (d) typing support (e) validation for failing fast (f) Specify default for each key. There are a few packages that can help tick most of those boxes like convict, env-var, zod, and others
Otherwise: Consider a mandatory environment variable that wasn't provided. The app starts successfully and serve requests, some information is already persisted to DB. Then, it's realized that without this mandatory key the request can't complete, leaving the app in a dirty state
🔗 Read More: configuration best practices

 1.5 Consider all the consequences when choosing the main framework
🌟 #new
TL;DR: When building apps and APIs, using a framework is mandatory. It's easy to overlook alternative frameworks or important considerations and then finally land on a sub optimal option. As of 2023/2024, we believe that these four frameworks are worth considering: Nest.js, Fastify, express, and Koa. Click read more below for a detailed pros/cons of each framework. Simplistically, we believe that Nest.js is the best match for teams who wish to go OOP and/or build large-scale apps that can't get partitioned into smaller autonomous components. Fastify is our recommendation for apps with reasonably-sized components (e.g., Microservices) that are built around simple Node.js mechanics. Read our full considerations guide here
Otherwise: Due to the overwhelming amount of considerations, it's easy to make decisions based on partial information and compare apples with oranges. For example, it's believed that Fastify is a minimal web-server that should get compared with express only. In reality, it's a rich framework with many official plugins that cover many concerns
🔗 Read More: Choosing the right framework
 1.6 Use TypeScript sparingly and thoughtfully
🌟 #new
TL;DR: Coding without type safety is no longer an option, TypeScript is the most popular option for this mission. Use it to define variables and functions return types. With that, it is also a double edge sword that can greatly encourage complexity with its additional ~ 50 keywords and sophisticated features. Consider using it sparingly, mostly with simple types, and utilize advanced features only when a real need arises
Otherwise: Researches show that using TypeScript can help in detecting ~20% bugs earlier. Without it, also the developer experience in the IDE is intolerable. On the flip side, 80% of other bugs were not discovered using types. Consequently, typed syntax is valuable but limited. Only efficient tests can discover the whole spectrum of bugs, including type-related bugs. It might also defeat its purpose: sophisticated code features are likely to increase the code complexity, which by itself increases both the amount of bugs and the average bug fix time
🔗 Read More: TypeScript considerations

⬆ Return to top
2. Error Handling Practices
 2.1 Use Async-Await or promises for async error handling
TL;DR: Handling async errors in callback style is probably the fastest way to hell (a.k.a the pyramid of doom). The best gift you can give to your code is using Promises with async-await which enables a much more compact and familiar code syntax like try-catch
Otherwise: Node.js callback style, function(err, response), is a promising way to un-maintainable code due to the mix of error handling with casual code, excessive nesting, and awkward coding patterns
🔗 Read More: avoiding callbacks

 2.2 Extend the built-in Error object
📝 #updated
TL;DR: Some libraries throw errors as a string or as some custom type – this complicates the error handling logic and the interoperability between modules. Instead, create app error object/class that extends the built-in Error object and use it whenever rejecting, throwing or emitting an error. The app error should add useful imperative properties like the error name/code and isCatastrophic. By doing so, all errors have a unified structure and support better error handling. There is no-throw-literal ESLint rule that strictly checks that (although it has some limitations which can be solved when using TypeScript and setting the @typescript-eslint/no-throw-literal rule)
Otherwise: When invoking some component, being uncertain which type of errors come in return – it makes proper error handling much harder. Even worse, using custom types to describe errors might lead to loss of critical error information like the stack trace!
🔗 Read More: using the built-in error object

 2.3 Distinguish catastrophic errors from operational errors
📝 #updated
TL;DR: Operational errors (e.g. API received an invalid input) refer to known cases where the error impact is fully understood and can be handled thoughtfully. On the other hand, catastrophic error (also known as programmer errors) refers to unusual code failures that dictate to gracefully restart the application
Otherwise: You may always restart the application when an error appears, but why let ~5000 online users down because of a minor, predicted, operational error? The opposite is also not ideal – keeping the application up when an unknown catastrophic issue (programmer error) occurred might lead to an unpredicted behavior. Differentiating the two allows acting tactfully and applying a balanced approach based on the given context
🔗 Read More: operational vs programmer error

 2.4 Handle errors centrally, not within a middleware
TL;DR: Error handling logic such as logging, deciding whether to crash and monitoring metrics should be encapsulated in a dedicated and centralized object that all entry-points (e.g. APIs, cron jobs, scheduled jobs) call when an error comes in
Otherwise: Not handling errors within a single place will lead to code duplication and probably to improperly handled errors
🔗 Read More: handling errors in a centralized place

 2.5 Document API errors using OpenAPI or GraphQL
TL;DR: Let your API callers know which errors might come in return so they can handle these thoughtfully without crashing. For RESTful APIs, this is usually done with documentation frameworks like OpenAPI. If you're using GraphQL, you can utilize your schema and comments as well
Otherwise: An API client might decide to crash and restart only because it received back an error it couldn’t understand. Note: the caller of your API might be you (very typical in a microservice environment)
🔗 Read More: documenting API errors in Swagger or GraphQL

 2.6 Exit the process gracefully when a stranger comes to town
TL;DR: When an unknown error occurs (catastrophic error, see best practice 2.3) - there is uncertainty about the application healthiness. In this case, there is no escape from making the error observable, shutting off connections and exiting the process. Any reputable runtime framework like Dockerized services or cloud serverless solutions will take care to restart
Otherwise: When an unfamiliar exception occurs, some object might be in a faulty state (e.g. an event emitter which is used globally and not firing events anymore due to some internal failure) and all future requests might fail or behave crazily
🔗 Read More: shutting the process

 2.7 Use a mature logger to increase errors visibility
📝 #updated
TL;DR: A robust logging tools like Pino or Winston increases the errors visibility using features like log-levels, pretty print coloring and more. Console.log lacks these imperative features and should be avoided. The best in class logger allows attaching custom useful properties to log entries with minimized serialization performance penalty. Developers should write logs to stdout and let the infrastructure pipe the stream to the appropriate log aggregator
Otherwise: Skimming through console.logs or manually through messy text file without querying tools or a decent log viewer might keep you busy at work until late
🔗 Read More: using a mature logger

 2.8 Test error flows using your favorite test framework
📝 #updated
TL;DR: Whether professional automated QA or plain manual developer testing – Ensure that your code not only satisfies positive scenarios but also handles and returns the right errors. On top of this, simulate deeper error flows like uncaught exceptions and ensure that the error handler treat these properly (see code examples within the "read more" section)
Otherwise: Without testing, whether automatically or manually, you can’t rely on your code to return the right errors. Without meaningful errors – there’s no error handling
🔗 Read More: testing error flows

 2.9 Discover errors and downtime using APM products
TL;DR: Monitoring and performance products (a.k.a APM) proactively gauge your codebase or API so they can automagically highlight errors, crashes, and slow parts that you were missing
Otherwise: You might spend great effort on measuring API performance and downtimes, probably you’ll never be aware which are your slowest code parts under real-world scenario and how these affect the UX
🔗 Read More: using APM products

 2.10 Catch unhandled promise rejections
📝 #updated
TL;DR: Any exception thrown within a promise will get swallowed and discarded unless a developer didn’t forget to explicitly handle it. Even if your code is subscribed to process.uncaughtException! Overcome this by registering to the event process.unhandledRejection
Otherwise: Your errors will get swallowed and leave no trace. Nothing to worry about
🔗 Read More: catching unhandled promise rejection

 2.11 Fail fast, validate arguments using a dedicated library
TL;DR: Assert API input to avoid nasty bugs that are much harder to track later. The validation code is usually tedious unless you are using a modern validation library like ajv, zod, or typebox
Otherwise: Consider this – your function expects a numeric argument “Discount” which the caller forgets to pass, later on, your code checks if Discount!=0 (amount of allowed discount is greater than zero), then it will allow the user to enjoy a discount. OMG, what a nasty bug. Can you see it?
🔗 Read More: failing fast

 2.12 Always await promises before returning to avoid a partial stacktrace
🌟 #new
TL;DR: Always do return await when returning a promise to benefit full error stacktrace. If a
function returns a promise, that function must be declared as async function and explicitly
await the promise before returning it
Otherwise: The function that returns a promise without awaiting won't appear in the stacktrace.
Such missing frames would probably complicate the understanding of the flow that leads to the error,
especially if the cause of the abnormal behavior is inside of the missing function
🔗 Read More: returning promises

 2.13 Subscribe to event emitters and streams 'error' event
🌟 #new
TL;DR: Unlike typical functions, a try-catch clause won't get errors that originate from Event Emitters and anything inherited from it (e.g., streams). Instead of try-catch, subscribe to an event emitter's 'error' event so your code can handle the error in context. When dealing with EventTargets (the web standard version of Event Emitters) there are no 'error' event and all errors end in the process.on('error) global event - in this case, at least ensure that the process crash or not based on the desired context. Also, mind that error originating from asynchronous event handlers are not get caught unless the event emitter is initialized with {captureRejections: true}
Otherwise: Event emitters are commonly used for global and key application functionality such as DB or message queue connection. When this kind of crucial objects throw an error, at best the process will crash due to unhandled exception. Even worst, it will stay alive as a zombie while a key functionality is turned off

⬆ Return to top
3. Code Patterns And Style Practices
 3.1 Use ESLint
TL;DR: ESLint is the de-facto standard for checking possible code errors and fixing code style, not only to identify nitty-gritty spacing issues but also to detect serious code anti-patterns like developers throwing errors without classification. Though ESLint can automatically fix code styles, other tools like prettier are more powerful in formatting the fix and work in conjunction with ESLint
Otherwise: Developers will focus on tedious spacing and line-width concerns and time might be wasted overthinking the project's code style
🔗 Read More: Using ESLint and Prettier

 3.2 Use Node.js eslint extension plugins
📝 #updated
TL;DR: On top of ESLint standard rules that cover vanilla JavaScript, add Node.js specific plugins like eslint-plugin-node, eslint-plugin-mocha and eslint-plugin-node-security, eslint-plugin-require, /eslint-plugin-jest and other useful rules
Otherwise: Many faulty Node.js code patterns might escape under the radar. For example, developers might require(variableAsPath) files with a variable given as a path which allows attackers to execute any JS script. Node.js linters can detect such patterns and complain early

 3.3 Start a Codeblock's Curly Braces on the Same Line
TL;DR: The opening curly braces of a code block should be on the same line as the opening statement
Code Example
// Do
function someFunction() {
  // code block
}

// Avoid
function someFunction()
{
  // code block
}
Otherwise: Deferring from this best practice might lead to unexpected results, as seen in the StackOverflow thread below:
🔗 Read more: "Why do results vary based on curly brace placement?" (StackOverflow)

 3.4 Separate your statements properly
No matter if you use semicolons or not to separate your statements, knowing the common pitfalls of improper linebreaks or automatic semicolon insertion, will help you to eliminate regular syntax errors.
TL;DR: Use ESLint to gain awareness about separation concerns. Prettier or Standardjs can automatically resolve these issues.
Otherwise: As seen in the previous section, JavaScript's interpreter automatically adds a semicolon at the end of a statement if there isn't one, or considers a statement as not ended where it should, which might lead to some undesired results. You can use assignments and avoid using immediately invoked function expressions to prevent most of the unexpected errors.
Code example
// Do
function doThing() {
    // ...
}

doThing()

// Do

const items = [1, 2, 3]
items.forEach(console.log)

// Avoid — throws exception
const m = new Map()
const a = [1,2,3]
[...m.values()].forEach(console.log)
> [...m.values()].forEach(console.log)
>  ^^^
> SyntaxError: Unexpected token ...

// Avoid — throws exception
const count = 2 // it tries to run 2(), but 2 is not a function
(function doSomething() {
  // do something amazing
}())
// put a semicolon before the immediate invoked function, after the const definition, save the return value of the anonymous function to a variable or avoid IIFEs altogether
🔗 Read more: "Semi ESLint rule"
🔗 Read more: "No unexpected multiline ESLint rule"

 3.5 Name your functions
TL;DR: Name all functions, including closures and callbacks. Avoid anonymous functions. This is especially useful when profiling a node app. Naming all functions will allow you to easily understand what you're looking at when checking a memory snapshot
Otherwise: Debugging production issues using a core dump (memory snapshot) might become challenging as you notice significant memory consumption from anonymous functions

 3.6 Use naming conventions for variables, constants, functions and classes
TL;DR: Use lowerCamelCase when naming constants, variables and functions, UpperCamelCase (capital first letter as well) when naming classes and UPPER_SNAKE_CASE when naming global or static variables. This will help you to easily distinguish between plain variables, functions, classes that require instantiation and variables declared at global module scope. Use descriptive names, but try to keep them short
Otherwise: JavaScript is the only language in the world that allows invoking a constructor ("Class") directly without instantiating it first. Consequently, Classes and function-constructors are differentiated by starting with UpperCamelCase
3.6 Code Example
// for global variables names we use the const/let keyword and UPPER_SNAKE_CASE
let MUTABLE_GLOBAL = "mutable value";
const GLOBAL_CONSTANT = "immutable value";
const CONFIG = {
  key: "value",
};

// examples of UPPER_SNAKE_CASE convention in nodejs/javascript ecosystem
// in javascript Math.PI module
const PI = 3.141592653589793;

// https://github.com/nodejs/node/blob/b9f36062d7b5c5039498e98d2f2c180dca2a7065/lib/internal/http2/core.js#L303
// in nodejs http2 module
const HTTP_STATUS_OK = 200;
const HTTP_STATUS_CREATED = 201;

// for class name we use UpperCamelCase
class SomeClassExample {
  // for static class properties we use UPPER_SNAKE_CASE
  static STATIC_PROPERTY = "value";
}

// for functions names we use lowerCamelCase
function doSomething() {
  // for scoped variable names we use the const/let keyword and lowerCamelCase
  const someConstExample = "immutable value";
  let someMutableExample = "mutable value";
}

 3.7 Prefer const over let. Ditch the var
TL;DR: Using const means that once a variable is assigned, it cannot be reassigned. Preferring const will help you to not be tempted to use the same variable for different uses, and make your code clearer. If a variable needs to be reassigned, in a for loop, for example, use let to declare it. Another important aspect of let is that a variable declared using it is only available in the block scope in which it was defined. var is function scoped, not block-scoped, and shouldn't be used in ES6 now that you have const and let at your disposal
Otherwise: Debugging becomes way more cumbersome when following a variable that frequently changes
🔗 Read more: JavaScript ES6+: var, let, or const? 

 3.8 Require modules first, not inside functions
TL;DR: Require modules at the beginning of each file, before and outside of any functions. This simple best practice will not only help you easily and quickly tell the dependencies of a file right at the top but also avoids a couple of potential problems
Otherwise: Requires are run synchronously by Node.js. If they are called from within a function, it may block other requests from being handled at a more critical time. Also, if a required module or any of its dependencies throw an error and crash the server, it is best to find out about it as soon as possible, which might not be the case if that module is required from within a function

 3.9 Set an explicit entry point to a module/folder
📝 #updated
TL;DR: When developing a module/library, set an explicit root file that exports the public and interesting code. Discourage the client code from importing deep files and becoming familiar with the internal structure. With commonjs (require), this can be done with an index.js file at the folder's root or the package.json.main field. With ESM (import), if a package.json exists on the root, the field "exports" allow specifying the module's root file. If no package.json exists, you may put an index.js file on the root which re-exports all the public functionality
Otherwise: Having an explicit root file acts like a public 'interface' that encapsulates the internal, directs the caller to the public code and facilitates future changes without breaking the contract
3.9 Code example - avoid coupling the client to the module structure
// Avoid: client has deep familiarity with the internals

// Client code
const SMSWithMedia = require("./SMSProvider/providers/media/media-provider.js");

// Better: explicitly export the public functions

//index.js, module code
module.exports.SMSWithMedia = require("./SMSProvider/providers/media/media-provider.js");

// Client code
const { SMSWithMedia } = require("./SMSProvider");

 3.10 Use the === operator
TL;DR: Prefer the strict equality operator === over the weaker abstract equality operator ==. == will compare two variables after converting them to a common type. There is no type conversion in ===, and both variables must be of the same type to be equal
Otherwise: Unequal variables might return true when compared with the == operator
3.10 Code example
"" == "0"; // false
0 == ""; // true
0 == "0"; // true

false == "false"; // false
false == "0"; // true

false == undefined; // false
false == null; // false
null == undefined; // true

" \t\r\n " == 0; // true
All statements above will return false if used with ===

 3.11 Use Async Await, avoid callbacks
TL;DR: Async-await is the simplest way to express an asynchronous flow as it makes asynchronous code look synchronous. Async-await will also result in much more compact code and support for try-catch. This technique now supersedes callbacks and promises in most cases. Using it in your code is probably the best gift one can give to the code reader
Otherwise: Handling async errors in callback style are probably the fastest way to hell - this style forces to check errors all over, deal with awkward code nesting, and makes it difficult to reason about the code flow
🔗Read more: Guide to async-await 1.0

 3.12 Use arrow function expressions (=>)
TL;DR: Though it's recommended to use async-await and avoid function parameters when dealing with older APIs that accept promises or callbacks - arrow functions make the code structure more compact and keep the lexical context of the root function (i.e. this)
Otherwise: Longer code (in ES5 functions) is more prone to bugs and cumbersome to read
🔗 Read more: It’s Time to Embrace Arrow Functions

 3.13 Avoid effects outside of functions
🌟 #new
TL;DR: Avoid putting code with effects like network or DB calls outside of functions. Such a code will be executed immediately when another file requires the file. This 'floating' code might get executed when the underlying system is not ready yet. It also comes with a performance penalty even when this module's functions will finally not be used in runtime. Last, mocking these DB/network calls for testing is harder outside of functions. Instead, put this code inside functions that should get called explicitly. If some DB/network code must get executed right when the module loads, consider using the factory or revealing module patterns
Otherwise: A typical web framework sets error handler, environment variables and monitoring. When DB/network calls are made before the web framework is initialized, they won't be monitored or fail due to a lack of configuration data

⬆ Return to top
4. Testing And Overall Quality Practices
_We have dedicated guides for testing, see below. The best practices list here is a brief summary of these guides
a. JavaScript testing best practices
b. Node.js testing - beyond the basics
_
 4.1 At the very least, write API (component) testing
TL;DR: Most projects just don't have any automated testing due to short timetables or often the 'testing project' ran out of control and was abandoned. For that reason, prioritize and start with API testing which is the easiest way to write and provides more coverage than unit testing (you may even craft API tests without code using tools like Postman). Afterwards, should you have more resources and time, continue with advanced test types like unit testing, DB testing, performance testing, etc
Otherwise: You may spend long days on writing unit tests to find out that you got only 20% system coverage

 4.2 Include 3 parts in each test name
🌟 #new
TL;DR: Make the test speak at the requirements level so it's self-explanatory also to QA engineers and developers who are not familiar with the code internals. State in the test name what is being tested (unit under test), under what circumstances, and what is the expected result
Otherwise: A deployment just failed, a test named “Add product” failed. Does this tell you what exactly is malfunctioning?
🔗 Read More: Include 3 parts in each test name

 4.3 Structure tests by the AAA pattern
🌟 #new
TL;DR: Structure your tests with 3 well-separated sections: Arrange, Act & Assert (AAA). The first part includes the test setup, then the execution of the unit under test, and finally the assertion phase. Following this structure guarantees that the reader spends no brain CPU on understanding the test plan
Otherwise: Not only you spend long daily hours on understanding the main code, but now also what should have been the simple part of the day (testing) stretches your brain
🔗 Read More: Structure tests by the AAA pattern

 4.4 Ensure Node version is unified
🌟 #new
TL;DR: Use tools that encourage or enforce the same Node.js version across different environments and developers. Tools like nvm, and Volta allow specifying the project's version in a file so each team member can run a single command to conform with the project's version. Optionally, this definition can be replicated to CI and the production runtime (e.g., copy the specified value to .Dockerfile build and to the CI declaration file)
Otherwise: A developer might face or miss an error because she uses a different Node.js version than her teammates. Even worse - the production runtime might be different than the environment where tests were executed

 4.5 Avoid global test fixtures and seeds, add data per-test
TL;DR: To prevent test coupling and easily reason about the test flow, each test should add and act on its own set of DB rows. Whenever a test needs to pull or assume the existence of some DB data - it must explicitly add that data and avoid mutating any other records
Otherwise: Consider a scenario where deployment is aborted due to failing tests, team is now going to spend precious investigation time that ends in a sad conclusion: the system works well, the tests however interfere with each other and break the build
🔗 Read More: Avoid global test fixtures

 4.6 Tag your tests
TL;DR: Different tests must run on different scenarios: quick smoke, IO-less, tests should run when a developer saves or commits a file, full end-to-end tests usually run when a new pull request is submitted, etc. This can be achieved by tagging tests with keywords like #cold #api #sanity so you can grep with your testing harness and invoke the desired subset. For example, this is how you would invoke only the sanity test group with Mocha: mocha --grep 'sanity'
Otherwise: Running all the tests, including tests that perform dozens of DB queries, any time a developer makes a small change can be extremely slow and keeps developers away from running tests

 4.7 Check your test coverage, it helps to identify wrong test patterns
TL;DR: Code coverage tools like Istanbul/NYC are great for 3 reasons: it comes for free (no effort is required to benefit this reports), it helps to identify a decrease in testing coverage, and last but not least it highlights testing mismatches: by looking at colored code coverage reports you may notice, for example, code areas that are never tested like catch clauses (meaning that tests only invoke the happy paths and not how the app behaves on errors). Set it to fail builds if the coverage falls under a certain threshold
Otherwise: There won't be any automated metric telling you when a large portion of your code is not covered by testing

 4.8 Use production-like environment for e2e testing
TL;DR: End to end (e2e) testing which includes live data used to be the weakest link of the CI process as it depends on multiple heavy services like DB. Use an environment which is as close to your real production environment as possible like a-continue (Missed -continue here, needs content. Judging by the Otherwise clause, this should mention docker-compose)
Otherwise: Without docker-compose, teams must maintain a testing DB for each testing environment including developers' machines, keep all those DBs in sync so test results won't vary across environments

 4.9 Refactor regularly using static analysis tools
TL;DR: Using static analysis tools helps by giving objective ways to improve code quality and keeps your code maintainable. You can add static analysis tools to your CI build to fail when it finds code smells. Its main selling points over plain linting are the ability to inspect quality in the context of multiple files (e.g. detect duplications), perform advanced analysis (e.g. code complexity), and follow the history and progress of code issues. Two examples of tools you can use are Sonarqube (2,600+ stars) and Code Climate (1,500+ stars).
Otherwise: With poor code quality, bugs and performance will always be an issue that no shiny new library or state of the art features can fix
🔗 Read More: Refactoring!

 4.10 Mock responses of external HTTP services
🌟 #new
TL;DR: Use network mocking tools to simulate responses of external collaborators' services that are approached over the network (e.g., REST, Graph). This is imperative not only to isolate the component under test but mostly to simulate non-happy path flows. Tools like nock (in-process) or Mock-Server allow defining a specific response of external service in a single line of code. Remember to simulate also errors, delays, timeouts, and any other event that is likely to happen in production
Otherwise: Allowing your component to reach real external services instances will likely result in naive tests that mostly cover happy paths. The tests might also be flaky and slow
🔗 Read More: Mock external services
 4.11 Test your middlewares in isolation
TL;DR: When a middleware holds some immense logic that spans many requests, it is worth testing it in isolation without waking up the entire web framework. This can be easily achieved by stubbing and spying on the {req, res, next} objects
Otherwise: A bug in Express middleware === a bug in all or most requests
🔗 Read More: Test middlewares in isolation
 4.12 Specify a port in production, randomize in testing
🌟 #new
TL;DR: When testing against the API, it's common and desirable to initialize the web server inside the tests. Let the server randomize the web server port in testing to prevent collisions. If you're using Node.js http server (used by most frameworks), doing so demands nothing but passing a port number zero - this will randomize an available port
Otherwise: Specifying a fixed port will prevent two testing processes from running at the same time. Most of the modern test runners run with multiple processes by default
🔗 Read More: Randomize a port for testing
 4.13 Test the five possible outcomes
🌟 #new
TL;DR: When testing a flow, ensure to cover five potential categories. Any time some action is triggered (e.g., API call), a reaction occurs, a meaningful outcome is produced and calls for testing. There are five possible outcome types for every flow: a response, a visible state change (e.g., DB), an outgoing API call, a new message in a queue, and an observability call (e.g., logging, metric). See a checklist here. Each type of outcome comes with unique challenges and techniques to mitigate those challenges - we have a dedicated guide about this topic: Node.js testing - beyond the basics
Otherwise: Consider a case when testing the addition of a new product to the system. It's common to see tests that assert on a valid response only. What if the product was failed to persist regardless of the positive response? what if when adding a new product demands calling some external service, or putting a message in the queue - shouldn't the test assert these outcomes as well? It's easy to overlook various paths, this is where a checklist comes handy
🔗 Read More: Test five outcomes

⬆ Return to top
5. Going To Production Practices
 5.1. Monitoring
TL;DR: Monitoring is a game of finding out issues before customers do – obviously this should be assigned unprecedented importance. The market is overwhelmed with offers thus consider starting with defining the basic metrics you must follow (my suggestions inside), then go over additional fancy features and choose the solution that ticks all boxes. In any case, the 4 layers of observability must be covered: uptime, metrics with focus on user-facing symptoms and Node.js technical metrics like event loop lag, distributed flows measurement with Open Telemetry and logging. Click ‘Read More’ below for an overview of the solutions
Otherwise: Failure === disappointed customers. Simple
🔗 Read More: Monitoring!

 5.2. Increase the observability using smart logging
TL;DR: Logs can be a dumb warehouse of debug statements or the enabler of a beautiful dashboard that tells the story of your app. Plan your logging platform from day 1: how logs are collected, stored and analyzed to ensure that the desired information (e.g. error rate, following an entire transaction through services and servers, etc) can really be extracted
Otherwise: You end up with a black box that is hard to reason about, then you start re-writing all logging statements to add additional information
🔗 Read More: Increase transparency using smart logging

 5.3. Delegate anything possible (e.g. gzip, SSL) to a reverse proxy
TL;DR: Node is quite bad at doing CPU intensive tasks like gzipping, SSL termination, etc. You should use specialized infrastructure like nginx, HAproxy or cloud vendor services instead
Otherwise: Your poor single thread will stay busy doing infrastructural tasks instead of dealing with your application core and performance will degrade accordingly
🔗 Read More: Delegate anything possible (e.g. gzip, SSL) to a reverse proxy

 5.4. Lock dependencies
TL;DR: Your code must be identical across all environments, but without a special lockfile npm lets dependencies drift across environments. Ensure to commit your package-lock.json so all the environments will be identical
Otherwise: QA will thoroughly test the code and approve a version that will behave differently in production. Even worse, different servers in the same production cluster might run different code
🔗 Read More: Lock dependencies

 5.5. Guard process uptime using the right tool
TL;DR: The process must go on and get restarted upon failures. Modern runtime platforms like Docker-ized platforms (e.g. Kubernetes), and Serverless take care for this automatically. When the app is hosted on a bare metal server, one must take care for a process management tools like systemd. Avoid including a custom process management tool in a modern platform that monitors an app instance (e.g., Kubernetes) - doing so will hide failures from the infrastructure. When the underlying infrastructure is not aware of errors, it can't perform useful mitigation steps like re-placing the instance in a different location
Otherwise: Running dozens of instances without a clear strategy and too many tools together (cluster management, docker, PM2) might lead to DevOps chaos
🔗 Read More: Guard process uptime using the right tool

 5.6. Utilize all CPU cores
TL;DR: At its basic form, a Node app runs on a single CPU core while all others are left idling. It’s your duty to replicate the Node process and utilize all CPUs. Most of the modern run-times platform (e.g., Kubernetes) allow replicating instances of the app but they won't verify that all cores are utilized - this is your duty. If the app is hosted on a bare server, it's also your duty to use some process replication solution (e.g. systemd)
Otherwise: Your app will likely utilize only 25% of its available resources(!) or even less. Note that a typical server has 4 CPU cores or more, naive deployment of Node.js utilizes only 1 (even using PaaS services like AWS beanstalk!)
🔗 Read More: Utilize all CPU cores

 5.7. Create a ‘maintenance endpoint’
TL;DR: Expose a set of system-related information, like memory usage and REPL, etc in a secured API. Although it’s highly recommended to rely on standard and battle-tested tools, some valuable information and operations are easier done using code
Otherwise: You’ll find that you’re performing many “diagnostic deploys” – shipping code to production only to extract some information for diagnostic purposes
🔗 Read More: Create a ‘maintenance endpoint’

 5.8. Discover the unknowns using APM products
📝 #updated
TL;DR: Consider adding another safety layer to the production stack - APM. While the majority of symptoms and causes can be detected using traditional monitoring techniques, in a distributed system there is more than meets the eye. Application monitoring and performance products (a.k.a. APM) can auto-magically go beyond traditional monitoring and provide additional layer of discovery and developer-experience. For example, some APM products can highlight a transaction that loads too slow on the end-user's side while suggesting the root cause. APMs also provide more context for developers who try to troubleshoot a log error by showing what was the server busy with when the error occurred. To name a few example
Otherwise: You might spend great effort on measuring API performance and downtimes, probably you’ll never be aware which is your slowest code parts under real-world scenario and how these affect the UX
🔗 Read More: Discover errors and downtime using APM products

 5.9. Make your code production-ready
TL;DR: Code with the end in mind, plan for production from day 1. This sounds a bit vague so I’ve compiled a few development tips that are closely related to production maintenance (click 'Read More')
Otherwise: A world champion IT/DevOps guy won’t save a system that is badly written
🔗 Read More: Make your code production-ready

 5.10. Measure and guard the memory usage
TL;DR: Node.js has controversial relationships with memory: the v8 engine has soft limits on memory usage (1.4GB) and there are known paths to leak memory in Node’s code – thus watching Node’s process memory is a must. In small apps, you may gauge memory periodically using shell commands but in medium-large apps consider baking your memory watch into a robust monitoring system
Otherwise: Your process memory might leak a hundred megabytes a day like how it happened at Walmart
🔗 Read More: Measure and guard the memory usage

 5.11. Get your frontend assets out of Node
TL;DR: Serve frontend content using a specialized infrastructure (nginx, S3, CDN) because Node performance gets hurt when dealing with many static files due to its single-threaded model. One exception to this guideline is when doing server-side rendering
Otherwise: Your single Node thread will be busy streaming hundreds of html/images/angular/react files instead of allocating all its resources for the task it was born for – serving dynamic content
🔗 Read More: Get your frontend assets out of Node

 5.12. Strive to be stateless
TL;DR: Store any type of data (e.g. user sessions, cache, uploaded files) within external data stores. When the app holds data in-process this adds additional layer of maintenance complexity like routing users to the same instance and higher cost of restarting a process. To enforce and encourage a stateless approach, most modern runtime platforms allows 'reapp-ing' instances periodically
Otherwise: Failure at a given server will result in application downtime instead of just killing a faulty machine. Moreover, scaling-out elasticity will get more challenging due to the reliance on a specific server
🔗 Read More: Be stateless, kill your Servers almost every day

 5.13. Use tools that automatically detect vulnerabilities
TL;DR: Even the most reputable dependencies such as Express have known vulnerabilities (from time to time) that can put a system at risk. This can be easily tamed using community and commercial tools that constantly check for vulnerabilities and warn (locally or at GitHub), some can even patch them immediately
Otherwise: Keeping your code clean from vulnerabilities without dedicated tools will require you to constantly follow online publications about new threats. Quite tedious
🔗 Read More: Use tools that automatically detect vulnerabilities

 5.14. Assign a transaction id to each log statement
TL;DR: Assign the same identifier, transaction-id: uuid(), to each log entry within a single request (also known as correlation-id/tracing-id/request-context). Then when inspecting errors in logs, easily conclude what happened before and after. Node has a built-in mechanism, AsyncLocalStorage, for keeping the same context across asynchronous calls. see code examples inside
Otherwise: Looking at a production error log without the context – what happened before – makes it much harder and slower to reason about the issue
🔗 Read More: Assign ‘TransactionId’ to each log statement

 5.15. Set NODE_ENV=production
TL;DR: Set the environment variable NODE_ENV to ‘production’ or ‘development’ to flag whether production optimizations should get activated – some npm packages determine the current environment and optimize their code for production
Otherwise: Omitting this simple property might greatly degrade performance when dealing with some specific libraries like Express server-side rendering
🔗 Read More: Set NODE_ENV=production

 5.16. Design automated, atomic and zero-downtime deployments
TL;DR: Research shows that teams who perform many deployments lower the probability of severe production issues. Fast and automated deployments that don’t require risky manual steps and service downtime significantly improve the deployment process. You should probably achieve this using Docker combined with CI tools as they became the industry standard for streamlined deployment
Otherwise: Long deployments -> production downtime & human-related error -> team unconfident in making deployment -> fewer deployments and features

 5.17. Use an LTS release of Node.js
TL;DR: Ensure you are using an LTS version of Node.js to receive critical bug fixes, security updates and performance improvements
Otherwise: Newly discovered bugs or vulnerabilities could be used to exploit an application running in production, and your application may become unsupported by various modules and harder to maintain
🔗 Read More: Use an LTS release of Node.js

 5.18. Log to stdout, avoid specifying log destination within the app
📝 #updated
TL;DR: Log destinations should not be hard-coded by developers within the application code, but instead should be defined by the execution environment the application runs in. Developers should write logs to stdout using a logger utility and then let the execution environment (container, server, etc.) pipe the stdout stream to the appropriate destination (i.e. Splunk, Graylog, ElasticSearch, etc.).
Otherwise: If developers set the log routing, less flexibility is left for the ops professional who wishes to customize it. Beyond this, if the app tries to log directly to a remote location (e.g., Elastic Search), in case of panic or crash - further logs that might explain the problem won't arrive
🔗 Read More: Log Routing

 5.19. Install your packages with npm ci
TL;DR: Run npm ci to strictly do a clean install of your dependencies matching package.json and package-lock.json. Obviously production code must use the exact version of the packages that were used for testing. While package-lock.json file sets strict version for dependencies, in case of mismatch with the file package.json, the command 'npm install' will treat package.json as the source of truth. On the other hand, the command 'npm ci' will exit with error in case of mismatch between these files
Otherwise: QA will thoroughly test the code and approve a version that will behave differently in production. Even worse, different servers in the same production cluster might run different code.
🔗 Read More: Use npm ci

⬆ Return to top
6. Security Best Practices



 6.1. Embrace linter security rules
 
TL;DR: Make use of security-related linter plugins such as eslint-plugin-security to catch security vulnerabilities and issues as early as possible, preferably while they're being coded. This can help catching security weaknesses like using eval, invoking a child process or importing a module with a string literal (e.g. user input). Click 'Read more' below to see code examples that will get caught by a security linter
Otherwise: What could have been a straightforward security weakness during development becomes a major issue in production. Also, the project may not follow consistent code security practices, leading to vulnerabilities being introduced, or sensitive secrets committed into remote repositories
🔗 Read More: Lint rules

 6.2. Limit concurrent requests using a middleware

TL;DR: DOS attacks are very popular and relatively easy to conduct. Implement rate limiting using an external service such as cloud load balancers, cloud firewalls, nginx, rate-limiter-flexible package, or (for smaller and less critical apps) a rate-limiting middleware (e.g. express-rate-limit)
Otherwise: An application could be subject to an attack resulting in a denial of service where real users receive a degraded or unavailable service.
🔗 Read More: Implement rate limiting

 6.3 Extract secrets from config files or use packages to encrypt them
 
TL;DR: Never store plain-text secrets in configuration files or source code. Instead, make use of secret-management systems like Vault products, Kubernetes/Docker Secrets, or using environment variables. As a last resort, secrets stored in source control must be encrypted and managed (rolling keys, expiring, auditing, etc). Make use of pre-commit/push hooks to prevent committing secrets accidentally
Otherwise: Source control, even for private repositories, can mistakenly be made public, at which point all secrets are exposed. Access to source control for an external party will inadvertently provide access to related systems (databases, apis, services, etc).
🔗 Read More: Secret management

 6.4. Prevent query injection vulnerabilities with ORM/ODM libraries

TL;DR: To prevent SQL/NoSQL injection and other malicious attacks, always make use of an ORM/ODM or a database library that escapes data or supports named or indexed parameterized queries, and takes care of validating user input for expected types. Never just use JavaScript template strings or string concatenation to inject values into queries as this opens your application to a wide spectrum of vulnerabilities. All the reputable Node.js data access libraries (e.g. Sequelize, Knex, mongoose) have built-in protection against injection attacks.
Otherwise: Unvalidated or unsanitized user input could lead to operator injection when working with MongoDB for NoSQL, and not using a proper sanitization system or ORM will easily allow SQL injection attacks, creating a giant vulnerability.
🔗 Read More: Query injection prevention using ORM/ODM libraries

 6.5. Collection of generic security best practices
TL;DR: This is a collection of security advice that is not related directly to Node.js - the Node implementation is not much different than any other language. Click read more to skim through.
🔗 Read More: Common security best practices

 6.6. Adjust the HTTP response headers for enhanced security

TL;DR: Your application should be using secure headers to prevent attackers from using common attacks like cross-site scripting (XSS), clickjacking and other malicious attacks. These can be configured easily using modules like helmet.
Otherwise: Attackers could perform direct attacks on your application's users, leading to huge security vulnerabilities
🔗 Read More: Using secure headers in your application

 6.7. Constantly and automatically inspect for vulnerable dependencies

TL;DR: With the npm ecosystem it is common to have many dependencies for a project. Dependencies should always be kept in check as new vulnerabilities are found. Use tools like npm audit or snyk to track, monitor and patch vulnerable dependencies. Integrate these tools with your CI setup so you catch a vulnerable dependency before it makes it to production.
Otherwise: An attacker could detect your web framework and attack all its known vulnerabilities.
🔗 Read More: Dependency security

 6.8. Protect Users' Passwords/Secrets using bcrypt or scrypt

TL;DR: Passwords or secrets (e.g. API keys) should be stored using a secure hash + salt function like bcrypt,scrypt, or worst case pbkdf2.
Otherwise: Passwords and secrets that are stored without using a secure function are vulnerable to brute forcing and dictionary attacks that will lead to their disclosure eventually.
🔗 Read More: User Passwords

 6.9. Escape HTML, JS and CSS output

TL;DR: Untrusted data that is sent down to the browser might get executed instead of just being displayed, this is commonly referred as a cross-site-scripting (XSS) attack. Mitigate this by using dedicated libraries that explicitly mark the data as pure content that should never get executed (i.e. encoding, escaping)
Otherwise: An attacker might store malicious JavaScript code in your DB which will then be sent as-is to the poor clients
🔗 Read More: Escape output

 6.10. Validate incoming JSON schemas
 
TL;DR: Validate the incoming requests' body payload and ensure it meets expectations, fail fast if it doesn't. To avoid tedious validation coding within each route you may use lightweight JSON-based validation schemas such as jsonschema or joi
Otherwise: Your generosity and permissive approach greatly increases the attack surface and encourages the attacker to try out many inputs until they find some combination to crash the application
🔗 Read More: Validate incoming JSON schemas

 6.11. Support blocklisting JWTs

TL;DR: When using JSON Web Tokens (for example, with Passport.js), by default there's no mechanism to revoke access from issued tokens. Once you discover some malicious user activity, there's no way to stop them from accessing the system as long as they hold a valid token. Mitigate this by implementing a blocklist of untrusted tokens that are validated on each request.
Otherwise: Expired, or misplaced tokens could be used maliciously by a third party to access an application and impersonate the owner of the token.
🔗 Read More: Blocklist JSON Web Tokens

 6.12. Prevent brute-force attacks against authorization

TL;DR: A simple and powerful technique is to limit authorization attempts using two metrics:

The first is number of consecutive failed attempts by the same user unique ID/name and IP address.
The second is number of failed attempts from an IP address over some long period of time. For example, block an IP address if it makes 100 failed attempts in one day.

Otherwise: An attacker can issue unlimited automated password attempts to gain access to privileged accounts on an application
🔗 Read More: Login rate limiting

 6.13. Run Node.js as non-root user

TL;DR: There is a common scenario where Node.js runs as a root user with unlimited permissions. For example, this is the default behaviour in Docker containers. It's recommended to create a non-root user and either bake it into the Docker image (examples given below) or run the process on this user's behalf by invoking the container with the flag "-u username"
Otherwise: An attacker who manages to run a script on the server gets unlimited power over the local machine (e.g. change iptable and re-route traffic to their server)
🔗 Read More: Run Node.js as non-root user

 6.14. Limit payload size using a reverse-proxy or a middleware
 
TL;DR: The bigger the body payload is, the harder your single thread works in processing it. This is an opportunity for attackers to bring servers to their knees without tremendous amount of requests (DOS/DDOS attacks). Mitigate this limiting the body size of incoming requests on the edge (e.g. firewall, ELB) or by configuring express body parser to accept only small-size payloads
Otherwise: Your application will have to deal with large requests, unable to process the other important work it has to accomplish, leading to performance implications and vulnerability towards DOS attacks
🔗 Read More: Limit payload size

 6.15. Avoid JavaScript eval statements
  
TL;DR: eval is evil as it allows executing custom JavaScript code during run time. This is not just a performance concern but also an important security concern due to malicious JavaScript code that may be sourced from user input. Another language feature that should be avoided is new Function constructor. setTimeout and setInterval should never be passed dynamic JavaScript code either.
Otherwise: Malicious JavaScript code finds a way into text passed into eval or other real-time evaluating JavaScript language functions, and will gain complete access to JavaScript permissions on the page. This vulnerability is often manifested as an XSS attack.
🔗 Read More: Avoid JavaScript eval statements

 6.16. Prevent evil RegEx from overloading your single thread execution

TL;DR: Regular Expressions, while being handy, pose a real threat to JavaScript applications at large, and the Node.js platform in particular. A user input for text to match might require an outstanding amount of CPU cycles to process. RegEx processing might be inefficient to an extent that a single request that validates 10 words can block the entire event loop for 6 seconds and set the CPU on 🔥. For that reason, prefer third-party validation packages like validator.js instead of writing your own Regex patterns, or make use of safe-regex to detect vulnerable regex patterns
Otherwise: Poorly written regexes could be susceptible to Regular Expression DoS attacks that will block the event loop completely. For example, the popular moment package was found vulnerable with malicious RegEx usage in November of 2017
🔗 Read More: Prevent malicious RegEx

 6.17. Avoid module loading using a variable
  
TL;DR: Avoid requiring/importing another file with a path that was given as parameter due to the concern that it could have originated from user input. This rule can be extended for accessing files in general (i.e. fs.readFile()) or other sensitive resource access with dynamic variables originating from user input. Eslint-plugin-security linter can catch such patterns and warn early enough
Otherwise: Malicious user input could find its way to a parameter that is used to require tampered files, for example, a previously uploaded file on the file system, or access already existing system files.
🔗 Read More: Safe module loading

 6.18. Run unsafe code in a sandbox
  
TL;DR: When tasked to run external code that is given at run-time (e.g. plugin), use any sort of 'sandbox' execution environment that isolates and guards the main code against the plugin. This can be achieved using a dedicated process (e.g. cluster.fork()), serverless environment or dedicated npm packages that act as a sandbox
Otherwise: A plugin can attack through an endless variety of options like infinite loops, memory overloading, and access to sensitive process environment variables
🔗 Read More: Run unsafe code in a sandbox

 6.19. Take extra care when working with child processes
  
TL;DR: Avoid using child processes when possible and validate and sanitize input to mitigate shell injection attacks if you still have to. Prefer using child_process.execFile which by definition will only execute a single command with a set of attributes and will not allow shell parameter expansion.
Otherwise: Naive use of child processes could result in remote command execution or shell injection attacks due to malicious user input passed to an unsanitized system command.
🔗 Read More: Be cautious when working with child processes

 6.20. Hide error details from clients

TL;DR: An integrated express error handler hides the error details by default. However, great are the chances that you implement your own error handling logic with custom Error objects (considered by many as a best practice). If you do so, ensure not to return the entire Error object to the client, which might contain some sensitive application details
Otherwise: Sensitive application details such as server file paths, third party modules in use, and other internal workflows of the application which could be exploited by an attacker, could be leaked from information found in a stack trace
🔗 Read More: Hide error details from client

 6.21. Configure 2FA for npm or Yarn

TL;DR: Any step in the development chain should be protected with MFA (multi-factor authentication), npm/Yarn are a sweet opportunity for attackers who can get their hands on some developer's password. Using developer credentials, attackers can inject malicious code into libraries that are widely installed across projects and services. Maybe even across the web if published in public. Enabling 2-factor-authentication in npm leaves almost zero chances for attackers to alter your package code.
Otherwise: Have you heard about the eslint developer whose password was hijacked?

 6.22. Modify session middleware settings

TL;DR: Each web framework and technology has its known weaknesses - telling an attacker which web framework we use is a great help for them. Using the default settings for session middlewares can expose your app to module- and framework-specific hijacking attacks in a similar way to the X-Powered-By header. Try hiding anything that identifies and reveals your tech stack (E.g. Node.js, express)
Otherwise: Cookies could be sent over insecure connections, and an attacker might use session identification to identify the underlying framework of the web application, as well as module-specific vulnerabilities
🔗 Read More: Cookie and session security

 6.23. Avoid DOS attacks by explicitly setting when a process should crash

TL;DR: The Node process will crash when errors are not handled. Many best practices even recommend to exit even though an error was caught and got handled. Express, for example, will crash on any asynchronous error - unless you wrap routes with a catch clause. This opens a very sweet attack spot for attackers who recognize what input makes the process crash and repeatedly send the same request. There's no instant remedy for this but a few techniques can mitigate the pain: Alert with critical severity anytime a process crashes due to an unhandled error, validate the input and avoid crashing the process due to invalid user input, wrap all routes with a catch and consider not to crash when an error originated within a request (as opposed to what happens globally)
Otherwise: This is just an educated guess: given many Node.js applications, if we try passing an empty JSON body to all POST requests - a handful of applications will crash. At that point, we can just repeat sending the same request to take down the applications with ease

 6.24. Prevent unsafe redirects

TL;DR: Redirects that do not validate user input can enable attackers to launch phishing scams, steal user credentials, and perform other malicious actions.
Otherwise: If an attacker discovers that you are not validating external, user-supplied input, they may exploit this vulnerability by posting specially-crafted links on forums, social media, and other public places to get users to click it.
🔗 Read More: Prevent unsafe redirects

 6.25. Avoid publishing secrets to the npm registry

TL;DR: Precautions should be taken to avoid the risk of accidentally publishing secrets to public npm registries. An .npmignore file can be used to ignore specific files or folders, or the files array in package.json can act as an allow list.
Otherwise: Your project's API keys, passwords or other secrets are open to be abused by anyone who comes across them, which may result in financial loss, impersonation, and other risks.
🔗 Read More: Avoid publishing secrets

 6.26 Inspect for outdated packages
TL;DR: Use your preferred tool (e.g. npm outdated or npm-check-updates) to detect installed outdated packages, inject this check into your CI pipeline and even make a build fail in a severe scenario. For example, a severe scenario might be when an installed package is 5 patch commits behind (e.g. local version is 1.3.1 and repository version is 1.3.8) or it is tagged as deprecated by its author - kill the build and prevent deploying this version
Otherwise: Your production will run packages that have been explicitly tagged by their author as risky

 6.27. Import built-in modules using the 'node:' protocol
🌟 #new

TL;DR: Import or require built-in Node.js modules using the 'node protocol' syntax:
import { functionName } from "node:module"; // note that 'node:' prefix
For example:
import { createServer } from "node:http";
This style ensures that there is no ambiguity with global npm packages and makes it clear for the reader that the code refers to a well-trusted official module. This style can be enforced with the eslint rule 'prefer-node-protocol'
Otherwise: Using the import syntax without 'node:' prefix opens the door for typosquatting attacks where one could mistakenly mistype a module name (e.g., 'event' instead of 'events) and get a malicious package that was built only to trick users into installing them

⬆ Return to top
7. Draft: Performance Best Practices
Our contributors are working on this section. Would you like to join?

 7.1. Don't block the event loop
TL;DR: Avoid CPU intensive tasks as they will block the mostly single-threaded Event Loop and offload those to a dedicated thread, process or even a different technology based on the context.
Otherwise: As the Event Loop is blocked, Node.js will be unable to handle other request thus causing delays for concurrent users. 3000 users are waiting for a response, the content is ready to be served, but one single request blocks the server from dispatching the results back
🔗 Read More: Do not block the event loop

 7.2. Prefer native JS methods over user-land utils like Lodash
TL;DR: It's often more penalising to use utility libraries like lodash and underscore over native methods as it leads to unneeded dependencies and slower performance.
Bear in mind that with the introduction of the new V8 engine alongside the new ES standards, native methods were improved in such a way that it's now about 50% more performant than utility libraries.
Otherwise: You'll have to maintain less performant projects where you could have simply used what was already available or dealt with a few more lines in exchange of a few more files.
🔗 Read More: Native over user land utils

⬆ Return to top
8. Docker Best Practices
🏅 Many thanks to Bret Fisher from whom we learned many of the following practices

 8.1 Use multi-stage builds for leaner and more secure Docker images
TL;DR: Use multi-stage build to copy only necessary production artifacts. A lot of build-time dependencies and files are not needed for running your application. With multi-stage builds these resources can be used during build while the runtime environment contains only what's necessary. Multi-stage builds are an easy way to get rid of overweight and security threats.
Otherwise: Larger images will take longer to build and ship, build-only tools might contain vulnerabilities and secrets only meant for the build phase might be leaked.
Example Dockerfile for multi-stage builds
FROM node:14.4.0 AS build

COPY . .
RUN npm ci && npm run build


FROM node:slim-14.4.0

USER node
EXPOSE 8080

COPY --from=build /home/node/app/dist /home/node/app/package.json /home/node/app/package-lock.json ./
RUN npm ci --production

CMD [ "node", "dist/app.js" ]
🔗 Read More: Use multi-stage builds

 8.2. Bootstrap using node command, avoid npm start
TL;DR: Use CMD ['node','server.js'] to start your app, avoid using npm scripts which don't pass OS signals to the code. This prevents problems with child-processes, signal handling, graceful shutdown and having zombie processes
Update: Starting from npm 7, npm claim to pass signals. We follow and will update accordingly
Otherwise: When no signals are passed, your code will never be notified about shutdowns. Without this, it will lose its chance to close properly possibly losing current requests and/or data
Read More: Bootstrap container using node command, avoid npm start

 8.3. Let the Docker runtime handle replication and uptime
TL;DR: When using a Docker run time orchestrator (e.g., Kubernetes), invoke the Node.js process directly without intermediate process managers or custom code that replicate the process (e.g. PM2, Cluster module). The runtime platform has the highest amount of data and visibility for making placement decision - It knows best how many processes are needed, how to spread them and what to do in case of crashes
Otherwise: Container keeps crashing due to lack of resources will get restarted indefinitely by the process manager. Should Kubernetes be aware of that, it could relocate it to a different roomy instance
🔗 Read More: Let the Docker orchestrator restart and replicate processes

 8.4. Use .dockerignore to prevent leaking secrets
TL;DR: Include a .dockerignore file that filters out common secret files and development artifacts. By doing so, you might prevent secrets from leaking into the image. As a bonus the build time will significantly decrease. Also, ensure not to copy all files recursively rather explicitly choose what should be copied to Docker
Otherwise: Common personal secret files like .env, .aws and .npmrc will be shared with anybody with access to the image (e.g. Docker repository)
🔗 Read More: Use .dockerignore

 8.5. Clean-up dependencies before production
TL;DR: Although Dev-Dependencies are sometimes needed during the build and test life-cycle, eventually the image that is shipped to production should be minimal and clean from development dependencies. Doing so guarantees that only necessary code is shipped and the amount of potential attacks (i.e. attack surface) is minimized. When using multi-stage build (see dedicated bullet) this can be achieved by installing all dependencies first and finally running npm ci --production
Otherwise: Many of the infamous npm security breaches were found within development packages (e.g. eslint-scope)
🔗 Read More: Remove development dependencies

 8.6. Shutdown smartly and gracefully
TL;DR: Handle the process SIGTERM event and clean-up all existing connection and resources. This should be done while responding to ongoing requests. In Dockerized runtimes, shutting down containers is not a rare event, rather a frequent occurrence that happen as part of routine work. Achieving this demands some thoughtful code to orchestrate several moving parts: The load balancer, keep-alive connections, the HTTP server and other resources
Otherwise: Dying immediately means not responding to thousands of disappointed users
🔗 Read More: Graceful shutdown

 8.7. Set memory limits using both Docker and v8
TL;DR: Always configure a memory limit using both Docker and the JavaScript runtime flags. The Docker limit is needed to make thoughtful container placement decision, the --v8's flag max-old-space is needed to kick off the GC on time and prevent under utilization of memory. Practically, set the v8's old space memory to be a just bit less than the container limit
Otherwise: The docker definition is needed to perform thoughtful scaling decision and prevent starving other citizens. Without also defining the v8's limits, it will under utilize the container resources - Without explicit instructions it crashes when utilizing ~50-60% of its host resources
🔗 Read More: Set memory limits using Docker only

 8.8. Plan for efficient caching
TL;DR: Rebuilding a whole docker image from cache can be nearly instantaneous if done correctly. The less updated instructions should be at the top of your Dockerfile and the ones constantly changing (like app code) should be at the bottom.
Otherwise: Docker build will be very long and consume lot of resources even when making tiny changes
🔗 Read More: Leverage caching to reduce build times

 8.9. Use explicit image reference, avoid latest tag
TL;DR: Specify an explicit image digest or versioned label, never refer to latest. Developers are often led to believe that specifying the latest tag will provide them with the most recent image in the repository however this is not the case. Using a digest guarantees that every instance of the service is running exactly the same code.
In addition, referring to an image tag means that the base image is subject to change, as image tags cannot be relied upon for a deterministic install. Instead, if a deterministic install is expected, a SHA256 digest can be used to reference an exact image.
Otherwise: A new version of a base image could be deployed into production with breaking changes, causing unintended application behaviour.
🔗 Read More: Understand image tags and use the "latest" tag with caution

 8.10. Prefer smaller Docker base images
TL;DR: Large images lead to higher exposure to vulnerabilities and increased resource consumption. Using leaner Docker images, such as Slim and Alpine Linux variants, mitigates this issue.
Otherwise: Building, pushing, and pulling images will take longer, unknown attack vectors can be used by malicious actors and more resources are consumed.
🔗 Read More: Prefer smaller images

 8.11. Clean-out build-time secrets, avoid secrets in args
🌟 #new
TL;DR: Avoid secrets leaking from the Docker build environment. A Docker image is typically shared in multiple environment like CI and a registry that are not as sanitized as production. A typical example is an npm token which is usually passed to a dockerfile as argument. This token stays within the image long after it is needed and allows the attacker indefinite access to a private npm registry. This can be avoided by coping a secret file like .npmrc and then removing it using multi-stage build (beware, build history should be deleted as well) or by using Docker build-kit secret feature which leaves zero traces
Otherwise: Everyone with access to the CI and docker registry will also get access to some precious organization secrets as a bonus
🔗 Read More: Clean-out build-time secrets

 8.12. Scan images for multi layers of vulnerabilities
TL;DR: Besides checking code dependencies vulnerabilities also scan the final image that is shipped to production. Docker image scanners check the code dependencies but also the OS binaries. This E2E security scan covers more ground and verifies that no bad guy injected bad things during the build. Consequently, it is recommended running this as the last step before deployment. There are a handful of free and commercial scanners that also provide CI/CD plugins
Otherwise: Your code might be entirely free from vulnerabilities. However it might still get hacked due to vulnerable version of OS-level binaries (e.g. OpenSSL, TarBall) that are commonly being used by applications
🔗 Read More: Scan the entire image before production

 8.13 Clean NODE_MODULE cache
TL;DR: After installing dependencies in a container remove the local cache. It doesn't make any sense to duplicate the dependencies for faster future installs since there won't be any further installs - A Docker image is immutable. Using a single line of code tens of MB (typically 10-50% of the image size) are shaved off
Otherwise: The image that will get shipped to production will weigh 30% more due to files that will never get used
🔗 Read More: Clean NODE_MODULE cache

 8.14. Generic Docker practices
TL;DR: This is a collection of Docker advice that is not related directly to Node.js - the Node implementation is not much different than any other language. Click read more to skim through.
🔗 Read More: Generic Docker practices

 8.15. Lint your Dockerfile
🌟 #new
TL;DR: Linting your Dockerfile is an important step to identify issues in your Dockerfile which differ from best practices. By checking for potential flaws using a specialised Docker linter, performance and security improvements can be easily identified, saving countless hours of wasted time or security issues in production code.
Otherwise: Mistakenly the Dockerfile creator left Root as the production user, and also used an image from unknown source repository. This could be avoided with with just a simple linter.
🔗 Read More: Lint your Dockerfile

⬆ Return to top
Milestones
To maintain this guide and keep it up to date, we are constantly updating and improving the guidelines and best practices with the help of the community. You can follow our milestones and join the working groups if you want to contribute to this project

Translations
All translations are contributed by the community. We will be happy to get any help with either completed, ongoing or new translations!
Completed translations

 Brazilian Portuguese - Courtesy of Marcelo Melo
 Chinese - Courtesy of Matt Jin
 Russian - Courtesy of Alex Ivanov
 Polish - Courtesy of Michal Biesiada
 Japanese - Courtesy of Yuki Ota, Yuta Azumi
 Basque - Courtesy of Ane Diaz de Tuesta & Joxefe Diaz de Tuesta

Translations in progress

 French (Discussion)
 Hebrew (Discussion)
 Korean - Courtesy of Sangbeom Han (Discussion)
 Spanish (Discussion)
 Turkish (Discussion)


Steering Committee
Meet the steering committee members - the people who work together to provide guidance and future direction to the project. In addition, each member of the committee leads a project tracked under our GitHub projects.

Yoni Goldberg


Independent Node.js consultant who works with customers in the USA, Europe, and Israel on building large-scale Node.js applications. Many of the best practices above were first published at goldbergyoni.com. Reach Yoni at @goldbergyoni or me@goldbergyoni.com


Josh Hemphill



Full Stack Software Engineer / Developer specializing in Security, DevOps/DevSecOps, and ERP Integrations.


Raz Luvaton


Full Stack Developer who knows how to exit from Vim and loves Architecture, Virtualization and Security.

Contributing
If you've ever wanted to contribute to open source, now is your chance! See the contributing docs for more information.
Contributors ✨
Thanks goes to these wonderful people who have contributed to this repository!




  
    
      Kevin Rambaud🖋
      Michael Fine🖋
      Shreya Dahal🖋
      Matheus Cruz Rocha🖋
      Yog Mehta🖋
      Kudakwashe Paradzayi🖋
      t1st3🖋
    
    
      mulijordan1976🖋
      Matan Kushner🖋
      Fabio Hiroki🖋
      James Sumners🖋
      Dan Gamble🖋
      PJ Trainor🖋
      Remek Ambroziak🖋
    
    
      Yoni Jah🖋
      Misha Khokhlov🖋
      Evgeny Orekhov🖋
      -🖋
      Isaac Halvorson🖋
      Vedran Karačić🖋
      lallenlowe🖋
    
    
      Nathan Wells🖋
      Paulo Reis🖋
      syzer🖋
      David Sancho🖋
      Robert Manolea🖋
      Xavier Ho🖋
      Aaron🖋
    
    
      Jan Charles Maghirang Adona🖋
      Allen🖋
      Leonardo Villela🖋
      Michał Załęcki🖋
      Chris Nicola🖋
      Alejandro Corredor🖋
      cwar🖋
    
    
      Yuwei🖋
      Utkarsh Bhatt🖋
      Duarte Mendes🖋
      Jason Kim🖋
      Mitja O.🖋
      Sandro Miguel Marques🖋
      Gabe🖋
    
    
      Ron Gross🖋
      Valeri Karpov🖋
      Sergio Bernal🖋
      Nikola Telkedzhiev🖋
      Vitor Godoy🖋
      Manish Saraan🖋
      Sangbeom Han🖋
    
    
      blackmatch🖋
      Joe Reeve🖋
      Ryan Busby🖋
      Iman Mohamadi🖋
      Sergii Paryzhskyi🖋
      Kapil Patel🖋
      迷渡🖋
    
    
      Hozefa🖋
      Ethan🖋
      Sam🖋
      Arlind🖋
      Teddy Toussaint🖋
      Lewis🖋
      Gabriel Lidenor 🖋
    
    
      Roman🖋
      Francozeira🖋
      Invvard🖋
      Rômulo Garofalo🖋
      Tho Q Luong🖋
      Burak Shen🖋
      Martin Muzatko🖋
    
    
      Jared Collier🖋
      Hilton Meyer🖋
      ChangJoo Park(박창주)🖋
      Masahiro Sakaguchi🖋
      Keith Holliday🖋
      coreyc🖋
      Maximilian Berkmann🖋
    
    
      Douglas Mariano Valero🖋
      Marcelo Melo🖋
      Mehmet Perk🖋
      ryan ouyang🖋
      Shabeer🖋
      Eduard Kyvenko🖋
      Deyvison Rocha🖋
    
    
      George Mamer🖋
      Konstantinos Leimonis🖋
      Oliver Lluberes🌍
      Tien Do🖋
      Ranvir Singh🖋
      Vadim Nicolaev🖋 🌍
      German Gamboa Gonzalez🖋
    
    
      Hafez🖋
      Chandiran🖋
      VinayaSathyanarayana🖋
      Kim Kern🖋
      Kenneth Freitas🖋
      songe🖋
      Kirill Shekhovtsov🖋
    
    
      Serge🖋
      keyrwinz🖋
      Dmitry Nikitenko🖋
      bushuai👀 🖋
      Benjamin Gruenbaum🖋
      Ezequiel🌍
      Juan José Rodríguez🌍
    
    
      Or Bin🖋
      Andreo Vieira🖋
      Michael Solomon🖋
      Jimmy Callin🖋
      Siddharth🖋
      Ryan Smith🖋
      Tom Boettger🖋
    
    
      Joaquín Ormaechea🌍
      dfrzuz🌍
      Victor Homyakov🖋
      Josh🖋 🛡️
      Alec Francis🖋
      arjun6610🖋
      Jan Osch🖋
    
    
      Thiago Rotondo Sampaio🌍
      Alexsey🖋
      Luis A. Acurero🌍
      Lucas Romano🌍
      Denise Case🖋
      Nick Ribal🖋 👀
      0xflotus🖋
    
    
      Jonathan Chen🖋
      Dilan Srilal🖋
      vladthelittleone🌍
      Nik Osvalds🖋
      Daniel Kiss📖
      Forresst🖋
      Jonathan Svenheden🖋
    
    
      AustrisC🖋
      kyeongtae kim🌍
      007🖋
      Ane Diaz de Tuesta🌍 🖋
      YukiOta🌍
      Frazer Smith🖋
      Raz Luvaton🖋
    
    
      Yuta Azumi🖋
      andrewjbarbour🖋
      mr🖋
      Aleksandar🖋
      Owl🖋
      Yedidya Schwartz🖋 💡
      ari🖋
    
    
      Thomas König🖋
      Kalle Lämsä🖋
      Wyatt🖋
      KHADIR Tayeb🖋
      Shankar Regmi🖋
      Shubham🖋
      Lucas Alves🖋
    
    
      Benjamin🖋
      Yeoh Joer🖋
      Miigon🖋
      Rostislav Bogorad🖋
      Flouse🖋
      Tarantini Pereira🖋
      Kazuki Matsuo🖋
    
    
      Adam Smith🖋
      Dohyeon Ko🖋
      Vladislav Legkov🖋
      Kerollos Magdy🖋
      Erez Lieberman🖋
      Breno Macedo🖋
      Fernando Flores🌍
    
    
      Rafael Brito🌍
      Emiliano Peralta🌍
      Shin, SJ🖋
      Benjamin Forster🖋
      Daniele Fedeli🖋
      djob195🖋
      antspk🖋
    
    
      정진영🖋
      kkk-cashwalk🖋
      apainintheneck🖋
      Fajar Budhi Iswanda🖋
      이주호🖋
      Singh🖋
      Alex Dumitru🖋
    
    
      Anton Lykhatskyi🖋
      sangwonlee🖋
      Eugenio Berretta🖋
      soranakk🖋
      고준영🖋 💻
      Guilherme Portella 🖋
      André Esser🖋
    
    
      Scc🌍
      Mauro Accornero🖋
      no-yan🖋
      hodbauer🌍
    
  




Steering Committee Emeriti
Bruno Scheufler

💻 full-stack web engineer, Node.js & GraphQL enthusiast


Kyle Martin


Full Stack Developer & Site Reliability Engineer based in New Zealand, interested in web application security, and architecting and building Node.js applications to perform at global scale.


Kevyn Bruyere

Independent full-stack developer with a taste for Ops and automation.


Sagir Khan



Deep specialist in JavaScript and its ecosystem — React, Node.js, TypeScript, GraphQL, MongoDB, pretty much anything that involves JS/JSON in any layer of the system — building products using the web platform for the world’s most recognized brands. Individual Member of the Node.js Foundation.\n\ngoldbergyoni
    
    /
    
      nodebestpractices
    

    Public
  


        

        
            
    
      

  
                Notifications
    You must be signed in to change notification settings

  

  
              Fork
    10.4k

  

  
        
            
          Star
          102k

  



        
      

        
      
      
        ✅ The Node.js best practices list (July 2024)
      
      
        
        
          twitter.com/nodepractices/
        
      

    
      License
  
    
      
     CC-BY-SA-4.0 license
    
  


    
        
          
          102k
          stars
        
          
          10.4k
          forks
        
          
          Branches
        
          
          Tags
        
          
          Activity
    

      
        
            
            
          Star


        
        
                    Notifications
    You must be signed in to change notification settings

        
        
          

        
      
  




          

  
      
  
    
              
        Code
          


    

      
  
    
              
        Issues
          44


    

      
  
    
              
        Pull requests
          36


    

      
  
    
              
        Actions
          


    

      
  
    
              
        Projects
          0


    

      
  
    
              
        Security
          

    

      
  
    
              
        Insights
          


    


          
  
      
Additional navigation options



  
    
                
  
    
        
    
    
    
        
          
        
      
        
          Code
      

  

        
    
    
    
        
          
        
      
        
          Issues
      

  

        
    
    
    
        
          
        
      
        
          Pull requests
      

  

        
    
    
    
        
          
        
      
        
          Actions
      

  

        
    
    
    
        
          
        
      
        
          Projects
      

  

        
    
    
    
        
          
        
      
        
          Security
      

  

        
    
    
    
        
          
        
      
        
          Insights
      

  

    




      
  



  

  




    
    



    
      
  goldbergyoni/nodebestpractices
  
    

  
        












  
  
      masterBranchesTagsGo to fileCodeFolders and filesNameNameLast commit messageLast commit dateLatest commit History3,916 Commits.github.github  .operations.operations  assetsassets  sectionssections  .all-contributorsrc.all-contributorsrc  .gitignore.gitignore  LICENSELICENSE  README.basque.mdREADME.basque.md  README.brazilian-portuguese.mdREADME.brazilian-portuguese.md  README.chinese.mdREADME.chinese.md  README.french.mdREADME.french.md  README.hebrew.mdREADME.hebrew.md  README.indonesian.mdREADME.indonesian.md  README.japanese.mdREADME.japanese.md  README.korean.mdREADME.korean.md  README.mdREADME.md  README.polish.mdREADME.polish.md  README.russian.mdREADME.russian.md  package.jsonpackage.json  View all filesRepository files navigationREADMECC-BY-SA-4.0 licenseNode.js Best Practices

  



    


 Follow us on Twitter! @nodepractices

Read in a different language: CN, FR, BR, RU, PL, JA, EU (ES, HE, KR and TR in progress! )

🎊 2024 edition is here!


🛰 Modernized to 2024: Tons of text edits, new recommended libraries, and some new best practices


✨ Easily focus on new content: Already visited before? Search for #new or #updated tags for new content only


🔖 Curious to see examples? We have a starter: Visit Practica.js, our application example and boilerplate (beta) to see some practices in action



Welcome! 3 Things You Ought To Know First
1. You are reading dozens of the best Node.js articles - this repository is a summary and curation of the top-ranked content on Node.js best practices, as well as content written here by collaborators
2. It is the largest compilation, and it is growing every week - currently, more than 80 best practices, style guides, and architectural tips are presented. New issues and pull requests are created every day to keep this live book updated. We'd love to see you contributing here, whether that is fixing code mistakes, helping with translations, or suggesting brilliant new ideas. See our writing guidelines here
3. Best practices have additional info - most bullets include a 🔗Read More link that expands on the practice with code examples, quotes from selected blogs, and more information

By Yoni Goldberg
Learn with me: As a consultant, I engage with worldwide teams on various activities like workshops and code reviews. 🎉AND... Hold on, I've just launched my beyond-the-basics testing course, which is on a 🎁 limited-time sale until August 7th

Table of Contents

  
    1. Project Architecture Practices (6)
  
  1.1 Structure your solution by components #strategic #updated
  1.2 Layer your components, keep the web layer within its boundaries #strategic #updated
  1.3 Wrap common utilities as packages, consider publishing
  1.4 Use environment aware, secure and hierarchical config #updated
  1.5 Consider all the consequences when choosing the main framework #new
  1.6 Use TypeScript sparingly and thoughtfully #new


  
    2. Error Handling Practices (12)
  
  2.1 Use Async-Await or promises for async error handling
  2.2 Extend the built-in Error object #strategic #updated
  2.3 Distinguish operational vs programmer errors #strategic #updated
  2.4 Handle errors centrally, not within a middleware #strategic
  2.5 Document API errors using OpenAPI or GraphQL
  2.6 Exit the process gracefully when a stranger comes to town #strategic
  2.7 Use a mature logger to increase errors visibility #updated
  2.8 Test error flows using your favorite test framework #updated
  2.9 Discover errors and downtime using APM products
  2.10 Catch unhandled promise rejections #updated
  2.11 Fail fast, validate arguments using a dedicated library
  2.12 Always await promises before returning to avoid a partial stacktrace #new
  2.13 Subscribe to event emitters 'error' event #new


  
    3. Code Style Practices (12)
  
  3.1 Use ESLint #strategic
  3.2 Use Node.js eslint extension plugins #updated
  3.3 Start a Codeblock's Curly Braces on the Same Line
  3.4 Separate your statements properly
  3.5 Name your functions
  3.6 Use naming conventions for variables, constants, functions and classes
  3.7 Prefer const over let. Ditch the var
  3.8 Require modules first, not inside functions
  3.9 Set an explicit entry point to a module/folder #updated
  3.10 Use the === operator
  3.11 Use Async Await, avoid callbacks #strategic
  3.12 Use arrow function expressions (=>)
  3.13 Avoid effects outside of functions #new


  
    4. Testing And Overall Quality Practices (13)
  
  4.1 At the very least, write API (component) testing #strategic
  4.2 Include 3 parts in each test name #new
  4.3 Structure tests by the AAA pattern #strategic
  4.4 Ensure Node version is unified #new
  4.5 Avoid global test fixtures and seeds, add data per-test #strategic
  4.6 Tag your tests #advanced
  4.7 Check your test coverage, it helps to identify wrong test patterns
  4.8 Use production-like environment for e2e testing
  4.9 Refactor regularly using static analysis tools
  4.10 Mock responses of external HTTP services #advanced #new #advanced
  4.11 Test your middlewares in isolation
  4.12 Specify a port in production, randomize in testing #new
  4.13 Test the five possible outcomes #strategic #new


  
    5. Going To Production Practices (19)
  
  5.1. Monitoring #strategic
  5.2. Increase the observability using smart logging #strategic
  5.3. Delegate anything possible (e.g. gzip, SSL) to a reverse proxy #strategic
  5.4. Lock dependencies
  5.5. Guard process uptime using the right tool
  5.6. Utilize all CPU cores
  5.7. Create a ‘maintenance endpoint’
  5.8. Discover the unknowns using APM products #advanced #updated
  5.9. Make your code production-ready
  5.10. Measure and guard the memory usage #advanced
  5.11. Get your frontend assets out of Node
  5.12. Strive to be stateless #strategic
  5.13. Use tools that automatically detect vulnerabilities
  5.14. Assign a transaction id to each log statement #advanced
  5.15. Set NODE_ENV=production
  5.16. Design automated, atomic and zero-downtime deployments #advanced
  5.17. Use an LTS release of Node.js
  5.18. Log to stdout, avoid specifying log destination within the app #updated
  5.19. Install your packages with npm ci #new


  
    6. Security Practices (25)
  
  6.1. Embrace linter security rules
  6.2. Limit concurrent requests using a middleware
  6.3 Extract secrets from config files or use packages to encrypt them #strategic
  6.4. Prevent query injection vulnerabilities with ORM/ODM libraries #strategic
  6.5. Collection of generic security best practices
  6.6. Adjust the HTTP response headers for enhanced security
  6.7. Constantly and automatically inspect for vulnerable dependencies #strategic
  6.8. Protect Users' Passwords/Secrets using bcrypt or scrypt #strategic
  6.9. Escape HTML, JS and CSS output
  6.10. Validate incoming JSON schemas #strategic
  6.11. Support blocklisting JWTs
  6.12. Prevent brute-force attacks against authorization #advanced
  6.13. Run Node.js as non-root user
  6.14. Limit payload size using a reverse-proxy or a middleware
  6.15. Avoid JavaScript eval statements
  6.16. Prevent evil RegEx from overloading your single thread execution
  6.17. Avoid module loading using a variable
  6.18. Run unsafe code in a sandbox
  6.19. Take extra care when working with child processes #advanced
  6.20. Hide error details from clients
  6.21. Configure 2FA for npm or Yarn #strategic
  6.22. Modify session middleware settings
  6.23. Avoid DOS attacks by explicitly setting when a process should crash #advanced
  6.24. Prevent unsafe redirects
  6.25. Avoid publishing secrets to the npm registry
  6.26. 6.26 Inspect for outdated packages
  6.27. Import built-in modules using the 'node:' protocol #new


  
    7. Performance Practices (2) (Work In Progress️ ✍️)
  
  7.1. Don't block the event loop
  7.2. Prefer native JS methods over user-land utils like Lodash


  
    8. Docker Practices (15)
  
  8.1 Use multi-stage builds for leaner and more secure Docker images #strategic
  8.2. Bootstrap using node command, avoid npm start
  8.3. Let the Docker runtime handle replication and uptime #strategic
  8.4. Use .dockerignore to prevent leaking secrets
  8.5. Clean-up dependencies before production
  8.6. Shutdown smartly and gracefully #advanced
  8.7. Set memory limits using both Docker and v8 #advanced #strategic
  8.8. Plan for efficient caching
  8.9. Use explicit image reference, avoid latest tag
  8.10. Prefer smaller Docker base images
  8.11. Clean-out build-time secrets, avoid secrets in args #strategic #new
  8.12. Scan images for multi layers of vulnerabilities #advanced
  8.13 Clean NODE_MODULE cache
  8.14. Generic Docker practices
  8.15. Lint your Dockerfile #new


1. Project Architecture Practices
 1.1 Structure your solution by business components
📝 #updated
TL;DR: The root of a system should contain folders or repositories that represent reasonably sized business modules. Each component represents a product domain (i.e., bounded context), like 'user-component', 'order-component', etc. Each component has its own API, logic, and logical database. What is the significant merit? With an autonomous component, every change is performed over a granular and smaller scope - the mental overload, development friction, and deployment fear are much smaller and better. As a result, developers can move much faster. This does not necessarily demand physical separation and can be achieved using a Monorepo or with a multi-repo
my-system
├─ apps (components)
│  ├─ orders
│  ├─ users
│  ├─ payments
├─ libraries (generic cross-component functionality)
│  ├─ logger
│  ├─ authenticator
Otherwise: when artifacts from various modules/topics are mixed together, there are great chances of a tightly-coupled 'spaghetti' system. For example, in an architecture where 'module-a controller' might call 'module-b service', there are no clear modularity borders - every code change might affect anything else. With this approach, developers who code new features struggle to realize the scope and impact of their change. Consequently, they fear breaking other modules, and each deployment becomes slower and riskier
🔗 Read More: structure by components

 1.2 Layer your components with 3-tiers, keep the web layer within its boundaries
📝 #updated
TL;DR: Each component should contain 'layers' - a dedicated folder for common concerns: 'entry-point' where controller lives, 'domain' where the logic lives, and 'data-access'. The primary principle of the most popular architectures is to separate the technical concerns (e.g., HTTP, DB, etc) from the pure logic of the app so a developer can code more features without worrying about infrastructural concerns. Putting each concern in a dedicated folder, also known as the 3-Tier pattern, is the simplest way to meet this goal
my-system
├─ apps (components)
│  ├─ component-a
   │  ├─ entry-points
   │  │  ├─ api # controller comes here
   │  │  ├─ message-queue # message consumer comes here
   │  ├─ domain # features and flows: DTO, services, logic
   │  ├─ data-access # DB calls w/o ORM
Otherwise: It's often seen that developer pass web objects like request/response to functions in the domain/logic layer - this violates the separation principle and makes it harder to access later the logic code by other clients like testing code, scheduled jobs, message queues, etc
🔗 Read More: layer your app

 1.3 Wrap common utilities as packages, consider publishing
TL;DR: Place all reusable modules in a dedicated folder, e.g., "libraries", and underneath each module in its own folder, e.g., "/libraries/logger". Make the module an independent package with its own package.json file to increase the module encapsulation, and allows future publishing to a repository. In a Monorepo setup, modules can be consumed by 'npm linking' to their physical paths, using ts-paths or by publishing and installing from a package manager repository like the npm registry
my-system
├─ apps (components)
  │  ├─ component-a
├─ libraries (generic cross-component functionality)
│  ├─ logger
│  │  ├─ package.json
│  │  ├─ src
│  │  │ ├─ index.js

Otherwise: Clients of a module might import and get coupled to internal functionality of a module. With a package.json at the root, one can set a package.json.main or package.json.exports to explicitly tell which files and functions are part of the public interface
🔗 Read More: Structure by feature

 1.4 Use environment aware, secure and hierarchical config
📝 #updated
TL;DR: A flawless configuration setup should ensure (a) keys can be read from file AND from environment variable (b) secrets are kept outside committed code (c) config is hierarchical for easier findability (d) typing support (e) validation for failing fast (f) Specify default for each key. There are a few packages that can help tick most of those boxes like convict, env-var, zod, and others
Otherwise: Consider a mandatory environment variable that wasn't provided. The app starts successfully and serve requests, some information is already persisted to DB. Then, it's realized that without this mandatory key the request can't complete, leaving the app in a dirty state
🔗 Read More: configuration best practices

 1.5 Consider all the consequences when choosing the main framework
🌟 #new
TL;DR: When building apps and APIs, using a framework is mandatory. It's easy to overlook alternative frameworks or important considerations and then finally land on a sub optimal option. As of 2023/2024, we believe that these four frameworks are worth considering: Nest.js, Fastify, express, and Koa. Click read more below for a detailed pros/cons of each framework. Simplistically, we believe that Nest.js is the best match for teams who wish to go OOP and/or build large-scale apps that can't get partitioned into smaller autonomous components. Fastify is our recommendation for apps with reasonably-sized components (e.g., Microservices) that are built around simple Node.js mechanics. Read our full considerations guide here
Otherwise: Due to the overwhelming amount of considerations, it's easy to make decisions based on partial information and compare apples with oranges. For example, it's believed that Fastify is a minimal web-server that should get compared with express only. In reality, it's a rich framework with many official plugins that cover many concerns
🔗 Read More: Choosing the right framework
 1.6 Use TypeScript sparingly and thoughtfully
🌟 #new
TL;DR: Coding without type safety is no longer an option, TypeScript is the most popular option for this mission. Use it to define variables and functions return types. With that, it is also a double edge sword that can greatly encourage complexity with its additional ~ 50 keywords and sophisticated features. Consider using it sparingly, mostly with simple types, and utilize advanced features only when a real need arises
Otherwise: Researches show that using TypeScript can help in detecting ~20% bugs earlier. Without it, also the developer experience in the IDE is intolerable. On the flip side, 80% of other bugs were not discovered using types. Consequently, typed syntax is valuable but limited. Only efficient tests can discover the whole spectrum of bugs, including type-related bugs. It might also defeat its purpose: sophisticated code features are likely to increase the code complexity, which by itself increases both the amount of bugs and the average bug fix time
🔗 Read More: TypeScript considerations

⬆ Return to top
2. Error Handling Practices
 2.1 Use Async-Await or promises for async error handling
TL;DR: Handling async errors in callback style is probably the fastest way to hell (a.k.a the pyramid of doom). The best gift you can give to your code is using Promises with async-await which enables a much more compact and familiar code syntax like try-catch
Otherwise: Node.js callback style, function(err, response), is a promising way to un-maintainable code due to the mix of error handling with casual code, excessive nesting, and awkward coding patterns
🔗 Read More: avoiding callbacks

 2.2 Extend the built-in Error object
📝 #updated
TL;DR: Some libraries throw errors as a string or as some custom type – this complicates the error handling logic and the interoperability between modules. Instead, create app error object/class that extends the built-in Error object and use it whenever rejecting, throwing or emitting an error. The app error should add useful imperative properties like the error name/code and isCatastrophic. By doing so, all errors have a unified structure and support better error handling. There is no-throw-literal ESLint rule that strictly checks that (although it has some limitations which can be solved when using TypeScript and setting the @typescript-eslint/no-throw-literal rule)
Otherwise: When invoking some component, being uncertain which type of errors come in return – it makes proper error handling much harder. Even worse, using custom types to describe errors might lead to loss of critical error information like the stack trace!
🔗 Read More: using the built-in error object

 2.3 Distinguish catastrophic errors from operational errors
📝 #updated
TL;DR: Operational errors (e.g. API received an invalid input) refer to known cases where the error impact is fully understood and can be handled thoughtfully. On the other hand, catastrophic error (also known as programmer errors) refers to unusual code failures that dictate to gracefully restart the application
Otherwise: You may always restart the application when an error appears, but why let ~5000 online users down because of a minor, predicted, operational error? The opposite is also not ideal – keeping the application up when an unknown catastrophic issue (programmer error) occurred might lead to an unpredicted behavior. Differentiating the two allows acting tactfully and applying a balanced approach based on the given context
🔗 Read More: operational vs programmer error

 2.4 Handle errors centrally, not within a middleware
TL;DR: Error handling logic such as logging, deciding whether to crash and monitoring metrics should be encapsulated in a dedicated and centralized object that all entry-points (e.g. APIs, cron jobs, scheduled jobs) call when an error comes in
Otherwise: Not handling errors within a single place will lead to code duplication and probably to improperly handled errors
🔗 Read More: handling errors in a centralized place

 2.5 Document API errors using OpenAPI or GraphQL
TL;DR: Let your API callers know which errors might come in return so they can handle these thoughtfully without crashing. For RESTful APIs, this is usually done with documentation frameworks like OpenAPI. If you're using GraphQL, you can utilize your schema and comments as well
Otherwise: An API client might decide to crash and restart only because it received back an error it couldn’t understand. Note: the caller of your API might be you (very typical in a microservice environment)
🔗 Read More: documenting API errors in Swagger or GraphQL

 2.6 Exit the process gracefully when a stranger comes to town
TL;DR: When an unknown error occurs (catastrophic error, see best practice 2.3) - there is uncertainty about the application healthiness. In this case, there is no escape from making the error observable, shutting off connections and exiting the process. Any reputable runtime framework like Dockerized services or cloud serverless solutions will take care to restart
Otherwise: When an unfamiliar exception occurs, some object might be in a faulty state (e.g. an event emitter which is used globally and not firing events anymore due to some internal failure) and all future requests might fail or behave crazily
🔗 Read More: shutting the process

 2.7 Use a mature logger to increase errors visibility
📝 #updated
TL;DR: A robust logging tools like Pino or Winston increases the errors visibility using features like log-levels, pretty print coloring and more. Console.log lacks these imperative features and should be avoided. The best in class logger allows attaching custom useful properties to log entries with minimized serialization performance penalty. Developers should write logs to stdout and let the infrastructure pipe the stream to the appropriate log aggregator
Otherwise: Skimming through console.logs or manually through messy text file without querying tools or a decent log viewer might keep you busy at work until late
🔗 Read More: using a mature logger

 2.8 Test error flows using your favorite test framework
📝 #updated
TL;DR: Whether professional automated QA or plain manual developer testing – Ensure that your code not only satisfies positive scenarios but also handles and returns the right errors. On top of this, simulate deeper error flows like uncaught exceptions and ensure that the error handler treat these properly (see code examples within the "read more" section)
Otherwise: Without testing, whether automatically or manually, you can’t rely on your code to return the right errors. Without meaningful errors – there’s no error handling
🔗 Read More: testing error flows

 2.9 Discover errors and downtime using APM products
TL;DR: Monitoring and performance products (a.k.a APM) proactively gauge your codebase or API so they can automagically highlight errors, crashes, and slow parts that you were missing
Otherwise: You might spend great effort on measuring API performance and downtimes, probably you’ll never be aware which are your slowest code parts under real-world scenario and how these affect the UX
🔗 Read More: using APM products

 2.10 Catch unhandled promise rejections
📝 #updated
TL;DR: Any exception thrown within a promise will get swallowed and discarded unless a developer didn’t forget to explicitly handle it. Even if your code is subscribed to process.uncaughtException! Overcome this by registering to the event process.unhandledRejection
Otherwise: Your errors will get swallowed and leave no trace. Nothing to worry about
🔗 Read More: catching unhandled promise rejection

 2.11 Fail fast, validate arguments using a dedicated library
TL;DR: Assert API input to avoid nasty bugs that are much harder to track later. The validation code is usually tedious unless you are using a modern validation library like ajv, zod, or typebox
Otherwise: Consider this – your function expects a numeric argument “Discount” which the caller forgets to pass, later on, your code checks if Discount!=0 (amount of allowed discount is greater than zero), then it will allow the user to enjoy a discount. OMG, what a nasty bug. Can you see it?
🔗 Read More: failing fast

 2.12 Always await promises before returning to avoid a partial stacktrace
🌟 #new
TL;DR: Always do return await when returning a promise to benefit full error stacktrace. If a
function returns a promise, that function must be declared as async function and explicitly
await the promise before returning it
Otherwise: The function that returns a promise without awaiting won't appear in the stacktrace.
Such missing frames would probably complicate the understanding of the flow that leads to the error,
especially if the cause of the abnormal behavior is inside of the missing function
🔗 Read More: returning promises

 2.13 Subscribe to event emitters and streams 'error' event
🌟 #new
TL;DR: Unlike typical functions, a try-catch clause won't get errors that originate from Event Emitters and anything inherited from it (e.g., streams). Instead of try-catch, subscribe to an event emitter's 'error' event so your code can handle the error in context. When dealing with EventTargets (the web standard version of Event Emitters) there are no 'error' event and all errors end in the process.on('error) global event - in this case, at least ensure that the process crash or not based on the desired context. Also, mind that error originating from asynchronous event handlers are not get caught unless the event emitter is initialized with {captureRejections: true}
Otherwise: Event emitters are commonly used for global and key application functionality such as DB or message queue connection. When this kind of crucial objects throw an error, at best the process will crash due to unhandled exception. Even worst, it will stay alive as a zombie while a key functionality is turned off

⬆ Return to top
3. Code Patterns And Style Practices
 3.1 Use ESLint
TL;DR: ESLint is the de-facto standard for checking possible code errors and fixing code style, not only to identify nitty-gritty spacing issues but also to detect serious code anti-patterns like developers throwing errors without classification. Though ESLint can automatically fix code styles, other tools like prettier are more powerful in formatting the fix and work in conjunction with ESLint
Otherwise: Developers will focus on tedious spacing and line-width concerns and time might be wasted overthinking the project's code style
🔗 Read More: Using ESLint and Prettier

 3.2 Use Node.js eslint extension plugins
📝 #updated
TL;DR: On top of ESLint standard rules that cover vanilla JavaScript, add Node.js specific plugins like eslint-plugin-node, eslint-plugin-mocha and eslint-plugin-node-security, eslint-plugin-require, /eslint-plugin-jest and other useful rules
Otherwise: Many faulty Node.js code patterns might escape under the radar. For example, developers might require(variableAsPath) files with a variable given as a path which allows attackers to execute any JS script. Node.js linters can detect such patterns and complain early

 3.3 Start a Codeblock's Curly Braces on the Same Line
TL;DR: The opening curly braces of a code block should be on the same line as the opening statement
Code Example
// Do
function someFunction() {
  // code block
}

// Avoid
function someFunction()
{
  // code block
}
Otherwise: Deferring from this best practice might lead to unexpected results, as seen in the StackOverflow thread below:
🔗 Read more: "Why do results vary based on curly brace placement?" (StackOverflow)

 3.4 Separate your statements properly
No matter if you use semicolons or not to separate your statements, knowing the common pitfalls of improper linebreaks or automatic semicolon insertion, will help you to eliminate regular syntax errors.
TL;DR: Use ESLint to gain awareness about separation concerns. Prettier or Standardjs can automatically resolve these issues.
Otherwise: As seen in the previous section, JavaScript's interpreter automatically adds a semicolon at the end of a statement if there isn't one, or considers a statement as not ended where it should, which might lead to some undesired results. You can use assignments and avoid using immediately invoked function expressions to prevent most of the unexpected errors.
Code example
// Do
function doThing() {
    // ...
}

doThing()

// Do

const items = [1, 2, 3]
items.forEach(console.log)

// Avoid — throws exception
const m = new Map()
const a = [1,2,3]
[...m.values()].forEach(console.log)
> [...m.values()].forEach(console.log)
>  ^^^
> SyntaxError: Unexpected token ...

// Avoid — throws exception
const count = 2 // it tries to run 2(), but 2 is not a function
(function doSomething() {
  // do something amazing
}())
// put a semicolon before the immediate invoked function, after the const definition, save the return value of the anonymous function to a variable or avoid IIFEs altogether
🔗 Read more: "Semi ESLint rule"
🔗 Read more: "No unexpected multiline ESLint rule"

 3.5 Name your functions
TL;DR: Name all functions, including closures and callbacks. Avoid anonymous functions. This is especially useful when profiling a node app. Naming all functions will allow you to easily understand what you're looking at when checking a memory snapshot
Otherwise: Debugging production issues using a core dump (memory snapshot) might become challenging as you notice significant memory consumption from anonymous functions

 3.6 Use naming conventions for variables, constants, functions and classes
TL;DR: Use lowerCamelCase when naming constants, variables and functions, UpperCamelCase (capital first letter as well) when naming classes and UPPER_SNAKE_CASE when naming global or static variables. This will help you to easily distinguish between plain variables, functions, classes that require instantiation and variables declared at global module scope. Use descriptive names, but try to keep them short
Otherwise: JavaScript is the only language in the world that allows invoking a constructor ("Class") directly without instantiating it first. Consequently, Classes and function-constructors are differentiated by starting with UpperCamelCase
3.6 Code Example
// for global variables names we use the const/let keyword and UPPER_SNAKE_CASE
let MUTABLE_GLOBAL = "mutable value";
const GLOBAL_CONSTANT = "immutable value";
const CONFIG = {
  key: "value",
};

// examples of UPPER_SNAKE_CASE convention in nodejs/javascript ecosystem
// in javascript Math.PI module
const PI = 3.141592653589793;

// https://github.com/nodejs/node/blob/b9f36062d7b5c5039498e98d2f2c180dca2a7065/lib/internal/http2/core.js#L303
// in nodejs http2 module
const HTTP_STATUS_OK = 200;
const HTTP_STATUS_CREATED = 201;

// for class name we use UpperCamelCase
class SomeClassExample {
  // for static class properties we use UPPER_SNAKE_CASE
  static STATIC_PROPERTY = "value";
}

// for functions names we use lowerCamelCase
function doSomething() {
  // for scoped variable names we use the const/let keyword and lowerCamelCase
  const someConstExample = "immutable value";
  let someMutableExample = "mutable value";
}

 3.7 Prefer const over let. Ditch the var
TL;DR: Using const means that once a variable is assigned, it cannot be reassigned. Preferring const will help you to not be tempted to use the same variable for different uses, and make your code clearer. If a variable needs to be reassigned, in a for loop, for example, use let to declare it. Another important aspect of let is that a variable declared using it is only available in the block scope in which it was defined. var is function scoped, not block-scoped, and shouldn't be used in ES6 now that you have const and let at your disposal
Otherwise: Debugging becomes way more cumbersome when following a variable that frequently changes
🔗 Read more: JavaScript ES6+: var, let, or const? 

 3.8 Require modules first, not inside functions
TL;DR: Require modules at the beginning of each file, before and outside of any functions. This simple best practice will not only help you easily and quickly tell the dependencies of a file right at the top but also avoids a couple of potential problems
Otherwise: Requires are run synchronously by Node.js. If they are called from within a function, it may block other requests from being handled at a more critical time. Also, if a required module or any of its dependencies throw an error and crash the server, it is best to find out about it as soon as possible, which might not be the case if that module is required from within a function

 3.9 Set an explicit entry point to a module/folder
📝 #updated
TL;DR: When developing a module/library, set an explicit root file that exports the public and interesting code. Discourage the client code from importing deep files and becoming familiar with the internal structure. With commonjs (require), this can be done with an index.js file at the folder's root or the package.json.main field. With ESM (import), if a package.json exists on the root, the field "exports" allow specifying the module's root file. If no package.json exists, you may put an index.js file on the root which re-exports all the public functionality
Otherwise: Having an explicit root file acts like a public 'interface' that encapsulates the internal, directs the caller to the public code and facilitates future changes without breaking the contract
3.9 Code example - avoid coupling the client to the module structure
// Avoid: client has deep familiarity with the internals

// Client code
const SMSWithMedia = require("./SMSProvider/providers/media/media-provider.js");

// Better: explicitly export the public functions

//index.js, module code
module.exports.SMSWithMedia = require("./SMSProvider/providers/media/media-provider.js");

// Client code
const { SMSWithMedia } = require("./SMSProvider");

 3.10 Use the === operator
TL;DR: Prefer the strict equality operator === over the weaker abstract equality operator ==. == will compare two variables after converting them to a common type. There is no type conversion in ===, and both variables must be of the same type to be equal
Otherwise: Unequal variables might return true when compared with the == operator
3.10 Code example
"" == "0"; // false
0 == ""; // true
0 == "0"; // true

false == "false"; // false
false == "0"; // true

false == undefined; // false
false == null; // false
null == undefined; // true

" \t\r\n " == 0; // true
All statements above will return false if used with ===

 3.11 Use Async Await, avoid callbacks
TL;DR: Async-await is the simplest way to express an asynchronous flow as it makes asynchronous code look synchronous. Async-await will also result in much more compact code and support for try-catch. This technique now supersedes callbacks and promises in most cases. Using it in your code is probably the best gift one can give to the code reader
Otherwise: Handling async errors in callback style are probably the fastest way to hell - this style forces to check errors all over, deal with awkward code nesting, and makes it difficult to reason about the code flow
🔗Read more: Guide to async-await 1.0

 3.12 Use arrow function expressions (=>)
TL;DR: Though it's recommended to use async-await and avoid function parameters when dealing with older APIs that accept promises or callbacks - arrow functions make the code structure more compact and keep the lexical context of the root function (i.e. this)
Otherwise: Longer code (in ES5 functions) is more prone to bugs and cumbersome to read
🔗 Read more: It’s Time to Embrace Arrow Functions

 3.13 Avoid effects outside of functions
🌟 #new
TL;DR: Avoid putting code with effects like network or DB calls outside of functions. Such a code will be executed immediately when another file requires the file. This 'floating' code might get executed when the underlying system is not ready yet. It also comes with a performance penalty even when this module's functions will finally not be used in runtime. Last, mocking these DB/network calls for testing is harder outside of functions. Instead, put this code inside functions that should get called explicitly. If some DB/network code must get executed right when the module loads, consider using the factory or revealing module patterns
Otherwise: A typical web framework sets error handler, environment variables and monitoring. When DB/network calls are made before the web framework is initialized, they won't be monitored or fail due to a lack of configuration data

⬆ Return to top
4. Testing And Overall Quality Practices
_We have dedicated guides for testing, see below. The best practices list here is a brief summary of these guides
a. JavaScript testing best practices
b. Node.js testing - beyond the basics
_
 4.1 At the very least, write API (component) testing
TL;DR: Most projects just don't have any automated testing due to short timetables or often the 'testing project' ran out of control and was abandoned. For that reason, prioritize and start with API testing which is the easiest way to write and provides more coverage than unit testing (you may even craft API tests without code using tools like Postman). Afterwards, should you have more resources and time, continue with advanced test types like unit testing, DB testing, performance testing, etc
Otherwise: You may spend long days on writing unit tests to find out that you got only 20% system coverage

 4.2 Include 3 parts in each test name
🌟 #new
TL;DR: Make the test speak at the requirements level so it's self-explanatory also to QA engineers and developers who are not familiar with the code internals. State in the test name what is being tested (unit under test), under what circumstances, and what is the expected result
Otherwise: A deployment just failed, a test named “Add product” failed. Does this tell you what exactly is malfunctioning?
🔗 Read More: Include 3 parts in each test name

 4.3 Structure tests by the AAA pattern
🌟 #new
TL;DR: Structure your tests with 3 well-separated sections: Arrange, Act & Assert (AAA). The first part includes the test setup, then the execution of the unit under test, and finally the assertion phase. Following this structure guarantees that the reader spends no brain CPU on understanding the test plan
Otherwise: Not only you spend long daily hours on understanding the main code, but now also what should have been the simple part of the day (testing) stretches your brain
🔗 Read More: Structure tests by the AAA pattern

 4.4 Ensure Node version is unified
🌟 #new
TL;DR: Use tools that encourage or enforce the same Node.js version across different environments and developers. Tools like nvm, and Volta allow specifying the project's version in a file so each team member can run a single command to conform with the project's version. Optionally, this definition can be replicated to CI and the production runtime (e.g., copy the specified value to .Dockerfile build and to the CI declaration file)
Otherwise: A developer might face or miss an error because she uses a different Node.js version than her teammates. Even worse - the production runtime might be different than the environment where tests were executed

 4.5 Avoid global test fixtures and seeds, add data per-test
TL;DR: To prevent test coupling and easily reason about the test flow, each test should add and act on its own set of DB rows. Whenever a test needs to pull or assume the existence of some DB data - it must explicitly add that data and avoid mutating any other records
Otherwise: Consider a scenario where deployment is aborted due to failing tests, team is now going to spend precious investigation time that ends in a sad conclusion: the system works well, the tests however interfere with each other and break the build
🔗 Read More: Avoid global test fixtures

 4.6 Tag your tests
TL;DR: Different tests must run on different scenarios: quick smoke, IO-less, tests should run when a developer saves or commits a file, full end-to-end tests usually run when a new pull request is submitted, etc. This can be achieved by tagging tests with keywords like #cold #api #sanity so you can grep with your testing harness and invoke the desired subset. For example, this is how you would invoke only the sanity test group with Mocha: mocha --grep 'sanity'
Otherwise: Running all the tests, including tests that perform dozens of DB queries, any time a developer makes a small change can be extremely slow and keeps developers away from running tests

 4.7 Check your test coverage, it helps to identify wrong test patterns
TL;DR: Code coverage tools like Istanbul/NYC are great for 3 reasons: it comes for free (no effort is required to benefit this reports), it helps to identify a decrease in testing coverage, and last but not least it highlights testing mismatches: by looking at colored code coverage reports you may notice, for example, code areas that are never tested like catch clauses (meaning that tests only invoke the happy paths and not how the app behaves on errors). Set it to fail builds if the coverage falls under a certain threshold
Otherwise: There won't be any automated metric telling you when a large portion of your code is not covered by testing

 4.8 Use production-like environment for e2e testing
TL;DR: End to end (e2e) testing which includes live data used to be the weakest link of the CI process as it depends on multiple heavy services like DB. Use an environment which is as close to your real production environment as possible like a-continue (Missed -continue here, needs content. Judging by the Otherwise clause, this should mention docker-compose)
Otherwise: Without docker-compose, teams must maintain a testing DB for each testing environment including developers' machines, keep all those DBs in sync so test results won't vary across environments

 4.9 Refactor regularly using static analysis tools
TL;DR: Using static analysis tools helps by giving objective ways to improve code quality and keeps your code maintainable. You can add static analysis tools to your CI build to fail when it finds code smells. Its main selling points over plain linting are the ability to inspect quality in the context of multiple files (e.g. detect duplications), perform advanced analysis (e.g. code complexity), and follow the history and progress of code issues. Two examples of tools you can use are Sonarqube (2,600+ stars) and Code Climate (1,500+ stars).
Otherwise: With poor code quality, bugs and performance will always be an issue that no shiny new library or state of the art features can fix
🔗 Read More: Refactoring!

 4.10 Mock responses of external HTTP services
🌟 #new
TL;DR: Use network mocking tools to simulate responses of external collaborators' services that are approached over the network (e.g., REST, Graph). This is imperative not only to isolate the component under test but mostly to simulate non-happy path flows. Tools like nock (in-process) or Mock-Server allow defining a specific response of external service in a single line of code. Remember to simulate also errors, delays, timeouts, and any other event that is likely to happen in production
Otherwise: Allowing your component to reach real external services instances will likely result in naive tests that mostly cover happy paths. The tests might also be flaky and slow
🔗 Read More: Mock external services
 4.11 Test your middlewares in isolation
TL;DR: When a middleware holds some immense logic that spans many requests, it is worth testing it in isolation without waking up the entire web framework. This can be easily achieved by stubbing and spying on the {req, res, next} objects
Otherwise: A bug in Express middleware === a bug in all or most requests
🔗 Read More: Test middlewares in isolation
 4.12 Specify a port in production, randomize in testing
🌟 #new
TL;DR: When testing against the API, it's common and desirable to initialize the web server inside the tests. Let the server randomize the web server port in testing to prevent collisions. If you're using Node.js http server (used by most frameworks), doing so demands nothing but passing a port number zero - this will randomize an available port
Otherwise: Specifying a fixed port will prevent two testing processes from running at the same time. Most of the modern test runners run with multiple processes by default
🔗 Read More: Randomize a port for testing
 4.13 Test the five possible outcomes
🌟 #new
TL;DR: When testing a flow, ensure to cover five potential categories. Any time some action is triggered (e.g., API call), a reaction occurs, a meaningful outcome is produced and calls for testing. There are five possible outcome types for every flow: a response, a visible state change (e.g., DB), an outgoing API call, a new message in a queue, and an observability call (e.g., logging, metric). See a checklist here. Each type of outcome comes with unique challenges and techniques to mitigate those challenges - we have a dedicated guide about this topic: Node.js testing - beyond the basics
Otherwise: Consider a case when testing the addition of a new product to the system. It's common to see tests that assert on a valid response only. What if the product was failed to persist regardless of the positive response? what if when adding a new product demands calling some external service, or putting a message in the queue - shouldn't the test assert these outcomes as well? It's easy to overlook various paths, this is where a checklist comes handy
🔗 Read More: Test five outcomes

⬆ Return to top
5. Going To Production Practices
 5.1. Monitoring
TL;DR: Monitoring is a game of finding out issues before customers do – obviously this should be assigned unprecedented importance. The market is overwhelmed with offers thus consider starting with defining the basic metrics you must follow (my suggestions inside), then go over additional fancy features and choose the solution that ticks all boxes. In any case, the 4 layers of observability must be covered: uptime, metrics with focus on user-facing symptoms and Node.js technical metrics like event loop lag, distributed flows measurement with Open Telemetry and logging. Click ‘Read More’ below for an overview of the solutions
Otherwise: Failure === disappointed customers. Simple
🔗 Read More: Monitoring!

 5.2. Increase the observability using smart logging
TL;DR: Logs can be a dumb warehouse of debug statements or the enabler of a beautiful dashboard that tells the story of your app. Plan your logging platform from day 1: how logs are collected, stored and analyzed to ensure that the desired information (e.g. error rate, following an entire transaction through services and servers, etc) can really be extracted
Otherwise: You end up with a black box that is hard to reason about, then you start re-writing all logging statements to add additional information
🔗 Read More: Increase transparency using smart logging

 5.3. Delegate anything possible (e.g. gzip, SSL) to a reverse proxy
TL;DR: Node is quite bad at doing CPU intensive tasks like gzipping, SSL termination, etc. You should use specialized infrastructure like nginx, HAproxy or cloud vendor services instead
Otherwise: Your poor single thread will stay busy doing infrastructural tasks instead of dealing with your application core and performance will degrade accordingly
🔗 Read More: Delegate anything possible (e.g. gzip, SSL) to a reverse proxy

 5.4. Lock dependencies
TL;DR: Your code must be identical across all environments, but without a special lockfile npm lets dependencies drift across environments. Ensure to commit your package-lock.json so all the environments will be identical
Otherwise: QA will thoroughly test the code and approve a version that will behave differently in production. Even worse, different servers in the same production cluster might run different code
🔗 Read More: Lock dependencies

 5.5. Guard process uptime using the right tool
TL;DR: The process must go on and get restarted upon failures. Modern runtime platforms like Docker-ized platforms (e.g. Kubernetes), and Serverless take care for this automatically. When the app is hosted on a bare metal server, one must take care for a process management tools like systemd. Avoid including a custom process management tool in a modern platform that monitors an app instance (e.g., Kubernetes) - doing so will hide failures from the infrastructure. When the underlying infrastructure is not aware of errors, it can't perform useful mitigation steps like re-placing the instance in a different location
Otherwise: Running dozens of instances without a clear strategy and too many tools together (cluster management, docker, PM2) might lead to DevOps chaos
🔗 Read More: Guard process uptime using the right tool

 5.6. Utilize all CPU cores
TL;DR: At its basic form, a Node app runs on a single CPU core while all others are left idling. It’s your duty to replicate the Node process and utilize all CPUs. Most of the modern run-times platform (e.g., Kubernetes) allow replicating instances of the app but they won't verify that all cores are utilized - this is your duty. If the app is hosted on a bare server, it's also your duty to use some process replication solution (e.g. systemd)
Otherwise: Your app will likely utilize only 25% of its available resources(!) or even less. Note that a typical server has 4 CPU cores or more, naive deployment of Node.js utilizes only 1 (even using PaaS services like AWS beanstalk!)
🔗 Read More: Utilize all CPU cores

 5.7. Create a ‘maintenance endpoint’
TL;DR: Expose a set of system-related information, like memory usage and REPL, etc in a secured API. Although it’s highly recommended to rely on standard and battle-tested tools, some valuable information and operations are easier done using code
Otherwise: You’ll find that you’re performing many “diagnostic deploys” – shipping code to production only to extract some information for diagnostic purposes
🔗 Read More: Create a ‘maintenance endpoint’

 5.8. Discover the unknowns using APM products
📝 #updated
TL;DR: Consider adding another safety layer to the production stack - APM. While the majority of symptoms and causes can be detected using traditional monitoring techniques, in a distributed system there is more than meets the eye. Application monitoring and performance products (a.k.a. APM) can auto-magically go beyond traditional monitoring and provide additional layer of discovery and developer-experience. For example, some APM products can highlight a transaction that loads too slow on the end-user's side while suggesting the root cause. APMs also provide more context for developers who try to troubleshoot a log error by showing what was the server busy with when the error occurred. To name a few example
Otherwise: You might spend great effort on measuring API performance and downtimes, probably you’ll never be aware which is your slowest code parts under real-world scenario and how these affect the UX
🔗 Read More: Discover errors and downtime using APM products

 5.9. Make your code production-ready
TL;DR: Code with the end in mind, plan for production from day 1. This sounds a bit vague so I’ve compiled a few development tips that are closely related to production maintenance (click 'Read More')
Otherwise: A world champion IT/DevOps guy won’t save a system that is badly written
🔗 Read More: Make your code production-ready

 5.10. Measure and guard the memory usage
TL;DR: Node.js has controversial relationships with memory: the v8 engine has soft limits on memory usage (1.4GB) and there are known paths to leak memory in Node’s code – thus watching Node’s process memory is a must. In small apps, you may gauge memory periodically using shell commands but in medium-large apps consider baking your memory watch into a robust monitoring system
Otherwise: Your process memory might leak a hundred megabytes a day like how it happened at Walmart
🔗 Read More: Measure and guard the memory usage

 5.11. Get your frontend assets out of Node
TL;DR: Serve frontend content using a specialized infrastructure (nginx, S3, CDN) because Node performance gets hurt when dealing with many static files due to its single-threaded model. One exception to this guideline is when doing server-side rendering
Otherwise: Your single Node thread will be busy streaming hundreds of html/images/angular/react files instead of allocating all its resources for the task it was born for – serving dynamic content
🔗 Read More: Get your frontend assets out of Node

 5.12. Strive to be stateless
TL;DR: Store any type of data (e.g. user sessions, cache, uploaded files) within external data stores. When the app holds data in-process this adds additional layer of maintenance complexity like routing users to the same instance and higher cost of restarting a process. To enforce and encourage a stateless approach, most modern runtime platforms allows 'reapp-ing' instances periodically
Otherwise: Failure at a given server will result in application downtime instead of just killing a faulty machine. Moreover, scaling-out elasticity will get more challenging due to the reliance on a specific server
🔗 Read More: Be stateless, kill your Servers almost every day

 5.13. Use tools that automatically detect vulnerabilities
TL;DR: Even the most reputable dependencies such as Express have known vulnerabilities (from time to time) that can put a system at risk. This can be easily tamed using community and commercial tools that constantly check for vulnerabilities and warn (locally or at GitHub), some can even patch them immediately
Otherwise: Keeping your code clean from vulnerabilities without dedicated tools will require you to constantly follow online publications about new threats. Quite tedious
🔗 Read More: Use tools that automatically detect vulnerabilities

 5.14. Assign a transaction id to each log statement
TL;DR: Assign the same identifier, transaction-id: uuid(), to each log entry within a single request (also known as correlation-id/tracing-id/request-context). Then when inspecting errors in logs, easily conclude what happened before and after. Node has a built-in mechanism, AsyncLocalStorage, for keeping the same context across asynchronous calls. see code examples inside
Otherwise: Looking at a production error log without the context – what happened before – makes it much harder and slower to reason about the issue
🔗 Read More: Assign ‘TransactionId’ to each log statement

 5.15. Set NODE_ENV=production
TL;DR: Set the environment variable NODE_ENV to ‘production’ or ‘development’ to flag whether production optimizations should get activated – some npm packages determine the current environment and optimize their code for production
Otherwise: Omitting this simple property might greatly degrade performance when dealing with some specific libraries like Express server-side rendering
🔗 Read More: Set NODE_ENV=production

 5.16. Design automated, atomic and zero-downtime deployments
TL;DR: Research shows that teams who perform many deployments lower the probability of severe production issues. Fast and automated deployments that don’t require risky manual steps and service downtime significantly improve the deployment process. You should probably achieve this using Docker combined with CI tools as they became the industry standard for streamlined deployment
Otherwise: Long deployments -> production downtime & human-related error -> team unconfident in making deployment -> fewer deployments and features

 5.17. Use an LTS release of Node.js
TL;DR: Ensure you are using an LTS version of Node.js to receive critical bug fixes, security updates and performance improvements
Otherwise: Newly discovered bugs or vulnerabilities could be used to exploit an application running in production, and your application may become unsupported by various modules and harder to maintain
🔗 Read More: Use an LTS release of Node.js

 5.18. Log to stdout, avoid specifying log destination within the app
📝 #updated
TL;DR: Log destinations should not be hard-coded by developers within the application code, but instead should be defined by the execution environment the application runs in. Developers should write logs to stdout using a logger utility and then let the execution environment (container, server, etc.) pipe the stdout stream to the appropriate destination (i.e. Splunk, Graylog, ElasticSearch, etc.).
Otherwise: If developers set the log routing, less flexibility is left for the ops professional who wishes to customize it. Beyond this, if the app tries to log directly to a remote location (e.g., Elastic Search), in case of panic or crash - further logs that might explain the problem won't arrive
🔗 Read More: Log Routing

 5.19. Install your packages with npm ci
TL;DR: Run npm ci to strictly do a clean install of your dependencies matching package.json and package-lock.json. Obviously production code must use the exact version of the packages that were used for testing. While package-lock.json file sets strict version for dependencies, in case of mismatch with the file package.json, the command 'npm install' will treat package.json as the source of truth. On the other hand, the command 'npm ci' will exit with error in case of mismatch between these files
Otherwise: QA will thoroughly test the code and approve a version that will behave differently in production. Even worse, different servers in the same production cluster might run different code.
🔗 Read More: Use npm ci

⬆ Return to top
6. Security Best Practices



 6.1. Embrace linter security rules
 
TL;DR: Make use of security-related linter plugins such as eslint-plugin-security to catch security vulnerabilities and issues as early as possible, preferably while they're being coded. This can help catching security weaknesses like using eval, invoking a child process or importing a module with a string literal (e.g. user input). Click 'Read more' below to see code examples that will get caught by a security linter
Otherwise: What could have been a straightforward security weakness during development becomes a major issue in production. Also, the project may not follow consistent code security practices, leading to vulnerabilities being introduced, or sensitive secrets committed into remote repositories
🔗 Read More: Lint rules

 6.2. Limit concurrent requests using a middleware

TL;DR: DOS attacks are very popular and relatively easy to conduct. Implement rate limiting using an external service such as cloud load balancers, cloud firewalls, nginx, rate-limiter-flexible package, or (for smaller and less critical apps) a rate-limiting middleware (e.g. express-rate-limit)
Otherwise: An application could be subject to an attack resulting in a denial of service where real users receive a degraded or unavailable service.
🔗 Read More: Implement rate limiting

 6.3 Extract secrets from config files or use packages to encrypt them
 
TL;DR: Never store plain-text secrets in configuration files or source code. Instead, make use of secret-management systems like Vault products, Kubernetes/Docker Secrets, or using environment variables. As a last resort, secrets stored in source control must be encrypted and managed (rolling keys, expiring, auditing, etc). Make use of pre-commit/push hooks to prevent committing secrets accidentally
Otherwise: Source control, even for private repositories, can mistakenly be made public, at which point all secrets are exposed. Access to source control for an external party will inadvertently provide access to related systems (databases, apis, services, etc).
🔗 Read More: Secret management

 6.4. Prevent query injection vulnerabilities with ORM/ODM libraries

TL;DR: To prevent SQL/NoSQL injection and other malicious attacks, always make use of an ORM/ODM or a database library that escapes data or supports named or indexed parameterized queries, and takes care of validating user input for expected types. Never just use JavaScript template strings or string concatenation to inject values into queries as this opens your application to a wide spectrum of vulnerabilities. All the reputable Node.js data access libraries (e.g. Sequelize, Knex, mongoose) have built-in protection against injection attacks.
Otherwise: Unvalidated or unsanitized user input could lead to operator injection when working with MongoDB for NoSQL, and not using a proper sanitization system or ORM will easily allow SQL injection attacks, creating a giant vulnerability.
🔗 Read More: Query injection prevention using ORM/ODM libraries

 6.5. Collection of generic security best practices
TL;DR: This is a collection of security advice that is not related directly to Node.js - the Node implementation is not much different than any other language. Click read more to skim through.
🔗 Read More: Common security best practices

 6.6. Adjust the HTTP response headers for enhanced security

TL;DR: Your application should be using secure headers to prevent attackers from using common attacks like cross-site scripting (XSS), clickjacking and other malicious attacks. These can be configured easily using modules like helmet.
Otherwise: Attackers could perform direct attacks on your application's users, leading to huge security vulnerabilities
🔗 Read More: Using secure headers in your application

 6.7. Constantly and automatically inspect for vulnerable dependencies

TL;DR: With the npm ecosystem it is common to have many dependencies for a project. Dependencies should always be kept in check as new vulnerabilities are found. Use tools like npm audit or snyk to track, monitor and patch vulnerable dependencies. Integrate these tools with your CI setup so you catch a vulnerable dependency before it makes it to production.
Otherwise: An attacker could detect your web framework and attack all its known vulnerabilities.
🔗 Read More: Dependency security

 6.8. Protect Users' Passwords/Secrets using bcrypt or scrypt

TL;DR: Passwords or secrets (e.g. API keys) should be stored using a secure hash + salt function like bcrypt,scrypt, or worst case pbkdf2.
Otherwise: Passwords and secrets that are stored without using a secure function are vulnerable to brute forcing and dictionary attacks that will lead to their disclosure eventually.
🔗 Read More: User Passwords

 6.9. Escape HTML, JS and CSS output

TL;DR: Untrusted data that is sent down to the browser might get executed instead of just being displayed, this is commonly referred as a cross-site-scripting (XSS) attack. Mitigate this by using dedicated libraries that explicitly mark the data as pure content that should never get executed (i.e. encoding, escaping)
Otherwise: An attacker might store malicious JavaScript code in your DB which will then be sent as-is to the poor clients
🔗 Read More: Escape output

 6.10. Validate incoming JSON schemas
 
TL;DR: Validate the incoming requests' body payload and ensure it meets expectations, fail fast if it doesn't. To avoid tedious validation coding within each route you may use lightweight JSON-based validation schemas such as jsonschema or joi
Otherwise: Your generosity and permissive approach greatly increases the attack surface and encourages the attacker to try out many inputs until they find some combination to crash the application
🔗 Read More: Validate incoming JSON schemas

 6.11. Support blocklisting JWTs

TL;DR: When using JSON Web Tokens (for example, with Passport.js), by default there's no mechanism to revoke access from issued tokens. Once you discover some malicious user activity, there's no way to stop them from accessing the system as long as they hold a valid token. Mitigate this by implementing a blocklist of untrusted tokens that are validated on each request.
Otherwise: Expired, or misplaced tokens could be used maliciously by a third party to access an application and impersonate the owner of the token.
🔗 Read More: Blocklist JSON Web Tokens

 6.12. Prevent brute-force attacks against authorization

TL;DR: A simple and powerful technique is to limit authorization attempts using two metrics:

The first is number of consecutive failed attempts by the same user unique ID/name and IP address.
The second is number of failed attempts from an IP address over some long period of time. For example, block an IP address if it makes 100 failed attempts in one day.

Otherwise: An attacker can issue unlimited automated password attempts to gain access to privileged accounts on an application
🔗 Read More: Login rate limiting

 6.13. Run Node.js as non-root user

TL;DR: There is a common scenario where Node.js runs as a root user with unlimited permissions. For example, this is the default behaviour in Docker containers. It's recommended to create a non-root user and either bake it into the Docker image (examples given below) or run the process on this user's behalf by invoking the container with the flag "-u username"
Otherwise: An attacker who manages to run a script on the server gets unlimited power over the local machine (e.g. change iptable and re-route traffic to their server)
🔗 Read More: Run Node.js as non-root user

 6.14. Limit payload size using a reverse-proxy or a middleware
 
TL;DR: The bigger the body payload is, the harder your single thread works in processing it. This is an opportunity for attackers to bring servers to their knees without tremendous amount of requests (DOS/DDOS attacks). Mitigate this limiting the body size of incoming requests on the edge (e.g. firewall, ELB) or by configuring express body parser to accept only small-size payloads
Otherwise: Your application will have to deal with large requests, unable to process the other important work it has to accomplish, leading to performance implications and vulnerability towards DOS attacks
🔗 Read More: Limit payload size

 6.15. Avoid JavaScript eval statements
  
TL;DR: eval is evil as it allows executing custom JavaScript code during run time. This is not just a performance concern but also an important security concern due to malicious JavaScript code that may be sourced from user input. Another language feature that should be avoided is new Function constructor. setTimeout and setInterval should never be passed dynamic JavaScript code either.
Otherwise: Malicious JavaScript code finds a way into text passed into eval or other real-time evaluating JavaScript language functions, and will gain complete access to JavaScript permissions on the page. This vulnerability is often manifested as an XSS attack.
🔗 Read More: Avoid JavaScript eval statements

 6.16. Prevent evil RegEx from overloading your single thread execution

TL;DR: Regular Expressions, while being handy, pose a real threat to JavaScript applications at large, and the Node.js platform in particular. A user input for text to match might require an outstanding amount of CPU cycles to process. RegEx processing might be inefficient to an extent that a single request that validates 10 words can block the entire event loop for 6 seconds and set the CPU on 🔥. For that reason, prefer third-party validation packages like validator.js instead of writing your own Regex patterns, or make use of safe-regex to detect vulnerable regex patterns
Otherwise: Poorly written regexes could be susceptible to Regular Expression DoS attacks that will block the event loop completely. For example, the popular moment package was found vulnerable with malicious RegEx usage in November of 2017
🔗 Read More: Prevent malicious RegEx

 6.17. Avoid module loading using a variable
  
TL;DR: Avoid requiring/importing another file with a path that was given as parameter due to the concern that it could have originated from user input. This rule can be extended for accessing files in general (i.e. fs.readFile()) or other sensitive resource access with dynamic variables originating from user input. Eslint-plugin-security linter can catch such patterns and warn early enough
Otherwise: Malicious user input could find its way to a parameter that is used to require tampered files, for example, a previously uploaded file on the file system, or access already existing system files.
🔗 Read More: Safe module loading

 6.18. Run unsafe code in a sandbox
  
TL;DR: When tasked to run external code that is given at run-time (e.g. plugin), use any sort of 'sandbox' execution environment that isolates and guards the main code against the plugin. This can be achieved using a dedicated process (e.g. cluster.fork()), serverless environment or dedicated npm packages that act as a sandbox
Otherwise: A plugin can attack through an endless variety of options like infinite loops, memory overloading, and access to sensitive process environment variables
🔗 Read More: Run unsafe code in a sandbox

 6.19. Take extra care when working with child processes
  
TL;DR: Avoid using child processes when possible and validate and sanitize input to mitigate shell injection attacks if you still have to. Prefer using child_process.execFile which by definition will only execute a single command with a set of attributes and will not allow shell parameter expansion.
Otherwise: Naive use of child processes could result in remote command execution or shell injection attacks due to malicious user input passed to an unsanitized system command.
🔗 Read More: Be cautious when working with child processes

 6.20. Hide error details from clients

TL;DR: An integrated express error handler hides the error details by default. However, great are the chances that you implement your own error handling logic with custom Error objects (considered by many as a best practice). If you do so, ensure not to return the entire Error object to the client, which might contain some sensitive application details
Otherwise: Sensitive application details such as server file paths, third party modules in use, and other internal workflows of the application which could be exploited by an attacker, could be leaked from information found in a stack trace
🔗 Read More: Hide error details from client

 6.21. Configure 2FA for npm or Yarn

TL;DR: Any step in the development chain should be protected with MFA (multi-factor authentication), npm/Yarn are a sweet opportunity for attackers who can get their hands on some developer's password. Using developer credentials, attackers can inject malicious code into libraries that are widely installed across projects and services. Maybe even across the web if published in public. Enabling 2-factor-authentication in npm leaves almost zero chances for attackers to alter your package code.
Otherwise: Have you heard about the eslint developer whose password was hijacked?

 6.22. Modify session middleware settings

TL;DR: Each web framework and technology has its known weaknesses - telling an attacker which web framework we use is a great help for them. Using the default settings for session middlewares can expose your app to module- and framework-specific hijacking attacks in a similar way to the X-Powered-By header. Try hiding anything that identifies and reveals your tech stack (E.g. Node.js, express)
Otherwise: Cookies could be sent over insecure connections, and an attacker might use session identification to identify the underlying framework of the web application, as well as module-specific vulnerabilities
🔗 Read More: Cookie and session security

 6.23. Avoid DOS attacks by explicitly setting when a process should crash

TL;DR: The Node process will crash when errors are not handled. Many best practices even recommend to exit even though an error was caught and got handled. Express, for example, will crash on any asynchronous error - unless you wrap routes with a catch clause. This opens a very sweet attack spot for attackers who recognize what input makes the process crash and repeatedly send the same request. There's no instant remedy for this but a few techniques can mitigate the pain: Alert with critical severity anytime a process crashes due to an unhandled error, validate the input and avoid crashing the process due to invalid user input, wrap all routes with a catch and consider not to crash when an error originated within a request (as opposed to what happens globally)
Otherwise: This is just an educated guess: given many Node.js applications, if we try passing an empty JSON body to all POST requests - a handful of applications will crash. At that point, we can just repeat sending the same request to take down the applications with ease

 6.24. Prevent unsafe redirects

TL;DR: Redirects that do not validate user input can enable attackers to launch phishing scams, steal user credentials, and perform other malicious actions.
Otherwise: If an attacker discovers that you are not validating external, user-supplied input, they may exploit this vulnerability by posting specially-crafted links on forums, social media, and other public places to get users to click it.
🔗 Read More: Prevent unsafe redirects

 6.25. Avoid publishing secrets to the npm registry

TL;DR: Precautions should be taken to avoid the risk of accidentally publishing secrets to public npm registries. An .npmignore file can be used to ignore specific files or folders, or the files array in package.json can act as an allow list.
Otherwise: Your project's API keys, passwords or other secrets are open to be abused by anyone who comes across them, which may result in financial loss, impersonation, and other risks.
🔗 Read More: Avoid publishing secrets

 6.26 Inspect for outdated packages
TL;DR: Use your preferred tool (e.g. npm outdated or npm-check-updates) to detect installed outdated packages, inject this check into your CI pipeline and even make a build fail in a severe scenario. For example, a severe scenario might be when an installed package is 5 patch commits behind (e.g. local version is 1.3.1 and repository version is 1.3.8) or it is tagged as deprecated by its author - kill the build and prevent deploying this version
Otherwise: Your production will run packages that have been explicitly tagged by their author as risky

 6.27. Import built-in modules using the 'node:' protocol
🌟 #new

TL;DR: Import or require built-in Node.js modules using the 'node protocol' syntax:
import { functionName } from "node:module"; // note that 'node:' prefix
For example:
import { createServer } from "node:http";
This style ensures that there is no ambiguity with global npm packages and makes it clear for the reader that the code refers to a well-trusted official module. This style can be enforced with the eslint rule 'prefer-node-protocol'
Otherwise: Using the import syntax without 'node:' prefix opens the door for typosquatting attacks where one could mistakenly mistype a module name (e.g., 'event' instead of 'events) and get a malicious package that was built only to trick users into installing them

⬆ Return to top
7. Draft: Performance Best Practices
Our contributors are working on this section. Would you like to join?

 7.1. Don't block the event loop
TL;DR: Avoid CPU intensive tasks as they will block the mostly single-threaded Event Loop and offload those to a dedicated thread, process or even a different technology based on the context.
Otherwise: As the Event Loop is blocked, Node.js will be unable to handle other request thus causing delays for concurrent users. 3000 users are waiting for a response, the content is ready to be served, but one single request blocks the server from dispatching the results back
🔗 Read More: Do not block the event loop

 7.2. Prefer native JS methods over user-land utils like Lodash
TL;DR: It's often more penalising to use utility libraries like lodash and underscore over native methods as it leads to unneeded dependencies and slower performance.
Bear in mind that with the introduction of the new V8 engine alongside the new ES standards, native methods were improved in such a way that it's now about 50% more performant than utility libraries.
Otherwise: You'll have to maintain less performant projects where you could have simply used what was already available or dealt with a few more lines in exchange of a few more files.
🔗 Read More: Native over user land utils

⬆ Return to top
8. Docker Best Practices
🏅 Many thanks to Bret Fisher from whom we learned many of the following practices

 8.1 Use multi-stage builds for leaner and more secure Docker images
TL;DR: Use multi-stage build to copy only necessary production artifacts. A lot of build-time dependencies and files are not needed for running your application. With multi-stage builds these resources can be used during build while the runtime environment contains only what's necessary. Multi-stage builds are an easy way to get rid of overweight and security threats.
Otherwise: Larger images will take longer to build and ship, build-only tools might contain vulnerabilities and secrets only meant for the build phase might be leaked.
Example Dockerfile for multi-stage builds
FROM node:14.4.0 AS build

COPY . .
RUN npm ci && npm run build


FROM node:slim-14.4.0

USER node
EXPOSE 8080

COPY --from=build /home/node/app/dist /home/node/app/package.json /home/node/app/package-lock.json ./
RUN npm ci --production

CMD [ "node", "dist/app.js" ]
🔗 Read More: Use multi-stage builds

 8.2. Bootstrap using node command, avoid npm start
TL;DR: Use CMD ['node','server.js'] to start your app, avoid using npm scripts which don't pass OS signals to the code. This prevents problems with child-processes, signal handling, graceful shutdown and having zombie processes
Update: Starting from npm 7, npm claim to pass signals. We follow and will update accordingly
Otherwise: When no signals are passed, your code will never be notified about shutdowns. Without this, it will lose its chance to close properly possibly losing current requests and/or data
Read More: Bootstrap container using node command, avoid npm start

 8.3. Let the Docker runtime handle replication and uptime
TL;DR: When using a Docker run time orchestrator (e.g., Kubernetes), invoke the Node.js process directly without intermediate process managers or custom code that replicate the process (e.g. PM2, Cluster module). The runtime platform has the highest amount of data and visibility for making placement decision - It knows best how many processes are needed, how to spread them and what to do in case of crashes
Otherwise: Container keeps crashing due to lack of resources will get restarted indefinitely by the process manager. Should Kubernetes be aware of that, it could relocate it to a different roomy instance
🔗 Read More: Let the Docker orchestrator restart and replicate processes

 8.4. Use .dockerignore to prevent leaking secrets
TL;DR: Include a .dockerignore file that filters out common secret files and development artifacts. By doing so, you might prevent secrets from leaking into the image. As a bonus the build time will significantly decrease. Also, ensure not to copy all files recursively rather explicitly choose what should be copied to Docker
Otherwise: Common personal secret files like .env, .aws and .npmrc will be shared with anybody with access to the image (e.g. Docker repository)
🔗 Read More: Use .dockerignore

 8.5. Clean-up dependencies before production
TL;DR: Although Dev-Dependencies are sometimes needed during the build and test life-cycle, eventually the image that is shipped to production should be minimal and clean from development dependencies. Doing so guarantees that only necessary code is shipped and the amount of potential attacks (i.e. attack surface) is minimized. When using multi-stage build (see dedicated bullet) this can be achieved by installing all dependencies first and finally running npm ci --production
Otherwise: Many of the infamous npm security breaches were found within development packages (e.g. eslint-scope)
🔗 Read More: Remove development dependencies

 8.6. Shutdown smartly and gracefully
TL;DR: Handle the process SIGTERM event and clean-up all existing connection and resources. This should be done while responding to ongoing requests. In Dockerized runtimes, shutting down containers is not a rare event, rather a frequent occurrence that happen as part of routine work. Achieving this demands some thoughtful code to orchestrate several moving parts: The load balancer, keep-alive connections, the HTTP server and other resources
Otherwise: Dying immediately means not responding to thousands of disappointed users
🔗 Read More: Graceful shutdown

 8.7. Set memory limits using both Docker and v8
TL;DR: Always configure a memory limit using both Docker and the JavaScript runtime flags. The Docker limit is needed to make thoughtful container placement decision, the --v8's flag max-old-space is needed to kick off the GC on time and prevent under utilization of memory. Practically, set the v8's old space memory to be a just bit less than the container limit
Otherwise: The docker definition is needed to perform thoughtful scaling decision and prevent starving other citizens. Without also defining the v8's limits, it will under utilize the container resources - Without explicit instructions it crashes when utilizing ~50-60% of its host resources
🔗 Read More: Set memory limits using Docker only

 8.8. Plan for efficient caching
TL;DR: Rebuilding a whole docker image from cache can be nearly instantaneous if done correctly. The less updated instructions should be at the top of your Dockerfile and the ones constantly changing (like app code) should be at the bottom.
Otherwise: Docker build will be very long and consume lot of resources even when making tiny changes
🔗 Read More: Leverage caching to reduce build times

 8.9. Use explicit image reference, avoid latest tag
TL;DR: Specify an explicit image digest or versioned label, never refer to latest. Developers are often led to believe that specifying the latest tag will provide them with the most recent image in the repository however this is not the case. Using a digest guarantees that every instance of the service is running exactly the same code.
In addition, referring to an image tag means that the base image is subject to change, as image tags cannot be relied upon for a deterministic install. Instead, if a deterministic install is expected, a SHA256 digest can be used to reference an exact image.
Otherwise: A new version of a base image could be deployed into production with breaking changes, causing unintended application behaviour.
🔗 Read More: Understand image tags and use the "latest" tag with caution

 8.10. Prefer smaller Docker base images
TL;DR: Large images lead to higher exposure to vulnerabilities and increased resource consumption. Using leaner Docker images, such as Slim and Alpine Linux variants, mitigates this issue.
Otherwise: Building, pushing, and pulling images will take longer, unknown attack vectors can be used by malicious actors and more resources are consumed.
🔗 Read More: Prefer smaller images

 8.11. Clean-out build-time secrets, avoid secrets in args
🌟 #new
TL;DR: Avoid secrets leaking from the Docker build environment. A Docker image is typically shared in multiple environment like CI and a registry that are not as sanitized as production. A typical example is an npm token which is usually passed to a dockerfile as argument. This token stays within the image long after it is needed and allows the attacker indefinite access to a private npm registry. This can be avoided by coping a secret file like .npmrc and then removing it using multi-stage build (beware, build history should be deleted as well) or by using Docker build-kit secret feature which leaves zero traces
Otherwise: Everyone with access to the CI and docker registry will also get access to some precious organization secrets as a bonus
🔗 Read More: Clean-out build-time secrets

 8.12. Scan images for multi layers of vulnerabilities
TL;DR: Besides checking code dependencies vulnerabilities also scan the final image that is shipped to production. Docker image scanners check the code dependencies but also the OS binaries. This E2E security scan covers more ground and verifies that no bad guy injected bad things during the build. Consequently, it is recommended running this as the last step before deployment. There are a handful of free and commercial scanners that also provide CI/CD plugins
Otherwise: Your code might be entirely free from vulnerabilities. However it might still get hacked due to vulnerable version of OS-level binaries (e.g. OpenSSL, TarBall) that are commonly being used by applications
🔗 Read More: Scan the entire image before production

 8.13 Clean NODE_MODULE cache
TL;DR: After installing dependencies in a container remove the local cache. It doesn't make any sense to duplicate the dependencies for faster future installs since there won't be any further installs - A Docker image is immutable. Using a single line of code tens of MB (typically 10-50% of the image size) are shaved off
Otherwise: The image that will get shipped to production will weigh 30% more due to files that will never get used
🔗 Read More: Clean NODE_MODULE cache

 8.14. Generic Docker practices
TL;DR: This is a collection of Docker advice that is not related directly to Node.js - the Node implementation is not much different than any other language. Click read more to skim through.
🔗 Read More: Generic Docker practices

 8.15. Lint your Dockerfile
🌟 #new
TL;DR: Linting your Dockerfile is an important step to identify issues in your Dockerfile which differ from best practices. By checking for potential flaws using a specialised Docker linter, performance and security improvements can be easily identified, saving countless hours of wasted time or security issues in production code.
Otherwise: Mistakenly the Dockerfile creator left Root as the production user, and also used an image from unknown source repository. This could be avoided with with just a simple linter.
🔗 Read More: Lint your Dockerfile

⬆ Return to top
Milestones
To maintain this guide and keep it up to date, we are constantly updating and improving the guidelines and best practices with the help of the community. You can follow our milestones and join the working groups if you want to contribute to this project

Translations
All translations are contributed by the community. We will be happy to get any help with either completed, ongoing or new translations!
Completed translations

 Brazilian Portuguese - Courtesy of Marcelo Melo
 Chinese - Courtesy of Matt Jin
 Russian - Courtesy of Alex Ivanov
 Polish - Courtesy of Michal Biesiada
 Japanese - Courtesy of Yuki Ota, Yuta Azumi
 Basque - Courtesy of Ane Diaz de Tuesta & Joxefe Diaz de Tuesta

Translations in progress

 French (Discussion)
 Hebrew (Discussion)
 Korean - Courtesy of Sangbeom Han (Discussion)
 Spanish (Discussion)
 Turkish (Discussion)


Steering Committee
Meet the steering committee members - the people who work together to provide guidance and future direction to the project. In addition, each member of the committee leads a project tracked under our GitHub projects.

Yoni Goldberg


Independent Node.js consultant who works with customers in the USA, Europe, and Israel on building large-scale Node.js applications. Many of the best practices above were first published at goldbergyoni.com. Reach Yoni at @goldbergyoni or me@goldbergyoni.com


Josh Hemphill



Full Stack Software Engineer / Developer specializing in Security, DevOps/DevSecOps, and ERP Integrations.


Raz Luvaton


Full Stack Developer who knows how to exit from Vim and loves Architecture, Virtualization and Security.

Contributing
If you've ever wanted to contribute to open source, now is your chance! See the contributing docs for more information.
Contributors ✨
Thanks goes to these wonderful people who have contributed to this repository!




  
    
      Kevin Rambaud🖋
      Michael Fine🖋
      Shreya Dahal🖋
      Matheus Cruz Rocha🖋
      Yog Mehta🖋
      Kudakwashe Paradzayi🖋
      t1st3🖋
    
    
      mulijordan1976🖋
      Matan Kushner🖋
      Fabio Hiroki🖋
      James Sumners🖋
      Dan Gamble🖋
      PJ Trainor🖋
      Remek Ambroziak🖋
    
    
      Yoni Jah🖋
      Misha Khokhlov🖋
      Evgeny Orekhov🖋
      -🖋
      Isaac Halvorson🖋
      Vedran Karačić🖋
      lallenlowe🖋
    
    
      Nathan Wells🖋
      Paulo Reis🖋
      syzer🖋
      David Sancho🖋
      Robert Manolea🖋
      Xavier Ho🖋
      Aaron🖋
    
    
      Jan Charles Maghirang Adona🖋
      Allen🖋
      Leonardo Villela🖋
      Michał Załęcki🖋
      Chris Nicola🖋
      Alejandro Corredor🖋
      cwar🖋
    
    
      Yuwei🖋
      Utkarsh Bhatt🖋
      Duarte Mendes🖋
      Jason Kim🖋
      Mitja O.🖋
      Sandro Miguel Marques🖋
      Gabe🖋
    
    
      Ron Gross🖋
      Valeri Karpov🖋
      Sergio Bernal🖋
      Nikola Telkedzhiev🖋
      Vitor Godoy🖋
      Manish Saraan🖋
      Sangbeom Han🖋
    
    
      blackmatch🖋
      Joe Reeve🖋
      Ryan Busby🖋
      Iman Mohamadi🖋
      Sergii Paryzhskyi🖋
      Kapil Patel🖋
      迷渡🖋
    
    
      Hozefa🖋
      Ethan🖋
      Sam🖋
      Arlind🖋
      Teddy Toussaint🖋
      Lewis🖋
      Gabriel Lidenor 🖋
    
    
      Roman🖋
      Francozeira🖋
      Invvard🖋
      Rômulo Garofalo🖋
      Tho Q Luong🖋
      Burak Shen🖋
      Martin Muzatko🖋
    
    
      Jared Collier🖋
      Hilton Meyer🖋
      ChangJoo Park(박창주)🖋
      Masahiro Sakaguchi🖋
      Keith Holliday🖋
      coreyc🖋
      Maximilian Berkmann🖋
    
    
      Douglas Mariano Valero🖋
      Marcelo Melo🖋
      Mehmet Perk🖋
      ryan ouyang🖋
      Shabeer🖋
      Eduard Kyvenko🖋
      Deyvison Rocha🖋
    
    
      George Mamer🖋
      Konstantinos Leimonis🖋
      Oliver Lluberes🌍
      Tien Do🖋
      Ranvir Singh🖋
      Vadim Nicolaev🖋 🌍
      German Gamboa Gonzalez🖋
    
    
      Hafez🖋
      Chandiran🖋
      VinayaSathyanarayana🖋
      Kim Kern🖋
      Kenneth Freitas🖋
      songe🖋
      Kirill Shekhovtsov🖋
    
    
      Serge🖋
      keyrwinz🖋
      Dmitry Nikitenko🖋
      bushuai👀 🖋
      Benjamin Gruenbaum🖋
      Ezequiel🌍
      Juan José Rodríguez🌍
    
    
      Or Bin🖋
      Andreo Vieira🖋
      Michael Solomon🖋
      Jimmy Callin🖋
      Siddharth🖋
      Ryan Smith🖋
      Tom Boettger🖋
    
    
      Joaquín Ormaechea🌍
      dfrzuz🌍
      Victor Homyakov🖋
      Josh🖋 🛡️
      Alec Francis🖋
      arjun6610🖋
      Jan Osch🖋
    
    
      Thiago Rotondo Sampaio🌍
      Alexsey🖋
      Luis A. Acurero🌍
      Lucas Romano🌍
      Denise Case🖋
      Nick Ribal🖋 👀
      0xflotus🖋
    
    
      Jonathan Chen🖋
      Dilan Srilal🖋
      vladthelittleone🌍
      Nik Osvalds🖋
      Daniel Kiss📖
      Forresst🖋
      Jonathan Svenheden🖋
    
    
      AustrisC🖋
      kyeongtae kim🌍
      007🖋
      Ane Diaz de Tuesta🌍 🖋
      YukiOta🌍
      Frazer Smith🖋
      Raz Luvaton🖋
    
    
      Yuta Azumi🖋
      andrewjbarbour🖋
      mr🖋
      Aleksandar🖋
      Owl🖋
      Yedidya Schwartz🖋 💡
      ari🖋
    
    
      Thomas König🖋
      Kalle Lämsä🖋
      Wyatt🖋
      KHADIR Tayeb🖋
      Shankar Regmi🖋
      Shubham🖋
      Lucas Alves🖋
    
    
      Benjamin🖋
      Yeoh Joer🖋
      Miigon🖋
      Rostislav Bogorad🖋
      Flouse🖋
      Tarantini Pereira🖋
      Kazuki Matsuo🖋
    
    
      Adam Smith🖋
      Dohyeon Ko🖋
      Vladislav Legkov🖋
      Kerollos Magdy🖋
      Erez Lieberman🖋
      Breno Macedo🖋
      Fernando Flores🌍
    
    
      Rafael Brito🌍
      Emiliano Peralta🌍
      Shin, SJ🖋
      Benjamin Forster🖋
      Daniele Fedeli🖋
      djob195🖋
      antspk🖋
    
    
      정진영🖋
      kkk-cashwalk🖋
      apainintheneck🖋
      Fajar Budhi Iswanda🖋
      이주호🖋
      Singh🖋
      Alex Dumitru🖋
    
    
      Anton Lykhatskyi🖋
      sangwonlee🖋
      Eugenio Berretta🖋
      soranakk🖋
      고준영🖋 💻
      Guilherme Portella 🖋
      André Esser🖋
    
    
      Scc🌍
      Mauro Accornero🖋
      no-yan🖋
      hodbauer🌍
    
  




Steering Committee Emeriti
Bruno Scheufler

💻 full-stack web engineer, Node.js & GraphQL enthusiast


Kyle Martin


Full Stack Developer & Site Reliability Engineer based in New Zealand, interested in web application security, and architecting and building Node.js applications to perform at global scale.


Kevyn Bruyere

Independent full-stack developer with a taste for Ops and automation.


Sagir Khan



Deep specialist in JavaScript and its ecosystem — React, Node.js, TypeScript, GraphQL, MongoDB, pretty much anything that involves JS/JSON in any layer of the system — building products using the web platform for the world’s most recognized brands. Individual Member of the Node.js Foundation.
   


      

        

      
        
          
            
  About

      
        ✅ The Node.js best practices list (July 2024)
      
      
        
        
          twitter.com/nodepractices/
        
      

    Topics
    
        
      
  nodejs

      
  javascript

      
  testing

      
  npm

      
  styleguide

      
  express

      
  microservices

      
  rest

      
  mocha

      
  types

      
  eslint

      
  es6

      
  jest

      
  style-guide

      
  best-practices

      
  expressjs

      
  node-js

      
  nodejs-development

  

    

    Resources
    
      
        
        Readme
    

  
    License
  
    
      
     CC-BY-SA-4.0 license
    
  




  

  
    
      Activity  


  Stars
  
    
      102k
      stars  

  Watchers
  
    
      1.9k
      watching  

  Forks
  
    
      10.4k
      forks  


    
      
          Report repository
    


          
        

        
        
        
        
        
            
              
                
  Contributors
      230


    
      
          
            
          
          
            
          
          
            
          
          
            
          
          
            
          
          
            
          
          
            
          
          
            
          
          
            
          
          
            
          
          
            
          
          
            
          
          
            
          
          
            
          
      


  
    + 216 contributors
              
            

        
        
            
              
                Languages

  
    
    


    
        
          
          Dockerfile
          87.9%
        
    
    
        
          
          TypeScript
          12.1%\n\n\n\nBuild and ship software on a single, collaborative platformJoin the world’s most widely adopted AI-powered developer platform.Enter your emailSign up for GitHubTry GitHub CopilotGitHub featuresA demonstration animation of a code editor using GitHub Copilot Chat, where the user requests GitHub Copilot to refactor duplicated logic and extract it into a reusable function for a given code snippet.CodePlanCollaborateAutomateSecureCodeBuild code quickly and more securely with GitHub Copilot embedded throughout your workflows.GitHub is used byPauseAccelerate performanceWith GitHub Copilot embedded throughout the platform, you can simplify your toolchain, automate tasks, and improve the developer experience.A Copilot chat window with extensions enabled. The user inputs the @ symbol to reveal a list of five Copilot Extensions. @Sentry is selected from the list, which shifts the window to a chat directly with that extension. There are three sample prompts at the bottom of the chat window, allowing the user to Get incident information, Edit status on incident, or List the latest issues. The last one is activated to send the prompt: @Sentry List the latest issues. The extension then lists several new issues and their metadata.Work 55% faster.Jump to footnote 1 Increase productivity with AI-powered coding assistance, including code completion, chat, and more.Explore GitHub CopilotDuolingo boosts developer speed by 25% with GitHub CopilotRead customer story2024 Gartner® Magic Quadrant™ for AI Code AssistantsRead reportAutomate any workflowOptimize your process with simple and secured CI/CD.A list of workflows displays a heading ‘45,167 workflow runs’ at the top. Below are five rows of completed workflows accompanied by their completion time and their duration formatted in minutes and seconds.Discover GitHub ActionsGet up and running in secondsStart building instantly with a comprehensive dev environment in the cloud.A GitHub Codespaces setup for the landing page of a game called OctoInvaders. On the left is a code editor with some HTML and Javascript files open. On the right is a live render of the page. In front of this split editor window is a screenshot of two active GitHub Codespaces environments with their branch names and a button to ‘Create codespace on main.’Check out GitHub CodespacesBuild on the goManage projects and chat with GitHub Copilot from anywhere.Two smartphone screens side by side. The left screen shows a Notification inbox, listing issues and pull requests from different repositories like TensorFlow and GitHub’s OctoArcade octoinvaders. The right screen shows a new conversation in GitHub Copilot chat.Download GitHub MobileIntegrate the tools you loveSync with 17,000+ integrations and a growing library of Copilot Extensions.A grid of fifty app tiles displays logos for integrations and extensions for companies like Stripe, Slack, and Docker. The tiles extend beyond the bounds of the image to indicate a wide array of apps. Visit GitHub MarketplaceBuilt-in application security  where found means fixedUse AI to find and fix vulnerabilities—freeing your teams to ship more secure software faster.Apply fixes in seconds. Spend less time fixing vulnerabilities and more time building features with Copilot Autofix.Explore GitHub Advanced SecuritySolve security debt. Leverage AI-assisted security campaigns to reduce application vulnerabilities and zero-day attacks.Discover security campaignsDependencies you can depend on. Update vulnerable dependencies with supported fixes for breaking changes.Learn about DependabotYour secrets, your business: protected. Detect, prevent, and remediate leaked secrets across your organization.Read about secret scanning7x fastervulnerability fixes with GitHubJump to footnote 290% coverageof alert types in all supported languages with Copilot AutofixWork together, achieve moreCollaborate with your teams, use management tools that sync with your projects, and code from anywhere—all on a single, integrated platform.Your workflows, your way. Plan effectively with an adaptable spreadsheet that syncs with your work.Jump into GitHub Projects“It helps us onboard new software engineers and get them productive right away. We have all our source code, issues, and pull requests in one place... GitHub is a complete platform that frees us from menial tasks and enables us to do our best work.Fabian FaulhaberApplication manager at Mercedes-BenzKeep track of your tasksCreate issues and manage projects with tools that adapt to your code.Display of task tracking within an issue, showing the status of related sub-issues and their connection to the main issue.Explore GitHub IssuesShare ideas and ask questionsCreate space for open-ended conversations alongside your project.A GitHub Discussions thread where a GitHub user suggests a power-up idea involving Hubot revealing a path and protecting Mona. The post has received 5 upvotes and several reactions. Below, three other users add to the discussion, suggesting Hubot could provide different power-ups depending on levels and appreciating the collaboration idea.Discover GitHub DiscussionsReview code changes togetherCreate review processes that improve code quality and fit neatly into your workflow.Two code review approvals by helios-ackmore and amanda-knox, which are followed by three successful checks for ‘Build,’ ‘Test,’ and ‘Publish.’Learn about code reviewFund open source projectsBecome an open source partner and support the tools and libraries that power your work.A GitHub Sponsors popup displays ‘$15,000 a month’ with a progress bar showing 87% towards a $15,000 goal.Dive into GitHub SponsorsFrom startups to enterprises, GitHub scales  with teams of any size in any industry.By industryBy sizeBy use caseBy industryTechnologyFigma streamlines development and strengthens securityRead customer storyAutomotiveMercedes-Benz standardizes source code and automates onboardingRead customer storyFinancial servicesMercado Libre cuts coding time by 50%Read customer storyExplore customer storiesView all solutionsMillions of developers and businesses call GitHub homeWhether you’re scaling your development process or just learning how to code, GitHub is where you belong. Join the world’s most widely adopted AI-powered developer platform to build the technologies that redefine what’s possible.Enter your emailSign up for GitHubTry GitHub CopilotFootnotesSurvey: The AI wave continues to grow on software development teams, 2024.This 7X times factor is based on data from the industry’s longest running analysis of fix rates Veracode State of Software Security 2023, which cites the average time to fix 50% of flaws as 198 days vs. GitHub’s fix rates of 72% of flaws with in 28 days which is at a minimum of 7X faster when compared.\n\n\n\nSign in to GitHub
    


    



  
    

  
    
      
    
    
      
      {{ message }}

    
  

  



    
      
        
      
    

    
      
  

    
      Username or email address
    
    

  
    
      Password
    
    
    Forgot password?
    













    
  
  
      
  

    


        Password login alternatives
        
            
    
        
    Sign in with a passkey
  

    
  

          
            New to GitHub?
              Create an account\n\n\n\nGitHub CopilotFor businessExtensions TutorialsWhat’s newPlans & pricingNow supercharged with agent modeAI that builds with youGet started for freeSee plans & pricingAlready have  Visual Studio Code? Open nowPauseGitHub Copilot is used byPauseFeaturesAgent mode: Because two brains are better than onePausePauseFrom broken to brilliant, fast. Need to make a sweeping change? Agent mode helps you do it quickly by analyzing code, proposing edits, running tests, and validating results across multiple files.Try agent modePlans the path, handles the work. Agent mode reasons through the problem, coordinates next steps, and applies the changes—while keeping you in the driver’s seat.Don’t sweat the small stuff. From renaming variables to fixing errors, agent mode manages the tedious tasks that might otherwise break your flow.Pick your brainpowerSwap between models like Claude 3.7 Sonnet, OpenAI o1, and Google Gemini 2.0 Flash to crush coding tasks fast or go deep when it counts.Drop an edit. Watch it spreadNext edit suggestions reveal the ripple effects of your changes across your project—helping you keep everything consistent.Try next edit suggestionsYour code’s guardian angelCode review analyzes your work, uncovers hidden bugs, fixes mistakes, and more—before a human ever sees it.Discover code reviewEverything you need, right where you codeThanks to an ecosystem of third-party extensions, Copilot Chat lets you check logs, toggle features, and deploy apps, without ever leaving your editor.Explore extensionsPlansTake flight with GitHub CopilotPricing plansFor individualsFor businessesFreeA fast way to get started with GitHub Copilot.$0USDGet startedOpen in VS CodeWhat's included50 agent mode or chat requests per month2,000 completions per monthAccess to Claude 3.5 Sonnet, GPT-4o, and moreProMost popularUnlimited completions and chats with access to more models.$19$10USDper month or $100 per yearTry for 30 days freeWhat's includedEverything in Free and:Unlimited agent mode and chats with GPT-4oUnlimited code completionsAccess to code review, Claude 3.7 Sonnet, o1, and more6x more premium requests to use latest models than Free, with the option to buy more1Free for verified students, teachers, and maintainers of popular open source projects. Learn morePro+Maximum flexibility and model choice.$39USDper month or $390 per yearGet startedWhat's includedEverything in Pro and:Access to all models, including GPT-4.530x more premium requests to use latest models than Free, with the option to buy more1GitHub Copilot is available on your favorite platforms:GitHub GitHub VS Code VS Code Visual Studio Visual Studio Xcode Xcode JetBrains IDEsJetBrains IDEsNeovim Neovim Azure Data StudioAzure Data StudioEclipse Eclipse Compare all plan featuresGitHub Copilot works where you workCommand the command lineTap into GitHub Copilot in your terminal for instant command-line help.Try Copilot in the CLIStart a chat anywhereUse Copilot Chat on the go with native apps for iOS and Android.Chat in GitHub MobileGet the most out of GitHub CopilotPreview the latest featuresBe the first to explore what’s next for GitHub Copilot.See previewsExplore the GitHub BlogDiscover the latest in software development with insights, best practices, and more.Read BlogVisit the GitHub Copilot Trust CenterGain peace of mind with our security, privacy, and responsible AI policies.Go to Trust CenterFrequently asked questionsGeneralWhat is GitHub Copilot?GitHub Copilot transforms the developer experience. Backed by the leaders in AI, GitHub Copilot provides contextualized assistance throughout the software development lifecycle, from code completions and chat assistance in the IDE to code explanations and answers to docs in GitHub and more. With GitHub Copilot elevating their workflow, developers can focus on: value, innovation, and happiness.GitHub Copilot enables developers to focus more energy on problem solving and collaboration and spend less effort on the mundane and boilerplate. That’s why developers who use GitHub Copilot report up to 75% higher satisfaction with their jobs than those who don’t and are up to 55% more productive at writing code without sacrifice to quality, which all adds up to engaged developers shipping great software faster.GitHub Copilot integrates with leading editors, including Visual Studio Code, Visual Studio, JetBrains IDEs, and Neovim, and, unlike other AI coding assistants, is natively built into GitHub. Growing to millions of individual users and tens of thousands of business customers, GitHub Copilot is the world’s most widely adopted AI developer tool and the competitive advantage developers ask for by name.Who is eligible to access GitHub Copilot for free?GitHub Copilot Free is a new free pricing tier with limited functionality for individual developers. Users assigned a Copilot Business or Copilot Enterprise seat are not eligible for access. Users with access to Copilot Pro through a paid subscription, trial, or through an existing verified OSS, student, faculty, or MVP account may elect to use Free instead. 
What languages, IDEs, and platforms does GitHub Copilot support?GitHub Copilot is trained on all languages that appear in public repositories. For each language, the quality of suggestions you receive may depend on the volume and diversity of training data for that language. For example, JavaScript is well-represented in public repositories and is one of GitHub Copilot’s best supported languages. Languages with less representation in public repositories may produce fewer or less robust suggestions.GitHub Copilot is available as an extension in Visual Studio Code, Visual Studio, Vim, Neovim, the JetBrains suite of IDEs, and Azure Data Studio. Although code completion functionality is available across all these extensions, chat functionality is currently available only in Visual Studio Code, JetBrains, and Visual Studio. GitHub Copilot is also supported in terminals through GitHub CLI and as a chat integration in Windows Terminal Canary. With the GitHub Copilot Enterprise plan, GitHub Copilot is natively integrated into GitHub.com. All plans are supported in GitHub Copilot in GitHub Mobile. GitHub Mobile for Copilot Pro and Copilot Business have access to Bing and public repository code search. Copilot Enterprise in GitHub Mobile gives you additional access to your organization's knowledge.Does GitHub Copilot “copy/paste”?No, GitHub Copilot generates suggestions using probabilistic determination.When thinking about intellectual property and open source issues, it is critical to understand how GitHub Copilot really works. The AI models that create GitHub Copilot’s suggestions may be trained on public code, but do not contain any code. When they generate a suggestion, they are not “copying and pasting” from any codebase.To generate a code suggestion, the GitHub Copilot extension begins by examining the code in your editor—focusing on the lines just before and after your cursor, but also information including other files open in your editor and the URLs of repositories or file paths to identify relevant context. That information is sent to GitHub Copilot’s model, to make a probabilistic determination of what is likely to come next and generate suggestions.To generate a suggestion for chat in the code editor, the GitHub Copilot extension creates a contextual prompt by combining your prompt with additional context including the code file open in your active document, your code selection, and general workspace information, such as frameworks, languages, and dependencies. That information is sent to GitHub Copilot’s model, to make a probabilistic determination of what is likely to come next and generate suggestions.To generate a suggestion for chat on GitHub.com, such as providing an answer to a question from your chat prompt, GitHub Copilot creates a contextual prompt by combining your prompt with additional context including previous prompts, the open pages on GitHub.com as well as retrieved context from your codebase or Bing search. That information is sent to GitHub Copilot’s model, to make a probabilistic determination of what is likely to come next and generate suggestions.  What are the differences between the GitHub Copilot Business, GitHub Copilot Enterprise, and GitHub Copilot Individual plans?GitHub Copilot has multiple offerings for organizations and an offering for individual developers. All the offerings include both code completion and chat assistance. The primary differences between the organization offerings and the individual offering are license management, policy management, and IP indemnity.Organizations can choose between GitHub Copilot Business and GitHub Copilot Enterprise. GitHub Copilot Business primarily features GitHub Copilot in the coding environment - that is the IDE, CLI and GitHub Mobile. GitHub Copilot Enterprise includes everything in GitHub Copilot Business. It also  adds an additional layer of customization for organizations and integrates into GitHub.com as a chat interface to allow developers to converse with GitHub Copilot throughout the platform. GitHub Copilot Enterprise can index an organization’s codebase for a deeper understanding of the customer’s knowledge for more tailored suggestions and will offer customers access to fine-tuned custom, private models for code completion.GitHub Copilot Individual is designed for individual developers, freelancers, students, educators, and open source maintainers. The plan includes all the features of GitHub Copilot Business except organizational license management, policy management, and IP indemnity.What data has GitHub Copilot been trained on?GitHub Copilot is powered by generative AI models developed by GitHub, OpenAI, and Microsoft. It has been trained on natural language text and source code from publicly available sources, including code in public repositories on GitHub.Which plan includes GitHub Copilot Autofix?GitHub Copilot Autofix provides contextual explanations and code suggestions to help developers fix vulnerabilities in code, and is included in GitHub Advanced Security.What if I do not want GitHub Copilot?GitHub Copilot is entirely optional and requires you to opt in before gaining access. You can easily configure its usage directly in the editor, enabling or disabling it at any time. Additionally, you have control over which file types GitHub Copilot is active for.How do I control access to GitHub Copilot in my company?Access to Copilot Business and Enterprise is managed by your GitHub Administrator. They can control access to preview features, models, and set GitHub Copilot policies for your organization. Additionally, you can use your network firewall to explicitly allow access to Copilot Business and/or block access to Copilot Pro or Free. For more details, refer to the documentation.Plans & pricingWhat are the differences between the Free, Pro, Business, and Enterprise plans?GitHub Copilot has multiple offerings for organizations and an offering for individual developers. All the offerings include both code completion and chat assistance. The primary differences between the organization offerings and the individual offering are license management, policy management, and IP indemnity.Organizations can choose between GitHub Copilot Business and GitHub Copilot Enterprise. GitHub Copilot Business primarily features GitHub Copilot in the coding environment - that is the IDE, CLI and GitHub Mobile. GitHub Copilot Enterprise includes everything in GitHub Copilot Business. It also  adds an additional layer of customization for organizations and integrates into GitHub.com as a chat interface to allow developers to converse with Copilot  throughout the platform. GitHub Copilot Enterprise can index an organization’s codebase for a deeper understanding of the customer’s knowledge for more tailored suggestions and will offer customers access to fine-tuned custom, private models for code completion.GitHub Copilot Pro is designed for individual developers, freelancers, students, educators, and open source maintainers. The plan includes all the features of GitHub Copilot Business except organizational license management, policy management, and IP indemnity.How can I upgrade my GitHub Copilot Free license to Copilot Pro?If you're on the Free plan, you can upgrade to Pro through your Copilot settings page or directly on the Copilot marketing page.What is included in GitHub Copilot Free?GitHub Copilot Free users are limited to 2000 completions and 50 chat requests (including Copilot Edits).Which plan includes GitHub Copilot Autofix?GitHub Copilot Autofix provides contextual explanations and code suggestions to help developers fix vulnerabilities in code, and is included in GitHub Advanced Security and available to all public repositories.PrivacyWhat personal data does GitHub Copilot process?GitHub Copilot processes personal data based on how Copilot is accessed and used: whether via GitHub.com, mobile app, extensions, or one of various IDE extensions, or through features like suggestions for the command line interface (CLI), IDE code completions, or personalized chat on GitHub.com. The types of personal data processed may include:User Engagement Data: This includes pseudonymous identifiers captured on user interactions with Copilot, such as accepted or dismissed completions, error messages, system logs, and product usage metrics. Prompts: These are inputs for chat or code, along with context, sent to Copilot's AI to generate suggestions. Suggestions: These are the AI-generated code lines or chat responses provided to users based on their prompts. Feedback Data: This comprises real-time user feedback, including reactions (e.g., thumbs up/down) and optional comments, along with feedback from support tickets.Does GitHub use Copilot Business or Enterprise data to train GitHub’s model?No. GitHub does not use either Copilot Business or Enterprise data to train its models. How does GitHub use the Copilot data?How GitHub uses Copilot data depends on how the user accesses Copilot and for what purpose. Users can access GitHub Copilot through the web, extensions, mobile apps, computer terminal, and various IDEs (Integrated Development Environments). GitHub generally uses personal data to:Deliver, maintain, and update the services as per the customer's configuration and usage, to ensure personalized experiences and recommendationsTroubleshoot, which involves preventing, detecting, resolving, and mitigating issues, including security incidents and product-related problems, by fixing software bugs and maintaining the online services' functionality and up-to-datenessEnhance user productivity, reliability, effectiveness, quality, privacy, accessibility, and security by keeping the service current and operationalThese practices are outlined in GitHub’s Data Protection Agreement (DPA), which details our data handling commitments to our data controller customers. GitHub also uses certain personal data with customer authorization under the DPA, for the following purposes:Billing and account managementTo comply with and resolve legal obligations For abuse detection, prevention, and protection, virus scanning, and scanning to detect violations of terms of serviceTo generate summary reports for calculating employee commissions and partner incentivesTo produce aggregated reports for internal use and strategic planning, covering areas like forecasting, revenue analysis, capacity planning, and product strategy,For details on GitHub's data processing activities as a controller, particularly for Copilot Pro customers, refer to the GitHub Privacy Statement.How long does GitHub retain Copilot data for Business and Enterprise customers? If and for how long GitHub’s retains Copilot data depends on how a Copilot user accesses Copilot and for what purpose. The default settings for Copilot Business and Enterprise Customers are as follows: Access through IDE for Chat and Code Completions:Prompts and Suggestions: Not retainedUser Engagement Data: Kept for two years.Feedback Data: Stored for as long as needed for its intended purpose.All other GitHub Copilot access and use:Prompts and Suggestions: Retained for 28 days.User Engagement Data: Kept for two years.Feedback Data: Stored for as long as needed for its intended purpose.Why do some Copilot features retain prompts and suggestions?Retaining prompts and suggestions is necessary for chat on github.com, mobile, and CLI Copilot because those features’ effectiveness depends on using thread history to improve responses. The Copilot model requires access to previous interactions to deliver accurate and relevant suggestions. Does GitHub Copilot support compliance with the GDPR and other data protection laws?Yes. GitHub and customers can enter a Data Protection Agreement that supports compliance with the GDPR and similar legislation.Does GitHub Copilot ever output personal data?While we've designed GitHub Copilot with privacy in mind, the expansive definition of personal data under legislation like the EU’s General Data Protection Regulation (GDPR) means we can't guarantee it will never output such data. The Large Language Model (LLM) powering GitHub Copilot was trained on public code and there were instances in our tests where the tool made suggestions resembling personal data. These suggestions were typically synthesized and not tied to real individuals. How does Copilot allow users to access, alter or delete personal data?These actions are available to Copilot users as described in the GitHub Privacy Statement.
Responsible AIWhat are the intellectual property considerations when using GitHub Copilot?The primary IP considerations for GitHub Copilot relate to copyright. The model that powers Copilot is trained on a broad collection of publicly accessible code, which may include copyrighted code, and Copilot’s suggestions (in rare instances) may resemble the code its model was trained on. Here’s some basic information you should know about these considerations:Copyright law permits the use of copyrighted works to train AI models:  Countries around the world have provisions in their copyright laws that enable machines to learn, understand, extract patterns, and facts from copyrighted materials, including software code. For example, the European Union, Japan, and Singapore, have express provisions permitting machine learning to develop AI models. Other countries including Canada, India, and the United States also permit such training under their fair use/fair dealing provisions. GitHub Copilot’s AI model was trained with the use of code from GitHub’s public repositories—which are publicly accessible and within the scope of permissible copyright use.What about copyright risk in suggestions? In rare instances (less than 1% based on GitHub’s research), suggestions from GitHub may match examples of code used to train GitHub’s AI model. Again, Copilot does not “look up” or “copy and paste” code, but is instead using context from a user’s workspace to synthesize and generate a suggestion.Our experience shows that matching suggestions are most likely to occur in two situations: (i) when there is little or no context in the code editor for Copilot’s model to synthesize, or (ii) when a matching suggestion represents a common approach or method. If a code suggestion matches existing code, there is risk that using that suggestion could trigger claims of copyright infringement, which would depend on the amount and nature of code used, and the context of how the code is used. In many ways, this is the same risk that arises when using any code that a developer does not originate, such as copying code from an online source, or reusing code from a library. That is why responsible organizations and developers recommend that users employ code scanning policies to identify and evaluate potential matching code.In Copilot, you can opt whether to allow Copilot to suggest code completions that match publicly available code on GitHub.com. For more information, see "Configuring GitHub Copilot settings on GitHub.com". If you have allowed suggestions that match public code, GitHub Copilot can provide you with details about the matching code when you accept such suggestions. Matching code does not necessarily mean copyright infringement, so it is ultimately up to the user to determine whether to use the suggestion, and what and who to attribute (along with other license compliance) in appropriate circumstances.Does GitHub Copilot include a filtering mechanism to mitigate risk?Yes, GitHub Copilot does include an optional code referencing filter to detect and suppress certain suggestions that match public code on GitHub.GitHub has created a duplication detection filter to detect and suppress suggestions that contain code segments over a certain length that match public code on GitHub. This filter can be enabled by the administrator for your enterprise and it can apply for all organizations within your enterprise, or the administrator can defer control to individual organizations. With the filter enabled, Copilot checks code suggestions for matches or near-matches against public code on GitHub of 65 lexemes or more (on average,150 characters). If there is a match, the suggestion will not be shown to the user.In addition to off-topic, harmful, and offensive output filters, GitHub Copilot also scans the outputs for vulnerable code.Does GitHub Copilot include features to make it easier for users to identify potentially relevant open source licenses for matching suggestions?Yes, GitHub Copilot is previewing a code referencing feature as an additional tool to assist users to find and review potentially relevant open source licenses. Code referencing is currently available in Visual Studio Code. This feature searches across public GitHub repositories for code that matches a Copilot suggestion. If there’s a match, users will find its information displayed in the Copilot console log, including where the match occurred, any applicable licenses, and a deep link to learn more. The deep link will take users to a navigable page on GitHub.com to browse examples of the code match and their repository licenses, and see how many repositories—including ones without licenses—that code appears in, as well as links to those repositories. Copilot users can review this information to determine whether the applicable suggestions are suitable for use, and whether additional measures may be necessary to use them.Who owns the suggestions provided by GitHub Copilot?We don’t determine whether a suggestion is capable of being owned, but we are clear that GitHub does not claim ownership of a suggestion. Whether a suggestion generated by an AI model can be owned depends on many factors (e.g. the intellectual property law in the relevant country, the length of the suggestion, the extent that suggestion is considered ‘functional’ instead of expressive, etc).If a suggestion is capable of being owned, our terms are clear: GitHub does not claim ownership.GitHub does not claim ownership of any suggestion. In certain cases, it is possible for Copilot to produce similar suggestions to different users. For example, two unrelated users both starting new files to code the quicksort algorithm in Java will likely get the same suggestion. The possibility of providing similar suggestions to multiple users is a common part of generative AI systems.Can GitHub Copilot introduce insecure code in its suggestions?Public code may contain insecure coding patterns, bugs, or references to outdated APIs or                        idioms. When GitHub Copilot synthesizes code suggestions based on this data, it can also                        synthesize code that contains these undesirable patterns. Copilot has filters in place that                        either block or notify users of insecure code patterns that are detected in Copilot suggestions. These filters target the most common vulnerable coding patterns, including hardcoded credentials, SQL injections, and path injections. Additionally, in recent years we’ve provided tools such as GitHub Advanced Security, GitHub Actions, Dependabot, and CodeQL to open source projects to help improve code quality. Of course, you should always use GitHub Copilot together with good testing and code review practices and security tools, as well as your own judgment.Is GitHub Copilot intended to fully automate code generation and replace developers?No. Copilot is a tool intended to make developers more efficient. It’s not intended to replace developers, who should continue to apply the same sorts of safeguards and diligence they would apply with regard to any third-party code of unknown origin.The product is called “Copilot” not “Autopilot” and it’s not intended to generate code without oversight. You should use exactly the same sorts of safeguards and diligence with Copilot’s suggestions as you would use with any third-party code.Identifying best practices for use of third party code is beyond the scope of this section. That said, whatever practices your organization currently uses – rigorous functionality testing, code scanning, security testing, etc. – you should continue these policies with Copilot’s suggestions. Moreover, you should make sure your code editor or editor does not automatically compile or run generated code before you review it.Can GitHub Copilot users simply use suggestions without concern?Not necessarily. GitHub Copilot users should align their use of Copilot with their respective                        risk tolerances.As noted above, GitHub Copilot is not intended to replace developers, or their individual skill and judgment, and is not intended to fully automate the process of code development. The same risks that apply to the use of any third-party code apply to the use of Copilot’s suggestions.Depending on your particular use case, you should consider implementing the protections discussed above. It is your responsibility to assess what is appropriate for the situation and implement appropriate safeguards.You’re entitled to IP indemnification from GitHub for the unmodified suggestions when Copilot’s filtering is enabled. If you do elect to enable this feature, the copyright responsibility is ours, not our customers. As part of our ongoing commitment to responsible AI, GitHub and Microsoft extends our IP indemnity and protection support to our customers who are empowering their teams with GitHub Copilot. See Microsoft's Copilot Copyright Commitment for more details.Does GitHub Copilot support accessibility features?We are conducting internal testing of GitHub Copilot’s ease of use by developers with                        disabilities and working to ensure that GitHub Copilot is accessible to all developers. Please feel free to share your feedback on GitHub Copilot accessibility in our feedback forum.Does GitHub Copilot produce offensive outputs?GitHub Copilot includes filters to block offensive language in the prompts and to avoid                        synthesizing suggestions in sensitive contexts. We continue to work on improving the filter                        system to more intelligently detect and remove offensive outputs. If you see offensive outputs, please report them directly to copilot-safety@github.com so that we can improve our safeguards. GitHub takes this challenge very seriously and we are committed to addressing it.Will GitHub Copilot work as well using languages other than English?Given public sources are predominantly in English, GitHub Copilot will likely work less well in scenarios where natural language prompts provided by the developer are not in English and/or are grammatically incorrect. Therefore, non-English speakers might experience a lower quality of service.What data has GitHub Copilot been trained on?GitHub Copilot is powered by generative AI models developed by GitHub, OpenAI, and Microsoft. It has been trained on natural language text and source code from publicly available sources, including code in public repositories on GitHub.Data from June 2023. Additional research can be found here.Feature in public beta for Copilot Pro and Business plans. Requires use of repositories, issues, discussions, Actions, and other features of GitHub.Authentication with SAML single sign-on (SSO) available for organizations using GitHub Enterprise Cloud.GeneralPlans & pricingPrivacyResponsible AIGeneralWhat is GitHub Copilot?GitHub Copilot transforms the developer experience. Backed by the leaders in AI, GitHub Copilot provides contextualized assistance throughout the software development lifecycle, from code completions and chat assistance in the IDE to code explanations and answers to docs in GitHub and more. With GitHub Copilot elevating their workflow, developers can focus on: value, innovation, and happiness.GitHub Copilot enables developers to focus more energy on problem solving and collaboration and spend less effort on the mundane and boilerplate. That’s why developers who use GitHub Copilot report up to 75% higher satisfaction with their jobs than those who don’t and are up to 55% more productive at writing code without sacrifice to quality, which all adds up to engaged developers shipping great software faster.GitHub Copilot integrates with leading editors, including Visual Studio Code, Visual Studio, JetBrains IDEs, and Neovim, and, unlike other AI coding assistants, is natively built into GitHub. Growing to millions of individual users and tens of thousands of business customers, GitHub Copilot is the world’s most widely adopted AI developer tool and the competitive advantage developers ask for by name.Who is eligible to access GitHub Copilot for free?GitHub Copilot Free is a new free pricing tier with limited functionality for individual developers. Users assigned a Copilot Business or Copilot Enterprise seat are not eligible for access. Users with access to Copilot Pro through a paid subscription, trial, or through an existing verified OSS, student, faculty, or MVP account may elect to use Free instead. 
What languages, IDEs, and platforms does GitHub Copilot support?GitHub Copilot is trained on all languages that appear in public repositories. For each language, the quality of suggestions you receive may depend on the volume and diversity of training data for that language. For example, JavaScript is well-represented in public repositories and is one of GitHub Copilot’s best supported languages. Languages with less representation in public repositories may produce fewer or less robust suggestions.GitHub Copilot is available as an extension in Visual Studio Code, Visual Studio, Vim, Neovim, the JetBrains suite of IDEs, and Azure Data Studio. Although code completion functionality is available across all these extensions, chat functionality is currently available only in Visual Studio Code, JetBrains, and Visual Studio. GitHub Copilot is also supported in terminals through GitHub CLI and as a chat integration in Windows Terminal Canary. With the GitHub Copilot Enterprise plan, GitHub Copilot is natively integrated into GitHub.com. All plans are supported in GitHub Copilot in GitHub Mobile. GitHub Mobile for Copilot Pro and Copilot Business have access to Bing and public repository code search. Copilot Enterprise in GitHub Mobile gives you additional access to your organization's knowledge.Does GitHub Copilot “copy/paste”?No, GitHub Copilot generates suggestions using probabilistic determination.When thinking about intellectual property and open source issues, it is critical to understand how GitHub Copilot really works. The AI models that create GitHub Copilot’s suggestions may be trained on public code, but do not contain any code. When they generate a suggestion, they are not “copying and pasting” from any codebase.To generate a code suggestion, the GitHub Copilot extension begins by examining the code in your editor—focusing on the lines just before and after your cursor, but also information including other files open in your editor and the URLs of repositories or file paths to identify relevant context. That information is sent to GitHub Copilot’s model, to make a probabilistic determination of what is likely to come next and generate suggestions.To generate a suggestion for chat in the code editor, the GitHub Copilot extension creates a contextual prompt by combining your prompt with additional context including the code file open in your active document, your code selection, and general workspace information, such as frameworks, languages, and dependencies. That information is sent to GitHub Copilot’s model, to make a probabilistic determination of what is likely to come next and generate suggestions.To generate a suggestion for chat on GitHub.com, such as providing an answer to a question from your chat prompt, GitHub Copilot creates a contextual prompt by combining your prompt with additional context including previous prompts, the open pages on GitHub.com as well as retrieved context from your codebase or Bing search. That information is sent to GitHub Copilot’s model, to make a probabilistic determination of what is likely to come next and generate suggestions.  What are the differences between the GitHub Copilot Business, GitHub Copilot Enterprise, and GitHub Copilot Individual plans?GitHub Copilot has multiple offerings for organizations and an offering for individual developers. All the offerings include both code completion and chat assistance. The primary differences between the organization offerings and the individual offering are license management, policy management, and IP indemnity.Organizations can choose between GitHub Copilot Business and GitHub Copilot Enterprise. GitHub Copilot Business primarily features GitHub Copilot in the coding environment - that is the IDE, CLI and GitHub Mobile. GitHub Copilot Enterprise includes everything in GitHub Copilot Business. It also  adds an additional layer of customization for organizations and integrates into GitHub.com as a chat interface to allow developers to converse with GitHub Copilot throughout the platform. GitHub Copilot Enterprise can index an organization’s codebase for a deeper understanding of the customer’s knowledge for more tailored suggestions and will offer customers access to fine-tuned custom, private models for code completion.GitHub Copilot Individual is designed for individual developers, freelancers, students, educators, and open source maintainers. The plan includes all the features of GitHub Copilot Business except organizational license management, policy management, and IP indemnity.What data has GitHub Copilot been trained on?GitHub Copilot is powered by generative AI models developed by GitHub, OpenAI, and Microsoft. It has been trained on natural language text and source code from publicly available sources, including code in public repositories on GitHub.Which plan includes GitHub Copilot Autofix?GitHub Copilot Autofix provides contextual explanations and code suggestions to help developers fix vulnerabilities in code, and is included in GitHub Advanced Security.What if I do not want GitHub Copilot?GitHub Copilot is entirely optional and requires you to opt in before gaining access. You can easily configure its usage directly in the editor, enabling or disabling it at any time. Additionally, you have control over which file types GitHub Copilot is active for.How do I control access to GitHub Copilot in my company?Access to Copilot Business and Enterprise is managed by your GitHub Administrator. They can control access to preview features, models, and set GitHub Copilot policies for your organization. Additionally, you can use your network firewall to explicitly allow access to Copilot Business and/or block access to Copilot Pro or Free. For more details, refer to the documentation.Plans & pricingWhat are the differences between the Free, Pro, Business, and Enterprise plans?GitHub Copilot has multiple offerings for organizations and an offering for individual developers. All the offerings include both code completion and chat assistance. The primary differences between the organization offerings and the individual offering are license management, policy management, and IP indemnity.Organizations can choose between GitHub Copilot Business and GitHub Copilot Enterprise. GitHub Copilot Business primarily features GitHub Copilot in the coding environment - that is the IDE, CLI and GitHub Mobile. GitHub Copilot Enterprise includes everything in GitHub Copilot Business. It also  adds an additional layer of customization for organizations and integrates into GitHub.com as a chat interface to allow developers to converse with Copilot  throughout the platform. GitHub Copilot Enterprise can index an organization’s codebase for a deeper understanding of the customer’s knowledge for more tailored suggestions and will offer customers access to fine-tuned custom, private models for code completion.GitHub Copilot Pro is designed for individual developers, freelancers, students, educators, and open source maintainers. The plan includes all the features of GitHub Copilot Business except organizational license management, policy management, and IP indemnity.How can I upgrade my GitHub Copilot Free license to Copilot Pro?If you're on the Free plan, you can upgrade to Pro through your Copilot settings page or directly on the Copilot marketing page.What is included in GitHub Copilot Free?GitHub Copilot Free users are limited to 2000 completions and 50 chat requests (including Copilot Edits).Which plan includes GitHub Copilot Autofix?GitHub Copilot Autofix provides contextual explanations and code suggestions to help developers fix vulnerabilities in code, and is included in GitHub Advanced Security and available to all public repositories.PrivacyWhat personal data does GitHub Copilot process?GitHub Copilot processes personal data based on how Copilot is accessed and used: whether via GitHub.com, mobile app, extensions, or one of various IDE extensions, or through features like suggestions for the command line interface (CLI), IDE code completions, or personalized chat on GitHub.com. The types of personal data processed may include:User Engagement Data: This includes pseudonymous identifiers captured on user interactions with Copilot, such as accepted or dismissed completions, error messages, system logs, and product usage metrics. Prompts: These are inputs for chat or code, along with context, sent to Copilot's AI to generate suggestions. Suggestions: These are the AI-generated code lines or chat responses provided to users based on their prompts. Feedback Data: This comprises real-time user feedback, including reactions (e.g., thumbs up/down) and optional comments, along with feedback from support tickets.Does GitHub use Copilot Business or Enterprise data to train GitHub’s model?No. GitHub does not use either Copilot Business or Enterprise data to train its models. How does GitHub use the Copilot data?How GitHub uses Copilot data depends on how the user accesses Copilot and for what purpose. Users can access GitHub Copilot through the web, extensions, mobile apps, computer terminal, and various IDEs (Integrated Development Environments). GitHub generally uses personal data to:Deliver, maintain, and update the services as per the customer's configuration and usage, to ensure personalized experiences and recommendationsTroubleshoot, which involves preventing, detecting, resolving, and mitigating issues, including security incidents and product-related problems, by fixing software bugs and maintaining the online services' functionality and up-to-datenessEnhance user productivity, reliability, effectiveness, quality, privacy, accessibility, and security by keeping the service current and operationalThese practices are outlined in GitHub’s Data Protection Agreement (DPA), which details our data handling commitments to our data controller customers. GitHub also uses certain personal data with customer authorization under the DPA, for the following purposes:Billing and account managementTo comply with and resolve legal obligations For abuse detection, prevention, and protection, virus scanning, and scanning to detect violations of terms of serviceTo generate summary reports for calculating employee commissions and partner incentivesTo produce aggregated reports for internal use and strategic planning, covering areas like forecasting, revenue analysis, capacity planning, and product strategy,For details on GitHub's data processing activities as a controller, particularly for Copilot Pro customers, refer to the GitHub Privacy Statement.How long does GitHub retain Copilot data for Business and Enterprise customers? If and for how long GitHub’s retains Copilot data depends on how a Copilot user accesses Copilot and for what purpose. The default settings for Copilot Business and Enterprise Customers are as follows: Access through IDE for Chat and Code Completions:Prompts and Suggestions: Not retainedUser Engagement Data: Kept for two years.Feedback Data: Stored for as long as needed for its intended purpose.All other GitHub Copilot access and use:Prompts and Suggestions: Retained for 28 days.User Engagement Data: Kept for two years.Feedback Data: Stored for as long as needed for its intended purpose.Why do some Copilot features retain prompts and suggestions?Retaining prompts and suggestions is necessary for chat on github.com, mobile, and CLI Copilot because those features’ effectiveness depends on using thread history to improve responses. The Copilot model requires access to previous interactions to deliver accurate and relevant suggestions. Does GitHub Copilot support compliance with the GDPR and other data protection laws?Yes. GitHub and customers can enter a Data Protection Agreement that supports compliance with the GDPR and similar legislation.Does GitHub Copilot ever output personal data?While we've designed GitHub Copilot with privacy in mind, the expansive definition of personal data under legislation like the EU’s General Data Protection Regulation (GDPR) means we can't guarantee it will never output such data. The Large Language Model (LLM) powering GitHub Copilot was trained on public code and there were instances in our tests where the tool made suggestions resembling personal data. These suggestions were typically synthesized and not tied to real individuals. How does Copilot allow users to access, alter or delete personal data?These actions are available to Copilot users as described in the GitHub Privacy Statement.
Responsible AIWhat are the intellectual property considerations when using GitHub Copilot?The primary IP considerations for GitHub Copilot relate to copyright. The model that powers Copilot is trained on a broad collection of publicly accessible code, which may include copyrighted code, and Copilot’s suggestions (in rare instances) may resemble the code its model was trained on. Here’s some basic information you should know about these considerations:Copyright law permits the use of copyrighted works to train AI models:  Countries around the world have provisions in their copyright laws that enable machines to learn, understand, extract patterns, and facts from copyrighted materials, including software code. For example, the European Union, Japan, and Singapore, have express provisions permitting machine learning to develop AI models. Other countries including Canada, India, and the United States also permit such training under their fair use/fair dealing provisions. GitHub Copilot’s AI model was trained with the use of code from GitHub’s public repositories—which are publicly accessible and within the scope of permissible copyright use.What about copyright risk in suggestions? In rare instances (less than 1% based on GitHub’s research), suggestions from GitHub may match examples of code used to train GitHub’s AI model. Again, Copilot does not “look up” or “copy and paste” code, but is instead using context from a user’s workspace to synthesize and generate a suggestion.Our experience shows that matching suggestions are most likely to occur in two situations: (i) when there is little or no context in the code editor for Copilot’s model to synthesize, or (ii) when a matching suggestion represents a common approach or method. If a code suggestion matches existing code, there is risk that using that suggestion could trigger claims of copyright infringement, which would depend on the amount and nature of code used, and the context of how the code is used. In many ways, this is the same risk that arises when using any code that a developer does not originate, such as copying code from an online source, or reusing code from a library. That is why responsible organizations and developers recommend that users employ code scanning policies to identify and evaluate potential matching code.In Copilot, you can opt whether to allow Copilot to suggest code completions that match publicly available code on GitHub.com. For more information, see "Configuring GitHub Copilot settings on GitHub.com". If you have allowed suggestions that match public code, GitHub Copilot can provide you with details about the matching code when you accept such suggestions. Matching code does not necessarily mean copyright infringement, so it is ultimately up to the user to determine whether to use the suggestion, and what and who to attribute (along with other license compliance) in appropriate circumstances.Does GitHub Copilot include a filtering mechanism to mitigate risk?Yes, GitHub Copilot does include an optional code referencing filter to detect and suppress certain suggestions that match public code on GitHub.GitHub has created a duplication detection filter to detect and suppress suggestions that contain code segments over a certain length that match public code on GitHub. This filter can be enabled by the administrator for your enterprise and it can apply for all organizations within your enterprise, or the administrator can defer control to individual organizations. With the filter enabled, Copilot checks code suggestions for matches or near-matches against public code on GitHub of 65 lexemes or more (on average,150 characters). If there is a match, the suggestion will not be shown to the user.In addition to off-topic, harmful, and offensive output filters, GitHub Copilot also scans the outputs for vulnerable code.Does GitHub Copilot include features to make it easier for users to identify potentially relevant open source licenses for matching suggestions?Yes, GitHub Copilot is previewing a code referencing feature as an additional tool to assist users to find and review potentially relevant open source licenses. Code referencing is currently available in Visual Studio Code. This feature searches across public GitHub repositories for code that matches a Copilot suggestion. If there’s a match, users will find its information displayed in the Copilot console log, including where the match occurred, any applicable licenses, and a deep link to learn more. The deep link will take users to a navigable page on GitHub.com to browse examples of the code match and their repository licenses, and see how many repositories—including ones without licenses—that code appears in, as well as links to those repositories. Copilot users can review this information to determine whether the applicable suggestions are suitable for use, and whether additional measures may be necessary to use them.Who owns the suggestions provided by GitHub Copilot?We don’t determine whether a suggestion is capable of being owned, but we are clear that GitHub does not claim ownership of a suggestion. Whether a suggestion generated by an AI model can be owned depends on many factors (e.g. the intellectual property law in the relevant country, the length of the suggestion, the extent that suggestion is considered ‘functional’ instead of expressive, etc).If a suggestion is capable of being owned, our terms are clear: GitHub does not claim ownership.GitHub does not claim ownership of any suggestion. In certain cases, it is possible for Copilot to produce similar suggestions to different users. For example, two unrelated users both starting new files to code the quicksort algorithm in Java will likely get the same suggestion. The possibility of providing similar suggestions to multiple users is a common part of generative AI systems.Can GitHub Copilot introduce insecure code in its suggestions?Public code may contain insecure coding patterns, bugs, or references to outdated APIs or                        idioms. When GitHub Copilot synthesizes code suggestions based on this data, it can also                        synthesize code that contains these undesirable patterns. Copilot has filters in place that                        either block or notify users of insecure code patterns that are detected in Copilot suggestions. These filters target the most common vulnerable coding patterns, including hardcoded credentials, SQL injections, and path injections. Additionally, in recent years we’ve provided tools such as GitHub Advanced Security, GitHub Actions, Dependabot, and CodeQL to open source projects to help improve code quality. Of course, you should always use GitHub Copilot together with good testing and code review practices and security tools, as well as your own judgment.Is GitHub Copilot intended to fully automate code generation and replace developers?No. Copilot is a tool intended to make developers more efficient. It’s not intended to replace developers, who should continue to apply the same sorts of safeguards and diligence they would apply with regard to any third-party code of unknown origin.The product is called “Copilot” not “Autopilot” and it’s not intended to generate code without oversight. You should use exactly the same sorts of safeguards and diligence with Copilot’s suggestions as you would use with any third-party code.Identifying best practices for use of third party code is beyond the scope of this section. That said, whatever practices your organization currently uses – rigorous functionality testing, code scanning, security testing, etc. – you should continue these policies with Copilot’s suggestions. Moreover, you should make sure your code editor or editor does not automatically compile or run generated code before you review it.Can GitHub Copilot users simply use suggestions without concern?Not necessarily. GitHub Copilot users should align their use of Copilot with their respective                        risk tolerances.As noted above, GitHub Copilot is not intended to replace developers, or their individual skill and judgment, and is not intended to fully automate the process of code development. The same risks that apply to the use of any third-party code apply to the use of Copilot’s suggestions.Depending on your particular use case, you should consider implementing the protections discussed above. It is your responsibility to assess what is appropriate for the situation and implement appropriate safeguards.You’re entitled to IP indemnification from GitHub for the unmodified suggestions when Copilot’s filtering is enabled. If you do elect to enable this feature, the copyright responsibility is ours, not our customers. As part of our ongoing commitment to responsible AI, GitHub and Microsoft extends our IP indemnity and protection support to our customers who are empowering their teams with GitHub Copilot. See Microsoft's Copilot Copyright Commitment for more details.Does GitHub Copilot support accessibility features?We are conducting internal testing of GitHub Copilot’s ease of use by developers with                        disabilities and working to ensure that GitHub Copilot is accessible to all developers. Please feel free to share your feedback on GitHub Copilot accessibility in our feedback forum.Does GitHub Copilot produce offensive outputs?GitHub Copilot includes filters to block offensive language in the prompts and to avoid                        synthesizing suggestions in sensitive contexts. We continue to work on improving the filter                        system to more intelligently detect and remove offensive outputs. If you see offensive outputs, please report them directly to copilot-safety@github.com so that we can improve our safeguards. GitHub takes this challenge very seriously and we are committed to addressing it.Will GitHub Copilot work as well using languages other than English?Given public sources are predominantly in English, GitHub Copilot will likely work less well in scenarios where natural language prompts provided by the developer are not in English and/or are grammatically incorrect. Therefore, non-English speakers might experience a lower quality of service.What data has GitHub Copilot been trained on?GitHub Copilot is powered by generative AI models developed by GitHub, OpenAI, and Microsoft. It has been trained on natural language text and source code from publicly available sources, including code in public repositories on GitHub.Data from June 2023. Additional research can be found here.Feature in public beta for Copilot Pro and Business plans. Requires use of repositories, issues, discussions, Actions, and other features of GitHub.Authentication with SAML single sign-on (SSO) available for organizations using GitHub Enterprise Cloud.FootnotesOption to purchase additional premium requests not available to users that subscribe or have subscribed to Pro or Pro+ through GitHub Mobile on iOS or Android.\n\n\n\nGitHub SecurityAdvanced SecuritySecret ProtectionCode SecuritySupply Chain SecurityPlans & pricingGitHub Advanced SecuritySecurity that moves at the  speed of developmentRequest a demoSee plans & pricingStop leaks before  they startExplore Secret ProtectionFix vulnerabilities  in your codeExplore Code SecurityGitHub is used byPauseBecome a risk reduction warriorStay ahead of threats with built-in security, secret protection, and dependency monitoring.Strengthen your development with AIWrite secure code at scale with AI-driven insights and automated fixes from GitHub Copilot Autofix.Empower your team with native AppSecFind and fix vulnerabilities in real time by integrating application security right into GitHub.“GitHub Advanced Security has solved the risk of leaked credentials. Now, developers are alerted to the problem before they push the code live. They have a direct feedback loop.Florian KochLead developer at Deutsche VermögensberatungTwo layers of powerful protectionCombine Secret Protection and Code Security to safeguard your code from every angle.See plans & pricingAdd-onSecret ProtectionFor teams and organizations serious about stopping secret leaks.$19USDper active committer/monthRequest a demoContact salesTeam or Enterprise plan requiredAdd-onCode SecurityFor teams and organizations committed to fixing vulnerabilities before production.$30USDper active committer/monthRequest a demoContact salesTeam or Enterprise plan requiredGet the most out of GitHub Advanced SecurityMaximize your defenses with industry-leading AppSecDiscover how our security solution can benefit your organization.Request a demoSee how improved security drives business successExplore the benefits of improving software security standards in organizations.Read the Forrester ReportHow top teams secure code while moving fastLearn how industry experts protect their code without sacrificing productivity.Explore videosFrequently asked questionsWhat is GitHub Advanced Security?GitHub Advanced Security (GHAS) encompasses GitHub’s application security products comprising GitHub Secret Protection and GitHub Code Security. GHAS adds cutting-edge tools for static analysis, software composition analysis, and secret scanning to the GitHub platform that developers already know and love. Unlike traditional application security packages that burden the software development toolchain with complex workflows that inhibit adoption, GHAS makes it easy for developers to find and fix vulnerabilities earlier in the software development life cycle. Why choose GitHub Advanced Security instead of a third-party AppSec product?Unlike third-party security add-ons, GitHub Advanced Security operates entirely in the native GitHub workflows that developers already know and love. By making it easier for developers to remediate vulnerabilities as they go, GitHub Advanced Security frees time for security teams to focus on critical strategies that protect businesses, customers, and communities from application-based vulnerabilities.What is DevSecOps?DevSecOps refers to a combination of the development, security, and operations tools necessary to develop software applications.What is AppSec?Application security (AppSec) is the process of finding, fixing, and preventing security vulnerabilities in applications. GitHub Advanced Security provides AppSec tools for static application security testing (SAST), which identifies vulnerabilities in the code itself. Can I use GitHub Advanced Security with Microsoft Azure DevOps?Yes. GitHub Advanced Security is available as an add-on for Azure DevOps.Where can I find case studies and reference customers?Read our customer stories to learn how customers like Telus, Mercado Libre, and KPMG use GitHub Advanced Security to secure applications and accelerate the software development lifecycle.Can I review documentation before purchase?Yes. As with all GitHub products, documentation for GitHub Advanced Security is publicly available.Does GitHub offer consulting, training, and other deployment services?Yes! Please visit Expert Services to learn more.\n\n\n\nFeaturesGitHub CopilotSecurityActionsCodespacesIssuesCode reviewDiscussionsCode searchGitHub ActionsAutomate your workflow from idea to productionGitHub Actions makes it easy to automate all your software workflows, now with world-class CI/CD. Build, test, and deploy your code right from GitHub. Make code reviews, branch management, and issue triaging work the way you want.
Get started with actionsContact salesKick off workflows on any GitHub event to automate tasksHosted runnersLinux, macOS, Windows, ARM, GPU, and containers make it easy to build and test all your projects. Run directly on a VM or inside a container. Use your own VMs, in the cloud or on-prem, with self-hosted runners.Matrix buildsSave time with matrix workflows that simultaneously test across multiple operating systems and versions of your runtime.
Any languageGitHub Actions supports Node.js, Python, Java, Ruby, PHP, Go, Rust, .NET, and more. Build, test, and deploy applications in your language of choice.
Live logsSee your workflow run in realtime with color and emoji. It’s one click to copy a link that highlights a specific line number to share a CI/CD failure.Built in secret storeAutomate your software development practices with workflow files embracing the Git flow by codifying it in your repository.Multi-container testingTest your web service and its DB in your workflow by simply adding some docker-compose to your workflow file.Run a workflow  on any eventWhether you want to build a container, deploy a web service, or automate welcoming new users to your open source projects—there's an action for that. Pair GitHub Packages with Actions to simplify package management, including version updates, fast distribution with our global CDN, and dependency resolution, using your existing GITHUB_TOKEN.Actions marketplaceGitHub Actions connects all of your tools to automate every step of your development workflow. Explore the actions marketplaceEasily deploy to any cloud, create tickets in Jira, or publish a package to npm.Want to venture off the beaten path? Use the millions of open source libraries available on GitHub to create your own actions. Write them in JavaScript or create a container action—both can interact with the full GitHub API and any other public API.Secure package registry for code and workflowsSecurely store and manage your code and packages with GitHub credentials, integrated into your workflows via APIs and webhooks. Enjoy fast, reliable downloads through a global CDN for optimized performance.Read the docs“Actions is an exciting development and unlocks so much potential beyond CI/CD. It promises to streamline our workflows for a variety of tasks, from deploying our websites to querying the GitHub API for custom status reports to standard CI builds.Ralf GommersSciPy maintainerGitHub Actions is free for public repositoriesWe take pride in our Open Source legacy, and are happy to provide free CI/CD for public repositories. Check out the doc to see which runners are included.View docsHost your own runners or use GitHub-hosted runnersCheck out plan details to see how many minutes are included and the pricing table below to see which runners you can use your free minutes on.View pricingThe future of workflow automation is now
Get started with actions\n\n\n\nFeaturesGitHub CopilotSecurityActionsCodespacesIssuesCode reviewDiscussionsCode searchGitHub CodespacesSecure development  made simpleGitHub Codespaces gets you up and coding faster with fully configured, secure cloud development environments native to GitHub.Get started for freeContact SalesSecure by designCreated with security in mind, Codespaces provides a secure development environment through its built-in capabilities and native integration with GitHub.Collaborate  where you codeCodespaces provides a shared development environment and removes the need for complex, time consuming setups.Your space, your way. Codespaces is a home away from home for your code that feels just like your usual machine.Your space, your way. Codespaces is a home away from home for your code that feels just like your usual machine.
Start coding instantly from anywhere in the world. Switching projects? Grab a new machine from the cloud that’s preconfigured for that project. Your settings travel with you.Tabs or spaces? Monokai or Solarized? Prettier or Beautify? It’s up to you. Control every nerdy detail only you care about with your own dotfiles repository.Browser preview  and port forwardingPreview your changes and get feedback from teammates by sharing ports within the scope allowed by policy.Onboard fasterQuickly spin up a codespace with only an IDE or browser and a GitHub account. With a few configuration files, you can give your developers an instant, fully configured, and secure development environment so they can start coding immediately.What you can do with CodespacesCode from any device. Want to code on an iPad? Go for it. Spin up Codespaces from any device with internet access. Don’t worry if your device is powerful enough—Codespaces lives in the cloud.Onboard at the speed of thought. No more building your dev environment while you onboard. Codespaces launches instantly from any repository on GitHub with pre-configured, secure environments.Fix bugs right from a pull request. Got a pull request detailing a bug or security issue? Open Codespaces right from the pull request without waiting for your dev environment to load.Learn how GitHub’s Engineering Team builds with CodespacesRead more“What used to be a 15-step process is just one step: open Codespaces and you’re off and running.Clint ChesterDeveloper Lead, Synergy“Codespaces lets developers skip the tedious, error-prone stuff that normally stands between them and getting started on real work.Keith AnnetteCloud Capability Lead, KPMG, UKStart coding in seconds with CodespacesGet started for freeFrequently asked questionsHow does Codespaces work?A codespace is a development environment that's hosted in the cloud. Customize your project for GitHub Codespaces by configuring dev container files to your repository (often known as configuration-as-code), which creates a repeatable codespace configuration for all users of your project.GitHub Codespaces run on a various VM-based compute options hosted by GitHub.com, which you can configure from 2 core machines up to 32 core machines. Connect to your codespaces from the browser or locally using an IDE like Visual Studio Code or IntelliJ.How do I use Codespaces?There are a number of entry points to spin up a Codespaces environment, including:A template.Your repository for new feature workAn open pull request to explore work-in-progressA commit in the repository's history to investigate a bug at a specific point in timeVisual Studio CodeIn beta, can you also use your JetBrains IDE or JupyterLabLearn more about how to use Codespaces in our documentation.Is Codespaces available for individual developers?Codespaces is available for developers in every organization, and under the control of the organization who pays for the user's codespace. All personal (individual) GitHub.com accounts include a quota of free usage each month, which organizations can enable (see the next question) for their private and internal repositories. GitHub will provide users in the free plan 120 core hours or 60 hours of run time on a 2 core codespace, plus 15 GB of storage each month. See how it's balanced on the billing page.Is Codespaces available for teams and companies?Codespaces is available for teams and companies, but needs to be enabled first in an organization’s settings. Teams and companies can select which repositories and users have access to Codespaces for added security and permissioning control. Learn how to enable Codespaces in an organization in our docs.How much does Codespaces cost?Codespaces is free for individual use up to 60 hours a month and comes with simple, pay-as-you-go pricing after that. It’s also available for organizations with pay-as-you-go pricing and has pricing controls so any company or team can determine how much they want to spend a month. Learn more about Codespaces pricing for organizations here.Can I self-host Codespaces?Codespaces cannot be self-hosted.How do I access Codespaces with LinkedIn Learning?You can use Codespaces directly through LinkedIn Learning. LinkedIn Learning offers 50+ courses across six of the most popular coding languages, as well as data science and machine learning. These courses are integrated with Codespaces, so you can get hands-on practice anytime, from any machine via LinkedIn. These courses will be unlocked on LinkedIn Learning for free through Feb. 2023. Learn more about LinkedIn Learning and GitHub Codespaces here.How do I enable Codespaces on GitHub?Codespaces is on by default for developers with a GitHub free account. If you belong to an organization, there may be a policy that prevents cloning—but if you can clone a repository, you will be able to start using Codespaces. Organizations will also need to pay for, enable, and manage their Codespaces instances.Is Codespaces available for students?Codespaces is available for free to students as part of the GitHub Student Developer Pack. Learn more about how to sign up and start using Codespaces and other GitHub products here.Is Codespaces available for open source maintainers?Codespaces provides both maintainers and contributors with generous free monthly usage.\n\n\n\nFeaturesGitHub CopilotSecurityActionsCodespacesIssuesCode reviewDiscussionsCode searchGitHub IssuesProject planning for developersCreate issues, break them into sub-issues, track progress, add custom fields, and have conversations. Visualize large projects as tables, boards, or roadmaps, and automate everything with code.Start using projectsContact salesLogos for Shopify, Vercel, Stripe, Ford, and NASABreak issues into sub-issuesTackle complex issues with sub-issues and track their status with progress indicators. Navigate the full scope of work all in one view.Streamline conversationsExpress ideas with GitHub Flavored Markdown, mention contributors, react with emoji, clarify with attachments, and see references from commits, pull requests, releases, and deploys. Coordinate by assigning contributors and teams, or by adding them to milestones and projects. All in a single timeline.Upload and attach videos to commentsDive into work faster with issue forms and templatesFeaturesBored of boards? Switch to tables and roadmaps. Create views for how you work. Save views for sprints, backlogs, teams, or releases. Rank, group, sort, slice and filter to suit the occasion. Create swimlanes, share templates and set work in progress limits.No mouse? No problem. Every action you can take with the mouse has a keyboard shortcut or command. Filter, sort, group, and assign issues. Your hands never leave the keyboard.Custom fieldsTrack metadata like iterations, priority, story points, dates, notes, and links. Add custom fields to projects and edit from the issue sidebar.
Track progress with project insightsTrack the health of your current iteration cycle, milestone, or any other custom field you create with new project insights. Identify bottlenecks and issues blocking the team from making progress with the new burn up chart.Share best practices with project templatesCreate templates to share and reuse when getting started with a new project. Share inspiration across teams and get started with a single click.Manage work automaticallyAccelerate your project planning with workflows. Automatically triage issues, set values for custom fields, or archive issues.
Manage work automatically Issues, where you need themIssues can be viewed, created, and managed in your browser, your favorite terminal, or on your phone or tablet.GitHub CLIView, update, and create issues without ever leaving your terminal.Learn moreGitHub MobileCreate and manage issues on the go with our native iOS and Android mobile apps.Learn moreWhat developers are saying
“The new planning and tracking functionality keeps my project management close to my code. I no longer find myself needing to reach for spreadsheets or 3P tools which go stale instantly.Dan GodfreyDevelopment ManagerFlexible project planning for developers Start using projectsContact salesFrequently asked questionsWhat is GitHub Issues?We all need a way to plan our work, track issues, and discuss the things we build. Our answer to this universal question is GitHub Issues, and it’s built-in to every repository. GitHub’s issue tracking is unique because of our focus on simplicity, references, and elegant formatting.With GitHub Issues, you can express ideas with GitHub Flavored Markdown, assign and mention contributors, react with emojis, clarify with attachments and videos, plus reference code like commits, pull requests, and deploys. With task lists, you can break big issues into tasks, further organize your work with milestones and labels, and track relationships and dependencies.We built GitHub Issues for developers. It is simple, adaptable, and powerful.What are Projects?As teams and projects grow, how we work evolves. Tools that hard-code a methodology are too specific and rigid to adapt to any moment. Often, we find ourselves creating a spreadsheet or pulling out a notepad to have the space to think. Then our planning is disconnected from where the work happens.The new Projects connect your planning directly to the work your teams are doing and flexibly adapt to whatever your team needs at any point. Built like a spreadsheet, project tables give you a live canvas to filter, sort, and group issues and pull requests. You can use it, or the accompanying project board, along with custom fields, to track a sprint, plan a feature, or manage a large-scale release.What plans have access to Projects?All users have access to the free tier of GitHub Issues and Projects. For more information about paid tiers, see our pricing page.Will the new Projects experience be available in GitHub Enterprise Server?Yes! GitHub Enterprise Server (GHES) support follows our regular cadence of one to two quarters before enabling the on-premises functionality.\n\n\n\nFeaturesGitHub CopilotSecurityActionsCodespacesIssuesCode reviewDiscussionsCode searchCode ReviewWrite better codeOn GitHub, lightweight code review tools are built into every pull request. Your team can create review processes that improve the quality of your code and fit neatly into your workflow.Get startedContact salesEvery change starts with a pull request.Every change starts with a pull request.Learn pull request fundamentalsStart a new feature or propose a change to existing code with a pull request—a base for your team to coordinate details and refine your changes.Pull requests are fundamental to how teams review and improve code on GitHub. Evolve projects, propose new features, and discuss implementation details before changing your source code.See every update and act on it, in-situDiffsPreview changes in context with your code to see what is being proposed. Side-by-side Diffs highlight added, edited, and deleted code right next to the original file, so you can easily spot changes.Learn moreHistoryBrowse commits, comments, and references related to your pull request in a timeline-style interface. Your pull request will also highlight what’s changed since you last checked.Learn moreBlameSee what a file looked like before a particular change. With blame view, you can see how any portion of your file has evolved over time without viewing the file’s full history.Learn moreDiscuss code within your codeCommentsOn GitHub, conversations happen alongside your code. Leave detailed comments on code syntax and ask questions about structure inline.Review requestsIf you’re on the other side of the code, requesting peer reviews is easy. Add users to your pull request, and they’ll receive a notification letting them know you need their feedback.ReviewsSave your teammates a few notifications. Bundle your comments into one cohesive review, then specify whether comments are required changes or just suggestions.You can’t always avoid conflict. Merge pull requests faster by resolving simple merge conflicts on GitHub—no command line necessary.Learn moreMerge the highest quality codeReviews can improve your code, but mistakes happen. Limit human error and ensure only high quality code gets merged with detailed permissions and status checks.Fast, relevant resultsGive collaborators as much access as they need through your repository settings. You can extend access to a few teams and select which ones can read or write to your files. The options you have for permissions depend on your plan.See plan optionsProtected branchesProtected Branches help you maintain the integrity of your code. Limit who can push to a branch, and disable force pushes to specific branches. Then scale your policies with the Protected Branches API.
Learn moreRequired status checks
Create required status checks to add an extra layer of error prevention on branches. Use the Status API to enforce checks and disable the merge button until they pass. To err is human; to automate, divine!Status API docEvery change starts with a pull request. Get started\n\n\n\nFeaturesGitHub CopilotSecurityActionsCodespacesIssuesCode reviewDiscussionsCode searchGitHub DiscussionsThe home for  developer communitiesAsk questions, share ideas, and build connections with each other—all right next to your code. GitHub Discussions enables healthy and productive software collaboration.Try nowContact salesDedicated space for conversationsDecrease the burden of managing active work in issues and pull requests by providing a separate space to host ongoing discussions, questions, and ideas.Highlight quality responses and make the best answer more discoverable. Keep context in-tact and conversations on track with threaded comments. Ask your community directly with custom polls. Leverage GraphQL API and webhooks to meet your teams wherever they are. Give your open ended conversations the room they need outside of issues. CustomizePersonalize for your community and team with any ways to make your space unique for you and your collaborators.Custom categories. Create discussion categories that fit your community's needs. Label and organize. Make announcements and the most important discussions more visible for contributors. Pin discussions. Make announcements and the most important discussions more visible for contributors. Monitor insightsTrack the health and growth of your community with a dashboard full of actionable data.Contribution activityCount of total contribution activity to Discussions, Issues, and PRs.Discussion page viewTotal page views to Discussions segmented by logged in vs anonymous users.Discussions daily contributorsCount of unique users who have reacted, upvoted, marked an answer, commented, or posted in the selected period.Start the conversation with your community Try now\n\n\n\nFeaturesGitHub CopilotSecurityActionsCodespacesIssuesCode reviewDiscussionsCode searchCode SearchExactly what you’re looking forYour code—and the world’s—is at your fingertips.Try it nowContact salesSearch, navigate, and understand your team’s code—and billions of lines of public code.Fast, relevant resultsCode search understands your code—and brings you relevant results with incredible speed.A power user's dreamSearch using regular expressions, boolean operations, keyboard shortcuts, and more.More than just searchDig deeper with the all-new code view—tightly integrating browsing and code navigation.Way more than grep.GitHub code search can search across multiple repositories and is always up to date. It understands your code, and puts the most relevant results first.Use the new search input to find symbols and files—and jump right to them. Know exactly what you’re looking for? Express it with our powerful search operators. Meet the all-new code view.Dig deeper into complex codebases with tightly integrated search, code navigation and browsing.Instantly jump to definitions in over 10 languages. No setup required with Code navigation. Keep all your code in context and instantly switch files with the new file tree pane. What developers are saying
“Code search makes it effortless to quickly find what I'm looking for in my code, or across all of GitHubKeith SmileySoftware Engineer“Code search turns what would've been a ~10 minute grep search into a 2 second UI search Marco MontagnaPlatform EngineerFind more, search lessTry it now\n\n\n\nWhy GitHubMost of the world's code lives on GitHub. Why not yours?GitHub empowers developers and enterprises to collaborate, innovate, and build securely. With AI-powered tools, built-in security testing, and seamless integration, it supports teams from first commit to enterprise development.
Start free for 30 daysContact salesWhat is GitHub?Over 90% of Fortune 100 companies and more than 150 million developers rely on GitHub to deliver scalable, reliable, and secure solutions for teams of all sizes.Developer-first: Designed for developers, GitHub offers seamless collaboration tools that make teamwork smarter, faster, and more secure.
Enterprise-grade: GitHub Enterprise scales with your organization, delivering the performance and security needed for teams of any size.
AI-powered: Leverage GitHub Copilot to automate tasks and enhance productivity with smart, context-aware code suggestions.
Logos for Fidelity Shopify Mercedes Benz American Airlines Adobe Ford Vodafone Spotify Home DepotThe developer platform that grows with you
Whether you're a small startup or a global enterprise, GitHub is designed to grow with you. The platform adapts to your needs, helping ensure that you don’t have to compromise on performance, security, or collaboration as your organization scales.Explore GitHub EnterpriseCustomizable workflowsTailor your workflows with GitHub Actions and integrate seamlessly with your existing tools.Learn more about GitHub ActionsSecurity at scaleGitHub's centralized access management and compliance tools help ensure your code and data remain safe.Explore GitHub securityYour code, your controlWith GitHub Enterprise Cloud, you decide where your code lives while enabling security, compliance, and scalability with SaaS agility and enterprise-grade governance.
Read about data residency55%faster coding enabled by GitHub Copilot80%time saved in developer onboarding$3.2Min savings by reducing developer onboarding training time through automation75%improvement in time spent managing tools and code infrastructureSecurity throughout the SDLC
Fix vulnerabilities before they hit production and reduce the risk of a costly breach with application security that is built in, not bolted on.Explore GitHub Advanced SecurityCode securityReview potential vulnerabilities and get suggested fixes with Copilot Autofix to accelerate remediation and strengthen security posture.Learn more about Copilot AutofixSecret protectionHelp ensure your secrets stay secure by preventing accidental exposure in your repositories.Check out GitHub Secret ProtectionSupply chain securityVisualize, protect, and remediate your code's upstream dependencies.Explore GitHub supply chain security3xfaster remediation on average with Copilot Autofix28 minfrom vulnerability detection to successful remediation4.4Msecrets prevented from being leaked on GitHub in 2024The comprehensive platformfor high-performance teams
GitHub is where the world builds software—faster, smarter, and more securely. Unlock the full potential of your team with an AI-native platform, seamless automation, and CI/CD workflows that help you build, scale, and innovate like never before.Explore CI/CD solutionSpeed up your workflows and eliminate bottlenecksHarness GitHub Copilot to automate tasks, enhance code quality, and boost productivity. With intelligent, adaptive recommendations, you’ll write cleaner code quicker and accomplish more in less time.See GitHub CopilotGet your team in sync, effortlesslyWith GitHub’s integrated tools—from pull requests to project boards—collaboration is streamlined, and automation handles the heavy lifting. Keep your team aligned, reduce manual tasks, and stay focused on building great software.Learn more about GitHub IssuesWork smarter, build faster, innovate with intentionGitHub introduces new ways to work smarter and faster. With AI-powered tools and agentic automation, you can reduce repetitive tasks and stay in a flow state—shaping the future of software with speed and intention.Explore GitHub Copilot agent mode“Between Copilot, Codespaces, Issues, Actions, and Dependabot, GitHub is at the center of our development universe. It has enabled us to increase the velocity of our development and has shortened our time-to-market.
Luigi UngaroGlobal Engine developer lead, AmplifonThe platform developers know and loveEmpower your team to collaborate, innovate, and build software—faster, smarter, and more securely—with the platform they know and love.
Start free for 30 daysContact sales\n\n\n\nThe tools you need to build what you wantExperience AI with Copilot ChatLearn moreThe latest GitHub previewsLearn moreCollaborative codingAutomation & CI/CDApplication securityClient appsProject managementGovernance & administrationCommunityCollaborative codingInnovate faster with seamless collaboration.See the changes you care about.Build community around your code.GitHub CodespacesSpin up fully configured dev environments in the cloud with the full power of your favorite editor.Learn moreGitHub CopilotGet suggestions for whole lines of code or entire functions right inside your editor.Learn morePull requestsReceive notifications of contributor changes to a repository, with specified access limits, and seamlessly merge accepted updates.Learn moreDiscussionsDedicated space for your community to come together, ask and answer questions, and have open-ended conversations.Learn moreCode search & code viewRapidly search, navigate, and understand code right from GitHub.com with our powerful new tools.Learn moreCode reviewReview new code, visualize changes, and merge confidently with automated status checks.Learn moreDraft pull requestsCollaborate and discuss changes without a formal review or the risk of unwanted merges.Learn moreProtected branchesEnforce branch merge restrictions by requiring reviews or limiting access to specific contributors.Learn moreAutomation and CI/CDAutomate everything: CI/CD, testing, planning, project management, issue labeling, approvals, onboarding, and more.Standardize and scale best practices, security, and compliance across your organization.Get started quickly with thousands of actions from partners and the community.GitHub ActionsAutomate your software workflows by writing tasks and combining them to build, test, and deploy faster from GitHub.Learn moreGitHub PackagesHost your own software packages or use them as dependencies in other projects, with both private and public hosting available.Learn moreAPIsCreate calls to get all the data and events you need within GitHub, and automatically kick off and advance your software workflows.Learn moreGitHub MarketplaceLeverage thousands of actions and applications from our community to help build, improve, and accelerate your workflows.Learn moreWebhooksDozens of events and a webhooks API help you integrate with and automate work for your repository, organization, or application.Learn moreGitHub-hosted runnersMove automation to the cloud with on-demand Linux, macOS, Windows, ARM, and GPU environments for your workflow runs, all hosted by GitHub.Learn moreSelf-hosted runnersGain more environments and fuller control with labels, groups, and policies to manage runs on your own machines, plus an open source runner application.Learn moreWorkflow visualizationMap workflows, track their progression in real time, understand complex workflows, and communicate status with the rest of the team.Learn moreWorkflow templatesStandardize and scale best practices and processes with preconfigured workflow templates shared across your organization.Learn moreApplication securityApplication security where found means fixed. Powered by GitHub Copilot Autofix.Explore GitHub Advanced SecurityPrevent, find, and fix application vulnerabilities and leaked secrets.Target historical alerts to reduce security debt at scale.Built into the GitHub platform that developers know and love.Code scanningFind vulnerabilities in your code with CodeQL, GitHub’s industry-leading semantic code analysis. Prevent new vulnerabilities from being introduced by scanning every pull request.Learn moreGitHub Copilot AutofixPowered by GitHub Copilot, generate automatic fixes for 90% of alert types in JavaScript, TypeScript, Java, and Python. Quickly remediate with contextual vulnerability intelligence and advice.Learn moreSecurity campaignsSolve your backlog of application security debt with security campaigns that target and generate autofixes for up to 1,000 alerts at a time, rapidly reducing the risk of vulnerabilities and zero-day attacks.Learn moreSecret scanningDetect exposed secrets in your public and private repositories, and revoke them to secure access to your services.Learn moreGitHub Copilot secret scanningAdditional AI capabilities to detect elusive secrets like passwords.Learn moreDependency graphView the packages your project relies on, the repositories that depend on them, and any vulnerabilities detected in their dependencies.Learn moreDependabot alertsReceive alerts when new vulnerabilities affect your repositories, with GitHub detecting and notifying you of vulnerable dependencies in both public and private repositories.Learn moreDependabot security and version updatesKeep your code secure by automatically opening pull requests that update vulnerable or out-of-date dependencies.Learn moreDependency reviewAssess the security impact of new dependencies in pull requests before merging.Learn moreGitHub security advisoriesPrivately report, discuss, fix, and publish information about security vulnerabilities found in open source repositories.Learn morePrivate vulnerability reportingEnable your public repository to privately receive vulnerability reports from the community and collaborate on solutions.Learn moreGitHub Advisory DatabaseBrowse or search GitHub's database of known vulnerabilities, featuring curated CVEs and security advisories linked to the GitHub dependency graph.Learn moreClient appsAccess GitHub anywhere: On Desktop, Mobile, and Command Line.Accessible anywhere. Use GitHub on macOS, Windows, mobile, or tablet with native apps.Efficient management. Handle pull requests, issues, and tasks swiftly with GitHub CLI or mobile.Streamlined development. Visualize and commit changes easily with GitHub Desktop.GitHub MobileTake your projects, ideas, and code to go with fully native mobile and tablet experiences.Learn moreGitHub CLIManage issues and pull requests from the terminal, where you're already working with Git and your code.Learn moreGitHub DesktopSimplify your development workflow with a GUI to visualize, commit, and push changes—no command line needed.Learn moreProject managementKeep feature requests, bugs, and more organized.Coordinate initiatives big and small with project tables, boards, and task lists.Engineered for software teams.Track what you deliver down to the commit.GitHub ProjectsCreate a customized view of your issues and pull requests to plan and track your work.Learn moreGitHub IssuesTrack bugs, enhancements, and other requests, prioritize work, and communicate with stakeholders as changes are proposed and merged.Learn moreMilestonesTrack progress on groups of issues or pull requests in a repository, and map groups to overall project goals.Learn moreCharts and insightsLeverage insights to visualize your projects by creating and sharing charts built from your project's data.Learn moreOrg dependency insightsView vulnerabilities, licenses, and other important information for the open source projects your organization depends on.Learn moreRepository insightsUse data about activity, trends, and contributions within your repositories, to make data-driven improvements to your development cycle.Learn moreWikisHost project documentation in a wiki within your repository, allowing contributors to easily edit it on the web or locally.Learn moreGovernance & administrationSimplify access and permissions management across your projects and teams.Update permissions, add new users as you grow, and assign everyone the exact permissions they need.Sync with Okta and Entra ID.OrganizationsCreate groups of user accounts that own repositories and manage access on a team-by-team or individual user basis.Learn moreTeamsOrganize your members to mirror your company's structure, with cascading access to permissions and mentions.Learn moreTeam syncEnable team synchronization between your identity provider and your organization on GitHub, including Entra ID and Okta.Learn moreCustom rolesDefine users' access level to your code, data, and settings based on their role in your organization.Learn moreCustom repository rolesEnsure members have only the permissions they need by creating custom roles with fine-grained permission settings.Learn moreDomain verificationVerify your organization's identity on GitHub and display that verification through a profile badge.Learn moreCompliance reportsTake care of your security assessment and certification needs by accessing GitHub’s cloud compliance reports, such as our SOC reports and Cloud Security Alliance CAIQ self-assessments (CSA CAIQ).Learn moreAudit logQuickly review the actions performed by members of your organization. Monitor access, permission changes, user changes, and other events.Learn moreRepository rulesEnhance your organization's security with scalable source code protections, and use rule insights to easily review how and why code changes occurred in your repositories.Learn moreRequires GitHub EnterpriseEnterprise accountsEnable collaboration between your organization and GitHub environments with a single point of visibility and management via an enterprise account.Learn moreRequires GitHub EnterpriseGitHub ConnectShare features and workflows between your GitHub Enterprise Server instance and GitHub Enterprise Cloud.Learn moreRequires GitHub EnterpriseSAMLSecurely control access to organization resources like repositories, issues, and pull requests with SAML, while allowing users to authenticate with their GitHub usernames.Learn moreRequires GitHub EnterpriseLDAPCentralize repository management. LDAP is one of the most common protocols used to integrate third-party software with large company user directories.Learn moreRequires GitHub EnterpriseEnterprise Managed UsersManage the lifecycle and authentication of users on GitHub Enterprise Cloud from your identity provider (IdP).Learn moreRequires GitHub EnterpriseBring your own identity provider for Enterprise Managed UsersUse the SSO and SCIM providers of your choice for Enterprise Managed Users, separate from one another, for a more flexible approach to user lifecycle management.Learn moreCommunityGitHub SponsorsFinancially support the open source projects your code depends on. Sponsor a contributor, maintainer, or project with one time or recurring contributions.Learn moreGitHub SkillsLearn new skills by completing tasks and projects directly within GitHub, guided by our friendly bot.Learn moreElectronWrite cross-platform desktop applications using JavaScript, HTML, and CSS with the Electron framework, based on Node.js and Chromium.Learn moreEducationGitHub Education is a commitment to bringing tech and open source collaboration to students and educators across the globe.Learn moreReady to get started?Explore all the plans to find the solution that fits your needs.View pricing plans\n\n\n\nEnterpriseAdvanced SecurityPremium SupportThe AI-powereddeveloper platformTo build, scale, and deliver secure software.Start free for 30 daysContact salesFeatured sponsorsPauseAnchor navigation menu. Currently selected: ScaleAISecurityReliabilityStart a free trialScaleThe enterprise-ready platform that developers know and loveConsolidate DevSecOps processes and enable unparalleled collaboration.Learn more about the ROI of GitHubLeverage the industry’s most flexible secure development platform.17,000+Third-party tools support your favorite languages and frameworksUnlocking innovation at scale with AI-driven software development.“We’ve used GitHub from the inception of Datadog. It’s a high-quality product, and a lot of our engineers contribute to open source so there’s a sense of community there. GitHub is ingrained in the DNA of our engineering, it’s become part of the culture.”Emilio EscobarChief Information Security Officer @ DatadogAIBuild, secure, and ship software fasterPush what's possible with GitHub Copilot, the world's most trusted and widely adopted AI developer tool.Learn more about Copilot for business88%of developers experience increased productivity.1Mercado Libre frees developers' minds to focus on their mission with GitHub.Read customer story~50%reduced time by writing code with GitHub Copilot100,000pull requests merged per dayProblemMercado Libre developer platform team needed secure DevOps tooling that would allow its developers to be more efficient and allow them to focus more on providing value to users.SolutionMercado Libre uses GitHub to automate deployment, security tests, and repetitive tasks so developers have more free time to spend on high-value, rewarding work.ProductsGitHub EnterpriseGitHub Copilot for businessGitHub Advanced SecuritySecurityEfficiency and security at every stepDeliver secure software fast, with enterprise-ready CI/CD, using GitHub Actions.Learn more about CI/CDFound means fixedKeep vulnerabilities out of code and solve security debtExplore GitHub Advanced SecurityGitHub Enterprise CloudEnhanced control with data residency2Learn moreSee how DVAG puts customers first by optimizing developer efficiency and security.Read customer storyReliability90% of the Fortune 100 choose GitHubMigrate, scale, and use cloud-based compute to accelerate digital transformation.Explore GitHub Enterprise ImporterReliability when it matters most with GitHub’s distributed architecture.75%Reduced time spent managing tools.3See how Telus saved $16.9 million in costs by replacing their DevOps tools with GitHub.Read customer storyStart your journey with GitHubStart a free trialContact salesPlanning your migration to GitHubLearn moreStay ahead with GitHub’s latest innovationsSee what's newCompare GitHub vs. GitLab and other DevOps toolsLearn moreFrequently asked questionsAbout GitHub EnterpriseWhat is GitHub Enterprise?GitHub Enterprise is an enterprise-grade software development platform designed for the complex workflows of modern development.As an extensible platform solution, GitHub Enterprise enables organizations to seamlessly integrate additional tools and functionalities, tailoring their development environment to meet specific needs and enhancing overall productivity.Why should organizations use GitHub EnterpriseThere are several reasons why organizations should consider using GitHub Enterprise:Accelerate development at scale with AI-powered development: GitHub is the world’s most widely adopted Copilot-powered developer platform helping organizations build, secure, and deliver innovative software at scale. Application security made simpler: Native security tools embedded into the developer workflow, such as GitHub Advanced Security, help developers easily fix security issues, while providing more visibility and controls.Centralize governance and compliance: Customers can access a range of administration features to help manage governance at scale and enforce business rules and policies to meet their specific needs. Boost productivity and collaboration: Increase productivity with automated CI/CD workflows using GitHub Actions, collaborate effectively with GitHub Projects and GitHub Issues, manage hosted packages with GitHub Packages, and utilize prebuilt and configured development environments with GitHub Codespaces.Greater flexibility and control over data: Whether self-hosting with GitHub Enterprise Server or using GitHub Enterprise Cloud, GitHub provides customers with flexibility and control over their data. And now with GitHub Enterprise Cloud with data residency, customers have enhanced control where certain data, like their code, resides. This is available in the EU and Australia with additional regions coming soon. Contact our sales team to learn more.Who uses GitHub Enterprise?GitHub Enterprise is used by organizations of all sizes that require greater productivity, collaboration, and security capabilities for their software development process. GitHub Enterprise can scale with teams, all the way from a small startup to a large corporation.What is GitHub Enterprise Cloud?GitHub Enterprise Cloud is the cloud-based solution of GitHub Enterprise, hosted on GitHub’s servers. This eliminates the need for organizations to maintain their own servers, infrastructure, and updates, allowing them to focus on development.In addition to the core productivity and collaboration features it provides, GitHub Enterprise Cloud provides access to additional features and add-ons for security, support, managed users, and many more. Customers can easily add or remove users as needed, and they can also increase storage capacity or processing power as their needs change.And for customers desiring more control over their data, GitHub Enterprise Cloud with data residency provides improved enterprise-grade features and more control over where code is stored. This is available in the EU and Australia with additional regions coming soon. Contact our sales team to learn more.What is GitHub Enterprise Server?GitHub Enterprise Server is the self-hosted version of GitHub Enterprise. It is installed on-premises or on a private cloud and provides organizations with a secure and customizable source code management and collaboration platform.One of the key advantages of GitHub Enterprise Server is that it provides organizations with complete control over their source code and data. Organizations can choose where to store their repositories and can control who has access to them. Administrators can also customize the platform to meet specific needs, such as integrating other tools or implementing custom workflows.GitHub Enterprise Server also offers enhanced security and compliance features. Organizations can configure their instance to meet their specific security requirements, such as using LDAP or SAML for authentication, setting up two-factor authentication, or implementing network security measures. Compliance features are also included, such as audit logs, access controls, and vulnerability scanning.How secure is GitHub Enterprise?GitHub Enterprise is designed with security in mind and includes a range of features to help organizations protect their code and data. Here are some of the key security features that GitHub Enterprise offers:Authentication and access controls: GitHub Enterprise includes two-factor authentication, LDAP and Active Directory integration, and OAuth authentication. This helps organizations ensure that only authorized users can access their repositories and data.Encryption: All data in transit between the user's computer and GitHub Enterprise server is encrypted using HTTPS. All data at rest uses AES-256 encryption.Vulnerability scanning: GitHub Enterprise includes built-in security scanning features that can detect known vulnerabilities and alert users.Audit logs: The platform provides detailed audit logs that record all user actions, including repository access, changes, and deletions. This helps organizations track and monitor user activity and identify potential security issues.Customizable policies: GitHub Enterprise allows organizations to create custom policies for repository access. This can help enforce compliance requirements and prevent unauthorized access to sensitive data.Regular security updates: There is also a dedicated security team that provides regular updates, monitors for potential security threats, and responds quickly to any issues that arise.Is GitHub Enterprise free?No, GitHub Enterprise is not free. It is a paid product that can be paid for either as a metered service on a monthly basis or as a subscription, with the cost determined by the number of users and the level of support required. For organizations interested in trying out the platform before making a commitment, GitHub Enterprise offers a free trial. Furthermore, organizations can contact the GitHub Sales team for the option to request a custom quote to meet their specific needs.Using GitHub EnterpriseHow can developers collaborate with GitHub Enterprise?Developers can collaborate with GitHub Enterprise using a variety of tools that are built into the platform, including:Pull requests: Allows developers to propose changes to a repository and submit them for review. Other team members can review the changes, leave comments, and suggest further improvements.GitHub Projects: Enables developers to track issues, assign tasks, and prioritize work. This helps teams stay on track, identify and resolve issues quickly, and ensure that everyone is working towards the same goals.GitHub Discussions: Empowers developers to have conversations about specific topics. This can be particularly useful for triaging complex issues or making decisions about the direction of a project.Choosing your planHow can organizations get started with GitHub Enterprise?To get started with GitHub Enterprise, try a free trial today or contact our sales team.What GitHub Enterprise plans are available?GitHub Enterprise offers several plans that vary in price and features. They are designed to accommodate different types of organizations and teams, from small startups to large enterprises. These plans include:GitHub Enterprise Server: This is the self-hosted version of GitHub Enterprise. It is installed on-premises or on a private cloud, and offers all the features of the cloud-based version of GitHub, including pull requests, code reviews, and project management tools. Pricing depends on the number of users and support requirements.GitHub Enterprise Cloud: This is the cloud-based version of GitHub Enterprise. It is hosted on GitHub's servers, and it offers all the features of GitHub Enterprise Server. The price depends on the number of users and storage requirements.How much does GitHub Enterprise cost?For more information on cost, please see our pricing page.Getting started with enterprise software development platformsWhat is a DevOps platform?A DevOps platform is a set of tools, technologies, and practices that enable software development and IT operations teams to collaborate and automate the software delivery process. It typically includes version control, continuous integration and continuous delivery (CI/CD), automated testing, deployment automation, and monitoring.The main goal of a DevOps platform is to provide a single environment for software development and IT operations teams. By automating the software delivery process, a DevOps platform helps organizations reduce the time and cost of delivering software, while also improving the reliability, security, and scalability of their applications.What is developer experience?Developer experience (DevEx) refers to the overall experience that software developers have when using development tools, frameworks, and platforms to create software applications. It encompasses all aspects of a developer's interaction with the tools, including onboarding, maintaining, ease of use, and productivity.The goal of optimizing DevEx is to make it as easy as possible for developers to create high-quality software quickly. This can involve designing tools with intuitive interfaces, providing clear and concise documentation, seamlessly integrating tools into workflows, and offering comprehensive support to help developers overcome challenges and obstacles.By prioritizing DevEx, organizations can improve the speed and quality of their software development processes, increase developer satisfaction and retention, and ultimately deliver better products.What is a software development platform?A software development platform is a set of tools, technologies, and resources that enable software developers to create, test, deploy, and maintain software applications. This typically includes a programming language or framework, an integrated development environment (IDE), libraries, code repositories, debugging and testing tools, and deployment and hosting options.The goal of a software development platform is to provide developers with a comprehensive set of tools and resources that make it easier to develop high-quality software. By providing an integrated environment for software development, a software development platform can help developers streamline their workflows, reduce errors, and improve the speed and quality of their work. Additionally, many software development platforms also provide access to a community of developers who can offer support, advice, and resources for improving software development practices.What is an application development platform?An application development platform is a set of tools that enables developers to build, deploy, and manage custom software applications.This kind of platform typically includes a programming language, software development kits (SDKs), application programming interfaces (APIs), libraries, and testing and debugging tools.These tools are designed to make it easier for developers to create and deploy custom applications for a specific platform, such as a mobile device or web browser.The goal of an application development platform is to provide developers with a comprehensive set of tools that makes it easier to create high-quality applications that meet the specific requirements of a particular platform or device.What is software development collaboration?Software development collaboration is the process of working together as a team to create, test, and deploy software applications. It can involve a range of activities, such as brainstorming, planning, code reviews, testing, and deployment. Collaboration is an essential component of the software development process, as it allows multiple developers and stakeholders to work together.Effective collaboration requires open communication, clear goals and objectives, shared resources, and a commitment to working together as a team. Collaboration tools such as version control systems, collaborative coding environments, and project management software, can also provide a centralized location for team members to share information, coordinate tasks, and track progress.Ultimately, software development collaboration is essential to creating high-quality software that’s reliable, scalable, and meets the needs of end-users and stakeholders.About GitHub EnterpriseUsing GitHub EnterpriseChoosing your planGetting started with enterprise software development platformsAbout GitHub EnterpriseWhat is GitHub Enterprise?GitHub Enterprise is an enterprise-grade software development platform designed for the complex workflows of modern development.As an extensible platform solution, GitHub Enterprise enables organizations to seamlessly integrate additional tools and functionalities, tailoring their development environment to meet specific needs and enhancing overall productivity.Why should organizations use GitHub EnterpriseThere are several reasons why organizations should consider using GitHub Enterprise:Accelerate development at scale with AI-powered development: GitHub is the world’s most widely adopted Copilot-powered developer platform helping organizations build, secure, and deliver innovative software at scale. Application security made simpler: Native security tools embedded into the developer workflow, such as GitHub Advanced Security, help developers easily fix security issues, while providing more visibility and controls.Centralize governance and compliance: Customers can access a range of administration features to help manage governance at scale and enforce business rules and policies to meet their specific needs. Boost productivity and collaboration: Increase productivity with automated CI/CD workflows using GitHub Actions, collaborate effectively with GitHub Projects and GitHub Issues, manage hosted packages with GitHub Packages, and utilize prebuilt and configured development environments with GitHub Codespaces.Greater flexibility and control over data: Whether self-hosting with GitHub Enterprise Server or using GitHub Enterprise Cloud, GitHub provides customers with flexibility and control over their data. And now with GitHub Enterprise Cloud with data residency, customers have enhanced control where certain data, like their code, resides. This is available in the EU and Australia with additional regions coming soon. Contact our sales team to learn more.Who uses GitHub Enterprise?GitHub Enterprise is used by organizations of all sizes that require greater productivity, collaboration, and security capabilities for their software development process. GitHub Enterprise can scale with teams, all the way from a small startup to a large corporation.What is GitHub Enterprise Cloud?GitHub Enterprise Cloud is the cloud-based solution of GitHub Enterprise, hosted on GitHub’s servers. This eliminates the need for organizations to maintain their own servers, infrastructure, and updates, allowing them to focus on development.In addition to the core productivity and collaboration features it provides, GitHub Enterprise Cloud provides access to additional features and add-ons for security, support, managed users, and many more. Customers can easily add or remove users as needed, and they can also increase storage capacity or processing power as their needs change.And for customers desiring more control over their data, GitHub Enterprise Cloud with data residency provides improved enterprise-grade features and more control over where code is stored. This is available in the EU and Australia with additional regions coming soon. Contact our sales team to learn more.What is GitHub Enterprise Server?GitHub Enterprise Server is the self-hosted version of GitHub Enterprise. It is installed on-premises or on a private cloud and provides organizations with a secure and customizable source code management and collaboration platform.One of the key advantages of GitHub Enterprise Server is that it provides organizations with complete control over their source code and data. Organizations can choose where to store their repositories and can control who has access to them. Administrators can also customize the platform to meet specific needs, such as integrating other tools or implementing custom workflows.GitHub Enterprise Server also offers enhanced security and compliance features. Organizations can configure their instance to meet their specific security requirements, such as using LDAP or SAML for authentication, setting up two-factor authentication, or implementing network security measures. Compliance features are also included, such as audit logs, access controls, and vulnerability scanning.How secure is GitHub Enterprise?GitHub Enterprise is designed with security in mind and includes a range of features to help organizations protect their code and data. Here are some of the key security features that GitHub Enterprise offers:Authentication and access controls: GitHub Enterprise includes two-factor authentication, LDAP and Active Directory integration, and OAuth authentication. This helps organizations ensure that only authorized users can access their repositories and data.Encryption: All data in transit between the user's computer and GitHub Enterprise server is encrypted using HTTPS. All data at rest uses AES-256 encryption.Vulnerability scanning: GitHub Enterprise includes built-in security scanning features that can detect known vulnerabilities and alert users.Audit logs: The platform provides detailed audit logs that record all user actions, including repository access, changes, and deletions. This helps organizations track and monitor user activity and identify potential security issues.Customizable policies: GitHub Enterprise allows organizations to create custom policies for repository access. This can help enforce compliance requirements and prevent unauthorized access to sensitive data.Regular security updates: There is also a dedicated security team that provides regular updates, monitors for potential security threats, and responds quickly to any issues that arise.Is GitHub Enterprise free?No, GitHub Enterprise is not free. It is a paid product that can be paid for either as a metered service on a monthly basis or as a subscription, with the cost determined by the number of users and the level of support required. For organizations interested in trying out the platform before making a commitment, GitHub Enterprise offers a free trial. Furthermore, organizations can contact the GitHub Sales team for the option to request a custom quote to meet their specific needs.Using GitHub EnterpriseHow can developers collaborate with GitHub Enterprise?Developers can collaborate with GitHub Enterprise using a variety of tools that are built into the platform, including:Pull requests: Allows developers to propose changes to a repository and submit them for review. Other team members can review the changes, leave comments, and suggest further improvements.GitHub Projects: Enables developers to track issues, assign tasks, and prioritize work. This helps teams stay on track, identify and resolve issues quickly, and ensure that everyone is working towards the same goals.GitHub Discussions: Empowers developers to have conversations about specific topics. This can be particularly useful for triaging complex issues or making decisions about the direction of a project.Choosing your planHow can organizations get started with GitHub Enterprise?To get started with GitHub Enterprise, try a free trial today or contact our sales team.What GitHub Enterprise plans are available?GitHub Enterprise offers several plans that vary in price and features. They are designed to accommodate different types of organizations and teams, from small startups to large enterprises. These plans include:GitHub Enterprise Server: This is the self-hosted version of GitHub Enterprise. It is installed on-premises or on a private cloud, and offers all the features of the cloud-based version of GitHub, including pull requests, code reviews, and project management tools. Pricing depends on the number of users and support requirements.GitHub Enterprise Cloud: This is the cloud-based version of GitHub Enterprise. It is hosted on GitHub's servers, and it offers all the features of GitHub Enterprise Server. The price depends on the number of users and storage requirements.How much does GitHub Enterprise cost?For more information on cost, please see our pricing page.Getting started with enterprise software development platformsWhat is a DevOps platform?A DevOps platform is a set of tools, technologies, and practices that enable software development and IT operations teams to collaborate and automate the software delivery process. It typically includes version control, continuous integration and continuous delivery (CI/CD), automated testing, deployment automation, and monitoring.The main goal of a DevOps platform is to provide a single environment for software development and IT operations teams. By automating the software delivery process, a DevOps platform helps organizations reduce the time and cost of delivering software, while also improving the reliability, security, and scalability of their applications.What is developer experience?Developer experience (DevEx) refers to the overall experience that software developers have when using development tools, frameworks, and platforms to create software applications. It encompasses all aspects of a developer's interaction with the tools, including onboarding, maintaining, ease of use, and productivity.The goal of optimizing DevEx is to make it as easy as possible for developers to create high-quality software quickly. This can involve designing tools with intuitive interfaces, providing clear and concise documentation, seamlessly integrating tools into workflows, and offering comprehensive support to help developers overcome challenges and obstacles.By prioritizing DevEx, organizations can improve the speed and quality of their software development processes, increase developer satisfaction and retention, and ultimately deliver better products.What is a software development platform?A software development platform is a set of tools, technologies, and resources that enable software developers to create, test, deploy, and maintain software applications. This typically includes a programming language or framework, an integrated development environment (IDE), libraries, code repositories, debugging and testing tools, and deployment and hosting options.The goal of a software development platform is to provide developers with a comprehensive set of tools and resources that make it easier to develop high-quality software. By providing an integrated environment for software development, a software development platform can help developers streamline their workflows, reduce errors, and improve the speed and quality of their work. Additionally, many software development platforms also provide access to a community of developers who can offer support, advice, and resources for improving software development practices.What is an application development platform?An application development platform is a set of tools that enables developers to build, deploy, and manage custom software applications.This kind of platform typically includes a programming language, software development kits (SDKs), application programming interfaces (APIs), libraries, and testing and debugging tools.These tools are designed to make it easier for developers to create and deploy custom applications for a specific platform, such as a mobile device or web browser.The goal of an application development platform is to provide developers with a comprehensive set of tools that makes it easier to create high-quality applications that meet the specific requirements of a particular platform or device.What is software development collaboration?Software development collaboration is the process of working together as a team to create, test, and deploy software applications. It can involve a range of activities, such as brainstorming, planning, code reviews, testing, and deployment. Collaboration is an essential component of the software development process, as it allows multiple developers and stakeholders to work together.Effective collaboration requires open communication, clear goals and objectives, shared resources, and a commitment to working together as a team. Collaboration tools such as version control systems, collaborative coding environments, and project management software, can also provide a centralized location for team members to share information, coordinate tasks, and track progress.Ultimately, software development collaboration is essential to creating high-quality software that’s reliable, scalable, and meets the needs of end-users and stakeholders.FootnotesGitHub, “Research: quantifying GitHub Copilot’s impact on developer productivity and happiness”, 2022This is currently available in the EU with additional regions coming soon. Contact our sales team to learn moreThe Total Economic Impact™ Of GitHub Enterprise Cloud and Advanced Security, a commissioned study conducted by Forrester Consulting, 2022. Results are for a composite organization based on interviewed customers.\n\n\n\nGitHub for Teams
        Build like the best teams on the planet
        With CI/CD, Dependabot, and the world’s largest developer community, GitHub gives your team everything they need to ship better software faster.
        
    
  Get started with Team
  
  


    
      
  Sign up for free
  
  

    


      
    
  

  
    

      
          
            
            
          
          
            
            
          
          
            
            
          
          
            
            
          
          
            
            
          
          
            
            
          
      
      
        
          

        
        
          

        
        
          

        
        
          

        
        
          

        
        
          

        
        
          

        
      
      
        
          
          
        
        
          
          
        
        
          
          
        
      
  




  
    
    
  



  
    Compare Plans
    Ready to get your team started?

    
      
        
          
            
              
                GitHub Free
                Basics for teams and developers
                
                  
                    
                    Unlimited public/private repositories
                  

                  
                    
                    2,000 Actions minutes/month
                  

                  
                    
                    500MB of GitHub Packages storage
                  

                  
                    
                    Dependabot
                  

                  
                    
                    Community Support
                  
                
              
            
            
                
  Get started for free
  
  

            
          
          
            Need SAML, self-hosting, or priority support?
              
    Learn more about GitHub Enterprise 


          
        

        
          
            
              
                GitHub Team
                Advanced collaboration and deploymentfeatures for teams
                
                  Everything included in Free, plus ...
                  3,000 Actions minutes/month
                  2GB of GitHub Packages storage
                  GitHub Codespaces
                  Protected branches
                  Multiple reviewers in pull requests
                  Code owners
                  Draft pull requests
                  Required reviewers
                  Pages and Wikis
                  Web-based support
                

                
                  Featured add-ons
                

                

                    
  
    
      
        
          
        

        
          
            GitHub Secret Protection
          

          
        
      
    

    
      
        Prevent secret leaks before they leak. Remediate those that exist.
      


                    
  
    
      
        
          
        

        
          
            GitHub Code Security
          

          
        
      
    

    
      
        Fix vulnerabilities in your code before they reach production.
      


                
              
              
                  Continue with Team

              
            
          
          
            Need something else?
              
    Compare all plans 


          
        
      
    
  




  
  
    
      
        

        

        

        

        

        

      
    
  



  
  
    
      Collaboration
      Manage everything in one place
    

    

      
        
          
            
              
                
                  
                  
                
              
            
            
              
                
                  
                  
                
              
            
            
              
                
                  
                  
                
              
            
            
              
                
                  
                  
                
              
            
            
              
                
                  
                  
                
              
            
            
              
                
                  
                  
                
              
            
          
        
        
          
        
        
          
            Connect your favorite tools
            Build the way that works best for you with support for all your go-to integrations, including Slack, Jira, and more.
          
        
      

      
        
          
            
            
          
        
        
          
        
        
          
            Add your team in a click
            Seamlessly update permissions and add new users as you build, whether you’re on a team of two or two thousand.
          
        
      

      
        
          
  
  
  

        
        
          
        
        
          
            Speed up code review
            Step up your code quality with code review tools that fit right into your workflow.
          
        
      

      
        
          
  
  
  

        
        
          
        
        
          
            Plan together
            Make it easy for project managers and developers to coordinate, track, and update their work in one place—so projects stay on schedule.
          
        
      

    

    
      
        
  
  
  

        

        
          “As a team, we’re way more confident that we’re in tune. We can all see our work, feedback, and roadmap going through GitHub.”
          
            
  
  
  

            Lee Adkins, Head of Engineering
            Peak Money
          
        
      
    

  



  
  
    
      
        Automation
        Build CI/CD workflows that work for you
      
      
        
          
          
        

        
          
            
              
                
                
                  Checkout
                  Check out a Git repository at a particular version.
                
              
              
                name: Checkoutuses: actions/checkout@v2.1.0
              
            
          

          
            
              
                
                
                  Set up Node.js environment
                  Set up a Node.js environment and add it to the PATH, providing additional proxy support.
                
              
              
                name: Set up Node.js for use with actionsuses: actions/setup-node@v1.1.0
              
            
          

          
            
              
                
                
                  NPM Publish
                  Automatically publish packages to NPM.
                
              
              
                name: NPM Publishuses: JS DevTools/npm-publish@v1
              
            
          
        
      

      

        
          
            
              
                
              
            
            
              Streamline your CI/CD
              Build, test, and deploy projects on any OS, language, or cloud.
            
          
        

        
          
            
              
                
              
            
            
              Choose from thousands of actions
              Find community-built GitHub Actions workflows on GitHub Marketplace, or build your own.
            
          
        

        
          
            
              
                
              
            
            
              Respond to GitHub events
              Trigger workflows based on GitHub events, including push, issue creation, new releases, and more.
            
          
        

        
          
            
              
                
              
            
            
              Collaborate on workflows
              Build, share, improve, and reuse actions just like code.
            
          
        
      

      
          
    Explore GitHub Actions 


      

      
        
          
  
  
  

          

          
            “With GitHub Actions, deployments happen 75 percent faster—taking about 10 minutes compared to the 40 minutes required when they were done manually.”
            
              
  
  
  

              Pierre Laurac, Technical Lead
              Front App
            
          
        
      

    
  



  
  
    
      
        Security
        Stay focused on development
      
      
        
        
          
          
        
      

      

        
          
            
              
                
              
            
            
              Grant the right access to your team
              Easily grant, limit, or revoke access for collaborators inside and outside your company.
            
          
        

        
          
            
              
                
              
            
            
              Keep secrets safe
              Get alerts when secrets are committed to your repositories—and notify over 30 cloud service providers automatically.
            
          
        

        
          
            
              
                
              
            
            
              Find vulnerable dependencies
              Scan your dependencies automatically. When a vulnerability is found, we’ll open a pull request with suggested fixes.
            
          
        
      

      
          
    See how GitHub helps secure your applications 


      

      
        
          
  
  
  

          

          
            “GitHub’s Dependabot security updates are smarter than any other vulnerability tracking tools we’ve used.”
            
              
  
  
  

              Alberto Giorgi, Director of Engineering
              Tray.io
            
          
        
      

    

    
      

    
  



  

    
        
          
          
        
        
          
          
        
        
          
          
        
        
          
          
        
        
          
          
        
        
          
          
        
        
          
          
        
        
          
          
        
    

    
      
        Users
        Home to the world’s software teams
        Meet your developers where they already are. GitHub is home to over 40 million developers and the world’s largest open source community.

        
          
            
              150M+ million
              developers
            
          
          
            
              1B+ billion
              contributions
            
          
          
            
              4M+ million
              organizations
            
          
        
      
    

    
        
          
          
        
        
          
          
        
        
          
          
        
        
          
          
        
        
          
          
        
        
          
          
        
        
          
          
        
    
  



  
    Customer Stories
    You’re in good company
    

      
        
          
            
              Front App
              Customer Story
              


              Read story 

            
          
          
            
            
          
        
      

      
        
          
            
              Tray.io
              Customer Story
              


              Read story 

            
          
          
            
            
          
        
      
    

    
        
    Read more customer stories 


    

  




  
    
      Build like the best
      Get the complete developer platform

      
        
  
    
  Get started with Team
  
  


    
      
  Sign up for free
  
  

    



      
    
  


  
    
      Related resources

      

              
    
        
            
              
            

          
        

      GitHub Actions cheat sheet

      
        Everything you need to know about getting started with GitHub Actions.
      

      
        Learn more 

      

              
    
        
            
              
            

          
        

      Collaboration is the key to DevOps success

      
        In a recent TechTarget study, 70 percent of organizations reported they had adopted DevOps.
      

      
        Learn more 

      

              
    
        
            
              
            

          
        

      How healthy teams build better software

      
        Your culture is key to recruiting and retaining the talent you need to ship exceptional customer experiences.
      

      
        Learn more\n\n\n\nGitHub for Startups

    
    

    Scale your startupon GitHub
      Apply today to receive startup-friendly pricing on GitHub Enterprise, Advanced Security, and the support you need to build, scale, and deliver secure software.

      
        
            
    
  Apply now
  
  




      
    

  
    
      
        
          
              Ready-to-scale developer platform
              
                Our AI-powered developer platform is equipped with the tools and integrations to build, scale, and deliver secure software.
              
              
                Get up to 20 seats of GitHub Enterprise free for one year.
              
          
        
      
      
        
          
              Build securely from the start
              
                Scale confidently with AI-powered application security tools embedded in your development workflow.
              
                
                  Get up to 20 seats of GitHub Advanced Security 50% off for one year.
                
          
        
      
      
        
          
              Community to help you grow
              
                Join our global startup network of over 30k startups across 145+ countries.
              
              
                Gain access to exclusive events and resources designed to help you scale and succeed.
              
          
        
      
    
  

  


  
    
    
    
      
        
        
        
        
        
        Collaboration that goes beyond code
        Build your business fast with access to the world’s largest open source registry. Host it in the cloud with unlimited free public and private repositories. Start conversations, propose changes, and get feedback with a pull request.
          
    Learn more 


              
        
          

        
        
        It’s like night and day. It’s the collaboration, it’s the sharing, it’s the community. It’s all because of GitHub.
        
        Shanna Senior Director of Build Platform // Autodesk
      

      
    

      
        
          
      
        
          
            
            
          
        
      

        
      

    
    
      
        
        
        
        
        
        Full project management
        Turn ideas into products with project boards and tables that integrate directly into your workflow—and link directly to your Issues. Plan your sprints, break out individual tasks, track progress, and ship software fast.
          
    Learn more 


              
        
          

        
        
        GitHub is our primary tool for R&D project management.
        
        Director of Ecosystem Engineering // Shopify
      

      
    

      
        
          
      
      
        
          
          
            
            
          
        
      

        
      

    
    
      
        
        
        
        
        
        Powerful automation and CI/CD
        Get a complete DevOps toolkit with extensive automation and CI/CD that lives right next to your code. Automate any webhook and script your entire workflow from code merges to deployments.
          
    Learn more 


              
        
          

        
        
          One of the big benefits of using GitHub for CI/CD and security automation is that we don’t have to build, deploy, or maintain additional tools because they’re built-in to GitHub. That means developers can spend less time managing tools and more time writing code, which is how they’d prefer to spend their time.
        
        Software Engineer // Mercari
      

      
    

      
        
          
      
        
          
        
        
          
        
      

        
      

    
    
      
        
        
        
        
        
        Security trusted by the Fortune 100
        GitHub offers the most trusted platform that helps with compliance and keeps your code secure. Stay ahead of security issues, get advanced monitoring, and build your business with confidence.
          
    Learn more 


              
        
          

        
        
          Six months ago we had around 60 outstanding security CVEs. Today, we have zero.
        
        Senior Engineering Manager // Wealthsimple
      

      
    

      
        
          
              
  
  
  

              
  
  
  

        
      

    
    
      
        
        
        
        
        
        Build on the shoulders of giants
        With the world’s largest software registry, GitHub makes it simple to find the best open source projects to accelerate your workflows and scale your business fast.
          
    Learn more 


              
        
          

        
        
        There is a huge open source community of code and developers to work with and draw inspiration from on GitHub. To build better developer tools, we need a direct line to it. GitHub accelerates production, progress, and connections, bringing us closer to our users.
        
        Developer Advocate // Stripe
      

      
    

      
        
          
        
          
            
          
        

        
          
            
              
            
          
          
            
              
            
          
          
            
              
            
          
          
            
              
            
          
        

        
      

    
    
      
        
        
        
        
        
        Build like the best
        From Spotify to Slack and Shopify to Netflix, the world’s most innovative companies are built on GitHub. That’s because GitHub offers the most complete—and most trusted—developer platform.
        
        
      
    

      
        
          

    
      
        

      
      
        

      
      
        

      
      
        

      
      
        

      
      
        

      
    

        
      

  



  
    Get started today
      
        Apply now to receive startup friendly pricing on GitHub Enterprise, Advanced Security, and the support you need to build, scale, and deliver secure software.
      

      

  
    
  
    
      
        GitHub for Startups Sign-up Form
      
        
    
    
      
    
  
  

      
            
      
          
          
          

          
            GitHub for Startups Sign-up Form
          
          
            Eligibility
          
          
              
                Funding Stage: Must have received outside funding (up to Series B or earlier).
                New to GitHub Plans & Credits: Must be new to GitHub Enterprise or Advanced Security, or have not been on an Enterprise plan within the past 6 months, including not having received credits for either plan.
              
          

          
            Want to add an extra year of savings on Enterprise and Advanced Security? Refer your investor, accelerator, or incubator to become an approved GitHub for Startups partner and apply with their unique application link!
          

          
            If you’re accepted, you’ll receive an email with further instructions within 2-4 business days. If you have any questions, please reach out to our team.
          

          
              * - required field
          

          
            
              
                Company Name
              
              
                
              
            

            
              
                
                  First Name
                
                
                  
                
              

              
                
                  Last Name
                
                
                  
                
              
            

            
              
                
                  Email Address
                
                
                  
                  
                    Please use an email with your company domain. Personal emails or emails that do not match the GitHub Account owner will be rejected. GitHub sends all important communications to the primary email of the admin - if you need to update your primary email address, please follow these instructions before submitting your application.
                  
                
              

              
                
                  Role in Company
                
                
                  Please select
Cofounder CEO
Cofounder/CTO
Technical Lead
Cofounder (other)
                
              
            

            
              
                Company Website
              
              
                
                Applications with invalid websites and/or websites with inappropriate content will be rejected.
              
            

            
              
                Company overview
              
              
                
                In a few sentences, please share a bit more about your company.
              
            

            
              
                
                  Industry
                
                
                  Please select
Agriculture & Mining
Business Services
Computers & Electronics
Consumer Services
Education
Energy & Utilities
Financial Services
Food & Beverage
Government
Healthcare
Manufacturing
Media & Entertainment
Not for Profit
Real Estate & Construction
Retail
Software & Internet
Telecommunications
Transportation & Storage
Travel, Recreation, and Leisure
Whole & Distribution
Other
                
              

              
                
                  Latest Funding Round
                
                
                  Please select
Bootstrap
Pre-Seed
Seed
Series A
Series B
Series C or later
                
              
            

            
              
                
                  Total Funding Raised
                
                
                  Please select
<$1M USD
$1M-$2M USD
$2M-$5M USD
$5M-$10M USD
$10M-$25M USD
$25M+ USD
                
              
            

            
              
                Proof of Funding
              
              
                
                  Provide links from credible sources such as third-party news, startup investment platforms (e.g. Crunchbase), or investor portfolio pages or blog posts. Self-published content will not be accepted. If you are a stealth startup, please apply through your approved GitHub for Startups partner page.
              
            

            

            
              Account Information
              You will not be billed at this time. This information will be used for any paid add-ons or upgrades you choose to add (beyond the 20 seat offer) during or after the program.
            

            
              
  
    Country
  
  
    Please selectAfghanistan
Åland
Albania
Algeria
American Samoa
Andorra
Angola
Anguilla
Antarctica
Antigua and Barbuda
Argentina
Armenia
Aruba
Australia
Austria
Azerbaijan
Bahamas
Bahrain
Bangladesh
Barbados
Belarus
Belgium
Belize
Benin
Bermuda
Bhutan
Bolivia
Bonaire, Sint Eustatius and Saba
Bosnia and Herzegovina
Botswana
Bouvet Island
Brazil
British Indian Ocean Territory
Brunei Darussalam
Bulgaria
Burkina Faso
Burundi
Cambodia
Cameroon
Canada
Cape Verde
Cayman Islands
Central African Republic
Chad
Chile
China
Christmas Island
Cocos (Keeling) Islands
Colombia
Comoros
Congo (Brazzaville)
Congo (Kinshasa)
Cook Islands
Costa Rica
Côte d'Ivoire
Croatia
Curaçao
Cyprus
Czech Republic
Denmark
Djibouti
Dominica
Dominican Republic
Ecuador
Egypt
El Salvador
Equatorial Guinea
Eritrea
Estonia
Ethiopia
Falkland Islands
Faroe Islands
Fiji
Finland
France
French Guiana
French Polynesia
French Southern Lands
Gabon
Gambia
Georgia
Germany
Ghana
Gibraltar
Greece
Greenland
Grenada
Guadeloupe
Guam
Guatemala
Guernsey
Guinea
Guinea-Bissau
Guyana
Haiti
Heard and McDonald Islands
Honduras
Hong Kong
Hungary
Iceland
India
Indonesia
Iran
Iraq
Ireland
Isle of Man
Israel
Italy
Jamaica
Japan
Jersey
Jordan
Kazakhstan
Kenya
Kiribati
Korea, South
Kuwait
Kyrgyzstan
Laos
Latvia
Lebanon
Lesotho
Liberia
Libya
Liechtenstein
Lithuania
Luxembourg
Macau
Macedonia
Madagascar
Malawi
Malaysia
Maldives
Mali
Malta
Marshall Islands
Martinique
Mauritania
Mauritius
Mayotte
Mexico
Micronesia
Moldova
Monaco
Mongolia
Montenegro
Montserrat
Morocco
Mozambique
Myanmar
Namibia
Nauru
Nepal
Netherlands
New Caledonia
New Zealand
Nicaragua
Niger
Nigeria
Niue
Norfolk Island
Northern Mariana Islands
Norway
Oman
Pakistan
Palau
Palestine
Panama
Papua New Guinea
Paraguay
Peru
Philippines
Pitcairn
Poland
Portugal
Puerto Rico
Qatar
Reunion
Romania
Rwanda
Saint Barthélemy
Saint Helena
Saint Kitts and Nevis
Saint Lucia
Saint Martin (French part)
Saint Pierre and Miquelon
Saint Vincent and the Grenadines
Samoa
San Marino
Sao Tome and Principe
Saudi Arabia
Senegal
Serbia
Seychelles
Sierra Leone
Singapore
Sint Maarten (Dutch part)
Slovakia
Slovenia
Solomon Islands
Somalia
South Africa
South Georgia and South Sandwich Islands
South Sudan
Spain
Sri Lanka
Sudan
Suriname
Svalbard and Jan Mayen Islands
Swaziland
Sweden
Switzerland
Taiwan
Tajikistan
Tanzania
Thailand
Timor-Leste
Togo
Tokelau
Tonga
Trinidad and Tobago
Tunisia
Türkiye
Turkmenistan
Turks and Caicos Islands
Tuvalu
Uganda
Ukraine
United Arab Emirates
United Kingdom
United States Minor Outlying Islands
United States of America
Uruguay
Uzbekistan
Vanuatu
Vatican City
Venezuela
Vietnam
Virgin Islands, British
Virgin Islands, U.S.
Wallis and Futuna Islands
Yemen
Zambia
Zimbabwe
  



            

            

            
              
                
                  GitHub for Startups Partner
                
                
                  
                  Please provide the name of the accelerator/incubator/VC fund through which you are applying for GitHub for Startups benefits. If you were referred by a GitHub employee, please list their email here.
                
              
            

            
              
                GitHub Enterprise Slug
              
              
                
                Please provide your startup’s GitHub Enterprise account in the format github.com/enterprises/SLUG. You can sign up for an Enterprise trial. Ensure you sign up for the trial using personal accounts. Applications with invalid, organization, or managed user accounts will be rejected. See details on account types to learn more.
              
            

            

            
              
                
                    I hereby accept the GitHub Customer Agreement on behalf of my organization and confirm that I have the authority to do so. For more information about GitHub's privacy practices, see the GitHub Privacy Statement.
              
            

            
              
                
                    I agree to the GitHub for Startups Terms and Conditions.
              
            

            
            
            
            
            
            
            

            Sign up for GitHub for Startups
          
    

      
      



  Apply now
  
  




    

    
  
      
          
    
    
    Early-stage startup
    You must be an early-stage startup that has received outside equity funding (Series B or earlier).
    
  

      

      
          
    
    
    New to GitHub Enterprise and/or Advanced Security
    You must be new to Enterprise or Advanced Security, or have not been on either plan in the past 6 months, and you should not have received credits for either plan.
    
  

      


  

    
    
      
        
        
        
        
        
        Our partners help us create the unicorns of tomorrow
        We know the value of community. That’s why GitHub for Startups partners with leading investors, accelerators, and startup support organizations to help early-stage startups go from seed funding to unicorn status. Startups affiliated with a GitHub for Startups partner are eligible for additional discounts and benefits while in the program.
        
              

  
    
  
    
      
        GitHub for Startups Partner Application
      
        
    
    
      
    
  
  

      
            
      
          
          
          

          
            GitHub for Startups Partner Application
          

          
            
              
                
                  Contact First Name
                
                
                  
                
              

              
                
                  Contact Last Name
                
                
                  
                
              
            

            
              
                Contact Email Address
              
              
                
              
            

            
              
                Company Name
              
              
                
              
            

            
              
                Role
              
              
                
              
            

            
              
                Website
              
              
                
              
            

            
  
    HQ Country
  
  
    Please selectAfghanistan
Åland
Albania
Algeria
American Samoa
Andorra
Angola
Anguilla
Antarctica
Antigua and Barbuda
Argentina
Armenia
Aruba
Australia
Austria
Azerbaijan
Bahamas
Bahrain
Bangladesh
Barbados
Belarus
Belgium
Belize
Benin
Bermuda
Bhutan
Bolivia
Bonaire, Sint Eustatius and Saba
Bosnia and Herzegovina
Botswana
Bouvet Island
Brazil
British Indian Ocean Territory
Brunei Darussalam
Bulgaria
Burkina Faso
Burundi
Cambodia
Cameroon
Canada
Cape Verde
Cayman Islands
Central African Republic
Chad
Chile
China
Christmas Island
Cocos (Keeling) Islands
Colombia
Comoros
Congo (Brazzaville)
Congo (Kinshasa)
Cook Islands
Costa Rica
Côte d'Ivoire
Croatia
Curaçao
Cyprus
Czech Republic
Denmark
Djibouti
Dominica
Dominican Republic
Ecuador
Egypt
El Salvador
Equatorial Guinea
Eritrea
Estonia
Ethiopia
Falkland Islands
Faroe Islands
Fiji
Finland
France
French Guiana
French Polynesia
French Southern Lands
Gabon
Gambia
Georgia
Germany
Ghana
Gibraltar
Greece
Greenland
Grenada
Guadeloupe
Guam
Guatemala
Guernsey
Guinea
Guinea-Bissau
Guyana
Haiti
Heard and McDonald Islands
Honduras
Hong Kong
Hungary
Iceland
India
Indonesia
Iran
Iraq
Ireland
Isle of Man
Israel
Italy
Jamaica
Japan
Jersey
Jordan
Kazakhstan
Kenya
Kiribati
Korea, South
Kuwait
Kyrgyzstan
Laos
Latvia
Lebanon
Lesotho
Liberia
Libya
Liechtenstein
Lithuania
Luxembourg
Macau
Macedonia
Madagascar
Malawi
Malaysia
Maldives
Mali
Malta
Marshall Islands
Martinique
Mauritania
Mauritius
Mayotte
Mexico
Micronesia
Moldova
Monaco
Mongolia
Montenegro
Montserrat
Morocco
Mozambique
Myanmar
Namibia
Nauru
Nepal
Netherlands
New Caledonia
New Zealand
Nicaragua
Niger
Nigeria
Niue
Norfolk Island
Northern Mariana Islands
Norway
Oman
Pakistan
Palau
Palestine
Panama
Papua New Guinea
Paraguay
Peru
Philippines
Pitcairn
Poland
Portugal
Puerto Rico
Qatar
Reunion
Romania
Rwanda
Saint Barthélemy
Saint Helena
Saint Kitts and Nevis
Saint Lucia
Saint Martin (French part)
Saint Pierre and Miquelon
Saint Vincent and the Grenadines
Samoa
San Marino
Sao Tome and Principe
Saudi Arabia
Senegal
Serbia
Seychelles
Sierra Leone
Singapore
Sint Maarten (Dutch part)
Slovakia
Slovenia
Solomon Islands
Somalia
South Africa
South Georgia and South Sandwich Islands
South Sudan
Spain
Sri Lanka
Sudan
Suriname
Svalbard and Jan Mayen Islands
Swaziland
Sweden
Switzerland
Taiwan
Tajikistan
Tanzania
Thailand
Timor-Leste
Togo
Tokelau
Tonga
Trinidad and Tobago
Tunisia
Türkiye
Turkmenistan
Turks and Caicos Islands
Tuvalu
Uganda
Ukraine
United Arab Emirates
United Kingdom
United States Minor Outlying Islands
United States of America
Uruguay
Uzbekistan
Vanuatu
Vatican City
Venezuela
Vietnam
Virgin Islands, British
Virgin Islands, U.S.
Wallis and Futuna Islands
Yemen
Zambia
Zimbabwe
  




            
              
                Organization Type
              
              
                Please select
Incubator/Accelerator
VC
TechHub
Startup Ecosystem Partner
              
            

            
              
                
                  Portfolio Size
                
                
                  
                
              

              
                
                  Number of Investments Annually
                
                
                  
                
              
            

            

            
              
                
                    GitHub for Startups provides certain resources to approved startup partners and startups in their portfolio, which are subject to change. I hereby accept the GitHub Logo Policy and GitHub Privacy Statement policy agreements on behalf of my organization.
              
            

            
            
            
            
            
            

            Apply to become a GitHub for Startups Partner
          
    

      
      



  Apply to become a partner
  
  




      
    

      
        
          
    
      
        

      
      
        

      
      
        

      
      
        

      
      
        

      
    

        
      

  
  
    Frequently asked questions

        
  
    
      
      
        What’s included in the GitHub for Startups offer?
      
    
    
      All GitHub for Startups companies receive up to 20 seats of GitHub Enterprise for free for 12 months*. Additionally, those interested can also redeem 20 seats of Advanced Security for 12 months at 50% off.  Learn more about the features and capabilities of GitHub Enterprise and Advanced Security.
*Startups affiliated with a GitHub for Startups VC or accelerator partner may be eligible for additional discounts and benefits. See list of partners. Don’t see your partner? Share this link to refer your partner to the GitHub for Startups partner program.
      
    
  


        
  
    
      
      
        Who is eligible to apply?
      
    
    
      Startups that meet the following criteria are eligible to apply for the GitHub for Startups program:

Received outside equity funding (up to Series B)
New to GitHub Enterprise or Advanced Security, or have not been on either plan within the past 6 months, including not having received credits for either plan.
Must not have previously received credits for GitHub Enterprise or Advanced Security.

      
    
  


        
  
    
      
      
        What if my startup is not eligible for GitHub for Startups? Are there other resources for me?
      
    
    
      If you’re not currently eligible for GitHub for Startups, please feel to sign up for a trial.
      
    
  


        
  
    
      
      
        How can my organization become a GitHub for Startups partner?
      
    
    
      Any investor, accelerator, or startup support organization is eligible to apply for the GitHub for Startups program. Apply here.
      
    
  


        
  
    
      
      
        Startup Program Terms & Conditions
      
    
    
      
Subscription Model: We do not support the pay-as-you-go billing model. By applying, you agree to switch to a subscription-based pricing model for the duration of your participation in the GitHub for Startups program.
Metered Add-ons: Metered product add-ons (like Copilot, larger runners, Codespaces, etc.) are not included in the program, and will be charged at standard rates.
Managed Users: Enterprise Accounts with managed users are not supported.
Payment Method: You must have a valid payment method on file\n\n\n\nSolutionsBy industryGitHub for NonprofitsDrive social impact one commit at a timeGitHub for Nonprofits enables organizations to leverage technology to drive forward their missions and accelerate human progress. Verified nonprofits get exclusive access to a free GitHub Team plan or 25% off the GitHub Enterprise cloud plan.Join GitHub for NonprofitsExclusive discounts for verified nonprofitsFree access to a GitHub Team planReceive access to advanced collaboration tools for individuals and organizations.25% off GitHub Enterprise CloudGet access to additional security, administrative, and customization options.Which plan is for you?GitHub Team offers collaboration for growing teams while GitHub Enterprise Cloud adds additional Actions and security features.Let GitHub power your missionInvesting in GitHub is not just about adopting a tool—it's about empowering nonprofits to drive positive change and advance the Sustainable Development Goals. Join us at GitHub, where technology meets purpose, and together, let's create a more sustainable and equitable future for all.Increase visibility and widen impactBy hosting projects on GitHub, nonprofits can increase their visibility and reach a broader audience. Whether it's sharing code libraries, publishing research, or showcasing success stories, GitHub provides nonprofits with a platform to amplify their impact and attract support from donors, funders, volunteers, and partners.Tap into the open source communityGitHub is home to the largest open source community on the planet - over 100 million developers. Whether you’re scaling your organization or just learning how to code, GitHub is your home.  Join the world’s largest developer platform to build the innovations that empower humanity.“GitHub provides us with a platform to amplify the critical needs of forcibly displaced persons and attract support from donors, volunteers, and partners, while also tapping into skills and resources of an incredible developer community.
Seema IyerUSA for UNCHRGet started todayBuild your nonprofit on the world's most advanced developer platform. Verified nonprofits get exclusive access to a free GitHub Team plan or 25% off the GitHub Enterprise cloud plan.Join GitHub for NonprofitsContact usFrequently Asked QuestionsWho qualifies for GitHub for Nonprofits?Nonprofit organizations that are 501(c)(3) or equivalent and are non-governmental, non-academic, non-commercial, non-political in nature, and have no religious affiliation are eligible for a free GitHub Team Plan with unlimited private repositories and unlimited users or 25% off of GitHub Enterprise Cloud.What if our organization does not qualify for nonprofit status but works in the social sector?At this time, we only support registered 501(c)(3) or equivalent organizations. In the future, we hope to provide additional programmatic support to social sector organizations.What are the different GitHub pricing plans?GitHub offers free and paid plans for storing and collaborating on code. Some plans are available only to personal accounts, while other plans are available only to organization and enterprise accounts. For more information about accounts, see "Types of GitHub accounts."I have another question, how do I reach the team?If you would like to learn more about our programming, partner with us, or get in touch, contact our team today.\n\n\n\nSolutionsBy use caseGitHub DevSecOpsThe AI-powered DevSecOps platformWith comprehensive security tools built into the developer workflow, you can build, secure, and ship all in one place. 

Request a demoSee plans & pricingIntegrate AI-powered security features directly into your development workflow, eliminating the need for third-party tools.Code scanningFind and fix security issues before production with static application security testing (SAST).
Secret scanningHunt, revoke, and prevent leaked secrets with automatic push protection.
Supply chain securityKeep vulnerable dependencies out of your applications with software composition analysis (SCA).
Logos for EY Mercado Libre 3M KPMG TELUSGive AI the heavy liftingOrganizations struggle to fix their backlog of vulnerabilities, despite the risks. Coming next, security managers can burn down years of security debt in one simple sprint.Discover GitHub CopilotFound means fixedDon’t just find vulnerable code, fix it. GitHub Advanced Security flags problems and suggests AI-powered solutions, freeing teams to ship more secure software faster.Explore AI-powered securityPump your team’s security prowessDevelopers aren’t security professionals. With GitHub Advanced Security, you can offload the technical complexity and give them the freedom to build and ship great software.
Discover code scanning autofixYour workflows, your wayWith support for more than 17,000 app integrations, GitHub Advanced Security accommodates your team’s tooling preferences.Explore GitHub Marketplace7xfaster vulnerabilities fixes 2.4fewer false positives than the industry standard20Mrepositories that have enabled secret scanning“We prefer to have security that leverages what developers are already using rather than trying to force them to use some other tool.
Emilio EscobarChief Information Security Officer @ DatadogApplication security made simplerEliminate toolchain cost and complexity with native security tools for GitHub Enterprise and Azure DevOps customers.
Request a demoSee plans & pricingAdditional resourcesDevSecOps explainedExplore how DevSecOps builds on the ideas of DevOps by applying security practices throughout the SDLC.
Learn moreMeet the companies who build with unified DevSecOpsLeading organizations choose GitHub to plan, build, secure, and ship software.
Read customer storiesDiscover how AI is changing the security landscapeFrom prevention to remediation, see how AI can help fix issues instantly.Watch webinar\n\n\n\nSolutionsBy use caseGitHub DevOpsThe unified platform for your DevOps lifecycle Build, scale, and deliver more secure software with GitHub's unified AI-powered developer platform.Start a free trialContact salesKeep developers in the flow with automation, AI, collaboration tools, and more.Increase collaborationGet the tools you need to facilitate collaboration among teams.
Eliminate barriersHarness the power of AI-powered coding to empower developer creativity and innovation.
Reduce context switchingBoost productivity with a single, integrated developer platform with powerful native tools to keep developers in the flow.
Logos for Ford, Shopify, NASA, Vercel, and SpotifyDrive innovation with AI-powered developer toolsAI-driven code suggestions enhances job satisfaction and focus for 60-75% of developers, reducing frustration and enabling more rewarding work.Explore GitHub CopilotBuilt-in securityManage the SDLC with automated security tools. Find and fix vulnerabilities quickly and efficiently with security checks integrated into every step of the developer's workflow.Explore GitHub Advanced SecurityStreamline team collaborationHelp developers and operations teams more regularly communicate and provide feedback about timelines and goals so everyone is responsible for the project’s success.Explore collaboration tools88%of developers experience increased productivity75%reduced time spent managing tools1minset-up time for largest repo with GitHub CodespacesBuild and innovate with a leader in the Gartner® Magic Quadrant™ for DevOps PlatformsRead the report“The availability of out-of-the-box integrations with our existing tooling is a big part of GitHub’s appeal. GitHub really helps bring DevOps to life.Danilo SuntalManufacturing Data Flow Product and Platform, P&GDevOps strategies, amplified by GitHub toolsTrusted by 90% of the Fortune 100, GitHub helps millions of developers and companies collaborate, build, and deliver secure software faster. And with thousands of DevOps integrations, developers can build smarter from day one with the tools you know and love—or discover new ones.
Start a free trialContact salesAdditional resourcesFind the right DevOps platformNarrow your search with the 2024 Gartner® Magic Quadrant™ for DevOps Platforms report.Get the Gartner reportWhat is DevOps?By bringing people, processes, and products together, DevOps enables development teams to continuously deliver value.Learn more about DevOpsDiscover innersourceThis practice empowers developers to save time and energy by bringing methodologies from open source into their internal development.
Read more on Innersouce\n\n\n\nSolutionsBy use caseGitHub CI/CDThe complete CI/CD solutionBuild, test, and deploy software with simple and secure enterprise CI/CD, all on the complete development platform.
Start a free trialContact salesStreamline, secure, and deploy with confidence: automate your software delivery pipelineTurn code into softwareAutomatically trigger builds on every commit with workflow builder.
Secure and improveEnd-to-end testing for security, code quality, performance, and functionality.
Ship with confidenceAutomate deployments from start to finish to one or multiple cloud providers.
Build fast, stay secureEasy-to-set-up and simple-to-maintain CI/CD that helps your developers build more secure code from the start without sacrificing speed.Explore GitHub Advanced SecurityContinuous testing made simpleTrack everything from code quality to your security profile with end-to-end testing built to keep you secure and in compliance at every stage.Deploy software with confidenceSeamless CI/CD deployment automation makes it simple to deliver secure software with all cloud providers so you can scale confidently.Explore GitHub Actions90%+Fortune 100 choose GitHub100M+Developers call GitHub home420M+Repositories on GitHubPowerful CI/CD with GitHub EnterpriseThe complete developer platform to build, scale, and deliver secure software.Start a free trialContact salesAdditional resourcesDevOps tips for Engineering leaders6 DevOps tips to help engineering leaders deliver software at scale
Get the report Ship secure software fastHow developer-first supply chain security helps you secure faster
Get the report CI/CD Solution Demo How to automate CI/CD and security with GitHub Enterprise
Get the report\n\n\n\nSolutionsUse CasesGitHub solutionsSolve your business challenges with proven combinations of GitHub solutions, empowering your team to ship secure software quickly and accelerate innovation.  Start a free trialContact salesDevSecOpsWith comprehensive security tools built into the developer workflow, you can build, secure, and ship all in one place.
Learn moreDevOpsScale and deliver more secure software with GitHub's unified AI-powered developer platform.Learn moreCI/CDTest and deploy software with simple and secure enterprise CI/CD.Learn moreRelated solutionsHealthcareBy incorporating security checks into developer workflows, you can build secure communication channels between patients and providers.Learn moreFinancial ServicesWith an AI-powered developer platform, you can build innovative financial solutions that drive economic growth.Learn moreManufacturingWith robust CI/CD that can handle the complex needs of manufacturing, you can securely transform operations at scale.Learn more2.4xmore precise leaked secrets found with fewer false positives~25%increase in developer speed with GitHub Copilot1minset-up time for largest repo with GitHub Codespaces+88%more productivity with GitHub Enterprise Get startedTrusted by 90% of the Fortune 100, GitHub helps millions of developers and companies collaborate, build, and deliver secure software faster. And with thousands of DevOps integrations, developers can build smarter from day one with the tools they know and love—or discover new ones.
Start a free trialContact sales\n\n\n\nSolutionsBy industryHealthcare solutionsEmpower healthcare development with a secure, AI-powered platformBy incorporating AI into developer workflows, you can build secure patient care solutions at scale. Start a free trialContact salesA single, integrated, enterprise-ready platformEnhance patient careFacilitate rapid innovation so you can implement the latest technologies more reliably.Unlock engineering potentialEmpower developer collaboration, productivity, and creativity at scale.Streamline healthcare developmentFocus on delivering impactful patient outcomes by priming your engineering staff for growth.Lorem IpsumDrive healthcare innovation with AIBy enabling your developers to code up to 55% faster, you can stay ahead of advancements and innovate services while remaining secure and compliant. 
Explore GitHub CopilotProtect patient dataCreate more secure healthcare applications by detecting vulnerabilities in your codebase and preventing credentials from being exposed.
Explore GitHub Advanced SecurityAutomate manual tasksMake life easier for developers. Reduce time-to-market and improve responsiveness to patients and stakeholders by using enterprise-ready, scalable CI/CD.
Explore GitHub Actions+88%more productivity with GitHub Enterprise 1minset-up time for largest repo with GitHub Codespaces~25%increase in developer speed with GitHub CopilotRead how Doctolib fostered a culture of reusability and simplified the CI/CD process with GitHub.Read the customer story3M transforms its software toolchain to bring cutting-edge science to customers, faster.Read storyPhilips builds and deploys digital health technology faster with innersource on GitHub.Read storyGitHub brings DevOps to life and enables streamlined developer experiences at Procter & Gamble.Read story“Healthcare organizations want a service that provides a world-class experience for patients and improves people’s lives. GitHub helps us meet and exceed those expectations.David TerolProgram director at the Philips Software Center of ExcellenceDevOps strategies for healthcare innovation, amplified by GitHubTrusted by 90% of the Fortune 100, GitHub helps millions of developers and companies collaborate, build, and deliver secure software faster. And with thousands of DevOps integrations, developers can build smarter from day one with the tools they know and love—or discover new ones.
Start a free trialContact salesAdditional resourcesFind the right DevOps platformNarrow your search with the 2024 Gartner® Magic Quadrant™ for DevOps Platforms report.Get the Gartner reportWhat is DevOps?By bringing people, processes, and products together, DevOps enables development teams to continuously deliver value.Learn more about DevOpsDiscover innersourceThis practice empowers developers to save time and energy by bringing methodologies from open source into their internal development.
Read more on Innersouce\n\n\n\nSolutionsBy industryFinancial servicesTransform financial services with a secure, AI-powered solution By embedding AI into developer workflows, you can accelerate secure financial innovation at scale. 
Start a free trialContact salesBuild secure financial services by having an all-in-one platform that eliminates the need for third-party tools and keeps developers in the flow.Reduce riskAvoid data breaches and fraud by incorporating security practices throughout the development process.
Increase speed and efficiencyEnable faster development and deployment of new features and services by leaving the manual, repetitive tasks to AI.
Streamline operationsImprove efficiency and enhance developer creativity by working on a single, secure, AI-powered platform.
Logos for Itaú Mercari Mercado Libre Stripe and PlaidGet ahead with AI-powered innovationStay at the forefront of technological advancements by using AI-powered tools to innovate services while remaining secure and compliant.Explore GitHub CopilotEnhance regulatory compliance and securityMeet regulatory standards and secure your supply chain by leveraging  AI-powered compliance features and natively-embedded application security testing.Explore GitHub Advanced SecurityAccelerate software developmentAutomation is everything. Reduce time-to-market and improve responsiveness to customers by using enterprise-ready, scalable CI/CD.Explore GitHub ActionsRead how Societe Generale tripled their releases and cut development time by more than half.Read the customer story“We used to have other tools as well, but GitHub offers us with an all-in-one solution that provides developers a single source of truth for security notifications and code management.David HeitzingerHead of Agile Engineering Support // Raiffeisen BankDevOps strategies for financial innovation, amplified by GitHubTrusted by 90% of the Fortune 100, GitHub helps millions of developers and companies collaborate, build, and deliver secure software faster. And with thousands of DevOps integrations, developers can build smarter from day one with the tools they know and love—or discover new ones.Start a free trialContact salesFind the right DevOps platformNarrow your search with the 2024 Gartner® Magic Quadrant™ for DevOps Platforms report.Get the Gartner reportWhat is DevOps?By bringing people, processes, and products together, DevOps enables development teams to continuously deliver value.Learn more about DevOpsDiscover innersourceThis practice empowers developers to save time and energy by bringing methodologies from open source into their internal development.
Read more on Innersouce\n\n\n\nSolutionsBy industryManufacturing solutionsAdvance manufacturing with a complete, AI-powered platformBy integrating AI into developer workflows, you can securely transform manufacturing operations at scale.Start a free trialContact salesSupport manufacturing's complex needs with an all-in-one platform that eliminates third-party tools, keeping developers in flow.Enhance industrial efficiencyEnsure the reliable implementation of cutting-edge technologies by incorporating security practices throughout the development process. 
Move fast, safelyBuild at the speed of innovation and enable faster deployment by embedding AI into developer workflows.
Reduce context switchingBoost efficiency and increase creativity by enabling developers to plan, track, and build in a single, integrated, AI-powered platform.
Logos for 3M P&G Decathlon Ford and BoltDrive industrial innovationBoost developer productivity and innovation with AI-powered tools, while remaining secure and compliant.Explore GitHub CopilotSecure your supply chainMinimize the risk of disruptions and data breaches by using robust security features and best practices, embedded directly into the developer workflow.Explore GitHub Advanced SecuritySupport developers with automation Transform continuous integration processes by using enterprise-ready, scalable CI/CD—now with Arm-hosted runners.Explore Arm64 on GitHub ActionsRead how Procter & Gamble streamlined the developer experience and improved developer satisfaction and security. Read the customer story“You don’t have to go out to a separate project management tool. You don’t have to go to a spreadsheet, or a Microsoft project, or into Jira. It’s all on GitHub. It’s made us more productive.Tina Beamer3M IT manager of operations and qualityDevOps strategies for manufacturing innovation, amplified by GitHubTrusted by 90% of the Fortune 100, GitHub helps millions of developers and companies collaborate, build, and deliver secure software faster. And with thousands of DevOps integrations, developers can build smarter from day one with the tools they know and love—or discover new ones.Start a free trialContact sales\n\n\n\nSolutionsBy industryGovernment solutionsEmpowering government agencies with secure, collaborative software developmentWith seamless collaboration and robust compliance, GitHub helps government agencies build and innovate securely on a single, AI-powered platform.Start a free trialContact salesTransforming government software development with security, collaboration, and flexibilitySecure and compliant development With FedRAMP authorization and industry-leading security features, GitHub meets the highest standards of compliance and protection. 
Efficient collaboration across teams GitHub’s collaborative platform enables seamless code sharing, review, and feedback within your agency or with external partners.
Flexible deployment options No matter where you need to host, GitHub Enterprise offers flexible deployment options to meet your agency’s unique operational requirements.Protect sensitive data Help keep your agency’s code secure with built-in vulnerability scanning, secret detection, and compliance monitoring, all seamlessly integrated into your development workflow..
Explore GitHub Advanced SecurityAccelerate development with AI-powered assistanceWhether drafting complex algorithms or automating tasks, GitHub Copilot empowers your agency to deliver mission-critical software with speed and precision.Explore GitHub CopilotAutomated, secure CI/CDWith customizable workflows and integrations, your agency can streamline operations and ensure consistent, high-quality code delivery.Explore GitHub ActionsLearn how the VA modernizes its approach to make healthcare more accessible to millions of veterans.
Read the customer story“We reduced our deployment time significantly. To deliver quickly, using GitHub and Azure DevOps for our DevSecOps process, CI/CD, infrastructure, code, and automation was the key.Shamal SiwanLead DevOps Engineer/Solutions Architect  //  California Department of TechnologyDevOps strategies for government agencies, amplified by GitHubTrusted by 90% of the Fortune 100, GitHub helps millions of developers and companies collaborate, build, and deliver secure software faster. And with thousands of DevOps integrations, developers can build smarter with the tools they know from day one—or discover new ones.
Contact salesStart a free enterprise trialAdditional resourcesFind the right DevOps platformNarrow your search with the 2024 Gartner® Magic Quadrant™ for DevOps Platforms report.Get the Gartner reportWhat is DevOps?By bringing people, processes, and products together, DevOps enables development teams to continuously deliver value.Learn more about DevOpsDiscover innersourceThis practice empowers developers to save time and energy by bringing methodologies from open source into their internal development.
Read more on Innersouce\n\n\n\nSolutionsIndustriesIndustry solutionsDiscover how GitHub’s industry solutions can help you improve efficiency, reduce costs, and capture new market opportunities.Start a free trialContact salesHealthcareBy incorporating security checks into developer workflows, you can build secure communication channels between patients and providers.Learn moreFinancial ServicesWith an AI-powered developer platform, you can build innovative financial solutions that drive economic growth.Learn moreManufacturingWith robust CI/CD that can handle the complex needs of manufacturing, you can securely transform operations at scale.Learn moreGovernmentWith seamless collaboration and robust compliance, GitHub helps government agencies build and innovate securely on a single, AI-powered platform.Learn moreRelated solutionsDevSecOpsWith comprehensive security tools built into the developer workflow, you can build, secure, and ship all in one place.
Learn moreDevOpsScale and deliver more secure software with GitHub's unified AI-powered developer platform.Learn moreCI/CDTest and deploy software with simple and secure enterprise CI/CD.Learn moreExecutive InsightsGet expert perspectives. Stay ahead with insights from industry leaders.Learn moreNarrow your DevOps platform search with this Gartner reportRead the report2.4xmore precise leaked secrets found with fewer false positives~25%increase in developer speed with GitHub Copilot1minset-up time for largest repo with GitHub Codespaces+88%more productivity with GitHub Enterprise Get startedTrusted by 90% of the Fortune 100, GitHub helps millions of developers and companies collaborate, build, and deliver secure software faster. And with thousands of DevOps integrations, developers can build smarter from day one with the tools they know and love—or discover new ones.Start a free trialContact sales\n\n\n\nAI-powered platform solutions to solve your company’s challengesGitHub empowers your team to deliver software faster and more efficiently, while maintaining robust security and compliance. Start a free trialContact salesGitHub scales with teams of any size.EnterprisesBuild, scale, and deliver secure software faster with GitHub’s AI-powered developer platform.Learn moreTeamsWith CI/CD, Dependabot, and the world's largest developer community, GitHub provides everything your team needs to ship secure software faster.Learn moreStartupsGo from idea to IPO in one place, complete with personalized onboarding, office hours, and tailored product guidance.Learn moreThe enterprise-grade platform that developers know and love.Learn more about GitHub EnterpriseSolving industry-specific challenges
View allHealthcareBy incorporating security checks into developer workflows, you can build secure communication channels between patients and providers.Learn moreFinancial ServicesWith an AI-powered developer platform, you can build innovative financial solutions that drive economic growth.Learn moreManufacturingWith robust CI/CD that can handle the complex needs of manufacturing, you can securely transform operations at scale.Learn moreThe solutions you need to build what you wantView allDevSecOpsWith comprehensive security tools built into the developer workflow, you can build, secure, and ship all in one place.
Learn moreDevOpsScale and deliver more secure software with GitHub's unified AI-powered developer platform.Learn moreCI/CDTest and deploy software with simple and secure enterprise CI/CD.Learn moreAdopted by the world's leading organizations3M transforms its software toolchain to bring cutting-edge science to customers, faster.Read storyPhilips builds and deploys digital health technology faster with innersource on GitHub.Read storyGitHub brings DevOps to life and enables streamlined developer experiences at Procter & Gamble.Read storyGet startedTrusted by 90% of the Fortune 100, GitHub helps millions of developers and companies collaborate, build, and deliver secure software faster. And with thousands of DevOps integrations, developers can build smarter from day one with the tools they know and love—or discover new ones.
Start a free trialContact sales\n\n\n\nAITopicsAll TopicsAIDevOpsSecuritySoftware DevelopmentMachine Learning (ML) in Software DevelopmentDiscover how machine learning (ML) is used in software development to optimize workflows and improve user experiences. Gain insights from real-world examples, learn how developers are integrating ML models into existing pipelines, and explore the future potential of ML in software development.Learn moreAI Code ReviewsDiscover how AI code reviews can boost developer productivity and speed up workflows by automating error detection and providing real-time feedback.Learn moreWhat is Natural language processing (NLP)?Learn why natural language processing (NLP) is becoming an indispensable tool for developers. Learn moreWhat are AI models?Learn how AI models help organizations identify data patterns, automate workflows, solve complex problems, forecast outcomes, and enhance decision making.Learn moreEnhancing software development with retrieval-augmented generationLearn how Retrieval Augmented Generation (RAG) improves coding, debugging, and code reviews.Learn moreWhat are AI agents?Discover how AI agents transform software development by automating workflows and enhancing security. Explore the different types of AI agents, learn how they integrate into development environments, and see real-world examples of their impact. Learn best practices for using AI agents and get a glimpse into the future of AI in development and security.Learn moreWhat is AI code generation?AI code generation uses machine learning models to provide context-based code suggestions.Learn moreAI coding tools for beginner and expert codersHow beginner and expert coders use AI coding tools to code faster and ship great software.Learn more\n\n\n\nDevOpsTopicsAll TopicsAIDevOpsSecuritySoftware DevelopmentWhat is CI/CD?Continuous Integration and Continuous Delivery/Deployment or (CI/CD) automates builds, testing, and deployment so you can ship code changes faster and reliablyLearn moreWhat is a DevOps engineer and what does a DevOps engineer do?A DevOps engineer enables collaboration and innovation within an organization.Learn moreWhat is Continuous Deployment?Continuous deployment (CD) is a process that uses automated testing to validate if changes to a codebase are secure, correct, and stable for deployment to a production environment.Learn moreWhat is the DevOps Model? Exploring foundational practices in DevOpsGitHub provides the tools required to be a mature DevOps organization. Discover the DevOps model that separates successful DevOps teams from those that fail.Learn moreWhat is DevSecOps?DevSecOps combines development, security, and operations to automate security integration across all phases of the software development lifecycle (SDLC).Learn moreWhat is containerization?Containers enable DevOps developers and system administrators to build, test, deploy, and maintain applications quickly, securely, and efficiently.Learn moreWhat is DevOps automation?DevOps automation is a modern approach to software development that uses tools and processes to automate tasks and streamline workflows.Learn moreWhat is agile methodology?Learn what agile is, its benefits, why it’s so popular, and how you can apply it in software development and other kinds of work.Learn moreWhat is a DevOps pipeline? A complete guideLearn how to transform your organization and deliver software faster by combining processes, tooling, and automation in a DevOps Pipeline.Learn moreWhat is DevOps?DevOps is a set of practices, methodologies, and tools that optimize software application delivery by integrating software development and IT operations processes. Learn moreDevOps monitoring tools: Automating your DevOps monitoring processesUse GitHub as your approach to developing, testing, and deploying applications through comprehensive and real-time monitoring systems. Workflows are the foundation of automation and DevOps, and monitoring is the bedrock.Learn moreThe fundamentals of continuous integration in DevOpsContinuous Integration (CI) is a practice allowing developers to integrate code into a shared repository regularly. Get to know the fundamentals of what makes this process successful.Learn morePrevious12Next\n\n\n\nSecurityTopicsAll TopicsAIDevOpsSecuritySoftware DevelopmentWhat is a Data Breach?Discover how data breaches occur, their impact on businesses, and the industries most at risk. Learn about common attack methods and tools and best practices for securing sensitive data.Learn moreWhat is risk-based vulnerability management (RBVM)? Discover how risk-based vulnerability management (RBVM) helps organizations focus on the most critical security risks to optimize protection and allocate resources effectively. Learn moreWhat is Code Scanning?Code scanning is essential because it helps developers and security teams find security vulnerabilities and errors. Keep reading for an overview of what code scanning is, how it works, and the benefits it provides. Plus, take a closer look at some code scanning tools and explore ways to enhance software security.Learn moreWhat is a security risk assessment?Learn what a security risk assessment is, how to perform one effectively, and the key benefits of identifying and mitigating potential risks.Learn moreWhat is Cross-Site Scripting (XSS)Discover how cross-site scripting (XSS) compromises web security and impacts users and organizations. Gain insights from real-world examples and learn about best practices to safeguard your applications.Learn moreWhat is secret scanning?In today's digital landscape, protecting sensitive information is crucial for maintaining the integrity and security of an organization’s software systems.Learn moreDynamic application security testing (DAST)DAST is an AppSec method that simulates attacks to test web apps for security issues.Learn moreWhat Is Incident Response?In today’s evolving threat landscape, a robust incident response plan is essential to minimize damage, protect sensitive data, and ensure business continuity.Learn moreWhat is software supply chain security?Learn how software supply chain security helps organizations protect the safety, reliability, and integrity of their software supply chains from cybersecurity threats.Learn moreWhat is shift left?Explore the benefits of shift left in software development, like early testing and efficient scanning strategies within the software development lifecycle.Learn moreWhat is software composition analysis (SCA)?Software composition analysis (SCA) helps developers identify and manage security vulnerabilities in open source software, leading to more compliant, better quality code. Learn moreWhat is security testing?Learn about security testing with our guide to security testing types, tools, and scanning methods, and best practices and trends for greater software security.Learn morePrevious12Next\n\n\n\nSoftware DevelopmentTopicsAll TopicsAIDevOpsSecuritySoftware DevelopmentWhat are code repositories?Ever wonder where all that code you write actually lives? Welcome to the world of code repositories.Learn moreWhat is the SDLC?Learn about the software development lifecycle (SDLC) and gain valuable insights into its essential phases, methodologies, and best practices. Enhance your understanding of this crucial process to drive successful software development projects.Learn moreWhat is cloud native?Cloud native is an approach to building and running scalable applications in dynamic environments like public, private, or hybrid clouds, using containers, microservices, and DevOps practices.Learn moreWhat is Platform engineering?Learn what platform engineering is and how it empowers developers by creating internal developer platforms, improving workflows, and reducing operational bottlenecks. Explore the benefits for developers and IT managers alike.Learn moreHow to accelerate innovation with innersourceOrganizations around the world are accelerating their development cycles and tapping into new wells of innovation within their companies through "innersource" projects that share code and resources internally, enabling cross-team collaboration and contributions.Learn moreWhat is Open Source Software (OSS)?Get an overview of open source software (OSS) with this guide—and explore tips for getting started.Learn moreAn introduction to innersourceOrganizations worldwide are incorporating open source methodologies into the way they build and ship their own software.Learn moreWhat is software development?Explore software development basics including tools, security, steps, and impact on industries.Learn moreWhat is Version Control?Learn how version control systems and software help track changes, support collaboration, and ensure code integrity throughout the development process.Learn moreTools and techniques for effective code documentationLearn about code documentation and why it’s essential for delivering quality software.Learn moreWhat is software architecture?Learn how software architecture helps developers build scalable, efficient systems using best practices, key components, and common styles and patterns.Learn moreWhat is a programming language?A programming language is a set of instructions that enables humans to communicate commands to a computer in software development.Learn morePrevious12Next\n\n\n\nAll TopicsTopicsAll TopicsAIDevOpsSecuritySoftware DevelopmentMachine Learning (ML) in Software DevelopmentDiscover how machine learning (ML) is used in software development to optimize workflows and improve user experiences. Gain insights from real-world examples, learn how developers are integrating ML models into existing pipelines, and explore the future potential of ML in software development.Learn moreWhat is a Data Breach?Discover how data breaches occur, their impact on businesses, and the industries most at risk. Learn about common attack methods and tools and best practices for securing sensitive data.Learn moreAI Code ReviewsDiscover how AI code reviews can boost developer productivity and speed up workflows by automating error detection and providing real-time feedback.Learn moreWhat is risk-based vulnerability management (RBVM)? Discover how risk-based vulnerability management (RBVM) helps organizations focus on the most critical security risks to optimize protection and allocate resources effectively. Learn moreWhat is Code Scanning?Code scanning is essential because it helps developers and security teams find security vulnerabilities and errors. Keep reading for an overview of what code scanning is, how it works, and the benefits it provides. Plus, take a closer look at some code scanning tools and explore ways to enhance software security.Learn moreWhat is Natural language processing (NLP)?Learn why natural language processing (NLP) is becoming an indispensable tool for developers. Learn moreWhat are AI models?Learn how AI models help organizations identify data patterns, automate workflows, solve complex problems, forecast outcomes, and enhance decision making.Learn moreWhat is a security risk assessment?Learn what a security risk assessment is, how to perform one effectively, and the key benefits of identifying and mitigating potential risks.Learn moreWhat is Cross-Site Scripting (XSS)Discover how cross-site scripting (XSS) compromises web security and impacts users and organizations. Gain insights from real-world examples and learn about best practices to safeguard your applications.Learn moreWhat is secret scanning?In today's digital landscape, protecting sensitive information is crucial for maintaining the integrity and security of an organization’s software systems.Learn moreDynamic application security testing (DAST)DAST is an AppSec method that simulates attacks to test web apps for security issues.Learn moreWhat is CI/CD?Continuous Integration and Continuous Delivery/Deployment or (CI/CD) automates builds, testing, and deployment so you can ship code changes faster and reliablyLearn morePrevious123456Next\n\n\n\nEbooks & WhitepapersBrowse our collection of Ebooks and Whitepapers for valuable industry knowledge, trends, and strategies to help you stay ahead and make informed decisions.Filters Open FiltersContent TypeContent TypeWhitepapersEbooksCategoryCategoryAICloudDevOpsGitHub ActionsGitHub Advanced SecurityGitHub EnterpriseInnersourceOpen SourceSecuritySoftware DevelopmentClear allApplyTraining and onboarding developers on GitHub CopilotWhitepaperDevelopers work alongside Copilot to write code, generate tests, fix bugs, create documentation, and much more. To fully realize Copilot’s potential, entire teams, not just individual developers, must adopt new skills. While Copilot may be a tool like any other, generative AI presents unique adoption challenges that require specific solutions.Learn more6 common pitfalls for DevOps teams and how to avoid themEbookDevOps is a transformative practice—and not only because it helps to build better software. It also aligns teams, from IT to engineering to security, removing siloed workstreams and promoting collaboration. As great as this sounds, pulling together your DevOps processes and tools requires some practice to make your strategy perfect.
Learn moreThe engineering leader’s guide to AIEbookAI coding is here. Developers have embraced it and already use various tools for AI code generation to augment their coding capabilities and offload some of their more mundane tasks.Learn moreDetecting and Preventing Secret Leaks in CodeEbookIn today’s interconnected digital landscape, safeguarding access to systems and sensitive data is more critical—and more challenging—than ever. With the increasing footprint of code and rapid software development cycles, malicious actors have an expanding array of opportunities to exploit vulnerabilities.
Learn moreGitHub case study: Enhancing customer support with AIEbookGitHub Copilot empowers engineers to help their organizations achieve better business outcomes for their customers. But AI doesn't simply help engineers do the same work more quickly; it can help them get to places they haven't been able to get to before! We're excited to share how our GitHub customer success team has been using AI to better serve our customers.Learn moreWhat AI Means for the Future of DevOpsEbookHarnessing AI's full potential isn't just about boosting productivity in isolated phases—it's about driving real organizational value across the entire software development lifecycle.Learn moreGo beyond code scanning with AI-powered AppSecWhitepaperUnder pressure to ship and meet business demands, development teams often introduce more security vulnerabilities to code than they fix. In other words, they're racking up security and technical debt. It's a difficult cycle to break.
Learn moreTaking GitHub Copilot to the stars, not just the skiesEbookEmbarking on a successful GitHub Copilot launch requires meticulous planning and execution.
Learn moreAt the forefront of DevOps innovation and excellenceWhitepaperBuild and innovate with a Leader in the Gartner® Magic Quadrant™ for DevOps PlatformsLearn moreAI Will Not Replace Software Engineers (and May, in Fact, Require More)WhitepaperExplore the current and future impact of AI on developers and see why humans will always be essential to delivering innovative software in this report.
Learn more5 DevOps tips to help teams deliver software at scaleEbookThere are real-world challenges for organizations seeking success in DevOps. In this info sheet, explore 5 DevOps tips to help teams deliver software at scale.
Learn moreModernizing COBOL with GitHub CopilotEbookExplore how GitHub Copilot can transform your legacy systems. Discover the best practices we've developed to help leading organizations achieve smoother migrations and revitalize their COBOL codebase.Learn morePrevious1234Next\n\n\n\nCustomer Stories

      
        
        
      

      
          Enterprise
          Team
          All stories
      

        
            
  Start a free trial
  
  


        
    



      
        



  
  
  



  
  
  



  
  
  








        
  
    

          
    
    
    

    Meet the companies who build with GitHub

    


        
            
    See all stories 


        

        
            
      
        
      

    
  
  
  
  

  

  

  With 12,000 developers using GitHub Copilot, Accenture doubles down on GitHub’s platform.

  
    Read the story 

  
            
      
        
      

    
  
  
  
  

  

  

  Philips builds and deploys digital health technology faster with innersource on GitHub. 

  
    Read the story 

  
            
      
        
      

    
  
  
  
  

  

  

  Carlsberg unifies development on GitHub Enterprise and accelerates innovation with Copilot.

  
    Read the story 

  
        

        
          The world's largest developer platform
          Leading organizations choose GitHub to plan, build, secure and ship software.
        

        
            
              100M+
              Developers
            
            
              90%
              Fortune 100
            
            
              4M+
              Organizations
            
        

          Businesses that utilize GitHub Enterprise:
          
              
                
              
              
                
              
              
                
              
              
                
              
              
                
              
          

  
    
  

  
  
    
    
  GitHub Enterprise provides an end-to-end developer platform to accelerate businesses.

  
    
        
  
      
    Industry
  
    
      
    




  
    
                
  
    
        
    
    
    
      
        
          All
      

  

        
    
    
    
      
        
          Advertising & Marketing
      

  

        
    
    
    
      
        
          Automotive
      

  

        
    
    
    
      
        
          Education
      

  

        
    
    
    
      
        
          Energy & Utilities
      

  

        
    
    
    
      
        
          Financial services
      

  

        
    
    
    
      
        
          Food & Beverage
      

  

        
    
    
    
      
        
          Government
      

  

        
    
    
    
      
        
          Healthcare & Life Sciences
      

  

        
    
    
    
      
        
          Manufacturing
      

  

        
    
    
    
      
        
          Media & Entertainment
      

  

        
    
    
    
      
        
          Nonprofit
      

  

        
    
    
    
      
        
          Professional services
      

  

        
    
    
    
      
        
          Real Estate
      

  

        
    
    
    
      
        
          Retail & ecommerce
      

  

        
    
    
    
      
        
          Social & Messaging
      

  

        
    
    
    
      
        
          Software, Hardware & Technology
      

  

        
    
    
    
      
        
          Telecommunications
      

  

        
    
    
    
      
        
          Transportation & Logistics
      

  

        
    
    
    
      
        
          Travel & Hospitality
      

  

    




      
  

        
  
      
    Feature
  
    
      
    




  
    
                
  
    
        
    
    
    
      
        
          All
      

  

        
    
    
    
      
        
          GitHub Actions
      

  

        
    
    
    
      
        
          GitHub Advanced Security
      

  

        
    
    
    
      
        
          GitHub Codespaces
      

  

        
    
    
    
      
        
          GitHub Copilot
      

  

        
    
    
    
      
        
          GitHub Discussions
      

  

        
    
    
    
      
        
          GitHub Enterprise
      

  

        
    
    
    
      
        
          GitHub Expert Services
      

  

        
    
    
    
      
        
          GitHub Issues
      

  

        
    
    
    
      
        
          GitHub Packages
      

  

        
    
    
    
      
        
          GitHub Team
      

  

    




      
  

        
  
      
    Region
  
    
      
    




  
    
                
  
    
        
    
    
    
      
        
          All
      

  

        
    
    
    
      
        
          Americas
      

  

        
    
    
    
      
        
          Asia Pacific
      

  

        
    
    
    
      
        
          Europe
      

  

        
    
    
    
      
        
          Middle East & Africa
      

  

    




      
  

        
  
      
    Size
  
    
      
    




  
    
                
  
    
        
    
    
    
      
        
          Startup
      

  

        
    
    
    
      
        
          Growth
      

  

        
    
    
    
      
        
          Enterprise
      

  

    




      
  

    

    
        
    Learn more about Enterprise 


        
    View Enterprise stories 


    
  
  
    
  
    Read more about Doctolib's customer story
    
      
        
  
  
  
  

      
    
     Doctolib
    Doctolib uses GitHub to drive digital transformation in healthcare.

    
      Read story 

    
  


    
  
    Read more about Jibo, Inc.'s customer story
    
      
        
  
  
  
  

      
    
     Jibo, Inc.
    Jibo, the social robot, is brought to life by developers all over the world. See how these builders connect with the core team on GitHub.
    
      Read story 

    
  


    
  
    Read more about ADEO's customer story
    
      
        
  
  
  
  

      
    
     ADEO
    ADEO works more efficiently across teams and time zones with a global innersource program.
    
      Read story 

    
  


    
  
    Read more about LambdaTest's customer story
    
      
        
  
  
  
  

      
    
     LambdaTest
    LambdaTest streamlines CI/CD with GitHub Actions.
    
      Read story 

    
  


    
  
    Read more about Arduino's customer story
    
      
        
  
  
  
  

      
    
     Arduino
    Millions of makers leverage Arduino and GitHub’s open source community to create interactive, innovative projects.
    
      Read story 

    
  


    
  
    Read more about Philips's customer story
    
      
        
  
  
  
  

      
    
     Philips
    Philips builds and deploys digital health technology faster with innersource on GitHub. 
    
      Read story 

    
  






      
  



  
    
      
          

        GitHub Enterprise
      

      Duolingo empowers its engineers to be force multipliers for expertise with GitHub Copilot.

      
        Read more about Duolingo and GitHub's story
        Read story 


        
            
              25%
              increase in developer speed with GitHub Copilot
            
            
              1m
              set-up time for largest repo with Codespaces
            
            
              67%
              decrease in median code review turnaround time
            
            
              70%
              increase in pull requests
            
        
    
  

    
      


  
  
  
  



  


      
        
          
        

        Problem
      
      
        Inconsistent standards and workflows limited developer mobility and efficiency, limiting Duolingo’s ability to expand its content and deliver on its core mission. 
      


      
        
          
        

        Solution
      
      
        GitHub Copilot, Codespaces, and custom API integrations enforce code consistency, accelerate developer speed, and remove the barriers to using engineering as a force multiplier for expertise.
      


    
      
        
      
      Products
    
    
      

      
          
            GitHub Enterprise
            
          

          
            GitHub Codespaces
            
          
          
            GitHub Copilot
            
          
      
    
  


    



  



    
  Discover how high-growth companies innovate faster with GitHub Team.

  
    
        
  
      
    Industry
  
    
      
    




  
    
                
  
    
        
    
    
    
      
        
          All
      

  

        
    
    
    
      
        
          Advertising & Marketing
      

  

        
    
    
    
      
        
          Automotive
      

  

        
    
    
    
      
        
          Education
      

  

        
    
    
    
      
        
          Energy & Utilities
      

  

        
    
    
    
      
        
          Financial services
      

  

        
    
    
    
      
        
          Food & Beverage
      

  

        
    
    
    
      
        
          Government
      

  

        
    
    
    
      
        
          Healthcare & Life Sciences
      

  

        
    
    
    
      
        
          Manufacturing
      

  

        
    
    
    
      
        
          Media & Entertainment
      

  

        
    
    
    
      
        
          Nonprofit
      

  

        
    
    
    
      
        
          Professional services
      

  

        
    
    
    
      
        
          Real Estate
      

  

        
    
    
    
      
        
          Retail & ecommerce
      

  

        
    
    
    
      
        
          Social & Messaging
      

  

        
    
    
    
      
        
          Software, Hardware & Technology
      

  

        
    
    
    
      
        
          Telecommunications
      

  

        
    
    
    
      
        
          Transportation & Logistics
      

  

        
    
    
    
      
        
          Travel & Hospitality
      

  

    




      
  

        
  
      
    Feature
  
    
      
    




  
    
                
  
    
        
    
    
    
      
        
          All
      

  

        
    
    
    
      
        
          GitHub Actions
      

  

        
    
    
    
      
        
          GitHub Advanced Security
      

  

        
    
    
    
      
        
          GitHub Codespaces
      

  

        
    
    
    
      
        
          GitHub Copilot
      

  

        
    
    
    
      
        
          GitHub Discussions
      

  

        
    
    
    
      
        
          GitHub Enterprise
      

  

        
    
    
    
      
        
          GitHub Expert Services
      

  

        
    
    
    
      
        
          GitHub Issues
      

  

        
    
    
    
      
        
          GitHub Packages
      

  

        
    
    
    
      
        
          GitHub Team
      

  

    




      
  

        
  
      
    Region
  
    
      
    




  
    
                
  
    
        
    
    
    
      
        
          All
      

  

        
    
    
    
      
        
          Americas
      

  

        
    
    
    
      
        
          Asia Pacific
      

  

        
    
    
    
      
        
          Europe
      

  

        
    
    
    
      
        
          Middle East & Africa
      

  

    




      
  

        
  
      
    Size
  
    
      
    




  
    
                
  
    
        
    
    
    
      
        
          Startup
      

  

        
    
    
    
      
        
          Growth
      

  

        
    
    
    
      
        
          Enterprise
      

  

    




      
  

    

    
        
    Learn more about Team 


        
    View Team stories 


    
  
  
    
  
    Read more about Netdata's customer story
    
      
        
  
  
  
  

      
    
     Netdata
    Netdata accelerates their developer workflow with built-in security and open source.
    
      Read story 

    
  


    
  
    Read more about Peak Money's customer story
    
      
        
  
  
  
  

      
    
     Peak Money
    Peak Money collaborates across tools, teams, and time zones with GitHub Team.
    
      Read story 

    
  


    
  
    Read more about Front's customer story
    
      
        
  
  
  
  

      
    
     Front
    Front takes the work out of their workflows with GitHub Team.
    
      Read story 

    
  


    
  
    Read more about Modsy's customer story
    
      
        
  
  
  
  

      
    
     Modsy
    Modsy leverages GitHub Team to make interior design easy and accessible for all.
    
      Read story 

    
  


    
  
    Read more about Sketch's customer story
    
      
        
  
  
  
  

      
    
     Sketch
    Sketch streamlines their workflows to provide teams with a comprehensive digital design editor.
    
      Read story 

    
  


    
  
    Read more about Tray.io's customer story
    
      
        
  
  
  
  

      
    
     Tray.io
    GitHub Team helps the general automation platform build, package, and deploy code faster than ever.
    
      Read story 

    
  






  

    
      

  
  
    
    
      
        
          Here's what software leaders have to say about GitHub
          Testimonials from our developers.
        

        
          1 / 4
          1 of 4
        
      

      
        
                

          
            
              
  
    
      
  
  
  
  

    

    
      “
      
        At Uber, we continuously strive to improve our developer experience. We migrated code hosting and review to GitHub and are adopting GitHub Copilot to boost overall developer productivity. 
      
    

    
      
        
          Ali-Reza Adl-Tabatabai 
        
      
      
        Senior Director of Engineering
          @ Uber
      
    
  


              
  
    
      
  
  
  
  

    

    
      “
      
        GitHub's endless plug-ins, beautiful UI, and optimized workflows make devs happy. Happy and empowered engineers write the best code, make better decisions, and have more time to innovate. 
      
    

    
      
        
          Jen Peck
        
      
      
        Senior Director of Engineering
          @ Redfin
      
    
  


              
  
    
      
  
  
  
  

    

    
      “
      
        GitHub Copilot will bring huge benefits to our engineering teams by reducing the amount of time spent on boilerplate code, keeping the teams in their flow state, allowing them to ship high-quality products to market faster.
      
    

    
      
        
          Santosh Lolyeker
        
      
      
        VP, Engineering Fellow
          @ Veritas
      
    
  


              
  
    
      
  
  
  
  

    

    
      “
      
        With GitHub Enterprise, we have alleviated engineering overhead at Costco, enabling our engineers to focus on innovating.
      
    

    
      
        
          Avdesh Rai
        
      
      
        Enterprise Solutions Engineer
          @ Costco
      
    
  


            
          

                
        
      
    

  


    

  
  
    

  
  
  



  What will your story be?
  Start collaborating with your team on GitHub
  
    
      
        Free
        The basics for individuals and organizations
        $0 USD per month

        
  Create a free organization
  
  


      
    

    
      
        Team
        Advanced collaboration for individuals and organizations
        $4 USD per month

        
  Continue with Team
  
  


      
    

    
      
        Enterprise
        Security, compliance, and flexible deployment
        $21 USD per month

        
  Enterprise
  
  


      
    
  
  
    Want to use GitHub on your own?
    
    Check out our plans for individuals\n\n\n\nSolutionsEnterprise ContentExecutive insights, curated just for youGitHub for Leaders: How CXOs limit risk without losing speedIn this episode of GitHub for Leaders, host Anjuan Simmons sits down with cybersecurity researcher Daniel Cuthbert to discuss the evolving challenges of enterprise security facing leaders right now – and why credential leaks remain one of the most costly, yet preventable, threats.Learn more Understanding your organization's exposure to secret leaksCredential leaks are expensive, damaging, and on the rise. This article helps you understand your organization’s specific risk—and how to reduce exposure before it turns into impact.Learn moreEvolving GitHub Advanced Security: Greater flexibility, easier to accessStarting April 1, 2025, GitHub Advanced Security (GHAS) will be unbundled and available as two standalone security products: GitHub Secret Protection and GitHub Code Security.Learn moreApril ‘25 enterprise roundupTo help you stay ahead, our Enterprise Advocacy team has curated this monthly roundup—bringing you a concise, enterprise-focused summary of the most important updates you might have missed.Learn moreEssential GitHub Copilot resources for enterprise teamsFrom initial setup to advanced features, this guide will walk you through the essential resources to make your Copilot implementation successful.Learn moreCreating space for developer creativity in high-scale organizationsHow do we ensure our developers can maintain the ability to innovate and experiment while operating within the constraints of a larger organization?Learn moreHow Thomson Reuters successfully adopted AIThomson Reuters began their AI journey in 2022. Engineering leaders realized that what started as industry buzz was an opportunity to foster engineering excellence within the company–and GitHub Copilot could be just the thing to accelerate their operations.Learn moreThe art of engineering team focus: less is moreGuiding engineering teams to prioritize fewer tasks, limit parallel work, and leave space for unforeseen needs not only boosts productivity, but also fosters more consistent, high-quality work.Learn moreWhy developer satisfaction is your best productivity metricLearn how prioritizing developer satisfaction can drive better code quality, foster innovation, and improve team retention, ultimately boosting engineering productivity.Learn moreRelated solutionsCarlsberg accelerates innovation with CopilotCarlsberg unified its development process and bolstered its security using GitHub Advanced Security, while the integration of Copilot enabled efficient coding practices and minimized the need for context-switching.
Learn moreAccenture cuts technical debt with GitHub Advanced Security and CopilotAccenture leverages GitHub Copilot and Advanced Security to reduce technical debt, driving faster project delivery and improved code quality.
Learn moreEY Scales Developer Efficiency with GitHub Copilot and CodespacesEY built integrations between GitHub and Microsoft Azure DevOps, so it could tap into the power of GitHub's cohesive developer platform for security, automation, and AI.Learn more90%of Fortune 100 choose GitHub433%ROI with GitHub Enterprise77,000organizations use GitHub Copilot75%reduced time spent managing toolsMaximize your investment in AIOur recent study with Accenture shows that AI-driven tools like GitHub Copilot, when integrated into daily workflows, can significantly boost productivity, job satisfaction, and overall code quality without adding complexity.
Discover how to seamlessly integrate AI into your development processes with GitHub Copilot and see measurable impact across your organization.
Learn moreContact sales\n\n\n\nSponsorsSee your top dependenciesGet sponsoredGitHub SponsorsSupport the developers who power open sourceSee your top dependenciesGet sponsoredGitHub Sponsors allows the developer community to financially support the open source projects they depend on, directly on GitHub
$40M+Given back to our maintainers103Regions supported globally4.2K+Organizations sponsoringFor maintainersLaunch a page in minutes and showcase Sponsors buttons on your GitHub profile and repositories! You will automatically appear in worldwide recommendations to partners who are eager to invest in their open source dependencies.Get sponsoredFor sponsorsFind and fund your dependencies in a single transaction. The discovery and bulk sponsorship tools are easy to use. Flexible payment enables you to choose when and how you pay. Corporations like Microsoft like it because all their payments go out as a single invoice.Learn about invoiced billingHelp open source thriveEveryone should be able to contribute to open source. Making open source a viable, financially rewarding career path helps contribute to our digital infrastructure. More funding, more projects, more software to power our world.See your top dependencies“Shopify uses GitHub Sponsors to efficiently manage and fund projects within the open source community, tailored to the needs of recipients.Azmat YuhannaSenior Engineering Operations Manager, ShopifyInvest in open source. It powers your world. See your top dependenciesGet sponsoredThe internet depends on open source, everywhereComprehensive website security and health monitoring with performance analysisweb-checkWeb-Check provides real-time monitoring for uptime, speed, and user experience, trusted by businesses like Amazon, Shopify, and Airbnb.Sponsor web-checkIntuitive, open-source interface for native GenAI applicationsOpenWebUIOpenWebUI simplifies the development of interactive GenAI apps using LLMs, used by developers at companies like Microsoft, IBM, and GitHub.Sponsor OpenWebUIA command line tool and library for transferring data with URL syntaxcURLcURL is included in almost every modern device–smartphones, cars, TVs, laptops, servers, consoles, printers, and beyond.Sponsor cURLFrequently asked questionsHow do I sponsor a project?Sign in and start by navigating to your dependencies, your explore tab, trending repositories, or collections. When a repository has the Sponsor graphic, you can sponsor them directly.How do I get paid for my contributions?You can become a sponsored developer by joining GitHub Sponsors, completing your sponsored developer profile, creating sponsorship tiers, submitting your bank and tax information, and enabling two-factor authentication for your account on GitHub.com. Learn more about getting paid for contributions
Do I need to fill out a tax form to receive sponsorships?Yes. Your tax information must be on file in order for GitHub to make payments to your bank account. The required tax documents may vary based on your location.Note that we do our best to help you with the Sponsors program, but we’re unable to provide tax guidance.Learn more about tax information for GitHub Sponsors\n\n\n\nThe ReadME Project

        

  
  
    
  


  
    
      
    
  


  



    
      
        

          
  
  
  
  


        
      

      
        Featured stories
        
  

  Featured Article



  
    Coding accessibility: Software by the blind, for the blind


  
    The NVDA screen reader has helped empower a new generation of blind and low-vision developers
  

      
    

    
        
          
            
  
    
    
  
  
  
  

    
  




          

          
            
              
              Featured Article
            

            
              
                 Coding accessibility: Disability as catalyst for creativity
              
            

            
              Faced with accessibility barriers, developer Paul Chiou turns obstacles into innovative solutions.
            
          
        
        
          
            
  
    
    
  
  
  
  

    
  




          

          
            
              
              Annalu  Waller
            

            
              
                Champion accessibility to unleash untapped potential
              
            

            
              Dr. Annalu Waller on the intricate, interdependent network of support that shapes our lives.
            
          
        
        
          
            
  
    
    
  
  
  
  

    
  




          

          
            
              
              Featured Article
            

            
              
                Coding accessibility: How Della found her voice with open source AAC
              
            

            
              When proprietary apps failed, Della’s brother built an app that incorporated her needs and feedback into the design.
            
          
        
        
          
            
  
    
    
  
  
  
  

    
  




          

          
            
              
              Featured Article
            

            
              
                Coding accessibility: Building autonomy with AI
              
            

            
              After bringing Braille to the digital world and creating the first screen reader for the web, Dr. Asakawa is now working on an AI-enabled suitcase to help blind people navigate the world independently.
            
          
        
    



        
          

  
    
The ReadME Project

          
        
      
  


          
  
  
    
      
        
          

        

              
            

          
      

      
        
          
            Browse by story type
          

          
              
                
                  Featured Articles
              
              
                
                  Developer Stories
              
              
                
                  Guides
              
              
                
                  The ReadMe Podcast
              
          
        

        
          
            Explore Topics

            
              See all topics 

            
          

          
              
                
                  AI
              
              
                
                  Application Security
              
              
                
                  Career Development
              
              
                
                  DevOps & Automation
              
              
                
                  Maintainer
              
              
                
                  Programming
              
          
        
      

      
        
          
            Nominate a developer//
          

            
              Support the community
            
        
      
    
  



          
  Stories by topic
  
    
      
        The ReadME Project amplifies the voices of the developer community by telling stories about:
      

      
          
            
              AI
            ,
          
          
            
              Application Security
            ,
          
          
            
              Career Development
            ,
          
          
            
              DevOps & Automation
            ,
          

        and more topics.
      
    
  


          

  Community stories
  
  
      
        
          
  
    
    
  
  
  
  

    
  

    Maintainer

    
	



        

        
  

  THE README PODCAST // EPISODE 31



  
    Bridging code and community


  
    Navigating open source in a regulated environment, the crucial role of non-code contributions to open source success, and lessons from scaling projects like Kubernetes.
  

      
      
        
          
  
    
    
  
  
  
  

    
  

    AI

    
	



        

        
  

  THE README PODCAST // EPISODE 33



  
    Powering public goods


  
    Exploring developer happiness through the vibrant Laravel community and the impact of digital public goods on open source, AI models, Wikipedia, and more.
  

      
  

  
  
      
        
          
  
    
    
  
  
  
  

    
  




        

        
  

  Anton Mirhorodchenko



  
    Harness the power of generative AI for software development


  
    Tools like GitHub Copilot and ChatGPT can change the way you build software.
  

      
      
        
          
  
    
    
  
  
  
  

    
  




        

        
  

  Aaron Francis // PlanetScale



  
    Finish your projects


  
    Don’t let fear, or that last 10%, hold you back.
  

      
      
        
          
  
    
    
  
  
  
  

    
  




        

        
  

  Cassidy Williams // Contenda



  
    Get your first software developer job


  
    Tips, tricks, and general advice for how to get in the door in tech.
  

      
  



            

  
    
      
        We all have the potential to become who we're meant to be, even when societal and socioeconomic challenges get in our way.
      
    

    
      
        
  
    
    
  
  
  
  

    
  

    Accessibility



      

      
        
          
            Champion accessibility to unleash untapped potential
          
        

        
          Annalu  Waller
        
      
    
  




            
  
  
    
      The ReadMe Podcast
    

    
      See all The ReadMe Podcast 

       stories from The ReadMe Podcast
  



  
      
        
          
            
              
  
  
  
  

            
          

          
	

        

        
          
  

  THE README PODCAST // EPISODE 32



  
    (De)coding conventions


  
    The evolution of TypeScript and the future of coding conventions, AI’s role in improving accessibility, and practical advice on encouraging non-code contributions. 
  

        
      
      
        
          
            
              
  
  
  
  

            
          

          
	

        

        
          
  

  THE README PODCAST // EPISODE 30



  
    Kelsey Hightower—Present


  
    Kelsey shares his origin story, insights on the future of Kubernetes, and advice on making complicated technology easier to understand.
  

        
      
  




            
  
  
    
      Featured Articles
    

    
      See all Featured Articles 

       stories from Featured Articles
  



  
    
      
        
  
    
    
  
  
  
  

    
  

    Programming



      

      
        
          
            
              Is Laravel the happiest developer community on the planet?
            
          

          How the PHP framework maintains a perpetual honeymoon period.
        
      
    
  




            
  
  
    
      Developer Stories
    

    
      See all Developer Stories 

       stories from Developer Stories
  



  
    
      
        
  
    
    
  
  
  
  

    
  




      

      
        
  

  Anton Mirhorodchenko



  
    Realizing potential with AI


  
    Anton uses AI to write code and tackle more projects.
  

      
    

      
        
          
  
    
    
  
  
  
  

    
  




        

        
          
  

  Kyler Middleton



  
    From fixing computers on farms to democratizing DevOps


  
    Kyler discusses her path from rural tech repair jobs to revolutionizing tech education.
  

        
      
      
        
          
  
    
    
  
  
  
  

    
  




        

        
          
  

  Aaron Gustafson



  
    Advancing inclusion with progressive enhancement


  
    Aaron’s journey towards progressive enhancement and inclusive design.
  

        
      
      
        
          
  
    
    
  
  
  
  

    
  




        

        
          
  

  Ruth Ikegah



  
    Putting the African open source community on the map


  
    Ruth’s dream is to show people that Africans aren’t just consumers of open source: They’re creators as well.
  

        
      
  




            
  
  
    
      Guides
    

    
      See all Guides 

       stories from Guides
  



  
    
      
        
  
    
    
  
  
  
  

    
  

    Application Security



      

      
        
  

  Denys Lashchevskyi // Betsson



  
    A beginner’s guide to running and managing custom CodeQL queries


  
    Transform your code into a structured database that you can use to surface security vulnerabilities and discover new insights.
  

      
    

    
        
          
            
  
    
    
  
  
  
  

    
  

    Career Development



          

          
  

  Nick Penston // Fidelity Investments



  
    Scaling standards and community in your organization


  
    Learn how to implement open source community ideas to spread best practices.
  

        
        
          
            
  
    
    
  
  
  
  

    
  




          

          
  

  Niek Palm // Philips



  
    Provisioning self-hosted GitHub Actions runners on demand


  
    How Philips optimized their CI/CD process using GitHub Actions and self-hosted runners.
  

        
        
          
            
  
    
    
  
  
  
  

    
  

    Open Source



          

          
  

  Mike Gifford // CivicActions



  
    Treat accessibility issues as bugs, not feature requests


  
    Follow Drupal’s lead: Prioritize and systematically squash accessibility bugs.
  

        
    
  


        
      

    
      
  
      
        
          
            About The ReadME Project
            Coding is usually seen as a solitary activity, but it’s actually the world’s largest community effort led by open source maintainers, contributors, and teams. These unsung heroes put in long hours to build software, fix issues, field questions, and manage communities.
            The ReadME Project is part of GitHub’s ongoing effort to amplify the voices of the developer community. It’s an evolving space to engage with the community and explore the stories, challenges, technology, and culture that surround the world of open source.

            
              Follow us:

              
                    
                      
                        

                      
                    
                    
                      
                        

                      
                    
                    
                      
                        

                      
                    
                    
                      
                        

                      
                    
                    
                      
                        

                      
                    
              
            
          
        

        

          
            Nominate a developer

            
          
          Nominate inspiring developers and projects you think we should feature in The ReadME Project.

          
            Support the community

            
          
          Recognize developers working behind the scenes and help open source projects get the resources they need.

          
  
    Sign Up For Newsletter
  

  
    Every month we’ll share new articles from The ReadME Project, episodes of The ReadME Podcast, and other great developer content from around the community.
  

  Email Address *
  
    


    

    

    
      Subscribe
    
  


  Thank you! for subscribing\n\n\n\nExplore

      Topics

        Trending

        Collections

        Events

        GitHub Sponsors
    
  




  
    Topics
    Browse popular topics on GitHub.
  


  
    
        
  
    



    
        
      
        Arduino
      
      Arduino is an open source platform for building electronic devices.
    
  


        
  
    



    
        
      
        Storybook
      
      Storybook is a UI development environment for your UI components.
    
  


        
  
    



    
        
      
        Terraform
      
      An infrastructure-as-code tool for building, changing, and versioning infrastructure safely and efficiently.
    
  


    
  


  
    All featured topics
    
    
      
          
            #
          
      
      
        3D
        
          3D refers to the use of three-dimensional graphics, modeling, and animation in various industries.
        
      
      
          
            
          Star


      
    
    
      
          
      
      
        Ajax
        
          Ajax is a technique for creating interactive web applications.
        
      
      
          
            
          Star


      
    
    
      
          
            #
          
      
      
        Algorithm
        
          Algorithms are self-contained sequences that carry out a variety of tasks.
        
      
      
          
            
          Star


      
    
    
      
          
      
      
        Amp
        
          Amp is a non-blocking concurrency library for PHP.
        
      
      
          
            
          Star


      
    
    
      
          
      
      
        Android
        
          Android is an operating system built by Google designed for mobile devices.
        
      
      
          
            
          Star


      
    
    
      
          
      
      
        Angular
        
          Angular is an open source web application platform.
        
      
      
          
            
          Star


      
    
    
      
          
      
      
        Ansible
        
          Ansible is a simple and powerful automation engine.
        
      
      
          
            
          Star


      
    
    
      
          
            #
          
      
      
        API
        
          An API (Application Programming Interface) is a collection of protocols and subroutines for building software.
        
      
      
          
            
          Star


      
    
    
      
          
      
      
        Arduino
        
          Arduino is an open source platform for building electronic devices.
        
      
      
          
            
          Star


      
    
    
      
          
      
      
        ASP.NET
        
          ASP.NET is a web framework for building modern web apps and services.
        
      
      
          
            
          Star


      
    
    
      
          
      
      
        Awesome Lists
        
          An awesome list is a list of awesome things curated by the community.
        
      
      
          
            
          Star


      
    
    
      
          
      
      
        Amazon Web Services
        
          Amazon Web Services provides on-demand cloud computing platforms on a subscription basis.
        
      
      
          
            
          Star


      
    
    
      
          
      
      
        Azure
        
          Azure is a cloud computing service created by Microsoft.
        
      
      
          
            
          Star


      
    
    
      
          
      
      
        Babel
        
          Babel is a compiler for writing next generation JavaScript, today.
        
      
      
          
            
          Star


      
    
    
      
          
      
      
        Bash
        
          Bash is a shell and command language interpreter for the GNU operating system.
        
      
      
          
            
          Star


      
    
    
      
          
      
      
        Bitcoin
        
          Bitcoin is a cryptocurrency developed by Satoshi Nakamoto.
        
      
      
          
            
          Star


      
    
    
      
          
      
      
        Bootstrap
        
          Bootstrap is an HTML, CSS, and JavaScript framework.
        
      
      
          
            
          Star


      
    
    
      
          
      
      
        Bot
        
          A bot is an application that runs automated tasks over the Internet.
        
      
      
          
            
          Star


      
    
    
      
          
      
      
        C
        
          C is a general purpose programming language that first appeared in 1972.
        
      
      
          
            
          Star


      
    
    
      
          
      
      
        Chrome
        
          Chrome is a web browser from the tech company Google.
        
      
      
          
            
          Star


      
    
    
      
          
      
      
        Chrome extension
        
          Chrome extensions enable users to customize the Chrome browsing experience.
        
      
      
          
            
          Star


      
    
    
      
          
      
      
        Command-line interface
        
          A CLI, or command-line interface, is a console that helps users issue commands to a program.
        
      
      
          
            
          Star


      
    
    
      
          
      
      
        Clojure
        
          Clojure is a dynamic, general-purpose programming language.
        
      
      
          
            
          Star


      
    
    
      
          
            #
          
      
      
        Code quality
        
          Automate your code review with style, quality, security, and test‑coverage checks when you need them.
        
      
      
          
            
          Star


      
    
    
      
          
            #
          
      
      
        Code review
        
          Ensure your code meets quality standards and ship with confidence.
        
      
      
          
            
          Star


      
    
    
      
          
            #
          
      
      
        Compiler
        
          Compilers are software that translate higher-level programming languages to lower-level languages (e.g. machine code).
        
      
      
          
            
          Star


      
    
    
      
          
            #
          
      
      
        Continuous integration
        
          Automatically build and test your code as you push it upstream, preventing bugs from being deployed to production.
        
      
      
          
            
          Star


      
    
    
      
          
      
      
        C++
        
          C++ is a general purpose and object-oriented programming language.
        
      
      
          
            
          Star


      
    
    
      
          
            #
          
      
      
        Cryptocurrency
        
          A cryptocurrency is a digital currency that uses cryptography.
        
      
      
          
            
          Star


      
    
    
      
          
      
      
        Crystal
        
          Crystal is a self-hosted, general purpose programming language.
        
      
      
          
            
          Star


      
    

  
    
    
      Load more…
    

  

  
      Popular topics
      
          
            
  react

          
          
            
  javascript

          
          
            
  config

          
          
            
  python

          
          
            
  api

          
          
            
  typescript

          
          
            
  ai

          
          
            
  nextjs

          
          
            
  tailwindcss

          
          
            
  github-config\n\n\n\nStar


  

  
    

      
        kortix-ai /

      suna  

    
      Suna - Open Source Generalist AI Agent
    

  
      
  
  TypeScript



      
        7,238
      
        801
      
        Built by

          
          
          
          
          

      
        
        1,304 stars today
  

  

      
            
        
          Star


  

  
    

      
        lapce /

      lapce  

    
      Lightning-fast and Powerful Code Editor written in Rust
    

  
      
  
  Rust



      
        35,415
      
        1,093
      
        Built by

          
          
          
          
          

      
        
        45 stars today
  

  

      
            
        
          Star


  

  
    

      
        rowboatlabs /

      rowboat  

    
      AI-powered multi-agent builder
    

  
      
  
  TypeScript



      
        1,623
      
        130
      
        Built by

          
          
          
          

      
        
        499 stars today
  

  

      
            
        
          Star


  

  
    

      
        ocrmypdf /

      OCRmyPDF  

    
      OCRmyPDF adds an OCR text layer to scanned PDF files, allowing them to be searched
    

  
      
  
  Python



      
        28,366
      
        1,917
      
        Built by

          
          
          
          
          

      
        
        78 stars today
  

  

      
            
        
          Star


  

  
    

      
        aquasecurity /

      trivy  

    
      Find vulnerabilities, misconfigurations, secrets, SBOM in containers, Kubernetes, code repositories, clouds and more
    

  
      
  
  Go



      
        25,879
      
        2,515
      
        Built by

          
          
          
          
          

      
        
        145 stars today
  

  
        
    
    
      Sponsor
    
  



      
            
        
          Star


  

  
    

      
        bregman-arie /

      devops-exercises  

    
      Linux, Jenkins, AWS, SRE, Prometheus, Docker, Python, Ansible, Git, Kubernetes, Terraform, OpenStack, SQL, NoSQL, Azure, GCP, DNS, Elastic, Network, Virtualization. DevOps Interview Questions
    

  
      
  
  Python



      
        74,905
      
        16,700
      
        Built by

          
          
          
          
          

      
        
        255 stars today
  

  

      
            
        
          Star


  

  
    

      
        trimstray /

      the-book-of-secret-knowledge  

    
      A collection of inspiring lists, manuals, cheatsheets, blogs, hacks, one-liners, cli/web tools and more.
    

  

      
        166,347
      
        10,413
      
        Built by

          
          
          
          
          

      
        
        1,399 stars today
  

  

      
            
        
          Star


  

  
    

      
        jujumilk3 /

      leaked-system-prompts  

    
      Collection of leaked system prompts
    

  

      
        4,114
      
        478
      
        Built by

          
          
          
          
          

      
        
        510 stars today
  

  
        
    
    
      Sponsor
    
  



      
            
        
          Star


  

  
    

      
        AmruthPillai /

      Reactive-Resume  

    
      A one-of-a-kind resume builder that keeps your privacy in mind. Completely secure, customizable, portable, open-source and free forever. Try it out today!
    

  
      
  
  TypeScript



      
        30,931
      
        3,198
      
        Built by

          
          
          
          
          

      
        
        62 stars today
  

  

      
            
        
          Star


  

  
    

      
        microsoft /

      generative-ai-for-beginners  

    
      21 Lessons, Get Started Building with Generative AI 🔗 https://microsoft.github.io/generative-ai-for-beginners/
    

  
      
  
  Jupyter Notebook



      
        80,164
      
        41,389
      
        Built by

          
          
          
          
          

      
        
        271 stars today
  

  
        
    
    
      Sponsor
    
  



      
            
        
          Star


  

  
    

      
        fastrepl /

      hyprnote  

    
      AI Notepad for back-to-back meetings. Local-first & Extensible.
    

  
      
  
  TypeScript



      
        1,323
      
        60
      
        Built by

          
          
          
          
          

      
        
        305 stars today
  

  

      
            
        
          Star


  

  
    

      
        getzep /

      graphiti  

    
      Build Real-Time Knowledge Graphs for AI Agents
    

  
      
  
  Python



      
        5,573
      
        404
      
        Built by

          
          
          
          
          

      
        
        514 stars today
  

  
        
    
    
      Sponsor
    
  



      
            
        
          Star


  

  
    

      
        khoj-ai /

      khoj  

    
      Your AI second brain. Self-hostable. Get answers from the web or your docs. Build custom agents, schedule automations, do deep research. Turn any online or local LLM into your personal, autonomous AI (gpt, claude, gemini, llama, qwen, mistral). Get started - free.
    

  
      
  
  Python



      
        29,558
      
        1,647
      
        Built by

          
          
          
          
          

      
        
        229 stars today
  

  

      
            
        
          Star


  

  
    

      
        ruanyf /

      weekly  

    
      科技爱好者周刊，每周五发布
    

  

      
        54,565
      
        3,203
      
        Built by

          
          
          
          
          

      
        
        36 stars today
  

  

      
            
        
          Star


  

  
    

      
        langgenius /

      dify  

    
      Dify is an open-source LLM app development platform. Dify's intuitive interface combines AI workflow, RAG pipeline, agent capabilities, model management, observability features and more, letting you quickly go from prototype to production.
    

  
      
  
  TypeScript



      
        94,437
      
        14,108
      
        Built by

          
          
          
          
          

      
        
        133 stars today
  

  

      
            
        
          Star


  

  
    

      
        RVC-Boss /

      GPT-SoVITS  

    
      1 min voice data can also be used to train a good TTS model! (few shot voice cloning)
    

  
      
  
  Python



      
        45,487
      
        5,022
      
        Built by

          
          
          
          
          

      
        
        53 stars today
  

  

      
            
        
          Star


  

  
    

      
        skypilot-org /

      skypilot  

    
      SkyPilot: Run AI and batch jobs on any infra (Kubernetes or 16+ clouds). Get unified execution, cost savings, and high GPU availability via a simple interface.
    

  
      
  
  Python



      
        7,857
      
        628
      
        Built by

          
          
          
          
          

      
        
        21 stars today\n\nExplore

      Topics

        Trending

        Collections

        Events

        GitHub Sponsors
    
  




  
    Trending

    
      See what the GitHub community is most excited about today.
    
  



  
    
      
  Repositories
  Developers



      
        
          
        Spoken Language:

    
        Any


  
    
      
        Select a spoken language

      

    

    
      
        
      
    

    

      
          
              Abkhazian
          
              Afar
          
              Afrikaans
          
              Akan
          
              Albanian
          
              Amharic
          
              Arabic
          
              Aragonese
          
              Armenian
          
              Assamese
          
              Avaric
          
              Avestan
          
              Aymara
          
              Azerbaijani
          
              Bambara
          
              Bashkir
          
              Basque
          
              Belarusian
          
              Bengali
          
              Bihari languages
          
              Bislama
          
              Bosnian
          
              Breton
          
              Bulgarian
          
              Burmese
          
              Catalan, Valencian
          
              Chamorro
          
              Chechen
          
              Chichewa, Chewa, Nyanja
          
              Chinese
          
              Chuvash
          
              Cornish
          
              Corsican
          
              Cree
          
              Croatian
          
              Czech
          
              Danish
          
              Divehi, Dhivehi, Maldivian
          
              Dutch, Flemish
          
              Dzongkha
          
              English
          
              Esperanto
          
              Estonian
          
              Ewe
          
              Faroese
          
              Fijian
          
              Finnish
          
              French
          
              Fulah
          
              Galician
          
              Georgian
          
              German
          
              Greek, Modern
          
              Guarani
          
              Gujarati
          
              Haitian, Haitian Creole
          
              Hausa
          
              Hebrew
          
              Herero
          
              Hindi
          
              Hiri Motu
          
              Hungarian
          
              Interlingua (International Auxil...
          
              Indonesian
          
              Interlingue, Occidental
          
              Irish
          
              Igbo
          
              Inupiaq
          
              Ido
          
              Icelandic
          
              Italian
          
              Inuktitut
          
              Japanese
          
              Javanese
          
              Kalaallisut, Greenlandic
          
              Kannada
          
              Kanuri
          
              Kashmiri
          
              Kazakh
          
              Central Khmer
          
              Kikuyu, Gikuyu
          
              Kinyarwanda
          
              Kirghiz, Kyrgyz
          
              Komi
          
              Kongo
          
              Korean
          
              Kurdish
          
              Kuanyama, Kwanyama
          
              Latin
          
              Luxembourgish, Letzeburgesch
          
              Ganda
          
              Limburgan, Limburger, Limburgish
          
              Lingala
          
              Lao
          
              Lithuanian
          
              Luba-Katanga
          
              Latvian
          
              Manx
          
              Macedonian
          
              Malagasy
          
              Malay
          
              Malayalam
          
              Maltese
          
              Maori
          
              Marathi
          
              Marshallese
          
              Mongolian
          
              Nauru
          
              Navajo, Navaho
          
              North Ndebele
          
              Nepali
          
              Ndonga
          
              Norwegian Bokmål
          
              Norwegian Nynorsk
          
              Norwegian
          
              Sichuan Yi, Nuosu
          
              South Ndebele
          
              Occitan
          
              Ojibwa
          
              Church Slavic, Old Slavonic, Chu...
          
              Oromo
          
              Oriya
          
              Ossetian, Ossetic
          
              Punjabi, Panjabi
          
              Pali
          
              Persian
          
              Polish
          
              Pashto, Pushto
          
              Portuguese
          
              Quechua
          
              Romansh
          
              Rundi
          
              Romanian, Moldavian, Moldovan
          
              Russian
          
              Sanskrit
          
              Sardinian
          
              Sindhi
          
              Northern Sami
          
              Samoan
          
              Sango
          
              Serbian
          
              Gaelic, Scottish Gaelic
          
              Shona
          
              Sinhala, Sinhalese
          
              Slovak
          
              Slovenian
          
              Somali
          
              Southern Sotho
          
              Spanish, Castilian
          
              Sundanese
          
              Swahili
          
              Swati
          
              Swedish
          
              Tamil
          
              Telugu
          
              Tajik
          
              Thai
          
              Tigrinya
          
              Tibetan
          
              Turkmen
          
              Tagalog
          
              Tswana
          
              Tonga (Tonga Islands)
          
              Turkish
          
              Tsonga
          
              Tatar
          
              Twi
          
              Tahitian
          
              Uighur, Uyghur
          
              Ukrainian
          
              Urdu
          
              Uzbek
          
              Venda
          
              Vietnamese
          
              Volapük
          
              Walloon
          
              Welsh
          
              Wolof
          
              Western Frisian
          
              Xhosa
          
              Yiddish
          
              Yoruba
          
              Zhuang, Chuang
          
              Zulu
      
    

    
      
      Loading

    
  



        

        
          
        Language:

    
        Any


  
    
      
        Select a language

      
    

    
      
        
      
    

    

      
          
              Unknown languages
          
              1C Enterprise
          
              2-Dimensional Array
          
              4D
          
              ABAP
          
              ABAP CDS
          
              ABNF
          
              ActionScript
          
              Ada
          
              Adblock Filter List
          
              Adobe Font Metrics
          
              Agda
          
              AGS Script
          
              AIDL
          
              AL
          
              Alloy
          
              Alpine Abuild
          
              Altium Designer
          
              AMPL
          
              AngelScript
          
              Answer Set Programming
          
              Ant Build System
          
              Antlers
          
              ANTLR
          
              ApacheConf
          
              Apex
          
              API Blueprint
          
              APL
          
              Apollo Guidance Computer
          
              AppleScript
          
              Arc
          
              AsciiDoc
          
              ASL
          
              ASN.1
          
              Classic ASP
          
              ASP.NET
          
              AspectJ
          
              Assembly
          
              Astro
          
              Asymptote
          
              ATS
          
              Augeas
          
              AutoHotkey
          
              AutoIt
          
              Avro IDL
          
              Awk
          
              B4X
          
              Ballerina
          
              BASIC
          
              Batchfile
          
              Beef
          
              Befunge
          
              Berry
          
              BibTeX
          
              BibTeX Style
          
              Bicep
          
              Bikeshed
          
              Bison
          
              BitBake
          
              Blade
          
              BlitzBasic
          
              BlitzMax
          
              Bluespec
          
              Bluespec BH
          
              Boo
          
              Boogie
          
              BQN
          
              Brainfuck
          
              BrighterScript
          
              Brightscript
          
              Zeek
          
              Browserslist
          
              C
          
              C#
          
              C++
          
              C-ObjDump
          
              C2hs Haskell
          
              Cabal Config
          
              Caddyfile
          
              Cadence
          
              Cairo
          
              Cairo Zero
          
              CameLIGO
          
              CAP CDS
          
              Cap'n Proto
          
              Carbon
          
              CartoCSS
          
              Ceylon
          
              Chapel
          
              Charity
          
              Checksums
          
              ChucK
          
              CIL
          
              Circom
          
              Cirru
          
              Clarion
          
              Clarity
          
              Classic ASP
          
              Clean
          
              Click
          
              CLIPS
          
              Clojure
          
              Closure Templates
          
              Cloud Firestore Security Rules
          
              CMake
          
              COBOL
          
              CODEOWNERS
          
              CodeQL
          
              CoffeeScript
          
              ColdFusion
          
              ColdFusion CFC
          
              COLLADA
          
              Common Lisp
          
              Common Workflow Language
          
              Component Pascal
          
              CoNLL-U
          
              Cool
          
              Coq
          
              Cpp-ObjDump
          
              Creole
          
              crontab
          
              Crystal
          
              CSON
          
              Csound
          
              Csound Document
          
              Csound Score
          
              CSS
          
              CSV
          
              Cuda
          
              CUE
          
              Cue Sheet
          
              cURL Config
          
              Curry
          
              CWeb
          
              Cycript
          
              Cylc
          
              Cypher
          
              Cython
          
              D
          
              D-ObjDump
          
              D2
          
              Dafny
          
              Darcs Patch
          
              Dart
          
              DataWeave
          
              Debian Package Control File
          
              DenizenScript
          
              desktop
          
              Dhall
          
              Diff
          
              DIGITAL Command Language
          
              dircolors
          
              DirectX 3D File
          
              DM
          
              DNS Zone
          
              Dockerfile
          
              Dogescript
          
              Dotenv
          
              DTrace
          
              Dune
          
              Dylan
          
              E
          
              E-mail
          
              Eagle
          
              Earthly
          
              Easybuild
          
              EBNF
          
              eC
          
              Ecere Projects
          
              ECL
          
              ECLiPSe
          
              Ecmarkup
          
              Edge
          
              EdgeQL
          
              EditorConfig
          
              Edje Data Collection
          
              edn
          
              Eiffel
          
              EJS
          
              Elixir
          
              Elm
          
              Elvish
          
              Elvish Transcript
          
              Emacs Lisp
          
              EmberScript
          
              E-mail
          
              EQ
          
              Erlang
          
              Euphoria
          
              F#
          
              F*
          
              Factor
          
              Fancy
          
              Fantom
          
              Faust
          
              Fennel
          
              FIGlet Font
          
              Filebench WML
          
              Filterscript
          
              FIRRTL
          
              fish
          
              Fluent
          
              FLUX
          
              Formatted
          
              Forth
          
              Fortran
          
              Fortran Free Form
          
              FreeBASIC
          
              FreeMarker
          
              Frege
          
              Futhark
          
              G-code
          
              Game Maker Language
          
              GAML
          
              GAMS
          
              GAP
          
              GCC Machine Description
          
              GDB
          
              GDScript
          
              GEDCOM
          
              Gemfile.lock
          
              Gemini
          
              Genero 4gl
          
              Genero per
          
              Genie
          
              Genshi
          
              Gentoo Ebuild
          
              Gentoo Eclass
          
              Gerber Image
          
              Gettext Catalog
          
              Gherkin
          
              Git Attributes
          
              Git Config
          
              Git Revision List
          
              Gleam
          
              Glimmer JS
          
              Glimmer TS
          
              GLSL
          
              Glyph
          
              Glyph Bitmap Distribution Format
          
              GN
          
              Gnuplot
          
              Go
          
              Go Checksums
          
              Go Module
          
              Go Workspace
          
              Godot Resource
          
              Golo
          
              Gosu
          
              Grace
          
              Gradle
          
              Gradle Kotlin DSL
          
              Grammatical Framework
          
              Graph Modeling Language
          
              GraphQL
          
              Graphviz (DOT)
          
              Groovy
          
              Groovy Server Pages
          
              GSC
          
              Hack
          
              Haml
          
              Handlebars
          
              HAProxy
          
              Harbour
          
              Hare
          
              Haskell
          
              Haxe
          
              HCL
          
              HiveQL
          
              HLSL
          
              HOCON
          
              HolyC
          
              hoon
          
              Hosts File
          
              HTML
          
              Jinja
          
              HTML+ECR
          
              HTML+EEX
          
              HTML+ERB
          
              HTML+PHP
          
              HTML+Razor
          
              HTTP
          
              HXML
          
              Hy
          
              HyPhy
          
              iCalendar
          
              IDL
          
              Idris
          
              Ignore List
          
              IGOR Pro
          
              ImageJ Macro
          
              Imba
          
              Inform 7
          
              INI
          
              Ink
          
              Inno Setup
          
              Io
          
              Ioke
          
              IRC log
          
              Isabelle
          
              Isabelle ROOT
          
              ISPC
          
              J
          
              Jai
          
              Janet
          
              JAR Manifest
          
              Jasmin
          
              Java
          
              Java Properties
          
              Java Server Pages
          
              Java Template Engine
          
              JavaScript
          
              JavaScript+ERB
          
              JCL
          
              Jest Snapshot
          
              JetBrains MPS
          
              JFlex
          
              Jinja
          
              Jison
          
              Jison Lex
          
              Jolie
          
              jq
          
              JSON
          
              JSON with Comments
          
              JSON5
          
              JSONiq
          
              JSONLD
          
              Jsonnet
          
              Julia
          
              Julia REPL
          
              Jupyter Notebook
          
              Just
          
              Kaitai Struct
          
              KakouneScript
          
              KDL
          
              KerboScript
          
              KiCad Layout
          
              KiCad Legacy Layout
          
              KiCad Schematic
          
              Kickstart
          
              Kit
          
              Kotlin
          
              KRL
          
              Kusto
          
              kvlang
          
              LabVIEW
          
              Lark
          
              Lasso
          
              Latte
          
              Lean
          
              Lean 4
          
              Less
          
              Lex
          
              LFE
          
              LigoLANG
          
              LilyPond
          
              Limbo
          
              Linear Programming
          
              Linker Script
          
              Linux Kernel Module
          
              Liquid
          
              Literate Agda
          
              Literate CoffeeScript
          
              Literate Haskell
          
              LiveCode Script
          
              LiveScript
          
              LLVM
          
              Logos
          
              Logtalk
          
              LOLCODE
          
              LookML
          
              LoomScript
          
              LSL
          
              LTspice Symbol
          
              Lua
          
              Luau
          
              M
          
              M4
          
              M4Sugar
          
              Macaulay2
          
              Makefile
          
              Mako
          
              Markdown
          
              Marko
          
              Mask
          
              Mathematica
          
              MATLAB
          
              Maven POM
          
              Max
          
              MAXScript
          
              mcfunction
          
              mdsvex
          
              MDX
          
              Wikitext
          
              Mercury
          
              Mermaid
          
              Meson
          
              Metal
          
              Microsoft Developer Studio Project
          
              Microsoft Visual Studio Solution
          
              MiniD
          
              MiniYAML
          
              MiniZinc
          
              MiniZinc Data
          
              Mint
          
              Mirah
          
              mIRC Script
          
              MLIR
          
              Modelica
          
              Modula-2
          
              Modula-3
          
              Module Management System
          
              Mojo
          
              Monkey
          
              Monkey C
          
              Moocode
          
              MoonBit
          
              MoonScript
          
              Motoko
          
              Motorola 68K Assembly
          
              Move
          
              MQL4
          
              MQL5
          
              MTML
          
              MUF
          
              mupad
          
              Muse
          
              Mustache
          
              Myghty
          
              nanorc
          
              Nasal
          
              NASL
          
              NCL
          
              Nearley
          
              Nemerle
          
              NEON
          
              nesC
          
              NetLinx
          
              NetLinx+ERB
          
              NetLogo
          
              NewLisp
          
              Nextflow
          
              Nginx
          
              Nim
          
              Ninja
          
              Nit
          
              Nix
          
              NL
          
              NMODL
          
              Noir
          
              NPM Config
          
              NSIS
          
              Nu
          
              NumPy
          
              Nunjucks
          
              Nushell
          
              NWScript
          
              OASv2-json
          
              OASv2-yaml
          
              OASv3-json
          
              OASv3-yaml
          
              Oberon
          
              ObjDump
          
              Object Data Instance Notation
          
              Objective-C
          
              Objective-C++
          
              Objective-J
          
              ObjectScript
          
              OCaml
          
              Odin
          
              Omgrofl
          
              OMNeT++ MSG
          
              OMNeT++ NED
          
              OMNeT++ MSG
          
              OMNeT++ NED
          
              ooc
          
              Opa
          
              Opal
          
              Open Policy Agent
          
              OpenAPI Specification v2
          
              OpenAPI Specification v3
          
              OpenCL
          
              OpenEdge ABL
          
              OpenQASM
          
              OpenRC runscript
          
              OpenSCAD
          
              OpenStep Property List
          
              OpenType Feature File
          
              Option List
          
              Org
          
              OverpassQL
          
              Ox
          
              Oxygene
          
              Oz
          
              P4
          
              Pact
          
              Pan
          
              Papyrus
          
              Parrot
          
              Parrot Assembly
          
              Parrot Internal Representation
          
              Pascal
          
              Pawn
          
              PDDL
          
              PEG.js
          
              Pep8
          
              Perl
          
              PHP
          
              Pic
          
              Pickle
          
              PicoLisp
          
              PigLatin
          
              Pike
          
              Pip Requirements
          
              Pkl
          
              PlantUML
          
              PLpgSQL
          
              PLSQL
          
              Pod
          
              Pod 6
          
              PogoScript
          
              Polar
          
              Pony
          
              Portugol
          
              PostCSS
          
              PostScript
          
              POV-Ray SDL
          
              PowerBuilder
          
              PowerShell
          
              Praat
          
              Prisma
          
              Processing
          
              Procfile
          
              Proguard
          
              Prolog
          
              Promela
          
              Propeller Spin
          
              Protocol Buffer
          
              Protocol Buffer Text Format
          
              Public Key
          
              Pug
          
              Puppet
          
              Pure Data
          
              PureBasic
          
              PureScript
          
              Pyret
          
              Python
          
              Python console
          
              Python traceback
          
              q
          
              Q#
          
              QMake
          
              QML
          
              Qt Script
          
              Quake
          
              QuickBASIC
          
              R
          
              Racket
          
              Ragel
          
              Raku
          
              RAML
          
              Rascal
          
              Raw token data
          
              RBS
          
              RDoc
          
              Readline Config
          
              REALbasic
          
              Reason
          
              ReasonLIGO
          
              Rebol
          
              Record Jar
          
              Red
          
              Redcode
          
              Redirect Rules
          
              Regular Expression
          
              Ren'Py
          
              RenderScript
          
              ReScript
          
              reStructuredText
          
              REXX
          
              Rez
          
              Rich Text Format
          
              Ring
          
              Riot
          
              RMarkdown
          
              RobotFramework
          
              robots.txt
          
              Roc
          
              Roff
          
              Roff Manpage
          
              RON
          
              Rouge
          
              RouterOS Script
          
              RPC
          
              RPGLE
          
              RPM Spec
          
              Ruby
          
              RUNOFF
          
              Rust
          
              Sage
          
              SaltStack
          
              SAS
          
              Sass
          
              Scala
          
              Scaml
          
              Scenic
          
              Scheme
          
              Scilab
          
              SCSS
          
              sed
          
              Self
          
              SELinux Policy
          
              ShaderLab
          
              Shell
          
              ShellCheck Config
          
              ShellSession
          
              Shen
          
              Sieve
          
              Simple File Verification
          
              Singularity
          
              Slang
          
              Slash
          
              Slice
          
              Slim
          
              Slint
          
              Smali
          
              Smalltalk
          
              Smarty
          
              Smithy
          
              SmPL
          
              SMT
          
              Snakemake
          
              Solidity
          
              Soong
          
              SourcePawn
          
              SPARQL
          
              Spline Font Database
          
              SQF
          
              SQL
          
              SQLPL
          
              Squirrel
          
              SRecode Template
          
              SSH Config
          
              Stan
          
              Standard ML
          
              STAR
          
              Starlark
          
              Stata
          
              STL
          
              STON
          
              StringTemplate
          
              Stylus
          
              SubRip Text
          
              SugarSS
          
              SuperCollider
          
              Svelte
          
              SVG
          
              Sway
          
              Sweave
          
              Swift
          
              SWIG
          
              SystemVerilog
          
              Tact
          
              Talon
          
              Tcl
          
              Tcsh
          
              Tea
          
              templ
          
              Terra
          
              Terraform Template
          
              TeX
          
              Texinfo
          
              Text
          
              TextGrid
          
              Textile
          
              TextMate Properties
          
              Thrift
          
              TI Program
          
              TL-Verilog
          
              TLA
          
              Toit
          
              TOML
          
              Tree-sitter Query
          
              TSPLIB data
          
              TSQL
          
              TSV
          
              TSX
          
              Turing
          
              Turtle
          
              Twig
          
              TXL
          
              Type Language
          
              TypeScript
          
              TypeSpec
          
              Typst
          
              Unified Parallel C
          
              Unity3D Asset
          
              Unix Assembly
          
              Uno
          
              UnrealScript
          
              UrWeb
          
              V
          
              Vala
          
              Valve Data Format
          
              VBA
          
              VBScript
          
              vCard
          
              VCL
          
              Velocity Template Language
          
              Verilog
          
              VHDL
          
              Vim Help File
          
              Vim Script
          
              Vim Snippet
          
              Visual Basic .NET
          
              Visual Basic .NET
          
              Visual Basic 6.0
          
              Volt
          
              Vue
          
              Vyper
          
              Wavefront Material
          
              Wavefront Object
          
              WDL
          
              Web Ontology Language
          
              WebAssembly
          
              WebAssembly Interface Type
          
              WebIDL
          
              WebVTT
          
              Wget Config
          
              WGSL
          
              Whiley
          
              Wikitext
          
              Win32 Message File
          
              Windows Registry Entries
          
              wisp
          
              Witcher Script
          
              Wollok
          
              World of Warcraft Addon Data
          
              Wren
          
              X BitMap
          
              X Font Directory Index
          
              X PixMap
          
              X10
          
              xBase
          
              XC
          
              XCompose
          
              Xmake
          
              XML
          
              XML Property List
          
              Xojo
          
              Xonsh
          
              XPages
          
              XProc
          
              XQuery
          
              XS
          
              XSLT
          
              Xtend
          
              Yacc
          
              YAML
          
              YANG
          
              YARA
          
              YASnippet
          
              Yul
          
              ZAP
          
              Zeek
          
              ZenScript
          
              Zephir
          
              Zig
          
              ZIL
          
              Zimpl
      
    
    
      
      Loading

    
  


        

        
          
        Date range:

    
      Today


  
    
      
        Adjust time span

      
    

    
        

          
            Today
        

          
            This week
        

          
            This month
    
  


        
      
    

    
          
  

      
            
        
          Star


  

  
    

      
        kortix-ai /

      suna  

    
      Suna - Open Source Generalist AI Agent
    

  
      
  
  TypeScript



      
        7,238
      
        801
      
        Built by

          
          
          
          
          

      
        
        1,304 stars today
  


          
  

      
            
        
          Star


  

  
    

      
        lapce /

      lapce  

    
      Lightning-fast and Powerful Code Editor written in Rust
    

  
      
  
  Rust



      
        35,415
      
        1,093
      
        Built by

          
          
          
          
          

      
        
        45 stars today
  


          
  

      
            
        
          Star


  

  
    

      
        rowboatlabs /

      rowboat  

    
      AI-powered multi-agent builder
    

  
      
  
  TypeScript



      
        1,623
      
        130
      
        Built by

          
          
          
          

      
        
        499 stars today
  


          
  

      
            
        
          Star


  

  
    

      
        ocrmypdf /

      OCRmyPDF  

    
      OCRmyPDF adds an OCR text layer to scanned PDF files, allowing them to be searched
    

  
      
  
  Python



      
        28,366
      
        1,917
      
        Built by

          
          
          
          
          

      
        
        78 stars today
  


          
  

      
            
        
          Star


  

  
    

      
        aquasecurity /

      trivy  

    
      Find vulnerabilities, misconfigurations, secrets, SBOM in containers, Kubernetes, code repositories, clouds and more
    

  
      
  
  Go



      
        25,879
      
        2,515
      
        Built by

          
          
          
          
          

      
        
        145 stars today
  


          
  
        
    
    
      Sponsor
    
  



      
            
        
          Star


  

  
    

      
        bregman-arie /

      devops-exercises  

    
      Linux, Jenkins, AWS, SRE, Prometheus, Docker, Python, Ansible, Git, Kubernetes, Terraform, OpenStack, SQL, NoSQL, Azure, GCP, DNS, Elastic, Network, Virtualization. DevOps Interview Questions
    

  
      
  
  Python



      
        74,905
      
        16,700
      
        Built by

          
          
          
          
          

      
        
        255 stars today
  


          
  

      
            
        
          Star


  

  
    

      
        trimstray /

      the-book-of-secret-knowledge  

    
      A collection of inspiring lists, manuals, cheatsheets, blogs, hacks, one-liners, cli/web tools and more.
    

  

      
        166,347
      
        10,413
      
        Built by

          
          
          
          
          

      
        
        1,399 stars today
  


          
  

      
            
        
          Star


  

  
    

      
        jujumilk3 /

      leaked-system-prompts  

    
      Collection of leaked system prompts
    

  

      
        4,114
      
        478
      
        Built by

          
          
          
          
          

      
        
        510 stars today
  


          
  
        
    
    
      Sponsor
    
  



      
            
        
          Star


  

  
    

      
        AmruthPillai /

      Reactive-Resume  

    
      A one-of-a-kind resume builder that keeps your privacy in mind. Completely secure, customizable, portable, open-source and free forever. Try it out today!
    

  
      
  
  TypeScript



      
        30,931
      
        3,198
      
        Built by

          
          
          
          
          

      
        
        62 stars today
  


          
  

      
            
        
          Star


  

  
    

      
        microsoft /

      generative-ai-for-beginners  

    
      21 Lessons, Get Started Building with Generative AI 🔗 https://microsoft.github.io/generative-ai-for-beginners/
    

  
      
  
  Jupyter Notebook



      
        80,164
      
        41,389
      
        Built by

          
          
          
          
          

      
        
        271 stars today
  


          
  
        
    
    
      Sponsor
    
  



      
            
        
          Star


  

  
    

      
        fastrepl /

      hyprnote  

    
      AI Notepad for back-to-back meetings. Local-first & Extensible.
    

  
      
  
  TypeScript



      
        1,323
      
        60
      
        Built by

          
          
          
          
          

      
        
        305 stars today
  


          
  

      
            
        
          Star


  

  
    

      
        getzep /

      graphiti  

    
      Build Real-Time Knowledge Graphs for AI Agents
    

  
      
  
  Python



      
        5,573
      
        404
      
        Built by

          
          
          
          
          

      
        
        514 stars today
  


          
  
        
    
    
      Sponsor
    
  



      
            
        
          Star


  

  
    

      
        khoj-ai /

      khoj  

    
      Your AI second brain. Self-hostable. Get answers from the web or your docs. Build custom agents, schedule automations, do deep research. Turn any online or local LLM into your personal, autonomous AI (gpt, claude, gemini, llama, qwen, mistral). Get started - free.
    

  
      
  
  Python



      
        29,558
      
        1,647
      
        Built by

          
          
          
          
          

      
        
        229 stars today
  


          
  

      
            
        
          Star


  

  
    

      
        ruanyf /

      weekly  

    
      科技爱好者周刊，每周五发布
    

  

      
        54,565
      
        3,203
      
        Built by

          
          
          
          
          

      
        
        36 stars today
  


          
  

      
            
        
          Star


  

  
    

      
        langgenius /

      dify  

    
      Dify is an open-source LLM app development platform. Dify's intuitive interface combines AI workflow, RAG pipeline, agent capabilities, model management, observability features and more, letting you quickly go from prototype to production.
    

  
      
  
  TypeScript



      
        94,437
      
        14,108
      
        Built by

          
          
          
          
          

      
        
        133 stars today
  


          
  

      
            
        
          Star


  

  
    

      
        RVC-Boss /

      GPT-SoVITS  

    
      1 min voice data can also be used to train a good TTS model! (few shot voice cloning)
    

  
      
  
  Python



      
        45,487
      
        5,022
      
        Built by

          
          
          
          
          

      
        
        53 stars today
  


          
  

      
            
        
          Star


  

  
    

      
        skypilot-org /

      skypilot  

    
      SkyPilot: Run AI and batch jobs on any infra (Kubernetes or 16+ clouds). Get unified execution, cost savings, and high GPU availability via a simple interface.
    

  
      
  
  Python



      
        7,857
      
        628
      
        Built by

          
          
          
          
          

      
        
        21 stars today\n\n\n\n#
    

    
      How to choose (and contribute to) your first open source project
      New to open source? Here’s how to find projects that need help and start making impactful contributions.
    
  
    
        #
    

    
      Clean code linters
      Make sure your code matches your style guide with these essential code linters.
    
  
    
        #
    

    
      Open journalism
      See how publications and data-driven journalists use open source to power their newsroom and ensure information is reported fairly and accurately.
    
  
    
        #
    

    
      Design essentials
      This collection of design libraries are the best on the web, and will complete your toolset for designing stunning products.
    
  
    
        #
    

    
      Music
      Drop the code bass with these musically themed repositories.
    
  
    
        
    

    
      Government apps
      Sites, apps, and tools built by governments across the world to make government work better, together. Read more at https://government.github.com
    
  
    
        #
    

    
      DevOps tools
      These tools help you manage servers and deploy happier and more often with more confidence.
    
  
    
        #
    

    
      Front-end JavaScript frameworks
      While the number of ways to organize JavaScript is almost infinite, here are some tools that help you build single-page applications.
    
  
    
        #
    

    
      GitHub Browser Extensions
      Some useful and fun browser extensions to personalize your GitHub browser experience.
    
  
    
        
    

    
      GitHub Pages examples
      Fine examples of projects using GitHub Pages (https://pages.github.com).
    
  
    
        
    

    
      Hacking Minecraft
      Minecraft is a game about building blocks, but it doesn’t end there. Take Minecraft further with some of the projects below, or dive into the code mines and hammer your own!
    
  
    
        #
    

    
      JavaScript Game Engines
      Learn or level up your 1337 gamedev skills and build amazing games together for web, desktop, or mobile using these HTML5 / JavaScript game engines.
    
  
    
        
    

    
      Learn to Code
      Resources to help people learn to code
    
  
    
        #
    

    
      Getting started with machine learning
      Today, machine learning—the study of algorithms that make data-based predictions—has found a new audience and a new set of possibilities.
    
  
    
        
    

    
      Made in Africa
      Developers in Africa use open source technology to solve some of the world's most intractable problems and grow their business ecosystems. Here's a snapshot of local projects across the continent.
    
  
    
        
    

    
      Net neutrality
      Software, research, and organizations protecting the free and open internet.
    
  
    
        #
    

    
      Open data
      Examples of using GitHub to store, publish, and collaborate on open, machine-readable datasets
    
  
    
        
    

    
      Open source organizations
      A showcase of organizations showcasing their open source projects.
    
  
    
        #
    

    
      Policies
      From federal governments to corporations to student clubs, groups of all sizes are using GitHub to share, discuss, and improve laws. *Ask not what the repository can do for you...*
    
  
    
        #
    

    
      Software productivity tools
      Build software faster with fewer headaches, using these tools and tricks.\n\nExplore

      Topics

        Trending

        Collections

        Events

        GitHub Sponsors
    
  




  
    Collections
    Curated lists and insight into burgeoning industries, topics, and communities.
  

  
    
        
  
      
    Made in Brazil
    Open source projects built in or receiving significant contributions from Brazil :brazil:
  


        
  
      
    Learn to Code
    Resources to help people learn to code
  


        
  
      
    Pixel Art Tools
    Creating pixel art for fun or animated sprites for a game? The digital artist in you will love these apps and tools!
  


    
  

    
    
        #
    

    
      How to choose (and contribute to) your first open source project
      New to open source? Here’s how to find projects that need help and start making impactful contributions.
    
  
  
    
        #
    

    
      Clean code linters
      Make sure your code matches your style guide with these essential code linters.
    
  
  
    
        #
    

    
      Open journalism
      See how publications and data-driven journalists use open source to power their newsroom and ensure information is reported fairly and accurately.
    
  
  
    
        #
    

    
      Design essentials
      This collection of design libraries are the best on the web, and will complete your toolset for designing stunning products.
    
  
  
    
        #
    

    
      Music
      Drop the code bass with these musically themed repositories.
    
  
  
    
        
    

    
      Government apps
      Sites, apps, and tools built by governments across the world to make government work better, together. Read more at https://government.github.com
    
  
  
    
        #
    

    
      DevOps tools
      These tools help you manage servers and deploy happier and more often with more confidence.
    
  
  
    
        #
    

    
      Front-end JavaScript frameworks
      While the number of ways to organize JavaScript is almost infinite, here are some tools that help you build single-page applications.
    
  
  
    
        #
    

    
      GitHub Browser Extensions
      Some useful and fun browser extensions to personalize your GitHub browser experience.
    
  
  
    
        
    

    
      GitHub Pages examples
      Fine examples of projects using GitHub Pages (https://pages.github.com).
    
  
  
    
        
    

    
      Hacking Minecraft
      Minecraft is a game about building blocks, but it doesn’t end there. Take Minecraft further with some of the projects below, or dive into the code mines and hammer your own!
    
  
  
    
        #
    

    
      JavaScript Game Engines
      Learn or level up your 1337 gamedev skills and build amazing games together for web, desktop, or mobile using these HTML5 / JavaScript game engines.
    
  
  
    
        
    

    
      Learn to Code
      Resources to help people learn to code
    
  
  
    
        #
    

    
      Getting started with machine learning
      Today, machine learning—the study of algorithms that make data-based predictions—has found a new audience and a new set of possibilities.
    
  
  
    
        
    

    
      Made in Africa
      Developers in Africa use open source technology to solve some of the world's most intractable problems and grow their business ecosystems. Here's a snapshot of local projects across the continent.
    
  
  
    
        
    

    
      Net neutrality
      Software, research, and organizations protecting the free and open internet.
    
  
  
    
        #
    

    
      Open data
      Examples of using GitHub to store, publish, and collaborate on open, machine-readable datasets
    
  
  
    
        
    

    
      Open source organizations
      A showcase of organizations showcasing their open source projects.
    
  
  
    
        #
    

    
      Policies
      From federal governments to corporations to student clubs, groups of all sizes are using GitHub to share, discuss, and improve laws. *Ask not what the repository can do for you...*
    
  
  
    
        #
    

    
      Software productivity tools
      Build software faster with fewer headaches, using these tools and tricks.
    
  
  
    
    Load more…\n\n\n\nGitHub CopilotFor businessExtensions TutorialsWhat’s newPlans & pricingCopilot for BusinessBuild what’s next with GitHub  CopilotView plans & pricingContact salesAccelerating Commerce: Mercado Libre + GitHubGitHub Copilot equips you to build the future, whether you're charged with scaling operations or boosting developer productivity. AI that grows with you. Use your code as context while setting boundaries for what to exclude and governance on use.Velocity with quality. Developers want tools without toil, and GitHub Copilot provides AI assistance from the IDE to GitHub to the CLI and more, with agents to review and suggest.Choose your AI adventure. From choice of model to third-party integrations, GitHub Copilot meets your challenges your way.
/features/copilot/copilot-business logoThe competitive advantage developers ask for by nameQuantifying GitHub Copilot's impactSince bringing GitHub Copilot to market, we’ve conducted several lab studies to discover its impact on developer efficiency, developer satisfaction, and overall code quality.Learn moreLeader in the Gartner Magic Quadrant for AI Code AssistantsIn 2024, Gartner published a first-of-its-kind report analyzing the state of play in the AI Code Assistants market–and named GitHub a Leader.View Gartner reportCommitted to your privacy, security, and trustGitHub is committed to building secure defaults for developers and organizations.Visit the trust centerHow Thomson Reuters successfully adopted AI —and how your organization can, tooRead more55%faster coding39%improvement in code quality68%had a positive experienceResources and insightsStay ahead with GitHub’s latest innovationsSee how our recent and upcoming releases can help your organization drive efficiency, security, and innovation.
See what's newMeasuring the impact of GitHub CopilotMany enterprises quite reasonably ask, “How do I know Copilot is conferring these benefits for my team?” To answer that question, this guide will walk you through a framework for evaluating impact across four stages. Learn moreHow developers spend the  time they save thanks to AI coding toolsDevelopers tell us how GitHub Copilot and other AI coding tools are transforming their work and changing how they spend their days.Learn moreGet approved onceHands-on consulting, guided workshops, and trainingInsights, best practices, and knowledge to help you adopt GitHub quickly and efficiently.Explore GitHub Expert ServicesMeet the companies who build with GitHubLeading organizations choose GitHub to plan, build, secure and ship software.Read customer storiesExecutive insights, curated just for youThought leadership from subject matter experts that extends beyond tooling into business impact.Explore Executive Insights“With the time savings Copilot unlocks, our developers are empowered to spend more time on the tasks they enjoy most — creative-problem solving, innovative projects and experimentation.”Jasmine RamosIT Principal Product Manager, Mercedes-Benz Build what’s nextWhether you're charged with scaling enterprise operations or boosting developer productivity, GitHub Copilot equips you to build what’s next.View plans & pricingContact salesFAQsCan I use code hosting platforms other than GitHub for my repositories and still use GitHub Copilot?Yes. GitHub Copilot functionality works in code editors regardless of code hosting platform. Some features are enhanced with the use of GitHub because Copilot can directly draw context and knowledge from repositories, pull requests, issues, and other data structures in the GitHub platform.
Does GitHub use Copilot Business or Enterprise data to train GitHub’s model?No. GitHub does not use either Copilot Business or Enterprise data to train its models. 
Does GitHub Copilot include a filtering mechanism to mitigate risk?Yes, GitHub Copilot does include an optional code referencing filter to detect and suppress certain suggestions that match public code on GitHub.GitHub has created a duplication detection filter to detect and suppress suggestions that contain code segments over a certain length that match public code on GitHub. This filter can be enabled by the administrator for your enterprise and it can apply for all organizations within your enterprise, or the administrator can defer control to individual organizations. With the filter enabled, Copilot checks code suggestions for matches or near-matches against public code on GitHub of 65 lexemes or more (on average,150 characters). If there is a match, the suggestion will not be shown to the user.In addition to off-topic, harmful, and offensive output filters, GitHub Copilot also scans the outputs for vulnerable code.Does GitHub Copilot support compliance with the GDPR and other data protection laws?Yes. GitHub and customers can enter a Data Protection Agreement that supports compliance with the GDPR and similar legislation.\n\n\n\nEnterprise

      
        
        
      

      
          Advanced Security
          Premium Support
      

    


  


  Get 24/7 support for your business with GitHub Premium Support

  
    
      
        
          
            
          
          Protect your business and manage IT health with a comprehensive support plan.
        

        
          
            
          
          Drive operational efficiency and boost uptime with dedicated GitHub experts.
        

        
          
            
          
          Empower your team and meet your goals with the resources to maximize your investment.
        

        
          
            
          
          
  Get a quote
  
  


          
            Looking for general support questions? Contact GitHub Support.
          
        
      
    

    
      
        
        
        
          
          
        
        
  
  
  

      
    
  

  
      
      
      
      
      
      
      
  


  
  Already an existing customer?

  
    
      
        
        Upgrade to GitHub Premium Support to drive impact quickly.
        
            
              
              Experience faster responses 24/7 to maximize your uptime
            
            
              
              Receive expert support in one central location
            
            
              
              Get a dedicated engineer who knows your account
            
        
        
          
  Discover all features
  
  

        
      
    

    
      
        
        Get GitHub Premium Support with your Microsoft Unified Support plan.
        
            
              
              Provide your team with convenient, self-service tools
            
            
              
              Ensure the reliability of your environment
            
            
              
              Accelerate your goals with best-in-class support
            
        
        
          
  Check your benefits
  
  

        
      
    

    
      
        
          
            
              Not a GitHub Enterprise customer yet?
              Learn more about GitHub Premium Support and GitHub Premium Plus Support to discover the plan that’s right for you.
              
                
  Get a quote
  
  


              
            
          
          
            
              
  
  
  

            
          
        
        
      
    
  


  

  Why choose GitHub Premium Support?
  
    
      
      
        “
          
            At TSIA, we're seeing technology leaders take an active role in helping their customers adopt new technologies. GitHub is demonstrating a thoughtful, deliberate approach to creating compelling service offerings.
            
            
              With three tiers of service options, GitHub Premium Support provides customers with smart services at the right time to drive business goals, while simplifying customer choice and allowing for service expansion as needed.
            
          
        
          Hal Stanley // VP Service Offer Management Research & Advisory, TSIA
          
            
          
        
      
    
  


  
  
    
      Discover the plan that’s right for you
      Use the dropdown filters to reflect your organization’s properties.
    
    
        
    
            Product

          

            GHES

            GHEC/GHES dual use + GHAS

            GHEC




        
    
            License seats

          

            < 1000

            < 2000

            >= 2000

            < 6000

            >= 6000




        
    
            Complexity

          

            Standard

            High




    

    
        
          
            
            Enterprise

            
                    
                      24/5
                      Support
                    
                    
                      < 8 hours
                      Initial response for urgent requests
                    
                    
                      < 8 hours
                      Initial response for high requests
                    
                    
                      —
                       
                    
                    
                      —
                       
                    
                    
                      —
                       
                    
                    
                      —
                       
                    
                    
                      —
                       
                    
            

              
                  
                    Already included with your Enterprise license:
                  
                  
                      Support via online ticket submission
                      Expert guidance from a shared support team
                  
              

        
        
          
            
            Premium

            
                    
                      24/7
                      Support
                    
                    
                      30 min
                      Initial response for urgent requests
                    
                    
                      4 hours
                      Initial response for high requests
                    
                    
                      48 hours
                      Initial response for normal requests
                    
                    
                      48 hours
                      Initial response for low requests
                    
                    
                      20
                      Support entitlements
                    
                    
                      —
                       
                    
                    
                      —
                       
                    
            

              
                  
                    Get everything in the Enterprise support plan, along with:
                  
                  
                      Phone support in English via callback request
                      Screenshare support for critical issues
                      Guaranteed service level agreements (SLAs)
                      20 support entitlement licenses
                      Priority ticket handling
                      Escalation management
                      Unlimited automated health check reports
                      Access to premium training content
                  
              

              
                
  Get a quote
  
  


              
        
        
          
            
            Premium Plus

            
                    
                      24/7
                      Support
                    
                    
                      30 min
                      Initial response for urgent requests
                    
                    
                      4 hours
                      Initial response for high requests
                    
                    
                      24 hours
                      Initial response for normal requests
                    
                    
                      48 hours
                      Initial response for low requests
                    
                    
                      40
                      Support entitlements
                    
                    
                      Named CRE
                      Per account
                    
                    
                      1 training
                      Per year
                    
            

              
                  
                    Get everything in Premium support plan, along with:
                  
                  
                      Additional 20 support entitlement licenses
                      Designated Customer Reliability Engineer (CRE)
                      Incident management
                      Quarterly enhanced health checks with findings, interpretations, and recommendations from a CRE (by request)
                      Crisis prevention: Guided incident simulations that help you prepare for — and experience — an incident without risk (available for GitHub Enterprise Server)
                      1 virtual training class per year
                      12 hours of technical advisory hours per quarter
                      Application upgrade assistance (by request)
                      Cloud planning (by request)
                  
              

              
                
  Get a quote
  
  


              
        
    
  
  
  
    
    Compare all features
  

  
    
      
        
          Features on Premium
        
        Switch plans
      
    
    
      
        
          Select a plan to review its features
        
        
          Enterprise
          Premium
          Premium Plus
        
      
    
  

  
    
      
        
          Features
        
          
            Enterprise
          
          
            Premium
          
          
            Premium Plus
          
      
      
        
          How to get started?
        
            
              Already included with your Enterprise license
            
            
              
                  
  Get a quote
  
  


              
            
            
              
                  
  Get a quote
  
  


              
            
      
    

    
          
      
          
            
  
    
      
        Plan coverage
      
    
  
  
    
        Included with Enterprise Cloud and Enterprise Server
    
    
        Available for Enterprise Cloud and Enterprise Server
    
    
        Available for Enterprise Cloud and Enterprise Server
    
  


          
      

      
        
            Included with Enterprise Cloud and Enterprise Server
        
      

      
        
            Available for Enterprise Cloud and Enterprise Server
        
      

      
        
            Available for Enterprise Cloud and Enterprise Server
        
      
    
    
      
          
            
  
    
      
        Support hours
      
    
  
  
    
        24/5
    
    
        24/7
    
    
        24/7
    
  


          
      

      
        
            24/5
        
      

      
        
            24/7
        
      

      
        
            24/7
        
      
    
    
      
          
            
  
    
      
        Initial response time
      
    
  
  
    
        < 8 hours
    
    
        30 minutes for Urgent (including initial troubleshooting)
4 hours for High
48 hours for Normal
48 hours for Low
    
    
        30 minutes for Urgent (including initial troubleshooting)
4 hours for High
24 hours for Normal
48 hours for Low
    
  


          
      

      
        
            < 8 hours
        
      

      
        
            30 minutes for Urgent (including initial troubleshooting)
4 hours for High
48 hours for Normal
48 hours for Low
        
      

      
        
            30 minutes for Urgent (including initial troubleshooting)
4 hours for High
24 hours for Normal
48 hours for Low
        
      
    
    
      
          
            
              
              
  
    
      
        Training
      
    
  
  
    
        n/a
    
    
        Access to premium content
    
    
        Access to premium content
1 virtual training class per year
    
  


            
            
              One virtual training class is offered per year, with topics such as “GitHub for developers” and “GitHub for admins”.
          
      

      
        
            n/a
        
      

      
        
            Access to premium content
        
      

      
        
            Access to premium content
1 virtual training class per year
        
      
    
    
      
          
            
              
              
  
    
      
        Members with support entitlements
      
    
  
  
    
        n/a
    
    
        20
    
    
        40
    
  


            
            
              These members determine if incoming inquiries can be addressed via their company’s admin or only by GitHub.
          
      

      
        
            n/a
        
      

      
        
            20
        
      

      
        
            40
        
      
    
    
      
          
            
  
    
      
        Dedicated resources
      
    
  
  
    
        n/a
    
    
        Priority ticket handling
    
    
        Priority ticket handling + named Customer Reliability Engineer
    
  


          
      

      
        
            n/a
        
      

      
        
            Priority ticket handling
        
      

      
        
            Priority ticket handling + named Customer Reliability Engineer
        
      
    
    
      
          
            
  
    
      
        Escalation management
      
    
  
  
    
        n/a
    
    
        For High and Urgent priority tickets
    
    
        For High and Urgent priority tickets
    
  


          
      

      
        
            n/a
        
      

      
        
            For High and Urgent priority tickets
        
      

      
        
            For High and Urgent priority tickets
        
      
    
    
      
          
            
              
              
  
    
      
        Incident management
      
    
  
  
    
        n/a
    
    
        n/a
    
    
        For Urgent priority tickets, as needed
    
  


            
            
              Ensures you have the technical resources needed for case resolution, and is available 24/7.
          
      

      
        
            n/a
        
      

      
        
            n/a
        
      

      
        
            For Urgent priority tickets, as needed
        
      
    
    
      
          
            
  
    
      
        Health Checks
      
    
  
  
    
        n/a
    
    
        Unlimited automated Health Check reports (see “Generating a Health Check for your enterprise”)
    
    
        Unlimited automated Health Check reports (see “Generating a Health Check for your enterprise”)
Quarterly enhanced health checks with findings, interpretations, and recommendations from a CRE (by request)
    
  


          
      

      
        
            n/a
        
      

      
        
            Unlimited automated Health Check reports (see “Generating a Health Check for your enterprise”)
        
      

      
        
            Unlimited automated Health Check reports (see “Generating a Health Check for your enterprise”)
Quarterly enhanced health checks with findings, interpretations, and recommendations from a CRE (by request)
        
      
    
    
      
          
            
  
    
      
        Crisis Prevention
      
    
  
  
    
        n/a
    
    
        n/a
    
    
        Up to four sessions about reliability best practices, preparing for a potential incident, and efficiently interacting with GitHub Support.
    
  


          
      

      
        
            n/a
        
      

      
        
            n/a
        
      

      
        
            Up to four sessions about reliability best practices, preparing for a potential incident, and efficiently interacting with GitHub Support.
        
      
    
    
      
          
            
              
              
  
    
      
        Technical advisory hours
      
    
  
  
    
        n/a
    
    
        n/a
    
    
        12 hours per quarter
    
  


            
            
              Hours can be scheduled at your discretion. You can use them for technical tasks, such as prepping for a GitHub Enterprise Server upgrade.
          
      

      
        
            n/a
        
      

      
        
            n/a
        
      

      
        
            12 hours per quarter
        
      
    
    
      
          
            
              
              
  
    
      
        Application upgrade assistance
      
    
  
  
    
        n/a
    
    
        n/a
    
    
        By request
    
  


            
            
              Delivered upon request via our Customer Reliability Engineers.
          
      

      
        
            n/a
        
      

      
        
            n/a
        
      

      
        
            By request
        
      
    
    
      
          
            
              
              
  
    
      
        Cloud planning
      
    
  
  
    
        n/a
    
    
        n/a
    
    
        By request
    
  


            
            
              Delivered upon request via our Customer Reliability Engineers.
          
      

      
        
            n/a
        
      

      
        
            n/a
        
      

      
        
            By request
        
      
    

    
  




  
  See what customers are saying about GitHub Premium Support

  
    
    
        
          “
          Our support engineer was very helpful in pointing me to the exact resource I needed in minutes.
          
            
          
        
        
          “
          The support agent took care of the request with a great sense of urgency and addressed the issue well.
          
            
          
        
        
          “
          I'd like to applaud our engineer for how he exceptionally responded to our query. This ticket was not a simple, one-answer investigation and I was very happy with how he explored multiple angles to investigate.
          
            
          
        
        
          “
          Our engineer was super helpful and spot on with figuring out the problem. The steps he suggested helped me figure out the problem quickly. Kudos!
          
            
          
        
    
  


  
  Meet your dedicated GitHub Premium Support team

  
      
        
  
  
  

        Premium Support Engineers
        Premium Support Engineers, available only for GitHub Premium Support customers, are dedicated resources who manage and coordinate your entire GitHub Premium Support experience.
      
      
        
  
  
  

        Support Incident Coordinators
        Support Incident Coordinators are responsible for any major incident management, from initiation until resolution, and are available to you 24/7.
      
      
        
  
  
  

        Customer Reliability Engineers (CREs)
        Customer Reliability Engineers (CREs), available only for GitHub Premium Plus Support customers, know your customer account in detail and can provide answers faster than Premium Support Engineers.
      
  



  
    
  
  
    Frequently asked questions


          About GitHub Premium Support


    
  
    
      
      
        What is GitHub Premium Support for?
      
    
    
      GitHub Premium Support helps customers implement GitHub Enterprise quickly and effectively across the organization with 24/7 support.
      
    
  


    
  
    
      
      
        How much does GitHub Premium Support cost?
      
    
    
      For pricing information, please get in touch with the GitHub Premium Support Sales sales team.
      
    
  


    
  
    
      
      
        What are the levels of support in GitHub Premium Support?
      
    
    
      There are three levels of support:

The basic plan included with your GitHub Enterprise license
GitHub Premium Support
GitHub Premium Plus Support

Please refer to our plan comparison table for more details.
      
    
  


    
  
    
      
      
        How do I contact GitHub Premium Support?
      
    
    
      If you are an existing GitHub Premium Support customer, please sign in to our support portal. If you don’t already have GitHub Premium Support, please contact sales.
      
    
  



          Choosing your plan


    
  
    
      
      
        What is escalation and incident management?
      
    
    
      Escalation and incident management is the ability to escalate ticket progression in the GitHub support portal. After someone escalates a ticket, Support Incident Coordinators orchestrate all necessary parties to resolve the ticket. Additionally, Senior Escalation Engineers (SEEs) facilitate GitHub-internal technical communications and liaise with the rest of GitHub to improve the support team’s capability in similar future circumstances.
      
    
  


    
  
    
      
      
        What is incident response management?
      
    
    
      Incident response management helps manage the technical resources needed for case resolution. Support Incident Coordinators are available for incident response management 24/7.
      
    
  


    
  
    
      
      
        What are my SLAs for initial response?
      
    
    
      GitHub Premium Support and GitHub Premium Plus Support customers have SLAs. For urgent priority tickets, your SLA guarantees a 30-minute initial response time, which includes troubleshooting. For high priority tickets, your SLA provides a four-hour initial response time.
      
    
  


    
  
    
      
      
        What’s included in initial troubleshooting?
      
    
    
      For initial troubleshooting, the assigned Premium Support Engineer/Customer Reliability Engineer will review and acknowledge your ticket. To better understand the issue and start troubleshooting, the engineer may ask for additional information such as screenshots, error messages, log files, diagnostics files, support bundles, or the output of specific console commands. They may also collaborate with others in support, engineering, or in the regional incident commander.
If a callback was requested, the engineer will determine if screen sharing is the most effective way to drive ticket resolution. If so, they will invite you to join a screen-sharing session.
      
    
  


    
  
    
      
      
        How do I get health check reports?
      
    
    
      GitHub Premium Support and GitHub Premium Plus Support customers are entitled to unlimited automated health check reports. Additionally, GitHub Premium Plus Support customers can request quarterly enhanced health checks with findings, interpretations, and recommendations from a Customer Reliability Engineer (CRE).
      
    
  


    
  
    
      
      
        What is crisis prevention?
      
    
    
      Crisis prevention allows GitHub Enterprise Server customers to prepare for — and experience — an incident without risk. Your Customer Reliability Engineer (CRE) guides your team through an incident simulation in a safe and controlled environment.
Crisis Prevention consists of up to four sessions about reliability best practices, preparing for a potential incident, and efficiently interacting with GitHub Support. After the incident simulation, your CRE will run a detailed retrospective, uncovering lessons learned and improvement suggestions for the future.
      
    
  


    
  
    
      
      
        How long does GitHub Premium Support take?
      
    
    
      GitHub Premium Support and GitHub Premium Plus Support Plus customers have service-level agreements (SLAs) for initial response. For urgent priority tickets, the initial response SLA guarantees a 30-minute initial response time, which includes troubleshooting. For high-priority tickets, the initial response SLA provides a four-hour time.
We currently do not provide estimates for time to resolution, as the complexity of tickets varies. However, we review these metrics on a regular basis and reduce times whenever possible.
      
    
  


    
  
    
      
      
        How do I resolve a problem in GitHub Enterprise?
      
    
    
      You can get support via online ticket submission if you’re using the basic plan included with your GitHub Enterprise license. If you have GitHub Premium Support or GitHub Premium Plus Support, you can submit a ticket online. For urgent tickets, GitHub Premium Support and GitHub Premium Plus Support customers can request a callback and have a screen-sharing session with one of our Premium Support Engineers or Customer Reliability Engineers (CREs). Please refer to our plan comparison table for more details.
      
    
  



          Rules and policies


    
  
    
      
      
        If I do not use all the technical advisory hours in a given quarter, can they be carried over?
      
    
    
      Premium Plus customers may use up to 12 technical advisory hours per quarter. Unused technical advisory hours may not be carried over into the next quarter.
      
    
  


    
  
    
      
      
        How can the technical advisory support hours be used? 
      
    
    
      There are multiple ways you can use technical advisory hours, including but not limited to:

Consultations regarding GitHub best practices and general recommendations
GitHub Enterprise Server upgrade preparation and assistance

      
    
  


    
  
    
      
      
        Does GitHub Premium Support provide service on weekends?
      
    
    
      Yes! GitHub Premium Support and GitHub Premium Plus Support customers receive 24/7 support.
      
    
  



          Upgrading your plan


    
  
    
      
      
        What virtual trainings are available with GitHub Premium Plus Support and who can participate?
      
    
    
      Customers get access to one virtual training class per year. Topics include:

GitHub for developers
GitHub for admins (Server)
GitHub for admins (Cloud)
GitHub for non-developers
GH API Training
GH Actions Fundamentals
GH Actions Intermediate
GH Copilot Fundamentals
GH Copilot Intermediate
GH Copilot Administration & Security
GitHub Enterprise Implementation (Cloud)

We recommend limiting training sessions to a maximum of 16 participants to ensure an optimal provider-to-participant ratio and a high-quality delivery experience. However, in specific cases where it makes sense, we can accommodate up to 20–25 participants while maintaining our commitment to delivering a valuable training experience for your team.
      
    
  


    
  
    
      
      
        What value will I get by upgrading to GitHub Premium Plus Support?
      
    
    
      GitHub Premium Plus Support customers get an assigned Customer Reliability Engineer (CRE), quarterly enhanced health checks, access to crisis prevention, technical advisory hours, and many additional benefits, which you can review in our plan comparison table.
      
    
  


    
  
    
      
      
        What’s the benefit of having a Customer Reliability Engineer (CRE) over a Premium Support Engineer?
      
    
    
      A CRE knows your customer account in detail and can help you expedite case resolution faster than a Premium Support Engineer.
      
    
  


    
  
    
      
      
        Since I get GitHub Enterprise Support for free, why should I upgrade to GitHub Premium Support?
      
    
    
      Most customers upgrade to GitHub Premium Support because they need initial response SLAs for urgent and high priority requests, phone support, screen share support for critical issues, and health checks. To see a full list of features for GitHub Premium Support packages, please refer to our plan comparison table.
      
    
  




  


  



    
  
    
      Ready to maximize your investment?
      Get in touch with a GitHub Premium Support specialist today.
      Click below to fill out the form, and our management team will contact you within 48 hours.
      
  Get a quote\n\n\n\nTry the Copilot-powered platform

  
  
    We get it, there's a lot you can do with GitHub.
    That’s why we've packed all of it into a single risk-free trial that includes GitHub Enterprise, Copilot,
    and Advanced Security.
  

    Start free for 30 days
  




  
    




  

  
    
      
        Free
        The basics for individuals and organizations
          
    
      
        
            $
            0
            USD
        
        
          per month
        
      
    
  

  
    
      
        
          
              $
              0
              USD
          
        
        
          
            per month
          
          
              forever
          
        
      
    
  






        
            
  Join for free
  
  

        
      

        
  
    
          
  
    
      
        
          
        

        
          
            Unlimited public/private repositories
          

          
        
      
    

    
      
        Host open source projects in public GitHub repositories, accessible via web or command line. Public repositories are accessible to anyone at GitHub.com.
      


    
  
    
      
        
          
        

        
          
            Dependabot security and version updates
          

          
        
      
    

    
      
        Keep projects secure by automatically opening pull requests to update vulnerable dependencies and keep them up to date.
      


    
  
    
      
        
          
        

        
          
            2,000 CI/CD minutes/month
          

          Free for public repositories
        
      
    

    
      
        Use execution minutes with GitHub Actions to automate your software development workflows. Write tasks and combine them to build, test, and deploy any code project on GitHub.
      


    
  
    
      
        
          
        

        
          
            500MB of Packages storage
          

          Free for public repositories
        
      
    

    
      
        Host your own software packages or use them as dependencies in other projects. Both private and public hosting available.
      


    
  
    
      
        
          
        

        
          
            Issues & Projects
          

          
        
      
    

    
      
        Give your developers flexible features for project management that adapts to any team, project, and workflow — all alongside your code.
      


    
  
    
      
        
          
        

        
          
            Community support
          

          
        
      
    

    
      
        Get help with most of your GitHub questions and issues in our Community Forum.
      



    

    
      Featured add-ons
    

    
          
  
    
      
        
          
        

        
          
            GitHub Copilot Access
          

          
        
      
    

    
      
        With GitHub Copilot, get suggestions for whole lines or entire functions—right inside your editor.
      


    
  
    
      
        
          
        

        
          
            GitHub Codespaces Access
          

          
        
      
    

    
      
        With GitHub Codespaces, get an instant dev environment in the cloud, so you can code anywhere on any device.
      



    
  
  Show features


    
  



    


  
    Most popular
    
      
        Team
        Advanced collaboration for individuals and organizations
          
    
      
        
            $
            4
            USD
        
        
          per user/month
        
      
    
  

  
    
      
        
          
              $
              4
              USD
          
        
        
          
            per user/month
          
          
              for the first 12 months*
          
        
      
    
  






        
            
  Continue with Team
  
  

        
      

        
  
    
      
        
          
        
        Everything included in Free, plus...
      

          
  
    
      
        
          
        

        
          
            Access to GitHub Codespaces
          

          
        
      
    

    
      
        Blazing fast cloud developer environments with flexible compute and pre-configured containers, developers can code, collaborate, and debug from any browser. Pay only for what you use with compute fees starting at $0.18/hr and storage fees at $0.07/GB per month.
      


    
  
    
      
        
          
        

        
          
            Protected branches
          

          
        
      
    

    
      
        Enforce restrictions on how code branches are merged, including requiring reviews by selected collaborators, or allowing only specific contributors to work on a particular branch.
      


    
  
    
      
        
          
        

        
          
            Multiple reviewers in pull requests
          

          
        
      
    

    
      
        Assign multiple users or a team to review a pull request.
      


    
  
    
      
        
          
        

        
          
            Draft pull requests
          

          
        
      
    

    
      
        Easily discuss and collaborate on pull requests before submitting to formal review.
      


    
  
    
      
        
          
        

        
          
            Code owners
          

          
        
      
    

    
      
        Automatically request reviews—or require approval—by selected contributors when changes are made to sections of code that they own.
      


    
  
    
      
        
          
        

        
          
            Required reviewers
          

          
        
      
    

    
      
        Ensure that pull requests have a specific number of approving reviews before collaborators can make changes to a protected branch.
      


    
  
    
      
        
          
        

        
          
            Pages and Wikis
          

          
        
      
    

    
      
        Host documentation and simple websites for your project in a wiki format that contributors can easily edit either on the web or command line.
      


    
  
    
      
        
          
        

        
          
            Environment deployment branches and secrets
          

          
        
      
    

    
      
        A job cannot access secrets that are defined in an environment unless it is running on the specified branch.
      


    
  
    
      
        
          
        

        
          
            3,000 CI/CD minutes/month
          

          Free for public repositories
        
      
    

    
      
        Use execution minutes with GitHub Actions to automate your software development workflows. Write tasks and combine them to build, test, and deploy any code project on GitHub.
      


    
  
    
      
        
          
        

        
          
            2GB of Packages storage
          

          Free for public repositories
        
      
    

    
      
        Host your own software packages or use them as dependencies in other projects. Both private and public hosting available.
      


    
  
    
      
        
          
        

        
          
            Web-based support
          

          
        
      
    

    
      
        GitHub Support can help you troubleshoot issues you run into while using GitHub.
      



    

    
      Featured add-ons
    

    
          
  
    
      
        
          
        

        
          
            GitHub Secret Protection
          

          
        
      
    

    
      
        Ensure your secrets stay secure. Mitigate risk associated with exposed secrets in your repositories, while preventing new leaks before they happen with push protection.
      


    
  
    
      
        
          
        

        
          
            GitHub Code Security
          

          
        
      
    

    
      
        Find and fix vulnerabilities in your code before they reach production. Prioritize your Dependabot alerts with automated triage rules.
      



    
  
  Show features


    
  



      

  
    Recommended
    
      
        Enterprise
        Security, compliance, and flexible deployment
        Starting at
          
    
      
        
            $
            21
            USD
        
        
          per user/month
        
      
    
  

  
    
      
        
          
              $
              21
              USD
          
        
        
          
            per user/month
          
          
              for the first 12 months*
          
        
      
    
  






        
          
                
                  
                        Start a free trial

                  
                  
                    
                      Contact Sales
                    
                  
                
          
        
      

        
  
    
      
        
          
        
        Everything included in Team, plus...
      


          
  
    
      
        
          
        

        
          
            Data residency
          

          
        
      
    

    
      
        GitHub Enterprise Cloud offers a multi-tenant enterprise SaaS solution on Microsoft Azure, allowing you to choose a regional cloud deployment for data residency, so your in-scope data is stored at rest in a designated location. This is available in the EU and Australia with additional regions coming soon. Contact our sales team to learn more.
      


    
  
    
      
        
          
        

        
          
            Enterprise Managed Users
          

          
        
      
    

    
      
        Own and control the user accounts of your enterprise members through your identity provider (IdP).
      


    
  
    
      
        
          
        

        
          
            User provisioning through SCIM
          

          
        
      
    

    
      
        Automatically invite members to join your organization when you grant access on your IdP. If you remove a member's access to your GitHub organization on your SAML IdP, the member will be automatically removed from the GitHub organization.
      


    
  
    
      
        
          
        

        
          
            Enterprise Account to centrally manage multiple organizations
          

          
        
      
    

    
      
        GitHub Enterprise Cloud includes the option to create an enterprise account, which enables collaboration between multiple organizations, gives administrators a single point of visibility and management and brings license cost savings for identical users in multiple organizations.
      


    
  
    
      
        
          
        

        
          
            Environment protection rules
          

          
        
      
    

    
      
        When a workflow job references an environment, the job won't start until all of the environment's protection rules pass.
      


    
  
    
      
        
          
        

        
          
            Repository rules
          

          
        
      
    

    
      
        Enforce branch and tag restrictions across your organization, ensuring branch and tag protection across your repositories. Evaluate rules to asses impact before enforcement.
      


    
  
    
      
        
          
        

        
          
            Audit Log API
          

          
        
      
    

    
      
        As a GitHub Enterprise Cloud organization administrator, you can now access log events using our GraphQL API and monitor the activity in your organization.
      


    
  
    
      
        
          
        

        
          
            SOC1, SOC2, type 2 reports annually
          

          
        
      
    

    
      
        GitHub offers AICPA System and Organization Controls (SOC) 1 Type 2 and SOC 2 Type 2 reports with IAASB International Standards on Assurance Engagements, ISAE 3000, and ISAE 3402.
      


    
  
    
      
        
          
        

        
          
            FedRAMP Tailored Authority to Operate (ATO)
          

          
        
      
    

    
      
        Government users can host projects on GitHub Enterprise Cloud with the confidence that our platform meets the low impact software-as-a-service (SaaS) baseline of security standards set by our U.S. federal government partners.
      


    
  
    
      
        
          
        

        
          
            SAML single sign-on
          

          
        
      
    

    
      
        Use an identity provider to manage the identities of GitHub users and applications.
      


    
  
    
      
        
          
        

        
          
            Advanced auditing
          

          
        
      
    

    
      
        Quickly review the actions performed by members of your organization. Keep copies of audit log data to ensure secure IP and maintain compliance for your organization.
      


    
  
    
      
        
          
        

        
          
            GitHub Connect
          

          
        
      
    

    
      
        Share features and workflows between your GitHub Enterprise Server instance and GitHub Enterprise Cloud.
      


    
  
    
      
        
          
        

        
          
            50,000 CI/CD minutes/month
          

          Free for public repositories
        
      
    

    
      
        Use execution minutes with GitHub Actions to automate your software development workflows. Write tasks and combine them to build, test, and deploy any code project on GitHub.
      


    
  
    
      
        
          
        

        
          
            50GB of Packages storage
          

          Free for public repositories
        
      
    

    
      
        Host your own software packages or use them as dependencies in other projects. Both private and public hosting available.
      



    

    
      Exclusive add-on
    
    
          
  
    
      
        
          
        

        
          
            Premium support
          

          
        
      
    

    
      
        With Premium, get a 30-minute SLA on Urgent tickets and 24/7 web and phone support via callback request. With Premium Plus, get everything in Premium, assigned Customer Reliability Engineer and more. Learn more about Premium Support
      
    



    
  
  Show features


    
  





    
  
    Additional add-ons
  

  
  
        
    
        
            
              
            

          
        

      GitHub Copilot

      
        Get started for free with up to 2,000 completions and 50 chat requests per month.
      

      
        Compare plans 

      

        
    
        
            
              
            

          
        

      GitHub Codespaces

      
        Starting at $0.18 per hour of compute and $0.07 per GB of storage.
      

      
        Learn more 

      

        
    
        
            
              
            

          
        

      Git Large File Storage

      
        $5 per month for 50 GB bandwidth and 50 GB of storage.
      

      
        Learn more 

      

        
    
        
            
              
            

          
        

      GitHub Advanced Security

      
        Secret Protection $19 per committer/ per month. Code Security $30 per committer/ per month
      

      
        Learn more 

      






    
      
        Compare all features
        
      
    
  




  
      
        
            
              
                
              
            
            
              
                
              
            
            
              
                
              
            
            
              
                
              
            
            
              
                
              
            
            
              
                
              
            
            
              
                
              
            
            
              
                
              
            
        

        
          
            
                
  
  
  

                
  
  
  

                
  
  
  

                
  
  
  

                
  
  
  

                
  
  
  

                
  
  
  

                
  
  
  

            
          

          
              
                
                  “GitHub is the world’s mono repository, so sharing our open source there is natural.”
                
                — Martin Andersen, VP of Engineering, Trustpilot
                  
    Read the case study 


              
              
                
                  “GitHub Advanced Security is there for every pull request and excels compared to other static analysis tools we have used.”
                
                — Dimosthenis Kaponis, CTO, Netdata
                  
    Read the case study 


              
              
                
                  “GitHub keeps us up to speed with the industry’s best tools. We want new hires to know GitHub is in our toolchain—it makes them excited to join us.”
                
                — Spencer Kaiser, Principal Architect of Emerging Tech, American Airlines
                  
    Read the case study 


              
              
                
                  “This collaborative way of building software is unstoppable. It isn’t going away—and GitHub has its place in that. We can make the whole company rethink how they build software.”
                
                — Ingo Sauerzapf, SAP Cloud Development Tools Manager
                  
    Read the case study 


              
              
                
                  “People know what a pull request is because it’s how they contribute to open source projects. We have many developers who are well-versed with GitHub, either for personal development or previous roles. With GitHub Enterprise, no one has to relearn the wheel.”
                
                — Laurent Ploix, Product Manager, Spotify
                  
    Read the case study 


              
              
                
                  “I have seen some truly revolutionary actions happen in communities on GitHub. People are collaborating on code but they’re also having foundational conversations on best practices and how software, as a whole, is built. More and more, GitHub is an internet archive. It’s a deeply social and critical piece of our infrastructure.”
                
                — Michael Glukhovsky, Developer, Stripe
                  
    Read the case study 


              
              
                
                  “When we started talking about code reuse, we felt like we already had the perfect platform in place: GitHub.”
                
                — Timothy Carmean, Software Processes and Tools Supervisor, Ford
                  
    Read the case study 


              
              
                
                  “Using GitHub Enterprise Cloud removes the burden of managing infrastructure, and we don’t need to worry about the availability of our versioning code, source code and versioning tools. It lets us focus on what’s important for our business, and that’s our customers.”
                
                — Victor Gomes, Infosec Tech Manager, Nubank
                  
    Read the case study 


              
          
        
      
  



  
    Compare features
  







  
    
      
        
          Features on team
        
        Switch plans
      
    
    
      
        
          Select a plan to review its features
        
        
          Free
            Team
              Enterprise
        
      
    
  

  
    
      
        
          
            
              Features
            
          

          
            
              Free
            
          


            
              
                Team
              
            

              
                
                  Enterprise
                
              
        
      

      
        
          
            
              Pricing
            
          

          
            
              
                
  
    
      
        $0
        USD
      
      
        per month
      
    

    
      
        $0
        USD
      
      
        per month
          forever
      
    
  



              
            
          


            
              
                
                  
  
    
      
        $4
        USD
      
      
        per user/month
      
    

    
      
        $4
        USD
      
      
        per user/month
          for the first 12 months*
      
    
  



                
              
            

              
                
                  
                    
  
    
      
        $21
        USD
      
      
        per user/month
      
    

    
      
        $21
        USD
      
      
        per user/month
          for the first 12 months*
      
    
  



                  
                
              
        
      

      
        
          
            
              How to get started
            
          

          
            
                  Join for free

            
          


            
              
                    Continue with Team

              
            

              
                
                        Start a free trial

                        
      Contact Sales
    

                
              
        
      
    

    
      

  
    Code management
  

  
    
  

  
    
  

    
      
    


          
  
    
      
        
          
            
              
            
            
              
                Public repositories
              
            
          
          
            
              Unlimited
              
            
              
                Unlimited
                
              
                
                  Unlimited
                  
                
          
        
      
      
        Host open source projects in public GitHub repositories, accessible via web or command line. Public repositories are accessible to anyone at GitHub.com.
  

  
    
      Unlimited
      
    
  

    
      
        Unlimited
        
      
    

      
        
          Unlimited
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Private repositories
              
            
          
          
            
              Unlimited
              
            
              
                Unlimited
                
              
                
                  Unlimited
                  
                
          
        
      
      
        Host code in private GitHub repositories, accessible via appliance, web, and command line. Private repositories are only accessible to you and people you share them with.
  

  
    
      Unlimited
      
    
  

    
      
        Unlimited
        
      
    

      
        
          Unlimited
          
        
      



    

    
      

  
    Code workflow
  

  
    
  

  
    
  

    
      
    


          
  
    
      
        
          
            
              
            
            
              
                GitHub Codespaces
              
            
          
          
            
              $0 spend limitWith policies and controls
              
            
              
                Ability to increase spend limit
                
              
                
                  Ability to increase spend limit
                  
                
          
        
      
      
        Spin up fully configured dev environments in the cloud with the power of your favorite editor. A "core hour" denotes compute usage. On a 2-core machine, you would get 60 hours free. On a 4-core machine, you would get 30 hours free, etc. Free hours are assigned to personal accounts, rather than free organizations.
  

  
    
      $0 spend limitWith policies and controls
      
    
  

    
      
        Ability to increase spend limit
        
      
    

      
        
          Ability to increase spend limit
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                GitHub Actions
              
            
          
          
            
              2,000 minutes/month
              Free for public repositories
            
              
                3,000 minutes/month
                Free for public repositories
              
                
                  50,000 minutes/month
                  Free for public repositories
                
          
        
      
      
        Use execution minutes with GitHub Actions to automate your software development workflows. Write tasks and combine them to build, test, and deploy any code project on GitHub. Minutes are free for public repositories.Learn more about billing
  

  
    
      2,000 minutes/month
      Free for public repositories
    
  

    
      
        3,000 minutes/month
        Free for public repositories
      
    

      
        
          50,000 minutes/month
          Free for public repositories
        
      


    
  
    
      
        
          
            
              
            
            
              
                GitHub Packages
              
            
          
          
            
              500 MB
              Free for public repositories
            
              
                2GB
                Free for public repositories
              
                
                  50GB
                  Free for public repositories
                
          
        
      
      
        Host your own software packages or use them as dependencies in other projects. Both private and public hosting available. Packages are free for public repositories.
  

  
    
      500 MB
      Free for public repositories
    
  

    
      
        2GB
        Free for public repositories
      
    

      
        
          50GB
          Free for public repositories
        
      


    
  
    
      
        
          
            
              
            
            
              
                Code reviews
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Review new code, see visual code changes, and confidently merge code changes with automated status checks.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Pull requests
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Allow contributors to easily notify you of changes they've pushed to a repository – with access limited to the contributors you specify. Easily merge changes you accept.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Protected branches
              
            
          
          
            
              Public repositories
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Enforce restrictions on how code branches are merged, including requiring reviews by selected collaborators, or allowing only specific contributors to work on a particular branch.
  

  
    
      Public repositories
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Code owners
              
            
          
          
            
              Public repositories
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Automatically request reviews – or require approval – by selected contributors when changes are made to sections of code that they own.
  

  
    
      Public repositories
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Draft pull requests
              
            
          
          
            
              Public repositories
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Easily discuss and collaborate on pull requests before submitting to formal review.
  

  
    
      Public repositories
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Multiple pull request assignees
              
            
          
          
            
              Public repositories
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Assign more than one person to a pull request.
  

  
    
      Public repositories
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Repository insights
              
            
          
          
            
              Public repositories
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        See data about activity and contributions within your repositories, including trends. You can use this data to improve collaboration and make development faster and more effective.
  

  
    
      Public repositories
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Scheduled reminders
              
            
          
          
            
              Public repositories
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Send scheduled messages to you or your team listing open pull requests.
  

  
    
      Public repositories
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Automatic code review assignment
              
            
          
          
            
              Public repositories
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Automatically assign code reviews to members of your team based on one of two algorithms.
  

  
    
      Public repositories
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Environment protection rules
              
            
          
          
            
              Public repositories
              
            
              
                Public repositories
                
              
                
                  
                  
                
          
        
      
      
        When a workflow job references an environment, the job won't start until all of the environment's protection rules pass.
  

  
    
      Public repositories
      
    
  

    
      
        Public repositories
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Environment deployment branches and secrets
              
            
          
          
            
              Public repositories
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        A job cannot access secrets that are defined in an environment unless it is running on the specified branch.
  

  
    
      Public repositories
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      



    

    
      

  
    Collaboration
  

  
    
  

  
    
  

    
      
    


          
  
    
      
        
          
            
              
            
            
              
                Collaborators for public repositories
              
            
          
          
            
              Unlimited
              
            
              
                Unlimited
                
              
                
                  Unlimited
                  
                
          
        
      
      
        Invite any GitHub member, or all GitHub members, to work with you on code in a public repository you control – including making changes and opening issues.
  

  
    
      Unlimited
      
    
  

    
      
        Unlimited
        
      
    

      
        
          Unlimited
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Collaborators for private repositories
              
            
          
          
            
              Unlimited
              
            
              
                


  
    
      
        $4
      
      
        per user/month
      
    
  

                
              
                
                  


  
    
      
        $21
      
      
        per user/month
      
    
  

                  
                
          
        
      
      
        Invite any GitHub member, or all GitHub members, to work with you on code in a private repository you control – including making changes and opening issues.
  

  
    
      Unlimited
      
    
  

    
      
        


  
    
      
        $4
      
      
        per user/month
      
    
  

        
      
    

      
        
          


  
    
      
        $21
      
      
        per user/month
      
    
  

          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Issues
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Track bugs, enhancements, and other requests, prioritize work, and communicate with stakeholders as changes are proposed and merged.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Projects
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Visualize and manage issues and pull requests across tables, boards, and roadmaps with custom fields and views that you can arrange to suit your workflow.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Milestones
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Track progress on groups of issues or pull requests in a repository, and map groups to overall project goals.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Team discussions
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Discuss any topic, unattached to a specific project or issue. Control who has access, notify discussion participants with updates, and link from anywhere.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Organization and team management
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Manage access to projects on a team-by-team, or individual user, basis.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Pages and wikis
              
            
          
          
            
              Public repositories
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Host documentation and simple websites for your project in a wiki format that contributors can easily edit either on the web or command line.
  

  
    
      Public repositories
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Multiple issue assignees
              
            
          
          
            
              Public repositories
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Assign more than one person to an issue.
  

  
    
      Public repositories
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      




    

    
      

  
    GitHub Secret Protection
  

  
    
  

  
    
  

    
      
    


          
  
    
      
        
          
            
              
            
            
              
                Push protection
              
            
          
          
            
              Public repositories
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Prevent secret exposures by proactively blocking secrets before they reach your code.
  

  
    
      Public repositories
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Secret scanning
              
            
          
          
            
              Public repositories
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Detect and manage exposed secrets across git history, pull requests, issues, and wikis.
  

  
    
      Public repositories
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Provider patterns
              
            
          
          
            
              Public repositories
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        GitHub collaborates with AWS, Azure, and Google Cloud to detect secrets with high accuracy. This minimizes false positives, letting you focus on what matters.
  

  
    
      Public repositories
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Provider notification
              
            
          
          
            
              Public repositories
              
            
              
                Public repositories
                
              
                
                  Public repositories
                  
                
          
        
      
      
        Providers get real-time alerts when their tokens appear in public code, enabling them to notify, quarantine, or revoke secrets.
  

  
    
      Public repositories
      
    
  

    
      
        Public repositories
        
      
    

      
        
          Public repositories
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Validity checks
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Prioritize active secrets with validity checks for provider patterns.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Copilot secret scanning
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Use AI to detect unstructured like passwords—without the noise.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Generic patterns
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Detect tokens from unknown providers, including HTTP authentication headers, connection strings, and private keys.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Custom patterns
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Create your own patterns and find organization-specific secrets.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Push protection bypass controls
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Manage who can bypass push protection and when.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Insights in security overview
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Understand how risk is distributed across your organization with security metrics and insight dashboards.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Scan history API 
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Review how and when GitHub scans your repositories for secrets.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      



    

    
      

  
    Code Security
  

  
    
  

  
    
  

    
      
    


          
  
    
      
        
          
            
              
            
            
              
                Copilot Autofix
              
            
          
          
            
              Public repositories
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Powered by GitHub Copilot, generate automatic fixes for 90% of alert types in JavaScript, Typescript, Java, and Python.
  

  
    
      Public repositories
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Third party extensibility for code scanning alerts
              
            
          
          
            
              Public repositories
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Centralize your findings across all your scanning tools via SARIF upload to GitHub.
  

  
    
      Public repositories
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Contextual vulnerability intelligence and advice
              
            
          
          
            
              Public repositories
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Quickly remediate with context provided by Copilot Autofix.
  

  
    
      Public repositories
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                CodeQL
              
            
          
          
            
              Public repositories
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Uncover vulnerabilities in your code with our industry-leading semantic code analysis.
  

  
    
      Public repositories
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Security campaigns
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Reduce security debt and burn down your security backlog with security campaigns.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Dependency graph
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Get a clear view of your project’s dependencies with a summary of manifest, lock files, and submitted dependencies via the API.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Dependency review action
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Catch insecure dependencies before adding them and get insights on licenses, dependents, and age.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Dependabot custom auto-triage rules
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Define alert-centric policies to control how Dependabot handles alerts and pull requests.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Dependabot security updates with grouped updates
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Automated pull requests that batch dependency updates for known vulnerabilities.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Dependabot version updates
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Automated pull requests that keep your dependencies up to date.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Insights in security overview
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Get a clear view of risk distribution with security metrics and dashboards.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      



    

    
      

  
    Platform security and compliance
  

  
    
  

  
    
  

    
      
    


          
  
    
      
        
          
            
              
            
            
              
                Repository rulesets
              
            
          
          
            
              Public repositories
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Enforce consistent code standards, security, and compliance across branches and tags.
  

  
    
      Public repositories
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                SBOMs
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Export a software bill of materials (SBOM) for your repository.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Artifact attestations
              
            
          
          
            
              Public repositories
              
            
              
                Public repositories
                
              
                
                  
                  
                
          
        
      
      
        Ensure unfalsifiable provenance and integrity for your software.
  

  
    
      Public repositories
      
    
  

    
      
        Public repositories
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                GitHub Security Advisories
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Role-based access control
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Define users' level of access to your code, data and settings.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Required 2FA
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Use an extra layer of security with two factor authentication (2FA) when logging into GitHub.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Audit log
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Quickly review the actions performed by members of your organization.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      




            
  
    
      
        
          
            
              
            
            
              
                Audit log API
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Keep copies of audit log data to ensure secure IP and maintain compliance for your organization.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                GitHub Connect
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Share features and workflows between your GitHub Enterprise Server instance and GitHub Enterprise Cloud.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                SAML single sign-on (SSO)
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Use an identity provider to manage the identities of GitHub users and applications.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                LDAP
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Access GitHub Enterprise Server using your existing accounts and centrally manage repository access.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                IP allow list
              
            
          
          
            
              
              
            
              
                
                
              
                
                  Enterprise Cloud
                  
                
          
        
      
      
        Limit access to known allowed IP addresses.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          Enterprise Cloud
          
        
      



    

    
      

  
    Marketplace and integrations
  

  
    
  

  
    
  

    
      
    


          
  
    
      
        
          
            
              
            
            
              
                GitHub Apps
              
            
          
          
            
              Unlimited
              
            
              
                Unlimited
                
              
                
                  Unlimited
                  
                
          
        
      
      
        Install apps that integrate directly with GitHub's API to improve development workflows – or build your own for private use or publication in the GitHub Marketplace.
  

  
    
      Unlimited
      
    
  

    
      
        Unlimited
        
      
    

      
        
          Unlimited
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Status checks
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Define tests that GitHub automatically runs against code being committed to your repository, and get details about failures and what is causing them.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      



        
  
    
      
        
          
            
              
            
            
              
                Pre-receive hooks
              
            
          
          
            
              
              
            
              
                
                
              
                
                  Enterprise Server
                  
                
          
        
      
      
        Create requirements for automatically accepting or rejecting a push based on the contents of the push.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          Enterprise Server
          
        
      


    

    
      

  
    Support and deployment
  

  
    
  

  
    
  

    
      
    


          
  
    
      
        
          
            
              
            
            
              
                Community Support
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Get help with most of your GitHub questions and issues in our Community Forum.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Standard Support
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        GitHub Support can help you troubleshoot issues you run into while using GitHub. Get support via the web.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      



            
  
    
      
        
          
            
              
            
            
              
                Premium and Premium Plus Support
              
            
          
          
            
              
              
            
              
                
                
              
                
                  Available
                  
                
          
        
      
      
        With Premium, get a 30-minute SLA on Urgent tickets and 24/7 web and phone support via callback request. With Premium Plus, get everything in Premium, assigned Customer Reliability Engineer and more. Learn more about Premium Support
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          Available
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Invoice billing
              
            
          
          
            
              
              
            
              
                
                
              
                
                  
                  
                
          
        
      
      
        Pay bills via invoice, rather than using your credit card.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Self-hosted deployment
              
            
          
          
            
              
              
            
              
                
                
              
                
                  Enterprise Server
                  
                
          
        
      
      
        Self-hosted GitHub for on-prem appliances or self-managed cloud tenants.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          Enterprise Server
          
        
      


    
  
    
      
        
          
            
              
            
            
              
                Data residency
              
            
          
          
            
              
              
            
              
                
                
              
                
                  Enterprise Cloud
                  
                
          
        
      
      
        Multi-tenant enterprise SaaS solution on Microsoft Azure, allowing you to choose a regional cloud deployment for data residency, so your in-scope data is stored at rest in a designated location. This is available in the EU and Australia with additional regions coming soon. Contact our sales team to learn more.
  

  
    
      
      
    
  

    
      
        
        
      
    

      
        
          Enterprise Cloud
          
        
      



    

    
      
        
        
          
        
        
          
        
          
            
          
      
    
  





  
    
      
      
        We love people who are changing the world
      
    

    
  
        
    
        
            
              
            

          
        

      Open source teams

      
        If you manage multiple contributors, there’s a free option. We also run GitHub Sponsors, where we help fund your work.
      

      
        Learn more 

      


        
    
        
            
              
            

          
        

      Students and teachers

      
        We’ve partnered with industry leaders to give students and teachers free access to the best developer tools—for the school year and beyond.
      

      
        Learn more 

      


        
    
        
            
              
            

          
        

      Nonprofits

      
        Work for a government-recognized nonprofit, association, or 501(c)(3)? Get a discounted Organization on us.
      

      
        Learn more\n\n\n\nCreate your free account
            Explore GitHub's core features for individuals and organizations.

              
              
                See what's included
                
                  
                
              
              
                
  
      
        
          
        
        
          Access to GitHub Copilot
          Increase your productivity and accelerate software development.
      
      
        
          
        
        
          Unlimited repositories
          Collaborate securely on public and private projects.
      
      
        
          
        
        
          Integrated code reviews
          Boost code quality with built-in review tools.
      
      
        
          
        
        
          Automated workflows
          Save time with CI/CD integrations and GitHub Actions.
      
      
        
          
        
        
          Community support
          Connect with developers worldwide for instant feedback and insights.
      
  

              
            
          
          
            
            
          
        
        
          
          
            
  
  


  
    
  
  
    
      
        
        
        

        
          Sign up to GitHub
        

        

        
          
            
              Email*
            
            
              
                
                
              
            
          

          
            
              Password*
            
            
              
                
                    
                    
                    
                  
                
              
              
                Password should be at least 15 characters OR at least 8 characters including a number and a lowercase letter.
              
            
          

          
            
              
                Username*
              
            
            
              
                
                  
                  
                
              
              
                Username may only contain alphanumeric characters or single hyphens, and cannot begin or end with a hyphen.
              
            
          
          
  
    
      
        Your Country/Region*, required
      
    
    
      
  
      
    Select Country/Region
  
    
      
    


    
      
  
    
      
        Select Country/Region
      
        
    
    
      
    
  
              
              
  
      
        
      
    
      
                  Sorry, something went wrong.

            
            
                
      
        Filter
    
  
      
        
          
      Loading

      
    
      

      
  
  
  

    


      
        
          
          
            
                
  
      
        
      
    
        
    
    
    
        
          
        
      
        
          Afghanistan
      

  

        
    
    
    
        
          
        
      
        
          Åland
      

  

        
    
    
    
        
          
        
      
        
          Albania
      

  

        
    
    
    
        
          
        
      
        
          Algeria
      

  

        
    
    
    
        
          
        
      
        
          American Samoa
      

  

        
    
    
    
        
          
        
      
        
          Andorra
      

  

        
    
    
    
        
          
        
      
        
          Angola
      

  

        
    
    
    
        
          
        
      
        
          Anguilla
      

  

        
    
    
    
        
          
        
      
        
          Antarctica
      

  

        
    
    
    
        
          
        
      
        
          Antigua and Barbuda
      

  

        
    
    
    
        
          
        
      
        
          Argentina
      

  

        
    
    
    
        
          
        
      
        
          Armenia
      

  

        
    
    
    
        
          
        
      
        
          Aruba
      

  

        
    
    
    
        
          
        
      
        
          Australia
      

  

        
    
    
    
        
          
        
      
        
          Austria
      

  

        
    
    
    
        
          
        
      
        
          Azerbaijan
      

  

        
    
    
    
        
          
        
      
        
          Bahamas
      

  

        
    
    
    
        
          
        
      
        
          Bahrain
      

  

        
    
    
    
        
          
        
      
        
          Bangladesh
      

  

        
    
    
    
        
          
        
      
        
          Barbados
      

  

        
    
    
    
        
          
        
      
        
          Belarus
      

  

        
    
    
    
        
          
        
      
        
          Belgium
      

  

        
    
    
    
        
          
        
      
        
          Belize
      

  

        
    
    
    
        
          
        
      
        
          Benin
      

  

        
    
    
    
        
          
        
      
        
          Bermuda
      

  

        
    
    
    
        
          
        
      
        
          Bhutan
      

  

        
    
    
    
        
          
        
      
        
          Bolivia
      

  

        
    
    
    
        
          
        
      
        
          Bonaire, Sint Eustatius and Saba
      

  

        
    
    
    
        
          
        
      
        
          Bosnia and Herzegovina
      

  

        
    
    
    
        
          
        
      
        
          Botswana
      

  

        
    
    
    
        
          
        
      
        
          Bouvet Island
      

  

        
    
    
    
        
          
        
      
        
          Brazil
      

  

        
    
    
    
        
          
        
      
        
          British Indian Ocean Territory
      

  

        
    
    
    
        
          
        
      
        
          Brunei Darussalam
      

  

        
    
    
    
        
          
        
      
        
          Bulgaria
      

  

        
    
    
    
        
          
        
      
        
          Burkina Faso
      

  

        
    
    
    
        
          
        
      
        
          Burundi
      

  

        
    
    
    
        
          
        
      
        
          Cambodia
      

  

        
    
    
    
        
          
        
      
        
          Cameroon
      

  

        
    
    
    
        
          
        
      
        
          Canada
      

  

        
    
    
    
        
          
        
      
        
          Cape Verde
      

  

        
    
    
    
        
          
        
      
        
          Cayman Islands
      

  

        
    
    
    
        
          
        
      
        
          Central African Republic
      

  

        
    
    
    
        
          
        
      
        
          Chad
      

  

        
    
    
    
        
          
        
      
        
          Chile
      

  

        
    
    
    
        
          
        
      
        
          China
      

  

        
    
    
    
        
          
        
      
        
          Christmas Island
      

  

        
    
    
    
        
          
        
      
        
          Cocos (Keeling) Islands
      

  

        
    
    
    
        
          
        
      
        
          Colombia
      

  

        
    
    
    
        
          
        
      
        
          Comoros
      

  

        
    
    
    
        
          
        
      
        
          Congo (Brazzaville)
      

  

        
    
    
    
        
          
        
      
        
          Congo (Kinshasa)
      

  

        
    
    
    
        
          
        
      
        
          Cook Islands
      

  

        
    
    
    
        
          
        
      
        
          Costa Rica
      

  

        
    
    
    
        
          
        
      
        
          Côte d'Ivoire
      

  

        
    
    
    
        
          
        
      
        
          Croatia
      

  

        
    
    
    
        
          
        
      
        
          Curaçao
      

  

        
    
    
    
        
          
        
      
        
          Cyprus
      

  

        
    
    
    
        
          
        
      
        
          Czech Republic
      

  

        
    
    
    
        
          
        
      
        
          Denmark
      

  

        
    
    
    
        
          
        
      
        
          Djibouti
      

  

        
    
    
    
        
          
        
      
        
          Dominica
      

  

        
    
    
    
        
          
        
      
        
          Dominican Republic
      

  

        
    
    
    
        
          
        
      
        
          Ecuador
      

  

        
    
    
    
        
          
        
      
        
          Egypt
      

  

        
    
    
    
        
          
        
      
        
          El Salvador
      

  

        
    
    
    
        
          
        
      
        
          Equatorial Guinea
      

  

        
    
    
    
        
          
        
      
        
          Eritrea
      

  

        
    
    
    
        
          
        
      
        
          Estonia
      

  

        
    
    
    
        
          
        
      
        
          Ethiopia
      

  

        
    
    
    
        
          
        
      
        
          Falkland Islands
      

  

        
    
    
    
        
          
        
      
        
          Faroe Islands
      

  

        
    
    
    
        
          
        
      
        
          Fiji
      

  

        
    
    
    
        
          
        
      
        
          Finland
      

  

        
    
    
    
        
          
        
      
        
          France
      

  

        
    
    
    
        
          
        
      
        
          French Guiana
      

  

        
    
    
    
        
          
        
      
        
          French Polynesia
      

  

        
    
    
    
        
          
        
      
        
          French Southern Lands
      

  

        
    
    
    
        
          
        
      
        
          Gabon
      

  

        
    
    
    
        
          
        
      
        
          Gambia
      

  

        
    
    
    
        
          
        
      
        
          Georgia
      

  

        
    
    
    
        
          
        
      
        
          Germany
      

  

        
    
    
    
        
          
        
      
        
          Ghana
      

  

        
    
    
    
        
          
        
      
        
          Gibraltar
      

  

        
    
    
    
        
          
        
      
        
          Greece
      

  

        
    
    
    
        
          
        
      
        
          Greenland
      

  

        
    
    
    
        
          
        
      
        
          Grenada
      

  

        
    
    
    
        
          
        
      
        
          Guadeloupe
      

  

        
    
    
    
        
          
        
      
        
          Guam
      

  

        
    
    
    
        
          
        
      
        
          Guatemala
      

  

        
    
    
    
        
          
        
      
        
          Guernsey
      

  

        
    
    
    
        
          
        
      
        
          Guinea
      

  

        
    
    
    
        
          
        
      
        
          Guinea-Bissau
      

  

        
    
    
    
        
          
        
      
        
          Guyana
      

  

        
    
    
    
        
          
        
      
        
          Haiti
      

  

        
    
    
    
        
          
        
      
        
          Heard and McDonald Islands
      

  

        
    
    
    
        
          
        
      
        
          Honduras
      

  

        
    
    
    
        
          
        
      
        
          Hong Kong
      

  

        
    
    
    
        
          
        
      
        
          Hungary
      

  

        
    
    
    
        
          
        
      
        
          Iceland
      

  

        
    
    
    
        
          
        
      
        
          India
      

  

        
    
    
    
        
          
        
      
        
          Indonesia
      

  

        
    
    
    
        
          
        
      
        
          Iran
      

  

        
    
    
    
        
          
        
      
        
          Iraq
      

  

        
    
    
    
        
          
        
      
        
          Ireland
      

  

        
    
    
    
        
          
        
      
        
          Isle of Man
      

  

        
    
    
    
        
          
        
      
        
          Israel
      

  

        
    
    
    
        
          
        
      
        
          Italy
      

  

        
    
    
    
        
          
        
      
        
          Jamaica
      

  

        
    
    
    
        
          
        
      
        
          Japan
      

  

        
    
    
    
        
          
        
      
        
          Jersey
      

  

        
    
    
    
        
          
        
      
        
          Jordan
      

  

        
    
    
    
        
          
        
      
        
          Kazakhstan
      

  

        
    
    
    
        
          
        
      
        
          Kenya
      

  

        
    
    
    
        
          
        
      
        
          Kiribati
      

  

        
    
    
    
        
          
        
      
        
          Korea, South
      

  

        
    
    
    
        
          
        
      
        
          Kuwait
      

  

        
    
    
    
        
          
        
      
        
          Kyrgyzstan
      

  

        
    
    
    
        
          
        
      
        
          Laos
      

  

        
    
    
    
        
          
        
      
        
          Latvia
      

  

        
    
    
    
        
          
        
      
        
          Lebanon
      

  

        
    
    
    
        
          
        
      
        
          Lesotho
      

  

        
    
    
    
        
          
        
      
        
          Liberia
      

  

        
    
    
    
        
          
        
      
        
          Libya
      

  

        
    
    
    
        
          
        
      
        
          Liechtenstein
      

  

        
    
    
    
        
          
        
      
        
          Lithuania
      

  

        
    
    
    
        
          
        
      
        
          Luxembourg
      

  

        
    
    
    
        
          
        
      
        
          Macau
      

  

        
    
    
    
        
          
        
      
        
          Macedonia
      

  

        
    
    
    
        
          
        
      
        
          Madagascar
      

  

        
    
    
    
        
          
        
      
        
          Malawi
      

  

        
    
    
    
        
          
        
      
        
          Malaysia
      

  

        
    
    
    
        
          
        
      
        
          Maldives
      

  

        
    
    
    
        
          
        
      
        
          Mali
      

  

        
    
    
    
        
          
        
      
        
          Malta
      

  

        
    
    
    
        
          
        
      
        
          Marshall Islands
      

  

        
    
    
    
        
          
        
      
        
          Martinique
      

  

        
    
    
    
        
          
        
      
        
          Mauritania
      

  

        
    
    
    
        
          
        
      
        
          Mauritius
      

  

        
    
    
    
        
          
        
      
        
          Mayotte
      

  

        
    
    
    
        
          
        
      
        
          Mexico
      

  

        
    
    
    
        
          
        
      
        
          Micronesia
      

  

        
    
    
    
        
          
        
      
        
          Moldova
      

  

        
    
    
    
        
          
        
      
        
          Monaco
      

  

        
    
    
    
        
          
        
      
        
          Mongolia
      

  

        
    
    
    
        
          
        
      
        
          Montenegro
      

  

        
    
    
    
        
          
        
      
        
          Montserrat
      

  

        
    
    
    
        
          
        
      
        
          Morocco
      

  

        
    
    
    
        
          
        
      
        
          Mozambique
      

  

        
    
    
    
        
          
        
      
        
          Myanmar
      

  

        
    
    
    
        
          
        
      
        
          Namibia
      

  

        
    
    
    
        
          
        
      
        
          Nauru
      

  

        
    
    
    
        
          
        
      
        
          Nepal
      

  

        
    
    
    
        
          
        
      
        
          Netherlands
      

  

        
    
    
    
        
          
        
      
        
          New Caledonia
      

  

        
    
    
    
        
          
        
      
        
          New Zealand
      

  

        
    
    
    
        
          
        
      
        
          Nicaragua
      

  

        
    
    
    
        
          
        
      
        
          Niger
      

  

        
    
    
    
        
          
        
      
        
          Nigeria
      

  

        
    
    
    
        
          
        
      
        
          Niue
      

  

        
    
    
    
        
          
        
      
        
          Norfolk Island
      

  

        
    
    
    
        
          
        
      
        
          Northern Mariana Islands
      

  

        
    
    
    
        
          
        
      
        
          Norway
      

  

        
    
    
    
        
          
        
      
        
          Oman
      

  

        
    
    
    
        
          
        
      
        
          Pakistan
      

  

        
    
    
    
        
          
        
      
        
          Palau
      

  

        
    
    
    
        
          
        
      
        
          Palestine
      

  

        
    
    
    
        
          
        
      
        
          Panama
      

  

        
    
    
    
        
          
        
      
        
          Papua New Guinea
      

  

        
    
    
    
        
          
        
      
        
          Paraguay
      

  

        
    
    
    
        
          
        
      
        
          Peru
      

  

        
    
    
    
        
          
        
      
        
          Philippines
      

  

        
    
    
    
        
          
        
      
        
          Pitcairn
      

  

        
    
    
    
        
          
        
      
        
          Poland
      

  

        
    
    
    
        
          
        
      
        
          Portugal
      

  

        
    
    
    
        
          
        
      
        
          Puerto Rico
      

  

        
    
    
    
        
          
        
      
        
          Qatar
      

  

        
    
    
    
        
          
        
      
        
          Reunion
      

  

        
    
    
    
        
          
        
      
        
          Romania
      

  

        
    
    
    
        
          
        
      
        
          Rwanda
      

  

        
    
    
    
        
          
        
      
        
          Saint Barthélemy
      

  

        
    
    
    
        
          
        
      
        
          Saint Helena
      

  

        
    
    
    
        
          
        
      
        
          Saint Kitts and Nevis
      

  

        
    
    
    
        
          
        
      
        
          Saint Lucia
      

  

        
    
    
    
        
          
        
      
        
          Saint Martin (French part)
      

  

        
    
    
    
        
          
        
      
        
          Saint Pierre and Miquelon
      

  

        
    
    
    
        
          
        
      
        
          Saint Vincent and the Grenadines
      

  

        
    
    
    
        
          
        
      
        
          Samoa
      

  

        
    
    
    
        
          
        
      
        
          San Marino
      

  

        
    
    
    
        
          
        
      
        
          Sao Tome and Principe
      

  

        
    
    
    
        
          
        
      
        
          Saudi Arabia
      

  

        
    
    
    
        
          
        
      
        
          Senegal
      

  

        
    
    
    
        
          
        
      
        
          Serbia
      

  

        
    
    
    
        
          
        
      
        
          Seychelles
      

  

        
    
    
    
        
          
        
      
        
          Sierra Leone
      

  

        
    
    
    
        
          
        
      
        
          Singapore
      

  

        
    
    
    
        
          
        
      
        
          Sint Maarten (Dutch part)
      

  

        
    
    
    
        
          
        
      
        
          Slovakia
      

  

        
    
    
    
        
          
        
      
        
          Slovenia
      

  

        
    
    
    
        
          
        
      
        
          Solomon Islands
      

  

        
    
    
    
        
          
        
      
        
          Somalia
      

  

        
    
    
    
        
          
        
      
        
          South Africa
      

  

        
    
    
    
        
          
        
      
        
          South Georgia and South Sandwich Islands
      

  

        
    
    
    
        
          
        
      
        
          South Sudan
      

  

        
    
    
    
        
          
        
      
        
          Spain
      

  

        
    
    
    
        
          
        
      
        
          Sri Lanka
      

  

        
    
    
    
        
          
        
      
        
          Sudan
      

  

        
    
    
    
        
          
        
      
        
          Suriname
      

  

        
    
    
    
        
          
        
      
        
          Svalbard and Jan Mayen Islands
      

  

        
    
    
    
        
          
        
      
        
          Swaziland
      

  

        
    
    
    
        
          
        
      
        
          Sweden
      

  

        
    
    
    
        
          
        
      
        
          Switzerland
      

  

        
    
    
    
        
          
        
      
        
          Taiwan
      

  

        
    
    
    
        
          
        
      
        
          Tajikistan
      

  

        
    
    
    
        
          
        
      
        
          Tanzania
      

  

        
    
    
    
        
          
        
      
        
          Thailand
      

  

        
    
    
    
        
          
        
      
        
          Timor-Leste
      

  

        
    
    
    
        
          
        
      
        
          Togo
      

  

        
    
    
    
        
          
        
      
        
          Tokelau
      

  

        
    
    
    
        
          
        
      
        
          Tonga
      

  

        
    
    
    
        
          
        
      
        
          Trinidad and Tobago
      

  

        
    
    
    
        
          
        
      
        
          Tunisia
      

  

        
    
    
    
        
          
        
      
        
          Türkiye
      

  

        
    
    
    
        
          
        
      
        
          Turkmenistan
      

  

        
    
    
    
        
          
        
      
        
          Turks and Caicos Islands
      

  

        
    
    
    
        
          
        
      
        
          Tuvalu
      

  

        
    
    
    
        
          
        
      
        
          Uganda
      

  

        
    
    
    
        
          
        
      
        
          Ukraine
      

  

        
    
    
    
        
          
        
      
        
          United Arab Emirates
      

  

        
    
    
    
        
          
        
      
        
          United Kingdom
      

  

        
    
    
    
        
          
        
      
        
          United States Minor Outlying Islands
      

  

        
    
    
    
        
          
        
      
        
          United States of America
      

  

        
    
    
    
        
          
        
      
        
          Uruguay
      

  

        
    
    
    
        
          
        
      
        
          Uzbekistan
      

  

        
    
    
    
        
          
        
      
        
          Vanuatu
      

  

        
    
    
    
        
          
        
      
        
          Vatican City
      

  

        
    
    
    
        
          
        
      
        
          Venezuela
      

  

        
    
    
    
        
          
        
      
        
          Vietnam
      

  

        
    
    
    
        
          
        
      
        
          Virgin Islands, British
      

  

        
    
    
    
        
          
        
      
        
          Virgin Islands, U.S.
      

  

        
    
    
    
        
          
        
      
        
          Wallis and Futuna Islands
      

  

        
    
    
    
        
          
        
      
        
          Yemen
      

  

        
    
    
    
        
          
        
      
        
          Zambia
      

  

        
    
    
    
        
          
        
      
        
          Zimbabwe
      

  

    


            
            
              No results found
            
        
      
  
      
      
        For compliance reasons, we're required to collect country information to send you occasional updates and announcements.
      
    
  
  
    
       Email preferences 
      
        
  
  
    
      Receive occasional product updates and announcements
      
  

      
    
  


        

          
              
    Continue
              
  

          

        
            Verify your account
            
              


  
    
  

  
    
  

  
      
  

  


            

          



        

        
            
    Create account
              
  

        

        
          
  By creating an account, you agree to the
  Terms of Service.
  For more information about GitHub's privacy practices, see the
  GitHub Privacy Statement.
  We'll occasionally send you account-related emails.\n\n\n\nYoni Goldberg - Developer, Architect, Consultant
About me in 2 paragraphs
I stumbled into the world of programming by accident, discovering a programming book at my parents' house. It was 9 PM when I began flipping through its pages, and suddenly, sun rays were streaming through the window—morning had arrived. I was amazed by this incredible science, feeling like Alice in Wonderland. Ever since then, I've been in love with this. I code, consult, write about it, and speak about it worldwide. My blog has welcomed over 7 million visitors, and my GitHub repositories have earned 132,000 stars



If there's one skill I've honed over the years, it's coding and designing with SIMPLICITY in mind. I always strive to find the sweet spot between robustness and simplicity, considering it one of the finest arts of our profession. While I'm curious about many aspects of software, it's Testing that I love a little more. I've had the privilege to work with over 40 organizations worldwide, including some giant companies you probably know, enhancing their testing processes. I'm a big fan of the new testing paradigm—the testing diamond—and believe that tests should blend seamlessly and effortlessly into developers' workflows
Some Git stats, cause it probably tells something about me

Cherry-picked content from my blog


📘 Node.js best practices - 100+ best practices with code examples for a modern backend, including tips about architecture, security, testing, performance, hardening and more
📊 4 million visitors, 103,000 stars


📘 JavaScript testing best practices - 50+ best practices with code examples for testing JavaScript apps, including tips about mocking, clean tests, testing strategy, api tests, UI tests and more
📊 2.5 million visitors, 24,000 stars


📘 Node.js testing best practices - A minibook about the art of backend component/integration tests. It shows with code examples how to meet both great develoepr experience and also high realism and risk coverage. The text cover all the key aspects of component tests: dealing with APIs, testing with data(base), testing message queues, testing integrations with other services, testing the component SecOps parts
📊 120K visitors visitors, 3,500 stars


Want to read more? See below a full list of publications
Let's work together
Want to work together? yay 🥳. Here are the 3 main services that I provide:


Architecture planning and consulting


Over the years, I’ve had the opportunity to plan challenging systems with large organizations (see customer list below). I remember once a customer asked me to plan a big system with a team of developers. After weeks of hard work, we came up with a skeleton. Some stakeholders were disappointed to see that the skeleton was only 300 lines of code and contained very few patterns and layers. "What took you so long?" they wondered
"We carefully chose valuable popular tools to do most of the work for us and removed any unnecessary overhead," we explained. For me, simplicity is the ultimate sophistication. Fast forward a year, and most of the organization learned to appreciate that lean and flat architecture that everyone can understand in hours, not weeks


Coding for you


My bread and butter activity. I code primarily in JavaScript (Node.js, Rect) and Python, though happy to code in other modern languages like Go and Kotlin. What makes me a reliable developer? I strive for simple code. Many others say this, but me? Even medium-level code complexity makes me sweat with unease in my chair. I fear complexity! This drives me to write highly standardized code,  avoiding reinventing new wheels, and just keeping it lean and nimble


Testing enhancements and workshop for your team


I worked with dozens of organizations worldwide to boost their testing skills, using various training methods, including a comprehensive workshop. See more details here including a short summary video
Among my customers

Public speaking
As a consultant and a blogger, speaking is home to me. I typically speak about strategic backend concepts like testing and architecture and bring to stage advanced and shiny topics. If you’d like to invite me to your conference, please approach using any of the methods here
See below a glimpse of me speaking at conferences:

  
    
    Yoni.Goldberg.-.Speaking.Conferences.mp4
    
  

  

  


Reach out

📞 Whatsapp
📥 me@goldbergyoni.com

All my blog posts and videos ever
🎬YouTube: Yoni Goldberg @ Node.TLV '24 | Reliable API Integration: Modern Workflows And Testing Techniques 08/03/2024
🎬YouTube: Yoni Goldberg @ NodeTLV '23 | Strategic Node.js crossroads in 2023 07/24/2024
🗞️Article: About the sweet and powerful 'use case' code pattern 04/22/2024
🗞️Article: A compilation of outstanding testing articles (with JavaScript) 08/06/2023
🗞️Article: Testing the dark scenarios of your Node.js application 07/07/2023
🎧Podcast: Episode 36: NodeJS in 2023 Part 1 - With Yoni Goldberg 04/2023 #Hebrew
🎬YouTube: Node.js strategic crossroads in 2022/2023 - Yoni Goldberg (Hebrew) 11/09/2022 #Hebrew
🗞️Article: Is Prisma better than your 'traditional' ORM? 12/07/2022
🗞️Article: Which Monorepo is right for a Node.js BACKEND now? 11/07/2022
🗞️Article: Popular Node.js patterns and tools to re-consider 08/02/2022
🗞️Article: Practica.js v0.0.1 is alive 07/15/2022
🎧Podcast: Yoni Goldberg on Integration Tests with JavaScript 07/2021
🎧Podcast: Episode 37: NodeJS in 2023, Part 2 with Yoni Goldberg 05/2021
🎬YouTube: Fruitful CI/CD Practices - Liran Tal, Yoni Goldberg and Gil Tayar | JSHeroes Meetups 05/18/2020
🎧Podcast: Best practices for Node developers (JS Party #139) 08/2020
🎧Podcast: Best practices for Node developers 08/2020
🗞️Article: Popular Node.js patterns and tools to re-consider 12/12/2022
🗞️Article: 20 ways to become a better Node.js developer in 2020 12/12/2019
🎬YouTube: Yoni Goldberg - JavaScript Testing: Latest 2019 trends, techniques and opportunities 11/02/2019
🎬YouTube: Yoni Goldberg - JavaScript Testing: Latest 2019 trends, techniques and opportunities 11/02/2019
🎬YouTube: Yoni Goldberg: Five Advanced & Shiny Testing Techniques | js.la August 2019 11/05/2019
🗞️Article: 30+ Node.js & JavaScript Testing Best Practices 01/11/2019
🗞️Article: 19 ways to become a better Node.JS developer in 2019 12/13/2018
🎬YouTube: Advanced Test Techniques by Yoni Goldberg 11/29/2018
🗞️Article: ‘Should it be a Microservice?’ 11/28/2018
🗞️Article: Advanced Node.js testing tools – slides from my talk 10/29/2018
🗞️Article: Node.js security best practices 08/01/2018
🗞️Article: My new GitHub project: Node.JS best practices 12/31/2017
🗞️Article: Checklist: Node.JS production best practices (August 2018) 08/05/2017
🗞️Article: Follow my Node.JS best practices social pages 01/18/2017
🗞️Article: Easily deploying microservices to AWS Elastic Beanstalk 07/10/2016
🗞️Article: Checklist: Best Practices of Node.JS Error Handling (2018) 05/05/2016
🗞️Article: View my keynote session from “JavaScript Israel” conference 12/15/2015
🗞️Article: Node.JS in Azure – 10 tips 12/10/2015
🗞️Article: 10 strategic web UI development best practices 07/12/2015
🗞️Article: What is the best way to connect to custom database using BCS? 12/28/2011
🗞️Article: 40+ SharePoint Workflow Tips – part 3 (Hebrew) 11/27/2011 #Hebrew
🗞️Article: 40+ SharePoint Workflow Tips – part 4 (Hebrew) 11/27/2011 #Hebrew
🗞️Article: 40+ SharePoint Workflow Tips – part 2 (Hebrew) 11/27/2011 #Hebrew
🗞️Article: 40+ SharePoint Workflow Tips – part 1 (Hebrew) 11/21/2011 #Hebrew
🗞️Article: SharePoint keyboard productivity tips 11/01/2011
🗞️Article: Workflow feedback process – granting one user (the pivot) to decide for all 10/04/2011
🗞️Article: A developer intro to sandboxed solutions 06/13/2011
🗞️Article: A new codeplex project: Taxonomy Breadcrumb web part 05/01/2011
🗞️Article: Workshop: composite applications in SharePoint
03/14/2011 #Hebrew
🗞️Article: Download my Tech-Ed 2010 BCS presentation code & slides
11/30/2010
🗞️Article: SharePoint 2010 launching event – download my presentation 07/27/2010
🗞️Article: List validation accepts excel functions 05/25/2010
🗞️Article: ASP.NET web parts demo for download 05/05/2010
🗞️Article: My introduction to SOA 05/02/2010
🗞️Article: Why C# version for DotNetNuke is not (so) important? 05/02/2010
🗞️Article: Passing objects by reference/value in C# 05/23/2010\n\ngoldbergyoni
                  
  
    
      Follow
    
  

                
              
            

              
              
  
    
    Overview

  
    
    Repositories
    32

  
    
    Projects
    0

    
      
      Packages
      0

  
    
    Stars
    220





  
    
            
        
        More
      

            
        
          
            Overview
          
          
            Repositories
          
          
            Projects
          
            
              Packages
            
          
            Stars
          
        
      




            

    
  


  
  
        
          
            
              
                
              
              
                
                  goldbergyoni
              
              
                
  
    
      Follow
    
  

              
            
          

          
  
    
        
      
  
    
      

  
    
      💭
    
    
        I may be slow to respond

    
  


    
  

    

    
      
        
          Yoni Goldberg
        
        
          goldbergyoni

        
      
    
  

      
      

  
    
      💭
    
    
        I may be slow to respond

    
  


  


  
    
        
              
                
                
  
    
      Follow
    
  

              
        


    

    

  An independent consultant who works with enterprises and garage startups on polishing their FullStack applications and testing


    
      
        
          
          4.7k
          followers
        · 
          11
          following
      
    

  
        
                  Yoni Goldberg

      
        Israel



    
      www.GoldbergYoni.com


      

        @goldbergyoni

  


  

      
    Achievementsx3x4Achievementsx3x4
    Highlights
    

  Pro



    
      
    Block or Report
  



  
    
  
    
      
        Block or report goldbergyoni
      
        
    
    
      
    
  
  

      
            
      
          
        

        Block user
        
            Prevent this user from interacting with your repositories and sending you notifications.
          Learn more about blocking users.
        





            
              You must be logged in to block users.
            

          
              
      
        Add an optional note:
    
  
    
      

      
  
  
  

      Please don't include any personal information such as legal names or email addresses. Maximum 100 characters, markdown supported. This note will be visible to only you.



          

        
          Block user
        
    
    
      Report abuse
      
        Contact GitHub support about this user’s behavior.
        Learn more about reporting abuse.
      
      Report abuse
    

      
      




      

          
          
  
    
    Overview

  
    
    Repositories
    32

  
    
    Projects
    0

    
      
      Packages
      0

  
    
    Stars
    220





  
    
            
        
        More
      

            
        
          
            Overview
          
          
            Repositories
          
          
            Projects
          
            
              Packages
            
          
            Stars
          
        
      




        
      

        
          
    




  
  
    
      
        goldbergyoni/README.md
      

    
    Yoni Goldberg - Developer, Architect, Consultant
About me in 2 paragraphs
I stumbled into the world of programming by accident, discovering a programming book at my parents' house. It was 9 PM when I began flipping through its pages, and suddenly, sun rays were streaming through the window—morning had arrived. I was amazed by this incredible science, feeling like Alice in Wonderland. Ever since then, I've been in love with this. I code, consult, write about it, and speak about it worldwide. My blog has welcomed over 7 million visitors, and my GitHub repositories have earned 132,000 stars



If there's one skill I've honed over the years, it's coding and designing with SIMPLICITY in mind. I always strive to find the sweet spot between robustness and simplicity, considering it one of the finest arts of our profession. While I'm curious about many aspects of software, it's Testing that I love a little more. I've had the privilege to work with over 40 organizations worldwide, including some giant companies you probably know, enhancing their testing processes. I'm a big fan of the new testing paradigm—the testing diamond—and believe that tests should blend seamlessly and effortlessly into developers' workflows
Some Git stats, cause it probably tells something about me

Cherry-picked content from my blog


📘 Node.js best practices - 100+ best practices with code examples for a modern backend, including tips about architecture, security, testing, performance, hardening and more
📊 4 million visitors, 103,000 stars


📘 JavaScript testing best practices - 50+ best practices with code examples for testing JavaScript apps, including tips about mocking, clean tests, testing strategy, api tests, UI tests and more
📊 2.5 million visitors, 24,000 stars


📘 Node.js testing best practices - A minibook about the art of backend component/integration tests. It shows with code examples how to meet both great develoepr experience and also high realism and risk coverage. The text cover all the key aspects of component tests: dealing with APIs, testing with data(base), testing message queues, testing integrations with other services, testing the component SecOps parts
📊 120K visitors visitors, 3,500 stars


Want to read more? See below a full list of publications
Let's work together
Want to work together? yay 🥳. Here are the 3 main services that I provide:


Architecture planning and consulting


Over the years, I’ve had the opportunity to plan challenging systems with large organizations (see customer list below). I remember once a customer asked me to plan a big system with a team of developers. After weeks of hard work, we came up with a skeleton. Some stakeholders were disappointed to see that the skeleton was only 300 lines of code and contained very few patterns and layers. "What took you so long?" they wondered
"We carefully chose valuable popular tools to do most of the work for us and removed any unnecessary overhead," we explained. For me, simplicity is the ultimate sophistication. Fast forward a year, and most of the organization learned to appreciate that lean and flat architecture that everyone can understand in hours, not weeks


Coding for you


My bread and butter activity. I code primarily in JavaScript (Node.js, Rect) and Python, though happy to code in other modern languages like Go and Kotlin. What makes me a reliable developer? I strive for simple code. Many others say this, but me? Even medium-level code complexity makes me sweat with unease in my chair. I fear complexity! This drives me to write highly standardized code,  avoiding reinventing new wheels, and just keeping it lean and nimble


Testing enhancements and workshop for your team


I worked with dozens of organizations worldwide to boost their testing skills, using various training methods, including a comprehensive workshop. See more details here including a short summary video
Among my customers

Public speaking
As a consultant and a blogger, speaking is home to me. I typically speak about strategic backend concepts like testing and architecture and bring to stage advanced and shiny topics. If you’d like to invite me to your conference, please approach using any of the methods here
See below a glimpse of me speaking at conferences:

  
    
    Yoni.Goldberg.-.Speaking.Conferences.mp4
    
  

  

  


Reach out

📞 Whatsapp
📥 me@goldbergyoni.com

All my blog posts and videos ever
🎬YouTube: Yoni Goldberg @ Node.TLV '24 | Reliable API Integration: Modern Workflows And Testing Techniques 08/03/2024
🎬YouTube: Yoni Goldberg @ NodeTLV '23 | Strategic Node.js crossroads in 2023 07/24/2024
🗞️Article: About the sweet and powerful 'use case' code pattern 04/22/2024
🗞️Article: A compilation of outstanding testing articles (with JavaScript) 08/06/2023
🗞️Article: Testing the dark scenarios of your Node.js application 07/07/2023
🎧Podcast: Episode 36: NodeJS in 2023 Part 1 - With Yoni Goldberg 04/2023 #Hebrew
🎬YouTube: Node.js strategic crossroads in 2022/2023 - Yoni Goldberg (Hebrew) 11/09/2022 #Hebrew
🗞️Article: Is Prisma better than your 'traditional' ORM? 12/07/2022
🗞️Article: Which Monorepo is right for a Node.js BACKEND now? 11/07/2022
🗞️Article: Popular Node.js patterns and tools to re-consider 08/02/2022
🗞️Article: Practica.js v0.0.1 is alive 07/15/2022
🎧Podcast: Yoni Goldberg on Integration Tests with JavaScript 07/2021
🎧Podcast: Episode 37: NodeJS in 2023, Part 2 with Yoni Goldberg 05/2021
🎬YouTube: Fruitful CI/CD Practices - Liran Tal, Yoni Goldberg and Gil Tayar | JSHeroes Meetups 05/18/2020
🎧Podcast: Best practices for Node developers (JS Party #139) 08/2020
🎧Podcast: Best practices for Node developers 08/2020
🗞️Article: Popular Node.js patterns and tools to re-consider 12/12/2022
🗞️Article: 20 ways to become a better Node.js developer in 2020 12/12/2019
🎬YouTube: Yoni Goldberg - JavaScript Testing: Latest 2019 trends, techniques and opportunities 11/02/2019
🎬YouTube: Yoni Goldberg - JavaScript Testing: Latest 2019 trends, techniques and opportunities 11/02/2019
🎬YouTube: Yoni Goldberg: Five Advanced & Shiny Testing Techniques | js.la August 2019 11/05/2019
🗞️Article: 30+ Node.js & JavaScript Testing Best Practices 01/11/2019
🗞️Article: 19 ways to become a better Node.JS developer in 2019 12/13/2018
🎬YouTube: Advanced Test Techniques by Yoni Goldberg 11/29/2018
🗞️Article: ‘Should it be a Microservice?’ 11/28/2018
🗞️Article: Advanced Node.js testing tools – slides from my talk 10/29/2018
🗞️Article: Node.js security best practices 08/01/2018
🗞️Article: My new GitHub project: Node.JS best practices 12/31/2017
🗞️Article: Checklist: Node.JS production best practices (August 2018) 08/05/2017
🗞️Article: Follow my Node.JS best practices social pages 01/18/2017
🗞️Article: Easily deploying microservices to AWS Elastic Beanstalk 07/10/2016
🗞️Article: Checklist: Best Practices of Node.JS Error Handling (2018) 05/05/2016
🗞️Article: View my keynote session from “JavaScript Israel” conference 12/15/2015
🗞️Article: Node.JS in Azure – 10 tips 12/10/2015
🗞️Article: 10 strategic web UI development best practices 07/12/2015
🗞️Article: What is the best way to connect to custom database using BCS? 12/28/2011
🗞️Article: 40+ SharePoint Workflow Tips – part 3 (Hebrew) 11/27/2011 #Hebrew
🗞️Article: 40+ SharePoint Workflow Tips – part 4 (Hebrew) 11/27/2011 #Hebrew
🗞️Article: 40+ SharePoint Workflow Tips – part 2 (Hebrew) 11/27/2011 #Hebrew
🗞️Article: 40+ SharePoint Workflow Tips – part 1 (Hebrew) 11/21/2011 #Hebrew
🗞️Article: SharePoint keyboard productivity tips 11/01/2011
🗞️Article: Workflow feedback process – granting one user (the pivot) to decide for all 10/04/2011
🗞️Article: A developer intro to sandboxed solutions 06/13/2011
🗞️Article: A new codeplex project: Taxonomy Breadcrumb web part 05/01/2011
🗞️Article: Workshop: composite applications in SharePoint
03/14/2011 #Hebrew
🗞️Article: Download my Tech-Ed 2010 BCS presentation code & slides
11/30/2010
🗞️Article: SharePoint 2010 launching event – download my presentation 07/27/2010
🗞️Article: List validation accepts excel functions 05/25/2010
🗞️Article: ASP.NET web parts demo for download 05/05/2010
🗞️Article: My introduction to SOA 05/02/2010
🗞️Article: Why C# version for DotNetNuke is not (so) important? 05/02/2010
🗞️Article: Passing objects by reference/value in C# 05/23/2010

  




  
  
      Pinned
    
      Loading

    
  

      
      
  
    
      
        
            
          practicajs/practica  practicajs/practica          Public
        
      


      
        Node.js solution starter boilerplate that is production-ready, packed with ✅ best practices and built with simplicity in mind
      

      
          
  
  TypeScript


          
            
            1.6k
          
          
            
            143
          
      
    
  









      
        
          
  
        
        
          Something went wrong, please refresh the page to try again.
          If the problem persists, check the GitHub status page
          or contact support.\n\n\n\nSign in to GitHub
    


    



  
    

  
    
      
    
    
      
      {{ message }}

    
  

  



    
      
        
      
    

    
      
  

    
      Username or email address
    
    

  
    
      Password
    
    
    Forgot password?
    













    
  
  
      
  

    


        Password login alternatives
        
            
    
        
    Sign in with a passkey
  

    
  

          
            New to GitHub?
              Create an account\n\n\n\ngoldbergyoni
    
    /
    
      nodebestpractices
    

    Public
  


        

        
            
    
      

  
                Notifications
    You must be signed in to change notification settings

  

  
              Fork
    10.4k

  

  
        
            
          Star
          102k

  



        
      

        



          

  
      
  
    
              
        Code
          


    

      
  
    
              
        Issues
          44


    

      
  
    
              
        Pull requests
          36


    

      
  
    
              
        Actions
          


    

      
  
    
              
        Projects
          0


    

      
  
    
              
        Security
          

    

      
  
    
              
        Insights
          


    


          
  
      
Additional navigation options



  
    
                
  
    
        
    
    
    
        
          
        
      
        
          Code
      

  

        
    
    
    
        
          
        
      
        
          Issues
      

  

        
    
    
    
        
          
        
      
        
          Pull requests
      

  

        
    
    
    
        
          
        
      
        
          Actions
      

  

        
    
    
    
        
          
        
      
        
          Projects
      

  

        
    
    
    
        
          
        
      
        
          Security
      

  

        
    
    
    
        
          
        
      
        
          Insights
      

  

    




      
  



  

  




    
    



    
      
    









  
  
     Files masterBreadcrumbsnodebestpractices/LICENSECopy path Blame  Blame        Latest commit HistoryHistory173 lines (88 loc) · 18.3 KB masterBreadcrumbsnodebestpractices/LICENSETopFile metadata and controlsCodeBlame173 lines (88 loc) · 18.3 KBRaw123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173## creative commons
# Attribution-ShareAlike 4.0 International
Creative Commons Corporation (“Creative Commons”) is not a law firm and does not provide legal services or legal advice. Distribution of Creative Commons public licenses does not create a lawyer-client or other relationship. Creative Commons makes its licenses and related information available on an “as-is” basis. Creative Commons gives no warranties regarding its licenses, any material licensed under their terms and conditions, or any related information. Creative Commons disclaims all liability for damages resulting from their use to the fullest extent possible.
### Using Creative Commons Public Licenses
Creative Commons public licenses provide a standard set of terms and conditions that creators and other rights holders may use to share original works of authorship and other material subject to copyright and certain other rights specified in the public license below. The following considerations are for informational purposes only, are not exhaustive, and do not form part of our licenses.
* __Considerations for licensors:__ Our public licenses are intended for use by those authorized to give the public permission to use material in ways otherwise restricted by copyright and certain other rights. Our licenses are irrevocable. Licensors should read and understand the terms and conditions of the license they choose before applying it. Licensors should also secure all rights necessary before applying our licenses so that the public can reuse the material as expected. Licensors should clearly mark any material not subject to the license. This includes other CC-licensed material, or material used under an exception or limitation to copyright. [More considerations for licensors](http://wiki.creativecommons.org/Considerations_for_licensors_and_licensees#Considerations_for_licensors).
* __Considerations for the public:__ By using one of our public licenses, a licensor grants the public permission to use the licensed material under specified terms and conditions. If the licensor’s permission is not necessary for any reason–for example, because of any applicable exception or limitation to copyright–then that use is not regulated by the license. Our licenses grant only permissions under copyright and certain other rights that a licensor has authority to grant. Use of the licensed material may still be restricted for other reasons, including because others have copyright or other rights in the material. A licensor may make special requests, such as asking that all changes be marked or described. Although not required by our licenses, you are encouraged to respect those requests where reasonable. [More considerations for the public](http://wiki.creativecommons.org/Considerations_for_licensors_and_licensees#Considerations_for_licensees).
## Creative Commons Attribution-ShareAlike 4.0 International Public License
By exercising the Licensed Rights (defined below), You accept and agree to be bound by the terms and conditions of this Creative Commons Attribution-ShareAlike 4.0 International Public License ("Public License"). To the extent this Public License may be interpreted as a contract, You are granted the Licensed Rights in consideration of Your acceptance of these terms and conditions, and the Licensor grants You such rights in consideration of benefits the Licensor receives from making the Licensed Material available under these terms and conditions.
### Section 1 – Definitions.
a. __Adapted Material__ means material subject to Copyright and Similar Rights that is derived from or based upon the Licensed Material and in which the Licensed Material is translated, altered, arranged, transformed, or otherwise modified in a manner requiring permission under the Copyright and Similar Rights held by the Licensor. For purposes of this Public License, where the Licensed Material is a musical work, performance, or sound recording, Adapted Material is always produced where the Licensed Material is synched in timed relation with a moving image.
b. __Adapter's License__ means the license You apply to Your Copyright and Similar Rights in Your contributions to Adapted Material in accordance with the terms and conditions of this Public License.
c. __BY-SA Compatible License__ means a license listed at [creativecommons.org/compatiblelicenses](http://creativecommons.org/compatiblelicenses), approved by Creative Commons as essentially the equivalent of this Public License.
d. __Copyright and Similar Rights__ means copyright and/or similar rights closely related to copyright including, without limitation, performance, broadcast, sound recording, and Sui Generis Database Rights, without regard to how the rights are labeled or categorized. For purposes of this Public License, the rights specified in Section 2(b)(1)-(2) are not Copyright and Similar Rights.
e. __Effective Technological Measures__ means those measures that, in the absence of proper authority, may not be circumvented under laws fulfilling obligations under Article 11 of the WIPO Copyright Treaty adopted on December 20, 1996, and/or similar international agreements.
f. __Exceptions and Limitations__ means fair use, fair dealing, and/or any other exception or limitation to Copyright and Similar Rights that applies to Your use of the Licensed Material.
g. __License Elements__ means the license attributes listed in the name of a Creative Commons Public License. The License Elements of this Public License are Attribution and ShareAlike.
h. __Licensed Material__ means the artistic or literary work, database, or other material to which the Licensor applied this Public License.
i. __Licensed Rights__ means the rights granted to You subject to the terms and conditions of this Public License, which are limited to all Copyright and Similar Rights that apply to Your use of the Licensed Material and that the Licensor has authority to license.
j. __Licensor__ means the individual(s) or entity(ies) granting rights under this Public License.
k. __Share__ means to provide material to the public by any means or process that requires permission under the Licensed Rights, such as reproduction, public display, public performance, distribution, dissemination, communication, or importation, and to make material available to the public including in ways that members of the public may access the material from a place and at a time individually chosen by them.
l. __Sui Generis Database Rights__ means rights other than copyright resulting from Directive 96/9/EC of the European Parliament and of the Council of 11 March 1996 on the legal protection of databases, as amended and/or succeeded, as well as other essentially equivalent rights anywhere in the world.
m. __You__ means the individual or entity exercising the Licensed Rights under this Public License. Your has a corresponding meaning.
### Section 2 – Scope.
a. ___License grant.___
   1. Subject to the terms and conditions of this Public License, the Licensor hereby grants You a worldwide, royalty-free, non-sublicensable, non-exclusive, irrevocable license to exercise the Licensed Rights in the Licensed Material to:
       A. reproduce and Share the Licensed Material, in whole or in part; and
       B. produce, reproduce, and Share Adapted Material.
   2. __Exceptions and Limitations.__ For the avoidance of doubt, where Exceptions and Limitations apply to Your use, this Public License does not apply, and You do not need to comply with its terms and conditions.
   3. __Term.__ The term of this Public License is specified in Section 6(a).
   4. __Media and formats; technical modifications allowed.__ The Licensor authorizes You to exercise the Licensed Rights in all media and formats whether now known or hereafter created, and to make technical modifications necessary to do so. The Licensor waives and/or agrees not to assert any right or authority to forbid You from making technical modifications necessary to exercise the Licensed Rights, including technical modifications necessary to circumvent Effective Technological Measures. For purposes of this Public License, simply making modifications authorized by this Section 2(a)(4) never produces Adapted Material.
   5. __Downstream recipients.__
       A. __Offer from the Licensor – Licensed Material.__ Every recipient of the Licensed Material automatically receives an offer from the Licensor to exercise the Licensed Rights under the terms and conditions of this Public License.
       B. __Additional offer from the Licensor – Adapted Material. Every recipient of Adapted Material from You automatically receives an offer from the Licensor to exercise the Licensed Rights in the Adapted Material under the conditions of the Adapter’s License You apply.
       C. __No downstream restrictions.__ You may not offer or impose any additional or different terms or conditions on, or apply any Effective Technological Measures to, the Licensed Material if doing so restricts exercise of the Licensed Rights by any recipient of the Licensed Material.
   6. __No endorsement.__ Nothing in this Public License constitutes or may be construed as permission to assert or imply that You are, or that Your use of the Licensed Material is, connected with, or sponsored, endorsed, or granted official status by, the Licensor or others designated to receive attribution as provided in Section 3(a)(1)(A)(i).
b. ___Other rights.___
   1. Moral rights, such as the right of integrity, are not licensed under this Public License, nor are publicity, privacy, and/or other similar personality rights; however, to the extent possible, the Licensor waives and/or agrees not to assert any such rights held by the Licensor to the limited extent necessary to allow You to exercise the Licensed Rights, but not otherwise.
   2. Patent and trademark rights are not licensed under this Public License.
   3. To the extent possible, the Licensor waives any right to collect royalties from You for the exercise of the Licensed Rights, whether directly or through a collecting society under any voluntary or waivable statutory or compulsory licensing scheme. In all other cases the Licensor expressly reserves any right to collect such royalties.
### Section 3 – License Conditions.
Your exercise of the Licensed Rights is expressly made subject to the following conditions.
a. ___Attribution.___
   1. If You Share the Licensed Material (including in modified form), You must:
       A. retain the following if it is supplied by the Licensor with the Licensed Material:
         i. identification of the creator(s) of the Licensed Material and any others designated to receive attribution, in any reasonable manner requested by the Licensor (including by pseudonym if designated);
         ii. a copyright notice;
         iii. a notice that refers to this Public License;
         iv. a notice that refers to the disclaimer of warranties;
         v. a URI or hyperlink to the Licensed Material to the extent reasonably practicable;
       B. indicate if You modified the Licensed Material and retain an indication of any previous modifications; and
       C. indicate the Licensed Material is licensed under this Public License, and include the text of, or the URI or hyperlink to, this Public License.
   2. You may satisfy the conditions in Section 3(a)(1) in any reasonable manner based on the medium, means, and context in which You Share the Licensed Material. For example, it may be reasonable to satisfy the conditions by providing a URI or hyperlink to a resource that includes the required information.
   3. If requested by the Licensor, You must remove any of the information required by Section 3(a)(1)(A) to the extent reasonably practicable.
b. ___ShareAlike.___
In addition to the conditions in Section 3(a), if You Share Adapted Material You produce, the following conditions also apply.
1. The Adapter’s License You apply must be a Creative Commons license with the same License Elements, this version or later, or a BY-SA Compatible License.
2. You must include the text of, or the URI or hyperlink to, the Adapter's License You apply. You may satisfy this condition in any reasonable manner based on the medium, means, and context in which You Share Adapted Material.
3. You may not offer or impose any additional or different terms or conditions on, or apply any Effective Technological Measures to, Adapted Material that restrict exercise of the rights granted under the Adapter's License You apply.
### Section 4 – Sui Generis Database Rights.
Where the Licensed Rights include Sui Generis Database Rights that apply to Your use of the Licensed Material:
a. for the avoidance of doubt, Section 2(a)(1) grants You the right to extract, reuse, reproduce, and Share all or a substantial portion of the contents of the database;
b. if You include all or a substantial portion of the database contents in a database in which You have Sui Generis Database Rights, then the database in which You have Sui Generis Database Rights (but not its individual contents) is Adapted Material, including for purposes of Section 3(b); and
c. You must comply with the conditions in Section 3(a) if You Share all or a substantial portion of the contents of the database.
For the avoidance of doubt, this Section 4 supplements and does not replace Your obligations under this Public License where the Licensed Rights include other Copyright and Similar Rights.
### Section 5 – Disclaimer of Warranties and Limitation of Liability.
a. __Unless otherwise separately undertaken by the Licensor, to the extent possible, the Licensor offers the Licensed Material as-is and as-available, and makes no representations or warranties of any kind concerning the Licensed Material, whether express, implied, statutory, or other. This includes, without limitation, warranties of title, merchantability, fitness for a particular purpose, non-infringement, absence of latent or other defects, accuracy, or the presence or absence of errors, whether or not known or discoverable. Where disclaimers of warranties are not allowed in full or in part, this disclaimer may not apply to You.__
b. __To the extent possible, in no event will the Licensor be liable to You on any legal theory (including, without limitation, negligence) or otherwise for any direct, special, indirect, incidental, consequential, punitive, exemplary, or other losses, costs, expenses, or damages arising out of this Public License or use of the Licensed Material, even if the Licensor has been advised of the possibility of such losses, costs, expenses, or damages. Where a limitation of liability is not allowed in full or in part, this limitation may not apply to You.__
c. The disclaimer of warranties and limitation of liability provided above shall be interpreted in a manner that, to the extent possible, most closely approximates an absolute disclaimer and waiver of all liability.
### Section 6 – Term and Termination.
a. This Public License applies for the term of the Copyright and Similar Rights licensed here. However, if You fail to comply with this Public License, then Your rights under this Public License terminate automatically.
b. Where Your right to use the Licensed Material has terminated under Section 6(a), it reinstates:
   1. automatically as of the date the violation is cured, provided it is cured within 30 days of Your discovery of the violation; or
   2. upon express reinstatement by the Licensor.
   For the avoidance of doubt, this Section 6(b) does not affect any right the Licensor may have to seek remedies for Your violations of this Public License.
c. For the avoidance of doubt, the Licensor may also offer the Licensed Material under separate terms or conditions or stop distributing the Licensed Material at any time; however, doing so will not terminate this Public License.
d. Sections 1, 5, 6, 7, and 8 survive termination of this Public License.
### Section 7 – Other Terms and Conditions.
a. The Licensor shall not be bound by any additional or different terms or conditions communicated by You unless expressly agreed.
b. Any arrangements, understandings, or agreements regarding the Licensed Material not stated herein are separate from and independent of the terms and conditions of this Public License.t stated herein are separate from and independent of the terms and conditions of this Public License.
### Section 8 – Interpretation.
a. For the avoidance of doubt, this Public License does not, and shall not be interpreted to, reduce, limit, restrict, or impose conditions on any use of the Licensed Material that could lawfully be made without permission under this Public License.
b. To the extent possible, if any provision of this Public License is deemed unenforceable, it shall be automatically reformed to the minimum extent necessary to make it enforceable. If the provision cannot be reformed, it shall be severed from this Public License without affecting the enforceability of the remaining terms and conditions.
c. No term or condition of this Public License will be waived and no failure to comply consented to unless expressly agreed to by the Licensor.
d. Nothing in this Public License constitutes or may be interpreted as a limitation upon, or waiver of, any privileges and immunities that apply to the Licensor or You, including from the legal processes of any jurisdiction or authority.
> Creative Commons is not a party to its public licenses. Notwithstanding, Creative Commons may elect to apply one of its public licenses to material it publishes and in those instances will be considered the “Licensor.” Except for the limited purpose of indicating that material is shared under a Creative Commons public license or as otherwise permitted by the Creative Commons policies published at [creativecommons.org/policies](http://creativecommons.org/policies), Creative Commons does not authorize the use of the trademark “Creative Commons” or any other trademark or logo of Creative Commons without its prior written consent including, without limitation, in connection with any unauthorized modifications to any of its public licenses or any other arrangements, understandings, or agreements concerning use of licensed material. For the avoidance of doubt, this paragraph does not form part of the public licenses.>> Creative Commons may be contacted at creativecommons.org\n\n\n\ngoldbergyoni
    
    /
    
      nodebestpractices
    

    Public
  


        

        
            
    
      

  
                Notifications
    You must be signed in to change notification settings

  

  
              Fork
    10.4k

  

  
        
            
          Star
          102k

  



        
      

        



          

  
      
  
    
              
        Code
          


    

      
  
    
              
        Issues
          44


    

      
  
    
              
        Pull requests
          36


    

      
  
    
              
        Actions
          


    

      
  
    
              
        Projects
          0


    

      
  
    
              
        Security
          

    

      
  
    
              
        Insights
          


    


          
  
      
Additional navigation options



  
    
                
  
    
        
    
    
    
        
          
        
      
        
          Code
      

  

        
    
    
    
        
          
        
      
        
          Issues
      

  

        
    
    
    
        
          
        
      
        
          Pull requests
      

  

        
    
    
    
        
          
        
      
        
          Actions
      

  

        
    
    
    
        
          
        
      
        
          Projects
      

  

        
    
    
    
        
          
        
      
        
          Security
      

  

        
    
    
    
        
          
        
      
        
          Insights
      

  

    




      
  



  

  




    
    



    
      
  
    
          Stargazers

  
  
    
  
      
      All 5,000+
      
      You know
  


      
          
  
    
      
        
      

      
        
          
    mosh1
        
        

  
  Is from San Francisco, CA
  
    San Francisco, CA
  
  

        
          
  
    
      Follow
    
  


        
      
    
  

          
  
    
      
        
      

      
        
          
    ersinisgor
        
        

  
  Is from İzmir,Turkey
  
    İzmir,Turkey
  
  

        
          
  
    
      Follow
    
  


        
      
    
  

          
  
    
      
        
      

      
        
          
    Brunoskyy
        
        

  Works for FullstackLabs
  
  
    FullstackLabs
  


        
          
  
    
      Follow
    
  


        
      
    
  

          
  
    
      
        
      

      
        
          
    kryptonian41
        
        

  Works for @thinkaidium 
  
  
    @thinkaidium 
  


        
          
  
    
      Follow
    
  


        
      
    
  

          
  
    
      
        
      

      
        
          
    nathanscully
        
        

  Works for @adora-so 
  
  
    @adora-so 
  


        
          
  
    
      Follow
    
  


        
      
    
  

          
  
    
      
        
      

      
        
          
    amineleghouil
        
        

  
  Is from Tunisia
  
    Tunisia
  
  

        
          
  
    
      Follow
    
  


        
      
    
  

          
  
    
      
        
      

      
        
          
    j2a1ck
        
        
 Joined on Apr 7, 2022

        
          
  
    
      Follow
    
  


        
      
    
  

          
  
    
      
        
      

      
        
          
    iuashrafi
        
        
 Joined on May 24, 2016

        
          
  
    
      Follow
    
  


        
      
    
  

          
  
    
      
        
      

      
        
          
    microHoffman
        
        

  Works for @PWNDAO 
  
  
    @PWNDAO 
  


        
          
  
    
      Follow
    
  


        
      
    
  

          
  
    
      
        
      

      
        
          
    Kanhaiyaphukev
        
        

  Works for Sreyah Technologies
  
  
    Sreyah Technologies
  


        
          
  
    
      Follow
    
  


        
      
    
  

          
  
    
      
        
      

      
        
          
    yusufalvian
        
        

  Works for Stealth Mode
  
  
    Stealth Mode
  


        
          
  
    
      Follow
    
  


        
      
    
  

          
  
    
      
        
      

      
        
          
    amitchell303
        
        

  
  Is from Denver, CO
  
    Denver, CO
  
  

        
          
  
    
      Follow
    
  


        
      
    
  

          
  
    
      
        
      

      
        
          
    saulin18
        
        

  
  Is from Holguín, Cuba
  
    Holguín, Cuba
  
  

        
          
  
    
      Follow
    
  


        
      
    
  

          
  
    
      
        
      

      
        
          
    HadiMardanian
        
        
 Joined on Apr 29, 2019

        
          
  
    
      Follow
    
  


        
      
    
  

          
  
    
      
        
      

      
        
          
    MohamedRagab93
        
        
 Joined on Jul 31, 2024

        
          
  
    
      Follow
    
  


        
      
    
  

          
  
    
      
        
      

      
        
          
    StefanShan
        
        
 Joined on Apr 10, 2017

        
          
  
    
      Follow
    
  


        
      
    
  

          
  
    
      
        
      

      
        
          
    axel-nyman
        
        

  
  Is from Stockholm, Sweden
  
    Stockholm, Sweden
  
  

        
          
  
    
      Follow
    
  


        
      
    
  

          
  
    
      
        
      

      
        
          
    Timi-Leyin
        
        

  
  Is from Nigeria
  
    Nigeria
  
  

        
          
  
    
      Follow
    
  


        
      
    
  

          
  
    
      
        
      

      
        
          
    advait2016
        
        

  
  Is from Bengaluru
  
    Bengaluru
  
  

        
          
  
    
      Follow
    
  


        
      
    
  

          
  
    
      
        
      

      
        
          
    Romerski
        
        

  
  Is from Spain
  
    Spain
  
  

        
          
  
    
      Follow
    
  


        
      
    
  

          
  
    
      
        
      

      
        
          
    xiaochunyu
        
        
 Joined on Oct 22, 2012

        
          
  
    
      Follow
    
  


        
      
    
  

          
  
    
      
        
      

      
        
          
    caitoulin
        
        
 Joined on Mar 12, 2019

        
          
  
    
      Follow
    
  


        
      
    
  

          
  
    
      
        
      

      
        
          
    assagman
        
        
 Joined on Jun 22, 2015

        
          
  
    
      Follow
    
  


        
      
    
  

          
  
    
      
        
      

      
        
          
    mdabcevic
        
        

  Works for Innovez d.o.o.
  
  
    Innovez d.o.o.
  


        
          
  
    
      Follow
    
  


        
      
    
  

      
      
        PreviousNext\n\n\n\ngoldbergyoni
    
    /
    
      nodebestpractices
    

    Public
  


        

        
            
    
      

  
                Notifications
    You must be signed in to change notification settings

  

  
              Fork
    10.4k

  

  
        
            
          Star
          102k

  



        
      

        



          

  
      
  
    
              
        Code
          


    

      
  
    
              
        Issues
          44


    

      
  
    
              
        Pull requests
          36


    

      
  
    
              
        Actions
          


    

      
  
    
              
        Projects
          0


    

      
  
    
              
        Security
          

    

      
  
    
              
        Insights
          


    


          
  
      
Additional navigation options



  
    
                
  
    
        
    
    
    
        
          
        
      
        
          Code
      

  

        
    
    
    
        
          
        
      
        
          Issues
      

  

        
    
    
    
        
          
        
      
        
          Pull requests
      

  

        
    
    
    
        
          
        
      
        
          Actions
      

  

        
    
    
    
        
          
        
      
        
          Projects
      

  

        
    
    
    
        
          
        
      
        
          Security
      

  

        
    
    
    
        
          
        
      
        
          Insights
      

  

    




      
  



  

  




    
    



    
      
Insights: goldbergyoni/nodebestpractices

  
  
        

  
    Pulse
    Contributors
      Community Standards
    Commits
    Code frequency
      Dependency graph
    Network
    Forks
  



  
      
  
  Switch to tree view

  
    Forks
      
      
        
      Period:
    2 years


  
    
      
  
        Filter by period


    


      


          
  

    

    
        
  1 month

        
  6 months

        
  1 year

        
  2 years

        
  5 years


      Nothing to show
    


          Any repository that has not been created or
    updated during this period will be excluded.



        
      Repository type:
    
        Active



  
    
      
  
        Filter by repository type


    


      


          
  

    

    
        
            
            Active
            Repositories with push activity


        
            
            Inactive
            Repositories with no push activity


        
            
            Network
            Forks of other forks


        
            
            Archived
            Archived repositories


        
            
            Starred
            Repositories with at least 1 star



      Nothing to show
    


      


        
      Sort:
    Most starred


  
    
      
  
        Sort by


    


      


          
  

    

    
        
          Most starred

        
          Recently updated

        
          Open issues

        
          Open pull requests


      Nothing to show
    


      





  
  
  
  
    
        
  
    
      
      
        sbmdkl
    
      /
    nodebestpractices  
      
    
      4

      
    
      0

      
    
      0

      
    
      1

      
  
    Created
    February 21, 2020 12:53


      
  
    Updated
    March 6, 2024 16:18


  

        
  
    
      
      
        WangHansen
    
      /
    nodebestpractices  
      
    
      3

      
    
      0

      
    
      0

      
    
      2

      
  
    Created
    October 9, 2018 07:38


      
  
    Updated
    March 6, 2024 16:18


  

        
  
    
      
      
        animir
    
      /
    nodebestpractices  
      
    
      3

      
    
      0

      
    
      0

      
    
      0

      
  
    Created
    December 27, 2018 09:56


      
  
    Updated
    February 27, 2024 13:43


  

        
  
    
      
      
        lwinmoepaing
    
      /
    nodebestpractices  
      
    
      3

      
    
      0

      
    
      0

      
    
      0

      
  
    Created
    January 5, 2020 20:48


      
  
    Updated
    October 26, 2023 03:51


  

        
  
    
      
      
        Berkmann18
    
      /
    nodebestpractices  
      
    
      2

      
    
      0

      
    
      0

      
    
      1

      
  
    Created
    December 25, 2018 01:53


      
  
    Updated
    April 15, 2025 22:07


  

        
  
    
      
      
        BrightkyEfoo
    
      /
    nodebestpractices  
      
    
      2

      
    
      0

      
    
      0

      
    
      0

      
  
    Created
    November 21, 2023 03:25


      
  
    Updated
    April 22, 2024 16:54


  

        
  
    
      
      
        talhawaqar
    
      /
    nodebestpractices  
      
    
      2

      
    
      0

      
    
      0

      
    
      0

      
  
    Created
    September 15, 2020 07:07


      
  
    Updated
    April 20, 2024 21:43


  

        
  
    
      
      
        DHsustainer
    
      /
    nodebestpractices  
      
    
      2

      
    
      0

      
    
      0

      
    
      0

      
  
    Created
    September 1, 2019 11:00


      
  
    Updated
    September 12, 2023 17:26


  

        
  
    
      
      
        nafisatuli
    
      /
    nodebestpractices  
      
    
      2

      
    
      0

      
    
      0

      
    
      0

      
  
    Created
    February 5, 2021 13:31


      
  
    Updated
    November 13, 2023 18:09


  

        
  
    
      
      
        radespratama
    
      /
    nodebestpractices  
      
    
      2

      
    
      0

      
    
      0

      
    
      0

      
  
    Created
    August 26, 2022 07:29


      
  
    Updated
    October 27, 2023 13:42


  

        
  
    
      
      
        nagendraallam
    
      /
    nodebestpractices  
      
    
      1

      
    
      0

      
    
      0

      
    
      0

      
  
    Created
    January 21, 2024 09:38


      
  
    Updated
    January 21, 2024 09:44


  

        
  
    
      
      
        JainamBheda
    
      /
    nodebestpractices  
      
    
      1

      
    
      0

      
    
      0

      
    
      0

      
  
    Created
    July 6, 2024 16:06


      
  
    Updated
    July 6, 2024 16:32


  

        
  
    
      
      
        inomad07
    
      /
    nodebestpractices  
      
    
      1

      
    
      0

      
    
      0

      
    
      0

      
  
    Created
    March 31, 2020 09:10


      
  
    Updated
    July 10, 2024 18:47


  

        
  
    
      
      
        Huniko-Team
    
      /
    nodebestpractices  
      
    
      1

      
    
      0

      
    
      0

      
    
      0

      
  
    Created
    July 6, 2022 07:59


      
  
    Updated
    April 6, 2024 02:21


  

        
  
    
      
      
        HaloXie
    
      /
    nodebestpractices  
      
    
      1

      
    
      0

      
    
      0

      
    
      0

      
  
    Created
    August 12, 2019 10:00


      
  
    Updated
    June 28, 2024 07:45


  

        
  
    
      
      
        Gsdhumal07
    
      /
    nodebestpractices  
      
    
      1

      
    
      0

      
    
      0

      
    
      0

      
  
    Created
    May 4, 2023 18:15


      
  
    Updated
    May 4, 2023 18:16


  

        
  
    
      
      
        ccf8dh
    
      /
    nodebestpractices  
      
    
      1

      
    
      0

      
    
      0

      
    
      0

      
  
    Created
    April 4, 2025 02:01


      
  
    Updated
    April 4, 2025 02:06


  

        
  
    
      
      
        blackmatch
    
      /
    nodebestpractices  
      
    
      1

      
    
      0

      
    
      0

      
    
      0

      
  
    Created
    October 31, 2018 14:02


      
  
    Updated
    October 10, 2024 06:44


  

        
  
    
      
      
        ourystd
    
      /
    nodebestpractices  
      
    
      1

      
    
      0

      
    
      0

      
    
      0

      
  
    Created
    December 22, 2020 23:50


      
  
    Updated
    April 14, 2024 05:27


  

        
  
    
      
      
        pinglu85
    
      /
    nodebestpractices  
      
    
      1

      
    
      0

      
    
      0

      
    
      1

      
  
    Created
    September 2, 2020 20:02


      
  
    Updated
    April 16, 2025 00:32


  

        
  
    
      
      
        raw-leak
    
      /
    nodebestpractices  
      
    
      1

      
    
      0

      
    
      0

      
    
      0

      
  
    Created
    May 23, 2020 12:50


      
  
    Updated
    January 24, 2024 18:35


  

        
  
    
      
      
        repobest
    
      /
    nodebestpractices  
      
    
      1

      
    
      0

      
    
      0

      
    
      0

      
  
    Created
    January 24, 2022 10:46


      
  
    Updated
    March 10, 2025 22:51


  

        
  
    
      
      
        rlscode
    
      /
    nodebestpractices  
      
    
      1

      
    
      0

      
    
      0

      
    
      0

      
  
    Created
    May 31, 2019 05:47


      
  
    Updated
    January 29, 2025 21:43


  

        
  
    
      
      
        SANAL-C-T
    
      /
    nodebestpractices  
      
    
      1

      
    
      0

      
    
      0

      
    
      0

      
  
    Created
    November 6, 2023 07:59


      
  
    Updated
    May 25, 2024 05:34


  

        
  
    
      
      
        SivaCse
    
      /
    nodebestpractices  
      
    
      1

      
    
      0

      
    
      0

      
    
      0

      
  
    Created
    March 14, 2019 15:17


      
  
    Updated
    May 1, 2024 23:32


  

  

  Previous 1 2 3 4 5 … 9 10 Next\n\n\n\ngoldbergyoni
    
    /
    
      nodebestpractices
    

    Public
  


        

        
            
    
      

  
                Notifications
    You must be signed in to change notification settings

  

  
              Fork
    10.4k

  

  
        
            
          Star
          102k

  



        
      

        



          

  
      
  
    
              
        Code
          


    

      
  
    
              
        Issues
          44


    

      
  
    
              
        Pull requests
          36


    

      
  
    
              
        Actions
          


    

      
  
    
              
        Projects
          0


    

      
  
    
              
        Security
          

    

      
  
    
              
        Insights
          


    


          
  
      
Additional navigation options



  
    
                
  
    
        
    
    
    
        
          
        
      
        
          Code
      

  

        
    
    
    
        
          
        
      
        
          Issues
      

  

        
    
    
    
        
          
        
      
        
          Pull requests
      

  

        
    
    
    
        
          
        
      
        
          Actions
      

  

        
    
    
    
        
          
        
      
        
          Projects
      

  

        
    
    
    
        
          
        
      
        
          Security
      

  

        
    
    
    
        
          
        
      
        
          Insights
      

  

    




      
  



  

  




    
    



    
      
    









  
  
    BranchesOverviewActiveStaleAllSearchDefaultBranchUpdatedCheck statusBehindAheadPull requestAction menumasterCopy branch name to clipboard Apr 15, 2025Delete branchBranch menu\n\n\n\ngoldbergyoni
    
    /
    
      nodebestpractices
    

    Public
  


        

        
            
    
      

  
                Notifications
    You must be signed in to change notification settings

  

  
              Fork
    10.4k

  

  
        
            
          Star
          102k

  



        
      

        



          

  
      
  
    
              
        Code
          


    

      
  
    
              
        Issues
          44


    

      
  
    
              
        Pull requests
          36


    

      
  
    
              
        Actions
          


    

      
  
    
              
        Projects
          0


    

      
  
    
              
        Security
          

    

      
  
    
              
        Insights
          


    


          
  
      
Additional navigation options



  
    
                
  
    
        
    
    
    
        
          
        
      
        
          Code
      

  

        
    
    
    
        
          
        
      
        
          Issues
      

  

        
    
    
    
        
          
        
      
        
          Pull requests
      

  

        
    
    
    
        
          
        
      
        
          Actions
      

  

        
    
    
    
        
          
        
      
        
          Projects
      

  

        
    
    
    
        
          
        
      
        
          Security
      

  

        
    
    
    
        
          
        
      
        
          Insights
      

  

    




      
  



  

  




    
    



    
      

  
    
      
  Releases
  Tags


    
  
  
    
    There aren’t any releases here
  
    You can create a release to package software, along with release notes and links to binary files, for other people to use. Learn more about releases in our docs.\n\n\n\ngoldbergyoni
    
    /
    
      nodebestpractices
    

    Public
  


        

        
            
    
      

  
                Notifications
    You must be signed in to change notification settings

  

  
              Fork
    10.4k

  

  
        
            
          Star
          102k

  



        
      

        



          

  
      
  
    
              
        Code
          


    

      
  
    
              
        Issues
          44


    

      
  
    
              
        Pull requests
          36


    

      
  
    
              
        Actions
          


    

      
  
    
              
        Projects
          0


    

      
  
    
              
        Security
          

    

      
  
    
              
        Insights
          


    


          
  
      
Additional navigation options



  
    
                
  
    
        
    
    
    
        
          
        
      
        
          Code
      

  

        
    
    
    
        
          
        
      
        
          Issues
      

  

        
    
    
    
        
          
        
      
        
          Pull requests
      

  

        
    
    
    
        
          
        
      
        
          Actions
      

  

        
    
    
    
        
          
        
      
        
          Projects
      

  

        
    
    
    
        
          
        
      
        
          Security
      

  

        
    
    
    
        
          
        
      
        
          Insights\n\n\n\ngoldbergyoni
    
    /
    
      nodebestpractices
    

    Public
  


        

        
            
    
      

  
                Notifications
    You must be signed in to change notification settings

  

  
              Fork
    10.4k

  

  
        
            
          Star
          102k

  



        
      

        



          

  
      
  
    
              
        Code
          


    

      
  
    
              
        Issues
          44


    

      
  
    
              
        Pull requests
          36


    

      
  
    
              
        Actions
          


    

      
  
    
              
        Projects
          0


    

      
  
    
              
        Security
          

    

      
  
    
              
        Insights
          


    


          
  
      
Additional navigation options



  
    
                
  
    
        
    
    
    
        
          
        
      
        
          Code
      

  

        
    
    
    
        
          
        
      
        
          Issues
      

  

        
    
    
    
        
          
        
      
        
          Pull requests
      

  

        
    
    
    
        
          
        
      
        
          Actions
      

  

        
    
    
    
        
          
        
      
        
          Projects
      

  

        
    
    
    
        
          
        
      
        
          Security
      

  

        
    
    
    
        
          
        
      
        
          Insights
      

  

    




      
  



  

  




    
    



    
      
    
      
  


  Issues: goldbergyoni/nodebestpractices



  
      Beta
      
    ⚡Try the new experience
  


    


  

    
      
      
    
      

  
    
    Labels
      26
  
    
    Milestones
      5


    
  
  
    
      

  
    
    Labels
      26
  
    
    Milestones
      5


    
             


  
    
    New issue
  
  
            
    
              
  



  
    Have a question about this project? Sign up for a free GitHub account to open an issue and contact its maintainers and the community.
  

  
          Sign up for GitHub

  

  By clicking “Sign up for GitHub”, you agree to our terms of service and
  privacy statement. We’ll occasionally send you account related emails.

  
    Already on GitHub?
    Sign in
    to your account
  



  

  




  
    

    
      
      44 Open
    

    
      
      284 Closed
    


  

  
        

  
    
      

    
      
      44 Open
    

    
      
      284 Closed
    


    

      
        
  
    
      Author
      
    
    
      
        
          Filter by author
          
            
          
        
        
          
        
        
          
            
              
      Loading

          
          
            
            
              author:
              Filter by this user
            
        
      
    
  

          

  
    Label
    
  
  
    
      
        Filter by label
        
          
        
      
      
        
      
      
        
      Loading

      
        
          Use alt + click/return to exclude labels
        
        
          or ⇧ + click/return for logical OR
        
      
    
  


        
            

        Projects
    
  
    
      
        Filter by project
        
          
        
      
      
        
      Loading

     
  


            

        Milestones
    
  
    
      
        Filter by milestone
        
          
        
      
      
        
      
      
        
      Loading

    
  


        
        

  
    Assignee
    
  
  
    
      
        Filter by who’s assigned
        
          
        
      
      
        
      
      
        
          
            
            Assigned to nobody
          
          
            
      Loading

        
        
          
          
            assignee:
            Filter by this user
          
      
    
  


        

  
    Sort
    
  
  
    
      
        Sort by
        
          
        
      

      
          
            
            Newest
          
          
            
            Oldest
          
          
            
            Most commented
          
          
            
            Least commented
          
          
            
            Recently updated
          
          
            
            Least recently updated
          
          
            
            Best match
          

        Most reactions
        
            
              👍
            
            
              👎
            
            
              😄
            
            
              🎉
            
            
              😕
            
            
              ❤️
            
            
              🚀
            
            
              👀
            
        
      
    
  


      
  




      Issues list
      
        
              

  


    
      
        
      
    

    
    

      General Bug / Enhancement Tracker for Node.js Website


      
        
          #1341
            opened Apr 18, 2025 by
            Vitiantanmay
            
        

        


        

        

      
    

    

      
      

      
        
          
          
        
      

      
      
    

      
  


              

  


    
      
        
      
    

    
    

      Semantic error in sentence


      
        
          #1338
            opened Mar 5, 2025 by
            katsyuta
            
        

        


        

        

      
    

    

      
          
              
                
                  
                  1
                
              
          
      

      
        
          
          
        
      

      
          
            
            2
          
      
    

      
  


              

  


    
      
        
      
    

    
    

      help


      
        
          #1337
            opened Mar 2, 2025 by
            reid-harrisson
            
        

        


        

        

      
    

    

      
      

      
        
          
          
        
      

      
      
    

      
  


              

  


    
      
        
      
    

    
    

      codebounty


      
        
          #1336
            opened Feb 18, 2025 by
            rohith-m19
            
        

        


        

        

      
    

    

      
      

      
        
          
          
        
      

      
      
    

      
  


              

  


    
      
        
      
    

    
    

      Stale spanish translation


      
        
          #1335
            opened Jan 20, 2025 by
            GeekBeardLinks
            
        

        


        

        

      
    

    

      
      

      
        
          
          
        
      

      
      
    

      
  


              

  


    
      
        
      
    

    
    

      Setting NODE_ENV to another value as 'production' is regarded an antipattern


      
        
          #1329
            opened Nov 7, 2024 by
            maon-fp
            
        

        


        

        

      
    

    

      
      

      
        
          
          
        
      

      
      
    

      
  


              

  


    
      
        
      
    

    
    

      Node


      
        
          #1328
            opened Oct 12, 2024 by
            vlzivan
            
        

        


        

        

      
    

    

      
      

      
        
          
          
        
      

      
      
    

      
  


              

  


    
      
        
      
    

    
    

      NODE.JS


      
        
          #1303
            opened Aug 11, 2024 by
            thanocollins
            
        

        


        

        

      
    

    

      
      

      
        
          
          
        
      

      
      
    

      
  


              

  


    
      
        
      
    

    
    

      I have a question regarding DI(Dependency Injector)


      
        
          #1299
            opened Jun 20, 2024 by
            polyglot-k
            
        

        


        

        

      
    

    

      
      

      
        
          
          
        
      

      
      
    

      
  


              

  


    
      
        
      
    

    
    

      Is using cache for npm install in docker safe?


      
        
          #1297
            opened Apr 10, 2024 by
            Motii1
            
        

        


        

        

      
    

    

      
      

      
        
          
          
        
      

      
      
    

      
  


              

  


    
      
        
      
    

    
    

      Mi006


      
        
          #1295
            opened Mar 8, 2024 by
            Cheapetsgrow
            
        

        


        

        

      
    

    

      
      

      
        
          
          
        
      

      
      
    

      
  


              

  


    
      
        
      
    

    
    

      Dead link for safe-regex


      
        
          #1290
            opened Dec 15, 2023 by
            hulkish
            
        

        


        

        

      
    

    

      
      

      
        
          
          
        
      

      
          
            
            1
          
      
    

      
  


              

  


    
      
        
      
    

    
    

      Кнас


      
        
          #1289
            opened Dec 7, 2023 by
            WaleriiChirkov-16021990
            
        

        


        

        

      
    

    

      
      

      
        
          
          
        
      

      
      
    

      
  


              

  


    
      
        
      
    

    
    

      Hinglish Translation 


      
        
          #1288
            opened Nov 17, 2023 by
            BornPsych
            
        

        


        

        

      
    

    

      
      

      
        
          
          
        
      

      
          
            
            1
          
      
    

      
  


              

  


    
      
        
      
    

    
    

      Italian Translation


      
        
          #1281
            opened Oct 9, 2023 by
            thomasravetto
            
        

        


        

        

      
    

    

      
      

      
        
          
          
        
      

      
      
    

      
  


              

  


    
      
        
      
    

    
    

      Another comment regarding "1.1 Structure your solutions by business components"


      
        
          #1266
            opened Aug 17, 2023 by
            mindactuate
            
        

        


        

        

      
    

    

      
      

      
        
          
          
        
      

      
          
            
            1
          
      
    

      
  


              

  


    
      
        
      
    

    
    

      Nextjs as main framework?


      
        
          #1264
            opened Aug 14, 2023 by
            movaldivia
            
        

        


        

        

      
    

    

      
      

      
        
          
          
        
      

      
          
            
            2
          
      
    

      
  


              

  


    
      
        
      
    

    
    

      Node


      
        
          #1253
            opened Jun 13, 2023 by
            Lifjordan23
            
        

        


        

        

      
    

    

      
      

      
        
          
          
        
      

      
      
    

      
  


              

  


    
      
        
      
    

    
    

      Bootstraping nodejs container may be misleading


      
        
          #1243
            opened May 9, 2023 by
            l2ysho
            
        

        


        

        

      
    

    

      
      

      
        
          
          
        
      

      
      
    

      
  


              

  


    
      
        
      
    

    
    

      Should include Corepack in our recommendation?


      
        
          #1242
            opened May 9, 2023 by
            goldbergyoni
            
        

        


        

        

      
    

    

      
      

      
        
          
          
        
      

      
          
            
            5
          
      
    

      
  


              

  


    
      
        
      
    

    
    

      Node practice 1


      
        
          #1236
            opened Apr 18, 2023 by
            rahul91101
            
        

        


        

        

      
    

    

      
      

      
        
          
          
        
      

      
      
    

      
  


              

  


    
      
        
      
    

    
    

      Arabic Translation


      
        
          #1231
            opened Apr 8, 2023 by
            SajadRafaa
            
        

        


        

        

      
    

    

      
      

      
        
          
          
        
      

      
          
            
            1
          
      
    

      
  


              

  


    
      
        
      
    

    
    

      Bonnes pratiques nodejs


      
        
          #1228
            opened Mar 25, 2023 by
            Gedeon-koumako
            
        

        


        

        

      
    

    

      
      

      
        
          
          
        
      

      
      
    

      
  


              

  


    
      
        
      
    

    
    

      Translations status 


      
        
          #1202
            opened Sep 20, 2022 by
            mauroaccornero
            
        

        


        

        

      
    

    

      
      

      
        
          
          
        
      

      
          
            
            1
          
      
    

      
  


              

  


    
      
        
      
    

    
    

      Easy to translate advice


      
        
          #1195
            opened Aug 26, 2022 by
            itabbot
            
        

        


        

        

      
    

    

      
      

      
        
          
          
        
      

      
          
            
            1
          
      
    

      
  


        
      
  

  
      Previous 1 2 Next
  

  
      Previous Next
  

  
  
  ProTip!
  Type g i on any issue or pull request to go back to the issue listing page.\n\n\n\ngoldbergyoni
    
    /
    
      nodebestpractices
    

    Public
  


        

        
            
    
      

  
                Notifications
    You must be signed in to change notification settings

  

  
              Fork
    10.4k

  

  
        
            
          Star
          102k

  



        
      

        



          

  
      
  
    
              
        Code
          


    

      
  
    
              
        Issues
          44


    

      
  
    
              
        Pull requests
          36


    

      
  
    
              
        Actions
          


    

      
  
    
              
        Projects
          0


    

      
  
    
              
        Security
          

    

      
  
    
              
        Insights
          


    


          
  
      
Additional navigation options



  
    
                
  
    
        
    
    
    
        
          
        
      
        
          Code
      

  

        
    
    
    
        
          
        
      
        
          Issues
      

  

        
    
    
    
        
          
        
      
        
          Pull requests
      

  

        
    
    
    
        
          
        
      
        
          Actions
      

  

        
    
    
    
        
          
        
      
        
          Projects
      

  

        
    
    
    
        
          
        
      
        
          Security
      

  

        
    
    
    
        
          
        
      
        
          Insights
      

  

    




      
  



  

  




    
    



    
      
    
      
  


  Pull requests: goldbergyoni/nodebestpractices




    


  

    
      
      
    
      

  
    
    Labels
      26
  
    
    Milestones
      5


    
  
  
    
      

  
    
    Labels
      26
  
    
    Milestones
      5


    
            
    New pull request
            New
  

  




  
    

    
      
      36 Open
    

    
      
      927 Closed
    


  

  
        

  
    
      

    
      
      36 Open
    

    
      
      927 Closed
    


    

      
        
  
    
      Author
      
    
    
      
        
          Filter by author
          
            
          
        
        
          
        
        
          
            
              
      Loading

          
          
            
            
              author:
              Filter by this user
            
        
      
    
  

          

  
    Label
    
  
  
    
      
        Filter by label
        
          
        
      
      
        
      
      
        
      Loading

      
        
          Use alt + click/return to exclude labels
        
        
          or ⇧ + click/return for logical OR
        
      
    
  


        
            

        Projects
    
  
    
      
        Filter by project
        
          
        
      
      
        
      Loading

     
  


            

        Milestones
    
  
    
      
        Filter by milestone
        
          
        
      
      
        
      
      
        
      Loading

    
  


            
        Reviews
    
  
    
      
        Filter by reviews
        
          
        
      
      
          
            
            No reviews
          
          
            
            Review required
          
          
            
            Approved review
          
          
            
            Changes requested
          
      
    
  


        
        

  
    Assignee
    
  
  
    
      
        Filter by who’s assigned
        
          
        
      
      
        
      
      
        
          
            
            Assigned to nobody
          
          
            
      Loading

        
        
          
          
            assignee:
            Filter by this user
          
      
    
  


        

  
    Sort
    
  
  
    
      
        Sort by
        
          
        
      

      
          
            
            Newest
          
          
            
            Oldest
          
          
            
            Most commented
          
          
            
            Least commented
          
          
            
            Recently updated
          
          
            
            Least recently updated
          
          
            
            Best match
          

        Most reactions
        
            
              👍
            
            
              👎
            
            
              😄
            
            
              🎉
            
            
              😕
            
            
              ❤️
            
            
              🚀
            
            
              👀
            
        
      
    
  


      
  




      Pull requests list
      
        
              

  


    
      
        
      
    

    
    

      Update createmaintenanceendpoint.*.md


      
        
          #1340
            opened Apr 17, 2025 by
            ViniciusFXavier
            
        

        
          
  
    

  
    Loading…




        

        

      
    

    

      
      

      
        
          
          
        
      

      
      
    

      
  


              

  


    
      
        
      
    

    
    

      chore: fix semantic error


      
        
          #1339
            opened Mar 6, 2025 by
            katsyuta
            
        

        
          
  
    

  
    Loading…




        

        

      
    

    

      
          
              
                
                  
                  1
                
              
          
      

      
        
          
          
        
      

      
          
            
            6
          
      
    

      
  


              

  


    
      
        
      
    

    
    

      Translation of paragraphs 5.11, 5.12


      
        
          #1327
            opened Sep 12, 2024 by
            Omer-Levi
            
        

        
          
  
    

  
    Loading…




        

        

      
    

    

      
      

      
        
          
          
        
      

      
          
            
            8
          
      
    

      
  


              

  


    
      
        
      
    

    
    

      Update Chinese readme.MD


      
        
          #1301
            opened Jul 4, 2024 by
            davqi
            
        

        
          
  
    

  
    Loading…




        

        

      
    

    

      
      

      
        
          
          
        
      

      
      
    

      
  


              

  


    
      
        
      
    

    
    

      Add Ukrainian translation 🇺🇦


      
        
          #1294
            opened Feb 10, 2024 by
            Shramkoweb
            
        

        
          
  
    •
    
      Draft
    
  



        
          
  
      
        
      
      

  


    20 of 23 tasks
  



        

      
    

    

      
      

      
        
          
          
        
      

      
      
    

      
  


              

  


    
      
        
      
    

    
    

      fix : link to safe-regex lib


      
        
          #1291
            opened Dec 22, 2023 by
            damienmarchandfr
            
        

        
          
  
    

  
    Loading…




        

        

      
    

    

      
      

      
        
          
          
        
      

      
      
    

      
  


              

  


    
      
        
      
    

    
    

      Update README.md section4.8


      
        
          #1282
            opened Oct 12, 2023 by
            ShaiDemri
            
        

        
          
  
    

  
    Loading…




        

        

      
    

    

      
      

      
        
          
          
        
      

      
          
            
            1
          
      
    

      
  


              

  


    
      
        
      
    

    
    

      feat: add eslint rules tips of 2.2 仅使用内建的错误对象 in README.chinese


      
        
          #1280
            opened Sep 28, 2023 by
            fkworld
            
        

        
          
  
    

  
    Loading…




        

        

      
    

    

      
      

      
        
          
          
        
      

      
      
    

      
  


              

  


    
      
        
      
    

    
    

      README.spanish.md update to ongoing spanish translation


      
        
          #1279
            opened Sep 16, 2023 by
            GeekBeardLinks
            
        

        
          
  
    

  
    Loading…




        

        

      
    

    

      
      

      
        
          
          
        
      

      
          
            
            10
          
      
    

      
  


              

  


    
      
        
      
    

    
    

      fixed break lines between points


      
        
          #1278
            opened Sep 16, 2023 by
            GeekBeardLinks
            
        

        
          
  
    

  
    Loading…




        

        

      
    

    

      
      

      
        
          
          
        
      

      
      
    

      
  


              

  


    
      
        
      
    

    
    

      update reference eslint-plugin-node to eslint-plugin-n


      
        
          #1277
            opened Sep 16, 2023 by
            GeekBeardLinks
            
        

        
          
  
    

  
    Loading…




        

        

      
    

    

      
      

      
        
          
          
        
      

      
      
    

      
  


              

  


    
      
        
      
    

    
    

      Adding arabic tranlations


      
        
          #1276
            opened Sep 13, 2023 by
            TheCodby
            
        

        
          
  
    

  
    Loading…




        

        

      
    

    

      
      

      
        
          
          
        
      

      
          
            
            1
          
      
    

      
  


              

  


    
      
        
      
    

    
    

      docs: add omahs as a contributor for content


      
        
          #1275
            opened Sep 10, 2023 by
            allcontributors
            bot
        

        
          
  
    

  
    Loading…




        

        

      
    

    

      
      

      
        
          
          
        
      

      
      
    

      
  


              

  


    
      
        
      
    

    
    

      docs: add ShaiDemri as a contributor for content


      
        
          #1274
            opened Sep 10, 2023 by
            allcontributors
            bot
        

        
          
  
    

  
    Loading…




        

        

      
    

    

      
      

      
        
          
          
        
      

      
      
    

      
  


              

  


    
      
        
      
    

    
    

      Update README.hebrew.md


      
        
          #1272
            opened Aug 29, 2023 by
            ShaiDemri
            
        

        
          
  
    

  
    Loading…




        

        

      
    

    

      
      

      
        
          
          
        
      

      
          
            
            2
          
      
    

      
  


              

  


    
      
        
      
    

    
    

      Update section 5.12 README.hebrew.md


      
        
          #1271
            opened Aug 29, 2023 by
            ShaiDemri
            
        

        
          
  
    

  
    Loading…




        

        

      
    

    

      
      

      
        
          
          
        
      

      
          
            
            2
          
      
    

      
  


              

  


    
      
        
      
    

    
    

      Translate section 5.11 to Hebrew


      
        
          #1269
            opened Aug 23, 2023 by
            ShaiDemri
            
        

        
          
  
    

  
    Loading…




        

        

      
    

    

      
      

      
        
          
          
        
      

      
          
            
            2
          
      
    

      
  


              

  


    
      
        
      
    

    
    

      Update README.hebrew.md


      
        
          #1268
            opened Aug 21, 2023 by
            ShaiDemri
            
        

        
          
  
    

  
    Loading…




        

        

      
    

    

      
      

      
        
          
          
        
      

      
          
            
            5
          
      
    

      
  


              

  


    
      
        
      
    

    
    

      Add reference to the 'aaa-comments' ESLint rule


      
        
          #1265
            opened Aug 16, 2023 by
            MatanYadaev
            
        

        
          
  
    

  
    Loading…




        

        

      
    

    

      
      

      
        
          
          
        
      

      
      
    

      
  


              

  


    
      
        
      
    

    
    

      fix: code example 3.3 corrected


      
        
          #1250
            opened May 30, 2023 by
            keshav-bohr
            
        

        
          
  
    

  
    Loading…




        

        

      
    

    

      
      

      
        
          
          
        
      

      
      
    

      
  


              

  


    
      
        
      
    

    
    

      Fix avoid example in curly braces


      
        
          #1249
            opened May 25, 2023 by
            mwargan
            
        

        
          
  
    

  
    Loading…




        

        

      
    

    

      
      

      
        
          
          
        
      

      
          
            
            1
          
      
    

      
  


              

  


    
      
        
      
    

    
    

      fix link text


      
        
          #1248
            opened May 24, 2023 by
            Bouchra99
            
        

        
          
  
    

  
    Loading…




        

        

      
    

    

      
      

      
        
          
          
        
      

      
      
    

      
  


              

  


    
      
        
      
    

    
    

      Update README.md


      
        
          #1247
            opened May 12, 2023 by
            harshal-shinde
            
        

        
          
  
    

  
    Loading…




        

        

      
    

    

      
      

      
        
          
          
        
      

      
      
    

      
  


              

  


    
      
        
      
    

    
    

      Update last update badge to today [skip ci]


        
              

                auto-merge

              

                update-last-update-badge

        
      
        
          #1241
            opened May 9, 2023 by
            github-actions
            bot
        

        
          
  
    

  
    Loading…




        

        

      
    

    

      
      

      
        
          
          
        
      

      
      
    

      
  


              

  


    
      
        
      
    

    
    

      Create IND.png


      
        
          #1239
            opened May 4, 2023 by
            Gsdhumal07
            
        

        
          
  
    

  
    Loading…




        

        

      
    

    

      
      

      
        
          
          
        
      

      
          
            
            1
          
      
    

      
  


        
      
  

  
      Previous 1 2 Next
  

  
      Previous Next
  

  
  
  ProTip!
  What’s not been updated in a month: updated:<2025-03-26.\n\n\n\ngoldbergyoni
    
    /
    
      nodebestpractices
    

    Public
  


        

        
            
    
      

  
                Notifications
    You must be signed in to change notification settings

  

  
              Fork
    10.4k

  

  
        
            
          Star
          102k

  



        
      

        



          

  
      
  
    
              
        Code
          


    

      
  
    
              
        Issues
          44


    

      
  
    
              
        Pull requests
          36


    

      
  
    
              
        Actions
          


    

      
  
    
              
        Projects
          0


    

      
  
    
              
        Security
          

    

      
  
    
              
        Insights
          


    


          
  
      
Additional navigation options



  
    
                
  
    
        
    
    
    
        
          
        
      
        
          Code
      

  

        
    
    
    
        
          
        
      
        
          Issues
      

  

        
    
    
    
        
          
        
      
        
          Pull requests
      

  

        
    
    
    
        
          
        
      
        
          Actions
      

  

        
    
    
    
        
          
        
      
        
          Projects
      

  

        
    
    
    
        
          
        
      
        
          Security
      

  

        
    
    
    
        
          
        
      
        
          Insights
      

  

    




      
  



  

  




    
    



    
      
  Actions: goldbergyoni/nodebestpractices
  
  
    
      
                  

  
    Actions
  

  
    
      

        
  
  
    
        
          

    
    
    
      
        
                        All workflows

      

  


          
        
          


  
      
  
    Workflows
  

    
        

    
    
    
      
        
          
  automerge

      

  



        

    
    
    
      
        
          
  Lint & Generate HTML from Markdown

      

  



        

    
    
    
      
        
          
  Update date in last update badge

      

  



          

    
    
    
      
        
                        Show more workflows...

      

  






          
        
          


  
      
  
    Management
  

    
        

    
    
    
        
          
        
      
        
                        Caches

      

  


    



  

        
          
        

        
          
        
      
    



                
      

  
  
  
    
            
          
            
              All workflows
            
          
      
      
              All workflows
      


  
      
        
          
            Actions
          
          
            
          
        
      
    
      
                
        Loading...
        
      Loading

      
      
        Sorry, something went wrong.
      


    


      

      

                
          
  
    
    
    
      
    

    
      
        
      
      
        
        
        will be ignored since log searching is not yet available
      
    


        

  
            Showing runs from all workflows

            
  
    
    
    
      
    

    
      
        
      
      
        
        
        will be ignored since log searching is not yet available
      
    




      
    




  
    
      15 workflow runs
    
  


  
    
        
          15 workflow runs
        
    
    
      
  
      
    Event
  
    
      
    


    
      
  
    
      
        Filter by Event
      
        
    
    
      
    
  
              
              
  
      
        
      
    
      
                  Sorry, something went wrong.

            
            
                
      
        Filter
    
  
      
        
          
      Loading

      
    
      

      
  
  
  

    


      
        
          
          
            
                
                  
                    
                      
  
                    
                    
                        
                          
                          Sorry, something went wrong.
                        
                    
            
            
              No matching events.
            
        
      
  

      
  
      
    Status
  
    
      
    


    
      
  
    
      
        Filter by Status
      
        
    
    
      
    
  
              
              
  
      
        
      
    
      
                  Sorry, something went wrong.

            
            
                
      
        Filter
    
  
      
        
          
      Loading

      
    
      

      
  
  
  

    


      
        
          
          
            
                
                  
                    
                      
  
                    
                    
                        
                          
                          Sorry, something went wrong.
                        
                    
            
            
              No matching statuses.
            
        
      
  

      
  
      
    Branch
  
    
      
    


    
      
  
    
      
        Filter by Branch
      
        
    
    
      
    
  
              
              
  
      
        
      
    
      
                  Sorry, something went wrong.

            
            
                
      
        Filter
    
  
      
        
          
      Loading

      
    
      

      
  
  
  

    


      
        
          
          
            
                
                  
                    
                      
  
                    
                    
                        
                          
                          Sorry, something went wrong.
                        
                    
            
            
              No matching branches.
            
        
      
  

      
  
      
    Actor
  
    
      
    


    
      
  
    
      
        Filter by Actor
      
        
    
    
      
    
  
              
              
  
      
        
      
    
      
                  Sorry, something went wrong.

            
            
                
      
        Filter
    
  
      
        
          
      Loading

      
    
      

      
  
  
  

    


      
        
          
          
            
                
                  
                    
                      
  
                    
                    
                        
                          
                          Sorry, something went wrong.
                        
                    
            
            
              No matching users.
            
        
      
  

    
  


      


    
  
    
      
          

    


          
            Update createmaintenanceendpoint.*.md
          
        

      
        automerge
        #696:

        
            Pull request #1340

            opened
            by
              ViniciusFXavier
              
        
      

      
        
  
  April 17, 2025 15:57


          
    
    Action required
  

          ViniciusFXavier:update-createmaintenanceendpoint
      
    

    
        ViniciusFXavier:update-createmaintenanceendpoint
    

    
      
        
          
  
  April 17, 2025 15:57


            
    
    Action required
  

        

        
            
                    

              

                  
                    
                      View #1340
                    
                  

                  
                    
                      View workflow file
                    
                  


              
            
        
      
    
  


  
    
      
          

    


          
            Update createmaintenanceendpoint.*.md
          
        

      
        Lint & Generate HTML from Markdown
        #439:

        
            Pull request #1340

            opened
            by
              ViniciusFXavier
              
        
      

      
        
  
  April 17, 2025 15:57


          
    
    Action required
  

          ViniciusFXavier:update-createmaintenanceendpoint
      
    

    
        ViniciusFXavier:update-createmaintenanceendpoint
    

    
      
        
          
  
  April 17, 2025 15:57


            
    
    Action required
  

        

        
            
                    

              

                  
                    
                      View #1340
                    
                  

                  
                    
                      View workflow file
                    
                  


              
            
        
      
    
  


  
    
      
          

    


          
            Merge pull request #1286 from oxxxxxy/master
          
        

      
        Update date in last update badge
        #183:

        
            Commit c0b71cc

            pushed
            by
              elektronik2k5
              
        
      

      
        
  
  April 15, 2025 21:52


            
      
      
        4s
      
    

          master
      
    

    
        master
    

    
      
        
          
  
  April 15, 2025 21:52


              
      
      
        4s
      
    

        

        
            
                    

              


                  
                    
                      View workflow file
                    
                  


              
            
        
      
    
  


  
    
      
          

    


          
            Merge pull request #1286 from oxxxxxy/master
          
        

      
        Lint & Generate HTML from Markdown
        #438:

        
            Commit c0b71cc

            pushed
            by
              elektronik2k5
              
        
      

      
        
  
  April 15, 2025 21:52


            
      
      
        4s
      
    

          master
      
    

    
        master
    

    
      
        
          
  
  April 15, 2025 21:52


              
      
      
        4s
      
    

        

        
            
                    

              


                  
                    
                      View workflow file
                    
                  


              
            
        
      
    
  


  
    
      
          

    


          
            automerge
          
        

      
        automerge
        #695:

        

            submitted
            by
              elektronik2k5
              
        
      

      
        
  
  March 7, 2025 16:40


            
      
      
        13s
      
    

      
    

    
    

    
      
        
          
  
  March 7, 2025 16:40


              
      
      
        13s
      
    

        

        
            
                    

              


                  
                    
                      View workflow file
                    
                  


              
            
        
      
    
  


  
    
      
          

    


          
            automerge
          
        

      
        automerge
        #694:

        

            submitted
            by
              katsyuta
              
        
      

      
        
  
  March 7, 2025 15:57


            
      
      
        15s
      
    

      
    

    
    

    
      
        
          
  
  March 7, 2025 15:57


              
      
      
        15s
      
    

        

        
            
                    

              


                  
                    
                      View workflow file
                    
                  


              
            
        
      
    
  


  
    
      
          

    


          
            chore: fix semantic error
          
        

      
        Lint & Generate HTML from Markdown
        #437:

        
            Pull request #1339

            synchronize
            by
              katsyuta
              
        
      

      
        
  
  March 7, 2025 15:55


            
      
      
        23s
      
    

          katsyuta:fix-semantic-error
      
    

    
        katsyuta:fix-semantic-error
    

    
      
        
          
  
  March 7, 2025 15:55


              
      
      
        23s
      
    

        

        
            
                    

              

                  
                    
                      View #1339
                    
                  

                  
                    
                      View workflow file
                    
                  


              
            
        
      
    
  


  
    
      
          

    


          
            chore: fix semantic error
          
        

      
        automerge
        #693:

        
            Pull request #1339

            synchronize
            by
              katsyuta
              
        
      

      
        
  
  March 7, 2025 15:55


            
      
      
        12s
      
    

          katsyuta:fix-semantic-error
      
    

    
        katsyuta:fix-semantic-error
    

    
      
        
          
  
  March 7, 2025 15:55


              
      
      
        12s
      
    

        

        
            
                    

              

                  
                    
                      View #1339
                    
                  

                  
                    
                      View workflow file
                    
                  


              
            
        
      
    
  


  
    
      
          

    


          
            README.spanish.md update to ongoing spanish translation
          
        

      
        Lint & Generate HTML from Markdown
        #435:

        
            Pull request #1279

            synchronize
            by
              GeekBeardLinks
              
        
      

      
        
  
  January 28, 2025 11:55


            
      
      
        26s
      
    

          GeekBeardLinks:readme-spanish-update
      
    

    
        GeekBeardLinks:readme-spanish-update
    

    
      
        
          
  
  January 28, 2025 11:55


              
      
      
        26s
      
    

        

        
            
                    

              

                  
                    
                      View #1279
                    
                  

                  
                    
                      View workflow file
                    
                  


              
            
        
      
    
  


  
    
      
          

    


          
            README.spanish.md update to ongoing spanish translation
          
        

      
        automerge
        #690:

        
            Pull request #1279

            synchronize
            by
              GeekBeardLinks
              
        
      

      
        
  
  January 28, 2025 11:55


            
      
      
        10s
      
    

          GeekBeardLinks:readme-spanish-update
      
    

    
        GeekBeardLinks:readme-spanish-update
    

    
      
        
          
  
  January 28, 2025 11:55


              
      
      
        10s
      
    

        

        
            
                    

              

                  
                    
                      View #1279
                    
                  

                  
                    
                      View workflow file
                    
                  


              
            
        
      
    
  


  
    
      
          

    


          
            README.spanish.md update to ongoing spanish translation
          
        

      
        automerge
        #689:

        
            Pull request #1279

            synchronize
            by
              GeekBeardLinks
              
        
      

      
        
  
  January 28, 2025 11:53


            
      
      
        12s
      
    

          GeekBeardLinks:readme-spanish-update
      
    

    
        GeekBeardLinks:readme-spanish-update
    

    
      
        
          
  
  January 28, 2025 11:53


              
      
      
        12s
      
    

        

        
            
                    

              

                  
                    
                      View #1279
                    
                  

                  
                    
                      View workflow file
                    
                  


              
            
        
      
    
  


  
    
      
          

    


          
            README.spanish.md update to ongoing spanish translation
          
        

      
        Lint & Generate HTML from Markdown
        #434:

        
            Pull request #1279

            synchronize
            by
              GeekBeardLinks
              
        
      

      
        
  
  January 28, 2025 11:53


            
      
      
        18s
      
    

          GeekBeardLinks:readme-spanish-update
      
    

    
        GeekBeardLinks:readme-spanish-update
    

    
      
        
          
  
  January 28, 2025 11:53


              
      
      
        18s
      
    

        

        
            
                    

              

                  
                    
                      View #1279
                    
                  

                  
                    
                      View workflow file
                    
                  


              
            
        
      
    
  


  
    
      
          

    


          
            automerge
          
        

      
        automerge
        #674:

        

            submitted
            by
              LazyCompiler
              
        
      

      
        
  
  September 12, 2024 21:49


            
      
      
        1m 28s
      
    

      
    

    
    

    
      
        
          
  
  September 12, 2024 21:49


              
      
      
        1m 28s
      
    

        

        
            
                    

              


                  
                    
                      View workflow file
                    
                  


              
            
        
      
    
  


  
    
      
          

    


          
            Translation of paragraphs 5.11, 5.12
          
        

      
        automerge
        #673:

        
            Pull request #1327

            opened
            by
              Omer-Levi
              
        
      

      
        
  
  September 12, 2024 10:51


            
      
      
        1m 54s
      
    

          Omer-Levi:translations-hebrew
      
    

    
        Omer-Levi:translations-hebrew
    

    
      
        
          
  
  September 12, 2024 10:51


              
      
      
        1m 54s
      
    

        

        
            
                    

              

                  
                    
                      View #1327
                    
                  

                  
                    
                      View workflow file
                    
                  


              
            
        
      
    
  


  
    
      
          

    


          
            Translation of paragraphs 5.11, 5.12
          
        

      
        Lint & Generate HTML from Markdown
        #421:

        
            Pull request #1327

            opened
            by
              Omer-Levi
              
        
      

      
        
  
  September 12, 2024 10:51


            
      
      
        18s
      
    

          Omer-Levi:translations-hebrew
      
    

    
        Omer-Levi:translations-hebrew
    

    
      
        
          
  
  September 12, 2024 10:51


              
      
      
        18s
      
    

        

        
            
                    

              

                  
                    
                      View #1327
                    
                  

                  
                    
                      View workflow file\n\n\n\ngoldbergyoni
    
    /
    
      nodebestpractices
    

    Public
  


        

        
            
    
      

  
                Notifications
    You must be signed in to change notification settings

  

  
              Fork
    10.4k

  

  
        
            
          Star
          102k

  



        
      

        



          

  
      
  
    
              
        Code
          


    

      
  
    
              
        Issues
          44


    

      
  
    
              
        Pull requests
          36


    

      
  
    
              
        Actions
          


    

      
  
    
              
        Projects
          0


    

      
  
    
              
        Security
          

    

      
  
    
              
        Insights
          


    


          
  
      
Additional navigation options



  
    
                
  
    
        
    
    
    
        
          
        
      
        
          Code
      

  

        
    
    
    
        
          
        
      
        
          Issues
      

  

        
    
    
    
        
          
        
      
        
          Pull requests
      

  

        
    
    
    
        
          
        
      
        
          Actions
      

  

        
    
    
    
        
          
        
      
        
          Projects
      

  

        
    
    
    
        
          
        
      
        
          Security
      

  

        
    
    
    
        
          
        
      
        
          Insights
      

  

    




      
  



  

  




    
    



    
      
    
      
  goldbergyoni/nodebestpractices projects
  
    
  
      

    
        
      
      
          
            
              
  
    
      
      
        Search all projects
    
  
      
        
      
    
      
      
        
      

      
  
  
  

    


    
    







  Search results
  
    0 open and 0 closed projects found.
  
  
  
    
                    
  
    
      

            No open projects\n\n\n\ngoldbergyoni
    
    /
    
      nodebestpractices
    

    Public
  


        

        
            
    
      

  
                Notifications
    You must be signed in to change notification settings

  

  
              Fork
    10.4k

  

  
        
            
          Star
          102k

  



        
      

        



          

  
      
  
    
              
        Code
          


    

      
  
    
              
        Issues
          44


    

      
  
    
              
        Pull requests
          36


    

      
  
    
              
        Actions
          


    

      
  
    
              
        Projects
          0


    

      
  
    
              
        Security
          

    

      
  
    
              
        Insights
          


    


          
  
      
Additional navigation options



  
    
                
  
    
        
    
    
    
        
          
        
      
        
          Code
      

  

        
    
    
    
        
          
        
      
        
          Issues
      

  

        
    
    
    
        
          
        
      
        
          Pull requests
      

  

        
    
    
    
        
          
        
      
        
          Actions
      

  

        
    
    
    
        
          
        
      
        
          Projects
      

  

        
    
    
    
        
          
        
      
        
          Security
      

  

        
    
    
    
        
          
        
      
        
          Insights
      

  

    




      
  



  

  




    
    



    
      
Security: goldbergyoni/nodebestpractices



    
    
    
  Security
  
  


  
  
    
    No security policy detected
  
    This project has not set up a SECURITY.md file yet.





    
  
    
      

              There aren’t any published security advisories\n\n\n\ngoldbergyoni
    
    /
    
      nodebestpractices
    

    Public
  


        

        
            
    
      

  
                Notifications
    You must be signed in to change notification settings

  

  
              Fork
    10.4k

  

  
        
            
          Star
          102k

  



        
      

        



          

  
      
  
    
              
        Code
          


    

      
  
    
              
        Issues
          44


    

      
  
    
              
        Pull requests
          36


    

      
  
    
              
        Actions
          


    

      
  
    
              
        Projects
          0


    

      
  
    
              
        Security
          

    

      
  
    
              
        Insights
          


    


          
  
      
Additional navigation options



  
    
                
  
    
        
    
    
    
        
          
        
      
        
          Code
      

  

        
    
    
    
        
          
        
      
        
          Issues
      

  

        
    
    
    
        
          
        
      
        
          Pull requests
      

  

        
    
    
    
        
          
        
      
        
          Actions
      

  

        
    
    
    
        
          
        
      
        
          Projects
      

  

        
    
    
    
        
          
        
      
        
          Security
      

  

        
    
    
    
        
          
        
      
        
          Insights
      

  

    




      
  



  

  




    
    



    
      
Insights: goldbergyoni/nodebestpractices

  
  
        

  
    Pulse
    Contributors
      Community Standards
    Commits
    Code frequency
      Dependency graph
    Network
    Forks
  



  
      
  
  April 19, 2025 – April 26, 2025
  
        
              Period:
          1 week
        
          
            Filter activity
          
          
              
                
                24 hours
              
              
                
                3 days
              
              
                
                1 week
              
              
                
                1 month
              
          
        
      


  
    
      Overview
    

    
      
        
          
          
          
            0
            Active pull requests
          
        

        
          
          
          
            0
            Active issues
          
        
      

      
        
          
                
                  
                  0
                
                Merged pull requests
          
          
              
                
                0
              
              Open pull requests
          
          
              
                
                0
              
              Closed issues
          
          
              
                
                0
              
              New issues
          
        
      
    
  

    
  
      There hasn’t been any commit activity on goldbergyoni/nodebestpractices in the last  week.

        Want to help out?
          
            
                    
                Fork this repository\n\n\n\ngoldbergyoni
    
    /
    
      nodebestpractices
    

    Public
  


        

        
            
    
      

  
                Notifications
    You must be signed in to change notification settings

  

  
              Fork
    10.4k

  

  
        
            
          Star
          102k

  



        
      

        



          

  
      
  
    
              
        Code
          


    

      
  
    
              
        Issues
          44


    

      
  
    
              
        Pull requests
          36


    

      
  
    
              
        Actions
          


    

      
  
    
              
        Projects
          0


    

      
  
    
              
        Security
          

    

      
  
    
              
        Insights
          


    


          
  
      
Additional navigation options



  
    
                
  
    
        
    
    
    
        
          
        
      
        
          Code
      

  

        
    
    
    
        
          
        
      
        
          Issues
      

  

        
    
    
    
        
          
        
      
        
          Pull requests
      

  

        
    
    
    
        
          
        
      
        
          Actions
      

  

        
    
    
    
        
          
        
      
        
          Projects
      

  

        
    
    
    
        
          
        
      
        
          Security
      

  

        
    
    
    
        
          
        
      
        
          Insights
      

  

    




      
  



  

  




    
    



    
      
    









  
  
    CommitsBranch selector masterUser selectorAll usersDatepickerAll timeCommit HistoryCommits on Apr 15, 2025Merge pull request #1286 from oxxxxxy/masterShow description for c0b71ccelektronik2k5authoredc0b71ccCopy full SHA for c0b71ccCommits on Mar 6, 2024Merge pull request #1287 from animir/patch-4Show description for 54f8732goldbergyoniauthored54f8732Copy full SHA for 54f8732Commits on Feb 27, 2024Merge branch 'goldbergyoni:master' into patch-4animirauthored0a444a9Copy full SHA for 0a444a9Commits on Feb 7, 2024Update README.mdgoldbergyoniauthoredd330711Copy full SHA for d330711Commits on Nov 11, 2023Update limitrequests.mdShow description for 6d4e0caanimirauthored6d4e0caCopy full SHA for 6d4e0caCommits on Nov 6, 2023fixed path to the checklist.png at test-five-outcomes.mdoxxxxxyauthoredd0d3493Copy full SHA for d0d3493Commits on Sep 21, 2023Merge pull request #1252 from look4regev/patch-1Show description for a9bd2bfrluvatonauthoreda9bd2bfCopy full SHA for a9bd2bfCommits on Sep 10, 2023Merge pull request #1273 from omahs/patch-1Show description for 544eccegoldbergyoniauthored544ecceCopy full SHA for 544ecceMerge pull request #1267 from hodbauer/hebrew-translation-introShow description for 896756bgoldbergyoniauthored896756bCopy full SHA for 896756bCommits on Sep 3, 2023fix typosomahsauthored8d825fcCopy full SHA for 8d825fcCommits on Aug 20, 2023Update README.mdShow description for 360868bhodbauerauthored360868bCopy full SHA for 360868bCommits on Aug 16, 2023Update README.hebrew.mdShow description for c9547bfhodbauerauthoredc9547bfCopy full SHA for c9547bfUpdate README.hebrew.mdShow description for efdd0f2hodbauerauthoredefdd0f2Copy full SHA for efdd0f2Commits on Aug 15, 2023Merge pull request #1263 from hodbauer/hebrew-translation-2023Show description for 94d9324goldbergyoniauthored94d9324Copy full SHA for 94d9324Commits on Aug 13, 2023Merge branch 'goldbergyoni:master' into hebrew-translation-2023hodbauerauthoredbcba380Copy full SHA for bcba380Commits on Aug 10, 2023translate section 5.10hodbauerauthoredd354129Copy full SHA for d354129translate section 5.9hodbauerauthored1f0d733Copy full SHA for 1f0d733translate section 5.8hodbauerauthoredb9968efCopy full SHA for b9968efCommits on Aug 8, 2023translate section 5.7hodbauerauthoredced052aCopy full SHA for ced052aCommits on Aug 7, 2023translate section 5.6hodbauerauthoreda1380caCopy full SHA for a1380caCommits on Aug 6, 2023translate section 5.5hodbauerauthored1f58131Copy full SHA for 1f58131Commits on Aug 5, 2023Merge pull request #1262 from andersonjoseph/fix-env-varShow description for 1cee119rluvatonauthored1cee119Copy full SHA for 1cee119Commits on Aug 4, 2023fix broken env-var broken linkandersonjosephauthoredf8534c6Copy full SHA for f8534c6Commits on Aug 2, 2023Merge pull request #1260 from djalilhebal/patch-1Show description for 5cc425crluvatonauthored5cc425cCopy full SHA for 5cc425cCommits on Aug 1, 2023translate section 5.4hodbauerauthored154a31dCopy full SHA for 154a31dtranslate section 5.3hodbauerauthored37a1a44Copy full SHA for 37a1a44translate section 5.2hodbauerauthoredc2cf071Copy full SHA for c2cf071translate section 5.1hodbauerauthoredc658135Copy full SHA for c658135Commits on Jul 30, 2023[doc] Line break curly braces- Same line Avoid examplelook4regevcommitted845dc5eCopy full SHA for 845dc5eCommits on Jul 28, 2023Fix typos and grammar in returningpromises.mddjalilhebalauthoredd7490baCopy full SHA for d7490baMerge pull request #1258 from muratcankirdar/3.3-fix-code-sampleShow description for 5694ed7rluvatonauthored5694ed7Copy full SHA for 5694ed7Merge pull request #1259 from eltociear/patch-1Show description for d3b764frluvatonauthoredd3b764fCopy full SHA for d3b764fCommits on Jul 27, 2023Fix typo in readme-general-toc-4.mdShow description for 27032a9Ikko Eltociear Ashimineauthored27032a9Copy full SHA for 27032a9Commits on Jul 26, 2023fix code sample for 3.3 in polishmuratcankirdarcommittedfedb0bdCopy full SHA for fedb0bdfix code sample for example 3.3muratcankirdarcommitted4c632f5Copy full SHA for 4c632f5PaginationPreviousNext\n\n\n\ngoldbergyoni
    
    /
    
      nodebestpractices
    

    Public
  


        

        
            
    
      

  
                Notifications
    You must be signed in to change notification settings

  

  
              Fork
    10.4k

  

  
        
            
          Star
          102k

  



        
      

        



          

  
      
  
    
              
        Code
          


    

      
  
    
              
        Issues
          44


    

      
  
    
              
        Pull requests
          36


    

      
  
    
              
        Actions
          


    

      
  
    
              
        Projects
          0


    

      
  
    
              
        Security
          

    

      
  
    
              
        Insights
          


    


          
  
      
Additional navigation options



  
    
                
  
    
        
    
    
    
        
          
        
      
        
          Code
      

  

        
    
    
    
        
          
        
      
        
          Issues
      

  

        
    
    
    
        
          
        
      
        
          Pull requests
      

  

        
    
    
    
        
          
        
      
        
          Actions
      

  

        
    
    
    
        
          
        
      
        
          Projects
      

  

        
    
    
    
        
          
        
      
        
          Security
      

  

        
    
    
    
        
          
        
      
        
          Insights
      

  

    




      
  



  

  




    
    



    
      
    









  
  
     Files masterBreadcrumbsnodebestpractices/.github/Copy pathDirectory actionsMore optionsDirectory actionsMore optionsLatest commit HistoryHistory masterBreadcrumbsnodebestpractices/.github/TopFolders and filesNameNameLast commit messageLast commit dateparent directory..workflowsworkflows  stale.ymlstale.yml  View all files\n\n\n\ngoldbergyoni
    
    /
    
      nodebestpractices
    

    Public
  


        

        
            
    
      

  
                Notifications
    You must be signed in to change notification settings

  

  
              Fork
    10.4k

  

  
        
            
          Star
          102k

  



        
      

        



          

  
      
  
    
              
        Code
          


    

      
  
    
              
        Issues
          44


    

      
  
    
              
        Pull requests
          36


    

      
  
    
              
        Actions
          


    

      
  
    
              
        Projects
          0


    

      
  
    
              
        Security
          

    

      
  
    
              
        Insights
          


    


          
  
      
Additional navigation options



  
    
                
  
    
        
    
    
    
        
          
        
      
        
          Code
      

  

        
    
    
    
        
          
        
      
        
          Issues
      

  

        
    
    
    
        
          
        
      
        
          Pull requests
      

  

        
    
    
    
        
          
        
      
        
          Actions
      

  

        
    
    
    
        
          
        
      
        
          Projects
      

  

        
    
    
    
        
          
        
      
        
          Security
      

  

        
    
    
    
        
          
        
      
        
          Insights
      

  

    




      
  



  

  




    
    



    
      
    









  
  
     Files masterBreadcrumbsnodebestpractices/.operations/Copy pathDirectory actionsMore optionsDirectory actionsMore optionsLatest commit HistoryHistory masterBreadcrumbsnodebestpractices/.operations/TopFolders and filesNameNameLast commit messageLast commit dateparent directory...markdownlint.json.markdownlint.json  CONTRIBUTING.mdCONTRIBUTING.md  common-answers.mdcommon-answers.md  operations-manual.mdoperations-manual.md  writing-guidelines.basque.mdwriting-guidelines.basque.md  writing-guidelines.chinese.mdwriting-guidelines.chinese.md  writing-guidelines.french.mdwriting-guidelines.french.md  writing-guidelines.indonesia.mdwriting-guidelines.indonesia.md  writing-guidelines.japanese.mdwriting-guidelines.japanese.md  writing-guidelines.mdwriting-guidelines.md  writing-guidelines.polish.mdwriting-guidelines.polish.md  writing-guidelines.russian.mdwriting-guidelines.russian.md  View all files\n\n\n\ngoldbergyoni
    
    /
    
      nodebestpractices
    

    Public
  


        

        
            
    
      

  
                Notifications
    You must be signed in to change notification settings

  

  
              Fork
    10.4k

  

  
        
            
          Star
          102k

  



        
      

        



          

  
      
  
    
              
        Code
          


    

      
  
    
              
        Issues
          44


    

      
  
    
              
        Pull requests
          36


    

      
  
    
              
        Actions
          


    

      
  
    
              
        Projects
          0


    

      
  
    
              
        Security
          

    

      
  
    
              
        Insights
          


    


          
  
      
Additional navigation options



  
    
                
  
    
        
    
    
    
        
          
        
      
        
          Code
      

  

        
    
    
    
        
          
        
      
        
          Issues
      

  

        
    
    
    
        
          
        
      
        
          Pull requests
      

  

        
    
    
    
        
          
        
      
        
          Actions
      

  

        
    
    
    
        
          
        
      
        
          Projects
      

  

        
    
    
    
        
          
        
      
        
          Security
      

  

        
    
    
    
        
          
        
      
        
          Insights
      

  

    




      
  



  

  




    
    



    
      
    









  
  
     Files masterBreadcrumbsnodebestpractices/assets/Copy pathDirectory actionsMore optionsDirectory actionsMore optionsLatest commit HistoryHistory masterBreadcrumbsnodebestpractices/assets/TopFolders and filesNameNameLast commit messageLast commit dateparent directory..flagsflags  imagesimages  View all files\n\n\n\ngoldbergyoni
    
    /
    
      nodebestpractices
    

    Public
  


        

        
            
    
      

  
                Notifications
    You must be signed in to change notification settings

  

  
              Fork
    10.4k

  

  
        
            
          Star
          102k

  



        
      

        



          

  
      
  
    
              
        Code
          


    

      
  
    
              
        Issues
          44


    

      
  
    
              
        Pull requests
          36


    

      
  
    
              
        Actions
          


    

      
  
    
              
        Projects
          0


    

      
  
    
              
        Security
          

    

      
  
    
              
        Insights
          


    


          
  
      
Additional navigation options



  
    
                
  
    
        
    
    
    
        
          
        
      
        
          Code
      

  

        
    
    
    
        
          
        
      
        
          Issues
      

  

        
    
    
    
        
          
        
      
        
          Pull requests
      

  

        
    
    
    
        
          
        
      
        
          Actions
      

  

        
    
    
    
        
          
        
      
        
          Projects
      

  

        
    
    
    
        
          
        
      
        
          Security
      

  

        
    
    
    
        
          
        
      
        
          Insights
      

  

    




      
  



  

  




    
    



    
      
    









  
  
     Files masterBreadcrumbsnodebestpractices/sections/Copy pathDirectory actionsMore optionsDirectory actionsMore optionsLatest commit HistoryHistory masterBreadcrumbsnodebestpractices/sections/TopFolders and filesNameNameLast commit messageLast commit dateparent directory..codestylepracticescodestylepractices  dockerdocker  draftsdrafts  errorhandlingerrorhandling  examples/dockerfileexamples/dockerfile  performanceperformance  productionproduction  projectstructreprojectstructre  securitysecurity  testingandqualitytestingandquality  template.basque.mdtemplate.basque.md  template.mdtemplate.md  View all files\n\n\n\ngoldbergyoni
    
    /
    
      nodebestpractices
    

    Public
  


        

        
            
    
      

  
                Notifications
    You must be signed in to change notification settings

  

  
              Fork
    10.4k

  

  
        
            
          Star
          102k

  



        
      

        



          

  
      
  
    
              
        Code
          


    

      
  
    
              
        Issues
          44


    

      
  
    
              
        Pull requests
          36


    

      
  
    
              
        Actions
          


    

      
  
    
              
        Projects
          0


    

      
  
    
              
        Security
          

    

      
  
    
              
        Insights
          


    


          
  
      
Additional navigation options



  
    
                
  
    
        
    
    
    
        
          
        
      
        
          Code
      

  

        
    
    
    
        
          
        
      
        
          Issues
      

  

        
    
    
    
        
          
        
      
        
          Pull requests
      

  

        
    
    
    
        
          
        
      
        
          Actions
      

  

        
    
    
    
        
          
        
      
        
          Projects
      

  

        
    
    
    
        
          
        
      
        
          Security
      

  

        
    
    
    
        
          
        
      
        
          Insights
      

  

    




      
  



  

  




    
    



    
      
    









  
  
     Files masterBreadcrumbsnodebestpractices/.all-contributorsrcCopy path Blame  Blame        Latest commit HistoryHistory1761 lines (1761 loc) · 47.7 KB masterBreadcrumbsnodebestpractices/.all-contributorsrcTopFile metadata and controlsCodeBlame1761 lines (1761 loc) · 47.7 KBRaw1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000{  "files": [    "README.basque.md",    "README.brazilian-portuguese.md",    "README.chinese.md",    "README.french.md",    "README.indonesian.md",    "README.japanese.md",    "README.korean.md",    "README.md",    "README.polish.md",    "README.russian.md"  ],  "imageSize": 100,  "contributorsPerLine": 7,  "contributorTemplate": "<a href=\"<%= contributor.profile %>\"><img src=\"<%= contributor.avatar_url %>\" width=\"<%= options.imageSize %>px;\" alt=\"<%= contributor.name %>\"style=\"max-width:<%= options.imageSize %>px;min-width:<%= options.imageSize %>px;\" /><br /><sub style=\"white-space: nowrap;overflow: hidden;text-overflow: ellipsis;\"><b><%= contributor.name %></b></sub></a><br /><%= contributions %>",  "badgeTemplate": "[![All Contributors](https://img.shields.io/badge/all_contributors-<%= contributors.length %>-orange.svg?style=flat-square)](#contributors)",  "contributors": [    {      "login": "kevinrambaud",      "name": "Kevin Rambaud",      "avatar_url": "https://avatars1.githubusercontent.com/u/7501477?v=4",      "profile": "https://github.com/kevinrambaud",      "contributions": [        "content"      ]    },    {      "login": "mfine15",      "name": "Michael Fine",      "avatar_url": "https://avatars1.githubusercontent.com/u/1286554?v=4",      "profile": "https://github.com/mfine15",      "contributions": [        "content"      ]    },    {      "login": "squgeim",      "name": "Shreya Dahal",      "avatar_url": "https://avatars0.githubusercontent.com/u/4996818?v=4",      "profile": "http://squgeim.github.io",      "contributions": [        "content"      ]    },    {      "login": "matheusrocha89",      "name": "Matheus Cruz Rocha",      "avatar_url": "https://avatars1.githubusercontent.com/u/3718366?v=4",      "profile": "http://matheusrocha89.com",      "contributions": [        "content"      ]    },    {      "login": "BitYog",      "name": "Yog Mehta",      "avatar_url": "https://avatars2.githubusercontent.com/u/28219178?v=4",      "profile": "https://bityog.github.io/Portfolio/",      "contributions": [        "content"      ]    },    {      "login": "kudapara",      "name": "Kudakwashe Paradzayi",      "avatar_url": "https://avatars3.githubusercontent.com/u/13519184?v=4",      "profile": "http://kudapara.co.zw",      "contributions": [        "content"      ]    },    {      "login": "t1st3",      "name": "t1st3",      "avatar_url": "https://avatars1.githubusercontent.com/u/1469638?v=4",      "profile": "https://www.t1st3.com/",      "contributions": [        "content"      ]    },    {      "login": "mulijordan1976",      "name": "mulijordan1976",      "avatar_url": "https://avatars0.githubusercontent.com/u/33382022?v=4",      "profile": "https://github.com/mulijordan1976",      "contributions": [        "content"      ]    },    {      "login": "matchai",      "name": "Matan Kushner",      "avatar_url": "https://avatars0.githubusercontent.com/u/4658208?v=4",      "profile": "https://twitter.com/matchai",      "contributions": [        "content"      ]    },    {      "login": "fabiothiroki",      "name": "Fabio Hiroki",      "avatar_url": "https://avatars2.githubusercontent.com/u/670057?v=4",      "profile": "https://fabiothiroki.github.io",      "contributions": [        "content"      ]    },    {      "login": "jsumners",      "name": "James Sumners",      "avatar_url": "https://avatars1.githubusercontent.com/u/321201?v=4",      "profile": "http://james.sumners.info/",      "contributions": [        "content"      ]    },    {      "login": "dan-gamble",      "name": "Dan Gamble",      "avatar_url": "https://avatars2.githubusercontent.com/u/7152041?v=4",      "profile": "https://twitter.com/_DanGamble",      "contributions": [        "content"      ]    },    {      "login": "trainorpj",      "name": "PJ Trainor",      "avatar_url": "https://avatars3.githubusercontent.com/u/13276704?v=4",      "profile": "https://github.com/trainorpj",      "contributions": [        "content"      ]    },    {      "login": "reod",      "name": "Remek Ambroziak",      "avatar_url": "https://avatars0.githubusercontent.com/u/3164299?v=4",      "profile": "https://github.com/reod",      "contributions": [        "content"      ]    },    {      "login": "yonjah",      "name": "Yoni Jah",      "avatar_url": "https://avatars0.githubusercontent.com/u/1829789?v=4",      "profile": "https://ca.non.co.il",      "contributions": [        "content"      ]    },    {      "login": "hazolsky",      "name": "Misha Khokhlov",      "avatar_url": "https://avatars1.githubusercontent.com/u/1270790?v=4",      "profile": "https://github.com/hazolsky",      "contributions": [        "content"      ]    },    {      "login": "EvgenyOrekhov",      "name": "Evgeny Orekhov",      "avatar_url": "https://avatars3.githubusercontent.com/u/8045060?v=4",      "profile": "https://plus.google.com/+ЕвгенийОрехов/",      "contributions": [        "content"      ]    },    {      "login": "gediminasml",      "name": "-",      "avatar_url": "https://avatars3.githubusercontent.com/u/19854105?v=4",      "profile": "https://github.com/gediminasml",      "contributions": [        "content"      ]    },    {      "login": "hisaac",      "name": "Isaac Halvorson",      "avatar_url": "https://avatars3.githubusercontent.com/u/923876?v=4",      "profile": "http://hisaac.net",      "contributions": [        "content"      ]    },    {      "login": "vkaracic",      "name": "Vedran Karačić",      "avatar_url": "https://avatars3.githubusercontent.com/u/2808092?v=4",      "profile": "http://www.vedrankaracic.com",      "contributions": [        "content"      ]    },    {      "login": "lallenlowe",      "name": "lallenlowe",      "avatar_url": "https://avatars3.githubusercontent.com/u/10761165?v=4",      "profile": "https://github.com/lallenlowe",      "contributions": [        "content"      ]    },    {      "login": "nwwells",      "name": "Nathan Wells",      "avatar_url": "https://avatars2.githubusercontent.com/u/1039473?v=4",      "profile": "https://github.com/nwwells",      "contributions": [        "content"      ]    },    {      "login": "paulovitin",      "name": "Paulo Reis",      "avatar_url": "https://avatars0.githubusercontent.com/u/125503?v=4",      "profile": "https://github.com/paulovitin",      "contributions": [        "content"      ]    },    {      "login": "syzer",      "name": "syzer",      "avatar_url": "https://avatars2.githubusercontent.com/u/1989646?v=4",      "profile": "https://snap.simpego.ch",      "contributions": [        "content"      ]    },    {      "login": "davesnx",      "name": "David Sancho",      "avatar_url": "https://avatars0.githubusercontent.com/u/3763599?v=4",      "profile": "http://sancho.dev",      "contributions": [        "content"      ]    },    {      "login": "pupix",      "name": "Robert Manolea",      "avatar_url": "https://avatars0.githubusercontent.com/u/4929965?v=4",      "profile": "https://apiforge.it",      "contributions": [        "content"      ]    },    {      "login": "spaxe",      "name": "Xavier Ho",      "avatar_url": "https://avatars2.githubusercontent.com/u/708395?v=4",      "profile": "https://jumptoglide.com",      "contributions": [        "content"      ]    },    {      "login": "ocularrhythm",      "name": "Aaron",      "avatar_url": "https://avatars0.githubusercontent.com/u/2738518?v=4",      "profile": "http://www.ocular-rhythm.io",      "contributions": [        "content"      ]    },    {      "login": "septa97",      "name": "Jan Charles Maghirang Adona",      "avatar_url": "https://avatars2.githubusercontent.com/u/13742634?v=4",      "profile": "https://septa97.me",      "contributions": [        "content"      ]    },    {      "login": "AllenFang",      "name": "Allen",      "avatar_url": "https://avatars2.githubusercontent.com/u/5351390?v=4",      "profile": "https://www.cakeresume.com/allenfang",      "contributions": [        "content"      ]    },    {      "login": "leonardovillela",      "name": "Leonardo Villela",      "avatar_url": "https://avatars3.githubusercontent.com/u/8650543?v=4",      "profile": "https://github.com/leonardovillela",      "contributions": [        "content"      ]    },    {      "login": "MichalZalecki",      "name": "Michał Załęcki",      "avatar_url": "https://avatars1.githubusercontent.com/u/3136577?v=4",      "profile": "https://michalzalecki.com",      "contributions": [        "content"      ]    },    {      "login": "chrisnicola",      "name": "Chris Nicola",      "avatar_url": "https://avatars1.githubusercontent.com/u/156449?v=4",      "profile": "http://www.wealthbar.com",      "contributions": [        "content"      ]    },    {      "login": "aecorredor",      "name": "Alejandro Corredor",      "avatar_url": "https://avatars3.githubusercontent.com/u/9114987?v=4",      "profile": "https://twitter.com/aecorredor",      "contributions": [        "content"      ]    },    {      "login": "cwar",      "name": "cwar",      "avatar_url": "https://avatars3.githubusercontent.com/u/272843?v=4",      "profile": "https://github.com/cwar",      "contributions": [        "content"      ]    },    {      "login": "keyfoxth",      "name": "Yuwei",      "avatar_url": "https://avatars3.githubusercontent.com/u/10647132?v=4",      "profile": "https://github.com/keyfoxth",      "contributions": [        "content"      ]    },    {      "login": "utkarshbhatt12",      "name": "Utkarsh Bhatt",      "avatar_url": "https://avatars3.githubusercontent.com/u/10895594?v=4",      "profile": "https://bigcodenerd.org",      "contributions": [        "content"      ]    },    {      "login": "duartemendes",      "name": "Duarte Mendes",      "avatar_url": "https://avatars2.githubusercontent.com/u/12852058?v=4",      "profile": "https://github.com/duartemendes",      "contributions": [        "content"      ]    },    {      "login": "serv",      "name": "Jason Kim",      "avatar_url": "https://avatars2.githubusercontent.com/u/103456?v=4",      "profile": "http://jasonkim.ca",      "contributions": [        "content"      ]    },    {      "login": "Max101",      "name": "Mitja O.",      "avatar_url": "https://avatars2.githubusercontent.com/u/2124249?v=4",      "profile": "https://github.com/Max101",      "contributions": [        "content"      ]    },    {      "login": "SandroMiguel",      "name": "Sandro Miguel Marques",      "avatar_url": "https://avatars0.githubusercontent.com/u/6423157?v=4",      "profile": "http://sandromiguel.com",      "contributions": [        "content"      ]    },    {      "login": "GabeKuslansky",      "name": "Gabe",      "avatar_url": "https://avatars3.githubusercontent.com/u/9855482?v=4",      "profile": "https://github.com/GabeKuslansky",      "contributions": [        "content"      ]    },    {      "login": "ripper234",      "name": "Ron Gross",      "avatar_url": "https://avatars1.githubusercontent.com/u/172282?v=4",      "profile": "http://ripper234.com/",      "contributions": [        "content"      ]    },    {      "login": "vkarpov15",      "name": "Valeri Karpov",      "avatar_url": "https://avatars2.githubusercontent.com/u/1620265?v=4",      "profile": "http://www.thecodebarbarian.com",      "contributions": [        "content"      ]    },    {      "login": "imsergiobernal",      "name": "Sergio Bernal",      "avatar_url": "https://avatars3.githubusercontent.com/u/20087388?v=4",      "profile": "https://sergiobernal.com",      "contributions": [        "content"      ]    },    {      "login": "ntelkedzhiev",      "name": "Nikola Telkedzhiev",      "avatar_url": "https://avatars2.githubusercontent.com/u/7332371?v=4",      "profile": "https://github.com/ntelkedzhiev",      "contributions": [        "content"      ]    },    {      "login": "vitordagamagodoy",      "name": "Vitor Godoy",      "avatar_url": "https://avatars0.githubusercontent.com/u/26370059?v=4",      "profile": "https://github.com/vitordagamagodoy",      "contributions": [        "content"      ]    },    {      "login": "manishsaraan",      "name": "Manish Saraan",      "avatar_url": "https://avatars2.githubusercontent.com/u/19797340?v=4",      "profile": "https://www.manishsaraan.com/",      "contributions": [        "content"      ]    },    {      "login": "uronly14me",      "name": "Sangbeom Han",      "avatar_url": "https://avatars2.githubusercontent.com/u/5186814?v=4",      "profile": "https://github.com/uronly14me",      "contributions": [        "content"      ]    },    {      "login": "blackmatch",      "name": "blackmatch",      "avatar_url": "https://avatars3.githubusercontent.com/u/12443954?v=4",      "profile": "https://blackmatch.github.io",      "contributions": [        "content"      ]    },    {      "login": "ISNIT0",      "name": "Joe Reeve",      "avatar_url": "https://avatars3.githubusercontent.com/u/5173131?v=4",      "profile": "https://simmsreeve.com",      "contributions": [        "content"      ]    },    {      "login": "BusbyActual",      "name": "Ryan Busby",      "avatar_url": "https://avatars2.githubusercontent.com/u/14985016?v=4",      "profile": "https://github.com/BusbyActual",      "contributions": [        "content"      ]    },    {      "login": "ImanMh",      "name": "Iman Mohamadi",      "avatar_url": "https://avatars3.githubusercontent.com/u/4482199?v=4",      "profile": "http://jsdecorator.com",      "contributions": [        "content"      ]    },    {      "login": "HeeL",      "name": "Sergii Paryzhskyi",      "avatar_url": "https://avatars1.githubusercontent.com/u/287769?v=4",      "profile": "https://github.com/HeeL",      "contributions": [        "content"      ]    },    {      "login": "kapilepatel",      "name": "Kapil Patel",      "avatar_url": "https://avatars3.githubusercontent.com/u/25738473?v=4",      "profile": "https://github.com/kapilepatel",      "contributions": [        "content"      ]    },    {      "login": "justjavac",      "name": "迷渡",      "avatar_url": "https://avatars1.githubusercontent.com/u/359395?v=4",      "profile": "https://twitter.com/justjavac",      "contributions": [        "content"      ]    },    {      "login": "hozefaj",      "name": "Hozefa",      "avatar_url": "https://avatars1.githubusercontent.com/u/2084833?v=4",      "profile": "https://github.com/hozefaj",      "contributions": [        "content"      ]    },    {      "login": "el-ethan",      "name": "Ethan",      "avatar_url": "https://avatars3.githubusercontent.com/u/10249884?v=4",      "profile": "https://github.com/el-ethan",      "contributions": [        "content"      ]    },    {      "login": "milkdeliver",      "name": "Sam",      "avatar_url": "https://avatars2.githubusercontent.com/u/3108407?v=4",      "profile": "https://github.com/milkdeliver",      "contributions": [        "content"      ]    },    {      "login": "ArlindXh",      "name": "Arlind",      "avatar_url": "https://avatars0.githubusercontent.com/u/19508764?v=4",      "profile": "https://github.com/ArlindXh",      "contributions": [        "content"      ]    },    {      "login": "ttous",      "name": "Teddy Toussaint",      "avatar_url": "https://avatars0.githubusercontent.com/u/19815440?v=4",      "profile": "https://github.com/ttous",      "contributions": [        "content"      ]    },    {      "login": "LewisArdern",      "name": "Lewis",      "avatar_url": "https://avatars2.githubusercontent.com/u/2419690?v=4",      "profile": "http://ardern.io",      "contributions": [        "content"      ]    },    {      "login": "GabrielLidenor",      "name": "Gabriel Lidenor ",      "avatar_url": "https://avatars2.githubusercontent.com/u/765963?v=4",      "profile": "https://gabriellidenor.com/",      "contributions": [        "content"      ]    },    {      "login": "animir",      "name": "Roman",      "avatar_url": "https://avatars3.githubusercontent.com/u/4623196?v=4",      "profile": "https://github.com/animir",      "contributions": [        "content"      ]    },    {      "login": "Francozeira",      "name": "Francozeira",      "avatar_url": "https://avatars1.githubusercontent.com/u/47419763?v=4",      "profile": "https://github.com/Francozeira",      "contributions": [        "content"      ]    },    {      "login": "Invvard",      "name": "Invvard",      "avatar_url": "https://avatars0.githubusercontent.com/u/7305493?v=4",      "profile": "https://twitter.com/invvard",      "contributions": [        "content"      ]    },    {      "login": "romulogarofalo",      "name": "Rômulo Garofalo",      "avatar_url": "https://avatars1.githubusercontent.com/u/18492592?v=4",      "profile": "https://romulogarofalo.github.io/",      "contributions": [        "content"      ]    },    {      "login": "thoqbk",      "name": "Tho Q Luong",      "avatar_url": "https://avatars0.githubusercontent.com/u/1491103?v=4",      "profile": "http://thoqbk.github.io/",      "contributions": [        "content"      ]    },    {      "login": "Qeneke",      "name": "Burak Shen",      "avatar_url": "https://avatars2.githubusercontent.com/u/20271568?v=4",      "profile": "https://github.com/Qeneke",      "contributions": [        "content"      ]    },    {      "login": "MartinMuzatko",      "name": "Martin Muzatko",      "avatar_url": "https://avatars0.githubusercontent.com/u/2950505?v=4",      "profile": "http://www.happy-css.com",      "contributions": [        "content"      ]    },    {      "login": "autoboxer",      "name": "Jared Collier",      "avatar_url": "https://avatars3.githubusercontent.com/u/2757601?v=4",      "profile": "https://github.com/autoboxer",      "contributions": [        "content"      ]    },    {      "login": "bikingbadger",      "name": "Hilton Meyer",      "avatar_url": "https://avatars3.githubusercontent.com/u/4545860?v=4",      "profile": "http://hiltonmeyer.com",      "contributions": [        "content"      ]    },    {      "login": "ChangJoo-Park",      "name": "ChangJoo Park(박창주)",      "avatar_url": "https://avatars0.githubusercontent.com/u/1451365?v=4",      "profile": "http://kr.vuejs.org",      "contributions": [        "content"      ]    },    {      "login": "MasahiroSakaguchi",      "name": "Masahiro Sakaguchi",      "avatar_url": "https://avatars0.githubusercontent.com/u/16427431?v=4",      "profile": "https://github.com/MasahiroSakaguchi",      "contributions": [        "content"      ]    },    {      "login": "TheHollidayInn",      "name": "Keith Holliday",      "avatar_url": "https://avatars1.githubusercontent.com/u/1253400?v=4",      "profile": "https://github.com/TheHollidayInn",      "contributions": [        "content"      ]    },    {      "login": "coreyc",      "name": "coreyc",      "avatar_url": "https://avatars3.githubusercontent.com/u/1485356?v=4",      "profile": "https://www.coreycleary.me",      "contributions": [        "content"      ]    },    {      "login": "Berkmann18",      "name": "Maximilian Berkmann",      "avatar_url": "https://avatars0.githubusercontent.com/u/8260834?v=4",      "profile": "http://maxcubing.wordpress.com",      "contributions": [        "content"      ]    },    {      "login": "DouglasMV",      "name": "Douglas Mariano Valero",      "avatar_url": "https://avatars3.githubusercontent.com/u/32845487?v=4",      "profile": "https://github.com/DouglasMV",      "contributions": [        "content"      ]    },    {      "login": "marcelosdm",      "name": "Marcelo Melo",      "avatar_url": "https://avatars0.githubusercontent.com/u/18266600?v=4",      "profile": "https://github.com/marcelosdm",      "contributions": [        "content"      ]    },    {      "login": "mperk",      "name": "Mehmet Perk",      "avatar_url": "https://avatars0.githubusercontent.com/u/3465794?v=4",      "profile": "https://twitter.com/mperk_",      "contributions": [        "content"      ]    },    {      "login": "ryanouyang",      "name": "ryan ouyang",      "avatar_url": "https://avatars2.githubusercontent.com/u/360426?v=4",      "profile": "https://github.com/ryanouyang",      "contributions": [        "content"      ]    },    {      "login": "shabeer-mdy",      "name": "Shabeer",      "avatar_url": "https://avatars0.githubusercontent.com/u/26842535?v=4",      "profile": "https://github.com/shabeer-mdy",      "contributions": [        "content"      ]    },    {      "login": "halfzebra",      "name": "Eduard Kyvenko",      "avatar_url": "https://avatars1.githubusercontent.com/u/3983879?v=4",      "profile": "https://github.com/halfzebra",      "contributions": [        "content"      ]    },    {      "login": "deyvisonrocha",      "name": "Deyvison Rocha",      "avatar_url": "https://avatars2.githubusercontent.com/u/686067?v=4",      "profile": "http://deyvisonrocha.com",      "contributions": [        "content"      ]    },    {      "login": "georgem3",      "name": "George Mamer",      "avatar_url": "https://avatars1.githubusercontent.com/u/20108934?v=4",      "profile": "http://twitter.com/georgemamer",      "contributions": [        "content"      ]    },    {      "login": "leimonio",      "name": "Konstantinos Leimonis",      "avatar_url": "https://avatars0.githubusercontent.com/u/1969742?v=4",      "profile": "https://github.com/leimonio",      "contributions": [        "content"      ]    },    {      "login": "Zybax",      "name": "Oliver Lluberes",      "avatar_url": "https://avatars3.githubusercontent.com/u/22094453?v=4",      "profile": "https://github.com/Zybax",      "contributions": [        "translation"      ]    },    {      "login": "tiendq",      "name": "Tien Do",      "avatar_url": "https://avatars2.githubusercontent.com/u/815910?v=4",      "profile": "https://stackoverflow.com/story/tiendq",      "contributions": [        "content"      ]    },    {      "login": "singh1114",      "name": "Ranvir Singh",      "avatar_url": "https://avatars0.githubusercontent.com/u/11356398?v=4",      "profile": "http://singh1114.github.io/",      "contributions": [        "content"      ]    },    {      "login": "collierrgbsitisfise",      "name": "Vadim Nicolaev",      "avatar_url": "https://avatars3.githubusercontent.com/u/13496126?v=4",      "profile": "https://github.com/collierrgbsitisfise",      "contributions": [        "content",        "translation"      ]    },    {      "login": "germangamboa95",      "name": "German Gamboa Gonzalez",      "avatar_url": "https://avatars3.githubusercontent.com/u/28633849?v=4",      "profile": "https://github.com/germangamboa95",      "contributions": [        "content"      ]    },    {      "login": "AbdelrahmanHafez",      "name": "Hafez",      "avatar_url": "https://avatars3.githubusercontent.com/u/19984935?v=4",      "profile": "https://github.com/AbdelrahmanHafez",      "contributions": [        "content"      ]    },    {      "login": "chandiran-dmc",      "name": "Chandiran",      "avatar_url": "https://avatars3.githubusercontent.com/u/42678579?v=4",      "profile": "http://linkedin.com/in/chandiran-dmc",      "contributions": [        "content"      ]    },    {      "login": "VinayaSathyanarayana",      "name": "VinayaSathyanarayana",      "avatar_url": "https://avatars2.githubusercontent.com/u/16976677?v=4",      "profile": "https://github.com/VinayaSathyanarayana",      "contributions": [        "content"      ]    },    {      "login": "kiwikern",      "name": "Kim Kern",      "avatar_url": "https://avatars1.githubusercontent.com/u/2671139?v=4",      "profile": "https://www.kimkern.de",      "contributions": [        "content"      ]    },    {      "login": "kennethfreitas",      "name": "Kenneth Freitas",      "avatar_url": "https://avatars2.githubusercontent.com/u/55669043?v=4",      "profile": "https://kennethfreitas.github.io/",      "contributions": [        "content"      ]    },    {      "login": "songe",      "name": "songe",      "avatar_url": "https://avatars2.githubusercontent.com/u/1531561?v=4",      "profile": "https://github.com/songe",      "contributions": [        "content"      ]    },    {      "login": "Ksedline",      "name": "Kirill Shekhovtsov",      "avatar_url": "https://avatars1.githubusercontent.com/u/30693707?v=4",      "profile": "http://ksed.dev",      "contributions": [        "content"      ]    },    {      "login": "SerzN1",      "name": "Serge",      "avatar_url": "https://avatars0.githubusercontent.com/u/2534649?v=4",      "profile": "https://github.com/SerzN1",      "contributions": [        "content"      ]    },    {      "login": "keyrwinz",      "name": "keyrwinz",      "avatar_url": "https://avatars3.githubusercontent.com/u/21241761?v=4",      "profile": "https://github.com/keyrwinz",      "contributions": [        "content"      ]    },    {      "login": "nDmitry",      "name": "Dmitry Nikitenko",      "avatar_url": "https://avatars0.githubusercontent.com/u/2134568?v=4",      "profile": "https://github.com/nDmitry",      "contributions": [        "content"      ]    },    {      "login": "bushuai",      "name": "bushuai",      "avatar_url": "https://avatars0.githubusercontent.com/u/1875256?v=4",      "profile": "https://bushuai.cc",      "contributions": [        "review",        "content"      ]    },    {      "login": "benjamingr",      "name": "Benjamin Gruenbaum",      "avatar_url": "https://avatars2.githubusercontent.com/u/1315533?v=4",      "profile": "https://stackoverflow.com/users/1348195/benjamin-gruenbaum",      "contributions": [        "content"      ]    },    {      "login": "byeze",      "name": "Ezequiel",      "avatar_url": "https://avatars1.githubusercontent.com/u/7424138?v=4",      "profile": "https://github.com/byeze",      "contributions": [        "translation"      ]    },    {      "login": "juaoose",      "name": "Juan José Rodríguez",      "avatar_url": "https://avatars3.githubusercontent.com/u/994594?v=4",      "profile": "https://github.com/juaoose",      "contributions": [        "translation"      ]    },    {      "login": "OrBin",      "name": "Or Bin",      "avatar_url": "https://avatars1.githubusercontent.com/u/6897234?v=4",      "profile": "https://github.com/OrBin",      "contributions": [        "content"      ]    },    {      "login": "andreoav",      "name": "Andreo Vieira",      "avatar_url": "https://avatars2.githubusercontent.com/u/508827?v=4",      "profile": "https://twitter.com/andreoav07",      "contributions": [        "content"      ]    },    {      "login": "mikicho",      "name": "Michael Solomon",      "avatar_url": "https://avatars1.githubusercontent.com/u/11459632?v=4",      "profile": "https://github.com/mikicho",      "contributions": [        "content"      ]    },    {      "login": "jimmycallin",      "name": "Jimmy Callin",      "avatar_url": "https://avatars0.githubusercontent.com/u/2225828?v=4",      "profile": "https://github.com/jimmycallin",      "contributions": [        "content"      ]View remainder of file in raw view\n\n\n\ngoldbergyoni
    
    /
    
      nodebestpractices
    

    Public
  


        

        
            
    
      

  
                Notifications
    You must be signed in to change notification settings

  

  
              Fork
    10.4k

  

  
        
            
          Star
          102k

  



        
      

        



          

  
      
  
    
              
        Code
          


    

      
  
    
              
        Issues
          44


    

      
  
    
              
        Pull requests
          36


    

      
  
    
              
        Actions
          


    

      
  
    
              
        Projects
          0


    

      
  
    
              
        Security
          

    

      
  
    
              
        Insights
          


    


          
  
      
Additional navigation options



  
    
                
  
    
        
    
    
    
        
          
        
      
        
          Code
      

  

        
    
    
    
        
          
        
      
        
          Issues
      

  

        
    
    
    
        
          
        
      
        
          Pull requests
      

  

        
    
    
    
        
          
        
      
        
          Actions
      

  

        
    
    
    
        
          
        
      
        
          Projects
      

  

        
    
    
    
        
          
        
      
        
          Security
      

  

        
    
    
    
        
          
        
      
        
          Insights
      

  

    




      
  



  

  




    
    



    
      
    









  
  
     Files masterBreadcrumbsnodebestpractices/.gitignoreCopy path Blame  Blame        Latest commit HistoryHistory18 lines (18 loc) · 217 Bytes masterBreadcrumbsnodebestpractices/.gitignoreTopFile metadata and controlsCodeBlame18 lines (18 loc) · 217 BytesRaw123456789101112131415161718*.log.idea.vscode.idea/**/*.vscode/**/*.nyc_outputmochawesome-report.DS_Storenpm-debug.log.*node_modulesnode_modules/**/*.eslintcachecertlogs/*desktop.inipackage-lock.json.history.env\n\n\n\nNode.js-ren praktika onak

  



    


 Hemen ere bagaude! @nodepractices

Irakurri beste hizkuntza batzuetan: EN, CN, BR, RU, PL,JA (ES, FR, HE, KR eta TR aribidean!)

Gure Zuzendaritza Batzordeak  eta laguntzaileek eraiki eta mantentzen dute webgune hau
Azken praktika onak eta albisteak


 Euskarazko itzulpena!: wow gure euskal irakurleek ere gida hau bere ama-hizkuntzan irakur dezakete! Ane Diaz de Tuesta eta Joxefe Diaz de Tuestaren eskutik


🇯🇵 Japonierazko itzulpena: hemendik aurrera japonieraz erabili daiteke gure gida, YukiOta eta Yuta Azumi gure laguntzaile ikaragarriei esker


🎊 60.000 izar!: Gure biltegiak 60.100 garatzaileren aitortza eta konfiantza jaso ditu. Hitzik gabe gaude



Ongi etorri! Hasi aurretik jakin beharreko 3 gauza
1. Hemen dozenaka artikulu dauzkazu, onenetarikoak Node.jsri buruz egindakoetan: alegia, bilduma honek Node.jsren praktika onak jasotzen ditu, edukien arabera sailkatuta
2. Dagoen bildumarik handiena da, eta astetik astera handiagoa da: une honetan 80tik gora praktika, estilo eskuliburu eta arkitektura aholku dauzkagu bilduta. Gustura asko jasoko genituzke zure ekarpenak bilduma hau eguneratuta edukitzeko, bai kode akatsak konponduz, bai itzulpenak eginez, bai ideia berriak proposatuz egin ditzakezunak: izan zaitez Node.jsren praktika onen liburuko partaide. Ikusi gure idazketa jarraibideak
3. Jarraibide gehienek informazio gehigarria dute. Jarraibideko puntu bakoitzaren ondoan 🔗Informazio gehiago esteka aurkituko duzu, jarraibidea osatzen duena kode adibideekin, blogetako aipu hautatuekin eta informazio osagarri gehiagorekin

Edukien aurkibidea

Proiektuaren egitura (5)
Erroreen kudeaketa (12) 
Kode estiloa (12) 
Probak eta kalitate orokorra (13) 
Ekoizpena (19) 
Segurtasuna (25)
Errendimendua (2) (Aribidean ✍️)
Docker, praktika onak (15)


1. Proiektuaren egitura
 1.1 Antolatu zure proiektua atal eta osagai txikiagotan
TL;PL: aplikazio handien oztoporik handiena kode base erraldoi bat mantendu beharra da, ehundaka lotura eta menpekotasun dituena. Horrelako lan monolitikoek programatzaileen lana motelarazten dute, funtzionalitate berriak gehitzen saiatzen dira eta. Hori gerta ez dadin, zatitu zure kodea osagai txikiagotan, bakoitza bere datuekin karpeta banatan, eta bermatu osagai bakoitza laburra eta sinplea izatea. Bisitatu hemen behean dagoen “Informazio gehiago” esteka, proiektu egoki baten egitura zuzenaren adibideak ikusteko
Bestela: funtzionalitate berriak programatzean, garatzaileek zailtasun handiak izaten dituzte aldaketa horien eragina atzemateko, eta beldur izaten dira funtzionalitateon menpeko osagaiak hautsiko ote dituzten. Ondorioz, inplementazioak motelagoak eta arriskutsuagoak izaten dira. Oro har, zailagoa izaten da aplikazio baten kodea luzatzea negozio unitateak banatuta ez daudenean
🔗 Informazio gehiago: antolatu zure proiektua osagai txikiagotan

 1.2 Antolatu zure aplikazioa geruzatan eta mantendu webaren geruza bere esparruaren barruan
TL;PL: osagai bakoitzak «geruzak» izan beharko lituzke: hau da, berariaz weberako egindako objektu bat; beste bat, logikarako; eta beste bat, datuen sarbidearen koderako. Horrek, zati bakoitzaren funtzioak ondo bereizteko aukera eskaintzeaz gainera, sistema errazago simulatu eta testatzea ahalbidetzen du. Modelo hau oso ohikoa bada ere, APIen garatzaileek joera izaten dute geruzak nahasteko, webeko objektu espezifikoa (Express req, res) logika operatiboaren eta datuen geruzetara pasatuz, eta, ondorioz bai aplikazioa bai sarbidea Expressen menpeko bihurtzen dira
Bestela: aplikazio batean webeko objektuak beste geruzekin nahastuta badaude, ezingo da bertara sartu testak, CRON atazak eta Express middleware-ak baino erabiliz
🔗 Informazio gehiago: antolatu zure aplikazioa geruzatan

 1.3 Kokatu baliabide komunak npm paketetan
TL;PL: datu base askok osatzen duten aplikazio handi bat prestatzen dugunean, geruza guztietan lan egiten duten zeharkako tresna bakoitzak –erregistragailuak, zifragailuak eta beste– bere kodearen barruan egon behar du, npm pakete pribatu moduan, tresna horiek hainbat proiektutan partekatu ahal izatea ahalbidetzen duena
Bestela: zuk zeuk asmatu beharko duzu zeure inplementazioa eta menpekotasun gurpila
🔗 Informazio gehiago: antolatu funtzioen arabera

 1.4 Banandu Express 'aplikazioa' eta 'zerbitzaria'
TL;PL: ekidin Express aplikazioa artxibo handi batean oso-osorik definitzeko ohitura desegokia. Banandu Express aplikazioaren definizioa bi artxibotan gutxienez: batetik, APIaren definizioa (app.js); eta, bestetik, sarearen ezaugarriak (WWW). Are gehiago, egitura egokiagoa izan dadin, jarri APIaren definizioa osagaiekin batera
Bestela: probak egiteko, HTTP deien bidez baino ezingo da zure APIra sartu. Sarbide hori motelagoa da eta asko zailtzen du estaldura txostenak egitea. Gainera, ziur aski, ez da bat ere atsegina izango ehundaka lerro dituen kodea mantentzea
🔗 Informazio gehiago: banandu Express 'aplikazioa' eta 'zerbitzaria'

 1.5 Erabili ingurunea errespetatzen duen konfigurazio seguru eta hierarkiko bat
TL;PL: akatsik gabeko konfigurazio perfektu batek bermatu behar du (a) giltzak fitxategietatik eta inguruneko aldagaietatik irakurri ahal izatea, (b) sekretuak iturri kodetik kanpo gordeta egotea, eta, (c), bilaketak errazte aldera, konfigurazioa hierarkikoa izatea. Hori dena lortzeko badira paketeak, hala nola, rc, nconf, config eta convict
Bestela: konfiguazioa egitean baldintza horietarikoren bat betetzen ez baduzu, lana moteldu egingo da, bai garapen taldearena, bai devops taldearena
🔗 Informazio gehiago: konfigurazio praktika onak

⬆ Itzuli hasierara
2. Erroreen kudeaketa
 2.1 Erabili Async-Await edo errore asinkronoak kudeatzeko promesak
TL;PL: errore asinkronoak callback erabiliz kudeatzen badituzu, infernurako biderik azkarrena hartuko duzu edo galbiderako piramidean sartuko zara. Zure kodeari opari on bat egin nahi badiozu, erabili agintzen liburutegi ezagun bat edo async-await, try-catch erakoa adibidez kode sintaxis askoz trinkoago eta ohikoago bat eskaintzen duena
Bestela: Node.jsren callback teknika (“err, response” prozedura) erabiltzen baduzu, kode ez jasangarriak sortuko dituzu, batera suertatuko baitira kode arrunta duten erroreen kudeaketa, habiaratze sarriegiak eta kodetze eredu ez erosoak
🔗 Informazio gehiago: ekidin callback prozedurak

 2.2 Erabili soilik “Errorea” objektu kapsulatua
TL;PL: maiz, erroreak kate gisa edo modu pertsonalizatuan agertzen dira, erroreak kudeatzeko logika zaildu eta moduluen arteko elkarreragingarritasuna oztopatzen duena. Agintza bat baztertu zein salbuespen bat ezarri edo errore ohar bat argitaratzen duzunean, soilik “Errorea” objektu kapsulatua –edo “Errore txertatua“ objektua zabaltzen duen objektua– erabiliz lortuko duzu bermatzea bateratasuna handitu eta informazioa ez galtzea
Bestela: osagairen bati deitzean erroreak zein motatakoak diren jakin gabe, askoz zailagoa da eurak kontrolatzea. Are okerrago, erroreak deskribatzeko modu pertsonalizatuak erabiltzeak errore kritikoen informazioa galtzea ekar dezake, pilaren aztarna, besteak beste
🔗 Informazio gehiago: erabili soilik “Errorea” objektu kapsulatua

 2.3 Bereizi eragiketa erroreak eta programatze erroreak
TL; PL: eragiketa erroreek (adibidez, APIak balio gabeko sarrera jasotzea) agerian jartzen dituzten arazoak ezagunak izaten dira, eta, haien eragina guztiz ulertu eta kontuz kudeatzeko modukoak izaten dira. Bestetik, programatze erroreak (adibidez, zehaztu gabeko aldagaia irakurtzen saiatzea) aplikazioa berrabiarazteko agindua ematen duten kode hutsegite ezezagunak izaten dira
Bestela: beti berrabiaraz dezakezu aplikazioa errore bat agertzen denean. Baina zergatik utzi 5.000 erabiltzaile offline iragarri daitekeen errore funtzional txiki batengatik? Kontrakoa ere ez da egokia: arazo ezezagun bat gertatzen denean -programatze errore bat, esaterako- aplikazioa martxan mantentzeak ezusteko jokaerak eragin ditzake. Biak bereizteak aukera ematen du kontuz jokatzeko eta ikuspegi orekatu bat aplikatzeko testuinguruan oinarrituz
🔗 Informazio gehiago: eragiketa erroreak vs programatze erroreak

 2.4 Kudeatu erroreak gune bakar batean, Express middleware erabili partez
TL;PL: erroreak kudeatzeko logika -hala nola, haien erregistroa eramatea eta administratzaileari mezuak bidaltzea- objektu dedikatu zentralizatu batean kapsulatu behar da, erroreren bat gertatzen denean helmuga guztiek (adibidez, Express middlewarea, cron atazak, atalkako egiaztatzeak) hara deitu dezaten
Bestela: erroreak toki bakarrean ez kudeatzeak kodea bikoiztea eragiten du eta, ziur aski, erroreak gaizki kudeatzea ere bai
🔗 Informazio gehiago: kudeatu erroreak gune bakar batean

 2.5 Dokumentatu aplikazioaren erroreak Swagger edo GraphQL-ren laguntzarekin
TL;PL: jakinaren gainean jarri aplikazioaren deitzaileak erroreak berriro gerta daitezkeela, errore horiek behar bezala konpondu ahal izateko hutsik egin gabe. RESTful aplikazioetan Swagger bezalako dokumentazio esparruak erabiltzen dira. GraphQL erabiltzen baduzu, zeure eskema eta azalpenak erabil ditzakezu
Bestela: aplikazio baten bezeroak erabaki dezake aplikazioa itxi eta berrabiaraztea, ulertzen ez duen errore baten abisua jaso duelako soil-soilik. Oharra: zu zeu izan zaitezke zure aplikaziotik deitzen duena (oso ohikoa mikrozerbitzu inguruneetan)
🔗 Informazio gehiago: dokumentatu aplikazioaren erroreak Swagger edo GraphQLren laguntzarekin

 2.6 Irten prozesutik elegantziarekin kanpoko norbait iristen denean hirira
TL;PL: errore ezezagun bat gertatzen denean (programazio errore bat, ikusi 2.3 praktika ona), zalantza izaten da era egokian lanean ote dabilen aplikazioa. Kasu horietan, oso ohikoa izaten da prozesuak kudeatzeko tresna bat erabiltzea Forever, PM2 edo antzekoren bat– prozesua berriro hasteko
Bestela: ezagutzen ez duzun zerbait gertatzen denean, izan daiteke objekturen batzuk egoera txarrean daudelako (esaterako, globalki erabiltzen den gertaera igorle bat, barneko erroreren batengatik ondo ez dabilena) eta gerta daiteke aurrerantzean abisuek huts egitea edo modu ero samarrean funtzionatzea
🔗 Informazio gehiago: gelditu prozesua

 2.7 Erabili erregistratze tresna helduak erroreen ikusgaitasuna handitzeko
TL;PL: erregistratze tresna helduen sortak erabiltzen badituzu –Pino edo Log4js, adibidez–, erroreak lehenago atzeman eta ulertuko dituzu. Beraz, utzi alde batera console.log
Bestela: console.log-ak arakatu behar badituzu edo testua desordenatua duen artxibo batean erroreak eskuz, kontsulta tresnarik gabe edo erregistratze bisore ganorazkorik gabe bilatu behar badituzu, ordu asko emango dituzu lanean gaueko ordu txikiak arte
🔗 Informazio gehiago: erabili erregistratze tresna helduak

 2.8 Testeatu erroreen fluxua zure test framework gustukoena erabiliz
TL;PL: kalitate profesionaleko kontrol tresna automatizatu bat izan zein programatzaileentzako eskuzko test soil bat izan, bermatu zure kodeak ez duela egoera positiboetan bakarrik lan egiten, baizik eta errore zuzenak ere kudeatu eta birbidaltzen dituela. Mocha eta Chai bezalako unitate test frameworkek erraz egin dezakete lan hori (ikusi “Gist leiho”ko kode adibideak)
Bestela: automatikoki zein eskuz probarik egin gabe ezin duzu konfiantzarik izan zure kodeak benetako erroreak atzemango dituen. Errore adierazgarririk gabe ez dago erroreak kudeatzerik
🔗 Informazio gehiago: testeatu erroreen fluxua

 2.9 Aurkitu erroreak eta jardunik gabeko uneak APM produktuak erabiliz
TL;PL: monitorizazio eta errendimendu produktuek (APM, ingelesezko siglen arabera) modu proaktiboan ebaluatzen dute zure kode basea edo aplikazioa automatikoki aurkitu ahal izan ditzaten erroreak, blokeoak eta atzeman ezin dituzun eraginkortasun txikiko atalak
Bestela: denbora asko pasa zenezake zure aplikazioaren errendimendua eta jardunik gabeko uneak neurtzen, eta, hala ere, ez zenuke aurkituko zeintzuk diren zure kodearen zatirik motelenak egoera errealetan eta ez zenuke inoiz jakingo nola eragiten dioten erabiltzailearen lanari
🔗 Informazio gehiago: APM produktuen erabilera

 2.10 Atzeman kudeatu gabeko agintzen arbuioak
TL;PL: agintza baten barruan dauden salbuespenak xurgatuak eta baztertuak izango dira programatzaileak modu esplizituan kudeatzen ez baditu, haren kodea process.uncaughtException-ari atxikia egonda ere. Ekidin hori process.unhandledRejection erabiliz
Bestela: zure erroreak xurgatuak izango dira eta ez da haien arrastorik geratuko. Ez duzu zertaz kezkatu
🔗 Informazio gehiago: atzeman kudeatu gabeko aginduen arbuioak

 2.11 Huts egin azkar, balidatu argudioak liburutegi dedikatu baten laguntzarekin
TL;PL: Express erabiltzen duzunean, zure praktika onetako bat izan beharko litzateke aplikazioaren sarbidea kontrolatzea, ustegabeko erroreak ekiditeko, aurrerago erroreak atzematea askoz zailagoa izaten da eta. Balidazio kodea gogaikarria izan ohi da, ajv eta Joi bezalako laguntza liburutegi moderno bat erabili ezean
Bestela: pentsatu zure funtzioa agintza numeriko baten zain dagoela, adibidez «deskontua», eskatzaileak bidaltzea ahaztu duena; geroago, haren kodeak baieztatzen du « deskontua! = 0 (baimendutako deskontua zero baino handiagoa da)», eta horrek ahalmena ematen dio erabiltzaileari deskontua izateko. Ene, nolako errore arriskutsua! Konturatzen zara?
🔗 Informazio gehiago: huts eragin azkar

 2.12 Agintzen zain egon beti itzuli aurretik, pilak arrastorik uztea saihesteko
TL; PL: beti egin return await promesa bat itzultzean, pila osoaren jarraipena egin ahal izateko. Funtzio batek promesa bat itzultzen badu, funtzio hori async, hau da, asinkronotzat jo behar da, eta esplizituki await, itxaron agintza, itzuli aurretik
Bestela: itxaron gabe agintza itzultzen duen funtzioa ez da pilaren arrastoan agertuko. Galdutako fotograma horiek akatsa eragingo duen fluxua ulertzea zailduko lukete, batez ere portaera anormalaren zergatia falta den funtzioaren barruan baldin badago
🔗 Informazio gehiago: agintzak itzultzea

⬆ Itzuli hasierara
3. Kode estiloa
 3.1 Erabili ESLint
TL;PL: ESLint da gerta daitezkeen kode erroreak egiaztatzeko eta kodearen estiloa zuzentzeko estandarra. Ez da soilik erabiltzen tarteen arazoak identifikatzeko, baizik eta kodearen antipatroi kritikoak atzemateko ere, hala nola garatzaileen errore ez-sailkatuak. ESLint kode estiloak automatikoki zuzentzeko gai bada ere, badira beste tresna batzuk eraginkorragoak direnak zuzenketak egiten –esaterako, prettier eta beautify– eta, gainera, ESLintekin batera egiten dute lan
Bestela: garatzaileek arreta jarriko dute hain gogaikarriak diren arazo batzuk konpontzen –kodearen tarteak eta lerroaren luzera–, eta denbora gehiegi gal dezakete proiektuaren kode estiloa aztertzen
🔗 Informazio gehiago: erabili ESLint eta Prettier

 3.2 Node.jsrentzako plugin espezifikoak
TL;PL: ESLintek Vanilla JavaScript babesteko dituen arau estandarretatik aparte, komeni da Node.jsren osagai espeziko batzuk erabiltzea, hala nola eslint-plugin-node, eslint-plugin-mocha eta eslint-plugin-node-security
Bestela: Node.jsren arau akastun batzuek radarraren kontrolari ihes egin ahal diote. Esaterako, garatzaileek sarbide moduan aldagai jakin baten beharra izan dezakete (require(variableCommeChemin)), edozein JS script erabiltzeko aukera ematen diena erasotzaileei. Node.jsren linterrek patroi horiek atzeman ditzakete eta garaiz jo alarma

 3.3 Jarri kode multzo baten giltzak lerro bakarrean
TL;PL: kode bloke baten hasierako parentesiak irekiera instrukzioaren lerroan egon behar du
Kode adibidea
// Egin
function edozeinFuntzio() {
  // kode blokea
}

// Baztertu
function edozeinFuntzio()
{
  // kode blokea
}
Bestela: praktika on hau ez erabiltzeak ustekabeko emaitzak eragin ditzake, behean dagoen StackOverflow-en eztabaida harian ikus daitekeen bezala:
🔗 Informazio gehiago: “Zergatik aldatzen dira emaitzak giltzen kokapenaren arabera?” (StackOverflow)

 3.4 Bereizi instrukzioak modu egokian
Ez dio axola instrukzioak bereizteko puntu eta koma erabiltzen duzun edo ez, ohiko lerro jauzi okerrak edo koma txertatze automatikoak ezagutzeak lagundu egingo dizu ohiko errore sintaktikoak ez egiten
TL;PL: erabili ESLint bereizketetan izaten diren erroreez jabetzeko. Prettier edo Standardjs erabiliz automatikoki konpon ditzakezu arazo horiek
Bestela: aurreko atalean esan bezala, JavaScripteko interpreteak automatikoki “puntu eta koma” gehitzen du instrukzio baten amaieran “puntu eta koma”rik ez badago edo instrukzioa behar den tokian ez dela amaitu eta horrek okerreko emaitzak eragin ditzakeela pentsatzen badu. Ustekabeko errore gehienak ekiditeko, esleipenak erabil ditzakezu eta, horrela, berehala deitutako funtzio adierazpenak erabiltzea saihestuko duzu
Kode Adibidea
// Egin
function eginZerbait() {
    // ...
}

eginZerbait()

// Egin

const items = [1, 2, 3]
items.forEach(console.log)

// Baztertu — salbuespen bat jaurtitzen du
const m = new Map()
const a = [1,2,3]
[...m.values()].forEach(console.log)
> [...m.values()].forEach(console.log)
>  ^^^
> SyntaxError: Unexpected token ...

// egin zerbait — salbuespen bat jaurtitzen du
const count = 2 // 2() burutzen saiatzen da, baina 2() ez da funtzio bat
(function egin zerbait() {
  // egin zerbait paregabea
}())
// jarri puntu eta koma berehala deitutako funtzioa baino lehen, const definizioaren ostean, funtzio anonimoak bueltatutako balioa aldagarri batean gorde edo baztertu IIFE guztiak
🔗 Informazio gehiago: "Semi ESLint araua"
🔗 Informazio gehiago: "Ez dago ustekabeko ESLint arau lerroaniztunik"

 3.5 Izendatu funtzio guztiak
TL;PL: izendatu funtzio guztiak, itxierak eta deiak. Saihestu funtzio anonimoak. Hau bereziki erabilgarria da node aplikazio bat profilatzerakoan. Funtzio guztiak izendatzeak memoria argazkia egiaztatzean aukera emango dizu zer bilatzen ari zaren ulertzen
Bestela: zaila izan liteke ekoizpen arazoak araztea memoria erregistroak erabiliz (memoria argazkia), funtzio anonimoetako memoria kontsumoa handia denean

 3.6 Erabili izen deskriptiboak aldagaiak, konstanteak, funtzioak eta klaseak izendatzeko
TL;PL: Erabili lowerCamelCase konstanteak, aldagaiak eta funtzioak izendatzean eta UpperCamelCase (maiuskulazko lehen letra ere) klaseak izendatzean. Horrek lagunduko dizu aldagai/funtzio arruntak eta instantziazioa behar duten klaseak erraz bereizten. Erabili izen deskriptiboak, baina saiatu laburrak izan daitezen
Bestela: Javascript munduko hizkuntza bakarra da eraikitzailea ("Klasea") zuzenean deitzea ahalbidetzen duena aurretik eskatu/instantziatu gabe. Horrenbestez, klaseak eta funtzio eraikitzaileak bereizten dira UpperCamelCase-tik hasita
3.6 Kode eredua
// funtzioa izendatzeko UpperCamelCase erabiltzen dugu
class KlaseBatenAdibidea {}

// konstanteak izendatzeko const hitz gakoa eta lowerCamelCase erabiltzen ditugu
const config = {
  key: "balioa",
};

// aldagaiak eta funtzioak izendatzeko lowerCamelCase erabiltzen dugu
let aldagaiBatenAdibidea = "balioa";
function eginZerbait() {}

 3.7 Aukeratu const, let ordez. Ez erabili var
TL;PL: const erabiltzeak esan nahi du behin aldagai bat esleituta ezin dela berriro esleitu. Beraz, erabilera desberdinetarako aldagai bakarra erabiltzeko joera baztertzen lagunduko dizu const erabiltzeak, bai eta kodea garbitzen ere. Aldagai bat behin baino gehiagotan esleitu behar baduzu –for begizta batean, adibidez– erabili let, garbiagoa da eta. Leten beste alderdi garrantzitsu bat da definitu duzun blokearen eremuan bakarrik eskura dezakezula deklaratutako aldagia. var funtzioen eremukoa da, ez blokearena, eta ez da ES6n erabili behar, const eta let erabiltzeko aukera duzu eta
Bestela: arazketa askoz ere astunagoa da, maiz aldatzen den aldagai baten jarraipena egitean
🔗 Informazio gehiago: JavaScript ES6 +: var, let, edo const? 

 3.8 Erabili moduluak lehenengo, barne funtzioen partez
TL;PL: moduluak fitxategi bakoitzaren hasieran erabili behar dira, edozein funtzioren aurretik eta kanpo. Praktika on eta sinple honek lagunduko dizu fitxategiaren menpekotasunak erraz eta azkar atzematen haren eskuineko goi aldean, baita arazo posible batzuk ekiditen ere
Bestela: Node.jsk aldi berean exekutatzen ditu require-ak. Funtzio batek dei egiten badie, egoera kritikoago batean dauden beste eskaera batzuk blokea daitezke. Gainera, deitutako moduluetako batek edo haren menpeko ataza batek errore bat izanez gero, komeni da lehenbailehen haren berri jakitea, eta agian ezingo da hori egin, modulu horri funtzio batek deitzen badio

 3.9 Inportatu moduluak karpetaka eta ez artxiboak zuzenean
TL;PL: modulua/liburutegia karpeta batean garatzean, sartu index.js fitxategia, moduluaren barruko osagarriak agerian jarri eta erabiltzaile guztiek bertara joko dute eta. Hori eginez gero, moduluaren 'interfaze' gisa lan egiten du, eta geroago egin beharreko aldaketak errazten ditu kontratua hautsi gabe
Bestela: fitxategien barne egitura edo sinadura aldatzeak erabiltzaileen interfazea apur dezake
3.9 Kodea adibidea
// Egin
module.exports.SMSProvider = require("./SMSProvider");
module.exports.SMSNumberResolver = require("./SMSNumberResolver");

// Baztertu
module.exports.SMSProvider = require("./SMSProvider/SMSProvider.js");
module.exports.SMSNumberResolver = require("./SMSNumberResolver/SMSNumberResolver.js");

 3.10 Erabili === eragilea
TL;PL: hobetsi berdintasunaren eragile zorrotza === berdintasun abstraktuaren eragile ahulagoa baino ==. == eragileak bi aldagai alderatuko ditu, behin aldagai arrunt bihurtu ondoren. === eragileak ez du aldagai motaren bihurketarik egiten, eta bi aldagaiek mota berekoak izan behar dute berdinak izateko
Bestela: == eragileak, berdinak ez diren aldagaiak alderatuz gero, berdinak direlako mezua helaraz dezake
3.10 Kode adibidea
"" == "0"; // false
0 == ""; // true
0 == "0"; // true

false == "false"; // false
false == "0"; // true

false == undefined; // false
false == null; // false
null == undefined; // true

" \t\r\n " == 0; // true
Aurreko azalpen guztiak faltsuak izango lirateke === eragilea erabili izan balitz

 3.11 Erabili Async Await, ekidin callbackak
TL;PL: Node 8 LTS erabat bateragarria da orain Async-awaitekin, eta, horrela kode asinkronikoa kudeatzeko aukera ematen du, callbackik eta agintzarik erabili gabe. Async-awaitek ez du blokeorik eragiten, eta kode asinkronikoak sinkroniko bihurtzen ditu. Zure kodeari egin ahal diozun oparirik onena async-await erabiltzea da, eskaintzen duen kode sintaxia askoz ere trinkoagoa eta ezagunagoa da eta
Bestela: gaizki pasatu eta infernura joateko biderik azkarrena hartu nahi baduzu, erabili callbackak errore asinkronoak kudeatzeko, seguruenik, infernura joateko biderik azkarrena aukeratuko duzu. Estilo honek gune guztietako erroreak egiaztatzera behartzen du, eta, gainera, kode habiaratze beti deserosoaren kudeaketa eta kode fluxua ulertzea zailtzen du
🔗Informazio gehiago: async-await 1.0ren gida

 3.12 Erabili gezi funtzioak (=>)
TL;PL: agintzak eta callbackak onartzen dituzten API zaharrekin async-await erabiltzea eta funtzio parametroak ekiditea gomendarria bada ere, gezi funtzioek kodearen egitura trinkotu egiten dute eta erro funtzioaren testuinguru lexikoa bermatu (hau da, this)
Bestela: (ES5 funtzioetan) kode luzeek erroreak izateko joera handiagoa dute, eta, gainera, irakurtzeko astunak dira
🔗 Informazio gehiago: gezi funtzioak erabiltzeko garaia da

⬆ Itzuli hasierara
4. Probak eta kalitate orokorra
 4.1 Idatzi APIaren probak (osagaia), gutxienez
TL;PL: proiektu gehienei ez zaie proba automatikorik egiten denbora gutxian egiten direlako edo, maiz, 'proba proiektua' kontroletik kanpo geratu eta bertan behera uzten delako. Hori dela eta, lehentasuna eman API probei eta hasi beraiek egiten; izan ere, hori da idazteko erarik errazena eta, gainera, proba unitarioek baino estaldura handiagoa eskaintzen dute; are gehiago, API probak sor ditzakezu, Postman bezalako tresnak erabiliz. Ondoren, baliabide eta denbora gehiago edukiz gero, jarraitu proba aurreratuak egiten, hala nola proba unitarioak, datu baseen probak, errendimendu probak, etab.
Bestela: luzaroan aritu zintezke proba unitarioak idazten, azkenean soilik %20ko estaldura lortu duzula jakiteko

 4.2 Erabili 3 zati proba izen bakoitzean
TL;PL: proba adierazgarria izan behar da eskakizunen mailan, barne kodearekin lan egiten ohituta ez dauden QAko ingeniariek eta garatzaileek berez eta erraz uler dezaten. Probaren izenean adierazi zer ari den probatzen (probapean dagoen unitatea), zer egoeratan eta zer emaitza espero den
Bestela: inplementazio batek huts egin du, “Gehitu produktua“ izeneko proba batek huts egin du. Esaten dizu horrek zehazki zer dabilen gaizki?
🔗 Informazio gehiago: erabili 3 zati proba izen bakoitzean

 4.3 Egitura probak AAA ereduaren arabera
TL;PL: egituratu zure probak ondo bereizitako 3 ataletan: antolatu, aritu eta baieztatu (AAA). Lehenengo atalean probaren konfigurazioa egin behar da; ondoren proba egikaritu behar da; eta, azkenik, baieztapen fasea dator. Egitura horri jarraitzeak bermatzen du irakurleak garuneko PUZik ez gastatzea proba plana ulertzen
Bestela: kode nagusia ulertzen egunero orduak eta orduak pasatzeaz gainera, orain zure garuna trebatzen pasatzen duzu bestela eguneko zatirik lasaiena izan behar zuena (probak)
🔗 Informazio gehiago: egitura probak AAA ereduaren arabera

 4.4 Antzeman kodeko arazoak linter bat erabiliz
TL;PL: erabili kode linterra oinarrizko kalitatea egiaztatzeko eta antiereduak garaiz atzemateko. Exekutatu edozein proba baino lehen eta gehitu aurre-commit-a git kako moduan, edozein arazo berrikusteko eta zuzentzeko behar den denbora minimizatu ahal izateko. Era berean, egiaztatu 3. atala, kodearen estilo praktikei dagokienez
Bestela: kode antiereduren bat zuzendu gabe utz dezakezu, zure ekoizpen ingurunean ahula izan litekeena

 4.5 Saihestu datu globalak, gehitu datu pertsonalizatuak proba bakoitzean
TL;PL: probak akopla daitezen ekiditeko eta proben fluxuari buruz erraz arrazoitzeko, proba bakoitzak bere datu baseko lerroen multzoan lan egin beharko luke. Proba batek datu baseko datu batzuk ba ote diren jakin nahi duenean edo haien beharra duen bakoitzean, berariaz erantsi behar dira datu horiek eta eragotzi beste erregistroren bat mutatzea
Bestela: probek huts egin dutela eta, inplementazioa bertan behera utzi beharra izan duzula pentsatu. Egoera horretan, lan taldeak denbora asko pasatuko du porrotaren zergatiak aztertzen, azkenean, ondorio tamalgarri honetara iristeko: sistema ondo dabil; probek, ordea, elkarri eragiten diote eta egitura hausten dute
🔗 Informazio gehiago: saihestu datu globalak

 4.6 Etengabe ikuskatu menpekotasun ahulak
TL;PL: Express bezalako menpekotasun ospetsuenek ere ahultasun ezagunak dituzte, erraz gaindi daitezkeenak tresna komunitarioak eta komertzialak erabiliz, esaterako 🔗 npm auditoria eta 🔗 snyk.io, zure CItik dei ditzakezunak konpilazio bakoitzean
Bestela: zure kodeak ahultasunik ez izatea lortzeko tresna dedikaturik erabili gabe, etengabe begiratu beharko duzu mehatxu berriei buruz onlinen zer argitaratzen den eta haren jarraipena egin

 4.7 Etiketatu zure probak
TL;PL: egin beharreko probak desberdinak dira eszenatokiaren arabera; ke lasterrak, input-output gabekoak, garatzaileek artxibo bat gorde edo commit egiten dutenean erabiltzen diren testak, hasieratik amaierarainoko test erabatekoak presio eskaera berri bat bidaltzen denean egikaritzen direnak, etab. Hori lor daiteke #cold #api #sanity bezalako gako hitzak erabiliz probak etiketatzean, aukera izan dezazun zure proba tresnak erabiltzeko eta behar duzun azpimultzoari deitzeko. Adibidez, honela deitu ahal izango zenioke zentzutasun proba multzoari Mocha erabiliz: mocha --grep 'sanity'
Bestela: garatzaile batek aldaketa txiki bat egiten duen bakoitzean oso motela izan daiteke proba guztiak exekutatzea, datu baseak kontsultatzen dituzten probak barne. Horrelako kasuetan, garatzaileei etsigarria gertatuko zaie probak egitea

 4.8 Egiaztatu zure proben estaldura, proba eredu okerrak identifikatzen laguntzen du eta
TL;PL: Istanbul/NYC bezalako estaldura tresnak oso aproposak dira 3 arrazoirengatik: dohainik dira, hau da, ez da lanik egin behar txostenak lortzeko; proben estaldura gutxitu den identifikatzen laguntzen dute; eta, azkenik, baina ez garrantzi txikiagokoa, proben desdoikuntzak agerian jartzen dituzte. Koloretako kode estalduraren txostenak aztertzean, baliteke harrapaketa kapsula moduan sekula testatzen ez diren kode arloak ikustea, adibidez. Horrek esan nahi du probek bide arrakastatsuak besterik ez dituztela atzematen eta ez aplikazioak nola jokatzen duen erroreak gertatzen direnean. Konfiguratu zure probak estaldura maila batetik behera jaisten denean erroreak eragiteko
Bestela: ez da inolako neurgailu automatizaturik egongo zure kodearen zati handi bat proben estalduratik kanpo dagoela esango dizuna

 4.9 Ikuskatu pakete zaharkituak
TL;PL: erabili zure tresnarik gogokoena (adibidez, 'npm outdated' edo npm-check-updates zaharkituta dauden paketeak atzemateko, ezarri kontrol hau zure IEren bideetan eta, are gehiago, eragin konpilazio batek huts egitea ingurune kritikoetan. Adibidez, agertoki kritikoa izan daiteke instalatutako pakete batek 5 adabaki baieztatuak dituenean (adibidez, bertsio lokala 1.3.1 da eta biltegi bertsioa 1.3.8) edo haren egileak zaharkitu etiketa jarri dionean. Kasu horretan, ezabatu konpilazioa eta ekidin bertsio hori erabiltzea
Bestela: modu esplizituan arriskutsutzat etiketatuta dauden paketeak egikarituko ditu zure produkzioak

 4.10 Erabili production bezalako inguruneak e2e probetarako
TL;PL: zuzeneko datuak erabiltzen dituen hasieratik amaierarainoko proba (e2e) lehen IEren prozesuko katebegirik ahulena izaten zen, datu baseak bezalako zerbitzu astun askoren menpean dago eta. Erabili zure ekoizpen errealetik ahalik eta hurbilen dagoen ingurunea
Bestela: docker-compose erabili ezean, taldeek ingurune bakoitzeko proben datu baseak mantendu behar izaten dituzte, garatzaileen makinak barne. Mantendu beti datu base horiek sinkronizatuta, proben emaitzak alda ez daitezen ingurune batetik bestera

 4.11 Eguneratu probak aldizka analisi estatikoko tresnak erabiliz
TL;PL: analisi estatikoko tresnak erabiltzeak lagundu egiten dizu kodearen kalitatea hobetzeko modu objektiboak lortzen eta zure kodea jasangarri izaten. Analisirako tresna estatikoak gehitu ahal dizkiozu zure IE konpilazioari, huts egingo duen susmoa duzuenean. Estaldurari dagokionean, bere aldeko puntu nagusiak dira kalitatea ikuskatzeko gaitasuna dutela fitxategi anitzen testuinguruan (adibidez, bikoizketak atzematea), azterketa aurreratuak egitea (adibidez, kodearen konplexutasuna hautematea), eta kode arazoen historiaren eta aurrerapenaren jarraipena egitea. Horretarako, bi tresna hauek erabil ditzakezu: Sonarqube (2.600+ izar) eta Code Climate (1.500+ izar)
Bestela: kodearen kalitatea txarra denean, erroreek eta errendimenduak beti emango dituzte arazoak, azken belaunaldiko ezaugarriak dituen liburutegi berri distiratsu batek ere konpontzerik izango ez dituenak
🔗 Informazio gehiago: berregituratu!

 4.12 Aukeratu arretaz zure IE plataforma (Jenkins vs CircleCI vs Travis vs gainerako mundua)
TL;PL: zure integrazio jarraituaren plataformak (CICD) kalitateko tresna guztiak (adib. testak, lintak) ostatatu behar ditu, eta, beraz, indartsua izan beharko du bere pluginen ekosistemak. Aspaldian Jenkins proiektu askoren balio lehenetsia izan ohi zen, komunitaterik handiena eta oso plataforma indartsua baititu, ordainetan konfigurazio konplexu samarra eta ikaste kurba pikoa baditu ere. Gaur egun, askoz errazagoa da IE irtenbide bat sortzea CircleCI eta haren antzeko SaaS tresnak erabiliz. Tresna horiek IE hodi malgu bat sortzea ahalbidetzen dute azpiegitura osoa kudeatzeko zama hartu beharra izan gabe. Azken batean, sendotasuna eta abiaduraren arteko oreka lortzea da kontua. Egin zure aukera arretaz
Bestela: hornitzaile espezializatu bat aukeratzeak blokeatu zaitzake, pertsonalizazio aurreratu bat behar duzunean. Bestalde, Jenkins erabiltzeak denbora asko eska dezake azpiegitura konfiguratzean
🔗 Informazio gehiago: aukeratu IE plataforma

 4.13 Probatu zure middlewareak eurak bakarrik
TL;PL: middlewareak eskaera askori erantzuten dion logika sendo bat duenean, merezi du middlewarea probatzea bera bakarrik, web esparru osoa aktibatu gabe. Hori erraz lor daiteke {req, res, next} objektuak atzemanez eta behatuz
Bestela: middleware Expressean === errorea izanez gero, errorea gertatuko zaizu eskaera guztietan edo gehienetan
🔗 Informazio gehiago: probatu zure middlewareak eurak bakarrik

⬆ Itzuli hasierara
5. Ekoizpena
 5.1. Monitorizazioa
TL;PL: bezeroek baino lehenago arazoak aurkitzeko joku bat da monitorizazioa. Jakina, garrantzi handia eman behar zaio. Merkatua eskaintzez gainezka dago, eta, beraz, komeni zaizu zehazten hastea zeintzuk diren hartu behar dituzun oinarrizko neurriak (hemen dituzu nire iradokizunak); ondoren, pentsatu zer neurri osagarri ezarri behar dituzun; eta, azkenik, aukeratu hipotesi guztiak kontuan hartzen dituen soluzioa. Egin klik soluzioen ikuspegi orokorra izateko
Bestela: hutsegitea === bezero zapuztuak
🔗 Informazio gehiago: monitorizazioa!

 5.2. Gardentasuna handitu erregistratze plataforma adimendunak erabiliz
TL;PL: erregistroak arazketa adierazpen hutsalen biltegia izan daitezke edo zure aplikazioaren historia kontatzen duen aginte mahai praktikoa. Planifikatu zure erregistratze plataforma lehenengo egunetik: hau da, nola bildu, gorde eta aztertuko dituzun erregistroak, nahi duzun informazioa benetan eskura daitekeela bermatzeko (adibidez, zein den errore tasa, zerbitzu eta zerbitzarien bidez transakzio oso bat egin ondoren, eta abar)
Bestela: kutxa beltz batekin amaituko duzu, eta zaila izango zaizu han jasotako ezarpenen zergatia aurkitzea. Azkenean, erregistro adierazpen guztiak idazten hasiko zara informazio osagarria gehitzeko
🔗 Informazio gehiago: gardentasuna handitu erregistratze plataforma adimendunak erabiliz

 5.3. Delegatu ahal den guztia alderantzizko proxy batean (adibidez, gzip, SSL)
TL;PL: Node izugarri txarra da PUZen zeregin intentsiboak egiten, esate baterako, gzipping, SSL termination. Haien partez benetako middleware zerbitzuak erabili behar dituzu –hala nola nginx eta Haproxy–
edo hornitzaileen lainoko zerbitzuak
Bestela: zure hari bakarra lanpetuta egongo da azpiegitura lanak egiten, zure aplikazioaren guneari kasu egin beharrean, eta, ondorioz, haren errendimenduak behera egingo du
🔗 Informazio gehiago: delegatu ahal den guztia alderantzizko proxy batean (adibidez, gzip, SSL)

 5.4. Blokeatu menpekotasunak
TL;PL: zure kodeak berdin-berdina izan behar du ingurune guztietan, baina harrigarria bada ere npm lehenetsita dago menpekotasunei ingurune batetik bestera pasatzen uzteko. Instalatzen dituzunean paketeak hainbat ingurunetan, paketeen azken bertsioa eskuratzen saiatzen da. Hori saihesteko, erabili npm edo .npmrc konfigurazio artxiboak, ingurune bakoitzean dagokion paketearen zein bertsio zehatz (eta ez derrigorrez berriena) komeni zaizun adieraziko dizu eta. Bestela, kontrola fintze aldera, erabili npm shrinkwrap. *Eguneratzea: NPM5 bertsiotik aurrera, menpekotasunak defektuz blokeatzeko konfiguratuta dator. Yarn pakete kudeatzaile berria ere lehenetsita dago horrela lan egiteko
Bestela: QAk kodea xeheki probatuko du eta onartuko duen bertsioak desberdin jokatuko du produkzioan. Are okerrago, produkzio talde bereko zerbitzarien kodeak desberdinak izan litezke
🔗 Informazio gehiago: blokeatu menpekotasunak

 5.5. Babestu prozesuaren erabilgarritasuna tresna egokiak erabiliz
TL;PL: prozesuak huts eginez gero, aurrera egin eta berrabiarazi beharra dago. Egoera arruntetan, nahikoak izan daitezke PM2 bezalako prozesuak kudeatzeko tresnak, baina gaur egungo mundu ”docker”-izatuan, taldeak kudeatzeko tresnak ere kontuan hartu behar dira
Bestela: estrategia argirik gabe dozenaka eskaera exekutatzeak DevOpsa nahaste-borrastera eraman dezake, hartarako aldi berean tresna gehiegi (talde kudeaketa, dockerra, PM2) erabiliz gero
🔗 Informazio gehiago: babestu prozesuaren erabilgarritasuna tresna egokiak erabiliz

 5.6. Erabili PUZeko nukleo guztiak
TL;PL: Noderen oinarrizko bertsioa PUZeko nukleo bakar batean exekutatzen da, eta beste nukleo guztiak geldi geratzen dira. Beharrezkoa da Noderen prozesua erreplikatzea PUZ guztiak erabiliz: aplikazio txiki eta ertainekin, Node Cluster edo PM2 erabil dezakezu; aplikazio handi samarrekin, berriz, saiatu erabiltzen Docker tankerako talderen bat (adibidez, K8S, ECS) edo Linux hasieratze sisteman oinarritutako garatze idazkerak (adibidez, systemd)
Bestela: seguruenik, zure aplikazioak erabilgarri dituen baliabideen %25a besterik ez du erabiltzen (!), edo gutxiago, agian. Kontuan izan ohiko zerbitzariek gutxienez lau nukleo dituztela PUZen, eta Node.jsren garatzaile soilak bat bakarra erabiltzen duela (AWS beanstalk bezalako PaaS zerbitzuekin lan egiten duenean ere)
🔗 Informazio gehiago: erabili PUZeko nukleo guztiak

 5.7. Sortu ‘mantentze lanen amaiera puntua‘
TL;PL: API seguru batean, jarri agerian sistemarekin lotutako informazio multzo bat, hala nola, memoriaren erabilera eta REPL, etab. Nahiz eta gomendagarria den proba estandarretan eta tresna arruntetan oinarritzea, zenbait informazio eta eragiketa baliotsu errazago egiten dira kodea erabiliz
Bestela: konturatuko zara “diagnostiko-inplementazio“ asko egiten ari zarela, eta kodea produkziora bidaltzen duzula soilik informazioa lortzeko diagnostikoa egite aldera
🔗 Informazio gehiago: sortu ‘mantentze lanen amaiera puntua‘

 5.8. Aurkitu erroreak eta geldialdiak APM produktuak erabiliz
TL;PL: aplikazioen jarraipen eta errendimendu produktuek (APM deritzona) modu proaktiboan neurtzen dituzte kode basea eta APIa, modu automatikoan ohiko jarraipenetik haratago joateko eta erabiltzaileen esperientzia arrunta zerbitzu eta maila guztietan neurtzeko. Adibidez, APM produktu batzuek agerian jarri dezakete azken erabiltzaileen aldean motelegi kargatzen dela transakzio bat, sakoneko arrazoia iradokitzen duten bitartean
Bestela: APIaren errendimendua eta geldialdiak neurtzeko ahalegin handia egin zenezake, eta, ziurrenik, ez zinateke jabetuko zein diren zure kodearen atalik motelenak mundu errealeko eszenatokian eta nola eragiten dioten zure erabiltzaile esperientziari
🔗 Informazio gehiago: aurkitu erroreak eta geldialdiak APM produktuak erabiliz

 5.9. Prestatu zure kodea ekoizpenerako
TL;PL: programatu helburua kontuan izanik; planifikatu produkzioa lehenengo egunetik hasita. Horrek lausoa eta zehazgabea ematen duenez, produkzioaren mantentzeari estu-estu lotuta dauden garatze aholku batzuk bildu ditut (egin klik hemen behean dagoen Gist estekan)
Bestela: IT / DevOps arloko munduko txapeldun batek ere ez du salbatuko gaizki idatzita dagoen sistema
🔗 Informazio gehiago: prestatu zure kodea ekoizpenerako

 5.10. Neurtu eta babestu memoriaren erabilera
TL;PL: Node.jsk harreman gatazkatsuak ditu memoriarekin: v8 motorrak muga leunak dauzka memoria erabiltzean (1,4 GB) eta ezaguna da zein bidetatik galtzen duen Noderen kodeak memoria. Beraz, ezinbestekoa da Noderen prozesu memoriari erreparatzea. Aplikazio txikietan memoria aldizka neur dezakezu geruza komandoak erabiliz; baina aplikazio ertainetan eta handietan aztertu beharko zenuke ez ote zaizun komeni zure memoria erlojua kontrol sistema sendo baten erara erabiltzea
Bestela: zure memoria prozesuak 100 bat megabyte gal dezake egunean, Walmart-i gertatu zitzaion bezala
🔗 Informazio gehiago: neurtu eta babestu memoriaren erabilera

 5.11. Atera zure frontend modulu aktiboak Nodetik
TL;PL: prestatu frontend edukia middleware dedikatu bat erabiliz (adibidez, nginx, S3, CDN), zeren Noderen errendimenduak behera egiten baitu artxibo estatiko askorekin lan egiten duenean, bera azpiprozesu bakarrekoa da eta
Bestela: Node eduki dinamikoa eskaintzeko sortu zen arren, haren hari bakarra lanpetuta egongo da html / images / angular / react erako ehunka fitxategi bidaltzen, bera egiteko sortua izan zen zereginei esleitu barik bere baliabide guztiak
🔗 Informazio gehiago: atera zure frontend/interfazeko modulu aktiboak Nodetik

 5.12. Izan aberrigabea, hil zerbitzariak ia egunero
TL;PL: gorde edozein datu mota (adibidez, erabiltzaile saioak, cacheak, kargatutako fitxategiak) kanpoko datu biltegietan; eta aztertu ez ote zenituzkeen zure zerbitzari guztiak aldian behin “hil” beharko edo “zerbitzaririk gabe”ko plataformaren bat erabili (adibidez, AWS Lambda), berariaz aberrigabe (stateless) jokaera duena
Bestela: zerbitzari jakin batek huts eginez gero, makina akastun bat hil beharrean, aplikazioen geldialdia eragingo du. Gainera, gero eta zailagoa izango da mailaketaren elastikotasuna, zerbitzari jakin baten menpeko izanda
🔗 Informazio gehiago: izan aberrigabea, hil zerbitzariak ia egunero

 5.13. Erabili menpekotasunak automatikoki atzematen dituzten tresnak
TL;PL: menpekotasun ezagunenek ere –Express, adibidez– badituzte (noizean behin) ahulezia ezagunak, sistema arriskuan jar ditzaketenak. Horrek konponbide erraza du, ordea, tresna komunitario eta komertzialak erabiliz gero, ahuleziak etengabe kontrolatu eta haien berri ematen dute eta (bertan edo GitHub-en)
Bestela: zure kodea ahulezia eta zaurgarritasunetatik garbi mantentzeko tresna dedikaturik gabe, jarraipen estua egin beharko diezu mehatxu berriei buruz linean egiten diren argitalpenei, bide batez esanda, aspergarri samarra izaten dena
🔗 Informazio gehiago: erabili menpekotasunak automatikoki atzematen dituzten tresnak

 5.14. Esleitu transakzio identifikazio bana adierazpen erregistro bakoitzari
TL;PL: esleitu identifikatzaile bera –transakzio-: {balioren bat}– erregistro sarrera bakoitzari eskaera bakar baten barruan. Ondoren, erregistroetako erroreak ikuskatzean, erraz konturatuko zara zer gertatu zen aurretik eta ondoren. Zoritxarrez, hori ez da erraz lortzen Noden, haren izaera asinkronoa da eta. Ikusi kodearen adibideak beheko estekan
Bestela: produkzioko erroreen erregistroa testuingururik gabe ikustean – aurretik gertatu zena, alegia –, askoz zailagoa eta motelagoa da arazoa aztertzea
🔗 Informazio gehiago: esleitu transakzio identifikazio bana adierazpen erregistro bakoitzari

 5.15. Ezarri NODE_ENV = produkzioa
TL;PL: ezarri NODE_ENV ingurune aldagaia ‘produkzioa‘ edo ‘garapena‘ ataletan produkzioaren optimizazioak aktibatu beharra dagoen adierazteko; npm pakete askok uneko ingurunea zehazten dute eta haren kodea optimizatzen dute ekoizpenerako
Bestela: ezaugarri soil hori gabe errendimendua asko jaits liteke. Adibidez, Express erabiltzean zerbitzarira bideratzeko NODE_ENV gabe, errendimendua heren bat moteltzen da
🔗 Informazio gehiago: Ezarri NODE_ENV = produkzioa

 5.16. Diseinatu inplementazio automatizatuak, atomikoak eta geldialdi gabekoak
TL;PL: ikerketek frogatu dute inplementazio ugari egiten dituzten taldeek ekoizpen arazo kritikoak izateko probabilitatea txikiagotzen dutela. Eskuz egin beharreko urrats arriskutsurik eta zerbitzuen geldialdirik ez duten inplementazio azkar eta automatizatuek nabarmen hobetzen dute inplementazio prozesua. Baliteke hori bera lortzea Docker eta IE tresnak, biak batera, erabiliz, inplementazio sinplifikatuari dagokionez industriaren estandarra bihurtu dira eta
Bestela: inplementazio luzeak -> produkzioaren geldialdia eta gizakiak eragindako erroreak -> inplementazioan konfiantzarik ez duen taldea -> inplementazio eta funtzio gutxiago egitea

 5.17. Erabili Node.jsren LTS bertsio berria
TL;PL: ziurtatu Node.jsren LTS bertsioa erabiltzen ari zarela errore kritikoen zuzenketak, segurtasun eguneratzeak eta errendimenduaren hobekuntzak jasotzeko
Bestela: aurkitu berri diren erroreak edo ahuleziak erabil litezke produkzioan exekutatzen den aplikazio bat ustiatzeko eta baliteke zure aplikazioa ez izatea bateragarria hainbat modulurekin eta zailagoa gertatzea hura mantentzea
🔗 Informazio gehiago: Erabili NTS.jsren LTS bertsioa

 5.18. Ez bideratu erregistrorik aplikazioaren barruan
TL;PL: garatzaileek ez dituzte erregistroen helmugak aplikazio kodearen barruan kodetu behar, aplikazioa exekutatzen den inguruneak berak definitu beharko ditu eta. Garatzaileek stdout-ean idatzi behar dituzte erregistroak erregistratze tresna bat erabiliz, eta gero exekuzio inguruneak (edukiontzia, zerbitzaria eta abar) bideratuko du stdout korrontea helmuga egokira (hau da, Splunk, Graylog, ElasticSearch eta abar)
Bestela: aplikazioen kudeaketaren erregistroak bideratzea === zaila da eskalatzen, erregistroen galera dakar, eskasa izaten da kezken bereizketa
🔗 Informazio gehiago: erregistroen bideraketa

 5.19. Instalatu zure paketeak npm ci erabiliz
TL;PL: ziurtatu ekoizpen kodeak erabiltzen duela probak egiteko erabili dituzun paketeen bertsio berdina. Exekutatu npm ci zure package.json eta package-lock.json paketen menpekotasunen instalazio garbia egiteko
Bestela: QAk kodea sakonki probatuko du eta produkzioan modu desberdinean jokatuko duen bertsioa onartuko du. Are okerrago, produkzio talde bateko hainbat zerbitzarik kode desberdinak exekuta ditzake
🔗 Informazio gehiago: erabili npm ci

⬆ Itzuli hasierara
6. Segurtasuna



 6.1. Erabili linter segurtasun arauak
 
TL;PL: erabili segurtasunarekin lotutako linter pluginak, eslint-plugin-security bezalako segurtasun ahuleziak eta arazoak lehenbailehen atzemateko, ahal bada kodetzen ari diren bitartean. Horrek segurtasun ahuleziak atzematen lagun dezake, hala nola eval erabiltzea, bigarren mailako prozesu bat deitzea edo modulu bat inportatzea kate literal batekin (adibidez, erabiltzailearen sarrera). Egin klik 'Informazio gehiago' atalean segurtasun liner batek atzematen dituen kode adibideak ikusteko
Bestela: garapenean zehar segurtasun ahulezia zuzena izan zitekeena produkzioaren arazo nagusia bihurtzen da. Gainera, baliteke proiektuak kodeen segurtasun praktika koherenterik ez jarraitzea, ahuleziak sartzea edo urruneko biltegietan sartutako sekretu konfidentzialak sortzea
🔗 Informazio gehiago: lint arauak

 6.2. Mugatu aldi baterako eskaerak middlewareak erabiliz

TL;PL: DOS erasoak oso ezagunak dira, eta nahiko erraz eragin daitezke. Ezarri abiadura muga kanpoko zerbitzu bat erabiliz, hala nola hodeiko karga orekatzaileak, hodeiko suebakiak, nginx, abiadura-mugatzaile-malgua (rate-limiter-flexible) edo (aplikazio txikiagoak eta ez hain kritikoetarako) abiadura mugatzeko middleware bat (adibidez, express-rate-limit, express abiadura mugatzailea)
Bestela: aplikazio batek erasoak jasan ahal ditu, haren erabiltzaileei ukatzen bazaie jaso beharko luketen zerbitzua, aplikazioa egoera txarrean dagoelako edo eskuragarri ez dagoelako
🔗 Informazio gehiago: ezarri abiadura muga

 6.3 Kendu sekretuak konfigurazio fitxategietatik edo erabili paketeak enkriptatzeko
 
TL;PL: ez gorde inoiz testu arrunteko sekreturik konfigurazio fitxategietan edo iturburu kodean. Horren ordez, erabili sekretuak kudeatzeko sistemak, hala nola Vault produktuak, Kubernetes / Docker Secrets edo ingurune aldagaiak. Azken baliabide gisa, iturburuko kontrolean gordetako sekretuak enkriptatu eta kudeatu egin behar dira (gako birakariak, iraungitzeak, ikuskaritza, etab.). Erabili aurre-commit/push kakoak, ustekabean sekreturik gordetzea saihesteko
Bestela: iturburu kodearen kontrola publiko egin daiteke akats baten ondorioz, biltegi pribatuetan ere, eta orduan sekretu guztiak agerian geratzen dira. Kanpoko norbaitek iturburuko kontrolaren sarbidea ezagutzeak nahi gabe eragingo du erlazionatutako sistemetarako sarbideak ere ezagutzea (datu baseak, APIak, zerbitzuak, etab.)
🔗 Informazio gehiago: kudeaketa sekretua

 6.4. Saihestu kontsultak injektatzeko ahultasunak ORM / ODM liburutegiekin

TL;PL: SQL / NoSQL injekzioa eta beste eraso maltzur batzuk ekiditeko, erabili beti ORM / ODM edo datuetatik ihes egiten duen datu baseen liburutegia, edo kontsulta parametro izendatuak edo indexatuak onartzen dituena eta espero diren erabiltzaileen sarrera balioztatzen duena. Inoiz ez erabili JavaScript txantiloien kateak edo katearen kateatzea balioak kontsultetan txertatzeko, horrek zure aplikazioa ahultasunen espektro zabalera irekitzen baitu. Node.js entzute handiko datuen liburutegi guztiek injekzio erasoen aurkako babesa dute (adibidez, Sequelize, Knex, mongoose)
Bestela: balidatu gabeko edo baimendu gabeko erabiltzaileen sarrerak operadorearen injekzioa ekar dezake NoSQLrako MongoDB-rekin lan egitean, eta saneamendu sistema edo ORM egokia ez erabiltzeak SQL injekzio erasoak ahalbidetuko ditu, ahultasun erraldoia sortuz
🔗 Informazio gehiago: kontsulten injekzioaren prebentzioa ORM / ODM liburutegiak erabiliz

 6.5. Segurtasuneko praktika onen bilduma
TL;PL: Node.jsrekin zuzenean loturarik ez duen segurtasuneko aholku bilduma bat da: Noderen inplementazioa ez da hain desberdina beste edozein hizkuntzaren inplementazioaren aldean. Egin klik “Informazio gehiago” botoian sakontzeko
🔗 Informazio gehiago: ohiko segurtasun praktika onak

 6.6. Doitu HTTP erantzunen izenburuak segurtasun hobea lortzeko

TL;PL: zure aplikazioak izenburu seguruak erabili beharko lituzke erasotzaileek gune arteko scriptak (XSS), clickjacking-a eta beste eraso maltzur arruntak egitea saihesteko. Horiek erraz konfigura daitezke helmet bezalako moduluak erabiliz
Bestela: erasotzaileek zure aplikazioaren erabiltzaileen aurkako eraso zuzenak egin ditzakete, segurtasun ahultasun handiak sortuz
🔗 Informazio gehiago: erabili izenburu seguruak zure aplikazioan

 6.7. Etengabe eta automatikoki ikuskatu ba ote dagoen erasotzen errazak diren menpekotasunak

TL;PL: npm ekosistemarekin ohikoa da proiektu batek menpekotasun ugari izatea. Menpekotasunak beti kontrolatuta egon behar dira ahultasun berriak aurkitzen diren heinean. Erabili npm audit edo snyk bezalako tresnak, erasotzen errazak diren menpekotasunen jarraipena egiteko, kontrolatzeko eta adabakiak jartzeko. Tresna horiek zure IE konfigurazioarekin integratu, erasotzen errazak diren menpekotasunenak atzemateko ekoizpenera iritsi aurretik
Bestela: erasotzaile batek zure web esparrua detektatu eta ageriko ahultasun guztiei eraso ahal die
🔗 Informazio gehiago: menpekotasunen segurtasuna

 6.8. Babestu erabiltzaileen pasahitzak / sekretuak BCrypt edo Script erabiliz

TL;PL: pasahitzak eta sekretuak (adibidez API giltzak) gorde behar dira hash + gatz funtzio seguru bat erabiliz, esaterako, bcryptedo scrypt; eta kasurik okerrenean, pbkdf2
Bestela: funtzio segururik erabili gabe gordetzen diren pasahitzak eta sekretuak bortxaz erasotuak izan daitezke edo hiztegi erasoak jasan ditzakete. Azkenean agerian gera daitezke, bai eta agian zabaldu ere
🔗 Informazio gehiago: erabiltzaileen pasahitzak

 6.9. Ekidin HTML, JS eta CSS irteerak

TL;PL: arakatzailera bidaltzen diren datu ez fidagarriak bistaratu beharrean exekutatu egin daitezke, normalean cross-site-scripting (XSS) erasoa deritzona. Arindu hori datuak inoiz exekutatu behar ez diren eduki huts gisa (hau da, kodetu, ihes)esplizituki markatzen dituzten liburutegi espezializatuak erabiliz
Bestela: erasotzaile batek JavaScript kodeketa kaltegarria gorde dezake zure DBn, gero bezero gizajoei dagoen moduan bidaliko zaiena
🔗 Informazio gehiago: ihes irteera

 6.10. Balidatu sarrerako JSON eskemak
 
TL;PL: balidatu sarrerako eskaeren gorputzeko zama erabilgarria eta ziurtatu zure itxaropenak betetzen dituela; eta, haiek bete ezean, huts eragin. Ibilbide bakoitzaren balioztatze kodetze neketsua saihesteko JSONen oinarritutako balioztatze eskema arinak erabil ditzakezu, hala nola jsonschema edo joi
Bestela: zure eskuzabaltasunak eta ikuspegi permisiboak asko handitzen dute erasoaren tamainua, eta erasotzailea sarrera asko probatzera bultzatzen du, aplikazioa kraskatzeko konbinazio bat aurkitu arte
🔗 Informazio gehiago: balidatu sarrerako JSON eskemak

 6.11. Onartu JWTen zerrenda beltzak

TL;PL: JSON web fitxak erabiltzean (adibidez, Passport.js)-rekin), lehenespenez ez dago igorritako fitxen sarbidea ezeztatzeko mekanismorik. Erabiltzaileen jarduera maltzurren bat aurkitu ondoren, ez dago modurik sistemara sartzea eragozteko, baliozko fitxaren bat duten bitartean. Konpondu hori eskaera bakoitzean balioztatuko diren fitxa ezfidagarrien zerrenda beltza erabiliz
Bestela: edozeinek erabil litzake iraungitako edo gaizki kokatutako fitxak, maltzurki aplikazio batera sartzeko eta fitxaren jabea ordezkatzeko
🔗 Informazio gehiago: JSON web fitxen zerrenda beltzak

 6.12. Aurrea hartu baimenaren aurkako eraso basatiei

TL;PL: oso teknika sinple eta eraginkorra da baimen saiakerak mugatzea bi metrika erabiliz:

Lehenengoa, erabiltzaile beraren ID / izen eta IP helbide bakarrak jarraian huts egin duen saiakera kopurua
Bigarrena, IP helbide batek denbora tarte luze batean huts egin duen saiakera kopurua. Adibidez, blokeatu IP helbide bat, egun batean 100 saiakera huts egiten baditu

Bestela: erasotzaile batek pasahitz automatizatuen saiakera mugagabeak egin ditzake aplikazio bateko kontu pribilegiatuetara sartzeko
🔗 Informazio gehiago: mugatu saioa hasteko abiadura

 6.13. Exekutatu Node.js erabiltzaile ez-erro gisa

TL;PL: eszenatoki arrunt batean Node.js baimen mugagabeak dituen erro erabiltzaile gisa exekutatzen da. Hori da, adibidez, Docker edukiontzietako portaera lehenetsia. Gomendagarria da erro ez den erabiltzaile bat sortzea eta Docker irudian sartzea (behean azaltzen dira adibideak) edo prozesua erabiltzaile horren izenean abiaraztea "-u username" marka duen edukiontzia deituz
Bestela: zerbitzarian script bat exekutatzea lortzen duten erasotzaileek botere mugagabea lortzen dute makina lokalaren gainean (adibidez, iptable aldatu eta trafikoa beren zerbitzarira bideratzea)
🔗 Informazio gehiago: exekutatu Node.js erabiltzaile ez-erro gisa

 6.14. Mugatu kargaren tamaina alderantzizko proxy edo middlewareak erabiliz
 
TL;PL: zenbat eta gorputzaren karga handiagoa izan, orduan eta zailagoa da zure hari bakarra lan egitea hura prozesatzean. Hori da erasotzaileek zerbitzariak belauniko jartzeko aukera ona eskaera kopuru izugarririk egin gabe (DOS / DDOS erasoak). Murriztu arriskua ertzean jasotako eskaeren gorputzaren tamaina mugatuz (adibidez, suebakia, ELB) edo express body parser konfiguratuz tamaina txikiko kargak bakarrik onartzeko
Bestela: zure aplikazioak eskaera handiei aurre egin beharko die, eta ezingo du prozesatu egin behar duen beste lan garrantzitsua, ondorioz errendimendua gutxituz eta DOS erasoekiko ahulduz
🔗 Informazio gehiago: mugatu kargaren tamaina

 6.15. Saihestu JavaScripten eval adierazpenak
  
TL;PL: eval arriskutsua da, exekutatzeko garaian JavaScript kode pertsonalizatua exekutatzea baimentzen baitu. Hori ez da errendimendu arazo bat bakarrik, baizik eta segurtasun arazo garrantzitsua, erabiltzaileen sarreratik JavaScript kode gaiztoa lor daiteke eta. Halaber, new Function constructor ere saihestu beharra dago; eta, azkenik, setTimeout eta setInterval, ez dira inoiz pasatu behar, ezta JavaScript kode dinamikoa ere
Bestela: Javascript kode gaiztoak bidea aurkitzen du eval testura edo JavaScript hizkuntzak denbora errealean ebaluatzeko dituen funtzioetara sartzeko, eta sarbide osoa lortuko du JavaScripten orrialdeko baimenetara. Ahultasun hori XSS eraso gisa agertzen da askotan
🔗 Informazio gehiago: saihestu JavaScript eval adierazpenak

 6.16. Saihestu RegEx gaiztoak zure exekuzio hari bakarra gainkargatzea

TL;PL: adierazpen erregularrak, oso erabilgarriak izan arren, benetako mehatxua dira JavaScript aplikazioentzat, oro har, eta Node.js plataformarentzat, bereziki. Erabiltzaile baten sarrera prozesatzeko testuarekin bat etor dadin, gerta liteke PUZeko ziklo kopuru handia behar izatea. RegExen prozesamenduaren eraginkortasuna hain txikia izan daiteke, ezen 10 hitz balioztatzen dituen eskaera bakar batek blokea baitezake gertaeren begizta osoa 6 segundoz, eta PUZa su hartzeko moduan jarri 🔥. Hori dela eta, erasotzen errazak diren ohiko adierazpen ahulen txantiloiak atzemateko erabili hirugarrenen balidazio paketeak -esaterako, validator.js-, zuk zeure Regex ereduak idatzi edo safe-regex erabili gabe
Bestela: gaizki idatzitako ohiko adierazpenek Regular Expression DoSen erasoak jasan ditzakete, gertaeren begizta erabat blokeatuko dutenak. Adibidez, 2017ko azaroan, RegExen erabilera gaiztoak agerian jarri zuen moment pakete ezagunaren ahultasuna
🔗 Informazio gehiago: saihestu RegEx gaiztoa erabiltzea

 6.17. Saihestu moduluak kargatzea aldagai bat erabiliz
  
TL;PL: bide bat erabiltzailea sartu ondoren sortua ote den kezka baduzu eta horregatik parametro gisa ezarri baduzu, saihestu bide hori erabiltzea beste fitxategi bat deitzeko / inportatzeko. Arau hori, oro har, edozein fitxategitara sartzeko erabil daiteke (hau da, fs.readFile()) edo erabiltzailea sartu ondoren sortutako aldagai dinamikoak dituen beste baliabide konfidentzialetara sartzeko. Eslint-plugin-security linterrek eredu horiek atzeman eta nahikoa goiz ohartaraz dezake
Bestela: erabiltzaile gaiztoen sarrerak manipulatutako fitxategiak deitzeko erabiltzen den parametro batera jo dezake, adibidez, aurretik fitxategi sisteman kargatutako fitxategietara edo lehendik sisteman bazeuden fitxategietara sartzeko
🔗 Informazio gehiago: moduluaren karga segurua

 6.18. Exekutatu kode ez segurua sandbox batean
  
TL;PL: exekuzio garaian ematen den kanpoko kodea exekutatu behar duzunean (adibidez, plugina), erabili kode nagusia isolatu eta pluginetik babesten duen 'sandbox' tankerako edozein exekuzio ingurune mota. Hori lor daiteke prozesu dedikatu baten bidez (adibidez, cluster.fork()), zerbitzaririk gabeko ingurune bat erabiliz edo sandbox bat balitz bezala jokatzen duten npm pakete dedikatuak erabiliz
Bestela: plugin batek bide ugari erabil ditzake erasotzeko, hala nola begizta infinituak erabiliz, memoria gainkargatuz eta prozesu ingurune eraso errazen aldagaiak eskuratuz
🔗 Informazio gehiago: exekutatu kode ez segurua sandbox batean

 6.19. Kontu handia izan bigarren mailako prozesuekin lan egitean
  
TL;PL: ahal dela, saihestu bigarren mailako prozesuak, eta, hala behar izanez gero, balioztatu eta garbitu sarrera, shell injekzioko erasoak arintzeko. Hobetsi child_process.execFile fitxategia, definizioz komando bakarra exekutatuko duena atributu multzo batekin eta shell parametroen hedapena onartuko ez duena
Bestela: bigarren mailako prozesuak ganorarik gabe erabiltzeak urruneko komandoen exekuzioa edo shell injekzioko erasoak eragin ditzake, desinfektatu gabeko sistema komando batera erabiltzaile gaiztoren bat sartu dela eta
🔗 Informazio gehiago: kontuz ibili bigarren mailako prozesuekin lan egitean

 6.20. Ezkutatu bezeroari erroreen xehetasunak

TL;PL: errore integratuen kudeatzaile lasterrek lehenespenez ezkutatzen dituzte erroreen xehetasunak. Haatik, aukera handia dago inplementa dezan errore pertsonalizatuak dituzten objektuak kudeatzeko berak daukan logika (batzuen ustez praktika ona dena). Hala eginez gero, ziurtatu bezeroari errorearen objektu osoa ez itzultzea, horrek aplikazioen datu sentikorrak izan litzake eta
Bestela: aplikazioaren xehetasun sentikorrak —hala nola, zerbitzariko fitxategien bideak, erabiltzen ari diren hirugarrenen moduluak eta erasotzaile batek balia ditzakeen aplikazioaren barneko beste lan fluxuak— atera daitezke pila aztarna batean aurkitutako informazioetatik
🔗 Informazio gehiago: ezkutatu bezeroari erroreen xehetasunak

 6.21. Konfiguratu 2FA npm edo Yarn-entzat

TL;PL: garapen katearen edozein urrats MFArekin (faktore anitzeko autentifikazioarekin) babestu behar da. Iza ere, npm / Yarn aukera paregabea da garatzaile batzuen pasahitza eskuratu nahi duten erasotzaileentzat. Garatzaileen egiaztagiriak erabiliz, erasotzaileek kode gaiztoa txerta dezakete proiektu eta zerbitzuetan instalatuta dauden liburutegietan, eta, agian, sarean bertan ere, jendaurrean argitarauta badago. npm-n autentifikazioa 2 faktore bidez egin beharra ezartzeak ia zero aukera uzten die erasotzaileei zure pakete kodea aldatzeko
Bestela: ba al duzu pasahitza bahitu zuten eslint garatzailearen berri?

 6.22. Aldatu saioko middlewarearen ezarpenak

TL;PL: web esparru eta teknologia bakoitzak bere ahulguneak ditu: erasotzaileei esatea zein web esparru erabiltzen dugun laguntza handia da haientzat. Saioaren middlewareen ezarpen lehenetsiak erabiltzeak eragin dezake zure moduluko eta esparruko berariazko bahiketa erasoak izatea zure aplikazioak, X-Powered-By izenburukoaren antzekoak. Saiatu ezkutatzen zure pila teknologkoa identifikatzen eta agerian uzten duen edozein gauza (adibidez, Node.js, express)
Bestela: cookieak segurtasunik gabeko konexioen bidez bidal litezke, eta erasotzaile batek saioaren identifikazioa erabil lezake web aplikazioaren barruko esparrua eta moduluen berariazko ahultasunak ere identifikatzeko
🔗 Informazio gehiago: cookieak eta saioaren segurtasuna

 6.23. Saihestu DOS erasoak prozesuak noiz huts egin behar duen berariaz ezarriz

TL;PL: Node prozesuak huts egingo du akatsak kudeatzen ez direnean. Praktika onetako askok irtetea gomendatzen dute, akats bat atzeman eta kudeatuta badago ere. Expressek, adibidez, huts egiten du errore asinkronoren bat izanez gero –blokeatze klausula batekin ibilbideak biltzen ez badituzu behintzat. Horrek oso eraso bide aproposa irekitzen die erasotzaileei, zer informaziok eragiten duen prozesuaren blokeoa jakinda, behin eta berriz eskaera bera bidaltzen baitute prozesua blokeatzea lortu arte. Horretarako ez dago berehalako erremediorik, baina teknika batzuek mina arindu dezakete: abisatu zorroztasun kritikoarekin, kontrolatu gabeko errore baten ondorioz prozesuak huts egiten duen bakoitzean, balioztatu sarrera eta saihestu prozesua blokeatuta gelditzea erabiltzailearen sarrera baliogabea delako, bildu ibilbide guztiak cacth batekin eta kontuan hartu prozesuak ez duela huts egin behar eskaera batean errore bat sortzen denean (oro har, gertatzen denaren kontra)
Bestela: hau uste oneko suposizio soil bat besterik ez da. Node.js aplikazio asko edukiz gero, JSON gorputz huts bat POST eskaera guztietara pasatzen saiatzen bagara, zenbait aplikazio blokeatu egingo dira. Une horretan, eskaera bera berbidal dezakegu, aplikazioak erraz ezabatzeko

 6.24. Saihestu birbideratze ez seguruak

TL;PL: erabiltzaileen sarrerak balioztatzen ez dituzten birbideratzeek ahalbidetzen dute erasotzaileek phishing iruzurrak abiatzea, erabiltzaileen egiaztagiriak lapurtzea eta beste ekintza kaltegarri batzuk burutzea
Bestela: erasotzailea ohartzen bada erabiltzaileek emandako kanpo sarrerarik ez dela balioztatzen, ahultasun hori balia dezake foroetan, sare sozialetan eta beste toki publiko batzuetan hartarako bereziki sortutako estekak argitaratzean, erabiltzaileek bertan klik egin dezaten
🔗 Informazio gehiago: saihestu birbideratze ez seguruak

 6.25. Saihestu sekretuak npm erregistroan argitaratzea

TL;PL: neurriak hartu behar dira npm erregistro publikoetan sekretuak nahi gabe argitaratzeko arriskua ekiditeko. Erabil daiteke .npmignore fitxategi bat karpeta edo fitxategi espezikoak zerrenda beltz batean jartzeko eta files matrizea package.json artxiboarekin erabil daiteke zerrenda zuri moduan lan egin dezan
Bestela: arriskua dago norbaitek zure proiektuaren API giltzak, pasahitzak edo beste sekretu batzuk aurkitu eta erasoak egiten saiatzeko, eta horrek galera ekonomikoak, nortasun arazoak eta bestelako arriskuak sor ditzake
🔗 Informazio gehiago: saihestu sekretuak argitaratzea

⬆ Itzuli hasierara
7. Zirriborroa: errendimendua
Gure laguntzaileak lanean ari dira atal honetan. Parte hartu nahi zenuke?

 7.1. Ez blokeatu gertaeren begizta
TL;PL: saihestu PUZen zeregin intentsiboak, gertaeren begizta blokeatuko baitute. Izan ere, gertaera horietako gehienak azpiprozesu bakarrekoak dira, eta deskargatuak izango baitira azpiprozesu dedikatu batean, prozesu batean edo teknologia desberdinetan, dauden testuinguruaren arabera
Bestela: gertaeren begizta blokeatuta dagoenez, Node.jsk ezin izango du beste eskaera bat kudeatu eta, ondorioz, atzerapena eragin diezaieke erabiltzaileei. 3000 erabiltzaile erantzunaren zain daude, edukia zerbitzatzeko prest dago, baina eskaera bakar batek emaitzak berriro bidaltzea galarazten dio zerbitzariari
🔗 Informazio gehiago: ez blokeatu gertaeraren begizta

 7.2. Hobetsi jatorrizko JS metodoak Lodash bezalako erabiltzaileen baliabideak baino
TL;PL: askotan zorrotzagoa da lodash eta underscore bezalako baliabide liburutegiak erabiltzea jatorrizko metodoak baino, beharrezkoak ez diren menpekotasunak eragin eta abiadura moteltzen baitu. Gogoan izan, V8 motor berria ES estandar berriekin batera, bertako metodoak hobetu egin zirela, eta gaur egun baliabide liburutegiak % 50 inguru eraginkorragoak direla liburutegi publikoak baino
Bestela: errendimendu txikiagoko proiektuak mantendu beharko zenituzke, non dagoeneko eskura zenuena erabili beharko baitzenuke edo, fitxategi batzu gehiagoren truke, beste zenbait lerro landu
🔗 Informazio gehiago: erabiltzaileen jatorrizko baliabideak

⬆ Itzuli hasierara
8. Docker, praktika onak
🏅 Mila esker Bret Fisher-i, ondorengo praktika hauetako asko ikasi baikenituen berarengandik

 8.1 Erabili etapa anitzeko konpilazioak Docker irudi sinpleagoak eta seguruagoak lortzeko
TL;PL: erabili etapa anitzeko konpilazioak beharrezko produkzio objektuak soilik kopiatzeko. Konpilazio menpekotasun eta fitxategi asko ez dira beharrezkoak zure aplikazioa exekutatzeko. Etapa anitzeko konpilazioak erabiliz gero, baliabide horiek konpilazioan zehar erabil daitezke, denboraren exekuzio inguruneak beharrezko baliabideak besterik ez duen bitartean. Etapa anitzeko konpilazioak oso modu erraza dira gehiegizko pisua kendu eta segurtasun mehatxuak saihesteko
Bestela: irudi handiagoek denbora gehiago beharko dute konpilatzeko eta zabaltzeko. Eraikitzeko soilik diren tresnek ahultasunak eduki ditzakete eta eraikitze faserako soilik gordetako sekretuak filtratu daitezke
Etapa anitzeko eraikuntzetarako Dockerfile fitxategiaren adibidea
FROM node:14.4.0 AS build

COPY . .
RUN npm ci && npm run build


FROM node:slim-14.4.0

USER node
EXPOSE 8080

COPY --from=build /home/node/app/dist /home/node/app/package.json /home/node/app/package-lock.json ./
RUN npm ci --production

CMD [ "node", "dist/app.js" ]
🔗 Informazio gehiago: erabili etapa anitzeko konpilazioak

 8.2. Abiarazi edukiontzia node komandoa erabiliz, saihestu npm
TL;PL: erabili CMD ['node','server.js'] aplikazioa abiarazteko, saihestu OS seinaleak kodera pasatzen ez dituzten npm scriptak erabiltzea. Horrek arazoak izatea ekiditen du bigarren mailako prozesuetan, seinaleak kudeatzean, itxiera seguruetan eta prozesu zonbietan
Bestela: seinalerik pasatzen ez denean, zure kodeak ez du inoiz izango itzalaldien berri, eta, hori gabe, ez da behar bezala itxiko, unean uneko eskaerak eta / edo datuak galduz
Informazio gehiago: abiarazi edukiontzia 'node' komandoa erabiliz, saihestu npm abiatzea

 8.3. Utzi Dockeren egikaritze denborari erreplikatu eta jardueraren iraupena kudeatzen
TL;PL: Dockerren exekuzio denboraren orkestratzailea erabiltzen duzunean (adibidez, Kubernetes), deitu Node.js prozesua zuzenean, prozesua errepikatzen duten bitarteko prozesuen kudeatzailerik edo koderik pertsonalizatu gabe (adibidez, PM2, Cluster modulua). Exekuzio denboraren plataformak datu kopuru eta ikusgarritasun handiena dauzka kokapenari buruzko erabakiak hartzeko: badaki zenbat prozesu behar diren, nola antolatu prozesuok eta zer egin huts eginez gero
Bestela: edukiontziak huts egiten jarraituko du baliabide faltagatik, eta prozesuen kudeatzaileak behin eta berriro berrabiaraziko du, gelditu gabe. Kubernetes horretaz jabetuko balitz, beste toki zabal batera lekualda lezake
🔗 Informazio gehiago: utzi Dockeren exekuzio denborari erreplikatu eta jardueraren iraupena kudeatzen

 8.4. Erabili .dockerignore sekretuak filtratzea ekiditeko
TL;DR: erabili .dockerignore fitxategia, fitxategi sekretu arruntak eta garapeneko objektuak iragazten ditu eta. Horrela, sekretuak irudira ez sartzea lor dezakezu. Eta onura gehigarri bat izango duzu: eraikitzeko denbora nabarmen murriztuko da. Gainera, ziurtatu fitxategi guztiak ez direla behin eta berriro kopiatzen eta berariaz aukeratu zer kopiatu behar den Dockerren
Bestela: irudira sarbidea duen edonorekin partekatuko dira .env, .aws eta .npmrc bezalako fitxategi sekretu pertsonal arruntak (adibidez, Docker biltegia)
🔗 Informazio gehiago: erabili .dockerignore

 8.5. Garbitu menpekotasunak ekoizpenaren aurretik
TL;PL: nahiz eta dev-menpekotasunak (dev-dependencies) batzuetan eraikuntza eta probako bizitza zikloan zehar beharrezkoak izan, azkenean ekoizpenera bidaltzen den irudiak ahalik eta txikiena izan behar du eta ez du garapeneko menpekotasunik eduki behar. Hori eginez gero, beharrezko kodea soilik bidaliko dela eta balizko erasoen kopurua (hau da, erasoaren azalera) minimizatuko dela bermatzen da, eta, hori lor daiteke menpekotasun guztiak lehenik instalatuz eta azkenean npm ci --production exekutatuz, beti ere etapa anitzeko eraikuntza erabiltzen denean (ikusi buleta dedikatua)
Bestela: npm segurtasun arau hauste ezagun asko garapen paketeen barruan aurkitu izan dira (adibidez, eslint-scope)
🔗 Informazio gehiago: ezabatu garapen menpekotasunak

 8.6. Itzali arazorik gabe eta dotore
TL;PL: kudeatu prozesuaren SIGTERM gertaera eta garbitu lehendik dauden konexio eta baliabide guztiak. Hori etengabeko eskaerei erantzutean egin behar da. Dockerized exekutatzen den bitartean edukiontziak ixtea ez da arraroa, baizik eta ohiko lanaren zati gisa maiz gertatzen den zerbait. Hori lortzeko ondo pentsatutako kodea prestatu beharra dago hainbat elementu koordinatuz: karga orekatzailea, mantentze konexioak, HTTP zerbitzaria eta beste baliabide batzuk
Bestela: berehala hiltzeak etsita dauden milaka erabiltzaileri ez erantzutea ekarriko du
🔗 Informazio gehiago: itzalaldi dotorea

 8.7. Ezarri memoria mugak Docker eta v8 erabiliz
TL;PL: konfiguratu beti memoria muga bai Docker bai JavaScript exekuzio adierazgailak erabiliz. Dockerren muga beharrezkoa da edukiontzien kokapena erabakitzeko; --v8ren bandera max-old-space beharrezkoa da GC garaiz abiarazteko eta memoria erabiltzea saihesteko. Praktikan, ezarri v8rren espazio memoria zaharra edukiontziaren muga baino apur bat txikiagoa izan dadin
Bestela: Dockerren definizioa beharrezkoa da eskalatutako erabakiak burutzeko eta beste herritarrak gosez hiltzea ekiditeko. V8rren mugak zehaztu gabe ere, edukiontziaren baliabideak erabiliko ditu. Argibide espliziturik gabe, baliabideen %50-60a erabiltzean huts egiten du
🔗 Informazio gehiago: ezarri memoria mugak Docker erabiliz soilik

 8.8. Baliatu cachea konpilazio denbora murrizteko
TL;PL: Dockerren irudi osoa cache-tik berreraikitzea ia berehalakoa izan daiteke, zuzen eginez gero. Eguneratu ez diren argibideek Dockerfile fitxategiaren goialdean egon behar dute, eta etengabe aldatzen ari direnek (aplikazioaren kodea, esate baterako) beheko aldean egon behar dute
Bestela: Docker eraikitzeak oso luze jo dezake eta baliabide asko kontsumituko ditu, nahiz eta aldaketa txikiak egin
🔗 Informazio gehiago: baliatu cachea konpilazio denborak murrizteko

 8.9. Erabili irudiaren erreferentzia esplizitua, saihestu "azken" (latest) etiketa
TL;PL: zehaztu irudi laburpen esplizitu bat edo etiketa baten bertsioa, inoiz ez aipatu latest. Garatzaileek sarritan uste izaten dute, latest adieraziz gero, biltegiko azken irudia eskuratuko dutela, baina ez da horrela. Laburpena erabiltzeak zerbitzuaren instantzia guztiek kode bera exekutatuko dutela bermatzen du
Gainera, irudi etiketa bat aipatzen bada, oinarrizko irudia aldatu egin daiteke, ez baitago irudi etiketekin fidatzerik instalazio determinista bat egiteko orduan. Horren ordez, instalazioa determinista izanez gero, SHA256 laburpena erabil daiteke irudi zehatza erreferentziatzeko
Bestela: oinarrizko irudi baten bertsio berri bat erabiliz gero, aldaketa handiak gerta litezke produkzioan, horrek aplikazioaren nahigabeko portaera sortuz
🔗 Informazio gehiago: ulertu irudi etiketak eta erabili "azken" (latest) etiketa kontu handiz

 8.10. Hobetsi Docker oinarrizko irudi txikiagoak
TL;PL: irudi handiek ahultasun gehiago izateko arriskua handitu eta baliabideen kontsumoa areagotzen dute. Docker irudi arinagoak erabiltzeak, Slim eta Alpine Linux aldaerak adibidez, arazo hori arindu egiten du
Bestela: batetik, denbora gehiago beharko da irudiak eraiki, txertatu eta ateratzeko; bestetik, erabiltzaile maltzurrek eraso bektore ezezagunak erabil ditzakete; eta, azkenik, baliabide gehiago beharko dira
🔗 Informazio gehiago: hobetsi irudi txikiagoak

 8.11. Garbitu eraikitze faseko sekretuak, saihestu sekretuak argudioetan
TL;PL: saihestu Dockerren konpilazio inguruneko sekretuak agerian geratzea. Docker irudi bat IE bezalako ingurune anitzetan eta ekoizpena bezain garbituta ez dauden erregistroetan partekatzen da normalean. Adibide tipikoa npm giltza (tokena) da, normalean dockerfile fitxategi batera pasatzen dena argumentu gisa. Giltza hori irudiaren barruan geratzen da denbora luzez beharrezkoa izateari utzi ondoren ere, eta erasotzaileari npm erregistro pribatura sartzeko aukera ematen dio. Hori ekidin daiteke sekretua .npmrc bezalako fitxategi batean kopiatuz, eta, ondoren, sekretu hori kenduz etapa anitzeko eraikuntza bat erabiliz (kontuz, eraikitze historia ere ezabatu beharko litzateke) edo bat ere aztarnarik uzten dituen Docker build-kit funtzio sekretua erabiliz
Bestela: IE eta docker erregistroan sartzeko aukera duten guztiek erakundearen sekretu preziatuak ere eskuratzeko aukera izango dute onura gehigarri gisa
🔗 Informazio gehiago: garbitu eraikitze faseko sekretuak

 8.12. Eskaneatu ahultasun geruza anitzeko irudiak
TL;PL: kode menpekotasunen ahultasunak egiaztatzeaz gain, eskaneatu ekoizpenera bidalitako azken irudia ere. Dockerren irudien eskanerrek kodeen menpekotasunak egiaztatzen dituzte, baina baita sistema eragilearen binarioak ere. E2E segurtasun eskaneatze horrek eremu handiago bat hartzen du eta egiaztatzen du inongo erabiltzaile maltzurrak ez duela maltzurkeriatik egin eraikitze aldian zerbait injektatuz. Ondorioz, hau exekutatzea gomendatzen da hedapenaren aurreko azken urrats gisa. Mordoska bat eskaner doako eta komertzial dago CI / CD pluginak ere eskaintzen dituztenak
Bestela: baliteke zure kodeak ahultasunik ez izatea. Hala ere, baliteke oraindik ere hackeatua izatea, aplikazioek normalean erabiltzen dituzten sistema eragilearen mailako binarioen bertsioak ahultasunak dituelako (adibidez, OpenSSL, TarBall)
🔗 Informazio gehiago: Docker praktika arruntak

 8.13 Garbitu NODE_MODULE cachea
TL;PL: menpekotasunak edukiontzi batean instalatu ondoren, kendu bertako cachea. Ez du inolako zentzurik etorkizuneko instalazio azkarragoetarako menpekotasunak bikoizteak, ez baita beste instalaziorik egingo: Dockeren irudiak aldaezinak dira. Kode lerro bakarra erabiliz dozenaka MB aurrezten dira (normalean, irudiaren tamainaren % 10-50)
Bestela: ekoizpenera bidaliko den irudiak % 30 gehiago pisatuko du, inoiz erabiliko ez diren fitxategiak direla eta
🔗 Informazio gehiago: garbitu NODE_MODULE cachea

 8.14. Dockeren praktika generikoak
TL;PL: hemen duzu Node.jsrekin zuzenean loturarik ez duen Docker aholkuen bilduma. Ez dago alderik Noderen eta beste edozein lengoaiaren inplementazioen artean. Egin klik “Informazio gehiago” botoian
🔗 Informazio gehiago: Dockeren praktika generikoak

 8.15. Garbitu zure Dockerfile fitxategia Linterra erabiliz
TL;PL: Linterra erabiliz zure Dockerfile fitxategia garbitzea urrats garrantzitsua da haren barruan praktika onak errespetatzen ez dituzten arazoak identifikatzeko. Docker garbitzaile (linter) espezializatu bat erabiliz errendimendu eta segurtasun hobekuntzak erraz atzematen dira, alferrikako ordu ugari aurreztea edo produkzio kodean segurtasun arazoak murriztea lortuz
Bestela: okerrez, Dockerfile fitxategiaren sortzaileak nagusi (root) bat utzi zuen produkzio erabiltzaile moduan, eta jatorri ezezaguneko biltegi irudi bat ere erabili zuen. Hori liner soil batekin ekidin liteke.
🔗 Informazio gehiago: garbitu zure Dockerfile fitxategia

⬆ Itzuli hasierara
Mugarriak
Gida hau mantentzeko eta eguneratuta egoteko, jarraibideak eta praktika onak eguneratzen eta hobetzen ari gara etengabe komunitatearen laguntzarekin. Proiektu honetan lagundu nahi baduzu, jarraitu gure mugarriak jarrai sartu lantaldeetan

Itzulpenak
Komunitatearen ekarpena dira hemengo itzulpen guztiak eman. Oso pozik hartuko genituzke zure itzulpenak, bai dagoeneko eginda dauden testuenak zein egiten ari garen eta egingo ditugunenak
Amaitutako itzulpenak

 Brasilgo portugalera - Marcelo Melo-ren eskutik
 Txinera - Matt Jin-ren eskutik
 Errusiera - Alex Ivanov-ren eskutik
 Poloniera - Michal Biesiada-ren eskutik
 Euskara - Ane Diaz de Tuesta & Joxefe Diaz de Tuestaren eskutik

Aribidean dauden itzulpenak

 Frantsesa (Eztabaidan)
 Hebrearra (Eztabaidan)
 Koreera - Sangbeom Han-ren eskutik (Eztabaidan)
 Gaztelera (Eztabaidan)
 Turkiera (Eztabaidan)


Zuzendaritza Batzordea
Ezagutu Zuzendaritza Batzordeko kideak, proiektuaren orientazioa eta etorkizunerako jarraibideak emateko elkarlanean dirautenak. Gainera, batzordeko kide bakoitza gure Github projects-pean dagoen proiektu baten buru da

Yoni Goldberg


EEBB-etan, Europan eta Israelen, bezeroekin tamaina handiko Node.js aplikazioen sorkuntzan lan egiten duen Node.jsren inguruko aholkulari independentea. Gida honetako praktika on asko lehenengo aldiz goldbergyoni.com-en argitaratuak izan ziren. Jar zaitez Yoni-rekin kontatuan @goldbergyoni-en edo me@goldbergyoni.com helbidearen bidez


Bruno Scheufler

💻 full-stack web ingeniaria, Node.js eta GraphQL zalea


Kyle Martin


Full Stack Garatzailea eta Zelanda Berrian lan egiten duen Site Reliability Ingeniaria, web aplikazioen segurtasutasunean eta egituraketan, eta tamaina handiko Node.js aplikazioen sorkuntzan interesa du


Kevyn Bruyere

Full-stack garatzaile independentea, Ops eta automatizazioan zaletua dena

Steering Committee Emeriti

Sagir Khan



Javascripten eta bere ekosisteman (React, Node.js, TypeScript, GraphQL, MongoDB, eta sistemako JS/JSON edozein geruzatan eragin dezakeen edozer) aditua, munduko marka ezagunenetarako produktuak sortzen ditu web plataforma erabiliaz. Node.js Fundazioko Banakako Kidea

Languntzaileak
Mila esker gure laguntzaile guztiei! 🙏
Gure kolaboratzaileak proiektuan maiz parte hartzen duten kideak dira, praktika onak proposatuz, gaien zerrenda ordenatuz, parte hartze eskaerak (pull request) aztertuz... Milaka pertsona Node.js aplikazioak hobeto sortzen laguntzen interesa baduzu, irakur ezazu gure kolaboratzaile gida 🎉









Ido Richter (Fundatzailea)
Keith Holliday



Emeriti Kolaboratzailea








Refael Ackermann




Parte hartu
Open sourcen parte hartu nahi baduzu, hemen duzu aukera! Gehiago jakiteko, irakurri parte hartu dokumentua
Parte hartzaileak ✨
Eskerrik asko proiektu honetan parte hartu duten pertsona zoragarriei!




  
    
      Kevin Rambaud🖋
      Michael Fine🖋
      Shreya Dahal🖋
      Matheus Cruz Rocha🖋
      Yog Mehta🖋
      Kudakwashe Paradzayi🖋
      t1st3🖋
    
    
      mulijordan1976🖋
      Matan Kushner🖋
      Fabio Hiroki🖋
      James Sumners🖋
      Dan Gamble🖋
      PJ Trainor🖋
      Remek Ambroziak🖋
    
    
      Yoni Jah🖋
      Misha Khokhlov🖋
      Evgeny Orekhov🖋
      -🖋
      Isaac Halvorson🖋
      Vedran Karačić🖋
      lallenlowe🖋
    
    
      Nathan Wells🖋
      Paulo Reis🖋
      syzer🖋
      David Sancho🖋
      Robert Manolea🖋
      Xavier Ho🖋
      Aaron🖋
    
    
      Jan Charles Maghirang Adona🖋
      Allen🖋
      Leonardo Villela🖋
      Michał Załęcki🖋
      Chris Nicola🖋
      Alejandro Corredor🖋
      cwar🖋
    
    
      Yuwei🖋
      Utkarsh Bhatt🖋
      Duarte Mendes🖋
      Jason Kim🖋
      Mitja O.🖋
      Sandro Miguel Marques🖋
      Gabe🖋
    
    
      Ron Gross🖋
      Valeri Karpov🖋
      Sergio Bernal🖋
      Nikola Telkedzhiev🖋
      Vitor Godoy🖋
      Manish Saraan🖋
      Sangbeom Han🖋
    
    
      blackmatch🖋
      Joe Reeve🖋
      Ryan Busby🖋
      Iman Mohamadi🖋
      Sergii Paryzhskyi🖋
      Kapil Patel🖋
      迷渡🖋
    
    
      Hozefa🖋
      Ethan🖋
      Sam🖋
      Arlind🖋
      Teddy Toussaint🖋
      Lewis🖋
      Gabriel Lidenor 🖋
    
    
      Roman🖋
      Francozeira🖋
      Invvard🖋
      Rômulo Garofalo🖋
      Tho Q Luong🖋
      Burak Shen🖋
      Martin Muzatko🖋
    
    
      Jared Collier🖋
      Hilton Meyer🖋
      ChangJoo Park(박창주)🖋
      Masahiro Sakaguchi🖋
      Keith Holliday🖋
      coreyc🖋
      Maximilian Berkmann🖋
    
    
      Douglas Mariano Valero🖋
      Marcelo Melo🖋
      Mehmet Perk🖋
      ryan ouyang🖋
      Shabeer🖋
      Eduard Kyvenko🖋
      Deyvison Rocha🖋
    
    
      George Mamer🖋
      Konstantinos Leimonis🖋
      Oliver Lluberes🌍
      Tien Do🖋
      Ranvir Singh🖋
      Vadim Nicolaev🖋 🌍
      German Gamboa Gonzalez🖋
    
    
      Hafez🖋
      Chandiran🖋
      VinayaSathyanarayana🖋
      Kim Kern🖋
      Kenneth Freitas🖋
      songe🖋
      Kirill Shekhovtsov🖋
    
    
      Serge🖋
      keyrwinz🖋
      Dmitry Nikitenko🖋
      bushuai👀 🖋
      Benjamin Gruenbaum🖋
      Ezequiel🌍
      Juan José Rodríguez🌍
    
    
      Or Bin🖋
      Andreo Vieira🖋
      Michael Solomon🖋
      Jimmy Callin🖋
      Siddharth🖋
      Ryan Smith🖋
      Tom Boettger🖋
    
    
      Joaquín Ormaechea🌍
      dfrzuz🌍
      Victor Homyakov🖋
      Josh🖋 🛡️
      Alec Francis🖋
      arjun6610🖋
      Jan Osch🖋
    
    
      Thiago Rotondo Sampaio🌍
      Alexsey🖋
      Luis A. Acurero🌍
      Lucas Romano🌍
      Denise Case🖋
      Nick Ribal🖋 👀
      0xflotus🖋
    
    
      Jonathan Chen🖋
      Dilan Srilal🖋
      vladthelittleone🌍
      Nik Osvalds🖋
      Daniel Kiss📖
      Forresst🖋
      Jonathan Svenheden🖋
    
    
      AustrisC🖋
      kyeongtae kim🌍
      007🖋
      Ane Diaz de Tuesta🌍 🖋
      YukiOta🌍
      Frazer Smith🖋
      Raz Luvaton🖋
    
    
      Yuta Azumi🖋
      andrewjbarbour🖋
      mr🖋
      Aleksandar🖋
      Owl🖋
      Yedidya Schwartz🖋 💡
      ari🖋
    
    
      Thomas König🖋
      Kalle Lämsä🖋
      Wyatt🖋
      KHADIR Tayeb🖋
      Shankar Regmi🖋
      Shubham🖋
      Lucas Alves🖋
    
    
      Benjamin🖋
      Yeoh Joer🖋
      Miigon🖋
      Rostislav Bogorad🖋
      Flouse🖋
      Tarantini Pereira🖋
      Kazuki Matsuo🖋
    
    
      Adam Smith🖋
      Dohyeon Ko🖋
      Vladislav Legkov🖋
      Kerollos Magdy🖋
      Erez Lieberman🖋
      Breno Macedo🖋
      Fernando Flores🌍
    
    
      Rafael Brito🌍
      Emiliano Peralta🌍
      Shin, SJ🖋
      Benjamin Forster🖋
      Daniele Fedeli🖋
      djob195🖋
      antspk🖋
    
    
      정진영🖋
      kkk-cashwalk🖋
      apainintheneck🖋
      Fajar Budhi Iswanda🖋
      이주호🖋
      Singh🖋
      Alex Dumitru🖋
    
    
      Anton Lykhatskyi🖋
      sangwonlee🖋
      Eugenio Berretta🖋
      soranakk🖋
      고준영🖋 💻
      Guilherme Portella 🖋
      André Esser🖋
    
    
      Scc🌍
      Mauro Accornero🖋
      no-yan🖋\n\ngoldbergyoni
    
    /
    
      nodebestpractices
    

    Public
  


        

        
            
    
      

  
                Notifications
    You must be signed in to change notification settings

  

  
              Fork
    10.4k

  

  
        
            
          Star
          102k

  



        
      

        



          

  
      
  
    
              
        Code
          


    

      
  
    
              
        Issues
          44


    

      
  
    
              
        Pull requests
          36


    

      
  
    
              
        Actions
          


    

      
  
    
              
        Projects
          0


    

      
  
    
              
        Security
          

    

      
  
    
              
        Insights
          


    


          
  
      
Additional navigation options



  
    
                
  
    
        
    
    
    
        
          
        
      
        
          Code
      

  

        
    
    
    
        
          
        
      
        
          Issues
      

  

        
    
    
    
        
          
        
      
        
          Pull requests
      

  

        
    
    
    
        
          
        
      
        
          Actions
      

  

        
    
    
    
        
          
        
      
        
          Projects
      

  

        
    
    
    
        
          
        
      
        
          Security
      

  

        
    
    
    
        
          
        
      
        
          Insights
      

  

    




      
  



  

  




    
    



    
      
    









  
  
     Files masterBreadcrumbsnodebestpractices/README.basque.mdCopy path Blame  Blame        Latest commit HistoryHistory1635 lines (990 loc) · 180 KB masterBreadcrumbsnodebestpractices/README.basque.mdTopFile metadata and controlsPreviewCodeBlame1635 lines (990 loc) · 180 KBRawNode.js-ren praktika onak

  



    


 Hemen ere bagaude! @nodepractices

Irakurri beste hizkuntza batzuetan: EN, CN, BR, RU, PL,JA (ES, FR, HE, KR eta TR aribidean!)

Gure Zuzendaritza Batzordeak  eta laguntzaileek eraiki eta mantentzen dute webgune hau
Azken praktika onak eta albisteak


 Euskarazko itzulpena!: wow gure euskal irakurleek ere gida hau bere ama-hizkuntzan irakur dezakete! Ane Diaz de Tuesta eta Joxefe Diaz de Tuestaren eskutik


🇯🇵 Japonierazko itzulpena: hemendik aurrera japonieraz erabili daiteke gure gida, YukiOta eta Yuta Azumi gure laguntzaile ikaragarriei esker


🎊 60.000 izar!: Gure biltegiak 60.100 garatzaileren aitortza eta konfiantza jaso ditu. Hitzik gabe gaude



Ongi etorri! Hasi aurretik jakin beharreko 3 gauza
1. Hemen dozenaka artikulu dauzkazu, onenetarikoak Node.jsri buruz egindakoetan: alegia, bilduma honek Node.jsren praktika onak jasotzen ditu, edukien arabera sailkatuta
2. Dagoen bildumarik handiena da, eta astetik astera handiagoa da: une honetan 80tik gora praktika, estilo eskuliburu eta arkitektura aholku dauzkagu bilduta. Gustura asko jasoko genituzke zure ekarpenak bilduma hau eguneratuta edukitzeko, bai kode akatsak konponduz, bai itzulpenak eginez, bai ideia berriak proposatuz egin ditzakezunak: izan zaitez Node.jsren praktika onen liburuko partaide. Ikusi gure idazketa jarraibideak
3. Jarraibide gehienek informazio gehigarria dute. Jarraibideko puntu bakoitzaren ondoan 🔗Informazio gehiago esteka aurkituko duzu, jarraibidea osatzen duena kode adibideekin, blogetako aipu hautatuekin eta informazio osagarri gehiagorekin

Edukien aurkibidea

Proiektuaren egitura (5)
Erroreen kudeaketa (12) 
Kode estiloa (12) 
Probak eta kalitate orokorra (13) 
Ekoizpena (19) 
Segurtasuna (25)
Errendimendua (2) (Aribidean ✍️)
Docker, praktika onak (15)


1. Proiektuaren egitura
 1.1 Antolatu zure proiektua atal eta osagai txikiagotan
TL;PL: aplikazio handien oztoporik handiena kode base erraldoi bat mantendu beharra da, ehundaka lotura eta menpekotasun dituena. Horrelako lan monolitikoek programatzaileen lana motelarazten dute, funtzionalitate berriak gehitzen saiatzen dira eta. Hori gerta ez dadin, zatitu zure kodea osagai txikiagotan, bakoitza bere datuekin karpeta banatan, eta bermatu osagai bakoitza laburra eta sinplea izatea. Bisitatu hemen behean dagoen “Informazio gehiago” esteka, proiektu egoki baten egitura zuzenaren adibideak ikusteko
Bestela: funtzionalitate berriak programatzean, garatzaileek zailtasun handiak izaten dituzte aldaketa horien eragina atzemateko, eta beldur izaten dira funtzionalitateon menpeko osagaiak hautsiko ote dituzten. Ondorioz, inplementazioak motelagoak eta arriskutsuagoak izaten dira. Oro har, zailagoa izaten da aplikazio baten kodea luzatzea negozio unitateak banatuta ez daudenean
🔗 Informazio gehiago: antolatu zure proiektua osagai txikiagotan

 1.2 Antolatu zure aplikazioa geruzatan eta mantendu webaren geruza bere esparruaren barruan
TL;PL: osagai bakoitzak «geruzak» izan beharko lituzke: hau da, berariaz weberako egindako objektu bat; beste bat, logikarako; eta beste bat, datuen sarbidearen koderako. Horrek, zati bakoitzaren funtzioak ondo bereizteko aukera eskaintzeaz gainera, sistema errazago simulatu eta testatzea ahalbidetzen du. Modelo hau oso ohikoa bada ere, APIen garatzaileek joera izaten dute geruzak nahasteko, webeko objektu espezifikoa (Express req, res) logika operatiboaren eta datuen geruzetara pasatuz, eta, ondorioz bai aplikazioa bai sarbidea Expressen menpeko bihurtzen dira
Bestela: aplikazio batean webeko objektuak beste geruzekin nahastuta badaude, ezingo da bertara sartu testak, CRON atazak eta Express middleware-ak baino erabiliz
🔗 Informazio gehiago: antolatu zure aplikazioa geruzatan

 1.3 Kokatu baliabide komunak npm paketetan
TL;PL: datu base askok osatzen duten aplikazio handi bat prestatzen dugunean, geruza guztietan lan egiten duten zeharkako tresna bakoitzak –erregistragailuak, zifragailuak eta beste– bere kodearen barruan egon behar du, npm pakete pribatu moduan, tresna horiek hainbat proiektutan partekatu ahal izatea ahalbidetzen duena
Bestela: zuk zeuk asmatu beharko duzu zeure inplementazioa eta menpekotasun gurpila
🔗 Informazio gehiago: antolatu funtzioen arabera

 1.4 Banandu Express 'aplikazioa' eta 'zerbitzaria'
TL;PL: ekidin Express aplikazioa artxibo handi batean oso-osorik definitzeko ohitura desegokia. Banandu Express aplikazioaren definizioa bi artxibotan gutxienez: batetik, APIaren definizioa (app.js); eta, bestetik, sarearen ezaugarriak (WWW). Are gehiago, egitura egokiagoa izan dadin, jarri APIaren definizioa osagaiekin batera
Bestela: probak egiteko, HTTP deien bidez baino ezingo da zure APIra sartu. Sarbide hori motelagoa da eta asko zailtzen du estaldura txostenak egitea. Gainera, ziur aski, ez da bat ere atsegina izango ehundaka lerro dituen kodea mantentzea
🔗 Informazio gehiago: banandu Express 'aplikazioa' eta 'zerbitzaria'

 1.5 Erabili ingurunea errespetatzen duen konfigurazio seguru eta hierarkiko bat
TL;PL: akatsik gabeko konfigurazio perfektu batek bermatu behar du (a) giltzak fitxategietatik eta inguruneko aldagaietatik irakurri ahal izatea, (b) sekretuak iturri kodetik kanpo gordeta egotea, eta, (c), bilaketak errazte aldera, konfigurazioa hierarkikoa izatea. Hori dena lortzeko badira paketeak, hala nola, rc, nconf, config eta convict
Bestela: konfiguazioa egitean baldintza horietarikoren bat betetzen ez baduzu, lana moteldu egingo da, bai garapen taldearena, bai devops taldearena
🔗 Informazio gehiago: konfigurazio praktika onak

⬆ Itzuli hasierara
2. Erroreen kudeaketa
 2.1 Erabili Async-Await edo errore asinkronoak kudeatzeko promesak
TL;PL: errore asinkronoak callback erabiliz kudeatzen badituzu, infernurako biderik azkarrena hartuko duzu edo galbiderako piramidean sartuko zara. Zure kodeari opari on bat egin nahi badiozu, erabili agintzen liburutegi ezagun bat edo async-await, try-catch erakoa adibidez kode sintaxis askoz trinkoago eta ohikoago bat eskaintzen duena
Bestela: Node.jsren callback teknika (“err, response” prozedura) erabiltzen baduzu, kode ez jasangarriak sortuko dituzu, batera suertatuko baitira kode arrunta duten erroreen kudeaketa, habiaratze sarriegiak eta kodetze eredu ez erosoak
🔗 Informazio gehiago: ekidin callback prozedurak

 2.2 Erabili soilik “Errorea” objektu kapsulatua
TL;PL: maiz, erroreak kate gisa edo modu pertsonalizatuan agertzen dira, erroreak kudeatzeko logika zaildu eta moduluen arteko elkarreragingarritasuna oztopatzen duena. Agintza bat baztertu zein salbuespen bat ezarri edo errore ohar bat argitaratzen duzunean, soilik “Errorea” objektu kapsulatua –edo “Errore txertatua“ objektua zabaltzen duen objektua– erabiliz lortuko duzu bermatzea bateratasuna handitu eta informazioa ez galtzea
Bestela: osagairen bati deitzean erroreak zein motatakoak diren jakin gabe, askoz zailagoa da eurak kontrolatzea. Are okerrago, erroreak deskribatzeko modu pertsonalizatuak erabiltzeak errore kritikoen informazioa galtzea ekar dezake, pilaren aztarna, besteak beste
🔗 Informazio gehiago: erabili soilik “Errorea” objektu kapsulatua

 2.3 Bereizi eragiketa erroreak eta programatze erroreak
TL; PL: eragiketa erroreek (adibidez, APIak balio gabeko sarrera jasotzea) agerian jartzen dituzten arazoak ezagunak izaten dira, eta, haien eragina guztiz ulertu eta kontuz kudeatzeko modukoak izaten dira. Bestetik, programatze erroreak (adibidez, zehaztu gabeko aldagaia irakurtzen saiatzea) aplikazioa berrabiarazteko agindua ematen duten kode hutsegite ezezagunak izaten dira
Bestela: beti berrabiaraz dezakezu aplikazioa errore bat agertzen denean. Baina zergatik utzi 5.000 erabiltzaile offline iragarri daitekeen errore funtzional txiki batengatik? Kontrakoa ere ez da egokia: arazo ezezagun bat gertatzen denean -programatze errore bat, esaterako- aplikazioa martxan mantentzeak ezusteko jokaerak eragin ditzake. Biak bereizteak aukera ematen du kontuz jokatzeko eta ikuspegi orekatu bat aplikatzeko testuinguruan oinarrituz
🔗 Informazio gehiago: eragiketa erroreak vs programatze erroreak

 2.4 Kudeatu erroreak gune bakar batean, Express middleware erabili partez
TL;PL: erroreak kudeatzeko logika -hala nola, haien erregistroa eramatea eta administratzaileari mezuak bidaltzea- objektu dedikatu zentralizatu batean kapsulatu behar da, erroreren bat gertatzen denean helmuga guztiek (adibidez, Express middlewarea, cron atazak, atalkako egiaztatzeak) hara deitu dezaten
Bestela: erroreak toki bakarrean ez kudeatzeak kodea bikoiztea eragiten du eta, ziur aski, erroreak gaizki kudeatzea ere bai
🔗 Informazio gehiago: kudeatu erroreak gune bakar batean

 2.5 Dokumentatu aplikazioaren erroreak Swagger edo GraphQL-ren laguntzarekin
TL;PL: jakinaren gainean jarri aplikazioaren deitzaileak erroreak berriro gerta daitezkeela, errore horiek behar bezala konpondu ahal izateko hutsik egin gabe. RESTful aplikazioetan Swagger bezalako dokumentazio esparruak erabiltzen dira. GraphQL erabiltzen baduzu, zeure eskema eta azalpenak erabil ditzakezu
Bestela: aplikazio baten bezeroak erabaki dezake aplikazioa itxi eta berrabiaraztea, ulertzen ez duen errore baten abisua jaso duelako soil-soilik. Oharra: zu zeu izan zaitezke zure aplikaziotik deitzen duena (oso ohikoa mikrozerbitzu inguruneetan)
🔗 Informazio gehiago: dokumentatu aplikazioaren erroreak Swagger edo GraphQLren laguntzarekin

 2.6 Irten prozesutik elegantziarekin kanpoko norbait iristen denean hirira
TL;PL: errore ezezagun bat gertatzen denean (programazio errore bat, ikusi 2.3 praktika ona), zalantza izaten da era egokian lanean ote dabilen aplikazioa. Kasu horietan, oso ohikoa izaten da prozesuak kudeatzeko tresna bat erabiltzea Forever, PM2 edo antzekoren bat– prozesua berriro hasteko
Bestela: ezagutzen ez duzun zerbait gertatzen denean, izan daiteke objekturen batzuk egoera txarrean daudelako (esaterako, globalki erabiltzen den gertaera igorle bat, barneko erroreren batengatik ondo ez dabilena) eta gerta daiteke aurrerantzean abisuek huts egitea edo modu ero samarrean funtzionatzea
🔗 Informazio gehiago: gelditu prozesua

 2.7 Erabili erregistratze tresna helduak erroreen ikusgaitasuna handitzeko
TL;PL: erregistratze tresna helduen sortak erabiltzen badituzu –Pino edo Log4js, adibidez–, erroreak lehenago atzeman eta ulertuko dituzu. Beraz, utzi alde batera console.log
Bestela: console.log-ak arakatu behar badituzu edo testua desordenatua duen artxibo batean erroreak eskuz, kontsulta tresnarik gabe edo erregistratze bisore ganorazkorik gabe bilatu behar badituzu, ordu asko emango dituzu lanean gaueko ordu txikiak arte
🔗 Informazio gehiago: erabili erregistratze tresna helduak

 2.8 Testeatu erroreen fluxua zure test framework gustukoena erabiliz
TL;PL: kalitate profesionaleko kontrol tresna automatizatu bat izan zein programatzaileentzako eskuzko test soil bat izan, bermatu zure kodeak ez duela egoera positiboetan bakarrik lan egiten, baizik eta errore zuzenak ere kudeatu eta birbidaltzen dituela. Mocha eta Chai bezalako unitate test frameworkek erraz egin dezakete lan hori (ikusi “Gist leiho”ko kode adibideak)
Bestela: automatikoki zein eskuz probarik egin gabe ezin duzu konfiantzarik izan zure kodeak benetako erroreak atzemango dituen. Errore adierazgarririk gabe ez dago erroreak kudeatzerik
🔗 Informazio gehiago: testeatu erroreen fluxua

 2.9 Aurkitu erroreak eta jardunik gabeko uneak APM produktuak erabiliz
TL;PL: monitorizazio eta errendimendu produktuek (APM, ingelesezko siglen arabera) modu proaktiboan ebaluatzen dute zure kode basea edo aplikazioa automatikoki aurkitu ahal izan ditzaten erroreak, blokeoak eta atzeman ezin dituzun eraginkortasun txikiko atalak
Bestela: denbora asko pasa zenezake zure aplikazioaren errendimendua eta jardunik gabeko uneak neurtzen, eta, hala ere, ez zenuke aurkituko zeintzuk diren zure kodearen zatirik motelenak egoera errealetan eta ez zenuke inoiz jakingo nola eragiten dioten erabiltzailearen lanari
🔗 Informazio gehiago: APM produktuen erabilera

 2.10 Atzeman kudeatu gabeko agintzen arbuioak
TL;PL: agintza baten barruan dauden salbuespenak xurgatuak eta baztertuak izango dira programatzaileak modu esplizituan kudeatzen ez baditu, haren kodea process.uncaughtException-ari atxikia egonda ere. Ekidin hori process.unhandledRejection erabiliz
Bestela: zure erroreak xurgatuak izango dira eta ez da haien arrastorik geratuko. Ez duzu zertaz kezkatu
🔗 Informazio gehiago: atzeman kudeatu gabeko aginduen arbuioak

 2.11 Huts egin azkar, balidatu argudioak liburutegi dedikatu baten laguntzarekin
TL;PL: Express erabiltzen duzunean, zure praktika onetako bat izan beharko litzateke aplikazioaren sarbidea kontrolatzea, ustegabeko erroreak ekiditeko, aurrerago erroreak atzematea askoz zailagoa izaten da eta. Balidazio kodea gogaikarria izan ohi da, ajv eta Joi bezalako laguntza liburutegi moderno bat erabili ezean
Bestela: pentsatu zure funtzioa agintza numeriko baten zain dagoela, adibidez «deskontua», eskatzaileak bidaltzea ahaztu duena; geroago, haren kodeak baieztatzen du « deskontua! = 0 (baimendutako deskontua zero baino handiagoa da)», eta horrek ahalmena ematen dio erabiltzaileari deskontua izateko. Ene, nolako errore arriskutsua! Konturatzen zara?
🔗 Informazio gehiago: huts eragin azkar

 2.12 Agintzen zain egon beti itzuli aurretik, pilak arrastorik uztea saihesteko
TL; PL: beti egin return await promesa bat itzultzean, pila osoaren jarraipena egin ahal izateko. Funtzio batek promesa bat itzultzen badu, funtzio hori async, hau da, asinkronotzat jo behar da, eta esplizituki await, itxaron agintza, itzuli aurretik
Bestela: itxaron gabe agintza itzultzen duen funtzioa ez da pilaren arrastoan agertuko. Galdutako fotograma horiek akatsa eragingo duen fluxua ulertzea zailduko lukete, batez ere portaera anormalaren zergatia falta den funtzioaren barruan baldin badago
🔗 Informazio gehiago: agintzak itzultzea

⬆ Itzuli hasierara
3. Kode estiloa
 3.1 Erabili ESLint
TL;PL: ESLint da gerta daitezkeen kode erroreak egiaztatzeko eta kodearen estiloa zuzentzeko estandarra. Ez da soilik erabiltzen tarteen arazoak identifikatzeko, baizik eta kodearen antipatroi kritikoak atzemateko ere, hala nola garatzaileen errore ez-sailkatuak. ESLint kode estiloak automatikoki zuzentzeko gai bada ere, badira beste tresna batzuk eraginkorragoak direnak zuzenketak egiten –esaterako, prettier eta beautify– eta, gainera, ESLintekin batera egiten dute lan
Bestela: garatzaileek arreta jarriko dute hain gogaikarriak diren arazo batzuk konpontzen –kodearen tarteak eta lerroaren luzera–, eta denbora gehiegi gal dezakete proiektuaren kode estiloa aztertzen
🔗 Informazio gehiago: erabili ESLint eta Prettier

 3.2 Node.jsrentzako plugin espezifikoak
TL;PL: ESLintek Vanilla JavaScript babesteko dituen arau estandarretatik aparte, komeni da Node.jsren osagai espeziko batzuk erabiltzea, hala nola eslint-plugin-node, eslint-plugin-mocha eta eslint-plugin-node-security
Bestela: Node.jsren arau akastun batzuek radarraren kontrolari ihes egin ahal diote. Esaterako, garatzaileek sarbide moduan aldagai jakin baten beharra izan dezakete (require(variableCommeChemin)), edozein JS script erabiltzeko aukera ematen diena erasotzaileei. Node.jsren linterrek patroi horiek atzeman ditzakete eta garaiz jo alarma

 3.3 Jarri kode multzo baten giltzak lerro bakarrean
TL;PL: kode bloke baten hasierako parentesiak irekiera instrukzioaren lerroan egon behar du
Kode adibidea
// Egin
function edozeinFuntzio() {
  // kode blokea
}

// Baztertu
function edozeinFuntzio()
{
  // kode blokea
}
Bestela: praktika on hau ez erabiltzeak ustekabeko emaitzak eragin ditzake, behean dagoen StackOverflow-en eztabaida harian ikus daitekeen bezala:
🔗 Informazio gehiago: “Zergatik aldatzen dira emaitzak giltzen kokapenaren arabera?” (StackOverflow)

 3.4 Bereizi instrukzioak modu egokian
Ez dio axola instrukzioak bereizteko puntu eta koma erabiltzen duzun edo ez, ohiko lerro jauzi okerrak edo koma txertatze automatikoak ezagutzeak lagundu egingo dizu ohiko errore sintaktikoak ez egiten
TL;PL: erabili ESLint bereizketetan izaten diren erroreez jabetzeko. Prettier edo Standardjs erabiliz automatikoki konpon ditzakezu arazo horiek
Bestela: aurreko atalean esan bezala, JavaScripteko interpreteak automatikoki “puntu eta koma” gehitzen du instrukzio baten amaieran “puntu eta koma”rik ez badago edo instrukzioa behar den tokian ez dela amaitu eta horrek okerreko emaitzak eragin ditzakeela pentsatzen badu. Ustekabeko errore gehienak ekiditeko, esleipenak erabil ditzakezu eta, horrela, berehala deitutako funtzio adierazpenak erabiltzea saihestuko duzu
Kode Adibidea
// Egin
function eginZerbait() {
    // ...
}

eginZerbait()

// Egin

const items = [1, 2, 3]
items.forEach(console.log)

// Baztertu — salbuespen bat jaurtitzen du
const m = new Map()
const a = [1,2,3]
[...m.values()].forEach(console.log)
> [...m.values()].forEach(console.log)
>  ^^^
> SyntaxError: Unexpected token ...

// egin zerbait — salbuespen bat jaurtitzen du
const count = 2 // 2() burutzen saiatzen da, baina 2() ez da funtzio bat
(function egin zerbait() {
  // egin zerbait paregabea
}())
// jarri puntu eta koma berehala deitutako funtzioa baino lehen, const definizioaren ostean, funtzio anonimoak bueltatutako balioa aldagarri batean gorde edo baztertu IIFE guztiak
🔗 Informazio gehiago: "Semi ESLint araua"
🔗 Informazio gehiago: "Ez dago ustekabeko ESLint arau lerroaniztunik"

 3.5 Izendatu funtzio guztiak
TL;PL: izendatu funtzio guztiak, itxierak eta deiak. Saihestu funtzio anonimoak. Hau bereziki erabilgarria da node aplikazio bat profilatzerakoan. Funtzio guztiak izendatzeak memoria argazkia egiaztatzean aukera emango dizu zer bilatzen ari zaren ulertzen
Bestela: zaila izan liteke ekoizpen arazoak araztea memoria erregistroak erabiliz (memoria argazkia), funtzio anonimoetako memoria kontsumoa handia denean

 3.6 Erabili izen deskriptiboak aldagaiak, konstanteak, funtzioak eta klaseak izendatzeko
TL;PL: Erabili lowerCamelCase konstanteak, aldagaiak eta funtzioak izendatzean eta UpperCamelCase (maiuskulazko lehen letra ere) klaseak izendatzean. Horrek lagunduko dizu aldagai/funtzio arruntak eta instantziazioa behar duten klaseak erraz bereizten. Erabili izen deskriptiboak, baina saiatu laburrak izan daitezen
Bestela: Javascript munduko hizkuntza bakarra da eraikitzailea ("Klasea") zuzenean deitzea ahalbidetzen duena aurretik eskatu/instantziatu gabe. Horrenbestez, klaseak eta funtzio eraikitzaileak bereizten dira UpperCamelCase-tik hasita
3.6 Kode eredua
// funtzioa izendatzeko UpperCamelCase erabiltzen dugu
class KlaseBatenAdibidea {}

// konstanteak izendatzeko const hitz gakoa eta lowerCamelCase erabiltzen ditugu
const config = {
  key: "balioa",
};

// aldagaiak eta funtzioak izendatzeko lowerCamelCase erabiltzen dugu
let aldagaiBatenAdibidea = "balioa";
function eginZerbait() {}

 3.7 Aukeratu const, let ordez. Ez erabili var
TL;PL: const erabiltzeak esan nahi du behin aldagai bat esleituta ezin dela berriro esleitu. Beraz, erabilera desberdinetarako aldagai bakarra erabiltzeko joera baztertzen lagunduko dizu const erabiltzeak, bai eta kodea garbitzen ere. Aldagai bat behin baino gehiagotan esleitu behar baduzu –for begizta batean, adibidez– erabili let, garbiagoa da eta. Leten beste alderdi garrantzitsu bat da definitu duzun blokearen eremuan bakarrik eskura dezakezula deklaratutako aldagia. var funtzioen eremukoa da, ez blokearena, eta ez da ES6n erabili behar, const eta let erabiltzeko aukera duzu eta
Bestela: arazketa askoz ere astunagoa da, maiz aldatzen den aldagai baten jarraipena egitean
🔗 Informazio gehiago: JavaScript ES6 +: var, let, edo const? 

 3.8 Erabili moduluak lehenengo, barne funtzioen partez
TL;PL: moduluak fitxategi bakoitzaren hasieran erabili behar dira, edozein funtzioren aurretik eta kanpo. Praktika on eta sinple honek lagunduko dizu fitxategiaren menpekotasunak erraz eta azkar atzematen haren eskuineko goi aldean, baita arazo posible batzuk ekiditen ere
Bestela: Node.jsk aldi berean exekutatzen ditu require-ak. Funtzio batek dei egiten badie, egoera kritikoago batean dauden beste eskaera batzuk blokea daitezke. Gainera, deitutako moduluetako batek edo haren menpeko ataza batek errore bat izanez gero, komeni da lehenbailehen haren berri jakitea, eta agian ezingo da hori egin, modulu horri funtzio batek deitzen badio

 3.9 Inportatu moduluak karpetaka eta ez artxiboak zuzenean
TL;PL: modulua/liburutegia karpeta batean garatzean, sartu index.js fitxategia, moduluaren barruko osagarriak agerian jarri eta erabiltzaile guztiek bertara joko dute eta. Hori eginez gero, moduluaren 'interfaze' gisa lan egiten du, eta geroago egin beharreko aldaketak errazten ditu kontratua hautsi gabe
Bestela: fitxategien barne egitura edo sinadura aldatzeak erabiltzaileen interfazea apur dezake
3.9 Kodea adibidea
// Egin
module.exports.SMSProvider = require("./SMSProvider");
module.exports.SMSNumberResolver = require("./SMSNumberResolver");

// Baztertu
module.exports.SMSProvider = require("./SMSProvider/SMSProvider.js");
module.exports.SMSNumberResolver = require("./SMSNumberResolver/SMSNumberResolver.js");

 3.10 Erabili === eragilea
TL;PL: hobetsi berdintasunaren eragile zorrotza === berdintasun abstraktuaren eragile ahulagoa baino ==. == eragileak bi aldagai alderatuko ditu, behin aldagai arrunt bihurtu ondoren. === eragileak ez du aldagai motaren bihurketarik egiten, eta bi aldagaiek mota berekoak izan behar dute berdinak izateko
Bestela: == eragileak, berdinak ez diren aldagaiak alderatuz gero, berdinak direlako mezua helaraz dezake
3.10 Kode adibidea
"" == "0"; // false
0 == ""; // true
0 == "0"; // true

false == "false"; // false
false == "0"; // true

false == undefined; // false
false == null; // false
null == undefined; // true

" \t\r\n " == 0; // true
Aurreko azalpen guztiak faltsuak izango lirateke === eragilea erabili izan balitz

 3.11 Erabili Async Await, ekidin callbackak
TL;PL: Node 8 LTS erabat bateragarria da orain Async-awaitekin, eta, horrela kode asinkronikoa kudeatzeko aukera ematen du, callbackik eta agintzarik erabili gabe. Async-awaitek ez du blokeorik eragiten, eta kode asinkronikoak sinkroniko bihurtzen ditu. Zure kodeari egin ahal diozun oparirik onena async-await erabiltzea da, eskaintzen duen kode sintaxia askoz ere trinkoagoa eta ezagunagoa da eta
Bestela: gaizki pasatu eta infernura joateko biderik azkarrena hartu nahi baduzu, erabili callbackak errore asinkronoak kudeatzeko, seguruenik, infernura joateko biderik azkarrena aukeratuko duzu. Estilo honek gune guztietako erroreak egiaztatzera behartzen du, eta, gainera, kode habiaratze beti deserosoaren kudeaketa eta kode fluxua ulertzea zailtzen du
🔗Informazio gehiago: async-await 1.0ren gida

 3.12 Erabili gezi funtzioak (=>)
TL;PL: agintzak eta callbackak onartzen dituzten API zaharrekin async-await erabiltzea eta funtzio parametroak ekiditea gomendarria bada ere, gezi funtzioek kodearen egitura trinkotu egiten dute eta erro funtzioaren testuinguru lexikoa bermatu (hau da, this)
Bestela: (ES5 funtzioetan) kode luzeek erroreak izateko joera handiagoa dute, eta, gainera, irakurtzeko astunak dira
🔗 Informazio gehiago: gezi funtzioak erabiltzeko garaia da

⬆ Itzuli hasierara
4. Probak eta kalitate orokorra
 4.1 Idatzi APIaren probak (osagaia), gutxienez
TL;PL: proiektu gehienei ez zaie proba automatikorik egiten denbora gutxian egiten direlako edo, maiz, 'proba proiektua' kontroletik kanpo geratu eta bertan behera uzten delako. Hori dela eta, lehentasuna eman API probei eta hasi beraiek egiten; izan ere, hori da idazteko erarik errazena eta, gainera, proba unitarioek baino estaldura handiagoa eskaintzen dute; are gehiago, API probak sor ditzakezu, Postman bezalako tresnak erabiliz. Ondoren, baliabide eta denbora gehiago edukiz gero, jarraitu proba aurreratuak egiten, hala nola proba unitarioak, datu baseen probak, errendimendu probak, etab.
Bestela: luzaroan aritu zintezke proba unitarioak idazten, azkenean soilik %20ko estaldura lortu duzula jakiteko

 4.2 Erabili 3 zati proba izen bakoitzean
TL;PL: proba adierazgarria izan behar da eskakizunen mailan, barne kodearekin lan egiten ohituta ez dauden QAko ingeniariek eta garatzaileek berez eta erraz uler dezaten. Probaren izenean adierazi zer ari den probatzen (probapean dagoen unitatea), zer egoeratan eta zer emaitza espero den
Bestela: inplementazio batek huts egin du, “Gehitu produktua“ izeneko proba batek huts egin du. Esaten dizu horrek zehazki zer dabilen gaizki?
🔗 Informazio gehiago: erabili 3 zati proba izen bakoitzean

 4.3 Egitura probak AAA ereduaren arabera
TL;PL: egituratu zure probak ondo bereizitako 3 ataletan: antolatu, aritu eta baieztatu (AAA). Lehenengo atalean probaren konfigurazioa egin behar da; ondoren proba egikaritu behar da; eta, azkenik, baieztapen fasea dator. Egitura horri jarraitzeak bermatzen du irakurleak garuneko PUZik ez gastatzea proba plana ulertzen
Bestela: kode nagusia ulertzen egunero orduak eta orduak pasatzeaz gainera, orain zure garuna trebatzen pasatzen duzu bestela eguneko zatirik lasaiena izan behar zuena (probak)
🔗 Informazio gehiago: egitura probak AAA ereduaren arabera

 4.4 Antzeman kodeko arazoak linter bat erabiliz
TL;PL: erabili kode linterra oinarrizko kalitatea egiaztatzeko eta antiereduak garaiz atzemateko. Exekutatu edozein proba baino lehen eta gehitu aurre-commit-a git kako moduan, edozein arazo berrikusteko eta zuzentzeko behar den denbora minimizatu ahal izateko. Era berean, egiaztatu 3. atala, kodearen estilo praktikei dagokienez
Bestela: kode antiereduren bat zuzendu gabe utz dezakezu, zure ekoizpen ingurunean ahula izan litekeena

 4.5 Saihestu datu globalak, gehitu datu pertsonalizatuak proba bakoitzean
TL;PL: probak akopla daitezen ekiditeko eta proben fluxuari buruz erraz arrazoitzeko, proba bakoitzak bere datu baseko lerroen multzoan lan egin beharko luke. Proba batek datu baseko datu batzuk ba ote diren jakin nahi duenean edo haien beharra duen bakoitzean, berariaz erantsi behar dira datu horiek eta eragotzi beste erregistroren bat mutatzea
Bestela: probek huts egin dutela eta, inplementazioa bertan behera utzi beharra izan duzula pentsatu. Egoera horretan, lan taldeak denbora asko pasatuko du porrotaren zergatiak aztertzen, azkenean, ondorio tamalgarri honetara iristeko: sistema ondo dabil; probek, ordea, elkarri eragiten diote eta egitura hausten dute
🔗 Informazio gehiago: saihestu datu globalak

 4.6 Etengabe ikuskatu menpekotasun ahulak
TL;PL: Express bezalako menpekotasun ospetsuenek ere ahultasun ezagunak dituzte, erraz gaindi daitezkeenak tresna komunitarioak eta komertzialak erabiliz, esaterako 🔗 npm auditoria eta 🔗 snyk.io, zure CItik dei ditzakezunak konpilazio bakoitzean
Bestela: zure kodeak ahultasunik ez izatea lortzeko tresna dedikaturik erabili gabe, etengabe begiratu beharko duzu mehatxu berriei buruz onlinen zer argitaratzen den eta haren jarraipena egin

 4.7 Etiketatu zure probak
TL;PL: egin beharreko probak desberdinak dira eszenatokiaren arabera; ke lasterrak, input-output gabekoak, garatzaileek artxibo bat gorde edo commit egiten dutenean erabiltzen diren testak, hasieratik amaierarainoko test erabatekoak presio eskaera berri bat bidaltzen denean egikaritzen direnak, etab. Hori lor daiteke #cold #api #sanity bezalako gako hitzak erabiliz probak etiketatzean, aukera izan dezazun zure proba tresnak erabiltzeko eta behar duzun azpimultzoari deitzeko. Adibidez, honela deitu ahal izango zenioke zentzutasun proba multzoari Mocha erabiliz: mocha --grep 'sanity'
Bestela: garatzaile batek aldaketa txiki bat egiten duen bakoitzean oso motela izan daiteke proba guztiak exekutatzea, datu baseak kontsultatzen dituzten probak barne. Horrelako kasuetan, garatzaileei etsigarria gertatuko zaie probak egitea

 4.8 Egiaztatu zure proben estaldura, proba eredu okerrak identifikatzen laguntzen du eta
TL;PL: Istanbul/NYC bezalako estaldura tresnak oso aproposak dira 3 arrazoirengatik: dohainik dira, hau da, ez da lanik egin behar txostenak lortzeko; proben estaldura gutxitu den identifikatzen laguntzen dute; eta, azkenik, baina ez garrantzi txikiagokoa, proben desdoikuntzak agerian jartzen dituzte. Koloretako kode estalduraren txostenak aztertzean, baliteke harrapaketa kapsula moduan sekula testatzen ez diren kode arloak ikustea, adibidez. Horrek esan nahi du probek bide arrakastatsuak besterik ez dituztela atzematen eta ez aplikazioak nola jokatzen duen erroreak gertatzen direnean. Konfiguratu zure probak estaldura maila batetik behera jaisten denean erroreak eragiteko
Bestela: ez da inolako neurgailu automatizaturik egongo zure kodearen zati handi bat proben estalduratik kanpo dagoela esango dizuna

 4.9 Ikuskatu pakete zaharkituak
TL;PL: erabili zure tresnarik gogokoena (adibidez, 'npm outdated' edo npm-check-updates zaharkituta dauden paketeak atzemateko, ezarri kontrol hau zure IEren bideetan eta, are gehiago, eragin konpilazio batek huts egitea ingurune kritikoetan. Adibidez, agertoki kritikoa izan daiteke instalatutako pakete batek 5 adabaki baieztatuak dituenean (adibidez, bertsio lokala 1.3.1 da eta biltegi bertsioa 1.3.8) edo haren egileak zaharkitu etiketa jarri dionean. Kasu horretan, ezabatu konpilazioa eta ekidin bertsio hori erabiltzea
Bestela: modu esplizituan arriskutsutzat etiketatuta dauden paketeak egikarituko ditu zure produkzioak

 4.10 Erabili production bezalako inguruneak e2e probetarako
TL;PL: zuzeneko datuak erabiltzen dituen hasieratik amaierarainoko proba (e2e) lehen IEren prozesuko katebegirik ahulena izaten zen, datu baseak bezalako zerbitzu astun askoren menpean dago eta. Erabili zure ekoizpen errealetik ahalik eta hurbilen dagoen ingurunea
Bestela: docker-compose erabili ezean, taldeek ingurune bakoitzeko proben datu baseak mantendu behar izaten dituzte, garatzaileen makinak barne. Mantendu beti datu base horiek sinkronizatuta, proben emaitzak alda ez daitezen ingurune batetik bestera

 4.11 Eguneratu probak aldizka analisi estatikoko tresnak erabiliz
TL;PL: analisi estatikoko tresnak erabiltzeak lagundu egiten dizu kodearen kalitatea hobetzeko modu objektiboak lortzen eta zure kodea jasangarri izaten. Analisirako tresna estatikoak gehitu ahal dizkiozu zure IE konpilazioari, huts egingo duen susmoa duzuenean. Estaldurari dagokionean, bere aldeko puntu nagusiak dira kalitatea ikuskatzeko gaitasuna dutela fitxategi anitzen testuinguruan (adibidez, bikoizketak atzematea), azterketa aurreratuak egitea (adibidez, kodearen konplexutasuna hautematea), eta kode arazoen historiaren eta aurrerapenaren jarraipena egitea. Horretarako, bi tresna hauek erabil ditzakezu: Sonarqube (2.600+ izar) eta Code Climate (1.500+ izar)
Bestela: kodearen kalitatea txarra denean, erroreek eta errendimenduak beti emango dituzte arazoak, azken belaunaldiko ezaugarriak dituen liburutegi berri distiratsu batek ere konpontzerik izango ez dituenak
🔗 Informazio gehiago: berregituratu!

 4.12 Aukeratu arretaz zure IE plataforma (Jenkins vs CircleCI vs Travis vs gainerako mundua)
TL;PL: zure integrazio jarraituaren plataformak (CICD) kalitateko tresna guztiak (adib. testak, lintak) ostatatu behar ditu, eta, beraz, indartsua izan beharko du bere pluginen ekosistemak. Aspaldian Jenkins proiektu askoren balio lehenetsia izan ohi zen, komunitaterik handiena eta oso plataforma indartsua baititu, ordainetan konfigurazio konplexu samarra eta ikaste kurba pikoa baditu ere. Gaur egun, askoz errazagoa da IE irtenbide bat sortzea CircleCI eta haren antzeko SaaS tresnak erabiliz. Tresna horiek IE hodi malgu bat sortzea ahalbidetzen dute azpiegitura osoa kudeatzeko zama hartu beharra izan gabe. Azken batean, sendotasuna eta abiaduraren arteko oreka lortzea da kontua. Egin zure aukera arretaz
Bestela: hornitzaile espezializatu bat aukeratzeak blokeatu zaitzake, pertsonalizazio aurreratu bat behar duzunean. Bestalde, Jenkins erabiltzeak denbora asko eska dezake azpiegitura konfiguratzean
🔗 Informazio gehiago: aukeratu IE plataforma

 4.13 Probatu zure middlewareak eurak bakarrik
TL;PL: middlewareak eskaera askori erantzuten dion logika sendo bat duenean, merezi du middlewarea probatzea bera bakarrik, web esparru osoa aktibatu gabe. Hori erraz lor daiteke {req, res, next} objektuak atzemanez eta behatuz
Bestela: middleware Expressean === errorea izanez gero, errorea gertatuko zaizu eskaera guztietan edo gehienetan
🔗 Informazio gehiago: probatu zure middlewareak eurak bakarrik

⬆ Itzuli hasierara
5. Ekoizpena
 5.1. Monitorizazioa
TL;PL: bezeroek baino lehenago arazoak aurkitzeko joku bat da monitorizazioa. Jakina, garrantzi handia eman behar zaio. Merkatua eskaintzez gainezka dago, eta, beraz, komeni zaizu zehazten hastea zeintzuk diren hartu behar dituzun oinarrizko neurriak (hemen dituzu nire iradokizunak); ondoren, pentsatu zer neurri osagarri ezarri behar dituzun; eta, azkenik, aukeratu hipotesi guztiak kontuan hartzen dituen soluzioa. Egin klik soluzioen ikuspegi orokorra izateko
Bestela: hutsegitea === bezero zapuztuak
🔗 Informazio gehiago: monitorizazioa!

 5.2. Gardentasuna handitu erregistratze plataforma adimendunak erabiliz
TL;PL: erregistroak arazketa adierazpen hutsalen biltegia izan daitezke edo zure aplikazioaren historia kontatzen duen aginte mahai praktikoa. Planifikatu zure erregistratze plataforma lehenengo egunetik: hau da, nola bildu, gorde eta aztertuko dituzun erregistroak, nahi duzun informazioa benetan eskura daitekeela bermatzeko (adibidez, zein den errore tasa, zerbitzu eta zerbitzarien bidez transakzio oso bat egin ondoren, eta abar)
Bestela: kutxa beltz batekin amaituko duzu, eta zaila izango zaizu han jasotako ezarpenen zergatia aurkitzea. Azkenean, erregistro adierazpen guztiak idazten hasiko zara informazio osagarria gehitzeko
🔗 Informazio gehiago: gardentasuna handitu erregistratze plataforma adimendunak erabiliz

 5.3. Delegatu ahal den guztia alderantzizko proxy batean (adibidez, gzip, SSL)
TL;PL: Node izugarri txarra da PUZen zeregin intentsiboak egiten, esate baterako, gzipping, SSL termination. Haien partez benetako middleware zerbitzuak erabili behar dituzu –hala nola nginx eta Haproxy–
edo hornitzaileen lainoko zerbitzuak
Bestela: zure hari bakarra lanpetuta egongo da azpiegitura lanak egiten, zure aplikazioaren guneari kasu egin beharrean, eta, ondorioz, haren errendimenduak behera egingo du
🔗 Informazio gehiago: delegatu ahal den guztia alderantzizko proxy batean (adibidez, gzip, SSL)

 5.4. Blokeatu menpekotasunak
TL;PL: zure kodeak berdin-berdina izan behar du ingurune guztietan, baina harrigarria bada ere npm lehenetsita dago menpekotasunei ingurune batetik bestera pasatzen uzteko. Instalatzen dituzunean paketeak hainbat ingurunetan, paketeen azken bertsioa eskuratzen saiatzen da. Hori saihesteko, erabili npm edo .npmrc konfigurazio artxiboak, ingurune bakoitzean dagokion paketearen zein bertsio zehatz (eta ez derrigorrez berriena) komeni zaizun adieraziko dizu eta. Bestela, kontrola fintze aldera, erabili npm shrinkwrap. *Eguneratzea: NPM5 bertsiotik aurrera, menpekotasunak defektuz blokeatzeko konfiguratuta dator. Yarn pakete kudeatzaile berria ere lehenetsita dago horrela lan egiteko
Bestela: QAk kodea xeheki probatuko du eta onartuko duen bertsioak desberdin jokatuko du produkzioan. Are okerrago, produkzio talde bereko zerbitzarien kodeak desberdinak izan litezke
🔗 Informazio gehiago: blokeatu menpekotasunak

 5.5. Babestu prozesuaren erabilgarritasuna tresna egokiak erabiliz
TL;PL: prozesuak huts eginez gero, aurrera egin eta berrabiarazi beharra dago. Egoera arruntetan, nahikoak izan daitezke PM2 bezalako prozesuak kudeatzeko tresnak, baina gaur egungo mundu ”docker”-izatuan, taldeak kudeatzeko tresnak ere kontuan hartu behar dira
Bestela: estrategia argirik gabe dozenaka eskaera exekutatzeak DevOpsa nahaste-borrastera eraman dezake, hartarako aldi berean tresna gehiegi (talde kudeaketa, dockerra, PM2) erabiliz gero
🔗 Informazio gehiago: babestu prozesuaren erabilgarritasuna tresna egokiak erabiliz

 5.6. Erabili PUZeko nukleo guztiak
TL;PL: Noderen oinarrizko bertsioa PUZeko nukleo bakar batean exekutatzen da, eta beste nukleo guztiak geldi geratzen dira. Beharrezkoa da Noderen prozesua erreplikatzea PUZ guztiak erabiliz: aplikazio txiki eta ertainekin, Node Cluster edo PM2 erabil dezakezu; aplikazio handi samarrekin, berriz, saiatu erabiltzen Docker tankerako talderen bat (adibidez, K8S, ECS) edo Linux hasieratze sisteman oinarritutako garatze idazkerak (adibidez, systemd)
Bestela: seguruenik, zure aplikazioak erabilgarri dituen baliabideen %25a besterik ez du erabiltzen (!), edo gutxiago, agian. Kontuan izan ohiko zerbitzariek gutxienez lau nukleo dituztela PUZen, eta Node.jsren garatzaile soilak bat bakarra erabiltzen duela (AWS beanstalk bezalako PaaS zerbitzuekin lan egiten duenean ere)
🔗 Informazio gehiago: erabili PUZeko nukleo guztiak

 5.7. Sortu ‘mantentze lanen amaiera puntua‘
TL;PL: API seguru batean, jarri agerian sistemarekin lotutako informazio multzo bat, hala nola, memoriaren erabilera eta REPL, etab. Nahiz eta gomendagarria den proba estandarretan eta tresna arruntetan oinarritzea, zenbait informazio eta eragiketa baliotsu errazago egiten dira kodea erabiliz
Bestela: konturatuko zara “diagnostiko-inplementazio“ asko egiten ari zarela, eta kodea produkziora bidaltzen duzula soilik informazioa lortzeko diagnostikoa egite aldera
🔗 Informazio gehiago: sortu ‘mantentze lanen amaiera puntua‘

 5.8. Aurkitu erroreak eta geldialdiak APM produktuak erabiliz
TL;PL: aplikazioen jarraipen eta errendimendu produktuek (APM deritzona) modu proaktiboan neurtzen dituzte kode basea eta APIa, modu automatikoan ohiko jarraipenetik haratago joateko eta erabiltzaileen esperientzia arrunta zerbitzu eta maila guztietan neurtzeko. Adibidez, APM produktu batzuek agerian jarri dezakete azken erabiltzaileen aldean motelegi kargatzen dela transakzio bat, sakoneko arrazoia iradokitzen duten bitartean
Bestela: APIaren errendimendua eta geldialdiak neurtzeko ahalegin handia egin zenezake, eta, ziurrenik, ez zinateke jabetuko zein diren zure kodearen atalik motelenak mundu errealeko eszenatokian eta nola eragiten dioten zure erabiltzaile esperientziari
🔗 Informazio gehiago: aurkitu erroreak eta geldialdiak APM produktuak erabiliz

 5.9. Prestatu zure kodea ekoizpenerako
TL;PL: programatu helburua kontuan izanik; planifikatu produkzioa lehenengo egunetik hasita. Horrek lausoa eta zehazgabea ematen duenez, produkzioaren mantentzeari estu-estu lotuta dauden garatze aholku batzuk bildu ditut (egin klik hemen behean dagoen Gist estekan)
Bestela: IT / DevOps arloko munduko txapeldun batek ere ez du salbatuko gaizki idatzita dagoen sistema
🔗 Informazio gehiago: prestatu zure kodea ekoizpenerako

 5.10. Neurtu eta babestu memoriaren erabilera
TL;PL: Node.jsk harreman gatazkatsuak ditu memoriarekin: v8 motorrak muga leunak dauzka memoria erabiltzean (1,4 GB) eta ezaguna da zein bidetatik galtzen duen Noderen kodeak memoria. Beraz, ezinbestekoa da Noderen prozesu memoriari erreparatzea. Aplikazio txikietan memoria aldizka neur dezakezu geruza komandoak erabiliz; baina aplikazio ertainetan eta handietan aztertu beharko zenuke ez ote zaizun komeni zure memoria erlojua kontrol sistema sendo baten erara erabiltzea
Bestela: zure memoria prozesuak 100 bat megabyte gal dezake egunean, Walmart-i gertatu zitzaion bezala
🔗 Informazio gehiago: neurtu eta babestu memoriaren erabilera

 5.11. Atera zure frontend modulu aktiboak Nodetik
TL;PL: prestatu frontend edukia middleware dedikatu bat erabiliz (adibidez, nginx, S3, CDN), zeren Noderen errendimenduak behera egiten baitu artxibo estatiko askorekin lan egiten duenean, bera azpiprozesu bakarrekoa da eta
Bestela: Node eduki dinamikoa eskaintzeko sortu zen arren, haren hari bakarra lanpetuta egongo da html / images / angular / react erako ehunka fitxategi bidaltzen, bera egiteko sortua izan zen zereginei esleitu barik bere baliabide guztiak
🔗 Informazio gehiago: atera zure frontend/interfazeko modulu aktiboak Nodetik

 5.12. Izan aberrigabea, hil zerbitzariak ia egunero
TL;PL: gorde edozein datu mota (adibidez, erabiltzaile saioak, cacheak, kargatutako fitxategiak) kanpoko datu biltegietan; eta aztertu ez ote zenituzkeen zure zerbitzari guztiak aldian behin “hil” beharko edo “zerbitzaririk gabe”ko plataformaren bat erabili (adibidez, AWS Lambda), berariaz aberrigabe (stateless) jokaera duena
Bestela: zerbitzari jakin batek huts eginez gero, makina akastun bat hil beharrean, aplikazioen geldialdia eragingo du. Gainera, gero eta zailagoa izango da mailaketaren elastikotasuna, zerbitzari jakin baten menpeko izanda
🔗 Informazio gehiago: izan aberrigabea, hil zerbitzariak ia egunero

 5.13. Erabili menpekotasunak automatikoki atzematen dituzten tresnak
TL;PL: menpekotasun ezagunenek ere –Express, adibidez– badituzte (noizean behin) ahulezia ezagunak, sistema arriskuan jar ditzaketenak. Horrek konponbide erraza du, ordea, tresna komunitario eta komertzialak erabiliz gero, ahuleziak etengabe kontrolatu eta haien berri ematen dute eta (bertan edo GitHub-en)
Bestela: zure kodea ahulezia eta zaurgarritasunetatik garbi mantentzeko tresna dedikaturik gabe, jarraipen estua egin beharko diezu mehatxu berriei buruz linean egiten diren argitalpenei, bide batez esanda, aspergarri samarra izaten dena
🔗 Informazio gehiago: erabili menpekotasunak automatikoki atzematen dituzten tresnak

 5.14. Esleitu transakzio identifikazio bana adierazpen erregistro bakoitzari
TL;PL: esleitu identifikatzaile bera –transakzio-: {balioren bat}– erregistro sarrera bakoitzari eskaera bakar baten barruan. Ondoren, erregistroetako erroreak ikuskatzean, erraz konturatuko zara zer gertatu zen aurretik eta ondoren. Zoritxarrez, hori ez da erraz lortzen Noden, haren izaera asinkronoa da eta. Ikusi kodearen adibideak beheko estekan
Bestela: produkzioko erroreen erregistroa testuingururik gabe ikustean – aurretik gertatu zena, alegia –, askoz zailagoa eta motelagoa da arazoa aztertzea
🔗 Informazio gehiago: esleitu transakzio identifikazio bana adierazpen erregistro bakoitzari

 5.15. Ezarri NODE_ENV = produkzioa
TL;PL: ezarri NODE_ENV ingurune aldagaia ‘produkzioa‘ edo ‘garapena‘ ataletan produkzioaren optimizazioak aktibatu beharra dagoen adierazteko; npm pakete askok uneko ingurunea zehazten dute eta haren kodea optimizatzen dute ekoizpenerako
Bestela: ezaugarri soil hori gabe errendimendua asko jaits liteke. Adibidez, Express erabiltzean zerbitzarira bideratzeko NODE_ENV gabe, errendimendua heren bat moteltzen da
🔗 Informazio gehiago: Ezarri NODE_ENV = produkzioa

 5.16. Diseinatu inplementazio automatizatuak, atomikoak eta geldialdi gabekoak
TL;PL: ikerketek frogatu dute inplementazio ugari egiten dituzten taldeek ekoizpen arazo kritikoak izateko probabilitatea txikiagotzen dutela. Eskuz egin beharreko urrats arriskutsurik eta zerbitzuen geldialdirik ez duten inplementazio azkar eta automatizatuek nabarmen hobetzen dute inplementazio prozesua. Baliteke hori bera lortzea Docker eta IE tresnak, biak batera, erabiliz, inplementazio sinplifikatuari dagokionez industriaren estandarra bihurtu dira eta
Bestela: inplementazio luzeak -> produkzioaren geldialdia eta gizakiak eragindako erroreak -> inplementazioan konfiantzarik ez duen taldea -> inplementazio eta funtzio gutxiago egitea

 5.17. Erabili Node.jsren LTS bertsio berria
TL;PL: ziurtatu Node.jsren LTS bertsioa erabiltzen ari zarela errore kritikoen zuzenketak, segurtasun eguneratzeak eta errendimenduaren hobekuntzak jasotzeko
Bestela: aurkitu berri diren erroreak edo ahuleziak erabil litezke produkzioan exekutatzen den aplikazio bat ustiatzeko eta baliteke zure aplikazioa ez izatea bateragarria hainbat modulurekin eta zailagoa gertatzea hura mantentzea
🔗 Informazio gehiago: Erabili NTS.jsren LTS bertsioa

 5.18. Ez bideratu erregistrorik aplikazioaren barruan
TL;PL: garatzaileek ez dituzte erregistroen helmugak aplikazio kodearen barruan kodetu behar, aplikazioa exekutatzen den inguruneak berak definitu beharko ditu eta. Garatzaileek stdout-ean idatzi behar dituzte erregistroak erregistratze tresna bat erabiliz, eta gero exekuzio inguruneak (edukiontzia, zerbitzaria eta abar) bideratuko du stdout korrontea helmuga egokira (hau da, Splunk, Graylog, ElasticSearch eta abar)
Bestela: aplikazioen kudeaketaren erregistroak bideratzea === zaila da eskalatzen, erregistroen galera dakar, eskasa izaten da kezken bereizketa
🔗 Informazio gehiago: erregistroen bideraketa

 5.19. Instalatu zure paketeak npm ci erabiliz
TL;PL: ziurtatu ekoizpen kodeak erabiltzen duela probak egiteko erabili dituzun paketeen bertsio berdina. Exekutatu npm ci zure package.json eta package-lock.json paketen menpekotasunen instalazio garbia egiteko
Bestela: QAk kodea sakonki probatuko du eta produkzioan modu desberdinean jokatuko duen bertsioa onartuko du. Are okerrago, produkzio talde bateko hainbat zerbitzarik kode desberdinak exekuta ditzake
🔗 Informazio gehiago: erabili npm ci

⬆ Itzuli hasierara
6. Segurtasuna



 6.1. Erabili linter segurtasun arauak
 
TL;PL: erabili segurtasunarekin lotutako linter pluginak, eslint-plugin-security bezalako segurtasun ahuleziak eta arazoak lehenbailehen atzemateko, ahal bada kodetzen ari diren bitartean. Horrek segurtasun ahuleziak atzematen lagun dezake, hala nola eval erabiltzea, bigarren mailako prozesu bat deitzea edo modulu bat inportatzea kate literal batekin (adibidez, erabiltzailearen sarrera). Egin klik 'Informazio gehiago' atalean segurtasun liner batek atzematen dituen kode adibideak ikusteko
Bestela: garapenean zehar segurtasun ahulezia zuzena izan zitekeena produkzioaren arazo nagusia bihurtzen da. Gainera, baliteke proiektuak kodeen segurtasun praktika koherenterik ez jarraitzea, ahuleziak sartzea edo urruneko biltegietan sartutako sekretu konfidentzialak sortzea
🔗 Informazio gehiago: lint arauak

 6.2. Mugatu aldi baterako eskaerak middlewareak erabiliz

TL;PL: DOS erasoak oso ezagunak dira, eta nahiko erraz eragin daitezke. Ezarri abiadura muga kanpoko zerbitzu bat erabiliz, hala nola hodeiko karga orekatzaileak, hodeiko suebakiak, nginx, abiadura-mugatzaile-malgua (rate-limiter-flexible) edo (aplikazio txikiagoak eta ez hain kritikoetarako) abiadura mugatzeko middleware bat (adibidez, express-rate-limit, express abiadura mugatzailea)
Bestela: aplikazio batek erasoak jasan ahal ditu, haren erabiltzaileei ukatzen bazaie jaso beharko luketen zerbitzua, aplikazioa egoera txarrean dagoelako edo eskuragarri ez dagoelako
🔗 Informazio gehiago: ezarri abiadura muga

 6.3 Kendu sekretuak konfigurazio fitxategietatik edo erabili paketeak enkriptatzeko
 
TL;PL: ez gorde inoiz testu arrunteko sekreturik konfigurazio fitxategietan edo iturburu kodean. Horren ordez, erabili sekretuak kudeatzeko sistemak, hala nola Vault produktuak, Kubernetes / Docker Secrets edo ingurune aldagaiak. Azken baliabide gisa, iturburuko kontrolean gordetako sekretuak enkriptatu eta kudeatu egin behar dira (gako birakariak, iraungitzeak, ikuskaritza, etab.). Erabili aurre-commit/push kakoak, ustekabean sekreturik gordetzea saihesteko
Bestela: iturburu kodearen kontrola publiko egin daiteke akats baten ondorioz, biltegi pribatuetan ere, eta orduan sekretu guztiak agerian geratzen dira. Kanpoko norbaitek iturburuko kontrolaren sarbidea ezagutzeak nahi gabe eragingo du erlazionatutako sistemetarako sarbideak ere ezagutzea (datu baseak, APIak, zerbitzuak, etab.)
🔗 Informazio gehiago: kudeaketa sekretua

 6.4. Saihestu kontsultak injektatzeko ahultasunak ORM / ODM liburutegiekin

TL;PL: SQL / NoSQL injekzioa eta beste eraso maltzur batzuk ekiditeko, erabili beti ORM / ODM edo datuetatik ihes egiten duen datu baseen liburutegia, edo kontsulta parametro izendatuak edo indexatuak onartzen dituena eta espero diren erabiltzaileen sarrera balioztatzen duena. Inoiz ez erabili JavaScript txantiloien kateak edo katearen kateatzea balioak kontsultetan txertatzeko, horrek zure aplikazioa ahultasunen espektro zabalera irekitzen baitu. Node.js entzute handiko datuen liburutegi guztiek injekzio erasoen aurkako babesa dute (adibidez, Sequelize, Knex, mongoose)
Bestela: balidatu gabeko edo baimendu gabeko erabiltzaileen sarrerak operadorearen injekzioa ekar dezake NoSQLrako MongoDB-rekin lan egitean, eta saneamendu sistema edo ORM egokia ez erabiltzeak SQL injekzio erasoak ahalbidetuko ditu, ahultasun erraldoia sortuz
🔗 Informazio gehiago: kontsulten injekzioaren prebentzioa ORM / ODM liburutegiak erabiliz

 6.5. Segurtasuneko praktika onen bilduma
TL;PL: Node.jsrekin zuzenean loturarik ez duen segurtasuneko aholku bilduma bat da: Noderen inplementazioa ez da hain desberdina beste edozein hizkuntzaren inplementazioaren aldean. Egin klik “Informazio gehiago” botoian sakontzeko
🔗 Informazio gehiago: ohiko segurtasun praktika onak

 6.6. Doitu HTTP erantzunen izenburuak segurtasun hobea lortzeko

TL;PL: zure aplikazioak izenburu seguruak erabili beharko lituzke erasotzaileek gune arteko scriptak (XSS), clickjacking-a eta beste eraso maltzur arruntak egitea saihesteko. Horiek erraz konfigura daitezke helmet bezalako moduluak erabiliz
Bestela: erasotzaileek zure aplikazioaren erabiltzaileen aurkako eraso zuzenak egin ditzakete, segurtasun ahultasun handiak sortuz
🔗 Informazio gehiago: erabili izenburu seguruak zure aplikazioan

 6.7. Etengabe eta automatikoki ikuskatu ba ote dagoen erasotzen errazak diren menpekotasunak

TL;PL: npm ekosistemarekin ohikoa da proiektu batek menpekotasun ugari izatea. Menpekotasunak beti kontrolatuta egon behar dira ahultasun berriak aurkitzen diren heinean. Erabili npm audit edo snyk bezalako tresnak, erasotzen errazak diren menpekotasunen jarraipena egiteko, kontrolatzeko eta adabakiak jartzeko. Tresna horiek zure IE konfigurazioarekin integratu, erasotzen errazak diren menpekotasunenak atzemateko ekoizpenera iritsi aurretik
Bestela: erasotzaile batek zure web esparrua detektatu eta ageriko ahultasun guztiei eraso ahal die
🔗 Informazio gehiago: menpekotasunen segurtasuna

 6.8. Babestu erabiltzaileen pasahitzak / sekretuak BCrypt edo Script erabiliz

TL;PL: pasahitzak eta sekretuak (adibidez API giltzak) gorde behar dira hash + gatz funtzio seguru bat erabiliz, esaterako, bcryptedo scrypt; eta kasurik okerrenean, pbkdf2
Bestela: funtzio segururik erabili gabe gordetzen diren pasahitzak eta sekretuak bortxaz erasotuak izan daitezke edo hiztegi erasoak jasan ditzakete. Azkenean agerian gera daitezke, bai eta agian zabaldu ere
🔗 Informazio gehiago: erabiltzaileen pasahitzak

 6.9. Ekidin HTML, JS eta CSS irteerak

TL;PL: arakatzailera bidaltzen diren datu ez fidagarriak bistaratu beharrean exekutatu egin daitezke, normalean cross-site-scripting (XSS) erasoa deritzona. Arindu hori datuak inoiz exekutatu behar ez diren eduki huts gisa (hau da, kodetu, ihes)esplizituki markatzen dituzten liburutegi espezializatuak erabiliz
Bestela: erasotzaile batek JavaScript kodeketa kaltegarria gorde dezake zure DBn, gero bezero gizajoei dagoen moduan bidaliko zaiena
🔗 Informazio gehiago: ihes irteera

 6.10. Balidatu sarrerako JSON eskemak
 
TL;PL: balidatu sarrerako eskaeren gorputzeko zama erabilgarria eta ziurtatu zure itxaropenak betetzen dituela; eta, haiek bete ezean, huts eragin. Ibilbide bakoitzaren balioztatze kodetze neketsua saihesteko JSONen oinarritutako balioztatze eskema arinak erabil ditzakezu, hala nola jsonschema edo joi
Bestela: zure eskuzabaltasunak eta ikuspegi permisiboak asko handitzen dute erasoaren tamainua, eta erasotzailea sarrera asko probatzera bultzatzen du, aplikazioa kraskatzeko konbinazio bat aurkitu arte
🔗 Informazio gehiago: balidatu sarrerako JSON eskemak

 6.11. Onartu JWTen zerrenda beltzak

TL;PL: JSON web fitxak erabiltzean (adibidez, Passport.js)-rekin), lehenespenez ez dago igorritako fitxen sarbidea ezeztatzeko mekanismorik. Erabiltzaileen jarduera maltzurren bat aurkitu ondoren, ez dago modurik sistemara sartzea eragozteko, baliozko fitxaren bat duten bitartean. Konpondu hori eskaera bakoitzean balioztatuko diren fitxa ezfidagarrien zerrenda beltza erabiliz
Bestela: edozeinek erabil litzake iraungitako edo gaizki kokatutako fitxak, maltzurki aplikazio batera sartzeko eta fitxaren jabea ordezkatzeko
🔗 Informazio gehiago: JSON web fitxen zerrenda beltzak

 6.12. Aurrea hartu baimenaren aurkako eraso basatiei

TL;PL: oso teknika sinple eta eraginkorra da baimen saiakerak mugatzea bi metrika erabiliz:

Lehenengoa, erabiltzaile beraren ID / izen eta IP helbide bakarrak jarraian huts egin duen saiakera kopurua
Bigarrena, IP helbide batek denbora tarte luze batean huts egin duen saiakera kopurua. Adibidez, blokeatu IP helbide bat, egun batean 100 saiakera huts egiten baditu

Bestela: erasotzaile batek pasahitz automatizatuen saiakera mugagabeak egin ditzake aplikazio bateko kontu pribilegiatuetara sartzeko
🔗 Informazio gehiago: mugatu saioa hasteko abiadura

 6.13. Exekutatu Node.js erabiltzaile ez-erro gisa

TL;PL: eszenatoki arrunt batean Node.js baimen mugagabeak dituen erro erabiltzaile gisa exekutatzen da. Hori da, adibidez, Docker edukiontzietako portaera lehenetsia. Gomendagarria da erro ez den erabiltzaile bat sortzea eta Docker irudian sartzea (behean azaltzen dira adibideak) edo prozesua erabiltzaile horren izenean abiaraztea "-u username" marka duen edukiontzia deituz
Bestela: zerbitzarian script bat exekutatzea lortzen duten erasotzaileek botere mugagabea lortzen dute makina lokalaren gainean (adibidez, iptable aldatu eta trafikoa beren zerbitzarira bideratzea)
🔗 Informazio gehiago: exekutatu Node.js erabiltzaile ez-erro gisa

 6.14. Mugatu kargaren tamaina alderantzizko proxy edo middlewareak erabiliz
 
TL;PL: zenbat eta gorputzaren karga handiagoa izan, orduan eta zailagoa da zure hari bakarra lan egitea hura prozesatzean. Hori da erasotzaileek zerbitzariak belauniko jartzeko aukera ona eskaera kopuru izugarririk egin gabe (DOS / DDOS erasoak). Murriztu arriskua ertzean jasotako eskaeren gorputzaren tamaina mugatuz (adibidez, suebakia, ELB) edo express body parser konfiguratuz tamaina txikiko kargak bakarrik onartzeko
Bestela: zure aplikazioak eskaera handiei aurre egin beharko die, eta ezingo du prozesatu egin behar duen beste lan garrantzitsua, ondorioz errendimendua gutxituz eta DOS erasoekiko ahulduz
🔗 Informazio gehiago: mugatu kargaren tamaina

 6.15. Saihestu JavaScripten eval adierazpenak
  
TL;PL: eval arriskutsua da, exekutatzeko garaian JavaScript kode pertsonalizatua exekutatzea baimentzen baitu. Hori ez da errendimendu arazo bat bakarrik, baizik eta segurtasun arazo garrantzitsua, erabiltzaileen sarreratik JavaScript kode gaiztoa lor daiteke eta. Halaber, new Function constructor ere saihestu beharra dago; eta, azkenik, setTimeout eta setInterval, ez dira inoiz pasatu behar, ezta JavaScript kode dinamikoa ere
Bestela: Javascript kode gaiztoak bidea aurkitzen du eval testura edo JavaScript hizkuntzak denbora errealean ebaluatzeko dituen funtzioetara sartzeko, eta sarbide osoa lortuko du JavaScripten orrialdeko baimenetara. Ahultasun hori XSS eraso gisa agertzen da askotan
🔗 Informazio gehiago: saihestu JavaScript eval adierazpenak

 6.16. Saihestu RegEx gaiztoak zure exekuzio hari bakarra gainkargatzea

TL;PL: adierazpen erregularrak, oso erabilgarriak izan arren, benetako mehatxua dira JavaScript aplikazioentzat, oro har, eta Node.js plataformarentzat, bereziki. Erabiltzaile baten sarrera prozesatzeko testuarekin bat etor dadin, gerta liteke PUZeko ziklo kopuru handia behar izatea. RegExen prozesamenduaren eraginkortasuna hain txikia izan daiteke, ezen 10 hitz balioztatzen dituen eskaera bakar batek blokea baitezake gertaeren begizta osoa 6 segundoz, eta PUZa su hartzeko moduan jarri 🔥. Hori dela eta, erasotzen errazak diren ohiko adierazpen ahulen txantiloiak atzemateko erabili hirugarrenen balidazio paketeak -esaterako, validator.js-, zuk zeure Regex ereduak idatzi edo safe-regex erabili gabe
Bestela: gaizki idatzitako ohiko adierazpenek Regular Expression DoSen erasoak jasan ditzakete, gertaeren begizta erabat blokeatuko dutenak. Adibidez, 2017ko azaroan, RegExen erabilera gaiztoak agerian jarri zuen moment pakete ezagunaren ahultasuna
🔗 Informazio gehiago: saihestu RegEx gaiztoa erabiltzea

 6.17. Saihestu moduluak kargatzea aldagai bat erabiliz
  
TL;PL: bide bat erabiltzailea sartu ondoren sortua ote den kezka baduzu eta horregatik parametro gisa ezarri baduzu, saihestu bide hori erabiltzea beste fitxategi bat deitzeko / inportatzeko. Arau hori, oro har, edozein fitxategitara sartzeko erabil daiteke (hau da, fs.readFile()) edo erabiltzailea sartu ondoren sortutako aldagai dinamikoak dituen beste baliabide konfidentzialetara sartzeko. Eslint-plugin-security linterrek eredu horiek atzeman eta nahikoa goiz ohartaraz dezake
Bestela: erabiltzaile gaiztoen sarrerak manipulatutako fitxategiak deitzeko erabiltzen den parametro batera jo dezake, adibidez, aurretik fitxategi sisteman kargatutako fitxategietara edo lehendik sisteman bazeuden fitxategietara sartzeko
🔗 Informazio gehiago: moduluaren karga segurua

 6.18. Exekutatu kode ez segurua sandbox batean
  
TL;PL: exekuzio garaian ematen den kanpoko kodea exekutatu behar duzunean (adibidez, plugina), erabili kode nagusia isolatu eta pluginetik babesten duen 'sandbox' tankerako edozein exekuzio ingurune mota. Hori lor daiteke prozesu dedikatu baten bidez (adibidez, cluster.fork()), zerbitzaririk gabeko ingurune bat erabiliz edo sandbox bat balitz bezala jokatzen duten npm pakete dedikatuak erabiliz
Bestela: plugin batek bide ugari erabil ditzake erasotzeko, hala nola begizta infinituak erabiliz, memoria gainkargatuz eta prozesu ingurune eraso errazen aldagaiak eskuratuz
🔗 Informazio gehiago: exekutatu kode ez segurua sandbox batean

 6.19. Kontu handia izan bigarren mailako prozesuekin lan egitean
  
TL;PL: ahal dela, saihestu bigarren mailako prozesuak, eta, hala behar izanez gero, balioztatu eta garbitu sarrera, shell injekzioko erasoak arintzeko. Hobetsi child_process.execFile fitxategia, definizioz komando bakarra exekutatuko duena atributu multzo batekin eta shell parametroen hedapena onartuko ez duena
Bestela: bigarren mailako prozesuak ganorarik gabe erabiltzeak urruneko komandoen exekuzioa edo shell injekzioko erasoak eragin ditzake, desinfektatu gabeko sistema komando batera erabiltzaile gaiztoren bat sartu dela eta
🔗 Informazio gehiago: kontuz ibili bigarren mailako prozesuekin lan egitean

 6.20. Ezkutatu bezeroari erroreen xehetasunak

TL;PL: errore integratuen kudeatzaile lasterrek lehenespenez ezkutatzen dituzte erroreen xehetasunak. Haatik, aukera handia dago inplementa dezan errore pertsonalizatuak dituzten objektuak kudeatzeko berak daukan logika (batzuen ustez praktika ona dena). Hala eginez gero, ziurtatu bezeroari errorearen objektu osoa ez itzultzea, horrek aplikazioen datu sentikorrak izan litzake eta
Bestela: aplikazioaren xehetasun sentikorrak —hala nola, zerbitzariko fitxategien bideak, erabiltzen ari diren hirugarrenen moduluak eta erasotzaile batek balia ditzakeen aplikazioaren barneko beste lan fluxuak— atera daitezke pila aztarna batean aurkitutako informazioetatik
🔗 Informazio gehiago: ezkutatu bezeroari erroreen xehetasunak

 6.21. Konfiguratu 2FA npm edo Yarn-entzat

TL;PL: garapen katearen edozein urrats MFArekin (faktore anitzeko autentifikazioarekin) babestu behar da. Iza ere, npm / Yarn aukera paregabea da garatzaile batzuen pasahitza eskuratu nahi duten erasotzaileentzat. Garatzaileen egiaztagiriak erabiliz, erasotzaileek kode gaiztoa txerta dezakete proiektu eta zerbitzuetan instalatuta dauden liburutegietan, eta, agian, sarean bertan ere, jendaurrean argitarauta badago. npm-n autentifikazioa 2 faktore bidez egin beharra ezartzeak ia zero aukera uzten die erasotzaileei zure pakete kodea aldatzeko
Bestela: ba al duzu pasahitza bahitu zuten eslint garatzailearen berri?

 6.22. Aldatu saioko middlewarearen ezarpenak

TL;PL: web esparru eta teknologia bakoitzak bere ahulguneak ditu: erasotzaileei esatea zein web esparru erabiltzen dugun laguntza handia da haientzat. Saioaren middlewareen ezarpen lehenetsiak erabiltzeak eragin dezake zure moduluko eta esparruko berariazko bahiketa erasoak izatea zure aplikazioak, X-Powered-By izenburukoaren antzekoak. Saiatu ezkutatzen zure pila teknologkoa identifikatzen eta agerian uzten duen edozein gauza (adibidez, Node.js, express)
Bestela: cookieak segurtasunik gabeko konexioen bidez bidal litezke, eta erasotzaile batek saioaren identifikazioa erabil lezake web aplikazioaren barruko esparrua eta moduluen berariazko ahultasunak ere identifikatzeko
🔗 Informazio gehiago: cookieak eta saioaren segurtasuna

 6.23. Saihestu DOS erasoak prozesuak noiz huts egin behar duen berariaz ezarriz

TL;PL: Node prozesuak huts egingo du akatsak kudeatzen ez direnean. Praktika onetako askok irtetea gomendatzen dute, akats bat atzeman eta kudeatuta badago ere. Expressek, adibidez, huts egiten du errore asinkronoren bat izanez gero –blokeatze klausula batekin ibilbideak biltzen ez badituzu behintzat. Horrek oso eraso bide aproposa irekitzen die erasotzaileei, zer informaziok eragiten duen prozesuaren blokeoa jakinda, behin eta berriz eskaera bera bidaltzen baitute prozesua blokeatzea lortu arte. Horretarako ez dago berehalako erremediorik, baina teknika batzuek mina arindu dezakete: abisatu zorroztasun kritikoarekin, kontrolatu gabeko errore baten ondorioz prozesuak huts egiten duen bakoitzean, balioztatu sarrera eta saihestu prozesua blokeatuta gelditzea erabiltzailearen sarrera baliogabea delako, bildu ibilbide guztiak cacth batekin eta kontuan hartu prozesuak ez duela huts egin behar eskaera batean errore bat sortzen denean (oro har, gertatzen denaren kontra)
Bestela: hau uste oneko suposizio soil bat besterik ez da. Node.js aplikazio asko edukiz gero, JSON gorputz huts bat POST eskaera guztietara pasatzen saiatzen bagara, zenbait aplikazio blokeatu egingo dira. Une horretan, eskaera bera berbidal dezakegu, aplikazioak erraz ezabatzeko

 6.24. Saihestu birbideratze ez seguruak

TL;PL: erabiltzaileen sarrerak balioztatzen ez dituzten birbideratzeek ahalbidetzen dute erasotzaileek phishing iruzurrak abiatzea, erabiltzaileen egiaztagiriak lapurtzea eta beste ekintza kaltegarri batzuk burutzea
Bestela: erasotzailea ohartzen bada erabiltzaileek emandako kanpo sarrerarik ez dela balioztatzen, ahultasun hori balia dezake foroetan, sare sozialetan eta beste toki publiko batzuetan hartarako bereziki sortutako estekak argitaratzean, erabiltzaileek bertan klik egin dezaten
🔗 Informazio gehiago: saihestu birbideratze ez seguruak

 6.25. Saihestu sekretuak npm erregistroan argitaratzea

TL;PL: neurriak hartu behar dira npm erregistro publikoetan sekretuak nahi gabe argitaratzeko arriskua ekiditeko. Erabil daiteke .npmignore fitxategi bat karpeta edo fitxategi espezikoak zerrenda beltz batean jartzeko eta files matrizea package.json artxiboarekin erabil daiteke zerrenda zuri moduan lan egin dezan
Bestela: arriskua dago norbaitek zure proiektuaren API giltzak, pasahitzak edo beste sekretu batzuk aurkitu eta erasoak egiten saiatzeko, eta horrek galera ekonomikoak, nortasun arazoak eta bestelako arriskuak sor ditzake
🔗 Informazio gehiago: saihestu sekretuak argitaratzea

⬆ Itzuli hasierara
7. Zirriborroa: errendimendua
Gure laguntzaileak lanean ari dira atal honetan. Parte hartu nahi zenuke?

 7.1. Ez blokeatu gertaeren begizta
TL;PL: saihestu PUZen zeregin intentsiboak, gertaeren begizta blokeatuko baitute. Izan ere, gertaera horietako gehienak azpiprozesu bakarrekoak dira, eta deskargatuak izango baitira azpiprozesu dedikatu batean, prozesu batean edo teknologia desberdinetan, dauden testuinguruaren arabera
Bestela: gertaeren begizta blokeatuta dagoenez, Node.jsk ezin izango du beste eskaera bat kudeatu eta, ondorioz, atzerapena eragin diezaieke erabiltzaileei. 3000 erabiltzaile erantzunaren zain daude, edukia zerbitzatzeko prest dago, baina eskaera bakar batek emaitzak berriro bidaltzea galarazten dio zerbitzariari
🔗 Informazio gehiago: ez blokeatu gertaeraren begizta

 7.2. Hobetsi jatorrizko JS metodoak Lodash bezalako erabiltzaileen baliabideak baino
TL;PL: askotan zorrotzagoa da lodash eta underscore bezalako baliabide liburutegiak erabiltzea jatorrizko metodoak baino, beharrezkoak ez diren menpekotasunak eragin eta abiadura moteltzen baitu. Gogoan izan, V8 motor berria ES estandar berriekin batera, bertako metodoak hobetu egin zirela, eta gaur egun baliabide liburutegiak % 50 inguru eraginkorragoak direla liburutegi publikoak baino
Bestela: errendimendu txikiagoko proiektuak mantendu beharko zenituzke, non dagoeneko eskura zenuena erabili beharko baitzenuke edo, fitxategi batzu gehiagoren truke, beste zenbait lerro landu
🔗 Informazio gehiago: erabiltzaileen jatorrizko baliabideak

⬆ Itzuli hasierara
8. Docker, praktika onak
🏅 Mila esker Bret Fisher-i, ondorengo praktika hauetako asko ikasi baikenituen berarengandik

 8.1 Erabili etapa anitzeko konpilazioak Docker irudi sinpleagoak eta seguruagoak lortzeko
TL;PL: erabili etapa anitzeko konpilazioak beharrezko produkzio objektuak soilik kopiatzeko. Konpilazio menpekotasun eta fitxategi asko ez dira beharrezkoak zure aplikazioa exekutatzeko. Etapa anitzeko konpilazioak erabiliz gero, baliabide horiek konpilazioan zehar erabil daitezke, denboraren exekuzio inguruneak beharrezko baliabideak besterik ez duen bitartean. Etapa anitzeko konpilazioak oso modu erraza dira gehiegizko pisua kendu eta segurtasun mehatxuak saihesteko
Bestela: irudi handiagoek denbora gehiago beharko dute konpilatzeko eta zabaltzeko. Eraikitzeko soilik diren tresnek ahultasunak eduki ditzakete eta eraikitze faserako soilik gordetako sekretuak filtratu daitezke
Etapa anitzeko eraikuntzetarako Dockerfile fitxategiaren adibidea
FROM node:14.4.0 AS build

COPY . .
RUN npm ci && npm run build


FROM node:slim-14.4.0

USER node
EXPOSE 8080

COPY --from=build /home/node/app/dist /home/node/app/package.json /home/node/app/package-lock.json ./
RUN npm ci --production

CMD [ "node", "dist/app.js" ]
🔗 Informazio gehiago: erabili etapa anitzeko konpilazioak

 8.2. Abiarazi edukiontzia node komandoa erabiliz, saihestu npm
TL;PL: erabili CMD ['node','server.js'] aplikazioa abiarazteko, saihestu OS seinaleak kodera pasatzen ez dituzten npm scriptak erabiltzea. Horrek arazoak izatea ekiditen du bigarren mailako prozesuetan, seinaleak kudeatzean, itxiera seguruetan eta prozesu zonbietan
Bestela: seinalerik pasatzen ez denean, zure kodeak ez du inoiz izango itzalaldien berri, eta, hori gabe, ez da behar bezala itxiko, unean uneko eskaerak eta / edo datuak galduz
Informazio gehiago: abiarazi edukiontzia 'node' komandoa erabiliz, saihestu npm abiatzea

 8.3. Utzi Dockeren egikaritze denborari erreplikatu eta jardueraren iraupena kudeatzen
TL;PL: Dockerren exekuzio denboraren orkestratzailea erabiltzen duzunean (adibidez, Kubernetes), deitu Node.js prozesua zuzenean, prozesua errepikatzen duten bitarteko prozesuen kudeatzailerik edo koderik pertsonalizatu gabe (adibidez, PM2, Cluster modulua). Exekuzio denboraren plataformak datu kopuru eta ikusgarritasun handiena dauzka kokapenari buruzko erabakiak hartzeko: badaki zenbat prozesu behar diren, nola antolatu prozesuok eta zer egin huts eginez gero
Bestela: edukiontziak huts egiten jarraituko du baliabide faltagatik, eta prozesuen kudeatzaileak behin eta berriro berrabiaraziko du, gelditu gabe. Kubernetes horretaz jabetuko balitz, beste toki zabal batera lekualda lezake
🔗 Informazio gehiago: utzi Dockeren exekuzio denborari erreplikatu eta jardueraren iraupena kudeatzen

 8.4. Erabili .dockerignore sekretuak filtratzea ekiditeko
TL;DR: erabili .dockerignore fitxategia, fitxategi sekretu arruntak eta garapeneko objektuak iragazten ditu eta. Horrela, sekretuak irudira ez sartzea lor dezakezu. Eta onura gehigarri bat izango duzu: eraikitzeko denbora nabarmen murriztuko da. Gainera, ziurtatu fitxategi guztiak ez direla behin eta berriro kopiatzen eta berariaz aukeratu zer kopiatu behar den Dockerren
Bestela: irudira sarbidea duen edonorekin partekatuko dira .env, .aws eta .npmrc bezalako fitxategi sekretu pertsonal arruntak (adibidez, Docker biltegia)
🔗 Informazio gehiago: erabili .dockerignore

 8.5. Garbitu menpekotasunak ekoizpenaren aurretik
TL;PL: nahiz eta dev-menpekotasunak (dev-dependencies) batzuetan eraikuntza eta probako bizitza zikloan zehar beharrezkoak izan, azkenean ekoizpenera bidaltzen den irudiak ahalik eta txikiena izan behar du eta ez du garapeneko menpekotasunik eduki behar. Hori eginez gero, beharrezko kodea soilik bidaliko dela eta balizko erasoen kopurua (hau da, erasoaren azalera) minimizatuko dela bermatzen da, eta, hori lor daiteke menpekotasun guztiak lehenik instalatuz eta azkenean npm ci --production exekutatuz, beti ere etapa anitzeko eraikuntza erabiltzen denean (ikusi buleta dedikatua)
Bestela: npm segurtasun arau hauste ezagun asko garapen paketeen barruan aurkitu izan dira (adibidez, eslint-scope)
🔗 Informazio gehiago: ezabatu garapen menpekotasunak

 8.6. Itzali arazorik gabe eta dotore
TL;PL: kudeatu prozesuaren SIGTERM gertaera eta garbitu lehendik dauden konexio eta baliabide guztiak. Hori etengabeko eskaerei erantzutean egin behar da. Dockerized exekutatzen den bitartean edukiontziak ixtea ez da arraroa, baizik eta ohiko lanaren zati gisa maiz gertatzen den zerbait. Hori lortzeko ondo pentsatutako kodea prestatu beharra dago hainbat elementu koordinatuz: karga orekatzailea, mantentze konexioak, HTTP zerbitzaria eta beste baliabide batzuk
Bestela: berehala hiltzeak etsita dauden milaka erabiltzaileri ez erantzutea ekarriko du
🔗 Informazio gehiago: itzalaldi dotorea

 8.7. Ezarri memoria mugak Docker eta v8 erabiliz
TL;PL: konfiguratu beti memoria muga bai Docker bai JavaScript exekuzio adierazgailak erabiliz. Dockerren muga beharrezkoa da edukiontzien kokapena erabakitzeko; --v8ren bandera max-old-space beharrezkoa da GC garaiz abiarazteko eta memoria erabiltzea saihesteko. Praktikan, ezarri v8rren espazio memoria zaharra edukiontziaren muga baino apur bat txikiagoa izan dadin
Bestela: Dockerren definizioa beharrezkoa da eskalatutako erabakiak burutzeko eta beste herritarrak gosez hiltzea ekiditeko. V8rren mugak zehaztu gabe ere, edukiontziaren baliabideak erabiliko ditu. Argibide espliziturik gabe, baliabideen %50-60a erabiltzean huts egiten du
🔗 Informazio gehiago: ezarri memoria mugak Docker erabiliz soilik

 8.8. Baliatu cachea konpilazio denbora murrizteko
TL;PL: Dockerren irudi osoa cache-tik berreraikitzea ia berehalakoa izan daiteke, zuzen eginez gero. Eguneratu ez diren argibideek Dockerfile fitxategiaren goialdean egon behar dute, eta etengabe aldatzen ari direnek (aplikazioaren kodea, esate baterako) beheko aldean egon behar dute
Bestela: Docker eraikitzeak oso luze jo dezake eta baliabide asko kontsumituko ditu, nahiz eta aldaketa txikiak egin
🔗 Informazio gehiago: baliatu cachea konpilazio denborak murrizteko

 8.9. Erabili irudiaren erreferentzia esplizitua, saihestu "azken" (latest) etiketa
TL;PL: zehaztu irudi laburpen esplizitu bat edo etiketa baten bertsioa, inoiz ez aipatu latest. Garatzaileek sarritan uste izaten dute, latest adieraziz gero, biltegiko azken irudia eskuratuko dutela, baina ez da horrela. Laburpena erabiltzeak zerbitzuaren instantzia guztiek kode bera exekutatuko dutela bermatzen du
Gainera, irudi etiketa bat aipatzen bada, oinarrizko irudia aldatu egin daiteke, ez baitago irudi etiketekin fidatzerik instalazio determinista bat egiteko orduan. Horren ordez, instalazioa determinista izanez gero, SHA256 laburpena erabil daiteke irudi zehatza erreferentziatzeko
Bestela: oinarrizko irudi baten bertsio berri bat erabiliz gero, aldaketa handiak gerta litezke produkzioan, horrek aplikazioaren nahigabeko portaera sortuz
🔗 Informazio gehiago: ulertu irudi etiketak eta erabili "azken" (latest) etiketa kontu handiz

 8.10. Hobetsi Docker oinarrizko irudi txikiagoak
TL;PL: irudi handiek ahultasun gehiago izateko arriskua handitu eta baliabideen kontsumoa areagotzen dute. Docker irudi arinagoak erabiltzeak, Slim eta Alpine Linux aldaerak adibidez, arazo hori arindu egiten du
Bestela: batetik, denbora gehiago beharko da irudiak eraiki, txertatu eta ateratzeko; bestetik, erabiltzaile maltzurrek eraso bektore ezezagunak erabil ditzakete; eta, azkenik, baliabide gehiago beharko dira
🔗 Informazio gehiago: hobetsi irudi txikiagoak

 8.11. Garbitu eraikitze faseko sekretuak, saihestu sekretuak argudioetan
TL;PL: saihestu Dockerren konpilazio inguruneko sekretuak agerian geratzea. Docker irudi bat IE bezalako ingurune anitzetan eta ekoizpena bezain garbituta ez dauden erregistroetan partekatzen da normalean. Adibide tipikoa npm giltza (tokena) da, normalean dockerfile fitxategi batera pasatzen dena argumentu gisa. Giltza hori irudiaren barruan geratzen da denbora luzez beharrezkoa izateari utzi ondoren ere, eta erasotzaileari npm erregistro pribatura sartzeko aukera ematen dio. Hori ekidin daiteke sekretua .npmrc bezalako fitxategi batean kopiatuz, eta, ondoren, sekretu hori kenduz etapa anitzeko eraikuntza bat erabiliz (kontuz, eraikitze historia ere ezabatu beharko litzateke) edo bat ere aztarnarik uzten dituen Docker build-kit funtzio sekretua erabiliz
Bestela: IE eta docker erregistroan sartzeko aukera duten guztiek erakundearen sekretu preziatuak ere eskuratzeko aukera izango dute onura gehigarri gisa
🔗 Informazio gehiago: garbitu eraikitze faseko sekretuak

 8.12. Eskaneatu ahultasun geruza anitzeko irudiak
TL;PL: kode menpekotasunen ahultasunak egiaztatzeaz gain, eskaneatu ekoizpenera bidalitako azken irudia ere. Dockerren irudien eskanerrek kodeen menpekotasunak egiaztatzen dituzte, baina baita sistema eragilearen binarioak ere. E2E segurtasun eskaneatze horrek eremu handiago bat hartzen du eta egiaztatzen du inongo erabiltzaile maltzurrak ez duela maltzurkeriatik egin eraikitze aldian zerbait injektatuz. Ondorioz, hau exekutatzea gomendatzen da hedapenaren aurreko azken urrats gisa. Mordoska bat eskaner doako eta komertzial dago CI / CD pluginak ere eskaintzen dituztenak
Bestela: baliteke zure kodeak ahultasunik ez izatea. Hala ere, baliteke oraindik ere hackeatua izatea, aplikazioek normalean erabiltzen dituzten sistema eragilearen mailako binarioen bertsioak ahultasunak dituelako (adibidez, OpenSSL, TarBall)
🔗 Informazio gehiago: Docker praktika arruntak

 8.13 Garbitu NODE_MODULE cachea
TL;PL: menpekotasunak edukiontzi batean instalatu ondoren, kendu bertako cachea. Ez du inolako zentzurik etorkizuneko instalazio azkarragoetarako menpekotasunak bikoizteak, ez baita beste instalaziorik egingo: Dockeren irudiak aldaezinak dira. Kode lerro bakarra erabiliz dozenaka MB aurrezten dira (normalean, irudiaren tamainaren % 10-50)
Bestela: ekoizpenera bidaliko den irudiak % 30 gehiago pisatuko du, inoiz erabiliko ez diren fitxategiak direla eta
🔗 Informazio gehiago: garbitu NODE_MODULE cachea

 8.14. Dockeren praktika generikoak
TL;PL: hemen duzu Node.jsrekin zuzenean loturarik ez duen Docker aholkuen bilduma. Ez dago alderik Noderen eta beste edozein lengoaiaren inplementazioen artean. Egin klik “Informazio gehiago” botoian
🔗 Informazio gehiago: Dockeren praktika generikoak

 8.15. Garbitu zure Dockerfile fitxategia Linterra erabiliz
TL;PL: Linterra erabiliz zure Dockerfile fitxategia garbitzea urrats garrantzitsua da haren barruan praktika onak errespetatzen ez dituzten arazoak identifikatzeko. Docker garbitzaile (linter) espezializatu bat erabiliz errendimendu eta segurtasun hobekuntzak erraz atzematen dira, alferrikako ordu ugari aurreztea edo produkzio kodean segurtasun arazoak murriztea lortuz
Bestela: okerrez, Dockerfile fitxategiaren sortzaileak nagusi (root) bat utzi zuen produkzio erabiltzaile moduan, eta jatorri ezezaguneko biltegi irudi bat ere erabili zuen. Hori liner soil batekin ekidin liteke.
🔗 Informazio gehiago: garbitu zure Dockerfile fitxategia

⬆ Itzuli hasierara
Mugarriak
Gida hau mantentzeko eta eguneratuta egoteko, jarraibideak eta praktika onak eguneratzen eta hobetzen ari gara etengabe komunitatearen laguntzarekin. Proiektu honetan lagundu nahi baduzu, jarraitu gure mugarriak jarrai sartu lantaldeetan

Itzulpenak
Komunitatearen ekarpena dira hemengo itzulpen guztiak eman. Oso pozik hartuko genituzke zure itzulpenak, bai dagoeneko eginda dauden testuenak zein egiten ari garen eta egingo ditugunenak
Amaitutako itzulpenak

 Brasilgo portugalera - Marcelo Melo-ren eskutik
 Txinera - Matt Jin-ren eskutik
 Errusiera - Alex Ivanov-ren eskutik
 Poloniera - Michal Biesiada-ren eskutik
 Euskara - Ane Diaz de Tuesta & Joxefe Diaz de Tuestaren eskutik

Aribidean dauden itzulpenak

 Frantsesa (Eztabaidan)
 Hebrearra (Eztabaidan)
 Koreera - Sangbeom Han-ren eskutik (Eztabaidan)
 Gaztelera (Eztabaidan)
 Turkiera (Eztabaidan)


Zuzendaritza Batzordea
Ezagutu Zuzendaritza Batzordeko kideak, proiektuaren orientazioa eta etorkizunerako jarraibideak emateko elkarlanean dirautenak. Gainera, batzordeko kide bakoitza gure Github projects-pean dagoen proiektu baten buru da

Yoni Goldberg


EEBB-etan, Europan eta Israelen, bezeroekin tamaina handiko Node.js aplikazioen sorkuntzan lan egiten duen Node.jsren inguruko aholkulari independentea. Gida honetako praktika on asko lehenengo aldiz goldbergyoni.com-en argitaratuak izan ziren. Jar zaitez Yoni-rekin kontatuan @goldbergyoni-en edo me@goldbergyoni.com helbidearen bidez


Bruno Scheufler

💻 full-stack web ingeniaria, Node.js eta GraphQL zalea


Kyle Martin


Full Stack Garatzailea eta Zelanda Berrian lan egiten duen Site Reliability Ingeniaria, web aplikazioen segurtasutasunean eta egituraketan, eta tamaina handiko Node.js aplikazioen sorkuntzan interesa du


Kevyn Bruyere

Full-stack garatzaile independentea, Ops eta automatizazioan zaletua dena

Steering Committee Emeriti

Sagir Khan



Javascripten eta bere ekosisteman (React, Node.js, TypeScript, GraphQL, MongoDB, eta sistemako JS/JSON edozein geruzatan eragin dezakeen edozer) aditua, munduko marka ezagunenetarako produktuak sortzen ditu web plataforma erabiliaz. Node.js Fundazioko Banakako Kidea

Languntzaileak
Mila esker gure laguntzaile guztiei! 🙏
Gure kolaboratzaileak proiektuan maiz parte hartzen duten kideak dira, praktika onak proposatuz, gaien zerrenda ordenatuz, parte hartze eskaerak (pull request) aztertuz... Milaka pertsona Node.js aplikazioak hobeto sortzen laguntzen interesa baduzu, irakur ezazu gure kolaboratzaile gida 🎉









Ido Richter (Fundatzailea)
Keith Holliday



Emeriti Kolaboratzailea








Refael Ackermann




Parte hartu
Open sourcen parte hartu nahi baduzu, hemen duzu aukera! Gehiago jakiteko, irakurri parte hartu dokumentua
Parte hartzaileak ✨
Eskerrik asko proiektu honetan parte hartu duten pertsona zoragarriei!




  
    
      Kevin Rambaud🖋
      Michael Fine🖋
      Shreya Dahal🖋
      Matheus Cruz Rocha🖋
      Yog Mehta🖋
      Kudakwashe Paradzayi🖋
      t1st3🖋
    
    
      mulijordan1976🖋
      Matan Kushner🖋
      Fabio Hiroki🖋
      James Sumners🖋
      Dan Gamble🖋
      PJ Trainor🖋
      Remek Ambroziak🖋
    
    
      Yoni Jah🖋
      Misha Khokhlov🖋
      Evgeny Orekhov🖋
      -🖋
      Isaac Halvorson🖋
      Vedran Karačić🖋
      lallenlowe🖋
    
    
      Nathan Wells🖋
      Paulo Reis🖋
      syzer🖋
      David Sancho🖋
      Robert Manolea🖋
      Xavier Ho🖋
      Aaron🖋
    
    
      Jan Charles Maghirang Adona🖋
      Allen🖋
      Leonardo Villela🖋
      Michał Załęcki🖋
      Chris Nicola🖋
      Alejandro Corredor🖋
      cwar🖋
    
    
      Yuwei🖋
      Utkarsh Bhatt🖋
      Duarte Mendes🖋
      Jason Kim🖋
      Mitja O.🖋
      Sandro Miguel Marques🖋
      Gabe🖋
    
    
      Ron Gross🖋
      Valeri Karpov🖋
      Sergio Bernal🖋
      Nikola Telkedzhiev🖋
      Vitor Godoy🖋
      Manish Saraan🖋
      Sangbeom Han🖋
    
    
      blackmatch🖋
      Joe Reeve🖋
      Ryan Busby🖋
      Iman Mohamadi🖋
      Sergii Paryzhskyi🖋
      Kapil Patel🖋
      迷渡🖋
    
    
      Hozefa🖋
      Ethan🖋
      Sam🖋
      Arlind🖋
      Teddy Toussaint🖋
      Lewis🖋
      Gabriel Lidenor 🖋
    
    
      Roman🖋
      Francozeira🖋
      Invvard🖋
      Rômulo Garofalo🖋
      Tho Q Luong🖋
      Burak Shen🖋
      Martin Muzatko🖋
    
    
      Jared Collier🖋
      Hilton Meyer🖋
      ChangJoo Park(박창주)🖋
      Masahiro Sakaguchi🖋
      Keith Holliday🖋
      coreyc🖋
      Maximilian Berkmann🖋
    
    
      Douglas Mariano Valero🖋
      Marcelo Melo🖋
      Mehmet Perk🖋
      ryan ouyang🖋
      Shabeer🖋
      Eduard Kyvenko🖋
      Deyvison Rocha🖋
    
    
      George Mamer🖋
      Konstantinos Leimonis🖋
      Oliver Lluberes🌍
      Tien Do🖋
      Ranvir Singh🖋
      Vadim Nicolaev🖋 🌍
      German Gamboa Gonzalez🖋
    
    
      Hafez🖋
      Chandiran🖋
      VinayaSathyanarayana🖋
      Kim Kern🖋
      Kenneth Freitas🖋
      songe🖋
      Kirill Shekhovtsov🖋
    
    
      Serge🖋
      keyrwinz🖋
      Dmitry Nikitenko🖋
      bushuai👀 🖋
      Benjamin Gruenbaum🖋
      Ezequiel🌍
      Juan José Rodríguez🌍
    
    
      Or Bin🖋
      Andreo Vieira🖋
      Michael Solomon🖋
      Jimmy Callin🖋
      Siddharth🖋
      Ryan Smith🖋
      Tom Boettger🖋
    
    
      Joaquín Ormaechea🌍
      dfrzuz🌍
      Victor Homyakov🖋
      Josh🖋 🛡️
      Alec Francis🖋
      arjun6610🖋
      Jan Osch🖋
    
    
      Thiago Rotondo Sampaio🌍
      Alexsey🖋
      Luis A. Acurero🌍
      Lucas Romano🌍
      Denise Case🖋
      Nick Ribal🖋 👀
      0xflotus🖋
    
    
      Jonathan Chen🖋
      Dilan Srilal🖋
      vladthelittleone🌍
      Nik Osvalds🖋
      Daniel Kiss📖
      Forresst🖋
      Jonathan Svenheden🖋
    
    
      AustrisC🖋
      kyeongtae kim🌍
      007🖋
      Ane Diaz de Tuesta🌍 🖋
      YukiOta🌍
      Frazer Smith🖋
      Raz Luvaton🖋
    
    
      Yuta Azumi🖋
      andrewjbarbour🖋
      mr🖋
      Aleksandar🖋
      Owl🖋
      Yedidya Schwartz🖋 💡
      ari🖋
    
    
      Thomas König🖋
      Kalle Lämsä🖋
      Wyatt🖋
      KHADIR Tayeb🖋
      Shankar Regmi🖋
      Shubham🖋
      Lucas Alves🖋
    
    
      Benjamin🖋
      Yeoh Joer🖋
      Miigon🖋
      Rostislav Bogorad🖋
      Flouse🖋
      Tarantini Pereira🖋
      Kazuki Matsuo🖋
    
    
      Adam Smith🖋
      Dohyeon Ko🖋
      Vladislav Legkov🖋
      Kerollos Magdy🖋
      Erez Lieberman🖋
      Breno Macedo🖋
      Fernando Flores🌍
    
    
      Rafael Brito🌍
      Emiliano Peralta🌍
      Shin, SJ🖋
      Benjamin Forster🖋
      Daniele Fedeli🖋
      djob195🖋
      antspk🖋
    
    
      정진영🖋
      kkk-cashwalk🖋
      apainintheneck🖋
      Fajar Budhi Iswanda🖋
      이주호🖋
      Singh🖋
      Alex Dumitru🖋
    
    
      Anton Lykhatskyi🖋
      sangwonlee🖋
      Eugenio Berretta🖋
      soranakk🖋
      고준영🖋 💻
      Guilherme Portella 🖋
      André Esser🖋
    
    
      Scc🌍
      Mauro Accornero🖋
      no-yan🖋\n\n\n\nMelhores Práticas em Node.js

  



    


 Siga-nos no Twitter! @nodepractices

Leia em diferentes idiomas: CN, BR, RU, PL, JA, EU (ES, FR, HE, KR and TR em progresso! )

Construído e mantido pelo nosso Comitê Diretivo e Colaboradores
Novas Práticas e Notícias


Nova Boa Prática: 4.4: Evite dados fixos e sementes para teste, adicione os dados no teste


Nova Boa Prática: 6.25: Evite publicar segredos no registro do npm


Nova tradução:  Português Brasileiro disponível agora, cortesia de Marcelo Melo! ❤️


🎊 60,000 estrelas!: Nosso repo recebeu estrela e a confiança de 60.100 desenvolvedores. Estamos sem palavras



Bem-vindo! 3 Coisas Que Você Precisa Saber
1. Quando você lê aqui, na verdade você lê alguns dos melhores artigos de Node.js - este é um resumo e curadoria dos mais bem ranqueados conteúdos sobre as melhores práticas do Node.js.
2. Esta é a maior coletânea, e está crescendo mais a cada semana - atualmente, são apresentadas mais de 80 melhores práticas, guias de estilo e dicas de arquitetura. Novas issues e PR são criadas diariamente para manter este livro vivo atualizado. Gostaríamos muito de ver você contribuindo aqui, seja corrigindo algum erro de código ou sugerindo novas e brilhantes ideias. Veja nossas conquistas aqui.
3. A maioria dos tópicos possuem informações adicionais - perto dos tópicos das melhores práticas, você encontrará o link 🔗Leia Mais que irá apresentar exemplos de códigos, citações de blogs selecionados e mais informações.

Índice

Práticas de Estrutura de Projeto (5)
Práticas de Tratamento de Erros (12) 
Práticas de Estilo de Código (13) 
Práticas de Testes e Qualidade Geral (13) 
Práticas de Produção (19) 
Práticas de Segurança (25)
Práticas de Performance (1) (Em Progresso ✍️)


1. Práticas de Estrutura de Projeto
 1.1 Estruture sua solução por componentes
TL;DR: A pior armadilha das grandes aplicações é manter uma enorme base de código com centenas de dependências - tal qual as monolíticas, que diminuem a velocidade dos desenvolvedores conforme eles tentam incorporar novos recursos. Em vez disso, particione seu código em componentes, cada um com sua própria pasta ou uma base de código dedicada, e garanta que cada unidade seja mantida pequena e simples. Veja o link ‘Leia Mais’ abaixo, para ver exemplos de estrutura correta de projeto.
Caso contrário: Quando desenvolvendo novos recursos, desenvolvedores têm dificuldade para perceber o impacto de suas modificações e temem estragar outros componentes dependentes - deploys se tornam mais lentos e arriscados. Também é considerado mais difícil de escalar quando nenhuma unidade de negócio está separada.
🔗 Leia mais: estruture por componentes

 1.2 Coloque seus Componentes em Camadas, mantenha o Express dentro de seus limites
TL;DR: Cada componente deve conter 'layers' (camadas) - um objeto dedicado para web, lógica e código de acesso a dados. Isso não apenas faz uma separação clara dos interesses, como também facilita significativamente os mocks e testes de sistema. Embora este seja um padrão muito comum, desenvolvedores de API tendem a misturar camadas, passando os objetos da camada Web (req e res do Express) para a lógica de negócios e camadas de dados - isto torna sua aplicação dependente, e acessível apenas pelo Express.
Caso contrário: Uma aplicação que misture objetos WEB com outras camadas não podem ser acessadas por códigos de teste, CRON jobs e outras chamadas não oriundas do Express.
🔗 Leia Mais: seu app em camadas

 1.3 Envolva os utilitários comuns como pacotes npm
TL;DR: Em uma grande aplicação, que constitui uma grande base de código, utilidades de características transversais tais como logger, encriptação e afins, devem ser envolvidos pelo seu próprio código e exposto como pacotes npm privados. Isso permite compartilhá-los entre várias bases de código e projetos.
Caso contrário: Você deverá criar seu próprio ciclo de implantação e dependência.
🔗 Leia Mais: estrutura por característica

 1.4 Separe 'app' e 'server' no Express
TL;DR: Evite o péssimo hábito de definir todo a aplicação Express em um único arquivo enorme - separe a definição de seu 'Express' no mínimo em dois arquivos: a declaração da API (app.js) e as configurações de rede (WWW). Para uma estrutura ainda melhor, declare sua API dentro dos componentes.
Caso contrário: Sua API será acessível apenas para testes via chamadas HTTP (mais lentos e muito mais difíceis de gerar relatórios de cobertura). Provavelmente não será um grande prazer manter centenas de linhas de código em um único arquivo.
🔗 Leia Mais: separe 'app' e 'server' no Express

 1.5 Use configuração consciente, segura e hierárquica do ambiente
TL;DR: Uma definição de configuração perfeita e impecável deve garantir que (a) as chaves possam ser lidas a partir do arquivo E TAMBÉM da variável de ambiente (b) os segredos sejam mantidos fora do código consolidado (c) a configuração é hierárquica para facilitar a localização. Existem alguns pacotes que podem auxiliar na checagem destes tópicos, como rc, nconf, config e convict
Caso contrário: Deixar de satisfazer qualquer um dos requisitos de configuração simplesmente atrapalhará a equipe de desenvolvimento ou devops. Provavelmente ambas.
🔗 Leia Mais: melhores práticas de configuração

⬆ Voltar ao topo
2. Práticas de Tratamento de Erros
 2.1 Utilize Async-Await ou promises para tratamento de erros assíncronos
TL;DR: Tratar erros assíncronos no estilo callback provavelmente é o caminho mais rápido para o inferno (também conhecido como a pyramid of doom - ou pirâmide da desgraça em bom português). O melhor presente que você pode dar ao seu código é utilizar uma biblioteca respeitável de promise ou async-await, que proporciona uma sintaxe de código muito mais compacta e familiar, como o try-catch.
Caso contrário: O estilo de callback do Node.js, function(err, response), é um caminho promissor para um código insustentável devido à combinação de manipulação de erro com código casual, aninhamento excessivo e padrões de codificação inadequados.
🔗 Leia Mais: evitando callbacks

 2.2 Utilize apenas objetos de erro interno
TL;DR: Muitos geram erros como uma string ou como algum tipo personalizado - isso complica a lógica de tratamento de erros e a interoperabilidade entre módulos. Se você rejeita uma promise, lance uma mensagem de erro ou uma exceção - utilizando somente o objeto de erro interno aumentará a uniformidade e evitará a perda de informações.
Caso contrário: Ao invocar algum componente, sendo incerto qual tipo de erro irá retornar - isso faz com que o tratamento de erros seja muito mais difícil. Até pior, usar tipos personalizados para descrever erros pode levar à perda de informações de erros críticos, como o stack trace!
🔗 Leia Mais: usando o objeto interno de erro

 2.3 Diferencie erros operacionais vs erros de programação
TL;DR: Erros operacionais (ex: API recebeu um input inválido) referem-se a casos onde o impacto do erro é totalmente compreendido e pode ser tratado com cuidado. Por outro lado, erro de programação (ex: tentar ler uma variável não definida) refere-se a falhas de código desconhecidas que ditam para reiniciar a aplicação.
Caso contrário: Você pode sempre reiniciar o aplicativo quando um erro aparecer, mas por que derrubar aproximadamente 5000 usuários que estavam online por causa de um pequeno erro operacional previsto? O contrário também não é ideal - manter a aplicação rodando quando um problema desconhecido (erro de programação) ocorreu, pode levar para um comportamento não esperado. Diferenciá-los, permite agir com tato e aplicar uma abordagem equilibrada baseada no dado contexto.
🔗 Leia Mais: erros operacionais vs erros de programação

 2.4 Trate erros de forma centralizada, não dentro de um middleware do Express
TL;DR: A lógica de tratamento de erros, bem como email para administrador e registros (logs), deve ser encapsulada em um objeto dedicado e centralizado que todos os endpoints (por exemplo, middleware do Express, cron jobs, testes unitários) chamem quando um erro é recebido.
Caso contrário: Não tratar os erros em um mesmo lugar irá levar à duplicidade de código, e provavelmente, a erros tratados incorretamente.
🔗 Leia Mais: tratando erros de forma centralizada

 2.5 Documente erros de API usando o Swagger ou GraphQL
TL;DR: Permita que os clientes de sua API saibam quais erros podem ser retornados para que eles possam lidar com esses detalhes, sem causar falhas. Para RESTful APIs geralmente, isto é feito com frameworks de documentação REST API, como o Swagger. Se você está usando GraphQL, você também pode utilizar seu esquema e comentários.
Caso contrário: Um cliente de uma API pode decidir travar e reiniciar, apenas pelo motivo de ter recebido de volta um erro que não conseguiu entender. Nota: o visitante de sua API pode ser você (muito comum em um ambiente de microsserviço).
🔗 Leia Mais: documentando erros de API no Swagger ou GraphQL

 2.6 Finalize o processo quando um estranho chegar
TL;DR: Quando ocorre um erro desconhecido (um erro de programação, veja a melhor prática #3) - há incerteza sobre a integridade da aplicação. Uma prática comum sugere reiniciar cuidadosamente o processo utilizando uma ferramenta de “reinicialização” como Forever e PM2.
Caso contrário: Quando uma exceção desconhecida é lançada, algum objeto pode estar com defeito (por exemplo, um emissor de evento que é usado globalmente e não dispara mais eventos devido a alguma falha interna) e todas as requisições futuras podem falhar ou se comportar loucamente.
🔗 Leia Mais: finalizando o processo

 2.7 Use um agente de log maduro para aumentar a visibilidade de erros
TL;DR: Um conjunto de ferramentas de registro maduras como Pino, Winston, Bunyan ou Log4js, irão acelerar a descoberta e entendimento de erros. Portanto, esqueça o console.log.
Caso contrário: Ficar procurando através de console.logs ou manualmente em arquivos de texto confusos sem utilizar ferramentas de consulta ou um visualizador de log decente, pode mantê-lo ocupado até tarde.
🔗 Leia Mais: usando um logger maduro

 2.8 Fluxos de testes de erros usando seu framework favorito
TL;DR: Se o analista de QA ou o desenvolvedor de testes - Certifique-se de que seu código não atenda apenas o cenário positivo, mas também trate e retorne os erros corretos. Frameworks de teste como Mocha e Chai podem lidar com isso facilmente (veja exemplos de códigos no “Gist popup”)
Caso contrário: Sem testes, seja automático ou manual, não podemos confiar em nosso código para retornar os erros certos. Sem erros significantes, não há tratamento de erros.
🔗 Leia Mais: fluxos de testes de erros

 2.9 Descubra erros e downtime usando APM
TL;DR: Produtos de monitoramento e desempenho (também conhecido como APM), avaliam sua base de código ou API de forma proativa, para que possam destacar automaticamente erros, falhas e lentidões não percebidos.
Caso contrário: Você pode gastar muito esforço medindo o desempenho e os tempos de inatividade (downtime) da API. Provavelmente, você nunca saberá quais são suas partes de código mais lentas no cenário real e como elas afetam o UX.
🔗 Leia Mais: usando APM

 2.10 Capture rejeições de promises não tratadas
TL;DR: Qualquer exceção lançada dentro de uma promise será descartada, a menos que o desenvolvedor não se esqueça de tratá-la explicitamente. Mesmo que seu código esteja inscrito no process.uncaughtException! Supere isso, registrando no evento process.unhandledRejection.
Caso contrário: Seus erros serão engolidos e não vão deixar rastros. Nada para se preocupar.
🔗 Leia Mais: capturando rejeições de promises não tratadas

 2.11 Falhe rápido, valide argumentos usando uma biblioteca dedicada
TL;DR: Isto deveria fazer parte das melhores práticas de Express - Confirme a entrada da API para evitar erros desagradáveis ​​que são muito mais difíceis de acompanhar mais tarde. A validação de código geralmente é entediante ao menos que você esteja utilizando uma biblioteca de ajuda bem legal, como a Joi.
Caso contrário: Considere isto: sua função espera receber um “Desconto” como argumento numérico que foi esquecido de passar. Mais adiante, seu código verifica se Desconto!=0 (valor do desconto permitido é maior que zero). Depois, irá permitir que o usuário desfrute de um desconto. Meu Deus, que baita bug. Entendeu?
🔗 Leia Mais: falhando rápido

 2.12 Sempre use 'await' antes de retornar as 'promises' para evitar um rastreamento parcial da pilha de erro
TL;DR: Sempre use return await quando retornar uma 'promise' para beneficiar o rastreamento completo da pilha de erro. Se um função retorna uma 'promise', essa função deve ser declarada como função async e  explicitamente await na promise antes de devolvê-la
Caso contrário: Uma função que retorna uma promise sem o await não aparecerá na pilha de erro.
A ausência dessas informações provavelmente complicariam a compreensão do fluxo que leva ao erro,
especialmente se a causa do comportamento anormal estiver dentro da função ausente
🔗 Leia Mais: retornando promises

⬆ Voltar ao topo
3. Práticas de Estilo de Código
 3.1 Use ESLint
TL;DR: O ESLint é de fato o padrão para verificar possíveis erros e consertar o estilo de código, não apenas para identificar problemas básicos de espaçamento, mas também para detectar antipadrões de código, como desenvolvedores lançando erros sem classificação. Embora o ESLint possa corrigir automaticamente estilos de código, outra ferramentas como o prettier e o beautify são mais poderosos no quesito correção de formatação e trabalham em conjunto com o ESLint.
Caso contrário: Desenvolvedores irão focar nas preocupações tediosas de espaçamento e largura de linha e o tempo poderá ser desperdiçado pensando sobre o estilo de código do projeto.
🔗 Leia Mais: Usando ESLint e Prettier

 3.2 Plugins Específicos do Node.js
TL;DR: Além das regras padrões do ESLint que cobrem somente o Vanilla JS, adicione plug-ins específicos do Node, como o eslint-plugin-node, o eslint-plugin-mocha e o eslint-plugin-node-security
Caso contrário: Muitos padrões de código do Node.js com falha podem escapar do radar. Por exemplo, desenvolvedores podem chamar arquivos fazendo o require(variavelComoCaminho) com uma determinada variável como caminho, o que permite que invasores executem qualquer script JS. Os linters do Node.js podem detectar tais padrões e reclamar cedo.

 3.3 Comece um Bloco de Código com Chaves na Mesma Linha
TL;DR: As chaves que abrem um bloco de código devem estar na mesma linha da instrução de abertura
Exemplo de Código
// Do
function someFunction() {
  // code block
}

// Avoid
function someFunction()
{
  // code block
}
Caso contrário: Evitar esta recomendação pode levar a resultados inesperados, como visto nesta thread do StackOverflow:
🔗 Leia Mais: "Por que os resultados variam com base no posicionamento da chave?" (Stackoverflow)

 3.4 Separe suas declarações corretamente
Não importa se você usa ponto-e-vírgula ou não para separar suas declarações, conhecer as armadilhas comuns de quebras de linha impróprias ou inserção automática de ponto e vírgula, irá ajudá-lo a eliminar erros regulares de sintaxe.
TL;DR: Use o ESLint para obter conhecimento sobre as preocupações de separação. Prettier ou Standardjs podem resolver automaticamente esses problemas.
Caso contrário: Como visto na seção anterior, o interpretador do JavaScript adiciona automaticamente um ponto-e-vírgula ao final de uma instrução, se não houver uma, ou considera uma instrução como não terminada onde deveria, o que pode levar a alguns resultados indesejáveis. Você pode usar atribuições e evitar o uso de expressões de função chamadas imediatas para evitar a maioria dos erros inesperados.
Exemplo de código
// Faça
function doThing() {
    // ...
}

doThing()

// Faça

const items = [1, 2, 3]
items.forEach(console.log)

// Evitar - lança exceção
const m = new Map()
const a = [1,2,3]
[...m.values()].forEach(console.log)
> [...m.values()].forEach(console.log)
>  ^^^
> SyntaxError: Unexpected token ...

// Evitar - lança exceção
const count = 2 // tenta executar 2(), mas 2 não é uma função
(function doSomething() {
  // Faça algo incrível
}())
// Coloque um ponto-e-vírgula antes da função invocada imediatamente, após a definição const, salve o valor de retorno da função anônima para uma variável ou evite IIFEs no conjunto
🔗 Leia mais: "Regra Semi ESLint"
🔗 Leia mais: "Nenhuma regra ESLint de múltiplas linhas inesperada"

 3.5 Nomeie Suas Funções
TL;DR: Nomeie todas as funções, incluindo closures e callbacks. Evite funções anônimas. Isso é especialmente útil em uma aplicação node. Nomear todas a funções permitirá que você entenda facilmente o que está olhando quando verificar um snapshot da memória.
Caso contrário: A depuração de problemas de produção usando um dump principal (snapshot da memória) pode se tornar um desafio quando você percebe um consumo significativo de memória de funções anônimas.

 3.6 Convenções de nomenclatura para variáveis, constantes, funções e classes
TL;DR: Utilize lowerCamelCase quando nomeando constantes, variáveis e funções, e UpperCamelCase (primeira letra maiúscula também) quando nomeando classes. Isso irá lhe ajudar a distinguir facilmente entre variáveis/funções, e classes que necessitam de instanciação. Use nomes descritivos, mas tente mantê-los curtos.
Caso contrário: O JavaScript é a única linguagem no mundo que permite invocar um construtor (“Class”) diretamente sem instanciá-lo primeiro. Consequentemente, Classes e construtores de funções são diferenciados começando com UpperCamelCase
3.6 Exemplo de Código
// para classes nós usamos UpperCamelCase
class SomeClassExample {}

// para nomes de constantes nós usamos a palavra const e lowerCamelCase
const config = {
  key: "value",
};

// para nomes de variáveis e funções nós usamos lowerCamelCase
let someVariableExample = "value";
function doSomething() {}

 3.7 Prefira const do que let. Esqueça do var
TL;DR: Usar const significa que uma vez que a variável foi atribuída, ela não pode ser reatribuída. Preferir const irá te ajudar a não cair na tentação de utilizar a mesma variável para diferentes usos, e irá deixar seu código mais limpo. Se uma variável precisa ser reatribuída, em um for loop, por exemplo, use let para declarar. Outro aspecto importante do let é que esta variável só estará disponível no escopo de código em que ela foi definida. var tem escopo de função, não de bloco, e não deveria ser utilizada em ES6
, agora que você tem const e let ao seu dispor.
Caso contrário: A depuração se torna muito mais complicada ao seguir uma variável que frequentemente muda
🔗 Leia Mais: JavaScript ES6+: var, let ou const? 

 3.8 Requires vem primeiro e não dentro de funções
TL;DR: Faça o require de módulos no início de cada arquivo, antes e fora de qualquer função. Esta simples prática irá te ajudar não apenas a reconhecer as dependências de um determinado arquivo com facilidade e rapidez, como também evitará alguns possíveis problemas.
Caso contrário: Os requires rodam de forma síncrona pelo Node.js. Se eles forem chamados de dentro de uma função, isso pode impedir que outras solicitações sejam tratadas em um momento mais crítico. Além disso, se um módulo necessário ou qualquer uma de suas dependências lançar um erro e travar o servidor, é melhor descobrir isso o mais rápido possível, o que pode não ser o caso se este módulo tiver sido declarado dentro de uma função.

 3.9 Faça Require nas pastas, não diretamente nos arquivos
TL;DR: Ao desenvolver um módulo/biblioteca em uma pasta, coloque um arquivo index.js que exponha os componentes internos do módulo para que cada consumidor passe por ele. Isso serve como uma 'interface' para seu módulo e facilita futuras mudanças sem causar perdas.
Caso contrário: Alterar a estrutura interna dos arquivos ou a assinatura pode quebrar a interface com clientes.
3.9 Exemplo de Código
// Do
module.exports.SMSProvider = require("./SMSProvider");
module.exports.SMSNumberResolver = require("./SMSNumberResolver");

// Avoid
module.exports.SMSProvider = require("./SMSProvider/SMSProvider.js");
module.exports.SMSNumberResolver = require("./SMSNumberResolver/SMSNumberResolver.js");

 3.10 Use 0 operador ===
TL;DR: Dê preferência em usar o operador de comparação estrita === ao invés do operador de comparação abstrata ==, que é mais fraco. == irá comparar duas variáveis depois de convertê-las para o mesmo tipo. Não há conversão de tipo no === e ambas as variáveis devem ser do mesmo tipo para serem iguais.
Caso contrário: Variáveis diferentes podem retornar verdadeiro quando comparadas usando o operador ==.
3.10 Exemplo de Código
"" == "0"; // false
0 == ""; // true
0 == "0"; // true

false == "false"; // false
false == "0"; // true

false == undefined; // false
false == null; // false
null == undefined; // true

" \t\r\n " == 0; // true
Todas as declarações acima false se feitas com ===.

 3.11 Use Async Await, evite callbacks
TL;DR: Agora o Node 8 LTS possui suporte completo para Async-await. Esta é uma nova maneira de lidar com códigos assíncronos que substitui callbacks e promises. Async-await é não-bloqueante, e isso faz com que os códigos assíncronos pareçam síncronos. O melhor presente que você pode dar ao seu código é usar async-await, que fornece uma sintaxe de código muito mais compacta e familiar como o try-catch.
Caso contrário: Lidar com erros assíncronos no estilo de callback é provavelmente o caminho mais rápido para o inferno - esse estilo força verificar todos os erros, lidar com desajeitados aninhamentos de código e torna difícil raciocinar sobre o fluxo de código.
🔗Leia mais: Guia do async await 1.0

 3.12 Use Fat (=>) Arrow Functions
TL;DR: Embora seja recomendado usar async-await e evitar parâmetros de função ao lidar com APIs antigas, que aceitam promises ou callbacks - arrow functions tornam a estrutura do código mais compacta e mantém o contexto léxico da função raiz (por exemplo, 'this').
Caso contrário: Códigos mais longos (em funções ES5) são mais propensos a erros e são mais difíceis de ler.
🔗 Leia mais: Arrow Functions - é hora de abraçar a causa

⬆ Voltar ao topo
4. Práticas de Testes e Qualidade Geral
 4.1 No mínimo, escreva testes de API (componente)
TL;DR: A maioria dos projetos simplesmente não possuem testes automatizados devido a falta de tempo ou geralmente o 'testing project' fica fora de controle e acaba sendo abandonado. Por esse motivo, priorize e comece com o teste de API, que é o mais fácil de escrever e proporciona mais cobertura do que os testes unitários (você pode inclusive criar testes de API sem código usando ferramentas como Postman). Depois, se você tiver mais recursos e tempo, continue com testes avançados, como testes unitários, testes de banco de dados, testes de desempenho, etc.
Caso contrário: Voce pode passar longos dias escrevendo testes unitários para perceber que possui apenas 20% de cobertura de sistema.

 4.2 Inclua 3 partes em cada nome de teste
TL;DR: Faça o teste falar no nível de requisitos, de modo que seja autoexplicativo para engenheiros de garantia de qualidade e desenvolvedores que não estão familiarizados com o código. Indicar no nome do teste o que está sendo testado (unidade em teste), em que circunstâncias e qual é o resultado esperado.
Caso contrário: Uma implantação falhou, um teste chamado "Adicionar produto" falhou. Isso lhe diz exatamente o que está errado?
🔗 Leia Mais: Inclua 3 partes em cada nome de teste

 4.3 Estutura de testes padrão AAA
TL;DR: Estruture seus testes com 3 seções bem separadas: Arrange, Act & Assert (AAA). A primeira parte inclui a configuração do teste, depois a execução do teste unitário, e finalmente, a fase de asserção. Seguir esta estrutura garante que o leitor não gaste nenhuma CPU cerebral para entender o plano de teste
Caso contrário: Você não somente passará várias horas do dia para entender o código principal, mas agora também gastará várias horas no que deveria ter sido uma simples parte do dia (testando) esticando seu cérebro.
🔗 Leia Mais: Estutura de testes padrão AAA

 4.4 Detecte problemas de código com um linter
TL;DR: Use um code linter para checar a qualidade básica e detectar antipadrões antecipadamente. Rode-o antes de qualquer teste e adicione-o como um pre-commit git-hook para minimizar o tempo necessário para revisar e corrigir qualquer problema. Veja também Seção 3 no Prática de Estilo de Código.
Caso contrário: Você pode deixar passar algum antipadrão e possível código vulnerável para seu ambiente de produção.

 4.5 Evite dados fixos e sementes para teste, adicione os dados no teste
TL;DR: Para evitar o acoplamento de testes e facilitar o entendimento do fluxo do teste, cada teste deve adicionar e atuar em seu próprio conjunto de linhas de banco de dados. Sempre que um teste precisar extrair ou assumir a existência de alguns dados do banco de dados - ele deve incluir explicitamente esses dados e evitar a mutação de outros registros
Caso contrário: Considere um cenário em que a implementação é abortada devido a falhas nos testes. Agora, a equipe gastará um tempo precioso de investigação que termina em uma triste conclusão: o sistema funciona bem, mas os testes interferem uns nos outros e quebram a compilação
🔗 Leia Mais: Evite dados fixos para teste

 4.6 Inspencione constantemente por dependências vulneráveis
TL;DR: Até mesmo as dependências mais confiáveis, como o Express, têm vulnerabilidades conhecidas. Isso pode ser facilmente contornado usando ferramentas comunitárias e comerciais como 🔗 nsp que pode ser invocado a partir do seu CI em cada build.
Caso contrário: Manter seu código livre de vulnerabilidades sem ferramentas dedicadas exigirá o acompanhamento constante de publicações online sobre novas ameaças. Saia do tédio.

 4.7 Marque seus testes
TL;DR: Diferentes testes devem rodar em diferentes cenários: testes de rápidos, sem IO, devem ser executados quando um desenvolvedor salva ou faz commit em um arquivo, testes completos de ponta a ponta geralmente são executados quando uma nova solicitação de request é enviada, etc. Isso pode ser conseguido através da marcação de testes com palavras-chave como #cold #api #sanity. Assim você pode invocar o subconjunto desejado. Por exemplo, é desta forma que você invocaria apenas o grupo de sanity test usando o Mocha: mocha --grep 'sanity'
Caso contrário: Rodar todos os testes, incluindo aqueles que executam dezenas de consultas de banco de dados, sempre que o desenvolvedor fizer uma pequena alteração pode ser extremamente lento e impedir que desenvolvedores executem testes.

 4.8 Verifique a cobertura de seu teste, isso te ajuda a identificar padrões incorretos de teste
TL;DR: Ferramentas de cobertura de código como Istanbul/NYC, são ótimas por 3 motivos: elas são gratuitas (nenhum esforço é necessário para beneficiar esses relatórios), elas ajuda a identificar diminuição na cobertura de testes, e por último mas não menos importante, ela destacam a incompatibilidade de testes: olhando relatórios coloridos de cobertura de código, você pode notar, por exemplo, áreas de código que nunca são testadas como cláusulas catch (o que significa que os testes só invocam os caminhos felizes e não como o aplicativo se comporta em erros). Configure-o para falhas se a cobertura estiver abaixo de um certo limite.
Caso contrário: Não haverá nenhuma métrica automática informando quando uma grande parte de seu código não é coberta pelo teste.

 4.9 Inspecione pacotes desatualizados
TL;DR: Use sua ferramenta preferida (por exemplo, 'npm outdated' ou npm-check-updates para detectar pacotes instalados que estão desatualizados, injetar essa verificação em seu pipeline de CI e até mesmo fazer uma falha grave em um cenário grave. Por exemplo, um cenário grave pode ser quando um pacote instalado esteja há 5 commits atrás (por exemplo, a versão local é 1.3.1 e a versão no repositório é 1.3.8) ou está marcada como descontinuada pelo autor - mate o build e impeça a implantação desta versão.
Caso contrário: Sua produção executará pacotes que foram explicitamente marcados pelo autor como arriscados.

 4.10 Use docker-compose para testes e2e
TL;DR: Teste de ponta a ponta (end to end, ou e2e), que inclui dados ativos, costumava ser o elo mais fraco do processo de CI, já que depende de vários serviços pesados como o banco de dados. O docker-compose deixa isso mamão com açúcar, criando um ambiente de produção usando um arquivo de texto simples e comandos fáceis. Isto permite criar todos os serviços dependentes, banco de dados e rede isolada para teste e2e. Por último mas não menos importante, ele pode manter um ambiente sem estado que é invocado antes de cada suíte de testes e é encerrado logo após.
Caso contrário: Sem o docker-compose, as equipes devem manter um banco de dados de teste para cada ambiente de teste, incluindo as máquinas dos desenvolvedores, e manter todos esses bancos de dados sincronizados para que os resultados dos testes não variem entre os ambientes.

 4.11 Refatore regularmente usando ferramentas de análise estática
TL;DR: O uso de ferramentas de análise estática ajuda fornecendo maneiras objetivas de melhorar a qualidade do código e manter seu código sustentável. Você pode adicionar ferramentas de análise estática para seu build de Integração Contínua (CI) falhar quando encontre code smells. Seus principais pontos de vantagem sobre o linting são a abilidade de inspecionar a qualidade no contexto de múltiplos arquivos (por exemplo, detectar duplicidades), realizar análises avançadas (por exemplo, complexidade de código), e acompanhar histórico e progresso de problemas de código. Dois dexemplos de ferramentas que podem ser utilizadas são Sonarqube (mais de 2.600 stars) e Code Climate (mais de 1.500 stars).
Caso contrário: Com qualidade de código ruim, bugs e desempenho sempre serão um problema que nenhuma nova biblioteca maravilhosa ou recursos de última geração podem corrigir.
🔗 Leia Mais: Refatoração!

 4.12 Escolha cuidadosamente sua plataforma de Integração Contínua - CI (Jenkins vs CircleCI vs Travis vs Resto do mundo)
TL;DR: Sua plataforma de integração contínua (CICD) irá hospedar todas as ferramentas de qualidade (por exemplo, teste, lint), então ela deve vir com um ecosistema de plugins arrebatador. O Jenkins costumava ser o padrão de muitos projetos, pois tem a maior comunidade, juntamente com uma poderosa plataforma, ao preço de configuração complexa que exige uma curva de aprendizado íngreme. Atualmente, ficou bem mais fácil para configurar uma solução de CI usando ferramentas SaaS como CircleCI e outras. Essas ferramentas permitem a criação de um pipeline de CI flexível sem o peso de gerenciar toda a infraestrutura. Eventualmente, é um perde e ganha entre robustez e velocidade - escolha seu lado com cuidado!
Caso contrário: Escolher algum fornecedor de nicho pode fazer com que você fique engessado quando precisar de alguma personalização avançada. Por outro lado, escolher o Jenkins pode ser uma perda de tempo precioso na configuração da infraestrutura.
🔗 Leia Mais: Escolhendo a plataforma de CI

 4.13 Teste seus 'middlewares' isoladamente
TL;DR: quando um 'middleware' contém alguma lógica imensa que abrange muitas solicitações, vale a pena testá-lo isoladamente, sem ativar todo o framework. Isso pode ser facilmente alcançado por 'stubbing' e espionando os objetos {req, res, next}
Caso contrário: Um bug no 'middleware Express' === um bug em todas ou na maioria das solicitações
🔗 Read More: Test middlewares in isolation

⬆ Voltar ao topo
5. Boas Práticas de Produção
 5.1. Monitoramento
TL;DR: O monitoramento é um jogo de descobrir problemas antes que os clientes os encontrem - obviamente deve ser atribuída muita importância para isto. O mercado está sobrecarregado de ofertas, portanto, considere começar com a definição das métricas básicas que você deve seguir (sugestões minhas dentro), depois passe por recursos extras e escolha a solução que marca todas as caixas. Acesse o ‘Gist’ abaixo para uma visão geral das soluções.
Caso contrário: Falha === clientes desapontados. Simples
🔗 Leia Mais: Monitoramento!

 5.2. Aumente a transparência usando smart logging
TL;DR: Logs podem ser um armazém inútil de instruções de debug ou o ativador de um belo dashboard que conta a história do seu app. Planeje sua plataforma de logs desde o primeiro dia: como os logs são coletados, armazenados e analisados para ter certeza de que as informações desejadas possam realmente ser extraídas, por exemplo, a avaliação de erro, após uma transação inteira através de serviços e servidores, etc.
Caso contrário: Você acaba com uma caixa preta que é difícil de raciocinar, então você começa a reescrever todas as declarações de log para adicionar informações adicionais.
🔗 Leia Mais: Aumente a transparência usando smart logging

 5.3. Delegue tudo o que for possível (por exemplo, gzip, SSL) a um proxy reverso
TL;DR: O Node é terrivelmente ruim em fazer tarefas intensas de CPU como gzipping, SSL termination, etc. Você deve usar serviços de middleware “reais” como nginx, HAproxy ou serviços de nuvem.
Caso contrário: Seu único e pobre thread permanecerá ocupado fazendo tarefas de infra-estrutura em vez de lidar com o núcleo da sua aplicação e o desempenho certamente será degradado.
🔗 Leia Mais: Delegue tudo o que for possível (por exemplo, gzip, SSL) a um proxy reverso

 5.4. Bloqueio de dependências
TL;DR: Seu código deve ser idêntico em todos os ambientes, mas, surpreendentemente, o npm permite que as dependências derivem entre os ambientes por padrão - quando você instala pacotes em vários ambientes, ele tenta buscar a versão mais recente dos pacotes. Supere isso usando arquivos de configuração do npm, .npmrc, que dirão a cada ambiente para salvar a versão exata (não a última) de cada pacote. Outra alternativa, para um controle melhor, use o “shirinkwrap” do npm. *Atualização: a partir do NPM5, as dependências são bloqueadas por padrão. O novo gerenciador de pacotes no pedaço, Yarn, também faz isso por padrão.
Caso contrário: O QA testará completamente o código e aprovará uma versão que se comportará de maneira diferente na produção. Pior ainda, servidores diferentes no mesmo cluster de produção podem executar código diferente.
🔗 Leia Mais: Bloqueio de dependências

 5.5. Poupe tempo de atividade do processo usando a ferramenta certa
TL;DR: O processo deve continuar e ser reiniciado após falhas. Para cenários simples, as ferramentas de "reinicialização", como PM2, podem ser suficientes. Entretanto, no mundo atual "dockerizado", as ferramentas de gerenciamento de cluster também devem ser consideradas
Caso contrário: Rodar dezenas de instâncias sem uma estratégia clara e muitas ferramentas juntas (gerenciamento de cluster, docker, PM2) pode levar o DevOps ao caos.
🔗 Leia Mais: Poupe tempo de atividade do processo usando a ferramenta certa

 5.6. Utilize todos os núcleos do processador
TL;DR: Em sua forma básica, uma aplicação Node roda em um único núcleo do processador enquanto todos os demais ficam inativos. É seu dever replicar o processamento do Node e utilizar todos os processadores. Para aplicações pequenas/médias você pode usar o Node Cluster ou PM2. Para uma aplicação maior, considere replicar o processo usando algum cluster do Docker (por exemplo, o K8S ou o ECS) ou scripts de deploy que são baseados no sistema de inicialização do Linux (por exemplo, systemd)
Caso contrário: Sua aplicação vai utilizar apenas 25% dos recursos disponíveis(!) ou talvez até menos. Note que um servidor típico possui 4 núcleos de processamento ou mais, o deploy ingênuo do Node.js utiliza apenas 1 (mesmo usando serviços de PaaS como AWS Beanstalk!)
🔗 Leia Mais: Utilize todos os núcleos do processador

 5.7. Crie um ‘endpoint de manutenção’
TL;DR: Exponha um conjunto de informações relacionadas ao sistema, como uso de memória e REPL, etc, em uma API segura. Embora seja altamente recomendado confiar em ferramentas padrões e de battle-tests, algumas informações e operações valiosas são mais fáceis de serem feitas usando código.
Caso contrário: Você perceberá que está realizando muitos “deploys de diagnóstico” - enviando código para produção apenas para extrair algumas informações para fins de diagnóstico.
🔗 Leia Mais: Crie um ‘endpoint de manutenção’

 5.8. Descubra erros e tempo de inatividade usando produtos APM
TL;DR: Produtos de monitoramento e desempenho (também conhecidos como APM) medem a base de código e a API de forma proativa para que possam ir “automagicamente” além do monitoramento tradicional e medir a experiência geral do usuário entre os serviços e camadas. Por exemplo, alguns APMs podem destacar uma transação que é carregada muito lentamente no lado do usuário final, sugerindo a causa raiz.
Caso contrário: Você pode gastar muito esforço medindo o desempenho e os tempos de inatividade da API, provavelmente você nunca saberá quais são suas partes de código mais lentas no cenário do mundo real e como elas afetam o UX.
🔗 Leia Mais: Descubra erros e tempo de inatividade usando produtos APM

 5.9. Deixe seu código pronto para produção
TL;DR: Programe com o fim em mente, planeje para produção desde o primeiro dia. Isso pode parecer vago, então eu compilei algumas dicas de desenvolvimento que estão relacionadas à manutenção de produção (clique no Gist abaixo).
Caso contrário: Uma pessoa fera em TI/DevOps não salvará um sistema mal escrito.
🔗 Leia Mais: Deixe seu código pronto para produção

 5.10. Meça e proteja o uso de memória
TL;DR: O Node.js tem uma relação controversa com o uso de memória: o motor v8 possui limites no uso de memória (1.4GB) e existem caminhos conhecidos para vazamentos de memória no código do Node - portanto, observar a memória do processo do Node é uma obrigação. Em aplicações pequenas, você pode medir a memória periodicamente usando comandos shell, mas em aplicação média-grande considere utilizar um sistema de monitoramento de memória robusto.
Caso contrário: A memória de seus processos pode vazar cem megabytes por dia, assim como aconteceu no Walmart.
🔗 Leia Mais: Meça e proteja o uso de memória

 5.11. Deixe seus recursos de frontend fora do Node
TL;DR: Sirva conteúdo de frontend usando um middleware dedicado (nginx, S3, CDN) pois o desempenho do Node fica realmente prejudicado quando se lida com muitos arquivos estáticos devido ao seu modelo single threaded (segmento único).
Caso contrário: Seu único thread do Node ficará ocupado fazendo streaming the centenas de arquivos de html/imagens/angular/react ao invés de alocar todo seu recurso para a tarefa que ele foi designado - servir conteúdo dinâmico.
🔗 Leia Mais: Deixe seus recursos de frontend fora do Node

 5.12. Seja stateless, mate seus Servidores quase todos os dias
TL;DR: Armazene qualquer tipo de dados (por exemplo, sessões de usuário, cache, arquivos de upload) em armazenamentos externos. Considere ‘matar’ seus servidores periódicamente ou utilize plataformas ‘serverless’ (por exemplo, AWS Lambda) que forçam explicitamente um comportamento stateless.
Caso contrário: Falha em um determinado servidor resultará em tempo de inatividade da aplicação, em vez de apenas matar uma máquina defeituosa. Além do mais, dimensionar a elasticidade será mais desafiador devido à dependência de um servidor específico.
🔗 Leia Mais: Seja stateless, mate seus Servidores quase todos os dias

 5.13. Utilize ferramentas que detectam vulnerabilidades automaticamente
TL;DR: Mesmo as dependências mais confiáveis, como o Express, têm vulnerabilidades conhecidas (de tempos em tempos) que podem colocar um sistema em risco. Isso pode ser contornado usando ferramentas comunitárias e comerciais que constantemente verificam vulnerabilidades e avisam (localmente ou no Github). Algumas podem até corrigí-las imediatamente.
Caso contrário: Manter seu código limpo com vulnerabilidades sem ferramentas dedicadas exigirá o acompanhamento constante de publicações online sobre novas ameaças. Bem entendiante.
🔗 Leia Mais: Utilize ferramentas que detectam vulnerabilidades automaticamente

 5.14. Atribua‘TransactionId’ para cada declaração de log
TL;DR: Atribua o mesmo identificador, transaction-id: {some value}, para cada entrada de log dentro de um mesmo request. Depois, ao inspecionar erros em logs, conclua facilmente o que aconteceu antes e depois. Infelizmente, isso não é fácil de se conseguir no Node, devido à sua natureza assíncrona. Veja exemplos de código.
Caso contrário: Observar um log de erros de produção sem o contexto - o que aconteceu antes - torna muito mais difícil e mais lento raciocinar sobre o problema.
🔗 Leia Mais: Atribua ‘TransactionId’ para cada declaração de log

 5.15. Defina NODE_ENV=production
TL;DR: Defina a variável de ambiente NODE_ENV para ‘production’ ou ‘development’ para sinalizar se as otimizações de produção devem ser ativadas - muitos pacotes npm determinam o ambiente atual e otimizam seu código para produção.
Caso contrário: Omitir esta simples propriedade pode degradar muito o desempenho. Por exemplo, ao utilizar o Express para renderização do lado do servidor, omitir o NODE_ENV o torna mais lento!
🔗 Leia Mais: Defina NODE_ENV=production

 5.16. Projete deploys automáticos, atômicos e com tempo de inatividade zero
TL;DR: Pesquisas mostram que times que executam muitos deploys, reduzem a probabilidade de problemas graves em produção. Deploys rápidos e automatizados que não necessitam de processos manuais arriscados e significativo tempo de inatividade, melhoram o processo de deploy. Provavelmente, você irá alcançar isso usando Docker, combinado com ferramentas de CI, pois elas se tornaram o padrão do setor para deploy simplificado.
Caso contrário: Deploys demorados -> tempo de inatividade de produção e erro relacionado a humanos -> equipe não-confiante com os deploys -> menos implantações e recursos.

 5.17. Use uma versão LTS do Node.js
TL;DR: Certifique de que você está usando uma versão LTS do Node.js para receber correção de bugs críticos, atualizações de segurança e melhorias de performance.
Caso contrário: Bugs recentemente descobertos e vulnerabilidades podem ser usados para explorar uma aplicação em produção, e sua aplicação pode se tornar incompatível com vários módulos e mais difícil de manter.
🔗 Leia Mais: Use uma versão LTS do Node.js

 5.18. Não direcione logs dentro do aplicativo
TL;DR: O destino dos logs não devem ser codificados na unha por desenvolvedores, dentro do código da aplicação. Ao invés disso, deve ser definido pelo ambiente de execução no qual a aplicação é executada. Desenvolvedores devem escrever logs para stdout usando um utilitário logger e depois deixar o ambiente de execução (container, servidor, etc) canalizar o fluxo do stdout para o destino apropriado (por exemplo: Splunk, Graylog, ElasticSearch, etc).
Caso contrário: Aplicações manipulando o roteamento de log === difícil de dimensionar, perda de logs, separação ruim de preocupações.
🔗 Leia Mais: Roteamento de Logs

 5.19. Instale seus pacotes com npm ci
TL;DR: Você precisa ter certeza de que o código de produção usa a versão exata dos pacotes que você realizou os testes. Execute npm ci para fazer estritamente uma instalação limpa de suas dependências correspondentes do package.json e do package-lock.json. O uso desse comando é recomendado em ambientes automatizados, como pipelines de integração contínua.
Caso contrário: o QA testará completamente o código e aprovará uma versão que se comportará de maneira diferente em produção. Pior ainda, diferentes servidores no mesmo cluster de produção podem executar códigos diferentes.
🔗 Read More: Use npm ci

⬆ Voltar ao topo
6. Boas Práticas em Segurança



 6.1. Adote as regras de segurança do linter
 
TL;DR: Faça uso de plugins de linter relacionados à segurança, como por exemplo o eslint-plugin-security para capturar vulnerabilidades de segurança e erros o mais cedo possível, na melhor das hipóteses, enquanto estão sendo codificados. Isso pode ajudar a detectar pontos fracos de segurança, como usar o eval, invocar um processo filho ou importar um módulo com string literal (por exemplo, input do usuário). Clique em ‘Leia Mais’ abaixo para ver exemplos de códigos que serão capturados por um linter de segurança.
Caso contrário: O que poderia ser um ponto fraco de segurança durante o desenvolvimento, pode se tornar um grande problema no ambiente de produção. Além disso, o projeto pode não seguir práticas de segurança de código consistentes, levando a vulnerabilidades sendo introduzidas ou segredos confidenciais comprometidos em repositórios remotos.
🔗 Leia Mais: Regras de Lint

 6.2. Limite requests simultâneos usando um middleware

TL;DR: Ataques DOS são muito populares e relativamente fáceis de conduzir. Implemente uma limitação de taxa, usando um serviço externo como balanceadores de carga de nuvem, firewalls de nuvem, nginx, o pacote rate-limiter-flexible, ou (para aplicações menores e menos críticas) um middleware limitador de taxa (por exemplo, express-rate-limit)
Caso contrário: Uma aplicação pode estar sujeita a um ataque resultando em uma queda do serviço, onde usuários reais recebem um serviço degradado ou indisponível.
🔗 Leia Mais: Implementando limitador de taxa

 6.3 Extraia segredos dos config files ou use pacotes para criptografá-los
 
TL;DR: Nunca armazene segredos em textos simples em arquivos de configuração ou códigos fonte. Em vez disso, use sistemas de gerenciamento secreto como produtos Vault, Kubernetes/Docker Secrets, ou use variáveis de ambiente. Como resultado final, os segredos armazenados no código fonte devem ser criptografados e gerenciados(rolling keys, expiring, auditing, etc). Faça uso de hooks de pre-commit/push para evitar que faça o commit de secredos acidentalmente.
Caso contrário: O controle de origem, mesmo para repositórios privados, pode ser tornado público por engano, quando todos os segredos são expostos. O acesso ao controle de origem para uma parte externa fornecerá inadvertidamente acesso a sistemas relacionados (bancos de dados, APIs, serviços, etc.).
🔗 Leia Mais: Gerenciamento de segredos

 6.4. Impeça vulnerabilidades de query injection com bibliotecas ORM/ODM

TL;DR: Para evitar SQL/NoSQL injection e outros ataques maliciosos, sempre faça uso de um ORM/ODM ou de uma biblioteca de banco de dados que proteja os dados ou suporte consultas parametrizadas nomeadas ou indexadas, e que cuide da validação de entrada do usuário para os tipos esperados. Nunca use apenas template strings do JavaScript ou concatenação de string para injetar valores em queries, pois isto abre sua aplicação para muitas vulnerabilidades. Todas as bibliotecas respeitáveis de acesso a dados do Node.js (por exemplo, Sequelize, Knex, mongoose) possuem proteção contra ataques de injeção.
Caso contrário: A entrada de usuários não validados pode levar à injeção do operador ao trabalhar com MongoDB para NoSQL e não usar um sistema próprio ou ORM irão permitir facilmente um ataque de SQL injection, criando uma grande vulnerabilidade.
🔗 Leia Mais: Prevenção de query injection usando bibliotecas de ORM/ODM

 6.5. Coleção genérica de boas práticas de segurança
TL;DR: Esta é uma coleção de conselhos de segurança que não estão relacionadas diretamente com Node.js - a implementação do Node não é muito diferente comparado a outras linguagens. Clique em “leia mais” para dar uma olhada.
🔗 Leia Mais: Boas práticas comuns de segurança

 6.6. Ajuste os headers de resposta HTTP para uma segurança aprimorada

TL;DR: Sua aplicação deve estar utilizando headers seguros para evitar que invasores façam ataques comuns, como scripts entre sites (XSS), clickjacking, dentre outros ataques maliciosos. Eles podem ser configurados facilmente usando módulos como o helmet.
Caso contrário: Invasores podem realizar ataques diretos aos usuários de sua aplicação, levando a grandes vulnerabilidades de segurança.
🔗 Leia Mais: Usando headers seguros em sua aplicação

 6.7. Inspecione constante e automaticamente por dependências vulneráveis

TL;DR: Com o ecosistema do npm, é comum um projeto ter várias dependências. Dependências sempre devem ser checadas em caso de novas vulnerabilidades serem encontradas. Utilize ferramentas como npm audit ou snyk para rastrear, monitorar e corrigir dependências vulneráveis. Integre estas ferramentas com a configuração de seu CI, para que você possa capturar uma dependência vulnerável antes que ela afete o ambiente de produção.
Caso contrário: Um invasor pode detectar seu framework web e atacar todas suas vulnerabilidades.
🔗 Leia Mais: Segurança de dependências

 6.8. Evite usar a biblioteca de criptografia do Node.js para manipular senhas, use Bcrypt

TL;DR: Senhas ou segredos (chaves de API), devem ser armazenadas usando um hash seguro + salt function como bcrypt, que deve ser a escolha preferencial em relação à sua implementação de JavaScript, devido a razões de desempenho e segurança.
Caso contrário: Senhas ou segredos que são persistidos sem o uso de uma função segura, são vulneráveis a força bruta e ataques de dicionário que levarão eventualmente à sua divulgação.
🔗 Leia Mais: Use o Bcrypt

 6.9. Fuja de saídas HTML, JS e CSS

TL;DR: Dados não confiáveis que são enviados para o browser podem ser executados em invés de serem exibidos. Isso está sendo comumente referido como um ataque de script entre sites (XSS). Evite isto, usando bibliotecas dedicadas que marcam explicitamente os dados como conteúdo puro que nunca deve ser executado (por exemplo: encoding, escaping).
Caso contrário: Um invasor pode armazenar um código JavaScript malicioso em seu banco de dados, que será enviado para os clientes.
🔗 Leia Mais: Evite saídas

 6.10. Valide os esquemas de entrada JSON
 
TL;DR: Valide as requisições do body e garanta que elas atendem as expectativas e falhem rápido se não atender. Para evitar o tédio de códigos de validação para cada rota, você pode usar leves esquemas de validação baseados em JSON, como jsonschema ou joi
Caso contrário: Sua generosidade e abordagem permissiva aumentam muito a superfície de ataque e incentivam o invasor a experimentar muitas entradas até encontrar alguma combinação para travar a aplicação.
🔗 Leia Mais: Valide os esquemas de entrada JSON

 6.11. Ajude a inserir JWTs em listas negras

TL;DR: Ao usar JSON Web Tokens (por exemplo, com Passport.js), por padrão não existem mecanismos para revogar o acesso de tokens problemáticos. Uma vez descoberta alguma atividade maliciosa do usuário, não há como impedi-lo de acessar o sistema, desde que ele tenha um token válido. Abrande isso implementando uma lista negra de tokens não confiáveis que são validados em cada solicitação.
Caso contrário: Tokens expirados ou extraviados, podem ser usados maliciosamente por terceiros para acessar uma aplicação e para representar o proprietário do token.
🔗 Leia Mais: Blacklist de JSON Web Tokens

 6.12. Evite ataques de força bruta contra autorização

TL;DR: Uma técnica simples e poderosa é limitar as tentativas de autorização usando duas métricas:

A primeiro é o número de tentativas consecutivas com falha do mesmo ID/nome e endereço IP exclusivos do usuário.
A segundo é o número de tentativas malsucedidas de um endereço IP durante um longo período de tempo. Por exemplo, bloqueie um endereço IP se ele fizer 100 tentativas com falha em um dia.

Caso contrário: Um invasor pode emitir tentativas ilimitadas de senha automatizada para obter acesso a contas com privilégios em uma aplicação.
🔗 Leia Mais: Limitando a taxa de login

 6.13. Rode o Node.js como um usuário que não seja root

TL;DR: Existe um cenário comum em que o Node.js é executado como um usuário root com permissões ilimitadas. Por exemplo, esse é o comportamento padrão em contêineres do Docker. É recomendável criar um usuário não raiz e associá-lo à imagem do Docker (exemplos abaixo) ou executar o processo em nome desse usuário chamando o container com o sinalizador "-u username".
Caso contrário: Um invasor que consiga executar um script no servidor obtém poder ilimitado sobre a máquina local (por exemplo, alterar o iptable e redirecionar o tráfego para seu servidor).
🔗 Leia Mais: Rode o Node.js com um usuário não raiz

 6.14. Limite o tamanho do payload usando um proxy reverso ou um middleware
 
TL;DR: Quanto maior o payload do body, mais difícil será o processamento de um único segmento. Esta é uma oportunidade para os invasores colocarem seus servidores de joelhos sem uma enorme quantidade de solicitações (ataques DOS / DDOS). Reduza isso limitando o tamanho do corpo das solicitações recebidas (por exemplo, firewall, ELB) ou configurando o express body parser para aceitar somente cargas de tamanho pequeno.
Caso contrário: Sua aplicação terá que lidar com solicitações grandes, incapazes de processar o outro trabalho importante que ele precisa realizar, o que leva a implicações de desempenho e vulnerabilidade em relação a ataques DOS.
🔗 Leia Mais: Limite o tamanho dos payloads

 6.15. Evite instruções eval do JavaScript
  
TL;DR: eval é do mal, pois permite a execução de um código JavaScript personalizado durante o tempo de execução. Isso não é apenas uma preocupação de desempenho, mas também uma importante preocupação de segurança devido ao código JavaScript malicioso que pode ser originado da entrada do usuário. Outra feature da linguagem que deve ser evitada é o construtor new Function constructor. setTimeout e setInterval também não devem ser receber código JavaScript dinâmico.
Caso contrário: o código JavaScript malicioso encontra um caminho para um texto passado para o eval ou outras funções de avaliação em tempo real da linguagem JavaScript, e terá acesso total às permissões do JavaScript na página. Essa vulnerabilidade geralmente se manifesta como um ataque XSS.
🔗 Leia Mais: Evite instruções eval do JavaScript

 6.16. Evite que RegEx maliciosos sobrecarreguem sua execução de thread único

TL;DR: Regular Expressions, embora sejam úteis, representam uma ameaça real para aplicativos JavaScript em geral, e a plataforma Node.js em particular .Uma entrada do usuário para correspondência de texto pode exigir uma quantidade maior de ciclos de CPU para processar. O processamento RegEx pode ser ineficiente até um ponto em que uma única solicitação que valida 10 palavras pode bloquear todo o loop de eventos por 6 segundos e botar 🔥 na CPU. Por essa razão, prefira pacotes de validação de terceiros como validator.js ao invés de escrever seus próprios pardrões de Regex, ou faça uso do safe-regex para detectar padrões vulneráveis de regex.
Caso contrário: Expressões regulares mal escritas podem ser suscetíveis a ataques de Regular Expresssion DoS, que irão bloquear completamente o loop de eventos. Por exemplo, o popular pacote moment foi encontrado com vulnerabilidades de uso de RegEx maliciosos em novembro de 2017.
🔗 Leia Mais: Evite RegEx maliciosos

 6.17. Evite o carregamento de módulos usando uma variável
  
TL;DR: Evite fazer require ou importar outro arquivo com um caminho que tenha sido fornecido como parâmetro devido à preocupação de que ele possa ter se originado da entrada do usuário. Esta regra pode ser estendida para acessar arquivos em geral (ou seja, fs.readFile()) ou outro acesso a recursos confidenciais com variáveis dinâmicas provenientes da entrada do usuário. O linter Eslint-plugin-security pode pegar esses padrões e avisar o quanto antes.
Caso contrário: A entrada de usuário mal-intencionada pode encontrar o caminho para um parâmetro usado para require de arquivos adulterados, por exemplo, um arquivo carregado anteriormente no sistema de arquivos ou para acessar arquivos de sistema já existentes.
🔗 Leia Mais: Carregamento seguro de módulos

 6.18. Rode códigos não seguros em uma sandbox
  
TL;DR: Quando a tarefa for executar código externo que é fornecido em tempo de execução (por exemplo, plug-in), use qualquer tipo de ambiente de execução 'sandbox' que isole e proteja o código principal em relação ao plug-in. Isso pode ser feito usando um processo dedicado (por exemplo, cluster.fork ()), ambiente serverless ou pacotes npm dedicados que atuam como uma sandbox.
Caso contrário: Um plugin pode atacar através de uma infinita variedade de opções, como loops infinitos, sobrecarga de memória e acesso a variáveis sensíveis do ambiente de processo.
🔗 Leia Mais: Rode códigos não seguros em uma sandbox

 6.19. Tome cuidado extra ao trabalhar com processos filhos
  
TL;DR: Evite usar processos filhos quando possível e valide e limpe a entrada para mitigar os ataques de shell injection se ainda precisar. Prefira usar child_process.execFile que, por definição, só executará um único comando com um conjunto de atributos e não permitirá a expansão de parâmetros do shell.
Caso contrário: O uso ingênuo de processos filhos pode resultar na execução de comandos remotos ou em ataques de shell injection, devido à entrada do usuário mal-intencionado passada para um comando do sistema não-autorizado.
🔗 Leia Mais: Tenha cautela ao trabalhar com processos filhos

 6.20. Oculte detalhes de erros dos usuários

TL;DR: Um manipulador de erros integrado do express oculta os detalhes de erros por padrão. Entretanto, são grandes as chances de você implementar sua própria lógica para manipular erros com objetos de erro customizados (considerado por muitos, a melhor prática). Se você faz isso, tenha certeza de que não está retornando o objeto Error inteiro para o cliente, pois ele pode conter detalhes confidenciais da aplicação.
Caso contrário: Detalhes confidenciais da aplicação como caminhos e arquivos do servidor, módulos de terceiros em uso e outros workflows internos da aplicação poderiam ser explorados e expostos por um invasor.
🔗 Leia Mais: Oculte detalhes de erros dos usuários

 6.21. Configure 2FA para o npm ou Yarn

TL;DR: Qualquer passo na cadeia de desenvolvimento deve ser protegido com o MFA (multi-factor authentication, ou autenticação em várias etapas), e o npm / Yarn é uma boa oportunidade para os invasores poderem colocar as mãos na senha de algum desenvolvedor. Usando as credenciais de desenvolvedor, os invasores podem injetar código malicioso em bibliotecas que são amplamente instaladas em projetos e serviços. Talvez, até mesmo por toda a rede de internet, se publicado abertamente. Ativando a 2-factor-authentication (autenticação em duas etapas) no npm, reduz a quase zero as chances de invasores alterarem seu código.
Caso contrário: Você já ouviu falar sobre o desenvolvedor do eslint cuja senha foi hackeada?

 6.22. Modifique as configurações do middleware de sessão

TL;DR: Cada framework e tecnologia web tem seus pontos fracos conhecidos - dizer aos invasores qual framework utilizamos é uma grande ajuda para eles. Usar as configurações padrões para middlewares de sessão pode expor sua aplicação - e ataques específicos ao framework, semelhantes ao heade X-Powered-By header. Tente ocultar qualquer coisa que possa identificar ou revelar sua stack (por exemplo, Node.js, express).
Caso contrário: Cookies podem ser enviados através de conexões não seguras, e um hacker pode usar a sessão do usuário para identificar o framework utilizado na aplicação, bem como vulnerabilidades específicas do módulo.
🔗 Leia Mais: Segurança de cookies e sessões

 6.23. Evite ataques do DOS definindo explicitamente quando um processo deve falhar

TL;DR: O processo do Node irá falhar quando os erros não forem tratados. Muitas boas práticas recomendam sair, mesmo que um erro tenha sido detectado e resolvido. O Express, por exemplo, irá falhar em qualquer erro assíncrono - a menos que você envolva rotas com uma cláusula catch. Isso abre um ponto de ataque muito fácil para os hackers que reconhecem qual entrada faz o processo falhar e enviam repetidamente o mesmo request. Não existe solução instantânea para isso, mas algumas técnicas podem aliviar a dor: Alertar com severidade crítica sempre que um processo falha devido a um erro não tratado, validar a entrada e evitar travar o processo devido à entrada inválida do usuário, envolver todas as rotas com uma cláusula catch e considerar não travar quando um erro é originado em uma solicitação o que acontece globalmente).
Caso contrário: Este é apenas um palpite: dado muitos aplicações Node.js, se tentarmos passar um JSON vazio para todas as solicitações POST, um punhado de aplicações falhará. Nesse ponto, podemos apenas repetir o envio da mesma solicitação para derrubar as aplicações com facilidade.

 6.24. Impeça redirecionamentos não seguros

TL;DR: Redirecionamentos que não validam a entrada do usuário podem permitir que invasores iniciem tentativas de phishing, roubem credenciais de usuários e executem outras ações mal-intencionadas.
Caso contrário: Se um invasor descobrir que você não está validando informações externas fornecidas pelo usuário, ele poderá explorar essa vulnerabilidade postando links especialmente em fóruns, mídias sociais e outros locais públicos para que os usuários cliquem.
🔗 Leia Mais: Impeça redirecionamentos não seguros

 6.25. Evite publicar segredos no registro do npm

TL;DR: Precauções devem ser tomadas para evitar o risco de publicação acidental de segredos nos registros públicos do npm. Um arquivo .npmignore pode ser usado para colocar arquivos ou pastas específicos em uma blacklist, ou a lista files no package.json pode atuar como uma whitelist.
Caso contrário: As chaves, as senhas ou outros segredos da API do seu projeto estão sujeitos a abusos por qualquer pessoa que os encontre, o que pode resultar em perda financeira, falsificação de identidade e outros riscos.
🔗 Leia Mais: Evite publicar segredos

⬆ Voltar ao topo
7. Boas Práticas em Performance
Nossos colaboradores estão trabalhando nesta seção. Gostaria de participar?
 7.1. Prefira métodos JS nativos ao invés de utilitários de usuário, como o Lodash
TL;DR: Muitas vezes é mais complicado usar bibliotecas de utilitários como o lodash e underscore sobre os métodos nativos, pois leva a dependências desnecessárias e desempenho mais lento.
Tenha em mente que, com a introdução do novo motor V8 juntamente com os novos padrões ES, os métodos nativos foram aprimorados de tal forma que agora ele tem cerca de 50% a mais de desempenho que as bibliotecas de utilitários.
Caso contrário: Você terá que manter projetos de menor desempenho onde você poderia simplesmente ter usado o que já estava disponível ou lidar com mais algumas linhas em troca de mais alguns arquivos.
🔗 Leia Mais: Prefira métodos nativos ao invés de utilitários do usuário como Lodash

Feitos
Para manter este guia e deixá-lo atualizado, estamos constantemente atualizando e aprimorando as diretrizes e as práticas recomendadas com a ajuda da comunidade. Você pode acompanhar nossos feitos e se juntar aos grupos de trabalho, caso queira contribuir com este projeto.

Traduções
Todas as traduções são contribuições da comunidade. Nós ficaremos felizes em obter ajuda com traduções concluídas, em andamento, ou mesmo com novas traduções!
Traduções concluídas

 Português Brasileiro - Cortesia de Marcelo Melo
 Chinês - Cortesia de Matt Jin
 Vasco - Cortesia de Ane Diaz de Tuesta & Joxefe Diaz de Tuesta

Traduções em andamento

 Francês (Discussão)
 Hebraico (Discussão)
 Coreano (Discussão)
 Russo (Discussão)
 Espanhol (Discussão)
 Turco (Discussão)


Comitê Diretivo
Conheça os membros do comitê diretivo - as pessoas que trabalham juntas para fornecer orientação e direção futura para o projeto. Além disso, cada membro do comitê lidera um projeto rastreado em nossos projetos do Github.

Yoni Goldberg


Consultor de Node.js independente, que trabalha com clientes nos EUA, Europa e Israel, na criação de aplicações Node dimensionáveis em grande escala. Muitas das melhores práticas acima foram publicadas primeiro em um post em seu blog em goldbergyoni.com. Encontre-o como @goldbergyoni ou me@goldbergyoni.com


Bruno Scheufler

💻 full-stack web engineer e entusiasta de Node.js & GraphQL


Kyle Martin


Full Stack Developer e Engenheiro de Confiabilidade de Sites com sede na Nova Zelândia, interessados ​​em segurança de aplicativos da Web, e arquitetando e construindo aplicativos Node.js para executar em escala global.


Sagir Khan



Especialista profundo em JavaScript e seu ecossistema - React, Node.js, MongoDB, praticamente qualquer coisa que envolva o uso de JavaScript/JSON em qualquer camada do sistema - criando produtos usando a plataforma da web para as marcas mais reconhecidas do mundo. Membro individual da "Node.js Foundation", colaborando em "Community Committee's Website Redesign Initiative".

Colaboradores
Obrigado a todos nossos colaboradores! 🙏
Nossos colaboradores são membros que estão contribuindo com o repositório em base regular, sugerindo novas práticas recomendadas, triando problemas, analisando solicitações de pull e muito mais. Se você estiver interessado em nos ajudar a orientar milhares de pessoas a criar melhores aplicações Node.js, leia nossas diretrizes de colaborador 🎉









Ido Richter (Founder)
Keith Holliday



Colaboradores anteriores








Refael Ackermann




Thank You Notes
We appreciate any contribution, from a single word fix to a new best practice. View our contributors and contributing documentation here!\n\ngoldbergyoni
    
    /
    
      nodebestpractices
    

    Public
  


        

        
            
    
      

  
                Notifications
    You must be signed in to change notification settings

  

  
              Fork
    10.4k

  

  
        
            
          Star
          102k

  



        
      

        



          

  
      
  
    
              
        Code
          


    

      
  
    
              
        Issues
          44


    

      
  
    
              
        Pull requests
          36


    

      
  
    
              
        Actions
          


    

      
  
    
              
        Projects
          0


    

      
  
    
              
        Security
          

    

      
  
    
              
        Insights
          


    


          
  
      
Additional navigation options



  
    
                
  
    
        
    
    
    
        
          
        
      
        
          Code
      

  

        
    
    
    
        
          
        
      
        
          Issues
      

  

        
    
    
    
        
          
        
      
        
          Pull requests
      

  

        
    
    
    
        
          
        
      
        
          Actions
      

  

        
    
    
    
        
          
        
      
        
          Projects
      

  

        
    
    
    
        
          
        
      
        
          Security
      

  

        
    
    
    
        
          
        
      
        
          Insights
      

  

    




      
  



  

  




    
    



    
      
    









  
  
     Files masterBreadcrumbsnodebestpractices/README.brazilian-portuguese.mdCopy path Blame  Blame        Latest commit HistoryHistory1172 lines (629 loc) · 89.4 KB masterBreadcrumbsnodebestpractices/README.brazilian-portuguese.mdTopFile metadata and controlsPreviewCodeBlame1172 lines (629 loc) · 89.4 KBRawMelhores Práticas em Node.js

  



    


 Siga-nos no Twitter! @nodepractices

Leia em diferentes idiomas: CN, BR, RU, PL, JA, EU (ES, FR, HE, KR and TR em progresso! )

Construído e mantido pelo nosso Comitê Diretivo e Colaboradores
Novas Práticas e Notícias


Nova Boa Prática: 4.4: Evite dados fixos e sementes para teste, adicione os dados no teste


Nova Boa Prática: 6.25: Evite publicar segredos no registro do npm


Nova tradução:  Português Brasileiro disponível agora, cortesia de Marcelo Melo! ❤️


🎊 60,000 estrelas!: Nosso repo recebeu estrela e a confiança de 60.100 desenvolvedores. Estamos sem palavras



Bem-vindo! 3 Coisas Que Você Precisa Saber
1. Quando você lê aqui, na verdade você lê alguns dos melhores artigos de Node.js - este é um resumo e curadoria dos mais bem ranqueados conteúdos sobre as melhores práticas do Node.js.
2. Esta é a maior coletânea, e está crescendo mais a cada semana - atualmente, são apresentadas mais de 80 melhores práticas, guias de estilo e dicas de arquitetura. Novas issues e PR são criadas diariamente para manter este livro vivo atualizado. Gostaríamos muito de ver você contribuindo aqui, seja corrigindo algum erro de código ou sugerindo novas e brilhantes ideias. Veja nossas conquistas aqui.
3. A maioria dos tópicos possuem informações adicionais - perto dos tópicos das melhores práticas, você encontrará o link 🔗Leia Mais que irá apresentar exemplos de códigos, citações de blogs selecionados e mais informações.

Índice

Práticas de Estrutura de Projeto (5)
Práticas de Tratamento de Erros (12) 
Práticas de Estilo de Código (13) 
Práticas de Testes e Qualidade Geral (13) 
Práticas de Produção (19) 
Práticas de Segurança (25)
Práticas de Performance (1) (Em Progresso ✍️)


1. Práticas de Estrutura de Projeto
 1.1 Estruture sua solução por componentes
TL;DR: A pior armadilha das grandes aplicações é manter uma enorme base de código com centenas de dependências - tal qual as monolíticas, que diminuem a velocidade dos desenvolvedores conforme eles tentam incorporar novos recursos. Em vez disso, particione seu código em componentes, cada um com sua própria pasta ou uma base de código dedicada, e garanta que cada unidade seja mantida pequena e simples. Veja o link ‘Leia Mais’ abaixo, para ver exemplos de estrutura correta de projeto.
Caso contrário: Quando desenvolvendo novos recursos, desenvolvedores têm dificuldade para perceber o impacto de suas modificações e temem estragar outros componentes dependentes - deploys se tornam mais lentos e arriscados. Também é considerado mais difícil de escalar quando nenhuma unidade de negócio está separada.
🔗 Leia mais: estruture por componentes

 1.2 Coloque seus Componentes em Camadas, mantenha o Express dentro de seus limites
TL;DR: Cada componente deve conter 'layers' (camadas) - um objeto dedicado para web, lógica e código de acesso a dados. Isso não apenas faz uma separação clara dos interesses, como também facilita significativamente os mocks e testes de sistema. Embora este seja um padrão muito comum, desenvolvedores de API tendem a misturar camadas, passando os objetos da camada Web (req e res do Express) para a lógica de negócios e camadas de dados - isto torna sua aplicação dependente, e acessível apenas pelo Express.
Caso contrário: Uma aplicação que misture objetos WEB com outras camadas não podem ser acessadas por códigos de teste, CRON jobs e outras chamadas não oriundas do Express.
🔗 Leia Mais: seu app em camadas

 1.3 Envolva os utilitários comuns como pacotes npm
TL;DR: Em uma grande aplicação, que constitui uma grande base de código, utilidades de características transversais tais como logger, encriptação e afins, devem ser envolvidos pelo seu próprio código e exposto como pacotes npm privados. Isso permite compartilhá-los entre várias bases de código e projetos.
Caso contrário: Você deverá criar seu próprio ciclo de implantação e dependência.
🔗 Leia Mais: estrutura por característica

 1.4 Separe 'app' e 'server' no Express
TL;DR: Evite o péssimo hábito de definir todo a aplicação Express em um único arquivo enorme - separe a definição de seu 'Express' no mínimo em dois arquivos: a declaração da API (app.js) e as configurações de rede (WWW). Para uma estrutura ainda melhor, declare sua API dentro dos componentes.
Caso contrário: Sua API será acessível apenas para testes via chamadas HTTP (mais lentos e muito mais difíceis de gerar relatórios de cobertura). Provavelmente não será um grande prazer manter centenas de linhas de código em um único arquivo.
🔗 Leia Mais: separe 'app' e 'server' no Express

 1.5 Use configuração consciente, segura e hierárquica do ambiente
TL;DR: Uma definição de configuração perfeita e impecável deve garantir que (a) as chaves possam ser lidas a partir do arquivo E TAMBÉM da variável de ambiente (b) os segredos sejam mantidos fora do código consolidado (c) a configuração é hierárquica para facilitar a localização. Existem alguns pacotes que podem auxiliar na checagem destes tópicos, como rc, nconf, config e convict
Caso contrário: Deixar de satisfazer qualquer um dos requisitos de configuração simplesmente atrapalhará a equipe de desenvolvimento ou devops. Provavelmente ambas.
🔗 Leia Mais: melhores práticas de configuração

⬆ Voltar ao topo
2. Práticas de Tratamento de Erros
 2.1 Utilize Async-Await ou promises para tratamento de erros assíncronos
TL;DR: Tratar erros assíncronos no estilo callback provavelmente é o caminho mais rápido para o inferno (também conhecido como a pyramid of doom - ou pirâmide da desgraça em bom português). O melhor presente que você pode dar ao seu código é utilizar uma biblioteca respeitável de promise ou async-await, que proporciona uma sintaxe de código muito mais compacta e familiar, como o try-catch.
Caso contrário: O estilo de callback do Node.js, function(err, response), é um caminho promissor para um código insustentável devido à combinação de manipulação de erro com código casual, aninhamento excessivo e padrões de codificação inadequados.
🔗 Leia Mais: evitando callbacks

 2.2 Utilize apenas objetos de erro interno
TL;DR: Muitos geram erros como uma string ou como algum tipo personalizado - isso complica a lógica de tratamento de erros e a interoperabilidade entre módulos. Se você rejeita uma promise, lance uma mensagem de erro ou uma exceção - utilizando somente o objeto de erro interno aumentará a uniformidade e evitará a perda de informações.
Caso contrário: Ao invocar algum componente, sendo incerto qual tipo de erro irá retornar - isso faz com que o tratamento de erros seja muito mais difícil. Até pior, usar tipos personalizados para descrever erros pode levar à perda de informações de erros críticos, como o stack trace!
🔗 Leia Mais: usando o objeto interno de erro

 2.3 Diferencie erros operacionais vs erros de programação
TL;DR: Erros operacionais (ex: API recebeu um input inválido) referem-se a casos onde o impacto do erro é totalmente compreendido e pode ser tratado com cuidado. Por outro lado, erro de programação (ex: tentar ler uma variável não definida) refere-se a falhas de código desconhecidas que ditam para reiniciar a aplicação.
Caso contrário: Você pode sempre reiniciar o aplicativo quando um erro aparecer, mas por que derrubar aproximadamente 5000 usuários que estavam online por causa de um pequeno erro operacional previsto? O contrário também não é ideal - manter a aplicação rodando quando um problema desconhecido (erro de programação) ocorreu, pode levar para um comportamento não esperado. Diferenciá-los, permite agir com tato e aplicar uma abordagem equilibrada baseada no dado contexto.
🔗 Leia Mais: erros operacionais vs erros de programação

 2.4 Trate erros de forma centralizada, não dentro de um middleware do Express
TL;DR: A lógica de tratamento de erros, bem como email para administrador e registros (logs), deve ser encapsulada em um objeto dedicado e centralizado que todos os endpoints (por exemplo, middleware do Express, cron jobs, testes unitários) chamem quando um erro é recebido.
Caso contrário: Não tratar os erros em um mesmo lugar irá levar à duplicidade de código, e provavelmente, a erros tratados incorretamente.
🔗 Leia Mais: tratando erros de forma centralizada

 2.5 Documente erros de API usando o Swagger ou GraphQL
TL;DR: Permita que os clientes de sua API saibam quais erros podem ser retornados para que eles possam lidar com esses detalhes, sem causar falhas. Para RESTful APIs geralmente, isto é feito com frameworks de documentação REST API, como o Swagger. Se você está usando GraphQL, você também pode utilizar seu esquema e comentários.
Caso contrário: Um cliente de uma API pode decidir travar e reiniciar, apenas pelo motivo de ter recebido de volta um erro que não conseguiu entender. Nota: o visitante de sua API pode ser você (muito comum em um ambiente de microsserviço).
🔗 Leia Mais: documentando erros de API no Swagger ou GraphQL

 2.6 Finalize o processo quando um estranho chegar
TL;DR: Quando ocorre um erro desconhecido (um erro de programação, veja a melhor prática #3) - há incerteza sobre a integridade da aplicação. Uma prática comum sugere reiniciar cuidadosamente o processo utilizando uma ferramenta de “reinicialização” como Forever e PM2.
Caso contrário: Quando uma exceção desconhecida é lançada, algum objeto pode estar com defeito (por exemplo, um emissor de evento que é usado globalmente e não dispara mais eventos devido a alguma falha interna) e todas as requisições futuras podem falhar ou se comportar loucamente.
🔗 Leia Mais: finalizando o processo

 2.7 Use um agente de log maduro para aumentar a visibilidade de erros
TL;DR: Um conjunto de ferramentas de registro maduras como Pino, Winston, Bunyan ou Log4js, irão acelerar a descoberta e entendimento de erros. Portanto, esqueça o console.log.
Caso contrário: Ficar procurando através de console.logs ou manualmente em arquivos de texto confusos sem utilizar ferramentas de consulta ou um visualizador de log decente, pode mantê-lo ocupado até tarde.
🔗 Leia Mais: usando um logger maduro

 2.8 Fluxos de testes de erros usando seu framework favorito
TL;DR: Se o analista de QA ou o desenvolvedor de testes - Certifique-se de que seu código não atenda apenas o cenário positivo, mas também trate e retorne os erros corretos. Frameworks de teste como Mocha e Chai podem lidar com isso facilmente (veja exemplos de códigos no “Gist popup”)
Caso contrário: Sem testes, seja automático ou manual, não podemos confiar em nosso código para retornar os erros certos. Sem erros significantes, não há tratamento de erros.
🔗 Leia Mais: fluxos de testes de erros

 2.9 Descubra erros e downtime usando APM
TL;DR: Produtos de monitoramento e desempenho (também conhecido como APM), avaliam sua base de código ou API de forma proativa, para que possam destacar automaticamente erros, falhas e lentidões não percebidos.
Caso contrário: Você pode gastar muito esforço medindo o desempenho e os tempos de inatividade (downtime) da API. Provavelmente, você nunca saberá quais são suas partes de código mais lentas no cenário real e como elas afetam o UX.
🔗 Leia Mais: usando APM

 2.10 Capture rejeições de promises não tratadas
TL;DR: Qualquer exceção lançada dentro de uma promise será descartada, a menos que o desenvolvedor não se esqueça de tratá-la explicitamente. Mesmo que seu código esteja inscrito no process.uncaughtException! Supere isso, registrando no evento process.unhandledRejection.
Caso contrário: Seus erros serão engolidos e não vão deixar rastros. Nada para se preocupar.
🔗 Leia Mais: capturando rejeições de promises não tratadas

 2.11 Falhe rápido, valide argumentos usando uma biblioteca dedicada
TL;DR: Isto deveria fazer parte das melhores práticas de Express - Confirme a entrada da API para evitar erros desagradáveis ​​que são muito mais difíceis de acompanhar mais tarde. A validação de código geralmente é entediante ao menos que você esteja utilizando uma biblioteca de ajuda bem legal, como a Joi.
Caso contrário: Considere isto: sua função espera receber um “Desconto” como argumento numérico que foi esquecido de passar. Mais adiante, seu código verifica se Desconto!=0 (valor do desconto permitido é maior que zero). Depois, irá permitir que o usuário desfrute de um desconto. Meu Deus, que baita bug. Entendeu?
🔗 Leia Mais: falhando rápido

 2.12 Sempre use 'await' antes de retornar as 'promises' para evitar um rastreamento parcial da pilha de erro
TL;DR: Sempre use return await quando retornar uma 'promise' para beneficiar o rastreamento completo da pilha de erro. Se um função retorna uma 'promise', essa função deve ser declarada como função async e  explicitamente await na promise antes de devolvê-la
Caso contrário: Uma função que retorna uma promise sem o await não aparecerá na pilha de erro.
A ausência dessas informações provavelmente complicariam a compreensão do fluxo que leva ao erro,
especialmente se a causa do comportamento anormal estiver dentro da função ausente
🔗 Leia Mais: retornando promises

⬆ Voltar ao topo
3. Práticas de Estilo de Código
 3.1 Use ESLint
TL;DR: O ESLint é de fato o padrão para verificar possíveis erros e consertar o estilo de código, não apenas para identificar problemas básicos de espaçamento, mas também para detectar antipadrões de código, como desenvolvedores lançando erros sem classificação. Embora o ESLint possa corrigir automaticamente estilos de código, outra ferramentas como o prettier e o beautify são mais poderosos no quesito correção de formatação e trabalham em conjunto com o ESLint.
Caso contrário: Desenvolvedores irão focar nas preocupações tediosas de espaçamento e largura de linha e o tempo poderá ser desperdiçado pensando sobre o estilo de código do projeto.
🔗 Leia Mais: Usando ESLint e Prettier

 3.2 Plugins Específicos do Node.js
TL;DR: Além das regras padrões do ESLint que cobrem somente o Vanilla JS, adicione plug-ins específicos do Node, como o eslint-plugin-node, o eslint-plugin-mocha e o eslint-plugin-node-security
Caso contrário: Muitos padrões de código do Node.js com falha podem escapar do radar. Por exemplo, desenvolvedores podem chamar arquivos fazendo o require(variavelComoCaminho) com uma determinada variável como caminho, o que permite que invasores executem qualquer script JS. Os linters do Node.js podem detectar tais padrões e reclamar cedo.

 3.3 Comece um Bloco de Código com Chaves na Mesma Linha
TL;DR: As chaves que abrem um bloco de código devem estar na mesma linha da instrução de abertura
Exemplo de Código
// Do
function someFunction() {
  // code block
}

// Avoid
function someFunction()
{
  // code block
}
Caso contrário: Evitar esta recomendação pode levar a resultados inesperados, como visto nesta thread do StackOverflow:
🔗 Leia Mais: "Por que os resultados variam com base no posicionamento da chave?" (Stackoverflow)

 3.4 Separe suas declarações corretamente
Não importa se você usa ponto-e-vírgula ou não para separar suas declarações, conhecer as armadilhas comuns de quebras de linha impróprias ou inserção automática de ponto e vírgula, irá ajudá-lo a eliminar erros regulares de sintaxe.
TL;DR: Use o ESLint para obter conhecimento sobre as preocupações de separação. Prettier ou Standardjs podem resolver automaticamente esses problemas.
Caso contrário: Como visto na seção anterior, o interpretador do JavaScript adiciona automaticamente um ponto-e-vírgula ao final de uma instrução, se não houver uma, ou considera uma instrução como não terminada onde deveria, o que pode levar a alguns resultados indesejáveis. Você pode usar atribuições e evitar o uso de expressões de função chamadas imediatas para evitar a maioria dos erros inesperados.
Exemplo de código
// Faça
function doThing() {
    // ...
}

doThing()

// Faça

const items = [1, 2, 3]
items.forEach(console.log)

// Evitar - lança exceção
const m = new Map()
const a = [1,2,3]
[...m.values()].forEach(console.log)
> [...m.values()].forEach(console.log)
>  ^^^
> SyntaxError: Unexpected token ...

// Evitar - lança exceção
const count = 2 // tenta executar 2(), mas 2 não é uma função
(function doSomething() {
  // Faça algo incrível
}())
// Coloque um ponto-e-vírgula antes da função invocada imediatamente, após a definição const, salve o valor de retorno da função anônima para uma variável ou evite IIFEs no conjunto
🔗 Leia mais: "Regra Semi ESLint"
🔗 Leia mais: "Nenhuma regra ESLint de múltiplas linhas inesperada"

 3.5 Nomeie Suas Funções
TL;DR: Nomeie todas as funções, incluindo closures e callbacks. Evite funções anônimas. Isso é especialmente útil em uma aplicação node. Nomear todas a funções permitirá que você entenda facilmente o que está olhando quando verificar um snapshot da memória.
Caso contrário: A depuração de problemas de produção usando um dump principal (snapshot da memória) pode se tornar um desafio quando você percebe um consumo significativo de memória de funções anônimas.

 3.6 Convenções de nomenclatura para variáveis, constantes, funções e classes
TL;DR: Utilize lowerCamelCase quando nomeando constantes, variáveis e funções, e UpperCamelCase (primeira letra maiúscula também) quando nomeando classes. Isso irá lhe ajudar a distinguir facilmente entre variáveis/funções, e classes que necessitam de instanciação. Use nomes descritivos, mas tente mantê-los curtos.
Caso contrário: O JavaScript é a única linguagem no mundo que permite invocar um construtor (“Class”) diretamente sem instanciá-lo primeiro. Consequentemente, Classes e construtores de funções são diferenciados começando com UpperCamelCase
3.6 Exemplo de Código
// para classes nós usamos UpperCamelCase
class SomeClassExample {}

// para nomes de constantes nós usamos a palavra const e lowerCamelCase
const config = {
  key: "value",
};

// para nomes de variáveis e funções nós usamos lowerCamelCase
let someVariableExample = "value";
function doSomething() {}

 3.7 Prefira const do que let. Esqueça do var
TL;DR: Usar const significa que uma vez que a variável foi atribuída, ela não pode ser reatribuída. Preferir const irá te ajudar a não cair na tentação de utilizar a mesma variável para diferentes usos, e irá deixar seu código mais limpo. Se uma variável precisa ser reatribuída, em um for loop, por exemplo, use let para declarar. Outro aspecto importante do let é que esta variável só estará disponível no escopo de código em que ela foi definida. var tem escopo de função, não de bloco, e não deveria ser utilizada em ES6
, agora que você tem const e let ao seu dispor.
Caso contrário: A depuração se torna muito mais complicada ao seguir uma variável que frequentemente muda
🔗 Leia Mais: JavaScript ES6+: var, let ou const? 

 3.8 Requires vem primeiro e não dentro de funções
TL;DR: Faça o require de módulos no início de cada arquivo, antes e fora de qualquer função. Esta simples prática irá te ajudar não apenas a reconhecer as dependências de um determinado arquivo com facilidade e rapidez, como também evitará alguns possíveis problemas.
Caso contrário: Os requires rodam de forma síncrona pelo Node.js. Se eles forem chamados de dentro de uma função, isso pode impedir que outras solicitações sejam tratadas em um momento mais crítico. Além disso, se um módulo necessário ou qualquer uma de suas dependências lançar um erro e travar o servidor, é melhor descobrir isso o mais rápido possível, o que pode não ser o caso se este módulo tiver sido declarado dentro de uma função.

 3.9 Faça Require nas pastas, não diretamente nos arquivos
TL;DR: Ao desenvolver um módulo/biblioteca em uma pasta, coloque um arquivo index.js que exponha os componentes internos do módulo para que cada consumidor passe por ele. Isso serve como uma 'interface' para seu módulo e facilita futuras mudanças sem causar perdas.
Caso contrário: Alterar a estrutura interna dos arquivos ou a assinatura pode quebrar a interface com clientes.
3.9 Exemplo de Código
// Do
module.exports.SMSProvider = require("./SMSProvider");
module.exports.SMSNumberResolver = require("./SMSNumberResolver");

// Avoid
module.exports.SMSProvider = require("./SMSProvider/SMSProvider.js");
module.exports.SMSNumberResolver = require("./SMSNumberResolver/SMSNumberResolver.js");

 3.10 Use 0 operador ===
TL;DR: Dê preferência em usar o operador de comparação estrita === ao invés do operador de comparação abstrata ==, que é mais fraco. == irá comparar duas variáveis depois de convertê-las para o mesmo tipo. Não há conversão de tipo no === e ambas as variáveis devem ser do mesmo tipo para serem iguais.
Caso contrário: Variáveis diferentes podem retornar verdadeiro quando comparadas usando o operador ==.
3.10 Exemplo de Código
"" == "0"; // false
0 == ""; // true
0 == "0"; // true

false == "false"; // false
false == "0"; // true

false == undefined; // false
false == null; // false
null == undefined; // true

" \t\r\n " == 0; // true
Todas as declarações acima false se feitas com ===.

 3.11 Use Async Await, evite callbacks
TL;DR: Agora o Node 8 LTS possui suporte completo para Async-await. Esta é uma nova maneira de lidar com códigos assíncronos que substitui callbacks e promises. Async-await é não-bloqueante, e isso faz com que os códigos assíncronos pareçam síncronos. O melhor presente que você pode dar ao seu código é usar async-await, que fornece uma sintaxe de código muito mais compacta e familiar como o try-catch.
Caso contrário: Lidar com erros assíncronos no estilo de callback é provavelmente o caminho mais rápido para o inferno - esse estilo força verificar todos os erros, lidar com desajeitados aninhamentos de código e torna difícil raciocinar sobre o fluxo de código.
🔗Leia mais: Guia do async await 1.0

 3.12 Use Fat (=>) Arrow Functions
TL;DR: Embora seja recomendado usar async-await e evitar parâmetros de função ao lidar com APIs antigas, que aceitam promises ou callbacks - arrow functions tornam a estrutura do código mais compacta e mantém o contexto léxico da função raiz (por exemplo, 'this').
Caso contrário: Códigos mais longos (em funções ES5) são mais propensos a erros e são mais difíceis de ler.
🔗 Leia mais: Arrow Functions - é hora de abraçar a causa

⬆ Voltar ao topo
4. Práticas de Testes e Qualidade Geral
 4.1 No mínimo, escreva testes de API (componente)
TL;DR: A maioria dos projetos simplesmente não possuem testes automatizados devido a falta de tempo ou geralmente o 'testing project' fica fora de controle e acaba sendo abandonado. Por esse motivo, priorize e comece com o teste de API, que é o mais fácil de escrever e proporciona mais cobertura do que os testes unitários (você pode inclusive criar testes de API sem código usando ferramentas como Postman). Depois, se você tiver mais recursos e tempo, continue com testes avançados, como testes unitários, testes de banco de dados, testes de desempenho, etc.
Caso contrário: Voce pode passar longos dias escrevendo testes unitários para perceber que possui apenas 20% de cobertura de sistema.

 4.2 Inclua 3 partes em cada nome de teste
TL;DR: Faça o teste falar no nível de requisitos, de modo que seja autoexplicativo para engenheiros de garantia de qualidade e desenvolvedores que não estão familiarizados com o código. Indicar no nome do teste o que está sendo testado (unidade em teste), em que circunstâncias e qual é o resultado esperado.
Caso contrário: Uma implantação falhou, um teste chamado "Adicionar produto" falhou. Isso lhe diz exatamente o que está errado?
🔗 Leia Mais: Inclua 3 partes em cada nome de teste

 4.3 Estutura de testes padrão AAA
TL;DR: Estruture seus testes com 3 seções bem separadas: Arrange, Act & Assert (AAA). A primeira parte inclui a configuração do teste, depois a execução do teste unitário, e finalmente, a fase de asserção. Seguir esta estrutura garante que o leitor não gaste nenhuma CPU cerebral para entender o plano de teste
Caso contrário: Você não somente passará várias horas do dia para entender o código principal, mas agora também gastará várias horas no que deveria ter sido uma simples parte do dia (testando) esticando seu cérebro.
🔗 Leia Mais: Estutura de testes padrão AAA

 4.4 Detecte problemas de código com um linter
TL;DR: Use um code linter para checar a qualidade básica e detectar antipadrões antecipadamente. Rode-o antes de qualquer teste e adicione-o como um pre-commit git-hook para minimizar o tempo necessário para revisar e corrigir qualquer problema. Veja também Seção 3 no Prática de Estilo de Código.
Caso contrário: Você pode deixar passar algum antipadrão e possível código vulnerável para seu ambiente de produção.

 4.5 Evite dados fixos e sementes para teste, adicione os dados no teste
TL;DR: Para evitar o acoplamento de testes e facilitar o entendimento do fluxo do teste, cada teste deve adicionar e atuar em seu próprio conjunto de linhas de banco de dados. Sempre que um teste precisar extrair ou assumir a existência de alguns dados do banco de dados - ele deve incluir explicitamente esses dados e evitar a mutação de outros registros
Caso contrário: Considere um cenário em que a implementação é abortada devido a falhas nos testes. Agora, a equipe gastará um tempo precioso de investigação que termina em uma triste conclusão: o sistema funciona bem, mas os testes interferem uns nos outros e quebram a compilação
🔗 Leia Mais: Evite dados fixos para teste

 4.6 Inspencione constantemente por dependências vulneráveis
TL;DR: Até mesmo as dependências mais confiáveis, como o Express, têm vulnerabilidades conhecidas. Isso pode ser facilmente contornado usando ferramentas comunitárias e comerciais como 🔗 nsp que pode ser invocado a partir do seu CI em cada build.
Caso contrário: Manter seu código livre de vulnerabilidades sem ferramentas dedicadas exigirá o acompanhamento constante de publicações online sobre novas ameaças. Saia do tédio.

 4.7 Marque seus testes
TL;DR: Diferentes testes devem rodar em diferentes cenários: testes de rápidos, sem IO, devem ser executados quando um desenvolvedor salva ou faz commit em um arquivo, testes completos de ponta a ponta geralmente são executados quando uma nova solicitação de request é enviada, etc. Isso pode ser conseguido através da marcação de testes com palavras-chave como #cold #api #sanity. Assim você pode invocar o subconjunto desejado. Por exemplo, é desta forma que você invocaria apenas o grupo de sanity test usando o Mocha: mocha --grep 'sanity'
Caso contrário: Rodar todos os testes, incluindo aqueles que executam dezenas de consultas de banco de dados, sempre que o desenvolvedor fizer uma pequena alteração pode ser extremamente lento e impedir que desenvolvedores executem testes.

 4.8 Verifique a cobertura de seu teste, isso te ajuda a identificar padrões incorretos de teste
TL;DR: Ferramentas de cobertura de código como Istanbul/NYC, são ótimas por 3 motivos: elas são gratuitas (nenhum esforço é necessário para beneficiar esses relatórios), elas ajuda a identificar diminuição na cobertura de testes, e por último mas não menos importante, ela destacam a incompatibilidade de testes: olhando relatórios coloridos de cobertura de código, você pode notar, por exemplo, áreas de código que nunca são testadas como cláusulas catch (o que significa que os testes só invocam os caminhos felizes e não como o aplicativo se comporta em erros). Configure-o para falhas se a cobertura estiver abaixo de um certo limite.
Caso contrário: Não haverá nenhuma métrica automática informando quando uma grande parte de seu código não é coberta pelo teste.

 4.9 Inspecione pacotes desatualizados
TL;DR: Use sua ferramenta preferida (por exemplo, 'npm outdated' ou npm-check-updates para detectar pacotes instalados que estão desatualizados, injetar essa verificação em seu pipeline de CI e até mesmo fazer uma falha grave em um cenário grave. Por exemplo, um cenário grave pode ser quando um pacote instalado esteja há 5 commits atrás (por exemplo, a versão local é 1.3.1 e a versão no repositório é 1.3.8) ou está marcada como descontinuada pelo autor - mate o build e impeça a implantação desta versão.
Caso contrário: Sua produção executará pacotes que foram explicitamente marcados pelo autor como arriscados.

 4.10 Use docker-compose para testes e2e
TL;DR: Teste de ponta a ponta (end to end, ou e2e), que inclui dados ativos, costumava ser o elo mais fraco do processo de CI, já que depende de vários serviços pesados como o banco de dados. O docker-compose deixa isso mamão com açúcar, criando um ambiente de produção usando um arquivo de texto simples e comandos fáceis. Isto permite criar todos os serviços dependentes, banco de dados e rede isolada para teste e2e. Por último mas não menos importante, ele pode manter um ambiente sem estado que é invocado antes de cada suíte de testes e é encerrado logo após.
Caso contrário: Sem o docker-compose, as equipes devem manter um banco de dados de teste para cada ambiente de teste, incluindo as máquinas dos desenvolvedores, e manter todos esses bancos de dados sincronizados para que os resultados dos testes não variem entre os ambientes.

 4.11 Refatore regularmente usando ferramentas de análise estática
TL;DR: O uso de ferramentas de análise estática ajuda fornecendo maneiras objetivas de melhorar a qualidade do código e manter seu código sustentável. Você pode adicionar ferramentas de análise estática para seu build de Integração Contínua (CI) falhar quando encontre code smells. Seus principais pontos de vantagem sobre o linting são a abilidade de inspecionar a qualidade no contexto de múltiplos arquivos (por exemplo, detectar duplicidades), realizar análises avançadas (por exemplo, complexidade de código), e acompanhar histórico e progresso de problemas de código. Dois dexemplos de ferramentas que podem ser utilizadas são Sonarqube (mais de 2.600 stars) e Code Climate (mais de 1.500 stars).
Caso contrário: Com qualidade de código ruim, bugs e desempenho sempre serão um problema que nenhuma nova biblioteca maravilhosa ou recursos de última geração podem corrigir.
🔗 Leia Mais: Refatoração!

 4.12 Escolha cuidadosamente sua plataforma de Integração Contínua - CI (Jenkins vs CircleCI vs Travis vs Resto do mundo)
TL;DR: Sua plataforma de integração contínua (CICD) irá hospedar todas as ferramentas de qualidade (por exemplo, teste, lint), então ela deve vir com um ecosistema de plugins arrebatador. O Jenkins costumava ser o padrão de muitos projetos, pois tem a maior comunidade, juntamente com uma poderosa plataforma, ao preço de configuração complexa que exige uma curva de aprendizado íngreme. Atualmente, ficou bem mais fácil para configurar uma solução de CI usando ferramentas SaaS como CircleCI e outras. Essas ferramentas permitem a criação de um pipeline de CI flexível sem o peso de gerenciar toda a infraestrutura. Eventualmente, é um perde e ganha entre robustez e velocidade - escolha seu lado com cuidado!
Caso contrário: Escolher algum fornecedor de nicho pode fazer com que você fique engessado quando precisar de alguma personalização avançada. Por outro lado, escolher o Jenkins pode ser uma perda de tempo precioso na configuração da infraestrutura.
🔗 Leia Mais: Escolhendo a plataforma de CI

 4.13 Teste seus 'middlewares' isoladamente
TL;DR: quando um 'middleware' contém alguma lógica imensa que abrange muitas solicitações, vale a pena testá-lo isoladamente, sem ativar todo o framework. Isso pode ser facilmente alcançado por 'stubbing' e espionando os objetos {req, res, next}
Caso contrário: Um bug no 'middleware Express' === um bug em todas ou na maioria das solicitações
🔗 Read More: Test middlewares in isolation

⬆ Voltar ao topo
5. Boas Práticas de Produção
 5.1. Monitoramento
TL;DR: O monitoramento é um jogo de descobrir problemas antes que os clientes os encontrem - obviamente deve ser atribuída muita importância para isto. O mercado está sobrecarregado de ofertas, portanto, considere começar com a definição das métricas básicas que você deve seguir (sugestões minhas dentro), depois passe por recursos extras e escolha a solução que marca todas as caixas. Acesse o ‘Gist’ abaixo para uma visão geral das soluções.
Caso contrário: Falha === clientes desapontados. Simples
🔗 Leia Mais: Monitoramento!

 5.2. Aumente a transparência usando smart logging
TL;DR: Logs podem ser um armazém inútil de instruções de debug ou o ativador de um belo dashboard que conta a história do seu app. Planeje sua plataforma de logs desde o primeiro dia: como os logs são coletados, armazenados e analisados para ter certeza de que as informações desejadas possam realmente ser extraídas, por exemplo, a avaliação de erro, após uma transação inteira através de serviços e servidores, etc.
Caso contrário: Você acaba com uma caixa preta que é difícil de raciocinar, então você começa a reescrever todas as declarações de log para adicionar informações adicionais.
🔗 Leia Mais: Aumente a transparência usando smart logging

 5.3. Delegue tudo o que for possível (por exemplo, gzip, SSL) a um proxy reverso
TL;DR: O Node é terrivelmente ruim em fazer tarefas intensas de CPU como gzipping, SSL termination, etc. Você deve usar serviços de middleware “reais” como nginx, HAproxy ou serviços de nuvem.
Caso contrário: Seu único e pobre thread permanecerá ocupado fazendo tarefas de infra-estrutura em vez de lidar com o núcleo da sua aplicação e o desempenho certamente será degradado.
🔗 Leia Mais: Delegue tudo o que for possível (por exemplo, gzip, SSL) a um proxy reverso

 5.4. Bloqueio de dependências
TL;DR: Seu código deve ser idêntico em todos os ambientes, mas, surpreendentemente, o npm permite que as dependências derivem entre os ambientes por padrão - quando você instala pacotes em vários ambientes, ele tenta buscar a versão mais recente dos pacotes. Supere isso usando arquivos de configuração do npm, .npmrc, que dirão a cada ambiente para salvar a versão exata (não a última) de cada pacote. Outra alternativa, para um controle melhor, use o “shirinkwrap” do npm. *Atualização: a partir do NPM5, as dependências são bloqueadas por padrão. O novo gerenciador de pacotes no pedaço, Yarn, também faz isso por padrão.
Caso contrário: O QA testará completamente o código e aprovará uma versão que se comportará de maneira diferente na produção. Pior ainda, servidores diferentes no mesmo cluster de produção podem executar código diferente.
🔗 Leia Mais: Bloqueio de dependências

 5.5. Poupe tempo de atividade do processo usando a ferramenta certa
TL;DR: O processo deve continuar e ser reiniciado após falhas. Para cenários simples, as ferramentas de "reinicialização", como PM2, podem ser suficientes. Entretanto, no mundo atual "dockerizado", as ferramentas de gerenciamento de cluster também devem ser consideradas
Caso contrário: Rodar dezenas de instâncias sem uma estratégia clara e muitas ferramentas juntas (gerenciamento de cluster, docker, PM2) pode levar o DevOps ao caos.
🔗 Leia Mais: Poupe tempo de atividade do processo usando a ferramenta certa

 5.6. Utilize todos os núcleos do processador
TL;DR: Em sua forma básica, uma aplicação Node roda em um único núcleo do processador enquanto todos os demais ficam inativos. É seu dever replicar o processamento do Node e utilizar todos os processadores. Para aplicações pequenas/médias você pode usar o Node Cluster ou PM2. Para uma aplicação maior, considere replicar o processo usando algum cluster do Docker (por exemplo, o K8S ou o ECS) ou scripts de deploy que são baseados no sistema de inicialização do Linux (por exemplo, systemd)
Caso contrário: Sua aplicação vai utilizar apenas 25% dos recursos disponíveis(!) ou talvez até menos. Note que um servidor típico possui 4 núcleos de processamento ou mais, o deploy ingênuo do Node.js utiliza apenas 1 (mesmo usando serviços de PaaS como AWS Beanstalk!)
🔗 Leia Mais: Utilize todos os núcleos do processador

 5.7. Crie um ‘endpoint de manutenção’
TL;DR: Exponha um conjunto de informações relacionadas ao sistema, como uso de memória e REPL, etc, em uma API segura. Embora seja altamente recomendado confiar em ferramentas padrões e de battle-tests, algumas informações e operações valiosas são mais fáceis de serem feitas usando código.
Caso contrário: Você perceberá que está realizando muitos “deploys de diagnóstico” - enviando código para produção apenas para extrair algumas informações para fins de diagnóstico.
🔗 Leia Mais: Crie um ‘endpoint de manutenção’

 5.8. Descubra erros e tempo de inatividade usando produtos APM
TL;DR: Produtos de monitoramento e desempenho (também conhecidos como APM) medem a base de código e a API de forma proativa para que possam ir “automagicamente” além do monitoramento tradicional e medir a experiência geral do usuário entre os serviços e camadas. Por exemplo, alguns APMs podem destacar uma transação que é carregada muito lentamente no lado do usuário final, sugerindo a causa raiz.
Caso contrário: Você pode gastar muito esforço medindo o desempenho e os tempos de inatividade da API, provavelmente você nunca saberá quais são suas partes de código mais lentas no cenário do mundo real e como elas afetam o UX.
🔗 Leia Mais: Descubra erros e tempo de inatividade usando produtos APM

 5.9. Deixe seu código pronto para produção
TL;DR: Programe com o fim em mente, planeje para produção desde o primeiro dia. Isso pode parecer vago, então eu compilei algumas dicas de desenvolvimento que estão relacionadas à manutenção de produção (clique no Gist abaixo).
Caso contrário: Uma pessoa fera em TI/DevOps não salvará um sistema mal escrito.
🔗 Leia Mais: Deixe seu código pronto para produção

 5.10. Meça e proteja o uso de memória
TL;DR: O Node.js tem uma relação controversa com o uso de memória: o motor v8 possui limites no uso de memória (1.4GB) e existem caminhos conhecidos para vazamentos de memória no código do Node - portanto, observar a memória do processo do Node é uma obrigação. Em aplicações pequenas, você pode medir a memória periodicamente usando comandos shell, mas em aplicação média-grande considere utilizar um sistema de monitoramento de memória robusto.
Caso contrário: A memória de seus processos pode vazar cem megabytes por dia, assim como aconteceu no Walmart.
🔗 Leia Mais: Meça e proteja o uso de memória

 5.11. Deixe seus recursos de frontend fora do Node
TL;DR: Sirva conteúdo de frontend usando um middleware dedicado (nginx, S3, CDN) pois o desempenho do Node fica realmente prejudicado quando se lida com muitos arquivos estáticos devido ao seu modelo single threaded (segmento único).
Caso contrário: Seu único thread do Node ficará ocupado fazendo streaming the centenas de arquivos de html/imagens/angular/react ao invés de alocar todo seu recurso para a tarefa que ele foi designado - servir conteúdo dinâmico.
🔗 Leia Mais: Deixe seus recursos de frontend fora do Node

 5.12. Seja stateless, mate seus Servidores quase todos os dias
TL;DR: Armazene qualquer tipo de dados (por exemplo, sessões de usuário, cache, arquivos de upload) em armazenamentos externos. Considere ‘matar’ seus servidores periódicamente ou utilize plataformas ‘serverless’ (por exemplo, AWS Lambda) que forçam explicitamente um comportamento stateless.
Caso contrário: Falha em um determinado servidor resultará em tempo de inatividade da aplicação, em vez de apenas matar uma máquina defeituosa. Além do mais, dimensionar a elasticidade será mais desafiador devido à dependência de um servidor específico.
🔗 Leia Mais: Seja stateless, mate seus Servidores quase todos os dias

 5.13. Utilize ferramentas que detectam vulnerabilidades automaticamente
TL;DR: Mesmo as dependências mais confiáveis, como o Express, têm vulnerabilidades conhecidas (de tempos em tempos) que podem colocar um sistema em risco. Isso pode ser contornado usando ferramentas comunitárias e comerciais que constantemente verificam vulnerabilidades e avisam (localmente ou no Github). Algumas podem até corrigí-las imediatamente.
Caso contrário: Manter seu código limpo com vulnerabilidades sem ferramentas dedicadas exigirá o acompanhamento constante de publicações online sobre novas ameaças. Bem entendiante.
🔗 Leia Mais: Utilize ferramentas que detectam vulnerabilidades automaticamente

 5.14. Atribua‘TransactionId’ para cada declaração de log
TL;DR: Atribua o mesmo identificador, transaction-id: {some value}, para cada entrada de log dentro de um mesmo request. Depois, ao inspecionar erros em logs, conclua facilmente o que aconteceu antes e depois. Infelizmente, isso não é fácil de se conseguir no Node, devido à sua natureza assíncrona. Veja exemplos de código.
Caso contrário: Observar um log de erros de produção sem o contexto - o que aconteceu antes - torna muito mais difícil e mais lento raciocinar sobre o problema.
🔗 Leia Mais: Atribua ‘TransactionId’ para cada declaração de log

 5.15. Defina NODE_ENV=production
TL;DR: Defina a variável de ambiente NODE_ENV para ‘production’ ou ‘development’ para sinalizar se as otimizações de produção devem ser ativadas - muitos pacotes npm determinam o ambiente atual e otimizam seu código para produção.
Caso contrário: Omitir esta simples propriedade pode degradar muito o desempenho. Por exemplo, ao utilizar o Express para renderização do lado do servidor, omitir o NODE_ENV o torna mais lento!
🔗 Leia Mais: Defina NODE_ENV=production

 5.16. Projete deploys automáticos, atômicos e com tempo de inatividade zero
TL;DR: Pesquisas mostram que times que executam muitos deploys, reduzem a probabilidade de problemas graves em produção. Deploys rápidos e automatizados que não necessitam de processos manuais arriscados e significativo tempo de inatividade, melhoram o processo de deploy. Provavelmente, você irá alcançar isso usando Docker, combinado com ferramentas de CI, pois elas se tornaram o padrão do setor para deploy simplificado.
Caso contrário: Deploys demorados -> tempo de inatividade de produção e erro relacionado a humanos -> equipe não-confiante com os deploys -> menos implantações e recursos.

 5.17. Use uma versão LTS do Node.js
TL;DR: Certifique de que você está usando uma versão LTS do Node.js para receber correção de bugs críticos, atualizações de segurança e melhorias de performance.
Caso contrário: Bugs recentemente descobertos e vulnerabilidades podem ser usados para explorar uma aplicação em produção, e sua aplicação pode se tornar incompatível com vários módulos e mais difícil de manter.
🔗 Leia Mais: Use uma versão LTS do Node.js

 5.18. Não direcione logs dentro do aplicativo
TL;DR: O destino dos logs não devem ser codificados na unha por desenvolvedores, dentro do código da aplicação. Ao invés disso, deve ser definido pelo ambiente de execução no qual a aplicação é executada. Desenvolvedores devem escrever logs para stdout usando um utilitário logger e depois deixar o ambiente de execução (container, servidor, etc) canalizar o fluxo do stdout para o destino apropriado (por exemplo: Splunk, Graylog, ElasticSearch, etc).
Caso contrário: Aplicações manipulando o roteamento de log === difícil de dimensionar, perda de logs, separação ruim de preocupações.
🔗 Leia Mais: Roteamento de Logs

 5.19. Instale seus pacotes com npm ci
TL;DR: Você precisa ter certeza de que o código de produção usa a versão exata dos pacotes que você realizou os testes. Execute npm ci para fazer estritamente uma instalação limpa de suas dependências correspondentes do package.json e do package-lock.json. O uso desse comando é recomendado em ambientes automatizados, como pipelines de integração contínua.
Caso contrário: o QA testará completamente o código e aprovará uma versão que se comportará de maneira diferente em produção. Pior ainda, diferentes servidores no mesmo cluster de produção podem executar códigos diferentes.
🔗 Read More: Use npm ci

⬆ Voltar ao topo
6. Boas Práticas em Segurança



 6.1. Adote as regras de segurança do linter
 
TL;DR: Faça uso de plugins de linter relacionados à segurança, como por exemplo o eslint-plugin-security para capturar vulnerabilidades de segurança e erros o mais cedo possível, na melhor das hipóteses, enquanto estão sendo codificados. Isso pode ajudar a detectar pontos fracos de segurança, como usar o eval, invocar um processo filho ou importar um módulo com string literal (por exemplo, input do usuário). Clique em ‘Leia Mais’ abaixo para ver exemplos de códigos que serão capturados por um linter de segurança.
Caso contrário: O que poderia ser um ponto fraco de segurança durante o desenvolvimento, pode se tornar um grande problema no ambiente de produção. Além disso, o projeto pode não seguir práticas de segurança de código consistentes, levando a vulnerabilidades sendo introduzidas ou segredos confidenciais comprometidos em repositórios remotos.
🔗 Leia Mais: Regras de Lint

 6.2. Limite requests simultâneos usando um middleware

TL;DR: Ataques DOS são muito populares e relativamente fáceis de conduzir. Implemente uma limitação de taxa, usando um serviço externo como balanceadores de carga de nuvem, firewalls de nuvem, nginx, o pacote rate-limiter-flexible, ou (para aplicações menores e menos críticas) um middleware limitador de taxa (por exemplo, express-rate-limit)
Caso contrário: Uma aplicação pode estar sujeita a um ataque resultando em uma queda do serviço, onde usuários reais recebem um serviço degradado ou indisponível.
🔗 Leia Mais: Implementando limitador de taxa

 6.3 Extraia segredos dos config files ou use pacotes para criptografá-los
 
TL;DR: Nunca armazene segredos em textos simples em arquivos de configuração ou códigos fonte. Em vez disso, use sistemas de gerenciamento secreto como produtos Vault, Kubernetes/Docker Secrets, ou use variáveis de ambiente. Como resultado final, os segredos armazenados no código fonte devem ser criptografados e gerenciados(rolling keys, expiring, auditing, etc). Faça uso de hooks de pre-commit/push para evitar que faça o commit de secredos acidentalmente.
Caso contrário: O controle de origem, mesmo para repositórios privados, pode ser tornado público por engano, quando todos os segredos são expostos. O acesso ao controle de origem para uma parte externa fornecerá inadvertidamente acesso a sistemas relacionados (bancos de dados, APIs, serviços, etc.).
🔗 Leia Mais: Gerenciamento de segredos

 6.4. Impeça vulnerabilidades de query injection com bibliotecas ORM/ODM

TL;DR: Para evitar SQL/NoSQL injection e outros ataques maliciosos, sempre faça uso de um ORM/ODM ou de uma biblioteca de banco de dados que proteja os dados ou suporte consultas parametrizadas nomeadas ou indexadas, e que cuide da validação de entrada do usuário para os tipos esperados. Nunca use apenas template strings do JavaScript ou concatenação de string para injetar valores em queries, pois isto abre sua aplicação para muitas vulnerabilidades. Todas as bibliotecas respeitáveis de acesso a dados do Node.js (por exemplo, Sequelize, Knex, mongoose) possuem proteção contra ataques de injeção.
Caso contrário: A entrada de usuários não validados pode levar à injeção do operador ao trabalhar com MongoDB para NoSQL e não usar um sistema próprio ou ORM irão permitir facilmente um ataque de SQL injection, criando uma grande vulnerabilidade.
🔗 Leia Mais: Prevenção de query injection usando bibliotecas de ORM/ODM

 6.5. Coleção genérica de boas práticas de segurança
TL;DR: Esta é uma coleção de conselhos de segurança que não estão relacionadas diretamente com Node.js - a implementação do Node não é muito diferente comparado a outras linguagens. Clique em “leia mais” para dar uma olhada.
🔗 Leia Mais: Boas práticas comuns de segurança

 6.6. Ajuste os headers de resposta HTTP para uma segurança aprimorada

TL;DR: Sua aplicação deve estar utilizando headers seguros para evitar que invasores façam ataques comuns, como scripts entre sites (XSS), clickjacking, dentre outros ataques maliciosos. Eles podem ser configurados facilmente usando módulos como o helmet.
Caso contrário: Invasores podem realizar ataques diretos aos usuários de sua aplicação, levando a grandes vulnerabilidades de segurança.
🔗 Leia Mais: Usando headers seguros em sua aplicação

 6.7. Inspecione constante e automaticamente por dependências vulneráveis

TL;DR: Com o ecosistema do npm, é comum um projeto ter várias dependências. Dependências sempre devem ser checadas em caso de novas vulnerabilidades serem encontradas. Utilize ferramentas como npm audit ou snyk para rastrear, monitorar e corrigir dependências vulneráveis. Integre estas ferramentas com a configuração de seu CI, para que você possa capturar uma dependência vulnerável antes que ela afete o ambiente de produção.
Caso contrário: Um invasor pode detectar seu framework web e atacar todas suas vulnerabilidades.
🔗 Leia Mais: Segurança de dependências

 6.8. Evite usar a biblioteca de criptografia do Node.js para manipular senhas, use Bcrypt

TL;DR: Senhas ou segredos (chaves de API), devem ser armazenadas usando um hash seguro + salt function como bcrypt, que deve ser a escolha preferencial em relação à sua implementação de JavaScript, devido a razões de desempenho e segurança.
Caso contrário: Senhas ou segredos que são persistidos sem o uso de uma função segura, são vulneráveis a força bruta e ataques de dicionário que levarão eventualmente à sua divulgação.
🔗 Leia Mais: Use o Bcrypt

 6.9. Fuja de saídas HTML, JS e CSS

TL;DR: Dados não confiáveis que são enviados para o browser podem ser executados em invés de serem exibidos. Isso está sendo comumente referido como um ataque de script entre sites (XSS). Evite isto, usando bibliotecas dedicadas que marcam explicitamente os dados como conteúdo puro que nunca deve ser executado (por exemplo: encoding, escaping).
Caso contrário: Um invasor pode armazenar um código JavaScript malicioso em seu banco de dados, que será enviado para os clientes.
🔗 Leia Mais: Evite saídas

 6.10. Valide os esquemas de entrada JSON
 
TL;DR: Valide as requisições do body e garanta que elas atendem as expectativas e falhem rápido se não atender. Para evitar o tédio de códigos de validação para cada rota, você pode usar leves esquemas de validação baseados em JSON, como jsonschema ou joi
Caso contrário: Sua generosidade e abordagem permissiva aumentam muito a superfície de ataque e incentivam o invasor a experimentar muitas entradas até encontrar alguma combinação para travar a aplicação.
🔗 Leia Mais: Valide os esquemas de entrada JSON

 6.11. Ajude a inserir JWTs em listas negras

TL;DR: Ao usar JSON Web Tokens (por exemplo, com Passport.js), por padrão não existem mecanismos para revogar o acesso de tokens problemáticos. Uma vez descoberta alguma atividade maliciosa do usuário, não há como impedi-lo de acessar o sistema, desde que ele tenha um token válido. Abrande isso implementando uma lista negra de tokens não confiáveis que são validados em cada solicitação.
Caso contrário: Tokens expirados ou extraviados, podem ser usados maliciosamente por terceiros para acessar uma aplicação e para representar o proprietário do token.
🔗 Leia Mais: Blacklist de JSON Web Tokens

 6.12. Evite ataques de força bruta contra autorização

TL;DR: Uma técnica simples e poderosa é limitar as tentativas de autorização usando duas métricas:

A primeiro é o número de tentativas consecutivas com falha do mesmo ID/nome e endereço IP exclusivos do usuário.
A segundo é o número de tentativas malsucedidas de um endereço IP durante um longo período de tempo. Por exemplo, bloqueie um endereço IP se ele fizer 100 tentativas com falha em um dia.

Caso contrário: Um invasor pode emitir tentativas ilimitadas de senha automatizada para obter acesso a contas com privilégios em uma aplicação.
🔗 Leia Mais: Limitando a taxa de login

 6.13. Rode o Node.js como um usuário que não seja root

TL;DR: Existe um cenário comum em que o Node.js é executado como um usuário root com permissões ilimitadas. Por exemplo, esse é o comportamento padrão em contêineres do Docker. É recomendável criar um usuário não raiz e associá-lo à imagem do Docker (exemplos abaixo) ou executar o processo em nome desse usuário chamando o container com o sinalizador "-u username".
Caso contrário: Um invasor que consiga executar um script no servidor obtém poder ilimitado sobre a máquina local (por exemplo, alterar o iptable e redirecionar o tráfego para seu servidor).
🔗 Leia Mais: Rode o Node.js com um usuário não raiz

 6.14. Limite o tamanho do payload usando um proxy reverso ou um middleware
 
TL;DR: Quanto maior o payload do body, mais difícil será o processamento de um único segmento. Esta é uma oportunidade para os invasores colocarem seus servidores de joelhos sem uma enorme quantidade de solicitações (ataques DOS / DDOS). Reduza isso limitando o tamanho do corpo das solicitações recebidas (por exemplo, firewall, ELB) ou configurando o express body parser para aceitar somente cargas de tamanho pequeno.
Caso contrário: Sua aplicação terá que lidar com solicitações grandes, incapazes de processar o outro trabalho importante que ele precisa realizar, o que leva a implicações de desempenho e vulnerabilidade em relação a ataques DOS.
🔗 Leia Mais: Limite o tamanho dos payloads

 6.15. Evite instruções eval do JavaScript
  
TL;DR: eval é do mal, pois permite a execução de um código JavaScript personalizado durante o tempo de execução. Isso não é apenas uma preocupação de desempenho, mas também uma importante preocupação de segurança devido ao código JavaScript malicioso que pode ser originado da entrada do usuário. Outra feature da linguagem que deve ser evitada é o construtor new Function constructor. setTimeout e setInterval também não devem ser receber código JavaScript dinâmico.
Caso contrário: o código JavaScript malicioso encontra um caminho para um texto passado para o eval ou outras funções de avaliação em tempo real da linguagem JavaScript, e terá acesso total às permissões do JavaScript na página. Essa vulnerabilidade geralmente se manifesta como um ataque XSS.
🔗 Leia Mais: Evite instruções eval do JavaScript

 6.16. Evite que RegEx maliciosos sobrecarreguem sua execução de thread único

TL;DR: Regular Expressions, embora sejam úteis, representam uma ameaça real para aplicativos JavaScript em geral, e a plataforma Node.js em particular .Uma entrada do usuário para correspondência de texto pode exigir uma quantidade maior de ciclos de CPU para processar. O processamento RegEx pode ser ineficiente até um ponto em que uma única solicitação que valida 10 palavras pode bloquear todo o loop de eventos por 6 segundos e botar 🔥 na CPU. Por essa razão, prefira pacotes de validação de terceiros como validator.js ao invés de escrever seus próprios pardrões de Regex, ou faça uso do safe-regex para detectar padrões vulneráveis de regex.
Caso contrário: Expressões regulares mal escritas podem ser suscetíveis a ataques de Regular Expresssion DoS, que irão bloquear completamente o loop de eventos. Por exemplo, o popular pacote moment foi encontrado com vulnerabilidades de uso de RegEx maliciosos em novembro de 2017.
🔗 Leia Mais: Evite RegEx maliciosos

 6.17. Evite o carregamento de módulos usando uma variável
  
TL;DR: Evite fazer require ou importar outro arquivo com um caminho que tenha sido fornecido como parâmetro devido à preocupação de que ele possa ter se originado da entrada do usuário. Esta regra pode ser estendida para acessar arquivos em geral (ou seja, fs.readFile()) ou outro acesso a recursos confidenciais com variáveis dinâmicas provenientes da entrada do usuário. O linter Eslint-plugin-security pode pegar esses padrões e avisar o quanto antes.
Caso contrário: A entrada de usuário mal-intencionada pode encontrar o caminho para um parâmetro usado para require de arquivos adulterados, por exemplo, um arquivo carregado anteriormente no sistema de arquivos ou para acessar arquivos de sistema já existentes.
🔗 Leia Mais: Carregamento seguro de módulos

 6.18. Rode códigos não seguros em uma sandbox
  
TL;DR: Quando a tarefa for executar código externo que é fornecido em tempo de execução (por exemplo, plug-in), use qualquer tipo de ambiente de execução 'sandbox' que isole e proteja o código principal em relação ao plug-in. Isso pode ser feito usando um processo dedicado (por exemplo, cluster.fork ()), ambiente serverless ou pacotes npm dedicados que atuam como uma sandbox.
Caso contrário: Um plugin pode atacar através de uma infinita variedade de opções, como loops infinitos, sobrecarga de memória e acesso a variáveis sensíveis do ambiente de processo.
🔗 Leia Mais: Rode códigos não seguros em uma sandbox

 6.19. Tome cuidado extra ao trabalhar com processos filhos
  
TL;DR: Evite usar processos filhos quando possível e valide e limpe a entrada para mitigar os ataques de shell injection se ainda precisar. Prefira usar child_process.execFile que, por definição, só executará um único comando com um conjunto de atributos e não permitirá a expansão de parâmetros do shell.
Caso contrário: O uso ingênuo de processos filhos pode resultar na execução de comandos remotos ou em ataques de shell injection, devido à entrada do usuário mal-intencionado passada para um comando do sistema não-autorizado.
🔗 Leia Mais: Tenha cautela ao trabalhar com processos filhos

 6.20. Oculte detalhes de erros dos usuários

TL;DR: Um manipulador de erros integrado do express oculta os detalhes de erros por padrão. Entretanto, são grandes as chances de você implementar sua própria lógica para manipular erros com objetos de erro customizados (considerado por muitos, a melhor prática). Se você faz isso, tenha certeza de que não está retornando o objeto Error inteiro para o cliente, pois ele pode conter detalhes confidenciais da aplicação.
Caso contrário: Detalhes confidenciais da aplicação como caminhos e arquivos do servidor, módulos de terceiros em uso e outros workflows internos da aplicação poderiam ser explorados e expostos por um invasor.
🔗 Leia Mais: Oculte detalhes de erros dos usuários

 6.21. Configure 2FA para o npm ou Yarn

TL;DR: Qualquer passo na cadeia de desenvolvimento deve ser protegido com o MFA (multi-factor authentication, ou autenticação em várias etapas), e o npm / Yarn é uma boa oportunidade para os invasores poderem colocar as mãos na senha de algum desenvolvedor. Usando as credenciais de desenvolvedor, os invasores podem injetar código malicioso em bibliotecas que são amplamente instaladas em projetos e serviços. Talvez, até mesmo por toda a rede de internet, se publicado abertamente. Ativando a 2-factor-authentication (autenticação em duas etapas) no npm, reduz a quase zero as chances de invasores alterarem seu código.
Caso contrário: Você já ouviu falar sobre o desenvolvedor do eslint cuja senha foi hackeada?

 6.22. Modifique as configurações do middleware de sessão

TL;DR: Cada framework e tecnologia web tem seus pontos fracos conhecidos - dizer aos invasores qual framework utilizamos é uma grande ajuda para eles. Usar as configurações padrões para middlewares de sessão pode expor sua aplicação - e ataques específicos ao framework, semelhantes ao heade X-Powered-By header. Tente ocultar qualquer coisa que possa identificar ou revelar sua stack (por exemplo, Node.js, express).
Caso contrário: Cookies podem ser enviados através de conexões não seguras, e um hacker pode usar a sessão do usuário para identificar o framework utilizado na aplicação, bem como vulnerabilidades específicas do módulo.
🔗 Leia Mais: Segurança de cookies e sessões

 6.23. Evite ataques do DOS definindo explicitamente quando um processo deve falhar

TL;DR: O processo do Node irá falhar quando os erros não forem tratados. Muitas boas práticas recomendam sair, mesmo que um erro tenha sido detectado e resolvido. O Express, por exemplo, irá falhar em qualquer erro assíncrono - a menos que você envolva rotas com uma cláusula catch. Isso abre um ponto de ataque muito fácil para os hackers que reconhecem qual entrada faz o processo falhar e enviam repetidamente o mesmo request. Não existe solução instantânea para isso, mas algumas técnicas podem aliviar a dor: Alertar com severidade crítica sempre que um processo falha devido a um erro não tratado, validar a entrada e evitar travar o processo devido à entrada inválida do usuário, envolver todas as rotas com uma cláusula catch e considerar não travar quando um erro é originado em uma solicitação o que acontece globalmente).
Caso contrário: Este é apenas um palpite: dado muitos aplicações Node.js, se tentarmos passar um JSON vazio para todas as solicitações POST, um punhado de aplicações falhará. Nesse ponto, podemos apenas repetir o envio da mesma solicitação para derrubar as aplicações com facilidade.

 6.24. Impeça redirecionamentos não seguros

TL;DR: Redirecionamentos que não validam a entrada do usuário podem permitir que invasores iniciem tentativas de phishing, roubem credenciais de usuários e executem outras ações mal-intencionadas.
Caso contrário: Se um invasor descobrir que você não está validando informações externas fornecidas pelo usuário, ele poderá explorar essa vulnerabilidade postando links especialmente em fóruns, mídias sociais e outros locais públicos para que os usuários cliquem.
🔗 Leia Mais: Impeça redirecionamentos não seguros

 6.25. Evite publicar segredos no registro do npm

TL;DR: Precauções devem ser tomadas para evitar o risco de publicação acidental de segredos nos registros públicos do npm. Um arquivo .npmignore pode ser usado para colocar arquivos ou pastas específicos em uma blacklist, ou a lista files no package.json pode atuar como uma whitelist.
Caso contrário: As chaves, as senhas ou outros segredos da API do seu projeto estão sujeitos a abusos por qualquer pessoa que os encontre, o que pode resultar em perda financeira, falsificação de identidade e outros riscos.
🔗 Leia Mais: Evite publicar segredos

⬆ Voltar ao topo
7. Boas Práticas em Performance
Nossos colaboradores estão trabalhando nesta seção. Gostaria de participar?
 7.1. Prefira métodos JS nativos ao invés de utilitários de usuário, como o Lodash
TL;DR: Muitas vezes é mais complicado usar bibliotecas de utilitários como o lodash e underscore sobre os métodos nativos, pois leva a dependências desnecessárias e desempenho mais lento.
Tenha em mente que, com a introdução do novo motor V8 juntamente com os novos padrões ES, os métodos nativos foram aprimorados de tal forma que agora ele tem cerca de 50% a mais de desempenho que as bibliotecas de utilitários.
Caso contrário: Você terá que manter projetos de menor desempenho onde você poderia simplesmente ter usado o que já estava disponível ou lidar com mais algumas linhas em troca de mais alguns arquivos.
🔗 Leia Mais: Prefira métodos nativos ao invés de utilitários do usuário como Lodash

Feitos
Para manter este guia e deixá-lo atualizado, estamos constantemente atualizando e aprimorando as diretrizes e as práticas recomendadas com a ajuda da comunidade. Você pode acompanhar nossos feitos e se juntar aos grupos de trabalho, caso queira contribuir com este projeto.

Traduções
Todas as traduções são contribuições da comunidade. Nós ficaremos felizes em obter ajuda com traduções concluídas, em andamento, ou mesmo com novas traduções!
Traduções concluídas

 Português Brasileiro - Cortesia de Marcelo Melo
 Chinês - Cortesia de Matt Jin
 Vasco - Cortesia de Ane Diaz de Tuesta & Joxefe Diaz de Tuesta

Traduções em andamento

 Francês (Discussão)
 Hebraico (Discussão)
 Coreano (Discussão)
 Russo (Discussão)
 Espanhol (Discussão)
 Turco (Discussão)


Comitê Diretivo
Conheça os membros do comitê diretivo - as pessoas que trabalham juntas para fornecer orientação e direção futura para o projeto. Além disso, cada membro do comitê lidera um projeto rastreado em nossos projetos do Github.

Yoni Goldberg


Consultor de Node.js independente, que trabalha com clientes nos EUA, Europa e Israel, na criação de aplicações Node dimensionáveis em grande escala. Muitas das melhores práticas acima foram publicadas primeiro em um post em seu blog em goldbergyoni.com. Encontre-o como @goldbergyoni ou me@goldbergyoni.com


Bruno Scheufler

💻 full-stack web engineer e entusiasta de Node.js & GraphQL


Kyle Martin


Full Stack Developer e Engenheiro de Confiabilidade de Sites com sede na Nova Zelândia, interessados ​​em segurança de aplicativos da Web, e arquitetando e construindo aplicativos Node.js para executar em escala global.


Sagir Khan



Especialista profundo em JavaScript e seu ecossistema - React, Node.js, MongoDB, praticamente qualquer coisa que envolva o uso de JavaScript/JSON em qualquer camada do sistema - criando produtos usando a plataforma da web para as marcas mais reconhecidas do mundo. Membro individual da "Node.js Foundation", colaborando em "Community Committee's Website Redesign Initiative".

Colaboradores
Obrigado a todos nossos colaboradores! 🙏
Nossos colaboradores são membros que estão contribuindo com o repositório em base regular, sugerindo novas práticas recomendadas, triando problemas, analisando solicitações de pull e muito mais. Se você estiver interessado em nos ajudar a orientar milhares de pessoas a criar melhores aplicações Node.js, leia nossas diretrizes de colaborador 🎉









Ido Richter (Founder)
Keith Holliday



Colaboradores anteriores








Refael Ackermann




Thank You Notes
We appreciate any contribution, from a single word fix to a new best practice. View our contributors and contributing documentation here!\n\n\n\n