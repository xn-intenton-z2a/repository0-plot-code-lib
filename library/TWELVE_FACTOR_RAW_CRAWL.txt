III. Config

Store config in the environment

An app’s config is everything that is likely to vary between deploys (staging, production, developer environments, etc). This includes:


Resource handles to the database, Memcached, and other backing services

Credentials to external services such as Amazon S3 or Twitter

Per-deploy values such as the canonical hostname for the deploy


Apps sometimes store config as constants in the code. This is a violation of twelve-factor, which requires strict separation of config from code. Config varies substantially across deploys, code does not.

A litmus test for whether an app has all config correctly factored out of the code is whether the codebase could be made open source at any moment, without compromising any credentials.

Note that this definition of “config” does not include internal application config, such as config/routes.rb in Rails, or how code modules are connected in Spring. This type of config does not vary between deploys, and so is best done in the code.

Another approach to config is the use of config files which are not checked into revision control, such as config/database.yml in Rails. This is a huge improvement over using constants which are checked into the code repo, but still has weaknesses: it’s easy to mistakenly check in a config file to the repo; there is a tendency for config files to be scattered about in different places and different formats, making it hard to see and manage all the config in one place. Further, these formats tend to be language- or framework-specific.

The twelve-factor app stores config in environment variables (often shortened to env vars or env). Env vars are easy to change between deploys without changing any code; unlike config files, there is little chance of them being checked into the code repo accidentally; and unlike custom config files, or other config mechanisms such as Java System Properties, they are a language- and OS-agnostic standard.

Another aspect of config management is grouping. Sometimes apps batch config into named groups (often called “environments”) named after specific deploys, such as the development, test, and production environments in Rails. This method does not scale cleanly: as more deploys of the app are created, new environment names are necessary, such as staging or qa. As the project grows further, developers may add their own special environments like joes-staging, resulting in a combinatorial explosion of config which makes managing deploys of the app very brittle.

In a twelve-factor app, env vars are granular controls, each fully orthogonal to other env vars. They are never grouped together as “environments”, but instead are independently managed for each deploy. This is a model that scales up smoothly as the app naturally expands into more deploys over its lifetime.\n\n\n\nIntroduction

In the modern era, software is commonly delivered as a service: called web apps, or software-as-a-service. The twelve-factor app is a methodology for building software-as-a-service apps that:


Use declarative formats for setup automation, to minimize time and cost for new developers joining the project;

Have a clean contract with the underlying operating system, offering maximum portability between execution environments;

Are suitable for deployment on modern cloud platforms, obviating the need for servers and systems administration;

Minimize divergence between development and production, enabling continuous deployment for maximum agility;

And can scale up without significant changes to tooling, architecture, or development practices.


The twelve-factor methodology can be applied to apps written in any programming language, and which use any combination of backing services (database, queue, memory cache, etc).

Background

The contributors to this document have been directly involved in the development and deployment of hundreds of apps, and indirectly witnessed the development, operation, and scaling of hundreds of thousands of apps via our work on the Heroku platform.

This document synthesizes all of our experience and observations on a wide variety of software-as-a-service apps in the wild. It is a triangulation on ideal practices for app development, paying particular attention to the dynamics of the organic growth of an app over time, the dynamics of collaboration between developers working on the app’s codebase, and avoiding the cost of software erosion.

Our motivation is to raise awareness of some systemic problems we’ve seen in modern application development, to provide a shared vocabulary for discussing those problems, and to offer a set of broad conceptual solutions to those problems with accompanying terminology. The format is inspired by Martin Fowler’s books Patterns of Enterprise Application Architecture and Refactoring.

Who should read this document?

Any developer building applications which run as a service. Ops engineers who deploy or manage such applications.

The Twelve Factors

I. Codebase

One codebase tracked in revision control, many deploys

II. Dependencies

Explicitly declare and isolate dependencies

III. Config

Store config in the environment

IV. Backing services

Treat backing services as attached resources

V. Build, release, run

Strictly separate build and run stages

VI. Processes

Execute the app as one or more stateless processes

VII. Port binding

Export services via port binding

VIII. Concurrency

Scale out via the process model

IX. Disposability

Maximize robustness with fast startup and graceful shutdown

X. Dev/prod parity

Keep development, staging, and production as similar as possible

XI. Logs

Treat logs as event streams

XII. Admin processes

Run admin/management tasks as one-off processes\n\n\n\nWhy Intuit is Thrilled About the Evolution of the Twelve-Factor Model

03 Apr, 2025

Brett Weaver

 At Intuit, we’ve long embraced the twelve-factor app principles as a guiding framework for modern software development. As a company building cutting-edge development tools and runtime platforms for our internal engineers, these principles have been instrumental in unifying service developers, platform engineers, and SREs under a shared philosophy. read on…

Evolving Twelve-Factor: Applications to Modern Cloud-Native Platforms

10 Feb, 2025

Brian Hammons

 The recent open sourcing of the Twelve-Factor App Methodology comes at a transformative moment for cloud-native platforms. As organizations increasingly rely on cloud-native technologies to power mission-critical workloads, the principles behind Twelve-Factor offer timeless foundations that remain relevant for modern platform builders. read on…

December Monthly Updates

3 Dec, 2024

Vish Abrams

 Welcome to our first monthly update! We’re excited to share our progress and what’s coming next.

What We’ve Been Working On

In addition to some minor formatting fixes, our initial focus has been on getting organized for larger updates. Here are the key activities: read on…

Twelve-Factor App Methodology is now Open Source

12 Nov, 2024

Yehuda Katz

 Join us in modernizing the twelve-factor app manifesto together. As a community of app, framework and platform developers, we’re working together to refresh this foundational document for the modern era. While it’s not software we’re working on, we’ll use familiar processes like pull requests, issues, and reviews to collaborate together in the twelve-factor project repo.

This initiative builds on a strong foundation laid by Heroku when they originally created “The Twelve-Factor App” all the way back in 2011, a time when container-based deployment was still just emerging. Back then, developers could get apps running on their local machines, but common development mistakes often made it challenging to deploy those apps to production. read on…

Narrow Conduits and the Application-Platform Interface

12 Nov, 2024

Vish Abrams

 Welcome to the twelve-factor maintainters blog. As stated in our announcement, some of our posts will analyze the manifesto more generically. This is the first post in that vein, where we dive into the interface between the application and the platform.

It is well understood that defining a clear contract between parts of a system allows one to shed cognitive load on either side of the contract. This has been called the “narrow-waist” principle which has some unfortunate connotations, so we’ll refer to it as the “narrow-conduit” principle. This principle is especially valuable when the humans on either side of the conduit have dramatically different concerns. read on…\n\n\n\nWelcome to the Twelve-Factor community!

Thank you for your interest in the twelve-factor manifesto. Here are some suggestions for getting started with the community:



Familiarize Yourself with the Project


Begin by reviewing the Twelve-Factor Manifesto to see the current state.

Check out the Twelve-Factor Vision to understand the project’s goals and principles.

Take a look at the Twelve-Factor Governance document to familiarize yourself with how we operate.




Join the Discussion


Participate in discussions on open issues.

Broader discussions often happen on the mailing list

Near real-time collaboration happens on discord

Respectful dialogue and collaboration a key to our community’s success.




Find an Area to Contribute


Contributions come in many forms: documentation, bug fixes, new features, or participating in discussions.

Look for open issues on our GitHub repository that are tagged as good first issue for beginners, or explore areas where you feel you can provide value.

More details can be found in The Contributing document.




Meetings

The maintainers group meets weekly in our discord at 8:30 AM PST.

Invite links: (gcal) (ics)

  
    
Maintainers

Vish Abrams

Heroku/Salesforce

 Vish Abrams is Chief Architect at Heroku, a subsidiary of Salesforce. Formerly he helped Oracle create their cloud, where he focused on virtualization, containerization, and machine learning. He was also NASA Nebula Technical Lead during the creation of Nova, one of the founding OpenStack projects, and was a member of both the OpenStack board and technical committee.

Evan Anderson

Stacklok (independent)

 Evan worked for about 15 years in Google’s cloud, with about 10 years in the public cloud. During that time, he was a founding member of the Google Compute Engine team, then worked on App Engine (control plane API), Cloud Functions, and Knative/Cloud Run. In 2019, he moved to VMware, where he spent 4 years on VMware Tandy, VMware’s cloud-native developer platform. He’s also the author of “Designing Serverless Applications with Knative”, and has held many leadership roles in Knative over the years.

Brian Hammons

AWS

 Brian Hammons, a Principal Solutions Architect at AWS, is an original member of the launch team for Amazon EKS. He has held crucial roles in growing the service from its inception including co-founding projects such as eksworkshop.com, Data on EKS (DoEKS), and CNOE. Brian leads Application Modernization and Developer Productivity practice areas for AWS Strategic Industries as well as the Open Source Technical Field Community (TFC) of AWS Worldwide Specialists (WWSO).

Grace Jansen

IBM

 Grace is a Java Champion and Developer Advocate at IBM. She has been with IBM since graduating with a Degree in Biology. Grace enjoys bringing a varied perspective to her projects and using her knowledge of biological systems to simplify complex software patterns. As a developer advocate, Grace builds POC’s, demos, sample applications and tutorials. She is a regular presenter at international conferences and has authored a book on reactive systems.

Yehuda Katz

Heroku/Salesforce

 Yehuda is a True Believer in the power of the open web, especially when the web evolves as a collaboration between browser vendors, framework authors and application developers.

He is one of the creators of Ember.js, and a retired member of the Rust, the Ruby on Rails and jQuery Core Teams. He is an occasional member of ECMAScript’s TC39 standards committee, and a former member of the W3C’s TAG (Technical Architecture Group).

He was the co-author of the Extensible Web Manifesto, of which he is still very proud.

Joe Kutner

Salesforce

 Joe is co-founder of the Cloud Native Buildpacks project, which aims to make containerization more secure and developer friendly. He started the project in 2018 while working as DX Architect at Salesforce Heroku, and today is the DX Architect for Salesforce’s Hyperforce platform.

Terence Lee

Heroku/Salesforce

 Terence is an architect at Heroku where he helped create Classic Buildpacks and then later co-founded Cloud Native Buildpacks, a CNCF Incubation Project. In the Ruby community he’s been a maintainer on projects such as Ruby itself, Bundler, and Resque, but is mostly known for getting people together for #rubykaraoke. When he’s not going to an awesome event, he lives in Austin, TX where it’s acceptable to eat a taco for every meal of the day.

James Ward

AWS

 Professional software developer since 1997, with much of that time spent helping developers build software that doesn’t suck. A Typed Pure Functional Programming zealot who often compromises on his ideals to just get stuff done. Currently a Developer Advocate for AWS.

Brett Weaver

Intuit

 Brett Weaver is a Distinguished Engineer at Intuit. He has spent the last twenty two odd years at Intuit in various software development and systems engineer roles. He has been focused on building distributed, scalable architectures for Intuit’s flagship products including Quickbooks and TurboTax. Most recently, Brett has been leading architecture for Intuit’s internal services platform.

Emeritus

Gail Frederick

Heroku/Salesforce

 As Heroku CTO, Gail is a Salesforce leader known for her technical excellence and drive to deliver. She stewards the opinionated magic that is Heroku’s developer platform. Prior to Heroku, Gail led engineering for Salesforce DX. Her values are integrity, impact, and joy. Previously, VP Engineering at eBay, where she was the 2019 winner of the John Donahoe Award, eBay’s highest leadership award, for building a new $3B annual GMB business by reinventing eBay’s developer ecosystem. Member of 2024 Curve Power List of 50 LGBTQ+ women and non-binary leaders. Formerly, executive advisory board member of Lesbians Who Tech, Business Governing Board member of OpenAPI Initiative at the Linux Foundation, and represented eBay at the founding of the Facebook-led Libra Initiative. Gail holds 9 software patents.

Steren Giannini

Google Cloud

 Steren is an engineer turned product manager. He is leading product management for Google Cloud’s serverless portfolio (Cloud Run, Cloud Run functions, App Engine). He is a founding member of Cloud Run.

https://twitter.com/steren

https://www.linkedin.com/in/steren

https://steren.fr\n\n\n\nI. Codebase

One codebase tracked in revision control, many deploys

A twelve-factor app is always tracked in a version control system, such as Git, Mercurial, or Subversion. A copy of the revision tracking database is known as a code repository, often shortened to code repo or just repo.

A codebase is any single repo (in a centralized revision control system like Subversion), or any set of repos who share a root commit (in a decentralized revision control system like Git).



There is always a one-to-one correlation between the codebase and the app:


If there are multiple codebases, it’s not an app – it’s a distributed system. Each component in a distributed system is an app, and each can individually comply with twelve-factor.

Multiple apps sharing the same code is a violation of twelve-factor. The solution here is to factor shared code into libraries which can be included through the dependency manager.


There is only one codebase per app, but there will be many deploys of the app. A deploy is a running instance of the app. This is typically a production site, and one or more staging sites. Additionally, every developer has a copy of the app running in their local development environment, each of which also qualifies as a deploy.

The codebase is the same across all deploys, although different versions may be active in each deploy. For example, a developer has some commits not yet deployed to staging; staging has some commits not yet deployed to production. But they all share the same codebase, thus making them identifiable as different deploys of the same app.\n\n\n\nIV. Backing services

Treat backing services as attached resources

A backing service is any service the app consumes over the network as part of its normal operation. Examples include datastores (such as MySQL or CouchDB), messaging/queueing systems (such as RabbitMQ or Beanstalkd), SMTP services for outbound email (such as Postfix), and caching systems (such as Memcached).

Backing services like the database are traditionally managed by the same systems administrators who deploy the app’s runtime. In addition to these locally-managed services, the app may also have services provided and managed by third parties. Examples include SMTP services (such as Postmark), metrics-gathering services (such as New Relic or Loggly), binary asset services (such as Amazon S3), and even API-accessible consumer services (such as Twitter, Google Maps, or Last.fm).

The code for a twelve-factor app makes no distinction between local and third party services. To the app, both are attached resources, accessed via a URL or other locator/credentials stored in the config. A deploy of the twelve-factor app should be able to swap out a local MySQL database with one managed by a third party (such as Amazon RDS) without any changes to the app’s code. Likewise, a local SMTP server could be swapped with a third-party SMTP service (such as Postmark) without code changes. In both cases, only the resource handle in the config needs to change.

Each distinct backing service is a resource. For example, a MySQL database is a resource; two MySQL databases (used for sharding at the application layer) qualify as two distinct resources. The twelve-factor app treats these databases as attached resources, which indicates their loose coupling to the deploy they are attached to.



Resources can be attached to and detached from deploys at will. For example, if the app’s database is misbehaving due to a hardware issue, the app’s administrator might spin up a new database server restored from a recent backup. The current production database could be detached, and the new database attached – all without any code changes.\n\n\n\nIII. Konfigurace

Konfigurace ukládejte do prostředí.

Konfigurace aplikace je všechno, co se liší mezi nasazeními (testovací, produkční, vývojové prostředí, atd.). To zahrnuje:


Přihlašovací údaje k databázím, Memcached a dalším podpůrným službám.

Přístupové údaje k externím službám jako je Amazon S3 nebo Twitter.

Specifické hodnoty pro dané nasazení jako například kanonické názvy hostitelů.


Aplikace si někdy ukládají konfiguraci jako konstanty v kódu. To je porušení twelve-factor metodiky, která vyžaduje přísné oddělení konfigurace od kódu. Konfigurace se mezi nasazeními značně liší, kód však nikoliv.

Test lakmusovým papírkem na správné oddělení konfigurace od kódu je fakt, že aplikace by mohla být kdykoliv uvolněna jako open source bez kompromitace přístupových údajů.

Nutno podotknout, že do definice “konfigurace” nepatří interní nastavení aplikace jako je například config/routes.rb v Rails nebo nastavení propojení základních modulů ve Springu. Tento typ konfigurace se neliší mezi nasazeními a je nejlepší ho ponechat v kódu.

Další možností jak přistupovat ke konfiguracím je mít konfigurační soubory, které nejsou uložené ve verzovacím systému, jak je tomu například u config/database.yml v Rails. To je obrovské zlepšení oproti konstantám uloženým v repozitáři, tento přístup má však stále několik slabin: je velmi jednoduché omylem uložit tento soubor do repozitáře; chtě nechtě jsou tyto soubory obvykle rozmístěny na několika místech a v různých formátech, což komplikuje jejich centrální správu. Navíc jsou tyto konfigurační soubory často specifické pro daný jazyk či framework.

Twelve-factor aplikace ukládají konfiguraci do proměnných prostředí (často zkracováno jak env vars nebo env). Proměnné prostředí se dají jednoduše měnit mezi nasazeními bez zásahu do kódu. Oproti konfiguračním souborům je zde velmi malá šance, že by byly omylem uloženy do repozitáře a narozdíl od vlastních konfiguračních souborů a jiných konfiguračních mechanismů, jako například Java System Properties, jsou nezávislé na jazyce a operačním systému.

Dalším úskalím správy konfigurace je seskupování. Aplikace někdy seskupují konfigurace do pojmenovaných skupin (často nazývaných jako “prostředí”), rozlišených podle specifického nasazení, jako například vývojové, testovací nebo produkční prostředí. Tento přístup lze jen velmi težko čistě škálovat. Jak přibývají nasazení jsou zapotřebí nová prostředí, jako například staging nebo qa. Jakmile projekt začne narůstat, vývojáři přidávají svoje specifická prostředí jako třeba joes-staging, což má za následek kombinatorickou explozi konfigurací a správa nasazení se tak stáva velmi delikátní záležitostí.

Ve twelve-factor aplikaci jsou proměnné prostředí jako vzájemně nezávislé ovládací prvky. Ty nejsou nikdy seskupovány do “prostředí”, namísto toho jsou všechny spravovány nezávisle pro každé nasazení. Tento model plynule škáluje s přirozeně se rozrůstající aplikací a narůstajícím počtem nasazení během celého životního cyklu aplikace.\n\n\n\nIII. Konfiguration

Die Konfiguration in Umgebungsvariablen ablegen

Die Konfiguration einer App ist alles, was sich wahrscheinlich zwischen den Deploys ändern wird (Staging, Produktion, Entwicklungsumgebungen, usw.). Dies umfasst:


Resource-Handles für Datenbanken, Memcached und andere unterstützende Dienste

Credentials für externe Dienste wie Amazon S3 oder Twitter

Direkt vom Deploy abhängige Werte wie der kanonische Hostname für den Deploy


Manchmal speichern Apps die Konfiguration als Konstanten im Code. Dies ist eine Verletzung der zwölf Faktoren. Sie fordern strikte Trennung der Konfiguration vom Code. Die Konfiguration ändert sich deutlich von Deploy zu Deploy, ganz im Gegensatz zu Code.

Ein Lackmustest, ob eine App die Konfiguration vollständig ausgelagert hat, ist, wenn die Codebase jederzeit als Open Source veröffentlicht werden könnte, ohne Credentials preiszugeben.

Es sei darauf hingewiesen, dass diese Definition von “Konfiguration” die interne Anwendungskonfiguration nicht einschließt, wie config/routes.rb in Rails oder wie Code-Module mit Spring verdrahtet sind. Diese Art von Konfiguration ändert sich nicht von Deploy zu Deploy und gehört daher zum Code.

Als Konfiguration könnte man auch Dateien verwenden, die nicht ins Versionsmanagement eingecheckt sind wie config/database.yml in Rails. Dies ist eine deutliche Verbesserung gegenüber der Verwendung von Konstanten, die ins Versionsmanagement eingecheckt sind, hat aber Schwächen. Es ist relativ einfach, versehentlich eine Konfigurationsdatei ins Repo einzuchecken. Zusätzlich gibt es Tendenzen, Konfigurationsdateien an verschiedenen Orten und in verschiedenen Formaten zu streuen. Das macht es schwer die Konfiguration von einem Punkt aus zu managen. Desweiteren sind diese Formate oft sprach- oder plattformspezifisch.

Die Zwölf-Faktor-App speichert die Konfiguration in Umgebungsvariablen (kurz auch env vars oder env). Umgebungsvariablen von Deploy zu Deploy zu ändern ist einfach; im Gegensatz zu Konfigurationsdateien ist es unwahrscheinlich, dass sie versehentlich ins Code Repository eingecheckt werden und im Gegensatz zu speziellen Konfigurationsdateien oder anderen Konfigurationsmechanismen wie den Java Properties sind sie Sprach- und Betriebssystemunabhängig.

Ein anderer Aspekt des Konfigurationsmanagements ist die Gruppierung. Manchmal sammeln Apps die Konfiguration in benamten Gruppen (oft “Umgebungen” genannt), benannt nach bestimmten Deploys wie zum Beispiel die Umgebungen development, test und production in Rails. Diese Methode skaliert nicht sauber: Je mehr Deploys einer App es gibt, desto mehr Umgebungsnamen werden benötigt, wie zum Beispiel staging oder qa. Wenn das Projekt noch weiter wächst, könnten Entwickler ihre eigenen speziellen Umgebungen wie joes-staging hinzufügen. Am Ende explodiert die Konfiguration kombinatorisch und die Verwaltung der Deploys wird fehleranfällig.

In einer Zwölf-Faktor-App sind Umgebungsvariablen granulare Stellschrauben und vollständig orthogonal zueinander. Sie werden nie als “Umgebungen” zusammengefasst, sondern können für jeden Deploy unabhängig verwaltet werden. Dieses Modell skaliert reibungslos aufwärts, wenn die App sich natürlicherweise über ihre Lebenszeit hinweg auf mehr Deploys ausdehnt.\n\n\n\nIII. Παραμετροποίηση

Αποθήκευση παραμέτρων στο περιβάλλον

Οι παράμετροι (config) μιας εφαρμογής είναι όλα εκείνα που είναι πιθανό να αλλάζουν ανά ανάπτυξη της εφαρμογής (έλεγχος, παραγωγή, περιβάλλον προγραμματιστή, κλπ). Αυτό περιλαμβάνει:


Αναγνωριστικά πόρων (resource handles) στη βάση δεδομένων, στο Memcached, και άλλες υπηρεσίες υποστήριξης

Διαπιστευτήρια (credentials) για εξωτερικές υπηρεσίες όπως το Amazon S3 ή το Twitter

Τιμές σχετικές με μια συγκεκριμένη ανάπτυξη όπως το κανονικό όνομα φιλοξενητή (canonical hostname) της ανάπτυξης


Οι εφαρμογές μερικές φορές αποθηκέυουν τις παραμέτρους ως σταθερές στον κώδικα. Αυτό αποτελεί παραβίαση των δώδεκα παραγόντων, το οποίο απαιτεί αυστηρό διαχωρισμό παραμέτρων από τον κώδικα. Οι παράμετροι διαφοροποιούνται σημαντικά μεταξύ αναπτύξεων, ο κώδικας όχι.

Ένα τέστ litmus για το αν μία εφαρμογή έχει αφήσει έξω την παραμετροποίηση με σωστό τρόπο είναι εάν η βάση κώδικα μπορει να γίνει ανοιχτού κώδικα ανά πάσα στιγμή, χωρίς να γίνει γνωστό κανένα διαπιστευτήριο.

Σημειώστε ότι αυτός ο ορισμός της παραμετροποίησης δεν συμπεριλαμβάνει την εσωτερική παραμετροποίηση της εφαρμογής, όπως το config/routes.rb στο Rails, ή πως συνδέονται τα μέρη του κώδικα στο Spring. Αυτός ο τύπος παραμετροποίησης δεν μεταβάλλεται μεταξύ αναπτύξεων, οπότε είναι καλύτερα να γίνεται στον κώδικα.

Μια άλλη προσέγγιση στην παραμετροποίηση είναι η χρήση αρχείων παραμέτρων (config files) τα οποία δεν περιλαμβάνονται στο αποθετήριο της εφαρμογής, όπως το config/database.yml στο Rails. Αυτό αποτελεί μια μεγάλη βελτίωση από το να χρησιμοποιούνται σταθερές στον κώδικα, αλλά ακόμα έχει αδυναμίες: είναι εύκολο κατά λάθος να συμπεριληφθεί το αρχείο στο αποθετήριο, υπάρχει μία τάση τα αρχεία παραμέτρων να είναι διασκορπισμένα σε διάφορα μέρη και σε διαφορετικές μορφές, καθιστώντας έτσι δύσκολο να δει και να διαχειριστεί κάποιος όλες τις παραμέτρους σε ένα μέρος. Επιπλέον, αυτές οι μορφές τείνουν να είναι συγκεκριμένες ως προς τη γλώσσα προγραμματισμού ή το πλαισιο ανάπτυξης της εφαρμογής.

Η εφαρμογή δώδεκα παραγόντων αποθηκεύει την παραμετροποίηση σε μεταβλητές περιβάλλοντος (environment variables, env vars, env). Οι μεταβλητές περιβάλλοντος αλλάζουν έυκολα μεταξύ αναπτύξεων της εφαρμογής χωρίς να αλλάξει ο κώδικας, σε σχέση με τα αρχεία παραμέτρων, υπάρχει μικρή πιθανότητα κατά λάθος να εισαχθούν στο αποθετήριο του κώδικα, και επίσης πάλι σε σχέση με τα αρχεία παραμέτρων, ή άλλους μηχανισμούς παραμετροποίησης όπως τα Java System Properties, αποτελούν ένα πρότυπο ανεξάρτητο από τη γλώσσα προγραμματισμού και το λειτουργικό σύτημα.

Μια άλλη πλευρά της διαχείρισης παραμέτρων είναι η ομαδοποίηση. Μερικές φορές οι εφαρμογές στοιβάζουν παραμέτρους σε ονομαστικές ομάδες (συχνά καλούνται “περιβάλλοντα”) που παίρνουν το όνομά τους απο συγκεκριμένες αναπτύξεις, όπως τα περιβάλλοντα development (υλοποίηση), test (τέστ), και production (παραγωγή) στο Rails. Αυτή η μέθοδος δεν κλιμακώνεται καθαρά: καθώς περισσότερες αναπτύξεις της εφαρμογής δημιουργούνται, νέα ονόματα περιβαλλόντων γίνονται απαραίτητα, όπως staging (έλεγχος) ή qa. Καθώς το έργο επεκτείνεται περαιτέρω, οι προγραμματιστές μπορει να προσθέσουν τα δικά τους ειδικά περιβάλλοντα όπως joes-staging, συνεπαγόμενα μια συνδυαστική έκρηξη από παραμετροποιήσεις που κάνουν την διαχείριση αναπτύξεων της εφαρμογής πολύ εύθραυστη.

Σε μια εφαρμογή δώδεκα παραγόντων, οι μεταβλητές περιβάλλοντος αποτελούν στοιχεία λεπτοφυούς ελέγχου, το καθένα πλήρως ορθογώνιο σε άλλες μεταβλητές περιβάλλοντος. Ποτέ δεν ομαδοποιούνται μαζί ως “περιβάλλοντα”, αντιθέτως διαχειρίζονται ανεξάρτητα για κάθε ανάπτυξη της εφαρμογής. Αυτό είναι ένα μοντέλο που κλιμακώνεται ομαλά προς τα πάνω καθώς η εφαρμογή φυσικά διευρύνεται σε περισσότερες αναπτύξεις κατά της διάρκεια της ζωής της.\n\n\n\nIII. Configuración

Guardar la configuración en el entorno

La configuración de una aplicación es todo lo que puede variar entre despliegues (entornos de preproducción, producción, desarrollo, etc), lo cual incluye:


Recursos que manejan la base de datos, Memcached, y otros “backing services”

Credenciales para servicios externos tales como Amazon S3 o Twitter

Valores de despliegue como por ejemplo el nombre canónico del equipo para el despliegue


A veces las aplicaciones guardan configuraciones como constantes en el código, lo que conduce a una violación de la metodología “twelve-factor”, que requiere una estricta separación de la configuración y el código. La configuración varía sustancialmente en cada despliegue, el código no.

La prueba de fuego para saber si una aplicación tiene toda su configuración correctamente separada del código es comprobar que el código base puede convertirse en código abierto en cualquier momento, sin comprometer las credenciales.

Hay que resaltar que la definición de “configuración” no incluye las configuraciones internas de la aplicación, como config/routes.rb en Rails, o como se conectan los módulos en Spring. Este tipo de configuraciones no varían entre despliegues, y es por eso que están mejor en el código.

Otra estrategia de configuración es el uso de ficheros de configuración que no se guardan en el control de versiones, como ocurre con el config/database.yml de Rails. Esto supone una gran mejora con respecto a las constantes que se guardan en el repositorio, aunque todavía tiene ciertas debilidades: es fácil guardar un fichero de configuración en el repo por error; se tiende a desperdigar los ficheros de configuración en diferentes sitios y con distintos formatos, siendo más difícil la tarea de ver y gestionar toda la configuración en un solo sitio. Además, el formato tiende a ser específico del lenguaje o del framework.

Las aplicaciones “twelve-factor” almacenan la configuración en variables de entorno (abreviadas normalmente como env vars o env). Las variables de entorno se modifican fácilmente entre despliegues sin realizar cambios en el código; a diferencia de los ficheros de configuración, en los que existe una pequeña posibilidad de que se guarden en el repositorio de código accidentalmente; y a diferencia de los ficheros de configuración personalizados u otros mecanismos de configuración, como los System Properties de Java, son un estándar independiente del lenguaje y del sistema operativo.

Otro aspecto de la gestión de la configuración es la clasificación. A veces, las aplicaciones clasifican las configuraciones en grupos identificados (a menudo llamados “entornos” o “environments”) identificando después despliegues específicos, como ocurre en Rails con los entornos development, test, y production. Este método no escala de una manera limpia: según se van creando despliegues de la aplicación, se van necesitando nuevos entornos, tales como staging o qa. Según va creciendo el proyecto, los desarrolladores van añadiendo sus propios entornos especiales como joes-staging, resultando en una explosión de combinaciones de configuraciones que hacen muy frágil la gestión de despliegues de la aplicación.

En una aplicación “twelve-factor”, las variables de entorno son controles granulares, cada una de ellas completamente ortogonales a las otras. Nunca se agrupan juntas como “entornos”, pero en su lugar se gestionan independientemente para cada despliegue. Este es un modelo que escala con facilidad según la aplicación se amplía, naturalmente, en más despliegues a lo largo de su vida.\n\n\n\nIII. Configuration

Stockez la configuration dans l’environnement

La configuration d’une application est tout ce qui est susceptible de varier entre des déploiements (validation, production, environnement de développement, etc.). Cela inclut :


Les ressources gérées par la base de données, Memcached, ou tout autre service de stockage

Les identifiants pour des services externes, tel qu’Amazon S3 ou Twitter

Les valeurs spécifiques au déploiement, tel que son nom d’hôte canonique


Les applications stockent parfois la configuration avec des constantes dans le code. C’est une violation des 12 facteurs, qui requiert une stricte séparation de la configuration et du code. La configuration peut varier substantiellement à travers les déploiements, alors que ce n’est pas le cas du code.

Un bon moyen de tester si une application a correctement séparé son code, c’est de se demander si l’application pourrait être rendue open-source à tout instant, sans compromettre d’identifiants.

Notez que cette définition de “configuration” n’inclut pas la configuration interne de l’application, tel que config/routes.rb avec Rails, ou comment les modules du noyau sont connectés (en) dans Spring. Ce type de configuration ne varie pas à travers les déploiements, et est ainsi mieux réalisé dans le code.

Une autre approche de la configuration, c’est d’utiliser des fichiers de configuration qui ne sont pas inclus dans le système de contrôle de version, par exemple config/database.yml de Rails. C’est une amélioration considérable par rapport à l’utilisation de constantes qui sont versionnées dans le dépôt de code, mais a toujours des faiblesses : il est facile d’ajouter par inadvertance un fichier de configuration dans le dépôt. Il y a une tendance à ce que les fichiers de configuration soient dispersés à différents endroits et dans différents formats, rendant ainsi difficile de voir et gérer la configuration à un unique endroit. De plus, ces formats ont tendance à être spécifiques à un langage ou un framework.

Les applications 12 facteurs stockent la configuration dans des variables d’environnement (souvent raccourcies en variables d’env, ou env). Les variables d’environnement sont faciles à changer entre des déploiements sans changer le moindre code ; contrairement aux fichiers de configuration, il y a peu de chance pour qu’elles soient ajoutées au dépôt de code accidentellement ; et contrairement aux fichiers de configuration personnalisés, ou tout autre mécanisme de configuration comme les propriétés système Java, ce sont des standards agnostiques du langage ou du système d’exploitation.

Un autre aspect de la gestion de configuration est le groupage. Parfois, les applications regroupent la configuration dans des groupes nommés (souvent appelés les “environnements”), nommés ainsi d’après des déploiements spécifiques, comme les environnements development, test, et production de Rails. Cette méthode ne permet pas de grossir proprement : lorsque l’on ajoute de nouveaux déploiement à l’application, de nouveaux noms d’environnement sont nécessaires, comme validation ou qa. Quand le projet grossit encore plus, les développeurs vont avoir tendance à ajouter leurs propres environnements particuliers, comme joes-validation, ce qui entraîne une explosion combinatoire de la configuration qui rend la gestion des déploiements de l’application très fragile.

Dans une application 12 facteurs, les variables d’environnement permettent un contrôle granulaire, chacune complètement orthogonale aux autres variables d’environnement. Elles ne sont jamais groupées ensemble en “environnements”, mais sont plutôt gérées indépendamment pour chaque déploiement. C’est un modèle qui permet de grossir verticalement en souplesse, lorsque l’application grossit naturellement en un plus grand nombre de déploiements au cours de sa vie.\n\n\n\nIII. Configurazione

Memorizza le informazioni di configurazione nell’ambiente

La “configurazione” di un’applicazione è tutto quello che può variare da un deployment all’altro (staging, production, ambienti di sviluppo). Ad esempio:


Valori da usare per connettersi a un database, Memcached, oppure altri backing service;

Credenziali per servizi esterni, come Amazon S3 o Twitter;

Valori eventualmente definiti per i singoli deployment, come l’hostname;


Molto spesso, queste informazioni vengono memorizzate come costanti nel codice: la cosa viola la metodologia twelve-factor, che richiede una separazione ben definita delle impostazioni di configurazione dal codice. Le impostazioni possono infatti variare da un deployment all’altro: il codice, invece, no.

Il codice dell’applicazione, infatti, potrebbe essere reso open-source in ogni momento: un buon motivo per separare le due cose.

Nota che comunque la definizione di “configurazione” non include eventuali configurazione interne dell’applicazione, come config/routes.rb in Rails, o come i moduli di codice sono connessi in Spring. Questo tipo di configurazione non varia da deployment a deployment: come giusto che sia, quindi, rimane nel codice.

Un ottimo approccio al “rispetto” di questo principio consiste nell’usare dei file di configurazione non coinvolti dal version control, come per esempio config/database.yml in Rails. Stiamo parlando di un miglioramento enorme rispetto all’uso di costanti nel codice, ma c’è da dire la cosa ha il suo lato negativo: basta poco per sbagliarsi e includere nel repo il file di configurazione che, invece, non dovrebbe essere lì. C’è una certa tendenza, infatti, a non avere tutti i file di configurazione necessari nello stesso posto. Inoltre, i vari formati tendono a essere collegati a un certo linguaggio/framework.

L’applicazione che rispetta la metodologia twelve-factor memorizza tutte le impostazioni in variabili d’ambiente (spesso dette env vars o env). Le variabili d’ambiente sono molto semplici da cambiare di deployment in deployment senza dover toccare il codice direttamente. Inoltre, a differenza dei file di configurazione classici, c’è una probabilità molto bassa di venire inclusi nel repo. Infine, questi file sono indipendenti sia dal linguaggio che dal sistema operativo utilizzato.

Un altro aspetto del config management è il raggruppamento. A volte, infatti, alcune applicazioni prevedono la memorizzazione delle impostazioni in gruppi (chiamati spesso “ambienti”) dal nome ben preciso: “development”, “test” e “production”, per esempio. Questo metodo non scala correttamente, se ci pensi: potrebbero essere necessari nuovi ambienti, come “staging” e “qa”. Oppure, i vari sviluppatori potrebbero aver bisogno di creare i propri ambienti “speciali”, come “joes-staging” e così via. Il risultato? Una quantità di combinazioni ingestibile e disordinata.

In una buona twelve-factor app, le variabili di ambiente sono controllate in modo più “granulare”, in modo totalmente ortogonale alle altre. Non sono mai raggruppate e classificate sotto “ambienti” specifici, ma vengono gestite in modo totalmente indipendente per ogni deployment. Il prodotto finale ne risente positivamente in termini di scalabilità.\n\n\n\nIII. 設定

設定を環境変数に格納する

アプリケーションの 設定 は、デプロイ（ステージング、本番、開発環境など）の間で異なり得る唯一のものである。設定には以下のものが含まれる。


データベース、Memcached、他のバックエンドサービスなどのリソースへのハンドル

Amazon S3やTwitterなどの外部サービスの認証情報

デプロイされたホストの正規化されたホスト名など、デプロイごとの値


アプリケーションは時に設定を定数としてコード内に格納する。これはTwelve-Factorに違反している。Twelve-Factorは 設定をコードから厳密に分離すること を要求する。設定はデプロイごとに大きく異なるが、コードはそうではない。

アプリケーションがすべての設定をコードの外部に正しく分離できているかどうかの簡単なテストは、認証情報を漏洩させることなく、コードベースを今すぐにでもオープンソースにすることができるかどうかである。

なお、この“設定”の定義には、アプリケーション内部の設定は 含まない ことに注意する。内部の設定とは、Railsにおけるconfig/routes.rbや、Springにおいてコードモジュールがどう接続されるかなどの設定を指す。この種の設定はデプロイの間で変わらないため、コードの内部で行うべきである。

設定に対するもう1つのアプローチは、バージョン管理システムにチェックインされない設定ファイルを使う方法である。例として、Railsにおけるconfig/database.ymlがある。この方法は、リポジトリにチェックインされる定数を使うことに比べると非常に大きな進歩であるが、まだ弱点がある。設定ファイルが誤ってリポジトリにチェックインされやすいことと、設定ファイルが異なる場所に異なるフォーマットで散乱し、すべての設定を一つの場所で見たり管理したりすることが難しくなりがちであることである。その上、これらのフォーマットは言語やフレームワークに固有のものになりがちである。

Twelve-Factor Appは設定を 環境変数 に格納する。 環境変数は、コードを変更することなくデプロイごとに簡単に変更できる。設定ファイルとは異なり、誤ってリポジトリにチェックインされる可能性はほとんどない。また、独自形式の設定ファイルやJava System Propertiesなど他の設定の仕組みとは異なり、環境変数は言語やOSに依存しない標準である。

設定管理のもう1つの側面はグルーピングである。アプリケーションは設定を名前付きのグループ（しばしば“環境”と呼ばれる）にまとめることがある。グループは、Railsにおけるdevelopment、test、production環境のように、デプロイの名前を取って名付けられる。この方法はうまくスケールしない。アプリケーションのデプロイが増えるにつれて、新しい環境名（stagingやqa）が必要になる。さらにプロジェクトが拡大すると、開発者はjoes-stagingのような自分用の環境を追加する。結果として設定が組み合わせ的に爆発し、アプリケーションのデプロイの管理が非常に不安定になる。

Twelve-Factor Appの場合、環境変数は粒度の細かい管理であり、それぞれの環境変数は互いに直交している。環境変数は“環境”としてまとめられることはないが、代わりにデプロイごとに独立して管理される。これは、アプリケーションのライフサイクルに渡って、アプリケーションが多くのデプロイへと自然に拡大していくにつれて、スムーズにスケールアップするモデルである。\n\n\n\nIII. 설정

환경(environment)에 저장된 설정

애플리케이션의 설정은 배포 (스테이징, 프로덕션, 개발 환경 등) 마다 달라질 수 있는 모든 것들입니다. 설정에는 다음이 포함됩니다.


데이터베이스, memcached 등 백엔드 서비스들의 리소스 핸들

Amazon S3 이나 트위터 등의 외부 서비스 인증 정보

배포된 호스트의 정규화된 호스트 이름(canonical hostname)처럼 각 배포마다 달라지는 값


애플리케이션은 종종 설정을 상수로 코드에 저장합니다. 이것은 Twelve-Factor를 위반하며, Twelve-Factor는 설정을 코드에서 엄격하게 분리하는 것을 요구합니다. 설정은 배치마다 크게 다르지만, 코드는 그렇지 않습니다.

애플리케이션의 모든 설정이 정상적으로 코드 바깥으로 분리되어 있는지 확인할 수 있는 간단한 테스트는 어떠한 인증정보도 유출시키지 않고 코드베이스가 지금 당장 오픈 소스가 될 수 있는지 확인하는 것입니다.

이 “설정”의 정의는 애플리케이션 내부 설정을 포함하지 않는다는 점에 유의해야 합니다. Rails의 config/routes.rb이나 Spring의 “어떻게 코드 모듈이 연결되는 가과 같은 설정들은 배치 사이에서 변하지 않기 때문에 코드의 내부에 있는 것이 가장 좋습니다.

설정에 대한 또 다른 접근방식은 Rails의 config/database.yaml처럼 버전 관리 시스템에 등록되지 않은 설정 파일을 이용하는 것입니다. 이 방법은 코드 저장소에 등록된 상수를 사용하는 것에 비하면 매우 큰 발전이지만, 설정 파일이 여러 위치에 여러 포맷으로 흝어지고 모든 설정을 한 곳에서 확인하고 관리하기 어렵게 만드는 경향이 있습니다. 게다가, 이러한 형식들은 언어와 프레임워크을 따라가는 경향이 있습니다.

Twelve-Factor App은 설정을 환경 변수 (envvars나 env라고도 불림)에 저장합니다. 환경 변수는 코드 변경 없이 쉽게 배포 때마다 쉽게 변경할 수 있습니다. 설정 파일과 달리, 잘못해서 코드 저장소에 올라갈 가능성도 낮습니다. 또한, 커스텀 설정 파일이나 Java System Property와 같은 다른 설정 매커니즘과 달리 언어나 OS에 의존하지 않는 표준입니다.

설정 관리의 다른 측면은 그룹핑입니다. 종종 애플리케이션은 설정을 명명된 그룹(“environments”라고도 함)으로 구성하기도 합니다. 해당 그룹은 Rails의 ‘development’, ‘test’, ‘production’ environments처럼, 배포의 이름을 따서 명명됩니다. 이 방법은 깔끔하게 확장하기 어렵습니다. 응용 프로그램의 배포가 증가함에 따라, ‘staging’이라던가 ‘qa’같은 새로운 그룹의 이름이 필요하게 됩니다. 프로젝트가 성장함에 따라, 개발자은 자기 자신의 그룹를 추가하게 됩니다. 결과적으로 설정이 각 그룹의 조합으로 폭발하게 되고, 애플리케이션의 배포를 불안정하게 만듭니다.

Twelve-Factor App에서 환경 변수는 매우 정교한 관리이며, 각각의 환경변수는 서로 직교합니다. 환경 변수는 “environments”로 절대 그룹으로 묶이지 않지만, 대신 각 배포마다 독립적으로 관리됩니다. 이 모델은 애플리케이션의 수명주기를 거치는 동안 더 많은 배포로 원활하게 확장해 나갈 수 있습니다.\n\n\n\nIII. Konfiguracja

Przechowuj konfigurację w środowisku

Konfiguracja to jedyny element, który może się różnić pomiędzy wdrożeniami aplikacji (staging, produkcja, środowisko developerskie, etc). W jej skład wchodzą:


Ustawienia połączeń do baz danych, Memcached, i innych usług wspierających

Dane uwierzytelniające zewnętrznych usług takich jak Amazon S3 czy Twitter

Wartości różne dla każdego wdrożenia, jak np. kanoniczna nazwa hosta


Aplikacja czasem przechowuje konfigurację jako stałe wartości w kodzie źródłowym. Niestety jest to złamanie zasady 12factor wg której konfiguracja jest ściśle oddzielona od kodu aplikacji.

Dowodem na to, czy aplikacja posiada swoją konfigurację oddzieloną od kodu jest to, czy można ją udostępnić na zasadach open source bez równoczesnego udostępniania np. danych uwierzytelniających.

Należy pamiętać, że definicja “konfiguracji” nie dotyczy wewnętrznych ustawień aplikacji takich jak np. plik config/routes.rb w Railsach lub to jak są połączone moduły kodu w Springu. Konfiguracja tego typu nie zmienia się pomiędzy wdrożeniami co sprawia, że najbardziej odpowiednim miejscem do jej przechowywania jest kod aplikacji.

Innym podejściem do konfiguacji jest korzystanie z plików, które nie znajdują się w repozytorium i nie są wersjonowane, jak np. config/database.yml w Railsach. Jest to duże usprawnienie względem używania stałych wartości, które są zapisywane w repozytorium. Minusem tego rozwiązania jest możliwość przypadkowego umieszczenia pliku konfiguracyjnego w repo. Ponadto można spotkać się z tendencją do rozrzucania takich plików w różnych katalogach i różnych formatach, co czyni je trudnymi do znalezienia i zarządzania z jednego miejsca.

Aplikacja 12factor przechowuje konfigurację w zmiennych środowiskowych (czasem nazywane z języka angielskiego env vars lub env). W tej sytuacji można łatwo modyfikować zmienne środowiskowe pomiędzy wdrożeniami bez zmiany kodu aplikacji. W odróżnieniu do plików konfiguracyjnych istnieje mała szansa by zostały umieszczone przypadkowo w repozytorium. Ich kolejną zaletą jest to, że nie są powiązane z językiem programowania, frameworkiem, jak np. Java System Properties, czy też systemem operacyjnym.

Kolejnym zagadnieniem zarządzania konfiguracją jest jej grupowanie. Czasem aplikacje gromadzą konfigurację w grupach (czasem nazywane “środowiskami”) nazywanych od nazwy wdrożenia, takie jak development, test, czy produkcja w Railsach. Ten sposób organizacji jest niestety nieskalowalny. Im więcej różnych wdrożeń, tym większa potrzeba nazw, jak np. staging czy qa. Wraz z rozwojem projektu programiści mogą dodawać swoje specjalne konfiguracje, jak staging-józefa. Efektem tego mogą być niezliczone kombinacje nazw plików konfiguracyjnych, co utrudniać będzie zarządzanie wdrożonymi aplikacji.

W aplikacji 12factor zmienne środowiskowe służą do precyzyjnej kontroli poszczególnych ustawień, posiadając różne, niemylące się ze sobą nazwy. Nigdy nie są zgrupowane w “środowiskach”, tylko niezależnie ustawiane dla każdego wdrożenia. Taki model konfiguracji skaluje się bez problemu, nawet jeśli aplikacja będzie potrzebowała w przyszłości więcej zróżnicowanych wdrożeń.\n\n\n\nIII. Configurações

Armazene as configurações no ambiente

A configuração de uma aplicação é tudo o que é provável variar entre deploys (homologação, produção, ambientes de desenvolvimento, etc). Isto inclui:


Recursos para a base de dados, Memcached, e outros serviços de apoio

Credenciais para serviços externos como Amazon S3 ou Twitter

Valores por deploy como o nome canônico do host para o deploy


Aplicações às vezes armazenam as configurações no código como constantes. Isto é uma violação da doze-fatores, a qual exige uma estrita separação entre configuração e código. Configuração varia substancialmente entre deploys, código não.

A prova de fogo para saber se uma aplicação tem todas as configurações corretamente consignadas fora do código é saber se a base de código poderia ter seu código aberto ao público a qualquer momento, sem comprometer as credenciais.

Note que esta definição de “configuração” não inclui configuração interna da aplicação, como config/routes.rb em Rails, ou como módulos de códigos são conectados em Spring. Este tipo de configuração não varia entre deploys, e por isso é melhor que seja feito no código.

Outra abordagem para configuração é o uso de arquivos de configuração que não são versionados no controle de versão, como config/database.yml em Rails. Isto é uma grande melhoria sobre o uso de constantes que são versionadas no repositório do código, mas ainda tem pontos fracos: é fácil de colocar por engano um arquivo de configuração no repositório; há uma tendência para que os arquivos de configuração sejam espelhados em diferentes lugares e diferentes formatos, tornando-se difícil de ver e gerenciar todas as configurações em um só lugar. Além disso estes formatos tendem a ser específicos da linguagem ou framework.

A aplicação doze-fatores armazena configuração em variáveis de ambiente (muitas vezes abreviadas para env vars ou env). Env vars são fáceis de mudar entre deploys sem alterar qualquer código; ao contrário de arquivos de configuração, há pouca chance de serem colocados acidentalmente no repositório do código; e ao contrário dos arquivos de configuração personalizados, ou outros mecanismos de configuração como Propriedades do Sistema Java, eles são por padrão agnósticos a linguagem e ao SO.

Outro aspecto do gerenciamento de configuração é o agrupamento. Às vezes, as aplicações incluem a configuração em grupos nomeados (muitas vezes chamados de ambientes) que remetem a deploys específicos, tais como os ambientes development, test, e production em Rails. Este método não escala de forma limpa: quanto mais deploys da aplicação são criados, novos nomes de ambiente são necessários, tais como staging ou qa. A medida que o projeto cresce ainda mais, desenvolvedores podem adicionar seus próprios ambientes especiais como joes-staging, resultando em uma explosão combinatória de configurações que torna o gerenciamento de deploys da aplicação muito frágil.

Em uma aplicação doze-fatores, env vars são controles granulares, cada um totalmente ortogonal às outras env vars. Elas nunca são agrupadas como “environments”, mas em vez disso são gerenciadas independentemente para cada deploy. Este é um modelo que escala sem problemas à medida que o app naturalmente se expande em muitos deploys durante seu ciclo de vida.\n\n\n\nIII. Конфигурация

Сохраняйте конфигурацию в среде выполнения

Конфигурация приложения – это всё, что может меняться между развёртываниями (среда разработки, промежуточное и рабочее развёртывание). Это включает в себя:


Идентификаторы подключения к ресурсам типа базы данных, кэш-памяти и другим сторонним службам

Регистрационные данные для подключения к внешним сервисам, например, к Amazon S3 или Twitter

Значения зависимые от среды развёртывания такие, как каноническое имя хоста


Иногда приложения хранят конфигурации как константы в коде. Это нарушение методологии двенадцати факторов, которая требует строгого разделения конфигурации и кода. Конфигурация может существенно различаться между развёртываниями, код не должен различаться.

Лакмусовой бумажкой того, правильно ли разделены конфигурация и код приложения, является факт того, что кодовая база приложения может быть в любой момент открыта в свободный доступ без компрометации каких-либо приватных данных.

Обратите внимание, что это определение “конфигурации” не включает внутренние конфигурации приложения, например такие как ‘config/routes.rb’ в Rails, или того как основные модули будут связаны в Spring. Этот тип конфигурации не меняется между развёртываниями и поэтому лучше всего держать его в коде.

Другим подходом к конфигурации является использование конфигурационных файлов, которые не сохраняются в систему контроля версия, например ‘config/database.yml’ в Rails. Это огромное улучшение перед использованием констант, которые сохраняются в коде, но по-прежнему и у этого метода есть недостатки: легко по ошибке сохранить конфигурационный файл в репозиторий; существует тенденция когда конфигурационные файлы разбросаны в разных местах и в разных форматах, из за этого становится трудно просматривать и управлять всеми настройками в одном месте. Кроме того форматы этих файлов, как правило, специфичны для конкретного языка или фреймворка.

Приложение двенадцати факторов хранит конфигурацию в переменных окружения (часто сокращается до env vars или env). Переменные окружения легко изменить между развёртываниями, не изменяя код; в отличие от файлов конфигурации, менее вероятно случайно сохранить их в репозиторий кода; и в отличие от пользовательских конфигурационных файлов или других механизмов конфигурации, таких как Java System Properties, они являются независимым от языка и операционной системы стандартом.

Другим подходом к управлению конфигурациями является группировка. Иногда приложения группируют конфигурации в именованные группы (часто называемые “окружениями”) названые по названию конкретного развёртывания, например как development, test и production окружения в Rails. Этот метод не является достаточно масштабируемым: чем больше различных развёртываний приложения создаётся, тем больше новых имён окружений необходимо, например staging и qa. При дальнейшем росте проекта, разработчики могут добавлять свои собственные специальные окружения, такие как joes-staging, в результате происходит комбинаторный взрыв конфигураций, который делает управление развёртываниями приложения очень хрупким.

В приложении двенадцати факторов переменные окружения являются не связанными между собой средствами управления, где каждая переменная окружения полностью независима от других. Они никогда не группируются вместе в “окружения”, а вместо этого управляются независимо для каждого развёртывания. Эта модель которая масштабируется постепенно вместе с естественным появлением большего количества развёртываний приложения за время его жизни.\n\n\n\nIII. Konfigurácia

Konfigurácia uložená v prostredí

Konfigurácia aplikácie je všetko, čo sa líši medzi nasadeniami (staging, produkcia, vývojárske prostredie, atď). To zahŕňa:


Pripojenia k databázam, Memcached a iným podporným službám

Prihlasovacie údaje k externým službám ako Amazon S3 alebo Twitter

Špeciálne hodnotu Per-nasadenie values such ako napríklad kanonické názvy hostov.


Aplikácia si niekedy ukladá konštanty v kóde. Toto je porušenie dvanástich faktorov, ktoré vyžaduje striktné oddelenie konfigurácie od kódu. Konfigurácia sa medzi nasadeniami podstatne odlišuje, kód nie.

Litmusovým testom správneho oddelenia konfigurácie, je to či by mohla byť v ktoromkoľvek momente open-sourcovaná bez úniku prihlasovacích údajov.

Všimnite si, že definícia “konfigurácie” nezahŕňa internú konfiguráciu aplikácie, ako napríklad config/routes.rb v Rails, alebo prepojenie modulov v Spring. Tento typ konfigurácie sa medzi nasadeniami nelíši, a preto je najlepšie ho nechať v kóde.

Ďalšou možnosťou, ako pristupovať ku konfiguráciám je mať konfiguračné súbory, ktoré nie sú uložené v revíznom systéme, ako napríklad config/database.yml v Rails. Je to obrovské zlepšenie oproti konštantám uloženým v repozitári, ale stále má slabosť: je veľmi jednoduché omylom tento súbor uložiť do repozitára; je tendencia mať konfiguračné súbory na rôznych miestach a v rôznych formátoch, a preto je ťažké ich spravovať z jedného miesta. Navyše, tieto formáty zvyknú byť špecifické pre jazyk alebo framework.

Dvanásť faktorová aplikácia konfiguráciu ukladá v premenných prostredia (často skrátané na env vars alebo env). Premenné prostredia sa dajú jednoducho meniť pri nasadeniach bez potreby zmeny v kóde; na rozdiel od konfiguračných súborov je minimálna šanca, že ich niekto omylom uloží do repozitára; a narozdiel od rôznych konfiguračných súborov, alebo iných konfiguračných mechanizmov ako napr. Java System Properties, premenné prostredia sú nezávislé na jazyku alebo OS.

Ďalším pohľadom na správu konfigurácie je zoskupovanie. Niekedy aplikácie zoskupia konfigurácie do pomenovaných skupín (často nazývaných called “prostredia”) a sú pomenované podľa jednotlivých typov nasadení, ako napríklad development, test, a production prostredia v Rails. Tento spôsob je náročné škálovať čistým spôsobom: ako pribúdajú ďalšie typy nasadení, je potrebné vytvárať nové názvy prostredí, ako napríklad staging alebo qa. Ako projekt ďalej rastie, developeri môžu pridávať ďalšie vlastné špeciálne prostredia ako joes-staging, a výsledkom je kombinatorická explózia konfiguračných prostredí a tým sa stáva spravovanie nasadení veľmi citlivé.

V dvanásť faktorovej aplikácii sú premenné prostredia granulárne nastavenia, každé ortogonálne k inej premennej prostredia. Nikdy sa nezoskupujú spolu do pomenovaných “prostredí”, ale namiesto toho sú nezávisle spravované pre každé nasadenie. Tento model sa plynule škáluje počas prirodzeného rastu aplikácie ako pribúdajú ďalšie typy nasadení.\n\n\n\nIII. Config

จัดเก็บการตั้งค่า (config) ไว้ในสิ่งแวดล้อมของระบบ

การตั้งค่า (config) ของ app เป็นสิ่งที่เปลี่ยนแปลงระหว่าง deploys (staging, production, developer environments เป็นต้น) รวมทั้ง:


ทรัพยากรที่จัดการกับฐานข้อมูล, Memcached, และ backing services อื่นๆ

ข้อมูลประจำตัว (credentials) สำหรับบริการภายนอก อย่างเช่น Amazon S3 หรือ Twitter

ค่า Pre-deploy อย่างเช่น canonical hostname สำหรับ deploy


บางครั้ง app เก็บการตั้งค่าเป็นค่าคงทีใน code เป็นการละเมิด twelve-factor ซึ่งต้องการให้ แยกการตั้งค่าออกจาก code อย่างสมบูรณ์ การตั้งค่าสามารถเปลี่ยนแปลงได้ตาม deploy ที่ไม่อยู่ใน code

การทดสอบ litmus เพื่อดูว่า app มีการเอาการตั้งค่าทั้งหมดออกจาก code ถูกต้องหรือไม่ ทำให้ codebase สามารถ open source ได้ตลอดเวลา โดยไม่กระทบกับ credential ใดๆ

โปรดทราบว่าการนิยามนี้ของ “การตั้งค่า” ไม่รวมการตั้งค่า internal application อย่างเช่น config/routes.rb ใน Rails หรือ code modules เชื่อมต่อกันอย่างไร ใน Spring ชนิดของการตั้งค่าเหล่านี้ไม่เปลี่ยนแปลงตาม deploy และควรจะอยู่ใน code

อีกวิธีการหนึ่งของการตั้งค่าคือการใช้ไฟล์การตั้งค่าซึ่งไม่รวมไว้ใน revision control อย่างเช่น config/database.yml ใน Reals ซึ่งเป็นการพัฒนาสำหรับการใช้ค่าคงที่ซึ่งถูกรวมเข้าไปใน code repo แต่ก็ยังมีจุดอ่อนคือมันจะเกิดความผิดพลาดจากการที่รวมค่าการตั้งค่านี้เข้าไปใน repo จะทำให้มีแนวโน้มที่การไฟล์การตั้งค่าจะกระจายอยู่ในที่แตกต่างกันและแตกต่างรูปแบบ ทำให้มันยากที่จะดูแลและจัดการการตั้งค่าทั้งหมดในหนึ่งที่ นอกจากนี้รูปแบบเหล่านี้ยังขึ้นอยู่กับภาษาคอมพิวเตอร์ หรือ เฉพาะ framework.

Twelve-factor app เก็บการตั้งค่าไว้ใน environment variable (เรียกสั้นๆ ว่า env vars หรือ env) Env vars จะทำให้ง่ายที่จะเปลี่ยนแปลงระหว่าง deloy โดยปราศจากการเปลี่ยนแปลงของ code ใดๆ ไม่เหมือนกับไฟล์การตั้งค่าที่จะมีโอการผิดพลาดที่จะรวมเข้าไปใน code repo ได้ และไม่เหมือนกับไฟล์การตั้งค่าที่กำหนดเองหรือกลไกการตั้งค่าอื่นๆ อย่างเช่น Java System Properties ที่เป็ของภาษาคอมพิวเตอร์ และมาตรฐานของระบบปฏิบัติการ (OS-agnostic)

อีกแง่มุมของการจัดการการตั้งค่าคือการจัดกลุ่ม (Grouping) บางครั้งการตั้งค่า app แบบกลุ่ม (batch) ในชื่อของกลุ่ม (เรียกว่า “environment”) หลังจาก deploy เฉพาะ อย่างเช่น development, test และ production environment ใน Rails วิธีการนี้ทำให้การขยายไม่เรียบร้อยทำให้มี deploy ของ app ถูกสร้างมากขึ้น, จำเป็นต้องตั้งชื่อของ environment ใหม่ อย่างเช่น staging หรือ qa เป็นตั้น เมื่อ project โตขึ้น developer อาจจะเพิ่ม environments เฉพาะของตัวเองขึ้นมา เช่น joes-staging ผมก็คือมีการตั้งค่าจำนวนมากเกินไปซึ่งทำให้จัดการ deploy ของ app ทำได้ยากมาก

ใน twelve-factor app, env vars เป็นรากฐานการควบควมของแต่ล่ะ evn vars อื่นๆ ไม่เคยมีการจัดกลุ่มเป็น “environments” แต่จะจัดการแบบอิสระสำหรับแต่ล่ะ deploy แทน นี่เป็นรูปแบบที่การขยายทำได้อย่างราบรื่นของ app เป็นการขยายโดยธรรมชาติของ deploy มากขึ้นตลอดอายุการทำงานของ app.\n\n\n\nIII. Yapılandırma

Yapılandırma ayarlarını ortam değişkeni saklama

Bir uygulamanın yapılandırma ayarları dağıtımlar arasında farklı olma ihtimali olan her şeydir. Örneğin:


Veritabanlarının, önbellekleme servislerinin ve diğer yardımcı servislerin erişim bilgileri

Amazon S3 ve Twitter gibi dış servisler için kimlik bilgileri

Dağıtımlar için standart sunucu ismi gibi dağıtım-öncesi değerler


Uygulamalar bazen yapılandırma ayarlarını kod içerisinde saklar. Bu on iki faktörün, yapılandırmayı koddan mutlak ayrımını gerektiren kuralın ihlalidir. Yapılandırma ayarları dağıtımlar arasında değişir, ama kod değişmez.

Bir uygulamanın herhangi bir kimlik bilgisinin gizliliğini ihlal etmeden açık kaynak yapılabilip yapılamayacak olması, tüm yapılandırmaları koddan doğru bir biçimde çıkarılıp çıkarılmadığını belirleyebilecek bir litmus testidir.

Bu yapılandırma ayarı tanımının, Spring‘de kod modüllerinin bağlantısında olduğu gibi ve Rails’deki config/routes.rb gibi dahili uygulama yapılandırmasını içermediğini unutmayın. Bu tip yapılandırmalar, dağıtımlar arasında değişiklik göstermeyeceği için, kod içinde gerçekleştirilmeleri mantıklıdır.

Yapılandırmaya diğer bir yaklaşım da Rails’deki config/database.yml gibi dosyaların versiyon kontrol sistemine dahil edilmeden kullanımıdır. Bu, kod deposuna dahil edilmiş sabitler kullanmaya göre büyük bir gelişimdir, fakat hala zayıflıkları vardır: Bu dosyaların yanlışlıkla versiyon kontrol sistemine dahil edilme olasılığı oldukça yüksektir. Yapılandırma dosyalarının farklı yerlerde ve farklı formatlarda dağılmış olması eğilimi mevcuttur, ve bu durum bütün yapılandırmayı bir yerde görmeyi ve yönetmeyi zorlaştırır. Dahası, bu formatlar genelde dil veya çatı için özelleşmiştir.

On iki faktör uygulamalarında yapılandırma ortam değişkenlerinde kaydedilir (sıklıkla env vars veya env olarak kısaltılır). Ortam değişkenleri herhangi bir kod değişikliği olmadan, dağıtımlar arasında kolay değişebilir; Yapılandırma dosyalarının aksine, kod deposuna yanlışlıkla dahil edilme ihtimali düşüktür; ve özel yapılandırma dosyalarının veya Java sistem özellikleri gibi yapılandırma mekanizmalarının aksine, onlar dil ve işletim sisteminden etkilenmez.

Yapılandırma yönetiminin diğer bir açısı da gruplandırmadır. Bazen uygulamalar, Rails’deki geliştirme, test ve canlı ortamları gibi belirli dağıtımlardan sonra adlandırılmış gruplar içinde yapılandırılır. Bu yöntem temiz bir şekilde ölçeklenemez. Çünkü uygulamanın daha fazla dağıtımı oluştukça, yeni ortam isimleri gerekli olur, staging veya qa gibi. Projeler ilerde geliştikçe, geliştiriciler joes-staging kendi özel ortam değişkenlerini ekleyebilir. Bu da yapılandırma dosyalarının hızla artmasıyla sonuçlanarak dağıtım yönetimini oldukça kırılganlaştırır.

On iki faktör uygulamasında ortam değişkenleri parçacıklı kontrol edilirler, birbirlerinden bağımsızlardır. Asla gruplandırılmazlar, onun yerine her bir dağıtım için bağımsız olarak yönetilirler. Bu, uygulamayı yaşam süresi boyunca daha fazla dağıtıma genişletmeyi sorunsuzca ölçeklendiren bir modeldir.\n\n\n\nIII. Конфігурація

Зберігайте конфігурацію в середовищі виконання

Конфігурація застосунку — це все, що може змінюватися між розгортаннями (staging-розгортання, production-розгортання, локальне середовище розробника тощо). Це включає:


Параметри підключення до бази даних, Memcached і інших сторонніх сервісів;

Реєстраційні дані для підключення до зовнішніх сервісів, таких як Amazon S3 або Twitter;

Значення, що залежать від середовища розгортання, такі як канонічне ім’я хосту.


Застосунки іноді зберігають конфігурації як константи в коді. Це є порушенням методології дванадцяти факторів, яка вимагає обов’язкового відокремлення конфігурації від коду. Конфігурації застосунку в розгортаннях суттєво відрізняються, код — однаковий.

Лакмусовим папірцем того, чи правильно розділені конфігурація і код, є можливість в будь-який момент відкрити вихідний код застосунку у вільний доступ, при цьому не оприлюднюючи будь-яких приватних даних.

Зверніть увагу, що визначення “конфігурації” не включає в себе внутрішні налаштування застосунку, такі як сonfig/routes.rb в Rails, або як пов’язані основні модулі в Spring. Ці налаштування не змінюються між розгортаннями, і тому краще місце для них — саме в коді.

Іншим підходом до конфігурації є використання конфігураційних файлів, що не зберігаються в систему контролю версій, таких як сonfig/database.yml в Rails. Це перевага у порівнянні з використанням констант в коді, але все ж таки має суттєві недоліки: є ймовірність помилково зберегти файл конфігурації в репозиторій; існує тенденція коли конфігураційні файли розкидані в різних місцях і в різних форматах, і стає важко передивлятися всі налаштування і керувати ними в одному місці. Крім того, формати цих файлів, як правило, специфічні для конкретної мови програмування чи фреймворку.

Застосунок дванадцати факторів зберігає конфігурацію в змінних оточення (часто скорочується до env vars або env). Значення змінних оточення легко змінити між розгортаннями без зміни коду; на відміну від конфігураційних файлів, менш ймовірно випадково зберегти їх в репозиторій коду; і на відміну від конфігураційних файлів або інших механізмів конфігурації, таких як Java System Properties, вони є стандартом, незалежним від мови програмування чи фреймворку.

Іншим аспектом керування конфігурацією є групування. Іноді застосунки об’єднують конфігурації в іменовані групи (які часто називаються “оточеннями”), які називаються в залежності від конкретного розгортання, наприклад, development, test і production оточення в Rails. Цей метод погано масштабується: чим більше створюється різних розгортань застосунку, тим більше необхідно нових імен оточень, наприклад, staging або qa. При подальшому рості проекту розробники можуть додавати свої власні спеціальні оточення, наприклад, joes-staging, що призводить до комбінаторного вибуху конфігурації, який робить керування розгортанням застосунку нестабільним.

У застосунку дванадцяти факторів змінні оточення є незв’язаними між собою засобами керування. Кожна змінна повністю незалежна від інших. Вони ніколи не групуються разом в “оточення”, керування ними здійснюється незалежно для кожного розгортання. Ця модель добре масштабується разом з появою більшої кількості розгортань застосунку протягом його експлуатації.\n\n\n\nIII. Cấu hình

Lưu trữ cấu hình trong môi trường

Cấu hình của ứng dụng là những thứ có thể thay đổi qua các triển khai (hệ thống thử, hệ thống sản xuất, môi trường phát triển, etc). Nó bao gồm: * Tài nguyên xử lý cơ sở dữ liệu, Memcached, và dịch vụ lớp dưới khác * Thông tin đăng nhập đến các dịch vụ như là Amazon S3 hay Twitter * Các giá trị ứng với từng triển khai như như là tên của máy chủ để triển khai

Các ứng dụng thường lưu trữ các cấu hình như là hằng số trong mã nguồn. Điều này không phù hợp với nguyên tắc của 12-thừa số, yêu cầu giới hạn tách biệt các cấu hình khỏi mã nguồn. Các cấu hình thay đổi qua các triển khai, mã nguồn thì không.

Một litmus test cho ứng dụng có các cấu hình được thừa số hoá chính xác là mã gốc có khả năng nguồn mở hoá bất kỳ lúc nào mà không lo sợ bị mất các thông tin đăng nhập.

Chú ý rằng, định nghĩa của “cấu hình” không bao gồm các cấu hình nội tại của ứng dụng, như là config/routes.rb trong Rails, hoặc các thành phần được kết nối trong Spring. Những cấu hình kiểu này thường không thay đổi giữa các triển khai, và do đó đã thực hiện tốt trong mã nguồn.

Một cách tiếp cận khác với các cấu hình là việc sử dụng tệp tin cấu hình mà tệp tin đó không được quản lý phiên bản, như là config/database.yml trong Rails. Đây là một cải tiến lớn so với việc sử dụng hằng số trong mã nguồn đã được quản lý phiên bản, nhưng vẫn có điểm yếu: dễ bị thêm nhầm vào quản lý phiên bản, các tệp tin cấu hình dễ bị phân tán ở những nơi khác nhau và các định dạng khác nhau, làm cho nó trở nên khó đọc và quản lý tất các cấu hỉnh một cách tập trung. Ngoài ra, định dạng của các tệp tin chứa cấu hình thường do đặc tả của ngôn ngữ- hoặc framework-.

Ứng dụng áp dụng mười hai thừa số chứa các cấu hình trong environment variables (biến môi trường) (thường viết tắt là env vars hoặc env). Các biến môi trường rất dễ để thay đổi giữa các triển khai mà không phải thay đổi mã nguồn; không giống như tệp tin cấu hình, vẫn có khả năng để bị thêm vào kho mã (code repository); và không giống như các tệp tin cấu hình tuỳ chỉnh, hoặc cơ chế quảnl lý cấu hình như là Java System Properties, các biến môi trường là agnostic standard theo ngôn ngữ và hệ điều hành.

Một khía cạnh khác của quản lý cấu hình là nhóm các cấu hình. Đôi khi, các ứng dụng tổ chức các cấu hình theo nhóm (thường được gọi là “các môi trường”) được đặt tên theo các triển khai, như là các môi trườngdevelopment, test, and production trong Rails. Phương pháp này không mở rộng rõ ràng: nếu như có nhiều triển khải của ứng dụng được tạo ra, tên của các môi trường rất quan trọng, như là staging hoặc qa. Nếu một dự án phát triển sau này, lập trình viên có thể thêm các môi trường của riêng họ như là joes-staging, kết quả là một sự bùng nổ về các cấu hình, làm cho việc quản lý các triển khai trở nên không ổn định.

Trong một ứng dụng áp dụng mười hai thừa số, các biến môi trường được quản lý chi tiết, hoàn toàn độc lập với các biến môi trường khác. Chúng không được nhóm với nhau như là các “môi trường”, nhưng thay vào đó được quản lý độc lập theo các triển khai. Mô hình này giúp cho việc mở rộng trở nên trơn tru như là việc thêm vào các triển khai theo vòng đời của phần mềm được mở rộng một cách tự nhiên.\n\n\n\nIII. 配置

在环境中存储配置

通常，应用的 配置 在不同 部署 (预发布、生产环境、开发环境等等)间会有很大差异。这其中包括：


数据库，Memcached，以及其他 后端服务 的配置

第三方服务的证书，如 Amazon S3、Twitter 等

每份部署特有的配置，如域名等


有些应用在代码中使用常量保存配置，这与 12-Factor 所要求的代码和配置严格分离显然大相径庭。配置文件在各部署间存在大幅差异，代码却完全一致。

判断一个应用是否正确地将配置排除在代码之外，一个简单的方法是看该应用的基准代码是否可以立刻开源，而不用担心会暴露任何敏感的信息。

需要指出的是，这里定义的“配置”并不包括应用的内部配置，比如 Rails 的 config/routes.rb，或是使用 Spring 时 代码模块间的依赖注入关系 。这类配置在不同部署间不存在差异，所以应该写入代码。

另外一个解决方法是使用配置文件，但不把它们纳入版本控制系统，就像 Rails 的 config/database.yml 。这相对于在代码中使用常量已经是长足进步，但仍然有缺点：总是会不小心将配置文件签入了代码库；配置文件的可能会分散在不同的目录，并有着不同的格式，这让找出一个地方来统一管理所有配置变的不太现实。更糟的是，这些格式通常是语言或框架特定的。

12-Factor推荐将应用的配置存储于 环境变量 中（ env vars, env ）。环境变量可以非常方便地在不同的部署间做修改，却不动一行代码；与配置文件不同，不小心把它们签入代码库的概率微乎其微；与一些传统的解决配置问题的机制（比如 Java 的属性配置文件）相比，环境变量与语言和系统无关。

配置管理的另一个方面是分组。有时应用会将配置按照特定部署进行分组（或叫做“环境”），例如Rails中的 development,test, 和 production 环境。这种方法无法轻易扩展：更多部署意味着更多新的环境，例如 staging 或 qa 。 随着项目的不断深入，开发人员可能还会添加他们自己的环境，比如 joes-staging ，这将导致各种配置组合的激增，从而给管理部署增加了很多不确定因素。

12-Factor 应用中，环境变量的粒度要足够小，且相对独立。它们永远也不会组合成一个所谓的“环境”，而是独立存在于每个部署之中。当应用程序不断扩展，需要更多种类的部署时，这种配置管理方式能够做到平滑过渡。\n\n\n\nII. Dependencies

Explicitly declare and isolate dependencies

Most programming languages offer a packaging system for distributing support libraries, such as CPAN for Perl or Rubygems for Ruby. Libraries installed through a packaging system can be installed system-wide (known as “site packages”) or scoped into the directory containing the app (known as “vendoring” or “bundling”).

A twelve-factor app never relies on implicit existence of system-wide packages. It declares all dependencies, completely and exactly, via a dependency declaration manifest. Furthermore, it uses a dependency isolation tool during execution to ensure that no implicit dependencies “leak in” from the surrounding system. The full and explicit dependency specification is applied uniformly to both production and development.

For example, Bundler for Ruby offers the Gemfile manifest format for dependency declaration and bundle exec for dependency isolation. In Python there are two separate tools for these steps – Pip is used for declaration and Virtualenv for isolation. Even C has Autoconf for dependency declaration, and static linking can provide dependency isolation. No matter what the toolchain, dependency declaration and isolation must always be used together – only one or the other is not sufficient to satisfy twelve-factor.

One benefit of explicit dependency declaration is that it simplifies setup for developers new to the app. The new developer can check out the app’s codebase onto their development machine, requiring only the language runtime and dependency manager installed as prerequisites. They will be able to set up everything needed to run the app’s code with a deterministic build command. For example, the build command for Ruby/Bundler is bundle install, while for Clojure/Leiningen it is lein deps.

Twelve-factor apps also do not rely on the implicit existence of any system tools. Examples include shelling out to ImageMagick or curl. While these tools may exist on many or even most systems, there is no guarantee that they will exist on all systems where the app may run in the future, or whether the version found on a future system will be compatible with the app. If the app needs to shell out to a system tool, that tool should be vendored into the app.\n\n\n\nIII. Config

Store config in the environment

An app’s config is everything that is likely to vary between deploys (staging, production, developer environments, etc). This includes:


Resource handles to the database, Memcached, and other backing services

Credentials to external services such as Amazon S3 or Twitter

Per-deploy values such as the canonical hostname for the deploy


Apps sometimes store config as constants in the code. This is a violation of twelve-factor, which requires strict separation of config from code. Config varies substantially across deploys, code does not.

A litmus test for whether an app has all config correctly factored out of the code is whether the codebase could be made open source at any moment, without compromising any credentials.

Note that this definition of “config” does not include internal application config, such as config/routes.rb in Rails, or how code modules are connected in Spring. This type of config does not vary between deploys, and so is best done in the code.

Another approach to config is the use of config files which are not checked into revision control, such as config/database.yml in Rails. This is a huge improvement over using constants which are checked into the code repo, but still has weaknesses: it’s easy to mistakenly check in a config file to the repo; there is a tendency for config files to be scattered about in different places and different formats, making it hard to see and manage all the config in one place. Further, these formats tend to be language- or framework-specific.

The twelve-factor app stores config in environment variables (often shortened to env vars or env). Env vars are easy to change between deploys without changing any code; unlike config files, there is little chance of them being checked into the code repo accidentally; and unlike custom config files, or other config mechanisms such as Java System Properties, they are a language- and OS-agnostic standard.

Another aspect of config management is grouping. Sometimes apps batch config into named groups (often called “environments”) named after specific deploys, such as the development, test, and production environments in Rails. This method does not scale cleanly: as more deploys of the app are created, new environment names are necessary, such as staging or qa. As the project grows further, developers may add their own special environments like joes-staging, resulting in a combinatorial explosion of config which makes managing deploys of the app very brittle.

In a twelve-factor app, env vars are granular controls, each fully orthogonal to other env vars. They are never grouped together as “environments”, but instead are independently managed for each deploy. This is a model that scales up smoothly as the app naturally expands into more deploys over its lifetime.\n\n\n\nV. Build, release, run

Strictly separate build and run stages

A codebase is transformed into a (non-development) deploy through three stages:


The build stage is a transform which converts a code repo into an executable bundle known as a build. Using a version of the code at a commit specified by the deployment process, the build stage fetches vendors dependencies and compiles binaries and assets.

The release stage takes the build produced by the build stage and combines it with the deploy’s current config. The resulting release contains both the build and the config and is ready for immediate execution in the execution environment.

The run stage (also known as “runtime”) runs the app in the execution environment, by launching some set of the app’s processes against a selected release.




The twelve-factor app uses strict separation between the build, release, and run stages. For example, it is impossible to make changes to the code at runtime, since there is no way to propagate those changes back to the build stage.

Deployment tools typically offer release management tools, most notably the ability to roll back to a previous release. For example, the Capistrano deployment tool stores releases in a subdirectory named releases, where the current release is a symlink to the current release directory. Its rollback command makes it easy to quickly roll back to a previous release.

Every release should always have a unique release ID, such as a timestamp of the release (such as 2011-04-06-20:32:17) or an incrementing number (such as v100). Releases are an append-only ledger and a release cannot be mutated once it is created. Any change must create a new release.

Builds are initiated by the app’s developers whenever new code is deployed. Runtime execution, by contrast, can happen automatically in cases such as a server reboot, or a crashed process being restarted by the process manager. Therefore, the run stage should be kept to as few moving parts as possible, since problems that prevent an app from running can cause it to break in the middle of the night when no developers are on hand. The build stage can be more complex, since errors are always in the foreground for a developer who is driving the deploy.\n\n\n\nVI. Processes

Execute the app as one or more stateless processes

The app is executed in the execution environment as one or more processes.

In the simplest case, the code is a stand-alone script, the execution environment is a developer’s local laptop with an installed language runtime, and the process is launched via the command line (for example, python my_script.py). On the other end of the spectrum, a production deploy of a sophisticated app may use many process types, instantiated into zero or more running processes.

Twelve-factor processes are stateless and share-nothing. Any data that needs to persist must be stored in a stateful backing service, typically a database.

The memory space or filesystem of the process can be used as a brief, single-transaction cache. For example, downloading a large file, operating on it, and storing the results of the operation in the database. The twelve-factor app never assumes that anything cached in memory or on disk will be available on a future request or job – with many processes of each type running, chances are high that a future request will be served by a different process. Even when running only one process, a restart (triggered by code deploy, config change, or the execution environment relocating the process to a different physical location) will usually wipe out all local (e.g., memory and filesystem) state.

Asset packagers like django-assetpackager use the filesystem as a cache for compiled assets. A twelve-factor app prefers to do this compiling during the build stage. Asset packagers such as Jammit and the Rails asset pipeline can be configured to package assets during the build stage.

Some web systems rely on “sticky sessions” – that is, caching user session data in memory of the app’s process and expecting future requests from the same visitor to be routed to the same process. Sticky sessions are a violation of twelve-factor and should never be used or relied upon. Session state data is a good candidate for a datastore that offers time-expiration, such as Memcached or Redis.\n\n\n\nVII. Port binding

Export services via port binding

Web apps are sometimes executed inside a webserver container. For example, PHP apps might run as a module inside Apache HTTPD, or Java apps might run inside Tomcat.

The twelve-factor app is completely self-contained and does not rely on runtime injection of a webserver into the execution environment to create a web-facing service. The web app exports HTTP as a service by binding to a port, and listening to requests coming in on that port.

In a local development environment, the developer visits a service URL like http://localhost:5000/ to access the service exported by their app. In deployment, a routing layer handles routing requests from a public-facing hostname to the port-bound web processes.

This is typically implemented by using dependency declaration to add a webserver library to the app, such as Tornado for Python, Thin for Ruby, or Jetty for Java and other JVM-based languages. This happens entirely in user space, that is, within the app’s code. The contract with the execution environment is binding to a port to serve requests.

HTTP is not the only service that can be exported by port binding. Nearly any kind of server software can be run via a process binding to a port and awaiting incoming requests. Examples include ejabberd (speaking XMPP), and Redis (speaking the Redis protocol).

Note also that the port-binding approach means that one app can become the backing service for another app, by providing the URL to the backing app as a resource handle in the config for the consuming app.\n\n\n\nVIII. Concurrency

Scale out via the process model

Any computer program, once run, is represented by one or more processes. Web apps have taken a variety of process-execution forms. For example, PHP processes run as child processes of Apache, started on demand as needed by request volume. Java processes take the opposite approach, with the JVM providing one massive uberprocess that reserves a large block of system resources (CPU and memory) on startup, with concurrency managed internally via threads. In both cases, the running process(es) are only minimally visible to the developers of the app.



In the twelve-factor app, processes are a first class citizen. Processes in the twelve-factor app take strong cues from the unix process model for running service daemons. Using this model, the developer can architect their app to handle diverse workloads by assigning each type of work to a process type. For example, HTTP requests may be handled by a web process, and long-running background tasks handled by a worker process.

This does not exclude individual processes from handling their own internal multiplexing, via threads inside the runtime VM, or the async/evented model found in tools such as EventMachine, Twisted, or Node.js. But an individual VM can only grow so large (vertical scale), so the application must also be able to span multiple processes running on multiple physical machines.

The process model truly shines when it comes time to scale out. The share-nothing, horizontally partitionable nature of twelve-factor app processes means that adding more concurrency is a simple and reliable operation. The array of process types and number of processes of each type is known as the process formation.

Twelve-factor app processes should never daemonize or write PID files. Instead, rely on the operating system’s process manager (such as systemd, a distributed process manager on a cloud platform, or a tool like Foreman in development) to manage output streams, respond to crashed processes, and handle user-initiated restarts and shutdowns.\n\n\n\nIX. Disposability

Maximize robustness with fast startup and graceful shutdown

The twelve-factor app’s processes are disposable, meaning they can be started or stopped at a moment’s notice. This facilitates fast elastic scaling, rapid deployment of code or config changes, and robustness of production deploys.

Processes should strive to minimize startup time. Ideally, a process takes a few seconds from the time the launch command is executed until the process is up and ready to receive requests or jobs. Short startup time provides more agility for the release process and scaling up; and it aids robustness, because the process manager can more easily move processes to new physical machines when warranted.

Processes shut down gracefully when they receive a SIGTERM signal from the process manager. For a web process, graceful shutdown is achieved by ceasing to listen on the service port (thereby refusing any new requests), allowing any current requests to finish, and then exiting. Implicit in this model is that HTTP requests are short (no more than a few seconds), or in the case of long polling, the client should seamlessly attempt to reconnect when the connection is lost.

For a worker process, graceful shutdown is achieved by returning the current job to the work queue. For example, on RabbitMQ the worker can send a NACK; on Beanstalkd, the job is returned to the queue automatically whenever a worker disconnects. Lock-based systems such as Delayed Job need to be sure to release their lock on the job record. Implicit in this model is that all jobs are reentrant, which typically is achieved by wrapping the results in a transaction, or making the operation idempotent.

Processes should also be robust against sudden death, in the case of a failure in the underlying hardware. While this is a much less common occurrence than a graceful shutdown with SIGTERM, it can still happen. A recommended approach is use of a robust queueing backend, such as Beanstalkd, that returns jobs to the queue when clients disconnect or time out. Either way, a twelve-factor app is architected to handle unexpected, non-graceful terminations. Crash-only design takes this concept to its logical conclusion.\n\n\n\nX. Dev/prod parity

Keep development, staging, and production as similar as possible

Historically, there have been substantial gaps between development (a developer making live edits to a local deploy of the app) and production (a running deploy of the app accessed by end users). These gaps manifest in three areas:


The time gap: A developer may work on code that takes days, weeks, or even months to go into production.

The personnel gap: Developers write code, ops engineers deploy it.

The tools gap: Developers may be using a stack like Nginx, SQLite, and OS X, while the production deploy uses Apache, MySQL, and Linux.


The twelve-factor app is designed for continuous deployment by keeping the gap between development and production small. Looking at the three gaps described above:


Make the time gap small: a developer may write code and have it deployed hours or even just minutes later.

Make the personnel gap small: developers who wrote code are closely involved in deploying it and watching its behavior in production.

Make the tools gap small: keep development and production as similar as possible.


Summarizing the above into a table:

  
    
    Traditional app
    Twelve-factor app
  
  
    Time between deploys
    Weeks
    Hours
  
  
    Code authors vs code deployers
    Different people
    Same people
  
  
    Dev vs production environments
    Divergent
    As similar as possible
  

Backing services, such as the app’s database, queueing system, or cache, is one area where dev/prod parity is important. Many languages offer libraries which simplify access to the backing service, including adapters to different types of services. Some examples are in the table below.

  
    Type
    Language
    Library
    Adapters
  
  
    Database
    Ruby/Rails
    ActiveRecord
    MySQL, PostgreSQL, SQLite
  
  
    Queue
    Python/Django
    Celery
    RabbitMQ, Beanstalkd, Redis
  
  
    Cache
    Ruby/Rails
    ActiveSupport::Cache
    Memory, filesystem, Memcached
  

Developers sometimes find great appeal in using a lightweight backing service in their local environments, while a more serious and robust backing service will be used in production. For example, using SQLite locally and PostgreSQL in production; or local process memory for caching in development and Memcached in production.

The twelve-factor developer resists the urge to use different backing services between development and production, even when adapters theoretically abstract away any differences in backing services. Differences between backing services mean that tiny incompatibilities crop up, causing code that worked and passed tests in development or staging to fail in production. These types of errors create friction that disincentivizes continuous deployment. The cost of this friction and the subsequent dampening of continuous deployment is extremely high when considered in aggregate over the lifetime of an application.

Lightweight local services are less compelling than they once were. Modern backing services such as Memcached, PostgreSQL, and RabbitMQ are not difficult to install and run thanks to modern packaging systems, such as Homebrew and apt-get. Alternatively, declarative provisioning tools such as Chef and Puppet combined with light-weight virtual environments such as Docker and Vagrant allow developers to run local environments which closely approximate production environments. The cost of installing and using these systems is low compared to the benefit of dev/prod parity and continuous deployment.

Adapters to different backing services are still useful, because they make porting to new backing services relatively painless. But all deploys of the app (developer environments, staging, production) should be using the same type and version of each of the backing services.\n\n\n\nXI. Logs

Treat logs as event streams

Logs provide visibility into the behavior of a running app. In server-based environments they are commonly written to a file on disk (a “logfile”); but this is only an output format.

Logs are the stream of aggregated, time-ordered events collected from the output streams of all running processes and backing services. Logs in their raw form are typically a text format with one event per line (though backtraces from exceptions may span multiple lines). Logs have no fixed beginning or end, but flow continuously as long as the app is operating.

A twelve-factor app never concerns itself with routing or storage of its output stream. It should not attempt to write to or manage logfiles. Instead, each running process writes its event stream, unbuffered, to stdout. During local development, the developer will view this stream in the foreground of their terminal to observe the app’s behavior.

In staging or production deploys, each process’ stream will be captured by the execution environment, collated together with all other streams from the app, and routed to one or more final destinations for viewing and long-term archival. These archival destinations are not visible to or configurable by the app, and instead are completely managed by the execution environment. Open-source log routers (such as Logplex and Fluentd) are available for this purpose.

The event stream for an app can be routed to a file, or watched via realtime tail in a terminal. Most significantly, the stream can be sent to a log indexing and analysis system such as Splunk, or a general-purpose data warehousing system such as Hadoop/Hive. These systems allow for great power and flexibility for introspecting an app’s behavior over time, including:


Finding specific events in the past.

Large-scale graphing of trends (such as requests per minute).

Active alerting according to user-defined heuristics (such as an alert when the quantity of errors per minute exceeds a certain threshold).\n\n\n\nXII. Admin processes

Run admin/management tasks as one-off processes

The process formation is the array of processes that are used to do the app’s regular business (such as handling web requests) as it runs. Separately, developers will often wish to do one-off administrative or maintenance tasks for the app, such as:


Running database migrations (e.g. manage.py migrate in Django, rake db:migrate in Rails).

Running a console (also known as a REPL shell) to run arbitrary code or inspect the app’s models against the live database. Most languages provide a REPL by running the interpreter without any arguments (e.g. python or perl) or in some cases have a separate command (e.g. irb for Ruby, rails console for Rails).

Running one-time scripts committed into the app’s repo (e.g. php scripts/fix_bad_records.php).


One-off admin processes should be run in an identical environment as the regular long-running processes of the app. They run against a release, using the same codebase and config as any process run against that release. Admin code must ship with application code to avoid synchronization issues.

The same dependency isolation techniques should be used on all process types. For example, if the Ruby web process uses the command bundle exec thin start, then a database migration should use bundle exec rake db:migrate. Likewise, a Python program using Virtualenv should use the vendored bin/python for running both the Tornado webserver and any manage.py admin processes.

Twelve-factor strongly favors languages which provide a REPL shell out of the box, and which make it easy to run one-off scripts. In a local deploy, developers invoke one-off admin processes by a direct shell command inside the app’s checkout directory. In a production deploy, developers can use ssh or other remote command execution mechanism provided by that deploy’s execution environment to run such a process.\n\n\n\nÚvod

V moderní době je software často dodáván jako služba, což označujeme pojmem webová aplikace nebo software-as-a-service (SaaS). Twelve-factor metodika slouží pro vytváření (SaaS) aplikací, které:


Používají deklarativní formáty pro nastavení automatizace, což vede k minimalizaci času a nákladů potřebných pro začlenění nových vývojářů do projektu;

Mají jasný kontrakt s operačním systémem ve kterém běží, čímž je umožněna maximální přenositelnost mezi různými běhovými prostředími;

Jsou vhodné pro nasazení na moderních cloudových platformách, což eliminuje potřebu správy serverů a podpůrných systémů;

Minimalizují rozdíly mezi vývojovým a produkčním prostředím, čímž umožňují průběžné nasazovaní a maximální flexibilitu;

Umožňují vyškálování bez výrazných změn v nástrojích, architektuře nebo vývojových postupech.


Twelve-factor metodiku lze použít na aplikace napsané v jakémkoliv programovacím jazyce a používající libovolnou kombinaci podpůrných služeb (databáze, fronty, vyrovnávací paměť atd.).

Pozadí

Přispěvatelé tohoto dokumentu se přímo podíleli na vývoji a nasazení stovek aplikací a byli svědky vývoje, provozu a škálování stovek tisíc aplikací prostřednictvím své práce na platformě Heroku.

Tento dokument shromažďuje všechny naše zkušenosti a postřehy týkající se široké škály aplikací typu software-as-a-service v divočině. Jedná se o sadu ideálních postupů pro vývoj aplikací se zvláštní pozorností věnovanou dynamice organického růstu aplikace v průběhu času, dynamice spolupráce mezi vývojáři pracujícími na kódu aplikace a vyhýbání se nákladům na erozi softwaru.

Naší motivací je zvyšovat povědomí o některých systémových problémech, které jsme zaznamenali v moderním vývoji aplikací, poskytnout společnou slovní zásobu pro diskusi o těchto problémech a nabídnout rozsáhlou sadu koncepčních řešení těchto problémů s doprovodnou terminologií. Formát je inspirován knihami Martina Fowlera Patterns of Enterprise Application Architecture a Refactoring.

Kdo by měl číst tento dokument?

Každý vývojář pracující na aplikaci, která běží jako služba. Systémoví inženýři, kteří takové aplikace nasazují nebo spravují.

The Twelve Factors

I. Zdrojový kód

Mějte jeden zdrojový kód ve verzovacím systému a mnoho nasazení.

II. Závislosti

Explicitně deklarujte a izololujte závislosti.

III. Konfigurace

Konfigurace ukládejte do prostředí.

IV. Podpůrné služby

Nakládejte s podpůrnými službami jako s připojenými zdroji.

V. Sestavení, vydání, spuštění

Striktně oddělte fáze sestavení, vydání a spuštění.

VI. Procesy

Spouštějte aplikaci jako jeden nebo více bezestavových procesů.

VII. Vazba s portem

Exportujte služby pomocí vazby na port.

VIII. Souběh

Škálujte do šířky použitím proces modelu.

IX. Zahoditelnost

Maximalizujte robustnost pomocí rychlého spouštění a korektního vypnutí.

X. Podobnost Vývoj/Produkce

Udržujte si co nejmenší rozdíly mezi vývojovým, testovacím a produkčním prostředím.

XI. Logy

S logy zacházejte jako s proudy událostí.

XII. Admin procesy

Spouštějte administrativní úlohy jako jednorázové procesy.\n\n\n\nEinführung

Heute wird Software oft als Dienst geliefert - auch Web App oder Software-As-A-Service genannt. Die Zwölf-Faktoren-App ist eine Methode um Software-As-A-Service Apps zu bauen die:


deklarative Formate benutzen für die Automatisierung der Konfiguration, um Zeit und Kosten für neue Entwickler im Projekt zu minimieren;

einen sauberen Vertrag mit dem zugrundeliegenden Betriebssystem haben, maximale Portierbarkeit zwischen Ausführungsumgebungen bieten;

sich für das Deployment auf modernen Cloud-Plattformen eignen, die Notwendigkeit von Servern und Serveradministration vermeiden;

die Abweichung minimieren zwischen Entwicklung und Produktion, um Continuous Deployment für maximale Agilität ermöglichen;

und skalieren können ohne wesentliche Änderungen im Tooling, in der Architektur oder in den Entwicklungsverfahren.


Die Zwölf-Faktoren-Methode kann auf Apps angewendet werden, die in einer beliebigen Programmiersprache geschrieben sind, und die eine beliebige Kombination von unterstützenden Diensten benutzen (Datenbank, Queue, Cache, …)

Hintergrund

Die Mitwirkenden an diesem Dokument waren direkt beteiligt an der Entwicklung und dem Deployment von hunderten von Apps und wurden Zeugen bei der Entwicklung, beim Betrieb und der Skalierung von hunderttausenden von Apps im Rahmen unserer Arbeit an der Heroku-Plattform.

Dieses Dokument ist eine Synthese all unserer Erfahrungen und der Beobachtungen einer großen Bandbreite von Software-As-A-Service Apps. Es ist eine Bestimmung der idealen Praktiken bei der App-Entwicklung mit besonderem Augenmerk auf die Dynamik des organischen Wachstums einer App über die Zeit, die Dynamik der Zusammenarbeit zwischen den Entwicklern die an einer Codebase zusammenarbeiten und der Vermeidung der Kosten von Software-Erosion.

Unsere Motivation ist, das Bewusstsein zu schärfen für systembedingte Probleme in der aktuellen Applikationsentwicklung, ein gemeinsames Vokabular zur Diskussion dieser Probleme zu liefern und ein Lösungsportfolio zu diesen Problemen mit einer zugehörigen Terminologie anzubieten. Das Format ist angelehnt an Martin Fowlers Bücher Patterns of Enterprise Application Architecture und Refactoring.

Wer sollte dieses Dokument lesen?

Jeder Entwickler der Apps baut, die als Dienst laufen. Administratoren, die solche Apps managen oder deployen.

Die zwölf Faktoren

I. Codebase

Eine im Versionsmanagementsystem verwaltete Codebase, viele Deployments

II. Abhängigkeiten

Abhängigkeiten explizit deklarieren und isolieren

III. Konfiguration

Die Konfiguration in Umgebungsvariablen ablegen

IV. Unterstützende Dienste

Unterstützende Dienste als angehängte Ressourcen behandeln

V. Build, release, run

Build- und Run-Phase strikt trennen

VI. Prozesse

Die App als einen oder mehrere Prozesse ausführen

VII. Bindung an Ports

Dienste durch das Binden von Ports exportieren

VIII. Nebenläufigkeit

Mit dem Prozess-Modell skalieren

IX. Einweggebrauch

Robuster mit schnellem Start und problemlosen Stopp

X. Dev-Prod-Vergleichbarkeit

Entwicklung, Staging und Produktion so ähnlich wie möglich halten

XI. Logs

Logs als Strom von Ereignissen behandeln

XII. Admin-Prozesse

Admin/Management-Aufgaben als einmalige Vorgänge behandeln\n\n\n\nΕισαγωγή

Στη μοντέρνα εποχή, το λογισμικό συνήθως παρέχεται ως υπηρεσία: καλούμενο εφαρμογές ιστού (web apps), ή λογισμικό-ως-υπηρεσία (software-as-a-service). Η εφαρμογή δώδεκα παραγόντων είναι μια μεθοδολογία κατασκευής εφαρμογών λογισμικού-ως-υπηρεσίας όπου:


Χρησιμοποιεί δηλωτικές μορφές (declarative formats) για να στήσει τον αυτοματισμό, να ελαχιστοποιήσει το χρόνο και το κόστος για νέους προγραμματιστές να συμμετέχουν στο έργο,

Έχει ένα καθαρό συμβόλαιο (clean contract) με το υποκείμενο λειτουργικό σύστημα, προσφέροντας μέγιστη φορητότητα (maximum portability) μεταξύ περιβαλλόντων εκτέλεσης,

Είναι κατάλληλη για ανάπτυξη (deployment) σε μοντέρνες πλατφόρμες υπολογιστικού νέφους (cloud platforms), καθιστώντας περιττή την ανάγκη για εξυπηρετητές και διαχείριση συστημάτων,

Ελαχιστοποιεί την απόκλιση μεταξύ υλοποίησης (development) και παραγωγής (production), διευκολύνοντας την συνεχή ανάπτυξη (continuous deployment) για μέγιστη ευκινησία (maximum agility),

Και μπορεί να κλιμακωθεί προς τα πάνω (scale up) χωρίς σημαντικές αλλαγές στα εργαλεία, στην αρχιτεκτονική, ή στις πρακτικές υλοποίησης.


Η μεθοδολογία δώδεκα παραγόντων μπορεί να εφαρμοστεί σε εφαρμογές οι οποίες είναι γραμμένες σε οποιαδήποτε γλώσσα προγραμματισμού, και οι οποίες χρησιμοποιούν οποιοδήποτε συνδυασμό από υπηρεσίες υποστήριξης (βάση δεδομένων, ουρά εργασιών, προσωρινή μνήμη, κλπ).

Πλαίσιο

Οι συγγραφείς αυτού του κειμένου έχουν άμεσα εμπλακεί στην υλοποίηση και ανάπτυξη εκατοντάδων εφαρμογών, και έχουν έμμεσα γίνει μάρτυρες της υλοποίησης, λειτουργίας, και κλιμάκωσης εκατοντάδων χιλιάδων εφαρμογών μέσω της εργασίας τους στη πλατφόρμα Heroku.

Αυτό το κείμενο συνθέτει όλη την εμπειρία μας και τις παρατηρήσεις μας σε μια ευρεία ποικιλία απο εφαρμογές λογισμικού-ως-υπηρεσίας εκεί έξω. Είναι μια τριγωνοποίηση σε ιδανικές πρακτικές για υλοποίηση εφαρμογών, δίνωντας ιδιαίτερη προσοχή στην δυναμική της οργανικής ανάπτυξης μιας εφαρμογής στο χρόνο, της δυναμικής της συνεργασίας μεταξύ προγραμματιστών που δουλέυουν πάνω στη βάση κώδικα της εφαρμογής, και της αποφυγής του κόστους διάβρωσης του λογισμικού.

Το κίνητρό μας είναι να αυξήσουμε τη συνειδητότητα για μερικά συστημικά προβλήματα που έχουμε δει στην υλοποίηση μοντέρνων εφαρμογών, να παρέχουμε ένα κοινό λεξιλόγιο για να συζητήσουμε αυτά τα προβλήματα, και να προσφέρουμε ένα σύνολο από ευρείς εννοιολογικές λύσεις μαζί με την συνάδουσα ορολογία. Η μορφή είναι εμπνευσμένη απο τα βιβλία του Martin Fowler Patterns of Enterprise Application Architecture και Refactoring.

Ποιός πρέπει να διαβάσει αυτό το κείμενο;

Κάθε προγραμματιστής που αναπτύσσει εφαρμογές που τρέχουν σαν υπηρεσίες. Μηχανικοί διαχείρισης συστημάτων οι οποίοι εγκαθιστούν ή διαχειρίζονται τέτοιες εφαρμογές.

Οι Δώδεκα Παράγοντες

I. Βάση Κώδικα

Μία βάση κώδικα με έλεγχο εκδόσεων, πολλές αναπτύξεις

II. Εξαρτήσεις

Εξαρτήσεις εκπεφρασμένα δηλωμένες και απομονωμένες

III. Παραμετροποίηση

Αποθήκευση παραμέτρων στο περιβάλλον

IV. Υπηρεσίες υποστήριξης

Υπηρεσίες υποστήριξης ως επισυναπτόμενοι πόροι

V. Κατασκευή, έκδοση, εκτέλεση

Αυστηρός διαχωρισμός μεταξύ των σταδίων μεταγλώττισης/κατασκευής και εκτέλεσης

VI. Διεργασίες

Εκτέλεση εφαρμογής ως μία ή περισσότερες διεργασίες χωρίς κατάσταση

VII. Πρόσδεση θυρών

Εξαγωγή υπηρεσιών μέσω πρόσδεσης θυρών

VIII. Παραλληλία

Κλιμάκωση προς τα έξω μέσω του μοντέλου διεργασιών

IX. Απορριψιμότητα

Μεγιστοποίηση ευρωστίας της εφαρμογής μέσω γρήγορης εκκίνησης και κομψού τερματισμού

X. Ισοτιμία dev/prod

Κράτησε τα περιβάλλοντα υλοποίησης, ελέγχου και παραγωγής όσο πιο όμοια γίνεται

XI. Αρχεία συμβάντων

Τα αρχεία συμβάντων ως ροές συμβάντων

XII. Διεργασίες διαχείρισης

Εκτέλεση εργασιών διαχείρισης ως διεργασίες μια και έξω\n\n\n\nIntroducción

En estos tiempos, el software se está distribuyendo como un servicio: se le denomina web apps, o software as a service (SaaS). “The twelve-factor app” es una metodología para construir aplicaciones SaaS que:


Usan formatos declarativos para la automatización de la configuración, para minimizar el tiempo y el coste que supone que nuevos desarrolladores se unan al proyecto;

Tienen un contrato claro con el sistema operativo sobre el que trabajan, ofreciendo la máxima portabilidad entre los diferentes entornos de ejecución;

Son apropiadas para desplegarse en modernas plataformas en la nube, obviando la necesidad de servidores y administración de sistemas;

Minimizan las diferencias entre los entornos de desarrollo y producción, posibilitando un despliegue continuo para conseguir la máxima agilidad;

Y pueden escalar sin cambios significativos para las herramientas, la arquitectura o las prácticas de desarrollo.


La metodología “twelve-factor” puede ser aplicada a aplicaciones escritas en cualquier lenguaje de programación, y cualquier combinación de ‘backing services’ (bases de datos, colas, memoria cache, etc).

Contexto

Los colaboradores de este documento han estado involucrados directamente en el desarrollo y despliegue de cientos de aplicaciones, y han sido testigos indirectos del desarrollo, las operaciones y el escalado de cientos de miles de aplicaciones mediante nuestro trabajo en la plataforma Heroku.

Este documento sintetiza toda nuestra experiencia y observaciones en una amplia variedad de aplicaciones SaaS. Es la triangulación entre practicas ideales para el desarrollo de aplicaciones, prestando especial atención a las dinámicas del crecimiento natural de una aplicación a lo largo del tiempo, las dinámicas de colaboración entre desarrolladores que trabajan en el código base de las aplicaciones y evitando el coste de la entropía del software.

Nuestra motivación es mejorar la concienciación sobre algunos problemas sistémicos que hemos observado en el desarrollo de las aplicaciones modernas, aportar un vocabulario común que sirva para discutir sobre estos problemas, y ofrecer un conjunto de soluciones conceptualmente robustas para esos problemas acompañados de su correspondiente terminología. El formato está inspirado en los libros de Martin Fowler Patterns of Enterprise Application Architecture y Refactoring.

¿Quién debería leer este documento?

Cualquier desarrollador que construya aplicaciones y las ejecute como un servicio. Ingenieros de operaciones que desplieguen y gestionen dichas aplicaciones.

Twelve Factors

I. Código base (Codebase)

Un código base sobre el que hacer el control de versiones y multiples despliegues

II. Dependencias

Declarar y aislar explícitamente las dependencias

III. Configuraciones

Guardar la configuración en el entorno

IV. Backing services

Tratar a los “backing services” como recursos conectables

V. Construir, desplegar, ejecutar

Separar completamente la etapa de construcción de la etapa de ejecución

VI. Procesos

Ejecutar la aplicación como uno o más procesos sin estado

VII. Asignación de puertos

Publicar servicios mediante asignación de puertos

VIII. Concurrencia

Escalar mediante el modelo de procesos

IX. Desechabilidad

Hacer el sistema más robusto intentando conseguir inicios rápidos y finalizaciones seguras

X. Paridad en desarrollo y producción

Mantener desarrollo, preproducción y producción tan parecidos como sea posible

XI. Historiales

Tratar los historiales como una transmisión de eventos

XII. Administración de procesos

Ejecutar las tareas de gestión/administración como procesos que solo se ejecutan una vez\n\n\n\nIntroduction

À l’époque actuelle, les logiciels sont régulièrement délivrés en tant que services : on les appelle des applications web (web apps), ou logiciels en tant que service (software-as-a-service). L’application 12 facteurs est une méthodologie pour concevoir des logiciels en tant que service qui :


Utilisent des formats déclaratifs pour mettre en oeuvre l’automatisation, pour minimiser le temps et les coûts pour que de nouveaux développeurs rejoignent le projet;

Ont un contrat propre avec le système d’exploitation sous-jacent, offrant une portabilité maximum entre les environnements d’exécution;

Sont adaptés à des déploiements sur des plateformes cloud modernes, rendant inutile le besoin de serveurs et de l’administration de systèmes;

Minimisent la divergence entre le développement et la production, ce qui permet le déploiement continu pour une agilité maximum;

et peuvent grossir verticalement sans changement significatif dans les outils, l’architecture ou les pratiques de développement;


La méthodologie 12 facteurs peut être appliquée à des applications écrites dans tout langage de programmation, et qui utilisent tout type de services externes (base de données, file, cache mémoire, etc.)

Contexte

Les contributeurs de ce document ont été directement impliqués dans le développement et le déploiement de centaines d’applications, et ont vu, indirectement, le développement, la gestion et le grossissement de centaines de milliers d’applications via le travail fait sur la plateforme Heroku.

Ce document fait la synthèse de toutes nos expériences et observations sur une large variété d’applications software-as-a-service. C’est la triangulation de pratiques idéales pour le développement d’applications, en portant un soin tout particulier aux dynamiques de la croissance organique d’une application au cours du temps, les dynamiques de la collaboration entre les développeurs qui travaillent sur le code de l’application, en évitant le coût de la lente détérioration du logiciel dans un environnement qui évolue (en).

Notre motivation est de faire prendre conscience de certains problèmes systémiques que nous avons rencontrés dans le développement d’applications modernes, afin de fournir un vocabulaire partagé pour discuter ces problèmes, et pour offrir un ensemble de solutions conceptuelles générales à ces problèmes, ainsi que la terminologie correspondante. Le format est inspiré par celui des livres de Martin Fowler Patterns of Enterprise Application Architecture (en) et Refactoring (en).

Qui devrait lire ce document ?

Tout développeur qui construit des applications qui fonctionnent en tant que service, ainsi que les personnes qui déploient et gèrent de telles applications.

Les 12 facteurs

I. Base de code

Une base de code suivie avec un système de contrôle de version, plusieurs déploiements

II. Dépendances

Déclarez explicitement et isolez les dépendances

III. Configuration

Stockez la configuration dans l’environnement

IV. Services externes

Traitez les services externes comme des ressources attachées

V. Assemblez, publiez, exécutez

Séparez strictement les étapes d’assemblage et d’exécution

VI. Processus

Exécutez l’application comme un ou plusieurs processus sans état

VII. Associations de ports

Exportez les services via des associations de ports

VIII. Concurrence

Grossissez à l’aide du modèle de processus

IX. Jetable

Maximisez la robustesse avec des démarrages rapides et des arrêts gracieux

X. Parité dev/prod

Gardez le développement, la validation et la production aussi proches que possible

XI. Logs

Traitez les logs comme des flux d’évènements

XII. Processus d’administration

Lancez les processus d’administration et de maintenance comme des one-off-processes\n\n\n\nIntroduzione

Nell’era moderna, il software viene fornito sempre più di frequente come servizio (delivered as a service): si parla di web app o software as a service (SaaS). La twelve-factor app è una metodologia di sviluppo orientata alla costruzione di applicazioni software-as-a-service che:


Seguono un formato dichiarativo per l’automazione della configurazione, minimizzando tempi e costi di ingresso per ogni sviluppatore che si aggiunge al progetto;

Si interfacciano in modo pulito con il sistema operativo sottostante, in modo tale da offrire la massima portabilità sui vari ambienti di esecuzione;

Sono adatte allo sviluppo sulle più recenti cloud platform, ovviando alla necessità di server e amministrazioni di sistema;

Minimizzano la divergenza tra sviluppo e produzione, permettendo il continuous deployment per una massima “agilità”;

Possono scalare significativamente senza troppi cambiamenti ai tool, all’architettura e al processo di sviluppo;


La metodologia twelve-factor può essere applicata a ogni software, scritto in qualsiasi linguaggio di programmazione, che fa uso di una serie di servizi come database, code, cache e così via.

Background

Chi ha scritto questo documento è stato coinvolto direttamente nella realizzazione e nel deployment di centinaia di applicazioni, e ha indirettamente assistito allo sviluppo, le operazioni e lo scaling di centinaia (o migliaia) di app tramite il proprio lavoro sulla piattaforma Heroku.

Questo documento riassume tutta quella che è stata la nostra esperienza, basata sull’osservazione di un grande numero di applicazioni SaaS. Si tratta di una “triangolazione” di pratiche di sviluppo ideali (con una particolare attenzione alla crescita organica dell’app nel tempo), la collaborazione dinamica nel corso del tempo tra gli sviluppatori sulla codebase e la necessità di evitare i costi di software erosion.

La nostra motivazione è di far crescere la consapevolezza intorno ad alcuni problemi sistemici che abbiamo scoperto nello sviluppo di applicazioni moderne, cercando di fornire un vocabolario condiviso per la discussione di tali problemi. Oltre, ovviamente, a offrire delle soluzioni concettuali a queste situazioni (senza però tralasciare il fattore tecnologia). Questo format si rifà ai libri di Martin Fowler Patterns of Enterprise Application Architecture e Refactoring.

A chi è destinato questo documento?

A ogni sviluppatore che costruisca applicazioni SaaS (Software As a Service), e a ogni ops che effettui il deploy e gestisca queste applicazioni.

I “Dodici Fattori”

I. Codebase

Una sola codebase sotto controllo di versione, tanti deployment

II. Dipendenze

Dipendenze dichiarate e isolate

III. Configurazione

Memorizza le informazioni di configurazione nell’ambiente

IV. Backing Service

Tratta i backing service come “risorse”

V. Build, release, esecuzione

Separare in modo netto lo stadio di build dall’esecuzione

VI. Processi

Esegui l’applicazione come uno o più processi stateless

VII. Binding delle Porte

Esporta i servizi tramite binding delle porte

VIII. Concorrenza

Scalare attraverso il process model

IX. Rilasciabilità

Massimizzare la robustezza con avvii veloci e chiusure non brusche

X. Parità tra Sviluppo e Produzione

Mantieni lo sviluppo, staging e produzione simili il più possibile

XI. Log

Tratta i log come stream di eventi

XII. Processi di Amministrazione

Esegui i task di amministrazione/management come processi una tantum\n\n\n\nはじめに

現代では、ソフトウェアは一般にサービスとして提供され、Webアプリケーション や Software as a Service と呼ばれる。Twelve-Factor Appは、次のようなSoftware as a Serviceを作り上げるための方法論である。


セットアップ自動化のために 宣言的な フォーマットを使い、プロジェクトに新しく加わった開発者が要する時間とコストを最小化する。

下層のOSへの 依存関係を明確化 し、実行環境間での 移植性を最大化 する。

モダンな クラウドプラットフォーム 上への デプロイ に適しており、サーバー管理やシステム管理を不要なものにする。

開発環境と本番環境の 差異を最小限 にし、アジリティを最大化する 継続的デプロイ を可能にする。

ツール、アーキテクチャ、開発プラクティスを大幅に変更することなく スケールアップ できる。


Twelve-Factorの方法論は、どのようなプログラミング言語で書かれたアプリケーションにでも適用できる。また、どのようなバックエンドサービス（データベース、メッセージキュー、メモリキャッシュなど）の組み合わせを使っていても適用できる。

背景

このドキュメントへの寄稿者は、何百ものアプリケーションの開発とデプロイに直接関わり、Herokuプラットフォーム上での仕事を通して、何百何千ものアプリケーションの開発・運用・スケールに間接的に立ち会った。

このドキュメントは、多種多様なSaaSアプリケーション開発現場での私たちの経験と観察をすべてまとめたものである。これは、アプリケーション開発における理想的なプラクティスを見出すための三角測量である。特に、アプリケーションが時間と共に有機的に成長する力学、アプリケーションのコードベースに取り組む開発者間のコラボレーションの力学、そしてソフトウェア腐敗によるコストの回避に注目している。

私たちの動機は、私たちがモダンなアプリケーション開発で見てきたある種のシステム的な問題への関心を高めること、この問題を議論するための共通の語彙を提供すること、そしてこの問題に対する広い概念的な解決策と専門用語を提供することである。フォーマットはMartin Fowlerの書籍、Patterns of Enterprise Application Architecture および Refactoring に着想を得ている。

このドキュメントの対象者

サービスとして動くアプリケーションを開発しているすべての開発者。およびそのようなアプリケーションをデプロイまたは管理しているインフラエンジニア。

The Twelve Factors

I. コードベース

バージョン管理されている1つのコードベースと複数のデプロイ

II. 依存関係

依存関係を明示的に宣言し分離する

III. 設定

設定を環境変数に格納する

IV. バックエンドサービス

バックエンドサービスをアタッチされたリソースとして扱う

V. ビルド、リリース、実行

ビルド、リリース、実行の3つのステージを厳密に分離する

VI. プロセス

アプリケーションを1つもしくは複数のステートレスなプロセスとして実行する

VII. ポートバインディング

ポートバインディングを通してサービスを公開する

VIII. 並行性

プロセスモデルによってスケールアウトする

IX. 廃棄容易性

高速な起動とグレースフルシャットダウンで堅牢性を最大化する

X. 開発/本番一致

開発、ステージング、本番環境をできるだけ一致させた状態を保つ

XI. ログ

ログをイベントストリームとして扱う

XII. 管理プロセス

管理タスクを1回限りのプロセスとして実行する\n\n\n\n머리말

최근 소프트웨어를 서비스 형태로 제공하는게 일반화 되면서, 웹앱 혹은 SaaS(Software As A Service)라고 부르게 되었다. Twelve-Factor app은 아래 특징을 가진 SaaS 앱을 만들기 위한 방법론이다.


설정 자동화를 위한 절차(declarative) 를 체계화 하여 새로운 개발자가 프로젝트에 참여하는데 드는 시간과 비용을 최소화한다.

OS에 따라 달라지는 부분을 명확히하고, 실행 환경 사이의 이식성을 극대화 한다.

최근 등장한 클라우드 플랫폼 배포에 적합하고, 서버와 시스템의 관리가 필요없게 된다.

개발 환경과 운영 환경의 차이를 최소화하고 민첩성을 극대화하기 위해 지속적인 배포가 가능하다.

툴, 아키텍처, 개발 방식을 크게 바꾸지 않고 확장(scale up) 할 수 있다.


Twelve-Factor 방법론은 어떤 프로그래밍 언어로 작성된 앱에도 적용할 수 있고 백엔드 서비스(데이터베이스, 큐, 메모리 캐시 등)와 다양한 조합으로 사용할 수 있다.

배경

이 문서에 기여한 사람들은 수백개 앱의 개발과 배포에 직접 참여했으며, Heroku 플랫폼을 통해서 방대한 앱의 개발, 운영, 확장을 간접적으로 관찰했다.

이 문서는 실제로 쓰이는 다양한 SaaS 앱에 대한 경험과 관찰을 종합한 결과물이다. 특히 시간이 지나면서 앱이 유기적으로 성장하는 부분, 앱 코드베이스에서 작업하는 개발자들 간의 협업, 시간이 지나면서 망가지는 소프트웨어 유지비용을 줄이는 법에 집중하여 이상적인 앱 개발 방법을 찾고자 했다.

이 문서는 우리가 최신 애플리케이션 개발에서 만났던 몇가지 시스템적인 문제에 대한 인지도를 높이고, 이 문제들을 가지고 논의 하는데 필요한 공통의 어휘를 제공하며, 이 문제들에 대한 넓은 개념의 해결책과 용어를 제공하기 위해 작성 했다. 형식은 Martin Fowler의 책, Patterns of Enterprise Application Architecture과 Refactoring에서 영감을 받았다.

이 문서의 대상

서비스로 동작하는 애플리케이션을 개발하는 모든 개발자. 그런 애플리케이션을 배포하고 관리하는 인프라 엔지니어.

The Twelve Factors

I. 코드베이스

버전 관리되는 하나의 코드베이스와 다양한 배포

II. 종속성

명시적으로 선언되고 분리된 종속성

III. 설정

환경(environment)에 저장된 설정

IV. 백엔드 서비스

백엔드 서비스를 연결된 리소스로 취급

V. 빌드, 릴리즈, 실행

철저하게 분리된 빌드와 실행 단계

VI. 프로세스

애플리케이션을 하나 혹은 여러개의 무상태(stateless) 프로세스로 실행

VII. 포트 바인딩

포트 바인딩을 사용해서 서비스를 공개함

VIII. 동시성(Concurrency)

프로세스 모델을 사용한 확장

IX. 폐기 가능(Disposability)

빠른 시작과 그레이스풀 셧다운(graceful shutdown)을 통한 안정성 극대화

X. 개발/프로덕션환경 일치

개발, 스테이징, 프로덕션 환경을 최대한 비슷하게 유지

XI. 로그

로그를 이벤트 스트림으로 취급

XII. Admin 프로세스

admin/maintenance 작업을 일회성 프로세스로 실행\n\n\n\nWprowadzenie

We współczesnym świecie oprogramowanie jest powszechnie wytwarzane w formie usługi, nazywane software-as-service (SaaS) lub aplikacjami internetowymi. Dwanaście aspektów aplikacji jest metodologią budowania aplikacji SaaS, które:


Używają deklaratywnego formatu by zautomatyzować konfigurację aplikacji w celu zmniejszenia czasu i kosztów dołączenia nowych programistów do projektu;

Mają czysty kontrakt z systemem operacyjnym, umożliwiając jak największą możliwość przenoszenia pomiędzy środowiskami, w których działają;

Są dopasowane do wdrożenia na nowoczesne chmury obliczeniowe, zapobiegając potrzebie użycia serwerów i administracji systemu;

Minimalizują rozbieżności pomiędzy środowiskami developerskimi i produkcyjnymi, umożliwiając nieustanne wdrażanie aplikacji by zmaksymalizować prędkość zmian;

I mogą skalować się bez większej zmiany narzędzi, architektury, czy sposobu pracy zespołu.


Metodologia dwunastu aspektów może być stosowana do aplikacji napisanych w każdym języku programowania i wykorzystujących dowolną kombinację usług wspierających (bazy danych, kolejki, cache pamięci etc).

Background

Kontrybutorzy tego dokumentu byli bezpośrednio zaangażowani w tworzenie i wdrażanie setek aplikacji i pośrednio byli świadkami produkcji, działania i skalowania setek tysięcy aplikacji dzięki naszej pracy na platformie Heroku.

Ten dokument jest podsumowaniem całego naszego doświadczenia i obserwacji szerokiej gamy aplikacji SaaS. Jest on połączeniem idealnych praktyk developmentu, zwracania szczególnej uwagi na naturalny rozrost aplikacji w czasie, dynamiki współpracy developerów pracujących nad jednym codebase’m, oraz unikania kosztów gnijącego oprogramowania.

Naszym celem jest podniesienie poziomu świadomości o podstawowych problemach, które dostrzegliśmy przy tworzeniu nowoczesnych aplikacji, zapewnienie wspólnego słownictwa do rozmowy o tych problemach oraz zaoferowanie ogólnych rozwiązań dla tych problemów wraz z towarzyszącą terminologią. Format dokumentu jest inspirowany książkami Martina Fowlera Patterns of Enterprise Application Architecture oraz Refactoring.

Dla kogo przeznaczony jest ten dokument?

Dla każdego developera tworzącego aplikacje, które działają jako usługa. Dla każdego Dev-opsa, który wdraża i zarządza takimi aplikacjami.

The Twelve Factors

I. Codebase

Jedno źródło kodu śledzone systemem kontroli wersji, wiele wdrożeń

II. Zależności

Jawnie zadeklaruj i wydziel zależności

III. Konfiguracja

Przechowuj konfigurację w środowisku

IV. Usługi wspierające

Traktuj usługi wspierające jako przydzielone zasoby

V. Buduj, publikuj, uruchamiaj

Oddzielaj etap budowania od uruchamiania

VI. Procesy

Uruchamiaj aplikację jako jeden lub więcej bezstanowych procesów

VII. Przydzielanie portów

Udostępniaj usługi przez przydzielanie portów

VIII. Współbieżność

Skaluj przez odpowiednio dobrane procesy

IX. Zbywalność

Zwiększ elastyczność pozwalając na szybkie uruchamianie i zatrzymywanie aplikacji

X. Jednolitość środowisk

Utrzymuj konfigurację środowisk jak najbardziej zbliżoną do siebie

XI. Logi

Traktuj logi jako strumień zdarzeń

XII. Zarządzanie aplikacją

Uruchamiaj zadania administracyjne jako jednorazowe procesy\n\n\n\nIntrodução

Na era moderna, software é comumente entregue como um serviço: denominados web apps, ou software-como-serviço. A aplicação doze-fatores é uma metodologia para construir softwares-como-serviço que:


Usam formatos declarativos para automatizar a configuração inicial, minimizar tempo e custo para novos desenvolvedores participarem do projeto;

Tem um contrato claro com o sistema operacional que o suporta, oferecendo portabilidade máxima entre ambientes que o executem;

São adequados para implantação em modernas plataformas em nuvem, evitando a necessidade por servidores e administração do sistema;

Minimizam a divergência entre desenvolvimento e produção, permitindo a implantação contínua para máxima agilidade;

E podem escalar sem significativas mudanças em ferramentas, arquiteturas, ou práticas de desenvolvimento.


A metodologia doze-fatores pode ser aplicada a aplicações escritas em qualquer linguagem de programação, e que utilizem qualquer combinação de serviços de suportes (banco de dados, filas, cache de memória, etc).

Experiência

Os contribuidores deste documento estão diretamente envolvidos no desenvolvimento e implantação de centenas de aplicações, e indiretamente testemunhando o desenvolvimento, operação e escalada de centenas de milhares de aplicações através de seu trabalho na plataforma Heroku.

Este documento sintetiza toda nossa experiência e observação em uma variedade de aplicações que operam como software-como-serviço. Isto é a triangulação de práticas ideais ao desenvolvimento de software, com uma atenção particular a respeito das dinâmicas de crescimento orgânico de uma aplicação ao longo do tempo, a dinâmica de colaboração entre desenvolvedores trabalhando em uma base de código, e evitando os custos de erosão de software

Nossa motivação é aumentar a consciência de alguns problemas sistêmicos que temos visto no desenvolvimento de aplicações modernas, prover um vocabulário comum para discussão destes, e oferecer um amplo conjunto de soluções conceituais para esses problemas com a terminologia que os acompanha. O formato é inspirado nos livros de Martin Fowler Padrões de Arquitetura de Aplicações Enterprise e Refatorando.

Quem deve ler este documento?

Qualquer desenvolvedor que esta construindo aplicações que rodam como serviço. Engenheiros de Operações que implantam ou administram tais aplicações.

Os Doze Fatores

I. Base de Código

Uma base de código com rastreamento utilizando controle de revisão, muitos deploys

II. Dependências

Declare e isole as dependências

III. Configurações

Armazene as configurações no ambiente

IV. Serviços de Apoio

Trate os serviços de apoio, como recursos ligados

V. Construa, lance, execute

Separe estritamente os builds e execute em estágios

VI. Processos

Execute a aplicação como um ou mais processos que não armazenam estado

VII. Vínculo de porta

Exporte serviços por ligação de porta

VIII. Concorrência

Dimensione por um modelo de processo

IX. Descartabilidade

Maximizar a robustez com inicialização e desligamento rápido

X. Dev/prod semelhantes

Mantenha o desenvolvimento, teste, produção o mais semelhante possível

XI. Logs

Trate logs como fluxo de eventos

XII. Processos de Admin

Executar tarefas de administração/gerenciamento como processos pontuais\n\n\n\nВведение

В наши дни программное обеспечение обычно распространяется в виде сервисов, называемых веб-приложения (web apps) или software-as-a-service (SaaS). Приложение двенадцати факторов — это методология для создания SaaS-приложений, которые:


Используют декларативный формат для описания процесса установки и настройки, что сводит к минимуму затраты времени и ресурсов для новых разработчиков, подключённых к проекту;

Имеют соглашение с операционной системой, предполагающее максимальную переносимость между средами выполнения;

Подходят для развёртывания на современных облачных платформах, устраняя необходимость в серверах и системном администрировании;

Сводят к минимуму расхождения между средой разработки и средой выполнения, что позволяет использовать непрерывное развёртывание (continuous deployment) для максимальной гибкости;

И могут масштабироваться без существенных изменений в инструментах, архитектуре и практике разработки.


Методология двенадцати факторов может быть применена для приложений, написанных на любом языке программирования и использующих любые комбинации сторонних служб (backing services) (базы данных, очереди сообщений, кэш-памяти, и т.д.).

Предпосылки

Участники, внёсшие вклад в этот документ, были непосредственно вовлечены в разработку и развёртывание сотен приложений и косвенно были свидетелями разработки, выполнения и масштабирования сотен тысяч приложений во время нашей работы над платформой Heroku.

В этом документе обобщается весь наш опыт использования и наблюдения за самыми разнообразными SaaS-приложениями в дикой природе. Документ является объединением трёх идеальных подходов к разработке приложений: уделение особого внимания динамике органического роста приложения с течением времени, динамике сотрудничества разработчиков, работающих над кодовой базой приложения, и устранение последствий эрозии программного обеспечения.

Наша мотивация заключается в повышении осведомлённости о некоторых системных проблемах, которые мы встретили в практике разработки современных приложений, а также для того, чтобы предоставить общие основные понятия для обсуждения этих проблем и предложить набор общих концептуальных решений этих проблем с сопутствующей терминологией. Формат навеян книгами Мартина Фаулера (Martin Fowler) Patterns of Enterprise Application Architecture и Refactoring.

Кому следует читать этот документ?

Разработчикам, которые создают SaaS-приложения. Ops инженерам, выполняющим развёртывание и управление такими приложениями.

Двенадцать факторов

I. Кодовая база

Одна кодовая база, отслеживаемая в системе контроля версий, – множество развёртываний

II. Зависимости

Явно объявляйте и изолируйте зависимости

III. Конфигурация

Сохраняйте конфигурацию в среде выполнения

IV. Сторонние службы (Backing Services)

Считайте сторонние службы (backing services) подключаемыми ресурсами

V. Сборка, релиз, выполнение

Строго разделяйте стадии сборки и выполнения

VI. Процессы

Запускайте приложение как один или несколько процессов не сохраняющих внутреннее состояние (stateless)

VII. Привязка портов (Port binding)

Экспортируйте сервисы через привязку портов

VIII. Параллелизм

Масштабируйте приложение с помощью процессов

IX. Утилизируемость (Disposability)

Максимизируйте надёжность с помощью быстрого запуска и корректного завершения работы

X. Паритет разработки/работы приложения

Держите окружения разработки, промежуточного развёртывания (staging) и рабочего развёртывания (production) максимально похожими

XI. Журналирование (Logs)

Рассматривайте журнал как поток событий

XII. Задачи администрирования

Выполняйте задачи администрирования/управления с помощью разовых процессов\n\n\n\nÚvod

V modernej dobe sa zvyčajne softvér dodáva ako služba: nazýva sa webová aplikácia, alebo software-as-a-service. Dvanásť faktorová aplikácia je metodológia na budovanie software-as-a-service aplikácií, ktoré:


Používajú deklaratívne formáty na automatizáciu nastavení, a minimalizáciu času a nákladov pre nových developerov, ktorí sa začlenia do projektu;

Obsahuje jasnú zmluvu s operačným systémom, nad ktorým bežia, čím umožňujú maximálnu portabilitu medzi rôznymi prostrediami;

Sú vhodné na nasadenie na moderné cloudové platformy, čím vylučujú potrebu serverov a systémových administrátorov;

Minimalizujú rozdiely medzi vývojom a produkciou, čím umôžňujú continuous deployment s maximálnou agilnosťou;

A sú škálovateľné bez významných zmien v nástrojoch, architektúre alebo vývojárskych postupoch.


Dvanásť faktorová metodológia sa dá použiť na aplikácie písané v akomkoľvek programovacom jazyku, ktoré používajú akúkoľvek kombináciu podporných služieb (databáza, fronta, pamäťová cache, atď).

Background

The contributors to this document have been directly involved in the development and deployment of hundreds of apps, and indirectly witnessed the development, operation, and scaling of hundreds of thousands of apps via our work on the Heroku platform.

This document synthesizes all of our experience and observations on a wide variety of software-as-a-service apps in the wild. It is a triangulation on ideal practices for app development, paying particular attention to the dynamics of the organic growth of an app over time, the dynamics of collaboration between developers working on the app’s codebase, and avoiding the cost of software erosion.

Our motivation is to raise awareness of some systemic problems we’ve seen in modern application development, to provide a shared vocabulary for discussing those problems, and to offer a set of broad conceptual solutions to those problems with accompanying terminology. The format is inspired by Martin Fowler’s books Patterns of Enterprise Application Architecture and Refactoring.

Kto by si mal prečítať tento dokument?

Každý vývojár pracujúci na aplikácii, ktorá beží ako služba. Systémoví administrátori, ktorý také aplikácie nasadzujú.

The Twelve Factors

I. Zdrojový kód

Jeden zdrojový kód vo verzionovacom systéme, veľa nasadení

II. Závislosti

Explicitne deklarované a izolované závislosti

III. Konfigurácia

Konfigurácia uložená v prostredí

IV. Podporné služby

Podporné služby sú pripojené zdroje

V. Build, release, run

Jasne oddelené fázy budovania, vydani a behu

VI. Procesy

Aplikácia sa vykonáva ako jeden alebo viac bezstavových procesov

VII. Port binding

Export služieb cez porty

VIII. Concurrency

Škálovanie pomocou modelu procesov

IX. Disposability

Maximalizácia robustnosti rýchlym štartom a vhodným vypnutím

X. Dev/prod parity

Vývojové, testovacie a produkčné prostredie sú čo najpodobnejšie ako sa dá

XI. Logy

Logy sú prúdy udalostí

XII. Admin procesy

Spúštanie administrátorských/správcovských úloh ako jednorazových procesov\n\n\n\nบทนำ

ในยุคสมัยใหม่ ซอฟต์แวร์ถูกส่งมอบทั่วไปเป็นบริการ: เรียกว่า web apps, หรือ software-as-service. twelve-factor app เป็นหลัการสำหรับสร้างแอพพลิเคชัน software-as-a-service ที่:


ใช้รูปแบบ declarative สำหรับติดตั้งระบบอัตโนมัต เพื่อลดเวลาและค่าใช้จ่ายสำหรับนักพัฒนาใหม่ที่เข้าร่วมกับโครงการ;

มี clean contract กับระบบปฏิบัติการที่แอพพลิเคชันทำงานด้วย นำเสนอ maximun portibility ระหว่างสิ่งแวดล้อมที่ระบบทำงาน;

เหมาะสมสำหรับ deployment บน cloud platforms สมัยใหม่, ลดความต้องการของเซิร์ฟเวอร์และผู้ดูแลระบบ;

Maximized divergence ระหว่างการพัฒนาและการใช้งานจริง ด้วยการใช้ continuous deployment เพื่อเพิ่มความเร็วสูงสุด;

และสามารถ scale up โดยปราศจากการเปลี่ยนแปลงของ เครื่องมือ สถาปัตยกรรม หรือแนวทางปฏิบัตของการพัฒนา


หลักการ twelve-factor สามารถประยุกต์ใช้ได้กับแอพพลิเคชันที่เขียนด้วยภาษาใดๆ และซึ่งใช้ร่วมกับบริการสนับสนุนใดๆ (ฐานข้อมูล, คิว, หน่วยความจำเคช เป็นต้น).

ประวัติ

ผู้มีส่วนร่วมของเอกสารนี้ได้มีส่วนเกี่ยวข้องโดยตรงกับการพัฒนาและการใช้งานแอพพลิเคชันจำนวนมาก และเกี่ยวข้องทางอ้อมสำหรับการพัฒนา การดำเนินงาน และการขยายขนาดของแอพพลิเคชันจำนวมมหาศาลผ่านงานของเราที่แพลตฟอร์ม Heroku

เอกสารนี้สังเคราะห์จากประสบการณ์และการสังเกตทั้งหมดของพวกเราบนแอพพลิเคชัน software-as-a-service ที่หลากหลายจำนวนมาก เป็นสามเหลียมของแนวทางปฏิบัตในอุดมคติสำหรับการพัฒนาแอพพลิเคชัน ให้ความสนใจเป็นพิเศษกับพลวัตของการเจริญเติบโตของแอพพลิเคชันในช่วงเวลาหนึ่ง พลวัตของการมีส่วนร่วมระหว่างนักพัฒนาที่ทำงานกับ codebase ของแอพพลิเคชัน และหลีกเลี่ยงการใช้จ่ายของซอฟต์แวร์.

แรงจูงใจของเราเพื่อสร้างความตระหนักของปัญหาระบบบางอย่างที่เราเห็นในการพัฒนาแอพพลิเคชันสมัยใหม่ เพื่อให้คำศัพย์ที่ใช้ร่วมกันสำหรับการพูดคุยเกี่ยวกับปัญหาเหล่านี้ และนำเสนอแนวทางแก้ไขแนวกว้างสำหรับปัญหาเหล่านี้พร้อมกับคำศัพท์ที่ใช้ประกอบกัน รูปแบบนี้ได้รับแรงบันดาลใจจากหนังสือของ Martin Fowler Patterns of Enterprise Application Architecture และ Refactoring.

ใครควรจะอ่านเอกสารนี้?

นักพัฒนาที่สร้างแอพพลิเคชันซึ่งทำงานเป็นเซอร์วิซ (service) วิศวกรดำเนินงานผู้ซึ่งปรับใช้ (deploy) หรือจัดการแอพพลิเคชันดังกล่าว

The Twelve Factors

I. Codebase

มีเพียง codebase เดียวที่ติดตามด้วย version control, มีหลาย deploy

II. Dependencies

มีการประกาศและแยกการอ้างอิง (dependency) ทั้งหมดอย่างชัดเจน

III. Config

จัดเก็บการตั้งค่า (config) ไว้ในสิ่งแวดล้อมของระบบ

IV. Backing services

จัดการกับบริการสนับสนุน (backing service) ให้เป็นทรัพยากรที่แนบมา

V. Build, release, run

แยกขั้นตอนของการ build และ run อย่างเคร่งครัด

VI. Processes

รันแอพพลิเคชันเป็นหนึ่งหรือมากกว่าให้เป็น stateless processes

VII. Port binding

นำออกบริการด้วยการเชื่อมโยง port

VIII. Concurrency

ขยายออกของแอพพลิเคชันด้วยรูปแบบ process

IX. Disposability

เพิ่มความแข็งแกร่งด้วยการเริ่มต้นระบบอย่างรวดเร็วและปิดระบบอย่างนุ่มนวล

X. Dev/prod parity

รักษา development, staging และ production ให้มีความใกล้เคียงกันที่สุด

XI. Logs

จัดการ logs ให้เป็นแบบ event stream

XII. Admin processes

รันงานของผู้ดูแลระบบ/การจัดการให้เป็นกระบวนการแบบครั้งเดียว\n\n\n\nGiriş

Modern çağda yazılımlar çoğunlukla “web uygulaması” ya da “yazılım hizmeti” olarak isimlendirilen servisler olarak sunulurlar. On iki faktörlü uygulama, servis olarak çalışan yazılımlar (İng. software as a service veya SaaS) geliştirmek için bir yöntembilimdir. Bu yöntembilimin kuralları ve faydaları şunlardır:


Projenin kurulum otomasyonu için açıklayıcı (İng. declarative) biçimler kullanır. Bu şekilde, projeye yeni katılan geliştiricilerin geliştirmeye başlama zamanını ve maliyetinı en aza indirir;

Üzerinde çalıştığı işletim sistemi ile arasında basit bir bağlılık vardır. Bu, tüm çalıştırma ortamlarına (Docker gibi container sistemleri ve sıradan işletim sistemlerine) maksimum uyumluluk sağlar;

Sunucu ve sistem yönetimine olan ihtiyacı ortadan kaldıran modern bulut platformlarına kurulum için uygundur;

Geliştirme ve canlı yayın ortamları arasında farklılıklaşmayı minimize ederek, maksimum çeviklik ile sürekli dağıtımın önünü açar;

Kullanılan araçlarda, mimaride veya geliştirme pratiklerinde önemli değişikliklere gerek duymadan ölçeklenebilir.


On iki faktör uygulaması herhangi bir programlama dili ile yazılmış ve yardımcı (veritabanları, kuyruk işleyiciler, önbellek, vb. gibi) servislerin herhangi bir kombinasyonuna sahip tüm uygulamalara uygulanabilir.

Arkaplan

Bu belgeye katkıda bulunan kişiler, yüzlerce uygulamanın geliştirilmesi ve yayınlanmasında doğrudan yer almış, ve dolaylı olarak Heroku platformundaki üzerinde çalıştığımız yüz binlerce uygulamanın geliştirilmesi, çalıştırılması ve ölçeklendirilmesine tanık olmuştur.

Bu belge birçok yazılım servisinde edindiğimiz deneyim ve gözlemlerimizin bir sentezidir. Uygulama geliştirme aşamasındaki ideal pratiklerin, uygulamaların zaman içindeki organik büyüyüşlerine gösterilen özel ilginin, bir uygulamanın kodları üzerinde çalışan geliştiriciler arasındaki işbirliği dinamiklerinin, ve yazılım erozyonunun getirdiği masraftan kaçınmanın toplamı niteliğindedir.

Motivasyonumuz modern uygulama geliştirmelerinde gördüğümüz bazı sistemik problemlere olan farkındalığı arttırmak, bahsi geçen problemler için ortak bir terminoloji belirlemek, ve bu problemlere karşı bir dizi çözüm konsepti sunmaktır. Bu konsept oluşturulurken, Martin Fowler’ın kitapları olan Patterns of Enterprise Application Architecture ve Refactoring‘den ilham alınmıştır.

Bu belgeyi kim okumalı?

Servis yazılımı geliştiren tüm geliştiriciler. Bu tür uygulamaları yayınlayan ve yöneten operasyon mühendisleri.

On İki Faktör

I. Kod tabanı

Sürüm kontrol sistemi üzerinde tek bir kod tabanı, birden fazla dağıtım

II. Bağımlılıklar

Bağımlılıkların açıkça tanımlanması ve izole edilmesi

III. Yapılandırma

Yapılandırma ayarlarını ortam değişkeni olarak saklama

IV. Yardımcı servisler

Yardımcı servisleri iliştirilmiş kaynaklar olarak ele almak

V. Derleme, yayınlama, çalıştırma

Derleme ve çalıştırma aşamalarını tam olarak ayırma

VI. Süreçler

Uygulamayı bir veya daha fazla bağımsız süreç olarak çalıştırma

VII. Port bağlama

Servisin portlar üzerinden sunulması

VIII. Eş zamanlılık

Süreç modeli ile ölçeklendirme

IX. İmha edilebilirlik

Hızlı başlangıç ve zararsız sonlanma ile maksimum servis sağlığı

X.Geliştirme/Üretim Eşitliği

Geliştirme, test etme ve canlı yayın ortamının birbirine olabildiğince benzer olması

XI. Günlükler

Günlükleri olay akışı olarak ele almak

XII. Yönetici Süreci

Yönetici/yönetim görevlerini tek seferlik süreçler olarak çalıştırma\n\n\n\nВступ

У наш час програмне забезпечення зазвичай поставляється у вигляді сервісів, що називаються веб-застосунки (web-apps) або software-as-a-service (SaaS). Застосунок дванадцяти факторів — це методологія для створення SaaS-застосунків, які:


Використовують декларативний формат для автоматизації встановлення та налаштування, що зводить до мінімуму витрати часу і коштів для нових розробників, що приєднуються до проекту;

Мають угоду з операційною системою, пропонуючи максимальну переносимість між середовищами виконання;

Придатні для розгортання на сучасних хмарних платформах, що усуває необхідність у серверах та їх системному адмініструванні;

Мінімізують різницю між середовищем розробки і production середовищем, що дозволяє безперервне розгортання (continuous deployment) для забезпечення максимальної спритності розробки (agility);

Можуть масштабуватися без значних змін в інструментах, архітектурі і практиці розробки.


Методологію дванадцяти факторів можна використати для застосунків, що написані будь-якою мовою програмування та використовують будь-яку комбінацію із сторонніх служб (бази даних, черги, кеш-пам’ять тощо).

Передумови

Люди, що працювали над цим документом, брали безпосередню участь в розробці і розгортанні сотень застосунків, і мимоволі стали свідками розвитку, експлуатації та масштабування сотень тисяч застосунків під час нашої роботи над платформою Heroku.

В цьому документі узагальнюється весь наш досвід використання і спостереження за найрізноманітнішими SaaS-застосунками “в дикій природі”. Документ об’єднує ідеальні практики розробки застосунків, особлива увага приділяється динаміці органічного росту застосунку з плином часу, взаємодії між розробниками, які працюють над кодом застосунку, та уникненню витрат при ерозії програмного забезпечення.

Наша мета полягає в тому, щоб підвищити обізнаність про деякі системні проблеми, які ми бачили в практиці розробки сучасних застосунків, а також в тому, щоб сформулювати спільні загальні поняття для обговорення цих проблем, і запропонувати набір загальних концептуальних рішень цих проблем з супутньою термінологією. Формат навіяний книгами Мартіна Фаулера (Martin Fowler) Patterns of Enterprise Application Architecture та Refactoring.

Кому слід читати цей документ?

Розробникам, які створюють SaaS-застосунки. Ops-інженерам, які виконують розгортання і керування такими застосунками.

Дванадцять факторів

I. Кодова база

Одна кодова база, що відслідковується в системі контролю версій та має багато розгортань

II. Залежності

Явно оголошуйте та ізолюйте залежності

III. Конфігурація

Зберігайте конфігурацію в середовищі виконання

IV. Сторонні служби

Вважайте сторонні служби (backing services) підключеними ресурсами

V. Збірка, реліз, виконання

Суворо відокремлюйте етапи збірки та виконання

VI. Процеси

Запускайте застосунок як один або декілька процесів без збереження внутрішньго стану (stateless)

VII. Прив’язка портів

Експортуйте сервіси за допомогою прив’язки портів (port binding)

VIII. Конкурентність

Масштабуйте застосунок за допомогою процесів

IX. Утилізовуваність

Підвищуйте надійність за допомогою швидкого запуску і коректного вимкнення

X. Dev/prod паритет

Прагніть максимальної ідентичності development, staging та production середовищ

XI. Журналювання

Сприймайте журналювання (logs) як потоки подій

XII. Задачі адміністрування

Виконуйте задачі адміністрування/керування за допомогою разових процесів\n\n\n\nGiới thiệu

Ngày nay, phần mềm thường được chuyển giao như là một dịch vụ: còn được gọi là các ứng dụng web, hay phần mềm-như-một-dịch vụ (software-as-a-service). Ứng dụng 12-hệ số là một phương pháp để xây dựng các ứng dụng phần mềm-như-một-dịch vụ với các tiêu chí sau:


Sử dụng các định dạng theo kiểu tường thuật cho việc thiết lập tự động hoá, để cắt giảm chi phí và thời gian cho lập trình viên mới tham gia dự án;

Có một hợp đồng sạch với hệ điều hành bên dưới, cung cấp tối đa khả năng dịch chuyển giữa các môi trường thực thi;

Phù hợp để triển khai trên các nền tảng đám mây mới, cắt giảm yêu cầu quản trị cho server và hệ thống;

Giảm thiểu sự khác nhau giữa môi trường phát triển và môi trường sản xuất, cho phép đạt được sự linh hoạt tối đa trong triển khai liên tục;

Và có thể mở rộng mà không cần thay đổi lớn cho các công cụ, kiến trúc, hoặc cách thức phát triển.


Phương pháp 12-hệ số có thể được áp dụng cho các ứng dụng viết bằng bất kì ngôn ngữ lập trình nào, và sử dụng bất kì kết hợp giữa các dịch vụ backend (cơ sở dữ liệu, queue, memory cache, vv.).

Gốc gác

Tất cả tác giả của tài liệu này đã trực tiếp tham gia vào quá trình phát triển và triển khai của hàng trăm ứng dụng, và gián tiếp theo dõi các quá trình phát triển, vận hành, và mở rộng của hàng nghìn ứng dụng thông qua công việc của chúng tôi trên hệ thống Heroku.

Tài liệu này là cô đọng của tất cả kinh nghiệm và quan sát của chúng tôi trên một số lượng lớn các ứng dụng-như-một-dịch vụ ở ngoài. Đây là kết hợp của kiến thức thực hành chuẩn mực trong việc phát triển ứng dụng, với trọng tâm vào cơ cấu phát triển cơ bản của ứng dụng trong một khoảng thời gian, cơ cấu động của sự hợp tác giữa các lập trình viên đang làm việc trên cùng một mã gốc, và tránh rò rỉ chi phí phát triển phần mềm.

Động lực của chúng tôi là tăng cường nhận thức về các vấn đề hệ thống mà chúng tôi biết với các qui trình phát triển ứng dụng hiện tại, để chia sẻ một kho kiến thức thảo luận về các vấn đề này, và để cung cấp một chuỗi các giải pháp mở chác vấn đề trên và cũng đi kèm với các thuật ngữ chuyên môn. Định dạng này lấy ý tưởng từ cuốn sách Patterns of Enterprise Application Architecture và Refactoring của ông Martin Fowler.

Ai nên đọc tài liệu này?

Bất kì lập trình viên đang xây dựng các ứng dụng-như-một-dịch vụ. Các kỹ sư hệ thống đảm nhiệm triển khai hoặc quản lý các ứng dụng.

12 hệ số

I. Mã gốc

Một mã gốc được theo dõi với hệ thống quản lý phiên bản, và nhiều lần triển khai

II. Các phụ thuộc

Khai báo rõ ràng và phân tách các phụ thuộc

III. Cấu hình

Lưu trữ cấu hình trong môi trường

IV. Dịch vụ hỗ trợ

Dịch vụ hỗ trợ như là tài nguyên bổ xung

V. Xây dựng, phát hành, vận hành

Tách biệt hoàn toàn giữa bước xây dựng và vận hành

VI. Tiến trình

Vận hành ứng dụng như là một hoặc nhiều tiến trình phi trạng thái

VII. Mở cổng mạng

Cung cấp các dịch vụ thông qua công mạng

VIII. Đồng bộ

Mở rộng theo chiều ngang thông qua mô hình tiến trình

IX. Tính khả dụng

Tối ưu hoá với khởi động nhanh và dừng phần mềm ổn định

X. Sự tương đồng giữa quá trình phát triển và vận hành thực tế

Đảm bảo sự tương đồng giữa môi trường phát triển, kiểm thử và thực tế

XI. Nhật ký

Nhật ký là các luồng sự kiện

XII. Tiến trình quản trị

Thực thi nhiệm vụ quản trị như là một tiến trình\n\n\n\n简介

如今，软件通常会作为一种服务来交付，它们被称为网络应用程序，或软件即服务（SaaS）。12-Factor 为构建如下的 SaaS 应用提供了方法论：


使用标准化流程自动配置，从而使新的开发者花费最少的学习成本加入这个项目。

和操作系统之间尽可能的划清界限，在各个系统中提供最大的可移植性。

适合部署在现代的云计算平台，从而在服务器和系统管理方面节省资源。

将开发环境和生产环境的差异降至最低，并使用持续交付实施敏捷开发。

可以在工具、架构和开发流程不发生明显变化的前提下实现扩展。


这套理论适用于任意语言和后端服务（数据库、消息队列、缓存等）开发的应用程序。

背景

本文的贡献者参与过数以百计的应用程序的开发和部署，并通过 Heroku 平台间接见证了数十万应用程序的开发，运作以及扩展的过程。

本文综合了我们关于 SaaS 应用几乎所有的经验和智慧，是开发此类应用的理想实践标准，并特别关注于应用程序如何保持良性成长，开发者之间如何进行有效的代码协作，以及如何 避免软件污染 。

我们的初衷是分享在现代软件开发过程中发现的一些系统性问题，并加深对这些问题的认识。我们提供了讨论这些问题时所需的共享词汇，同时使用相关术语给出一套针对这些问题的广义解决方案。本文格式的灵感来自于 Martin Fowler 的书籍： Patterns of Enterprise Application Architecture ， Refactoring 。

读者应该是哪些人？

任何 SaaS 应用的开发人员。部署和管理此类应用的运维工程师。

12-factors

I. 基准代码

一份基准代码，多份部署

II. 依赖

显式声明依赖关系

III. 配置

在环境中存储配置

IV. 后端服务

把后端服务当作附加资源

V. 构建，发布，运行

严格分离构建和运行

VI. 进程

以一个或多个无状态进程运行应用

VII. 端口绑定

通过端口绑定提供服务

VIII. 并发

通过进程模型进行扩展

IX. 易处理

快速启动和优雅终止可最大化健壮性

X. 开发环境与线上环境等价

尽可能的保持开发，预发布，线上环境相同

XI. 日志

把日志当作事件流

XII. 管理进程

后台管理任务当作一次性进程运行\n\n\n\nIntroduction

In the modern era, software is commonly delivered as a service: called web apps, or software-as-a-service. The twelve-factor app is a methodology for building software-as-a-service apps that:


Use declarative formats for setup automation, to minimize time and cost for new developers joining the project;

Have a clean contract with the underlying operating system, offering maximum portability between execution environments;

Are suitable for deployment on modern cloud platforms, obviating the need for servers and systems administration;

Minimize divergence between development and production, enabling continuous deployment for maximum agility;

And can scale up without significant changes to tooling, architecture, or development practices.


The twelve-factor methodology can be applied to apps written in any programming language, and which use any combination of backing services (database, queue, memory cache, etc).

Background

The contributors to this document have been directly involved in the development and deployment of hundreds of apps, and indirectly witnessed the development, operation, and scaling of hundreds of thousands of apps via our work on the Heroku platform.

This document synthesizes all of our experience and observations on a wide variety of software-as-a-service apps in the wild. It is a triangulation on ideal practices for app development, paying particular attention to the dynamics of the organic growth of an app over time, the dynamics of collaboration between developers working on the app’s codebase, and avoiding the cost of software erosion.

Our motivation is to raise awareness of some systemic problems we’ve seen in modern application development, to provide a shared vocabulary for discussing those problems, and to offer a set of broad conceptual solutions to those problems with accompanying terminology. The format is inspired by Martin Fowler’s books Patterns of Enterprise Application Architecture and Refactoring.

Who should read this document?

Any developer building applications which run as a service. Ops engineers who deploy or manage such applications.

The Twelve Factors

I. Codebase

One codebase tracked in revision control, many deploys

II. Dependencies

Explicitly declare and isolate dependencies

III. Config

Store config in the environment

IV. Backing services

Treat backing services as attached resources

V. Build, release, run

Strictly separate build and run stages

VI. Processes

Execute the app as one or more stateless processes

VII. Port binding

Export services via port binding

VIII. Concurrency

Scale out via the process model

IX. Disposability

Maximize robustness with fast startup and graceful shutdown

X. Dev/prod parity

Keep development, staging, and production as similar as possible

XI. Logs

Treat logs as event streams

XII. Admin processes

Run admin/management tasks as one-off processes\n\n\n\nWhy Intuit is Thrilled About the Evolution of the Twelve-Factor Model

03 Apr, 2025

Brett Weaver

 At Intuit, we’ve long embraced the twelve-factor app principles as a guiding framework for modern software development. As a company building cutting-edge development tools and runtime platforms for our internal engineers, these principles have been instrumental in unifying service developers, platform engineers, and SREs under a shared philosophy.

By fostering a universal understanding across teams, we’ve eliminated friction between services, platforms, and dependencies. Concepts like running applications as stateless processes aren’t up for debate anymore—they’re simply ingrained in how we build.

In this article, we’ll take you behind the scenes of our internal platform, explore how we’ve expanded on the twelve-factor model with our own Intuit Factors, and dive into our open-source contributions that are helping shape the future of cloud-native development.

The Benefits of an Internal Platform

Over the past decade, Intuit has built an internal developer platform that streamlines the software development lifecycle, leveraging open-source technologies and aligning with our strategic goals. This platform is intentionally opinionated, giving us a competitive edge by standardizing how thousands of developers build, deploy, and operate services.

At its core, our developer platform is engineered around the twelve-factor principles, including:


Stateless workloads – Every workload runs statelessly, with pods responding properly to shutdown signals, validated throughout the service lifecycle.

Separation of configuration – Configurations are decoupled from deployments and managed through our configuration service or environment variables.

Decoupled dependencies – Services operate in fully isolated environments. Our Kubernetes runtime, for example, is hosted in its own AWS account and VPC, with externalized dependencies separated into another VPC.


Beyond the 12 Factors - The Intuit Factors

As technology has advanced, we’ve identified key areas where the twelve-factor model does not cover all the specific requirements of Intuit’s modern cloud platform. That’s why we’ve introduced our own Intuit Factors—a superset of the original factors, specific to Intuit that enhance security, observability, and developer experience specific to Intuit.

These are factors which are unique to us (e.g. we have a factor which states you must leverage Intuit approved sensitive data management services and integrate with our API Gateway and leverage Intuit AuthN / AuthZ providers)

Evolving the 12 Factors - Workload Identity

While many factors we created are specific to Intuit, some of these are generic which we are working to support inclusion into the 12 factors update. For example, we believe that workload identity is necessary for a 12 factor app.

Workload identity refers to the unique identity and associated attributes assigned to a workload—such as a container, virtual machine, or serverless function enabling it to authenticate and interact securely with other services and resources within a computing platform. Unlike user identities, which are tied to human operators, workload identities are managed dynamically by the platform and serve to establish trust between workloads and external services without relying on static credentials.

From a technical perspective, workload identity typically includes:


Unique Identifiers - Platform generated attributes like instance IDs, pod service accounts, or unique workload names.

Authentication Mechanisms - Cryptographic credentials, OAuth tokens, or signed requests used to prove the identity.

Authorization Policies - Role based access controls (RBAC) or attribute based policies that define what the workload can access.

Lifecycle Management - Automated provisioning, rotation, and revocation of credentials to minimize security risks.


In our implementation, we leverage IRSA (IAM Roles for Service Accounts) alongside our runtime configuration service. This delivers just-in-time, short lived credentials, configuration, and policy to the given workload which is tied to the specific workload’s role. As we work with the community, we’d like to shape the definition of workload identity as a future factor.

Driving Open-Source Innovation

At Intuit, we believe in giving back to the developer community, which is why we’ve played a key role in advancing the Argo ecosystem. Our contributions ensure that Argo products align seamlessly with twelve-factor principles, enabling developers to adopt cloud-native best practices effortlessly.

For example, ArgoCD treats git as the single source of truth for application configuration, this enforces consistency across environments (Dev/Prod Parity) deploying a single codebase and cleanly separates configuration from code (Config). Workloads deployed via ArgoCD remain stateless and scalable, leveraging Kubernetes-native tools for process management and concurrency, treading processes as disposable.

Moreover, ArgoCD’s declarative approach and seamless CI/CD integration streamline the entire build, release, and run workflow—reinforcing twelve-factor principles while embracing modern cloud-native development.

The Future of 12-Factor at Intuit

As we continue refining our internal platform and contributing to open-source projects, Intuit remains committed to advancing the future of cloud-native development.

The original 12 factors transformed the way software is built and deployed. Now, with the next iteration on the horizon, we believe even greater innovation lies ahead—for developers, for organizations, and for the industry as a whole.

Stay tuned—this journey is just getting started. 🚀

  
All Posts

Why Intuit is Thrilled About the Evolution of the Twelve-Factor Model by Brett Weaver 03 Apr, 2025

Evolving Twelve-Factor: Applications to Modern Cloud-Native Platforms by Brian Hammons 10 Feb, 2025

December Monthly Updates by Vish Abrams 3 Dec, 2024

Twelve-Factor App Methodology is now Open Source by Yehuda Katz 12 Nov, 2024

Narrow Conduits and the Application-Platform Interface by Vish Abrams 12 Nov, 2024\n\n\n\nEvolving Twelve-Factor: Applications to Modern Cloud-Native Platforms

10 Feb, 2025

Brian Hammons

 The recent open sourcing of the Twelve-Factor App Methodology comes at a transformative moment for cloud-native platforms. As organizations increasingly rely on cloud-native technologies to power mission-critical workloads, the principles behind Twelve-Factor offer timeless foundations that remain relevant for modern platform builders.

As Gail Frederick, CTO at Heroku, noted in a recent interview with The New Stack, “the principles were primarily created to help developers develop their applications locally and package it portably across cloud providers, then have it be able to run resiliently and have it be a delightful experience to build that.“ This vision of developer empowerment coupled with operational excellence remains as relevant today as when Twelve-Factor was first introduced.

However, the landscape has evolved significantly since Twelve-Factor’s initial release. The rise of containers, Kubernetes, and cloud-native architectures has introduced new complexities that the original methodology couldn’t have anticipated. Modern platform builders must now balance the timeless principles of Twelve-Factor with emerging patterns in cloud-native development, security, and operations.

This convergence of established methodology and modern practice offers an opportunity for the cloud-native community. Through open source collaboration, the Twelve-Factor modernization initiative seeks to evolve these principles to better serve today’s developers while maintaining the operational rigor that made Twelve-Factor so influential in the first place.

Historical Context and Evolution

As Kelsey Hightower stated in 2017, Kubernetes is a platform for building platforms. But as platform evolution progresses, what are developers losing in the tradeoff? The modern cloud-native journey has been marked by distinct eras of innovation and challenges, and it is helpful to examine this history to better understand its implications and define a meaningful pathway forward.

Pre-Cloud Era (Early 2000s): The concept of the full-stack developer flourished during this period. These early innovators managed entire application stacks, enjoying the benefits of direct control over code and infrastructure. They made use of simpler deployment stacks such as LAMP and frameworks like Rails to create apps. The famous “rails new demo” command exemplified the streamlined developer experience of the time, though it came with limitations in scale and complexity.

DevOps Revolution (Late 2000s): The emergence of infrastructure automation and configuration management tools promised to improve deployment velocity and reliability. However, this evolution came with a cost: developers now needed to maintain automation pipelines alongside their application code, transforming many into reluctant DevOps engineers.

Modern Cloud Era (2000s - 2010s): After observing developers increasingly losing time to “undifferentiated heavy lifting” and infrastructure concerns, Heroku introduced the Twelve-Factor App methodology in 2011 as a way to help developers avoid common pitfalls in cloud deployment and to offer standardized practices for successfully building cloud-native applications.

Container Revolution (Mid 2010s): Docker’s introduction in 2013 and Kubernetes’ subsequent emergence revolutionized how applications are deployed in the cloud. Kubernetes, in particular, quickly became the standard for container orchestration and led to the establishment of the Cloud Native Computing Foundation (CNCF) in 2015 which has since grown to support a vast array of open source projects. Albeit remarkable in terms of innovation, the increased cognitive load on both development and engineering teams has added operational complexity and created new challenges while overshadowing any remnants of full-stack simplicity.

Addressing Modern Challenges with Twelve-Factor

The evolution of cloud-native technologies has introduced new complexities that the original Twelve-Factor methodology couldn’t have anticipated. Modern platforms have adopted practices such as “shift left” to better address this increased complexity:

Tackling the “Shift Left” Challenge

The “shift left” movement aims to integrate quality and security earlier in the development cycle. While well-intentioned, this often increases cognitive load on developers and introduces points of friction between developers and platform teams.

Twelve-Factor can help balance “shift left” considerations and still enable such modern DevOps benefits through:


Clear Role Definition: Separating platform concerns from the application layer allows developers to focus on business logic and operators to manage infrastructure complexity.

Balanced Responsibility Model:

Traditional Shift-Left Approach: Developers handle application code, infrastructure, security scanning, deployment configuration, and monitoring setup.

Twelve-Factor Approach: Developers focus on application code, business logic, and clear interfaces. The platform provides infrastructure abstraction, security controls, deployment automation, and observability by default.



GitOps Integration: While GitOps appears to be another “shift left” practice, Twelve-Factor principles help it become an enabler rather than a burden. Twelve-Factor supports GitOps practices by proposing methods for clean separation of codebase and config, enabling environment-specific settings, providing clear handoffs between build, release, and run stages, supporting declarative configurations, and promoting automated deployments.

Reducing Cognitive Load: Platforms can automate dependency management, security scanning, deployment pipelines, and infrastructure provisioning to better enable developers to concentrate on their code. Abstracted capabilities such as service discovery, configuration management, out of the box logging and monitoring, and scaling controls can greatly accelerate developer productivity.


Key Benefits for Platform Builders

Modern platform builders implementing Twelve-Factor principles can realize significant advantages while supporting both developer productivity and operational excellence:


Bridging the Dev-Ops Divide: Twelve-Factor provides a framework for deploying applications that serve both developers and operations teams effectively. Successful platforms must avoid catering to one group at the expense of the other. The methodology offers guidance that can help platform builders create abstractions that hide complexity from developers, create automated workflows that satisfy both groups’ needs, balance control with flexibility, and implement a shared responsibility model that works in practice. All this can be achieved while still ensuring operational excellence, heightened security, and reliability.

Clear Separation of Concerns: The methodology’s practical guidance offers a proven model for organizing capabilities such as:

Distinct separation of codebase, config, and build/release/run stages

Support for multiple environments without code changes

Consistent deployment patterns across the organization

Clear boundaries between application and infrastructure concerns

Standardized approaches to common challenges



Standardized Interface Design: Twelve-Factor’s principles around port binding, backing services, and process management offers platform builders patterns for designing consistent and clear interfaces. This standardization enables service discovery and composition, clear protocols for backing service connections, logging and monitoring interfaces, and portable workload definitions.

Alignment with Modern Cloud-Native Patterns: Twelve-Factor principles naturally align with modern cloud-native architectures, and can be applied to use cases such as containerization, config management, and orchestration. For instance, stateless processes map to container-based deployments, config separation supports Kubernetes ConfigMaps, and process management is consistent with cloud-native orchestration practices.

Enhancing Developer Experience: Twelve-Factor improves developer productivity by simplifying application onboarding, emphasizing consistent development-to-production parity, and enabling self-service capabilities. Consistent with the original goals of Twelve-Factor, the maintainers of the modernization initiative are focused on improving the developer experience of modern developers building cloud-native apps.


Practical Implementation Guidance

For platform teams hosting modern cloud infrastructure for app developers:


Abstract Infrastructure Complexity: Provide higher-level abstractions focused on applications, and hide underlying implementation details as much as possible including Kubernetes YAML and infrastructure components. Enhancing self-service capabilities, implementing intuitive search and discovery, and automation of routing tasks can help developers operate efficiently without managing infrastructure complexity.

Standardize Deployment Patterns: Implement consistent build, release, and run stages with support for declarative configurations. Enable automated pipeline creation, ensure reproducible deployments, and maintain secure isolation and granular access throughout the process.

Maintain Operational Control: Support development teams with standardized logging and monitoring capabilities out of the box. Provide clear troubleshooting capabilities, and sensible telemetry to enhance workload visibility and resilience. This will reduce the time it takes to uncover and diagnose problems, improving metrics such as MTTD and MTTR and the ability to maintain a high level of operational excellence. At the same time, platform teams maintain access to the underlying infrastructure APIs and are able to support audit and compliance requirements.

Prioritize Developer Workflows: Create simple and intuitive onboarding experiences, ensure development environments match production, and provide clear documentation and examples. This will enhance developers ability to operate efficiently and remain productive.


Looking Forward: The Future of Twelve-Factor

The open-sourcing of Twelve-Factor creates new opportunities for community-driven innovation. As we look ahead, several key areas show particular promise:


Enhanced Observability: Integration with OpenTelemetry can provide deeper insights into application behavior and performance. This standardized approach to telemetry data collection and transmission will enable better monitoring, troubleshooting, and optimization across distributed systems.

Security and Compliance Evolution: Automated security controls and validations are becoming increasingly sophisticated. Modern platforms can enforce security policies, manage secrets, and ensure compliance requirements are met consistently across all applications and environments. Given the lack of explicit inclusion in the original manifesto, the Twelve-Factor team has proposed a new factor, Identity, and are currently seeking feedback on its inclusion.


Conclusion

As platform engineering continues to evolve, Twelve-Factor provides enduring principles for building developer-friendly yet operationally sound platforms. The methodology’s open-sourcing marks a new chapter in its evolution, creating opportunities for the cloud-native community to adapt these principles for modern architectures while maintaining their original intent.

The challenges facing technology teams have grown in complexity and risk, increasing cognitive load on developers and constraining their productivity. However, by modernizing Twelve-Factor to better align with present-day cloud-native principles, platform builders can deliver capabilities and experiences that increase developer productivity while maintaining the operational control needed in modern cloud environments.

Get Involved

The Twelve-Factor approach to software development has inspired architecture and development practices for more than a decade. Its principles define a unified, predictable way to make enterprise systems safer to deploy and easier to maintain. Now, through open source collaboration, we have the opportunity to evolve these principles to better serve today’s developers while maintaining the operational rigor that made Twelve-Factor so influential in the first place.

We invite you to join the community and contribute to the next generation of cloud-native platform development. Visit our GitHub repository to learn more about how you can participate in shaping the future of Twelve-Factor methodology.

  
All Posts

Why Intuit is Thrilled About the Evolution of the Twelve-Factor Model by Brett Weaver 03 Apr, 2025

Evolving Twelve-Factor: Applications to Modern Cloud-Native Platforms by Brian Hammons 10 Feb, 2025

December Monthly Updates by Vish Abrams 3 Dec, 2024

Twelve-Factor App Methodology is now Open Source by Yehuda Katz 12 Nov, 2024

Narrow Conduits and the Application-Platform Interface by Vish Abrams 12 Nov, 2024\n\n\n\nDecember Monthly Updates

3 Dec, 2024

Vish Abrams

 Welcome to our first monthly update! We’re excited to share our progress and what’s coming next.

What We’ve Been Working On

In addition to some minor formatting fixes, our initial focus has been on getting organized for larger updates. Here are the key activities:


KubeCon: We announced the open sourcing of Twelve-Factor at KubeCon and had our first in-person office hours meetings. Thank you to everyone who joined our discussions there! If you missed the announcements, you can watch our two brief keynotes: * The Twelve-Factor App, Rebooted * Honoring the Past to Forge Ahead

Concepts and Examples Separation: We’ve started separating core concepts from examples to make the manifesto more accessible and clear (issue #13). This is an essential first step in making further updates easier to navigate.

Planning for Larger Changes: We’ve already started planning for some larger changes. Details are provided in the next section.


Current Proposals Under Discussion

After separating the concepts and examples, we’re focusing on some bigger structural and conceptual updates. We’re discussing these in proposals to gather community feedback and ensure we get the details right:


Adding a Factor for Workload Identity: This proposal introduces a new factor to address workload identity and improve security practices (issue #9).

Modifying the Config Factor: We’re proposing updates to the configuration factor to allow for the use of mounted volumes, expanding how configuration data can be handled in cloud environments (issue #4).

Updating the Logging Factor: This proposal aims to expand the logging factor to include telemetry, reflecting modern observability practices (issue #3).


What’s Next

Our next steps will be:


Continuing the Separation Work: We’ll finish separating concepts from examples as part of laying a solid foundation for further updates, with a pull request for each factor.

Updating the Examples: After completing the separation of concepts, we will update the examples to reflect modern technology.

Introducing Labeling or ‘Facets’ for Factors: We are starting an early discussion about introducing labeling, or ‘facets,’ for factors to help better organize and categorize the work.

Working on Larger Rewrites: Once the initial restructuring is complete, we’ll begin rewriting specific factors to better reflect the evolving needs of cloud-native applications. These changes will be developed collaboratively through the proposal process.


Community collaboration has been fantastic, and we’re excited to build on this momentum. Stay tuned for more updates, and thank you for your continued contributions!

To stay involved, join our discussions on Discord and take part in our weekly meetings every Thursday at 8 AM PST. We’d love to have your input!

  
All Posts

Why Intuit is Thrilled About the Evolution of the Twelve-Factor Model by Brett Weaver 03 Apr, 2025

Evolving Twelve-Factor: Applications to Modern Cloud-Native Platforms by Brian Hammons 10 Feb, 2025

December Monthly Updates by Vish Abrams 3 Dec, 2024

Twelve-Factor App Methodology is now Open Source by Yehuda Katz 12 Nov, 2024

Narrow Conduits and the Application-Platform Interface by Vish Abrams 12 Nov, 2024\n\n\n\nTwelve-Factor App Methodology is now Open Source

12 Nov, 2024

Yehuda Katz

 Join us in modernizing the twelve-factor app manifesto together. As a community of app, framework and platform developers, we’re working together to refresh this foundational document for the modern era. While it’s not software we’re working on, we’ll use familiar processes like pull requests, issues, and reviews to collaborate together in the twelve-factor project repo.

This initiative builds on a strong foundation laid by Heroku when they originally created “The Twelve-Factor App” all the way back in 2011, a time when container-based deployment was still just emerging. Back then, developers could get apps running on their local machines, but common development mistakes often made it challenging to deploy those apps to production.

The twelve-factor app started from a basic goal: you should be able to develop your app locally following your framework’s documentation and deploy it to production without tailoring it to a specific platform. To make this vision a reality, Twelve-Factor documented common pitfalls Heroku observed and organized them into a philosophy for building applications designed for deployment without thinking about deployment.

The philosophy of Twelve-Factor turned out to be surprisingly timeless. More than a decade later, people still find its insights valuable, and it’s often cited as a solid set of best practices for application development. But while the concepts remain relevant, many of the details have started to show their age.

Together with the community, we have begun an effort to refresh Twelve-Factor so people can apply its timeless concepts within the modern ecosystem. With Open Source governance, the refreshed Twelve-Factor will be a living document that evolves with the community, staying relevant as technology evolves.

It’s been exciting to see the interest from the broader community and the collaboration that’s starting to take shape. Our initial call for participation brought so many folks to the conversation and we are honored to have an amazing initial set of maintainers to kick off the project. Together we have been collaborating to define the project’s purpose and governance while taking the first steps to refine and modernize the principles.

The Twelve-Factor community is excited to continue this work. Meet our maintainers and hear from them on their excitement and interest in the project:

“The twelve-factor application definition was an early signpost on the direction of serverless and best practices for writing distributed applications. Twelve-Factor and the Heroku experience were key inspirations for Knative and Google Cloud Run, and I’m excited to be able to give back in updating these practices for the next generation of developers.”– Evan Anderson (Independent)

“The twelve-factor principles captured a powerful simplicity that has influenced how we design applications for scalability and resilience. In updating these ideas, I’m focused on clarifying what makes a twelve-factor app distinct and effective in a cloud-native world, maintaining that balance between restriction and operational power. By doubling down on these boundaries, we can ensure the manifesto remains as impactful today as it was in its first chapter.” – Vish Abrams (Chief Architect, Heroku)

“When I first encountered the twelve-factor application principles, it felt like a light bulb went off, and things clicked in my understanding of service development. These insights, drawn from both my own experience and the collective knowledge of others, have been instrumental in advancing system design in Intuit, as well as across the industry. I believe that, through collaboration with the community, we have a unique opportunity to shape the future of service and platform development for years to come.”–Brett Weaver (Distinguished Engineer, Intuit)

We’ll be sharing monthly updates on this blog about the changes we’re making as a community and what’s next for the project. You’ll also find analysis and discussion of the factors and software development more broadly. We plan to dive into trade-off discussions, explore Twelve-Factor from different perspectives, clarify the underlying principles we’re relying on, and provide case studies of twelve-factor implementations. The first analysis post is about Narrow Conduits and the Application-Platform Interface.

Have an idea you’d like to share or discuss? Join us on Discord – we’d love to see you at an upcoming community meeting.

  
All Posts

Why Intuit is Thrilled About the Evolution of the Twelve-Factor Model by Brett Weaver 03 Apr, 2025

Evolving Twelve-Factor: Applications to Modern Cloud-Native Platforms by Brian Hammons 10 Feb, 2025

December Monthly Updates by Vish Abrams 3 Dec, 2024

Twelve-Factor App Methodology is now Open Source by Yehuda Katz 12 Nov, 2024

Narrow Conduits and the Application-Platform Interface by Vish Abrams 12 Nov, 2024\n\n\n\nNarrow Conduits and the Application-Platform Interface

12 Nov, 2024

Vish Abrams

 Welcome to the twelve-factor maintainters blog. As stated in our announcement, some of our posts will analyze the manifesto more generically. This is the first post in that vein, where we dive into the interface between the application and the platform.

It is well understood that defining a clear contract between parts of a system allows one to shed cognitive load on either side of the contract. This has been called the “narrow-waist” principle which has some unfortunate connotations, so we’ll refer to it as the “narrow-conduit” principle. This principle is especially valuable when the humans on either side of the conduit have dramatically different concerns.

One way to think about twelve-factor as a whole is a narrow conduit between the application developer and the platform developer. The Manifesto provides other conduits as well, but this is a good place to start the discussion. Historically, for application developers this interface was source code, and the source code was ultimately handed off to an operations team. As software evolved through the era of DevOps, the hand-off morphed from code into a container image, with the development team generally taking on the container building duties.

As systems have become more distributed, the deployment and management of multiple containers have become the developers’ concern, with many companies focusing operations teams on building and maintaining a platform and development teams operating the systems themselves.

This has led to application developers writing code for container orchestration systems directly, often relying on templating systems like helm or infrastructure as code systems like terraform to do the heavy lifting. The challenge with this approach is that the world of the application developer is no longer simple. Development, build, and deployment concerns are all mixed together. We no longer have a narrow conduit.

In an ideal world an application developer would only need to worry about their source code and the platform would take care of everything else. Reducing the conduit aperture back to this level is challenging because it means eliminating features. It is necessary to ask: what functionality can we sacrifice on the altar of simplicity.

Ultimately, what we are looking for is a perfect balance: enough functionality to solve real problems, but not so much that we fall into the sea of complexity. The de-facto interface that has evolved between an application developer and the platform, the container orchestration system, is actually the wrong interface. It works, but it does not provide the cleanest and most valuable contract between the two worlds. Application developers should optimally stay focused on their application code. They need clear interfaces to be able to refer to connected systems from within the code. The container is a useful artifact for deployment consistency, but its existence is an implementation detail of the platform.

Instead, the contract needs to focus on how platform information makes its way into application code. For example: how does the application code know where it is reachable on the internet? How does it securely connect with other systems? It is the role of the platform to provide a mechanism for configuration information. Conversely, it is the role of the application to be built in a way that it can be deployed anywhere and scaled automatically so the platform can do its job.

One of the primary purposes of the twelve-factor update is to refresh this contract between the application and the platform in a way that makes both application developers and platform developers lives easier. Without this agreement, applications become special snowflakes that are both unmaintainable and un-operatable.

One of the most challenging aspects of this change is managing expectations for engineers that feel like they are losing something. Having access to a full orchestration system allows application developers to build anything, and shrinking the interface means reducing their power. The payoff is worth the loss: less application complexity and simplified operations. The cat is running wild, but we all benefit if we can find a way to coax it back into the bag.

  
All Posts

Why Intuit is Thrilled About the Evolution of the Twelve-Factor Model by Brett Weaver 03 Apr, 2025

Evolving Twelve-Factor: Applications to Modern Cloud-Native Platforms by Brian Hammons 10 Feb, 2025

December Monthly Updates by Vish Abrams 3 Dec, 2024

Twelve-Factor App Methodology is now Open Source by Yehuda Katz 12 Nov, 2024

Narrow Conduits and the Application-Platform Interface by Vish Abrams 12 Nov, 2024\n\n\n\nWhy Intuit is Thrilled About the Evolution of the Twelve-Factor Model

03 Apr, 2025

Brett Weaver

 At Intuit, we’ve long embraced the twelve-factor app principles as a guiding framework for modern software development. As a company building cutting-edge development tools and runtime platforms for our internal engineers, these principles have been instrumental in unifying service developers, platform engineers, and SREs under a shared philosophy. read on…

Evolving Twelve-Factor: Applications to Modern Cloud-Native Platforms

10 Feb, 2025

Brian Hammons

 The recent open sourcing of the Twelve-Factor App Methodology comes at a transformative moment for cloud-native platforms. As organizations increasingly rely on cloud-native technologies to power mission-critical workloads, the principles behind Twelve-Factor offer timeless foundations that remain relevant for modern platform builders. read on…

December Monthly Updates

3 Dec, 2024

Vish Abrams

 Welcome to our first monthly update! We’re excited to share our progress and what’s coming next.

What We’ve Been Working On

In addition to some minor formatting fixes, our initial focus has been on getting organized for larger updates. Here are the key activities: read on…

Twelve-Factor App Methodology is now Open Source

12 Nov, 2024

Yehuda Katz

 Join us in modernizing the twelve-factor app manifesto together. As a community of app, framework and platform developers, we’re working together to refresh this foundational document for the modern era. While it’s not software we’re working on, we’ll use familiar processes like pull requests, issues, and reviews to collaborate together in the twelve-factor project repo.

This initiative builds on a strong foundation laid by Heroku when they originally created “The Twelve-Factor App” all the way back in 2011, a time when container-based deployment was still just emerging. Back then, developers could get apps running on their local machines, but common development mistakes often made it challenging to deploy those apps to production. read on…

Narrow Conduits and the Application-Platform Interface

12 Nov, 2024

Vish Abrams

 Welcome to the twelve-factor maintainters blog. As stated in our announcement, some of our posts will analyze the manifesto more generically. This is the first post in that vein, where we dive into the interface between the application and the platform.

It is well understood that defining a clear contract between parts of a system allows one to shed cognitive load on either side of the contract. This has been called the “narrow-waist” principle which has some unfortunate connotations, so we’ll refer to it as the “narrow-conduit” principle. This principle is especially valuable when the humans on either side of the conduit have dramatically different concerns. read on…\n\n\n\nIntroduction

In the modern era, software is commonly delivered as a service: called web apps, or software-as-a-service. The twelve-factor app is a methodology for building software-as-a-service apps that:


Use declarative formats for setup automation, to minimize time and cost for new developers joining the project;

Have a clean contract with the underlying operating system, offering maximum portability between execution environments;

Are suitable for deployment on modern cloud platforms, obviating the need for servers and systems administration;

Minimize divergence between development and production, enabling continuous deployment for maximum agility;

And can scale up without significant changes to tooling, architecture, or development practices.


The twelve-factor methodology can be applied to apps written in any programming language, and which use any combination of backing services (database, queue, memory cache, etc).

Background

The contributors to this document have been directly involved in the development and deployment of hundreds of apps, and indirectly witnessed the development, operation, and scaling of hundreds of thousands of apps via our work on the Heroku platform.

This document synthesizes all of our experience and observations on a wide variety of software-as-a-service apps in the wild. It is a triangulation on ideal practices for app development, paying particular attention to the dynamics of the organic growth of an app over time, the dynamics of collaboration between developers working on the app’s codebase, and avoiding the cost of software erosion.

Our motivation is to raise awareness of some systemic problems we’ve seen in modern application development, to provide a shared vocabulary for discussing those problems, and to offer a set of broad conceptual solutions to those problems with accompanying terminology. The format is inspired by Martin Fowler’s books Patterns of Enterprise Application Architecture and Refactoring.

Who should read this document?

Any developer building applications which run as a service. Ops engineers who deploy or manage such applications.

The Twelve Factors

I. Codebase

One codebase tracked in revision control, many deploys

II. Dependencies

Explicitly declare and isolate dependencies

III. Config

Store config in the environment

IV. Backing services

Treat backing services as attached resources

V. Build, release, run

Strictly separate build and run stages

VI. Processes

Execute the app as one or more stateless processes

VII. Port binding

Export services via port binding

VIII. Concurrency

Scale out via the process model

IX. Disposability

Maximize robustness with fast startup and graceful shutdown

X. Dev/prod parity

Keep development, staging, and production as similar as possible

XI. Logs

Treat logs as event streams

XII. Admin processes

Run admin/management tasks as one-off processes\n\n\n\nWelcome to the Twelve-Factor community!

Thank you for your interest in the twelve-factor manifesto. Here are some suggestions for getting started with the community:



Familiarize Yourself with the Project


Begin by reviewing the Twelve-Factor Manifesto to see the current state.

Check out the Twelve-Factor Vision to understand the project’s goals and principles.

Take a look at the Twelve-Factor Governance document to familiarize yourself with how we operate.




Join the Discussion


Participate in discussions on open issues.

Broader discussions often happen on the mailing list

Near real-time collaboration happens on discord

Respectful dialogue and collaboration a key to our community’s success.




Find an Area to Contribute


Contributions come in many forms: documentation, bug fixes, new features, or participating in discussions.

Look for open issues on our GitHub repository that are tagged as good first issue for beginners, or explore areas where you feel you can provide value.

More details can be found in The Contributing document.




Meetings

The maintainers group meets weekly in our discord at 8:30 AM PST.

Invite links: (gcal) (ics)

  
    
Maintainers

Vish Abrams

Heroku/Salesforce

 Vish Abrams is Chief Architect at Heroku, a subsidiary of Salesforce. Formerly he helped Oracle create their cloud, where he focused on virtualization, containerization, and machine learning. He was also NASA Nebula Technical Lead during the creation of Nova, one of the founding OpenStack projects, and was a member of both the OpenStack board and technical committee.

Evan Anderson

Stacklok (independent)

 Evan worked for about 15 years in Google’s cloud, with about 10 years in the public cloud. During that time, he was a founding member of the Google Compute Engine team, then worked on App Engine (control plane API), Cloud Functions, and Knative/Cloud Run. In 2019, he moved to VMware, where he spent 4 years on VMware Tandy, VMware’s cloud-native developer platform. He’s also the author of “Designing Serverless Applications with Knative”, and has held many leadership roles in Knative over the years.

Brian Hammons

AWS

 Brian Hammons, a Principal Solutions Architect at AWS, is an original member of the launch team for Amazon EKS. He has held crucial roles in growing the service from its inception including co-founding projects such as eksworkshop.com, Data on EKS (DoEKS), and CNOE. Brian leads Application Modernization and Developer Productivity practice areas for AWS Strategic Industries as well as the Open Source Technical Field Community (TFC) of AWS Worldwide Specialists (WWSO).

Grace Jansen

IBM

 Grace is a Java Champion and Developer Advocate at IBM. She has been with IBM since graduating with a Degree in Biology. Grace enjoys bringing a varied perspective to her projects and using her knowledge of biological systems to simplify complex software patterns. As a developer advocate, Grace builds POC’s, demos, sample applications and tutorials. She is a regular presenter at international conferences and has authored a book on reactive systems.

Yehuda Katz

Heroku/Salesforce

 Yehuda is a True Believer in the power of the open web, especially when the web evolves as a collaboration between browser vendors, framework authors and application developers.

He is one of the creators of Ember.js, and a retired member of the Rust, the Ruby on Rails and jQuery Core Teams. He is an occasional member of ECMAScript’s TC39 standards committee, and a former member of the W3C’s TAG (Technical Architecture Group).

He was the co-author of the Extensible Web Manifesto, of which he is still very proud.

Joe Kutner

Salesforce

 Joe is co-founder of the Cloud Native Buildpacks project, which aims to make containerization more secure and developer friendly. He started the project in 2018 while working as DX Architect at Salesforce Heroku, and today is the DX Architect for Salesforce’s Hyperforce platform.

Terence Lee

Heroku/Salesforce

 Terence is an architect at Heroku where he helped create Classic Buildpacks and then later co-founded Cloud Native Buildpacks, a CNCF Incubation Project. In the Ruby community he’s been a maintainer on projects such as Ruby itself, Bundler, and Resque, but is mostly known for getting people together for #rubykaraoke. When he’s not going to an awesome event, he lives in Austin, TX where it’s acceptable to eat a taco for every meal of the day.

James Ward

AWS

 Professional software developer since 1997, with much of that time spent helping developers build software that doesn’t suck. A Typed Pure Functional Programming zealot who often compromises on his ideals to just get stuff done. Currently a Developer Advocate for AWS.

Brett Weaver

Intuit

 Brett Weaver is a Distinguished Engineer at Intuit. He has spent the last twenty two odd years at Intuit in various software development and systems engineer roles. He has been focused on building distributed, scalable architectures for Intuit’s flagship products including Quickbooks and TurboTax. Most recently, Brett has been leading architecture for Intuit’s internal services platform.

Emeritus

Gail Frederick

Heroku/Salesforce

 As Heroku CTO, Gail is a Salesforce leader known for her technical excellence and drive to deliver. She stewards the opinionated magic that is Heroku’s developer platform. Prior to Heroku, Gail led engineering for Salesforce DX. Her values are integrity, impact, and joy. Previously, VP Engineering at eBay, where she was the 2019 winner of the John Donahoe Award, eBay’s highest leadership award, for building a new $3B annual GMB business by reinventing eBay’s developer ecosystem. Member of 2024 Curve Power List of 50 LGBTQ+ women and non-binary leaders. Formerly, executive advisory board member of Lesbians Who Tech, Business Governing Board member of OpenAPI Initiative at the Linux Foundation, and represented eBay at the founding of the Facebook-led Libra Initiative. Gail holds 9 software patents.

Steren Giannini

Google Cloud

 Steren is an engineer turned product manager. He is leading product management for Google Cloud’s serverless portfolio (Cloud Run, Cloud Run functions, App Engine). He is a founding member of Cloud Run.

https://twitter.com/steren

https://www.linkedin.com/in/steren

https://steren.fr\n\n\n\nI. Zdrojový kód

Mějte jeden zdrojový kód ve verzovacím systému a mnoho nasazení.

Twelve-factor aplikace je vždy sledována ve verzovacím systému, jako je například Git, Mercurial nebo Subversion. Kopie verzovací databáze se nazývá kódový repozitář, často zkracováno jako repozitář nebo jen repo.

Zdrojový kód je jakýkoliv repozitář (v centralizovaném verzovacím systému jako je Subversion), nebo jakákoliv skupina repozitářů, které mají společný kořenový commit (v decentralizovaném verzovacím systému jako je Git).



Vždy existuje korelace jedna-ku-jedné mezi zdrojovým kódem a aplikací:


Pokud existuje více zdrojových kódů, nejedná se o aplikaci, ale o distribuovaný systém. Každá komponenta distribuovaného systému je dílčí aplikace, která může samostatně podléhat twelve-factor metodice.

Více aplikací sdílejících stejný kód je porušení twelve-factor metodiky. Řešením je oddělení sdíleného kódu do knihovny, která se připojí pomocí systému na správu závislostí.


Každá aplikace má pouze jeden zdrojový kód, ale nasazení jedné aplikace bude vícero. Nasazení je běžící instance aplikace. Typicky je to produkční web a jeden nebo více testovacích webů. Každý vývojář má navíc lokální vývojovou kopii běžící aplikace, každou takovou kopii lze také považovat za nasazení.

Zdrojový kód je stejný ve všech nasazeních, v každém nasazení však mohou být aktivní různé verze. Například vývojář má několik commitů, které ještě nejsou nasazeny v testovacím prostředí a na testovacím prostředí jsou commity, které zatím nejsou na produkci. Všechny verze však sdílejí jeden zdrojový kód a dá se tedy říct, že jsou různými nasazeními téže aplikace.\n\n\n\nI. Codebase

Eine im Versionsmanagementsystem verwaltete Codebase, viele Deployments

Eine Zwölf-Faktor-App wird immer in einem Versionsmanagementsystem verwaltet, wie zum Beispiel Git, Mercurial oder Subversion. Eine Kopie der Versionsdatenbank wird Code Repository genannt, kurz Code Repo oder auch nur Repo.

Eine Codebase ist jedes einzelne Repo (in einem zentralisierten Versionsmanagementsystem wie Subversion) oder jede Menge von Repos, die einen ursprünglichen Commit teilen (in dezentralisierten Versionsmanagementsystemen wie git).



Es gibt immer eine eineindeutige Korrelation zwischen einer Codebase und einer App:


Wenn es mehrere Codebases gibt, ist es keine App – sondern ein verteiltes System. Jede Komponente in einem verteilten System ist eine App, und Jede kann für sich den zwölf Faktoren entsprechen.

Wenn mehrere Apps denselben Code teilen, verletzt dies die zwölf Faktoren. Lösen lässt sich dies, indem man den gemeinsamen Code in Bibliotheken auslagert und über die Abhängigkeitsverwaltung lädt.


Es gibt nur eine Codebase pro App aber viele Deploys der App. Ein Deploy ist eine laufende Instanz der App. Meist gibt es ein Produktionssystem und eines oder mehrere Staging-Systeme. Zusätzlich hat jeder Entwickler eine Kopie der App in seiner lokalen Entwicklungsumgebung, das sind auch Deploys.

Die Codebase ist über alle diese Deploys hinweg dieselbe, auch wenn bei jedem Deploy unterschiedliche Versionen aktiv sind. So hat zum Beispiel ein Entwickler manche Commits noch nicht nach Staging deployt; Staging hat manche Commits noch nicht nach Produktion deployt. Aber alle teilen dieselbe Codebase, was sie als verschiedene Deploys derselben App auszeichnet.\n\n\n\nI. Βάση Κώδικα

Μία βάση κώδικα με έλεγχο εκδόσεων, πολλές αναπτύξεις

Μια εφαρμογή δώδεκα παραγόντων είναι πάντα διαχειριζόμενη από ένα σύστημα ελέγχου εκδόσεων κώδικα (version control system), όπως το Git, το Mercurial, ή το Subversion. Ένα αντίγραφο της βάσης αλλαγών του συστήματος είναι γνωστό ως αποθετήριο κώδικα (code repository), συχνά συντομευμένο σε αποθετήριο (code repo ή repo).

Μια βάση κώδικα (codebase) είναι είτε ένα οποιοδήποτε αποθετήριο (σε ένα κεντρικά διαχειριζόμενο σύστημα όπως το Subversion), είτε ένα οποιοδήποτε σύνολο από αποθετήρια τα οποία μοιράζονται μία κοινή ρίζα εισαγωγής κώδικα (σε ένα αποκεντρωμένο σύστημα διαχείρισης όπως το Git).



Υπάρχει πάντα μια σχέση ένα-προς-ένα μεταξύ της βάσης κώδικα και της εφαρμογής:


Αν υπάρχουν πολλαπλές βάσεις κώδικα, δεν είναι εφαρμογή – είναι ενα κατανεμημένο σύστημα. Κάθε μέρος του κατανεμημένου συστήματος είναι εφαρμογή, και το καθένα ξεχωριστά μπορεί να συνάδει με τους δώδεκα παράγοντες.

Πολλαπλές εφαρμογές οι οποίες μοιράζονται τον ίδιο κώδικα συνιστά παράβαση των δώδεκα παραγόντων. Η λύση εδώ είναι να παραγοντοποιηθεί ο κοινός κώδικας σε βιβλιοθήκες οι οποίες μπορούν να εισαχθούν μέσω του διαχειριστή εξαρτήσεων.


Υπάρχει μόνο μία βάση κώδικα ανά εφαρμογή, αλλά θα υπάρξουν πολλές αναπτύξεις της εφαρμογής. Μια ανάπτυξη (deploy) της εφαρμογής, είναι μία εκτελούμενη ενσάρκωση της εφαρμογής. Αυτό τυπικά είναι μία τοποθεσία παραγωγής (production site), και μία ή περισσότερες τοποθεσίες ελέγχου (staging sites). Επιπλέον, κάθε προγραμματιστής έχει ένα αντίγραφο της εφαρμογής εκτελούμενο τοπικά στο περιβάλλον του, το οποίο επίσης συνιστά μια ανάπτυξη.

Η βάση κώδικα είναι η ίδια για όλες τις αναπτύξεις, παρόλαυτά διαφορετικές εκδόσεις κώδικα μπορεί να είναι ενεργές ανά ανάπτυξη. Για παράδειγμα, ο προγραμματιστής έχει κάποιες αλλαγές που δεν έχουν ακόμα κατατεθεί στην τοποθεσία ελέγχου, η τοποθεσία ελέγχου έχει κάποιες αλλαγές που δεν έχουν ακόμα κατατεθεί στην παραγωγή. Αλλά όλα μοιράζονται την ίδια βάση κώδικα, έτσι μπορούν να ταυτοποιηθούν ως διαφορετικές αναπτύξεις της ίδιας εφαρμογής.\n\n\n\nI. Código base (Codebase)

Un código base sobre el que hacer el control de versiones y multiples despliegues

Una aplicación “twelve-factor” se gestiona siempre con un sistema de control de versiones, como Git, Mercurial, o Subversion. A la copia de la base de datos de seguimiento de versiones se le conoce como un repositorio de código, a menudo abreviado como repo de código o simplemente repo.

El código base es cualquier repositorio (en un sistema de control de versiones centralizado como Subversion), o cualquier conjunto de repositorios que comparten un commit raíz (en un sistema de control de versiones descentralizado como Git).



Siempre hay una relación uno a uno entre el código base y la aplicación:


Si hay multiples códigos base, no es una aplicación – es un sistema distribuido. Cada componente en un sistema distribuido es una aplicación, y cada uno, individualmente, puede cumplir los requisitos de una aplicación “twelve-factor”.

Compartir código en varias aplicaciones se considera una violación de la metodología “twelve factor”. La solución en este caso es separar el código compartido en librerías que pueden estar enlazadas mediante un gestor de dependencias.


El código base de la aplicación es único, sin embargo, puede haber tantos despliegues de la aplicación como sean necesarios. Un despliegue es una instancia de la aplicación que está en ejecución. Normalmente, se ejecuta en un entorno de producción, y uno o varios entornos de pruebas. Además, cada desarrollador tiene una instancia en su propio entorno de desarrollo, los cuales se consideran también como despliegues.

El código base es el mismo en todos los despliegues, aunque pueden ser diferentes versiones en cada despliegue. Por ejemplo, un desarrollador tiene algunos commits sin desplegar en preproducción; preproducción tiene algunos commits que no están desplegados en producción. Pero todos ellos comparten el mismo código base, de este modo todos son identificables como diferentes despliegues de la misma aplicación.\n\n\n\nI. Base de code

Une base de code suivie avec un système de contrôle de version, plusieurs déploiements

Une application 12 facteurs est toujours suivie dans un système de contrôle de version, tel que Git, Mercurial, ou Subversion. Une copie de la base de données de suivi des révisions est appelée dépôt de code, souvent raccourci en dépôt. Le terme anglais code repository, raccourci en repository et repo est également utilisé.

Une base de code correspond à chaque dépôt (dans un système de contrôle de version centralisé tel que Subversion), ou tout ensemble de dépôts qui partage un commit racine (dans un système de contrôle de version décentralisé comme Git).



Il y a toujours un rapport direct entre la base de code et l’application :


S’il y a plusieurs bases de code, ce n’est pas une application, c’est un système distribué. Chaque composant du système distribué est une application, et chacun peut individuellement respecter la méthodologie 12 facteurs.

Plusieurs applications partageant le même code est une violation des 12 facteurs. La solution dans ce cas est de factoriser le code partagé dans des bibliothèques qui peuvent être intégrées via un gestionnaire de dépendances.


Il y a seulement une base de code par application, mais il y aura plusieurs déploiements de l’application. Un déploiement est une instance en fonctionnement de l’application. C’est, par exemple, le site en production, ou bien un ou plusieurs sites de validation. En plus de cela, chaque développeur a une copie de l’application qui fonctionne dans son environnement local de développement, ce qui compte également comme un déploiement.

La base de code est la même à travers tous les déploiements, bien que différentes versions puissent être actives dans chaque déploiement. Par exemple, un développeur a des commits qui ne sont pas encore déployés dans l’environnement de validation. L’environnement de validation a des commits qui ne sont pas encore déployés en production. Par contre, ils partagent tous la même base de code, ce qui les identifie comme étant des déploiements différents d’une même application.\n\n\n\nI. Codebase

Una sola codebase sotto controllo di versione, tanti deploy

Un’app conforme alla metodologia twelve-factor è sempre sotto un sistema di controllo di versione, sia essa Git, Mercurial, o Subversion. Una copia della codebase è detta code repository, oppure più in breve code repo o repo.

Una codebase è quindi un singolo repository (in un sistema centralizzato come Subversion), oppure un set di repo che condividono una root commit (in un sistema di controllo decentralizzato come Git).



C’è sempre una relazione uno-ad-uno tra codebase e applicazione:


Se ci sono più codebase, non si parla più di applicazione ma di sistema distribuito. Ogni componente in un sistema distribuito è un’applicazione, e ognuna di queste applicazioni può individualmente aderire alla metodologia twelve-factor.

Se più applicazioni condividono lo stesso codice si ha una violazione del twelve-factor. La soluzione è, ovviamente, quella di sistemare il codice in modo adeguato, in modo tale da essere incluso eventualmente dove necessario tramite un dependency manager.


Quindi: una sola codebase per applicazione, ma ci saranno comunque tanti deployment della stessa app. Per deploy si intende un’istanza dell’applicazione. Può essere il software in produzione, oppure una delle varie istanze in staging. Ancora, un deploy può essere la copia posseduta dal singolo sviluppatore nel suo ambiente locale.

La codebase rimane comunque sempre la stessa su tutti i deployment, anche se potrebbero essere attive diverse versioni nello stesso istante. Si pensi per esempio a uno sviluppatore che possiede dei commit in più che non ha ancora mandato in staging. Nonostante questo, comunque, rimane la condivisione della stessa codebase, nonostante la possibilità di avere più deploy della stessa app.\n\n\n\nI. コードベース

バージョン管理されている1つのコードベースと複数のデプロイ

Twelve-Factor AppはGitやMercurial、Subversionなどのバージョン管理システムで常に変更を追跡している。リビジョン追跡データベースのコピーは コードリポジトリ と言われ、単に リポジトリ とも言われる。

コードベース は、単一のリポジトリ（Subversionのような集中バージョン管理システムの場合）またはルートコミットを共有する複数のリポジトリ（Gitのような分散バージョン管理システムの場合）である。



コードベースとアプリケーションの間には、常に1対1の関係がある。


もし複数のコードベースがある場合、それはアプリケーションではない – それは分散システムである。分散システムのそれぞれのコンポーネントがアプリケーションであり、個別にTwelve-Factorに適合することができる。

同じコードを共有する複数のアプリケーションは、Twelve-Factorに違反している。その場合の解決策は、共通のコードをライブラリに分解し、そのライブラリを依存関係管理ツールで組み込むようにすることである。


アプリケーションごとにただ1つのコードベースが存在するが、アプリケーションのデプロイは複数存在する。 デプロイ はアプリケーションの実行中のインスタンスである。これは通常1つの本番サイトと、1つ以上のステージングサイトである。さらにすべての開発者はローカル開発環境で動作するアプリケーションのコピーを持っており、それらもデプロイと見なせる。

デプロイごとに異なるバージョンがアクティブであるかもしれないが、コードベースはすべてのデプロイを通して同一である。例えば、開発者はステージング環境にまだデプロイされていないコミットを抱えているし、ステージング環境には本番環境にデプロイされていないコミットが含まれている。しかし、これらのデプロイはすべて同一のコードベースを共有しているため、同一のアプリケーションの異なるデプロイであると認識できる。\n\n\n\nI. 코드베이스

버전 관리되는 하나의 코드베이스와 다양한 배포

Twelve-Factor 앱은 항상 Git, Mercurial, Subversion 같은 버전 컨트롤 시스템을 사용하여 변화를 추적하며, 버전 추적 데이터베이스의 사본을 코드 저장소, 줄여서 저장소라고 부릅니다.

코드베이스는 단일 저장소(Subversion 같은 중앙 집중식 버전 관리 시스템의 경우) 일수도 있고, 루트 커밋을 공유하는 여러 저장소(Git 같은 분산 버전 관리 시스템)일수도 있습니다.



코드베이스와 앱 사이에는 항상 1대1 관계가 성립됩니다.


코드베이스가 여러개 있는 경우, 앱이 아니라 분산 시스템으로 봐야합니다. 분산 시스템의 개별 구성요소가 앱이 되며, 개별 앱이 Twelve-Factor를 따릅니다.

여러개 앱이 동일한 코드를 공유한다면 Twelve-Factor를 위반하는것입니다. 이를 해결하려면 공유하는 코드를 라이브러리화 시키고, 해당 라이브러리를 종속성 매니저로 관리해야합니다.


앱의 코드베이스는 한개여야 하지만, 앱 배포는 여러개가 될수 있습니다. 배포는 실행중인 앱의 인스턴스를 가리킵니다. 보통 운영 사이트와 여러 스테이징 사이트가 여기에 해당합니다. 모든 개발자는 자신의 로컬 개발 환경에 실행되는 앱을 가지고 있는데, 이것 역시 하나의 배포로 볼 수 있습니다.

배포마다 다른 버전이 활성화 될수 있지만, 코드베이스 자체는 모든 배포에 대해 동일합니다. 예를 들어, 개발자는 아직 스테이징 환경에 배포하지 않은 커밋이 있을 수 있으며, 스테이징 환경에는 아직 운영 환경에 배포되지 않은 커밋이 있을 수 있습니다. 하지만 이 모든 것들이 같은 코드베이스를 공유하고, 같은 앱의 다른 배포라고 할 수 있습니다.\n\n\n\nI. Codebase

Jedno źródło kodu śledzone systemem kontroli wersji, wiele wdrożeń

Aplikacja 12factor zawsze jest zarządzana w systemie kontroli wersji takim jak Git, Mercurial, czy Subversion. Miejsce, w którym trzymany i rewizjonowany jest kod nazywane jest repozytorium kodu źródłowego, często skracane do samego code repo, albo po prostu repo.

Codebase (baza kodu) jest więc niczym innym jak pojedynczym repo (w przypadku zcentralizowanego systemu kontroli wersji jak Subversion), albo zestawem repozytoriów, które współdzielą tzw. root commit. (w przypadku zdecentralizowanego systemu jak Git).



Aplikacja powinna zawsze odzwierciedlać bazowy kod:


Jeśli istnieje wiele źródeł, z których pobierany jest kod, nie można mówić o aplikacji, a systemie rozproszonym. Każdy komponent w systemie rozproszonym będzie wtedy aplikacją i każdy z osobna może spełniać wszystkie zasady 12factor.

Jeśli wiele aplikacji dzieli ten sam kod, mamy do czynienia z naruszeniem 12factor. Wyjściem z tej sytuacji może być wyizolowanie współdzielonego kodu do bibliotek, które będą dodane do aplikacji przez tzw. dependency manager.


Aplikacja może posiadać tylko jeden codebase, jednocześnie mając wiele wdrożeń. Deploy (z ang. wdrożenie) jest działającą instancją aplikacji. Zazwyczaj mówi się o wersji produkcyjnej i jednej lub więcej przedprodukcyjnych. Ponadto każdy developer pracujący nad aplikacją posiada jej kopię działającą w swoim lokalnym środowisku developerskim, co również kwalifikuje się jako osobne wdrożenie.

Codebase jest taki sam dla wszystkich wdrożeń aplikacji, jednak poszczególne wdrożenia aplikacji mogą korzystać z jego różnych wersji. Dla przykładu, developer pracujący nad aplikacją może nanieść zmiany, które nie znajdą się jeszcze w wersji produkcyjnej. Obie wersje dzielą jednak ten sam codebase, przez co kwalifikują się jako osobne wdrożenia tej samej aplikacji.\n\n\n\nI. Base de Código

Uma base de código com rastreamento utilizando controle de revisão, muitos deploys

Uma aplicação 12 fatores é sempre rastreada em um sistema de controle de versão, como Git, Mercurial, ou Subversion. Uma cópia da base de dados do rastreamento de revisões é conhecido como repositório de código, normalmente abreviado como repositório ou repo.

Uma base de código é um único repo (em um sistema de controle de versão centralizado como Subversion), ou uma série de repositórios que compartilham um registro raiz.



Existe sempre uma correlação um-para-um entre a base de código e a aplicação:


Se existem várias bases de código, isto não é uma app – é um sistema distribuído. Cada componente do sistema é uma app, e cada uma pode individualmente ser compatível com os 12 fatores.

Múltiplas apps compartilhando uma base de código é uma violação dos 12 fatores. A solução aqui é dividir o código compartilhado entre bibliotecas que podem ser incluídas através do gerenciador de dependências.


Existe apenas uma base de código por aplicação, mas existirão vários deploys da mesma. Um deploy (ou implantação) é uma instância executando a aplicação. Isto é tipicamente um local de produção, e um ou mais locais de testes. Adicionalmente, todo desenvolvedor tem uma cópia da aplicação rodando em seu ambiente local de desenvolvimento, cada um desses pode ser qualificado como um deploy.

A base de código é a mesma através de todos os deploys, entretanto diferentes versões podem estar ativas em cada deploy. Por exemplo, um desenvolvedor tem alguns registros ainda não implantados no ambiente de teste, o ambiente de teste ainda tem registros não implantados em produção. Mas todos esses ambientes compartilham a mesma base de código, tornando-os identificáveis ​​como diferentes deploys do mesmo app.\n\n\n\nI. Кодовая база

Одна кодовая база, отслеживаемая в системе контроля версий, – множество развёртываний

Приложение двенадцати факторов всегда отслеживается в системе контроля версий, такой как Git, Mercurial или Subversion. Копия базы данных отслеживаемых версий называется репозиторием кода (code repository), что часто сокращается до code repo или просто до репозиторий (repo)

Кодовая база – это один репозиторий (в централизованных системах контроля версий, как Subversion) или множество репозиториев, имеющих общие начальные коммиты (в децентрализованных системах контроля версий, как Git).



Всегда есть однозначное соответствие между кодовой базой и приложением:


Если есть несколько кодовых баз, то это не приложение — это распределённая система. Каждый компонент в распределённой системе является приложением и каждый компонент может индивидуально соответствовать двенадцати факторам.

Факт того, что несколько приложений совместно используют тот же самый код, является нарушением двенадцати факторов. Решением в данной ситуации является выделение общего кода в библиотеки, которые могут быть подключены через менеджер зависимостей.


Существует только одна кодовая база для каждого приложения, но может быть множество развёртываний одного и того же приложения. Развёрнутым приложением (deploy) является запущенный экземпляр приложения. Как правило, это рабочее развёртывание сайта и одно или несколько промежуточных развёртываний сайта. Кроме того каждый разработчик имеет копию приложения, запущенного в его локальном окружении разработки, каждая из которых также квалифицируется как развёрнутое приложение (deploy).

Кодовая база обязана быть единой для всех развёртываний, однако разные версии одной кодовой базы могут выполняться в каждом из развёртываний. Например разработчик может иметь некоторые изменения которые ещё не добавлены в промежуточное развёртывание; промежуточное развёртывание может иметь некоторые изменения, которые ещё не добавлены в рабочее развёртывание. Однако, все эти развёртывания используют одну и ту же кодовую базу, таким образом можно их идентифицировать как разные развёртывания одного и того же приложения.\n\n\n\nI. Zdrojový kód

Jeden zdrojový kód vo verzionovacom systéme, veľa nasadení

Dvanásť faktorová aplikácia je vždy uložená vo verzionovacom systéme ako napríklad Git, Mercurial, alebo Subversion. Kópia databázy verzionovacieho systému sa nazýva repozitár kódu, často skrátene repozitár alebo len repo.

Zdrojový kód je akýkoľvek repozitár (v centralizovanom verzionovacom systéme ako napr. Subversion), alebo akákoľvek skupina repozitárov, ktoré majú spoločný koreňový commit (v decentralizovanm verzionovacom systéme ako napr. Git).



Vždy existuje korelácia jedna k jednej medzi zdrojovým kódom a aplikáciou:


Ak je to viacero zdrojových kódov, nie je to aplikácia – je to distribuovaný systém. Každý komponent v distribuovanom systéme je aplikácia, a každá môže osobitne spĺňať dvanásť faktorov.

Viaceré aplikácie zdieľajúce jeden kód je porušenie dvanástich faktorov. Riešenie je oddelenie zdieľaného kódu do knižníc, ktoré sa pripoja pomocou správy závislostí.


Každá aplikácia má len jeden zdrojový kód, ale nasadení jednej aplikácie bude viacero. Nasadenie je bežiaca inštancia aplikácie. Typicky je to produkčný web a jeden alebo viacero testovacích webov. Navyše, každý developer má kópiu bežiacej aplikácie vo svojom vlastnom vývojovom prostredí, z ktorých každé sa ráta ako nasadenie.

Zdrojový kód je rovnaký na všetkých nasadeniach, aj keď samozrejvie rôzne verzie môžu byť aktívne na rôznych nasadeniach. Napríklad, developer má niekoľko commitov, ktoré nie sú nasadené na testovacom prostredí a na testovacom prostredí sú commity, ktoré ešte nie sú na produkcii. Ale všetky zdieľajú jeden zdrojový kód a dá sa teda povedať, že sú rôznymi nasadeniami jednej aplikácie.\n\n\n\nI. Codebase

มีเพียง codebase เดียวที่ติดตามด้วย version control, มีหลาย deploy

Twelve-factor app สามารถติดตามได้เสมอด้วย version control เช่น Git, Mercurial, หรือ Subversion สำเนาของฐานข้อมูลติดตาม version เรียกว่า code repository หรือเรียกสั้นๆว่า code repo หรือเรียกเพียงแค่ repo

codebase เป็น repo เดียวใดๆ (ในระบบ version control ที่มีศูนย์กลางอย่างเช่น Subversion) หรือเป็นเซตของ repo ซึ่งแบ่งปัน root commit (ในระบบ version control ที่ไม่มีศูนย์กลางอย่างเช่น Git)



มีความสัมพันธ์แบบ หนี่ง-ต่อ-หนึ่ง เสมอ ระหว่าง codebase และ app:


ถ้ามีหลาย codebase, จะไม่เป็น app – จะเป็นระบบกระจาย (distributed system) แต่ละคอมโพแนนท์ในระบบกระจายเป็น app, และแต่ล่ะคอมโพแนนท์จะปฏิบัติตาม twelve-factor

ถ้ามีหลาย app ที่ใช้งาน code เดียวกันจะเป็นการละเมิด twelve-factor วิธีแก้ปัญหาในที่นี้คือเอา code ที่ใช้ร่วมกันทำเป็น libraries ซึ่งสามารถเข้ากับ factor dependency manager


มีเพียงหนึ่ง codebase ต่อ app แต่มีหลาย deploy หรือการนำไปใช้งานของ app, หนึ่ง deploy จะรัน instance ของ app นี่เป็น production site และมีหนึ่งหรือมากว่า staging site เพิ่มเติม, developer ทุกคนจะมีสำเนาเดียวของ app ที่ทำงานอยู่บนสิ่งแวดล้อมพัฒนาในเครื่องของตนเอง ซึ่งจัดได้ว่าเป็น deploy ด้วยเช่นกัน

Codebase จะเหมือนกันตลอดทั้ง deploy ทั้งหมด แม้ว่า version จะแตกต่างกันอาจจะทำงานในแต่ล่ะ deploy ตัวอย่างเช่น developer มีบาง commit ที่ยังไม่ได้ deploy ไปยัง staging ซึ่ง staging จะมีบาง commit ที่ยังไม่ได้ deploy ไปยัง production แต่ทั้งหมดจะใช้ codebase เดียวกัน ดังนั้นจะต้องทำให้ระบุตัวตนได้ว่าเป็น deploy ที่แตกต่างกันของ app เดียวกัน\n\n\n\nI. Kod Tabanı

Sürüm kontrol sistemi üzerinde tek bir kod tabanı, birden fazla dağıtım

On iki faktör bir uygulama her zaman Git, Mercurial veya Subversion gibi bir sürüm kontrol sistemiyle izlenir. Bu sürüm kontrol sistemindeki dosya veritabanına kod deposu (İng. code repository) veya kısaca depo (İng. repo) denir.

Bir kod tabanı, tek bir depo (Subversion gibi merkezi sürüm kontrol sistemi) ya da kök commit paylaşan birden fazla depodan (Git gibi merkezi olmayan sürüm kontrol sistemi) oluşur.



Kod tabanı ve uygulama arasında her zaman birebir ilişki vardır:


Eğer birden fazla kod tabanı varsa bu bir uygulama değil, dağıtık sistemdir. Dağıtık sistemdeki her bileşen bir uygulamadır ve her biri on iki faktörle bireysel olarak uyumlu olmalıdır.

Aynı kodu paylaşan birden fazla uygulama, on iki faktörü ihlal eder. Burada çözüm, paylaşılan kodun bağımlılık yöneticisi aracılığıyla dahil edilebilecek kütüphanelere dönüştürülmesidir.


Uygulamanın sadece bir kod tabanı vardır fakat birden fazla dağıtımı olacaktır. Bir dağıtım, uygulamanın çalışan bir örneğidir. Bu dağıtımlar genelde bir canlı yayın (İng. production) ve bir veya birkaç test ortamıdır. Ayrıca her geliştiricinin kendi yerel geliştirme ortamında çalışan bir kopyası vardır ve bunların her biri aynı zamanda dağıtım olarak nitelendirilirler.

Dağıtımlarda anlık olarak farklı sürümler etkin olabilir fakat kod tabanı tüm dağıtımlarda aynıdır. Örneğin, bir geliştirici henüz commit’lemediği değişiklikleri çalıştırıyor olabilir, veya test ortamında henüz canlı yayına dağıtılmamış bir sürüm çalışıyor olabilir. Bu nedenle hepsi ayrı dağıtım olarak tanımlanır ama kod tabanı aynıdır.\n\n\n\nI. Кодова база

Одна кодова база, що відслідковується в системі контролю версій та має багато розгортань

Застосунок дванадцяти факторів завжди відслідковуються в системі контролю версій, такій як Git, Mercurial або Subversion. Копія бази даних відстеження ревізій називається репозиторій коду (code repository), що часто скорочується до code repo або просто repo.

Кодова база — це один репозиторій (в централізованих системах контролю версій, як Subversion), або декілька репозиторіїв, які мають спільний початковий комміт (в децентралізованих системах контролю версій, як Git).



Завжди існує однозначна відповідність між кодовою базою і застосунком:


За наявності кількох баз коду, це не застосунок, це — розподілена система. Кожен компонент в розподіленій системі є застосунком, і кожен з них може окремо дотримуватися дванадцяти факторів.

Кілька різних застосунків, що спільно використовують загальну базу коду, є порушенням дванадцяти факторів. Рішенням в даній ситуації є виділення загального коду в бібліотеки, які можуть бути підключені через менеджер залежностей.


Існує тільки одна кодова база для кожного застосунку, але може бути багато розгортань одного і того самого застосунку. Розгортанням (deploy) є запущений екземпляр застосунку. Це, як правило, production-сайт і один або більше staging-сайтів (проміжних розгортань). Крім того, розробник має копію застосунку, запущеного в його локальному середовищі розробки. Кожну з таких копій також можна кваліфікувати як розгортання (deploy).

Кодова база має бути єдина для всіх розгортань, хоча в кожному розгортанні можуть бути активні різні її версії. Наприклад, розробник може мати деякі зміни у коді, які ще не додані в staging-розгортання; staging-розгортання може мати деякі зміни, які ще не додані в production-розгортання. Але всі вони використовують одну і ту саму кодову базу, таким чином можна їх ідентифікувати як різні розгортання одного і того ж застосунку.\n\n\n\nI. Mã gốc (codebase)

Một mã gốc (codebase) được theo dõi với hệ thống quản lý phiên bản, và nhiều lần triển khai (deploy)

Một ứng dụng 12-hệ số luôn luôn được theo dõi bới hê thống quản lý phiên bản, như là Git, Mercurial, hay Subversion. Một bản lưu của cơ sở dữ liệu các phiên bản được gọi là kho mã (code repository), và hay được viết vắn tắt thành code repo hay repo.

Một mã gốc là bất kì một repo riêng lẻ (trong một hệ thống quản lý phiên bản thống nhất như Subversion), hoặc bất kì một nhóm các repo chia sẻ cùng một commit nguồn (root commit) (trong một hệ thống quản lý phiên bản kiểu phân quyển như Git).



Sẽ luôn luôn là sự tương quan một-với-một giữa mã gốc và ứng dụng:


Nếu có nhiều mã gốc, đấy không phải là một ứng dụng – mà là một hệ thống phân tán. Với các phần tử trong một hệ thống phân tán là một ứng dụng, với mỗi cá thể tuân theo luật 12-hệ số.

Nhiều ứng dụng chia sẻ cùng một mã là vi phạm luật của 12-hệ số. Giải pháp ở đây là xem xét để nhóm các mã chia sẻ thành các thư viện mà có thể được nhúng vào thông qua trình quản lý các gói phụ thuộc (dependency manager).


Chỉ có một mã gốc từng ứng dụng, nhưng sẽ có nhiều triển khai của một ứng dụng. Một triển khai là một đối tượng thực thi của ứng dụng đó. Đây là trường hợp rất phổ biến của các trang đã đi vào hoạt động, và của một vài trang thử nghiệm. Thêm vào đó mỗi lập trình viên sẽ có một bản lưu của ứng dụng đang chạy trên môi trường phát triển cá nhân, mỗi bản đều được coi như là một triển khai.

Mã gốc sẽ giống nhau trên các triển khai, tuy là phiên bản khác nhau có thể hoạt dộng trong mỗi triển khai. Lấy một ví dụ, một lập trình viên có nhiều commit nhưng chưa triển khai vào hệ thống thử (staging); hệ thống thử có nhiều commit mà chưa được triển khai trên hệ thống sản xuất (production). Nhưng cả hai đều chia sẻ cùng một mã gốc; thế nên phải định dạng chúng như những cá thể triển khai của cùng một ứng dụng.\n\n\n\nI. 基准代码

一份基准代码（Codebase），多份部署（deploy）

12-Factor应用(译者注：应该是说一个使用本文概念来设计的应用，下同)通常会使用版本控制系统加以管理，如Git, Mercurial, Subversion。一份用来跟踪代码所有修订版本的数据库被称作 代码库（code repository, code repo, repo）。

在类似 SVN 这样的集中式版本控制系统中，基准代码 就是指控制系统中的这一份代码库；而在 Git 那样的分布式版本控制系统中，基准代码 则是指最上游的那份代码库。



基准代码和应用之间总是保持一一对应的关系：


一旦有多个基准代码，就不能称为一个应用，而是一个分布式系统。分布式系统中的每一个组件都是一个应用，每一个应用可以分别使用 12-Factor 进行开发。

多个应用共享一份基准代码是有悖于 12-Factor 原则的。解决方案是将共享的代码拆分为独立的类库，然后使用 依赖管理 策略去加载它们。


尽管每个应用只对应一份基准代码，但可以同时存在多份部署。每份 部署 相当于运行了一个应用的实例。通常会有一个生产环境，一个或多个预发布环境。此外，每个开发人员都会在自己本地环境运行一个应用实例，这些都相当于一份部署。

所有部署的基准代码相同，但每份部署可以使用其不同的版本。比如，开发人员可能有一些提交还没有同步至预发布环境；预发布环境也有一些提交没有同步至生产环境。但它们都共享一份基准代码，我们就认为它们只是相同应用的不同部署而已。\n\n\n\nI. Codebase

One codebase tracked in revision control, many deploys

A twelve-factor app is always tracked in a version control system, such as Git, Mercurial, or Subversion. A copy of the revision tracking database is known as a code repository, often shortened to code repo or just repo.

A codebase is any single repo (in a centralized revision control system like Subversion), or any set of repos who share a root commit (in a decentralized revision control system like Git).



There is always a one-to-one correlation between the codebase and the app:


If there are multiple codebases, it’s not an app – it’s a distributed system. Each component in a distributed system is an app, and each can individually comply with twelve-factor.

Multiple apps sharing the same code is a violation of twelve-factor. The solution here is to factor shared code into libraries which can be included through the dependency manager.


There is only one codebase per app, but there will be many deploys of the app. A deploy is a running instance of the app. This is typically a production site, and one or more staging sites. Additionally, every developer has a copy of the app running in their local development environment, each of which also qualifies as a deploy.

The codebase is the same across all deploys, although different versions may be active in each deploy. For example, a developer has some commits not yet deployed to staging; staging has some commits not yet deployed to production. But they all share the same codebase, thus making them identifiable as different deploys of the same app.\n\n\n\nIV. Podpůrné služby

Nakládejte s podpůrnými službami jako s připojenými zdroji.

Podpůrná služba je jakákoliv služba, kterou aplikace konzumuje přes síť jako součást svého normálního běhu. Příklady zahrnují databáze (jako například MySQL nebo CouchDB), messaging/queueing systémy (jako jsou RabbitMQ nebo Beanstalkd), SMTP služby pro odchozí emaily (jako Postfix) a cachovací systémy (jako je Memcached).

Podpůrné služby, jako například databáze, jsou obvykle spravovány stejnými systémovými inženýry jako samotné nasazení aplikace. K těmto lokálně spravovaným službám může aplikace navíc využívat služby provozované a spravované třetí stranou. To mohou být například SMTP služby (jako je Postmark), služby na sbírání metrik (jako New Relic nebo Loggly), datová uložistě (jako Amazon S3) a dokonce i služby přístupné přes API (jako jsou například Twitter, Google Maps nebo Last.fm).

Kód twelve-factor aplikace nedělá rozdíly mezi lokální službou a službou třetí strany. Z pohledu aplikace jsou to připojené zdroje přístupné přes URL nebo jiné přístupové/přihlašovací údaje uložené v konfiguraci. Nasazení twelve-factor aplikace by mělo být schopné vyměnit lokální MySQL databázi za databázi spravovanou třetí stranou (jako je například Amazon RDS) bez jakýchkoliv změn v aplikačním kódu. Obdobně může být lokální SMTP server nahrazen SMTP službou třetí strany (jako Postmark) bez změn v kódu. V obou případech se změní pouze přístupové a přihlašovací údaje v konfiguraci.

Každá podpůrná služba je zdroj. Například MySQL databáze je zdroj, dvě MySQL databáze (použité pro sharding na aplikační úrovni) kvalifikujeme jako dva různé zdroje. Twelve-factor aplikace nakládá s těmito databázemi jako připojenými zdroji, což naznačuje i jejich volné spojení se souvisejícím nasazením.



Zdroje je možné připojovat a odpojovat z nasazení dle libosti. Například pokud je databáze z důvodu hardwarových problémů nestabilní, systémový inženýr může rozběhnout nový databázový server z aktuální zálohy. Aktuální produkční databáze pak může být odpojena a nová databáze připojena na její místo, vše beze změn v kódu.\n\n\n\nIV. Unterstützende Dienste

Unterstützende Dienste als angehängte Ressourcen behandeln

Ein unterstützender Dienst ist jeder Dienst, den die App über das Netzwerk im Rahmen ihrer normalen Arbeit konsumiert. Beispiele sind Datenspeicher (wie MySQL oder CouchDB), Messaging/Queueing-Systeme (wie RabbitMQ oder Beanstalkd), SMTP-Dienste für das Senden von Mail (wie Postfix), und Cache-Systeme (wie Memcached).

Unterstützende Dienste wie Datenbanken werden traditionell von denselben Systemadministratoren verwaltet, die die App deployen. Außer diesen intern verwalteten Diensten können der App auch von Dritten verwaltete Dienste zur Verfügung stehen. Dazu gehören SMTP-Dienste (wie Postmark), Metrik-Sammler (wie New Relic oder Loggly), Binary-Asset-Dienste (wie Amazon S3), und auch über eine API zugängliche Dienste (wie Twitter, Google Maps, oder Last.fm).

Der Code einer Zwölf-Faktor-App macht keinen Unterschied zwischen lokalen Diensten und solchen von Dritten. Für die App sind sie beide unterstützende Dienste, zugreifbar über eine URL oder andere Lokatoren/Credentials, die in der Konfiguration gespeichert sind. Ein Deploy einer Zwölf-Faktoren-App könnte eine lokale MySQL-Datenbank, durch eine von Dritten zur Verfügung gestellten, ersetzen (wie Amazon RDS). Genauso ohne Codeänderung kann ein lokaler SMTP-Server durch einen von Dritten zur Verfügung gestellten SMTP-Dienst ersetzt werden. In beiden Fällen muss sich nur der Resource-Handle in der Konfiguration ändern.

Jeder einzelne unterstützende Dienst ist eine Ressource. So ist zum Beispiel eine MySQL-Datenbank eine Ressource; zwei MySQL-Datenbanken (die für ein Sharding auf Applikationsebene verwendet werden) stellen zwei Ressourcen dar. Dass die Zwölf-Faktor-App diese Datenbanken als angehängte Ressourcen behandelt, zeigt ihre lose Kopplung, zu dem Deploy an dem sie hängen.



Ressourcen können beliebig an Deploys an- und abgehängt werden. Wenn zum Beispiel die Datenbank einer App aufgrund von Hardwareproblemen aus der Rolle fällt, könnte der App-Administrator eine neue Datenbank aus einem Backup aufsetzen. Die aktuelle Produktionsdatenbank könnte abgehängt und die neue Datenbank angehängt werden – ganz ohne Codeänderung.\n\n\n\nIV. Υπηρεσίες υποστήριξης

Υπηρεσίες υποστήριξης ως επισυναπτόμενοι πόροι

Μία υπηρεσία υποστήριξης (backing service) είναι οποιαδήποτε υπηρεσία την οποία η εφαρμογή καταναλώνει μέσω του δικτύου ως μέρος της κανονικής λειτουργίας της. Παραδείγματα περιλαμβάνουν τις αποθήκες δεδομένων (datastores) (όπως η MySQL ή η CouchDB), τα συστήματα μηνυμάτων/ουρών (messaging/queueing systems) (όπως το RabbitMQ ή το Beanstalkd), τις υπηρεσίες SMTP για εξερχόμενη ηλεκτρονική αλληλογραφία (όπως το Postfix), και συστήματα προσωρινής μνήμης (caching systems) (όπως το Memcached).

Υπηρεσίες υποστήριξης όπως η βάση δεδομένων παραδοσιακά διαχειρίζονται από τους ίδιους διαχειριστές συστημάτων που εγκαθιστούν την εφαρμογή. Πρόσθετα σε αυτές τις τοπικά διαχειριζόμενες υπηρεσίες, η εφαρμογή μπορεί επίσης να έχει και υπηρεσίες που προσφέρονται και διαχειρίζονται από τρίτους. Παραδείγματα περιλαμβάνουν υπηρεσίες SMTP (όπως το Postmark), υπηρεσίες στατιστικών εφαρμογής (όπως το New Relic ή το Loggly), υπηρεσίες δυαδικών επισυναπτόμενων αρχείων (binary asset services) (όπως το Amazon S3), και ακόμα καταναλωτικές υπηρεσίες προσβάσιμες μέσω API (όπως το Twitter, Google Maps, ή το Last.fm).

Ο κώδικας μιας εφαρμογής δώδεκα παραγόντων δεν κάνει καμία διάκριση μεταξύ τοπικών υπηρεσιών και υπηρεσιών τρίτων. Για την εφαρμογή, και οι δύο είναι επισυναπτόμενοι πόροι, προσβάσιμοι μέσω ενός URL ή μέσω άλλων εντοπιστών/διαπιστευτηρίων που αποθηκέυονται ως παράμετροι (config). Μία ανάπτυξη της εφαρμογής δώδεκα παραγόντων θα πρέπει να είναι ικανή να αντικαταστήσει μια τοπική βάση δεδομένων MySQL με μία άλλη διαχειριζόμενη από τρίτους (όπως η Amazon RDS) χωρίς καμία αλλαγή στον κώδικα της εφαρμογής. Παρομοίως, ένας τοπικός εξυπηρετητής SMTP μπορεί να αντικατασταθεί από μία υπηρεσία SMTP από τρίτους (όπως το Postmark) χωρίς αλλαγές στον κώδικα. Και στις δύο περιπτώσεις, μόνο το αναγνωριστικό του πόρου (resource handle) στις παραμέτρους πρέπει να αλλάξει.

Κάθε διακριτή υπηρεσία υποστήριξης είναι ένας πόρος (resource). Για παράδειγμα, μία βάση δεδομένων MySQL είναι ένας πόρος, δύο βάσεις δεδομένων MySQL (που χρησιμοποιούνται για κομμάτιασμα στο επίπεδο εφαρμογής) είναι δύο διακριτοί πόροι. Η εφαρμογή δώδεκα παραγόντων φέρεται σε αυτές τις βάσεις δεδομένων σαν να είναι επισυναπτόμενοι πόροι (attached resources), το οποίο σηματοδοτεί την χαλαρή σύνδεση (loose coupling) με την ανάπτυξη της εφαρμογής (deploy) στην οποία επισυνάπτονται.



Οι πόροι μπορεί να προστεθούν και να καταργηθούν από μία ανάπτυξη της εφαρμογής κατά βούληση. Για παράδειγμα, εάν η βάση δεδομένων της εφαρμογής λανθάνει λόγω αστοχίας του υλικού (hardware issue), ο διαχειριστής της εφαρμογής μπορεί να σηκώσει ένα νέο εξυπηρετητή βάσης δεδομένων από ένα πρόσφατο αντίγραφο ασφαλείας. Η τρέχουσα βάση δεδομένων της παραγωγής μπορεί να καταργηθεί, και η νέα βάση δεδομένων να προστεθεί – όλα χωρίς καμία αλλαγή στον κώδικα.\n\n\n\nIV. Backing services

Tratar a los “backing services” como recursos conectables

Un backing service es cualquier recurso que la aplicación puede consumir a través de la red como parte de su funcionamiento habitual. Entre otros ejemplos, podemos encontrar bases de datos (como MySQL o CouchDB), los sistemas de mensajería y de colas (como RabbitMQ o Beanstalkd), los servicios SMTP de email (como Postfix), y los sistemas de cache (como Memcached).

Tradicionalmente, los “backing services” (como las bases de datos) han sido gestionadas por los mismos administradores de sistemas que despliegan la aplicacion en producción. Además de esos servicios gestionados localmente, las aplicaciones también pueden usar servicios proporcionados y gestionados por terceros, como por ejemplo los servicios SMTP (Postmark), los servicios de recopilación de métricas (como New Relic o Loggly), los servicios de activos binarios (como Amazon S3), e incluso servicios que se consumen accediendo a ellos mediante un API (como Twitter, Google Maps, o Last.fm).

El código de una aplicación “twelve-factor” no hace distinciones entre servicios locales y de terceros. Para la aplicación, ambos son recursos conectados, accedidos mediante una URL u otro localizador o credencial almacenado en la config. Un despliegue de una aplicación “twelve-factor” debería ser capaz de reemplazar una base de datos local MySQL por una gestionada por un tercero (como Amazon RDS) sin ningún cambio en el código de la aplicación. Igualmente, un servidor SMTP local se podría cambiar por un servicio de terceros (como Postmark) sin modificaciones en el código. En ambos casos, solo el manejador del recurso necesita cambiar en la configuración.

Cada “backing service” distinto es un recurso. Por ejemplo, una base de datos MySQL es un recurso; dos bases de datos MySQL (usadas para “sharding” en la capa de aplicación) les convierte en dos recursos distintos. Una aplicación “twelve factor” trata esas bases de datos como recursos conectados, lo que demuestra su bajo acoplamiento al despliegue al que se unen.



Los recursos se pueden conectar y desconectar a voluntad. Por ejemplo, si la base de datos funciona mal debido a un problema en el hardware, el administrador de la aplicación puede cambiar a un nuevo servidor de bases de datos que haya sido restaurado de un backup reciente. La base de datos actual de producción se puede desconectar, y conectar una nueva base de datos sin tener que cambiar nada en el código.\n\n\n\nIV. Services externes

Traitez les services externes comme des ressources attachées

Un service externe (backing service) correspond à tout service que l’application utilise à travers le réseau pour son fonctionnement nominal. Cela concerne par exemple les bases de données (tel que MySQL ou CouchDB), les systèmes de messages/files (tel que RabbitMQ ou Beanstalkd), les services SMTP pour l’envoi d’email (comme Postfix), ainsi que les systèmes de cache (comme Memcached).

Les services externes comme la base de données sont le plus souvent gérés par les mêmes administrateurs réseau que ceux qui gèrent l’application de production. En plus de ces services gérés localement, l’application peut également avoir besoin de services gérés par des tiers. Cela concerne par exemple les services SMTP (comme Postmark), les services de gestion de métriques (comme New Relic ou Loggly), les services de ressources binaires (comme Amazon S3), et même les services que l’on peut consommer à travers une API (comme Twitter, Google Maps, ou Last.fm).

Le code d’une application 12 facteurs ne fait pas de distinction entre les services locaux et les services tiers. Pour l’application, ce sont tous les deux des ressources attachées, accessibles via une URL ou un autre système de localisation et d’authentification stockée dans la configuration. Un déploiement d’une application 12 facteurs doit pouvoir remplacer une base de données MySQL locale par une autre gérée par des tiers (Amazon RDS, par exemple) sans le moindre changement dans le code de l’application. De la même manière, un serveur SMTP local doit pouvoir être remplacé par un service tiers (Postmark, par exemple) sans changements dans le code. Dans les deux cas, seules les informations de configurations doivent changer.

Chaque service externe est une ressource. Par exemple, une base de données MySQL est une ressource. Deux bases de données MySQL (utilisées pour faire du sharding dans la couche applicative) correspondent à deux ressources distinctes. L’application 12 facteurs traite ces bases de données comme des ressources attachées, ce qui indique leur couplage faible au déploiement auquel elles sont rattachées.



Les ressources peuvent être attachées et détachées à volonté à des déploiements. Par exemple, si la base de données de l’application pose problème pour des raisons matérielles, l’administrateur de l’application peut vouloir lancer un nouveau serveur de base de données restauré à partir d’une sauvegarde récente. L’application courante pourrait être détachée de l’ancienne, puis rattachée à la nouvelle — le tout sans changement dans le code.\n\n\n\nIV. Backing Service

Tratta i backing service come “risorse”

Un “backing service” è un qualsiasi servizio che l’applicazione consuma attraverso la rete durante la sua esecuzione. Alcuni esempi includono i database (come MySQL o CouchDB), servizi di messaging/code (come RabbitMQ oppure Beanstalkd), servizi SMTP per la posta (come Postfix) e sistemi di cache (come Memcached).

Un backing service (prendiamo ad esempio un database) è tradizionalmente gestito dallo stesso amministratore di sistema, al deployment dell’applicazione. In aggiunta a questi servizi gestiti in locale potrebbero esserne presenti altri, forniti da terze parti. Parliamo di servizi SMTP (come Postmark), servizi di raccolta metriche (come New Relic o Loggly), servizi per asset (come Amazon S3), e anche servizi accessibili via API (come Twitter, Google Maps, o Last.fm).

Il codice di un’app twelve-factor non fa distinzioni tra servizi in locale o third party. Per l’applicazione, entrambi sono risorse connesse, accessibili via URL (o tramite un altro locator) e credenziali memorizzate nell’opportuno file di configurazione. A un qualsiasi deployment di un’applicazione twelve-factor si deve poter permettere di passare velocemente da un database MySQL locale a uno third party (come Amazon RDS) senza alcuna modifica al codice. Allo stesso modo, un server SMTP locale dovrebbe poter essere cambiato con uno third party (come Postmark). In entrambi i casi, a cambiare dovrebbero essere solo i file di configurazione necessari.

Ogni backing service è quindi definibile come una “risorsa connessa”. Un Database MySQL è una risorsa. Due database MySQL (utilizzati per lo sharding a livello di applicazione) saranno visti come due distinte risorse. Un’app twelve-factor vede questi database come risorse anche per sottolineare la separazione dal deployment a cui fanno riferimento.



Le risorse possono essere collegate e scollegate da un deployment a piacimento. Per esempio, supponiamo che il database dell’applicazione si comporti in modo anomalo per problemi hardware. L’amministratore potrebbe decidere di voler configurare un altro server di database ripreso da un recente backup. Il vecchio database verrebbe scollegato, quello nuovo connesso – senza modifiche al codice.\n\n\n\nIV. バックエンドサービス

バックエンドサービスをアタッチされたリソースとして扱う

バックエンドサービス はアプリケーションが通常の動作の中でネットワーク越しに利用するすべてのサービスを言う。例としては、データストア（例：MySQL や CouchDB）、メッセージキューイングシステム（例：RabbitMQ や Beanstalkd）、電子メールを送信するためのSMTPサービス（例：Postfix）、キャッシュシステム（例：Memcached）などがある。

従来、データストアなどのバックエンドサービスは、デプロイされたアプリケーションと同じシステム管理者によって管理されていた。このようなローカルで管理されるサービスに加えて、サードパーティによって提供、管理されるサービスを利用することもある。例としては、SMTP サービス（例：Postmark）、メトリクス収集システム（例：New Relic や Loggly）、ストレージサービス（例：Amazon S3）、APIアクセス可能な消費者向けサービス（例：TwitterやGoogle Maps、Last.fm）などがある。

Twelve-Factor Appのコードは、ローカルサービスとサードパーティサービスを区別しない。 アプリケーションにとっては、どちらもアタッチされたリソースであり、設定に格納されたURLやその他のロケーター、認証情報でアクセスする。Twelve-Factor Appのデプロイは、アプリケーションのコードに変更を加えることなく、ローカルで管理されるMySQLデータベースをサードパーティに管理されるサービス（Amazon RDSなど）に切り替えることができるべきである。同様に、ローカルのSMTPサーバーも、コードを変更することなくサードパーティのSMTPサービス（Postmarkなど）に切り替えることができるべきである。どちらの場合も、変更が必要なのは設定の中のリソースハンドルのみである。

それぞれのバックエンドサービスは リソース である。例えば、1つのMySQLデータベースはリソースである。2つのMySQLデータベース（アプリケーション層でのシャーディングに使う）は2つの異なるリソースと見なせる。Twelve-Factor Appはこれらのデータベースを アタッチされたリソース として扱う。これは、アタッチされたリソースとアタッチする対象のデプロイが疎結合であることを意味する。



リソースは自由にデプロイにアタッチしたり、デプロイからデタッチしたりできる。例えば、ハードウェアの問題によってアプリケーションのデータベースの動作がおかしい場合、アプリケーションの管理者は最新のバックアップから新しいデータベースサーバーを立ち上げる。そして現在の本番データベースをデタッチし、新しいデータベースをアタッチする – コードを一切変更せずに。\n\n\n\nIV. 백엔드 서비스

백엔드 서비스를 연결된 리소스로 취급

백엔드 서비스는 애플리케이션 정상 동작 중 네트워크를 통해 이용하는 모든 서비스입니다. 예를 들어, 데이터 저장소(예: MySQL, CouchDB), 메시지 큐잉 시스템(예: RabbitMQ, Beanstalkd), 메일을 보내기 위한 SMTP 서비스 (예: Postfix), 캐시 시스템(예: Memcached) 등이 있습니다.

데이터베이스와 같은 백엔드 서비스들은 통상적으로 배포된 애플리케이션과 같은 시스템 관리자에 의해서 관리되고 있었습니다. 애플리케이션은 이런 로컬에서 관리하는 서비스 대신, 서드파티에 의해서 제공되고 관리되는 서비스를 이용할 수 있습니다. 예를 들어, SMTP 서비스 (예: Postmark), 지표 수집 서비스 (예: New Relic, Loggly), 스토리지 서비스 (예: Amazon S3), API로 접근 가능한 소비자 서비스 (예: Twitter, Google Maps, Last.fm)등이 있습니다.

Twelve-Factor App의 코드는 로컬 서비스와 서드파티 서비스를 구별하지 않습니다. 애플리케이션에게는 양 쪽 모두 연결된 리소스이며, 설정에 있는 URL 혹은 다른 로케이터와 인증 정보를 사용해서 접근 됩니다. Twelve-Factor App의 배포는 애플리케이션 코드를 수정하지 않고 로컬에서 관리되는 MySQL DB를 서드파티에서 관리되는 DB(예: Amazon RDS)로 전환할 수 있어야 합니다. 마찬가지로, 로컬 SMTP 서버는 서드파티 SMTP 서비스(예: Postmark)로 코드 수정 없이 전환이 가능해야 합니다. 두 경우 모두 설정에 있는 리소스 핸들만 변경하면 됩니다.

각각의 다른 백엔드 서비스는 리소스입니다. 예를 들어, 하나의 MySQL DB는 하나의 리소스입니다. 애플리케이션 레이어에서 샤딩을 하는 두 개의 MySQL 데이터베이스는 두 개의 서로 다른 리소스라고 볼 수 있습니다. Twelve-Factor App은 이러한 데이터베이스들을 첨부된(Attached) 리소스으로 다룹니다. 이는 서로 느슨하게 결합된다는 점을 암시합니다.



리소스는 자유롭게 배포에 연결되거나 분리될 수 있습니다. 예를 들어, 애플리케이션의 데이터베이스가 하드웨어 이슈로 작용이 이상한 경우, 애플리케이션의 관리자는 최신 백업에서 새로운 데이터베이스 서버를 시작시킬 것입니다. 그리고 코드를 전혀 수정하지 않고 현재 운영에 사용하고 있는 데이터베이스를 분리하고 새로운 데이터베이스를 연결할 수 있습니다.\n\n\n\nIV. Usługi wspierające

Traktuj usługi wspierające jako przydzielone zasoby

Usługą wspierającą jest każda, z której aplikacja korzysta przez sieć jako część normalnego działania. Zaliczamy do nich np. magazyny danych (takie jak MySQL albo CouchDB), systemy wysyłania/kolejkowania wiadomości (takie jak RabbitMQ czy Beanstalkd), usługi SMTP do zewnętrznej wysyłki emaili (np. Postfix) oraz systemy cachowania pamięci (np. Memcached).

Usługa wspierająca taka jak baza danych jest zazwyczaj zarządzana przez tych samych programistów, którzy zajmują się wdrażaniem aplikacji. Dodatkowo aplikacja może również korzystać z usług oferowanych przez osoby trzecie. Do przykładów zaliczają się usługi SMTP (Postmark),usługi zbierające metryki (New Relic czy Loggly), usługi przechowywania danych (takie jak Amazon S3), czy również usługi dostępne przez publiczne API (jak np. Twitter, Google Maps, lub Last.fm).

Aplikacje 12factor nie rozróżniają usług lokalnych od zewnętrznych. Dla aplikacji wszystkie są załączonymi zasobami, dostepnymi przez adres URL lub inny standard zdefiniowany w konfiguracji. Przy wdrożeniu aplikacji nie może być problemów ze zmianą lokalnej bazy MySQL na oferowaną przez zewnętrznego usługodawcę (np. Amazon RDS) bez żadnych zmian w kodzie aplikacji. Podobnie lokalny serwer SMTP może być zamieniony na zewnętrzną usługę SMTP (taką jak Postmark) bez zmian kodu. W obu przypadkach zmiana powinna wystąpić jedynie w konfiguracji aplikacji.

Każda usługa jest traktowana jako zasób. Zasobem będzie np. baza MySQL; dwie bazy danych (używane do shardingu) w warstwie aplikacji) kwalifikują się jako dwa odrębne zasoby. Aplikacja 12factor traktuje te bazy danych jako załączone zasoby, co wskazuje, że nie są z nią trwale powiązane.



Zasoby mogą być dołączane i odłączane jeśli zajdzie taka potrzeba. W momencie gdy baza danych aplikacji z powodu usterek sprzętowych nie działa poprawnie, administrator może przełączyć bazę danych aplikacji na nowy serwer odtworzoną z ostatniego zapisu przywracania danych. Obecna produkcyjna baza może więc zostać przełączona bez żadnych zmian w kodzie aplikacji.\n\n\n\nIV. Serviços de Apoio

Trate serviços de apoio como recursos anexados

Um serviço de apoio é qualquer serviço que o app consuma via rede como parte de sua operação normal. Exemplos incluem armazenamentos de dados (como MySQL ou CouchDB), sistemas de mensagens/filas (tais como RabbitMQ ou Beanstalkd), serviços SMTP para emails externos (tais como Postfix), e sistemas de cache (tais como Memcached).

Serviços de apoio como o banco de dados são tradicionalmente gerenciados pelos mesmos administradores de sistema do servidor de deploy de tempo de execução do app. Adicionalmente à esses serviços localmente gerenciados, o app pode ter serviços providos e gerenciados por terceiros. Exemplos incluem serviços SMTP (tais como Postmark), serviços de colheita de métricas (tais como New Relic ou Loggly), serviços de ativos binários (tais como Amazon S3), e até serviços de consumidores acessíveis via API (tais como Twitter, Google Maps, ou Last.fm).

O código para um app doze-fatores não faz distinção entre serviços locais e de terceiros. Para o app, ambos são recursos anexados, acessíveis via uma URL ou outro localizador/credenciais na config. Um deploy do app doze-fatores deve ser capaz de trocar um banco de dados MySQL por um gerenciado por terceiros (tais como Amazon RDS) sem realizar quaisquer mudanças no código do app. Da mesma forma, um servidor local SMTP poderia ser trocado por um serviço de terceiros (tais como Postmark) sem as mudanças em código. Em ambos os casos, apenas o identificador de recurso precisa mudar.

Cada serviço de apoio distinto é um recurso. Por exemplo, um banco MySQL é um recurso; dois bancos MySQL (usados para sharding na camada da aplicação) qualificam como dois recursos distintos. O app doze-fatores trata tais bancos como recursos anexados, o que indica seu baixo acoplamento ao deploy que ele está anexado.



Recursos podem ser anexados e desanexados a deploys à vontade. Por exemplo, se o banco de dados do app não está funcionando corretamente devido a um problema de hardware, o administrador do app pode subir um novo servidor de banco de dados restaurado de um backup recente. O atual banco de produção pode ser desanexado, e o novo banco anexado – tudo sem nenhuma mudança no código.\n\n\n\nIV. Сторонние службы (Backing Services)

Считайте сторонние службы (backing services) подключаемыми ресурсами

Сторонняя служба– это любая служба, которая доступна приложению по сети и необходима как часть его нормальной работы. Например, хранилища данных (например, MySQL и CouchDB), системы очередей сообщений (например, RabbitMQ и Beanstalkd), службы SMTP для исходящей электронной почты (например, Postfix) и кэширующие системы (например, Memcached).

Традиционно, сторонние службы, такие как базы данных, поддерживаются тем же самым системным администратором, который разворачивает приложение. Помимо локальных сервисов приложение может использовать сервисы, предоставленные и управляемые третьей стороной. Примеры включают в себя SMTP сервисы (например Postmark), сервисы сбора метрик (такие как New Relic и Loggly), хранилища бинарных данных (например, Amazon S3), а также использование API различных сервисов (таких как Twitter, Google Maps и Last.fm).

Код приложения двенадцати факторов не делает различий между локальными и сторонними сервисами. Для приложения каждый из них является подключаемым ресурсом, доступным по URL-адресу или по другой паре расположение/учётные данные, хранящимися в конфигурации. Каждое развёртывание приложения двенадцати факторов должно иметь возможность заменить локальную базу данных MySQL на любую управляемую третьей стороной (например Amazon RDS) без каких либо изменений кода приложения. Аналогичным образом, локальный SMTP сервер может быть заменён сторонним (например Postmark) без изменения кода. В обоих случаях необходимо изменить только идентификатор ресурса в конфигурации.

Каждая различная сторонняя служба является ресурсом. Например, база данных MySQL является ресурсом, две базы данных MySQL (используются для фрагментации на уровне приложения) квалифицируются как два отдельных ресурса. Приложение двенадцати факторов считает эти базы данных подключёнными ресурсами, что указывает на их слабое связывание с развёртыванием, в котором они подключены.



Ресурсы можно по необходимости подключать к развёртыванию и отключать от развёртывания. Например, если база данных приложения функционирует некорректно из-за аппаратных проблем, администратор может запустить новый сервер базы данных, восстановленный из последней резервной копии. Текущая рабочая база данных может быть отключена, а новая база данных подключена – всё это без каких-либо изменений кода.\n\n\n\nIV. Podporné služby

Spravovanie podporných služieb ako pripojených zdrojov

Podporná služba je akákoľvek služba, ktorú aplikácia konzumuje cez sieť ako súčasť je normálneho behu. Príklady zahŕňajú databázy (ako napr. MySQL alebo CouchDB), messaging/queueing systémy (napr. RabbitMQ alebo Beanstalkd), SMTP služby pre odchádzajúce emaily (napr. Postfix), a cachovacie systémy (napr. Memcached).

Podporné služby ako databázy sú tradične spravované tými istými systémovými administrátormi ako nasadenia aplikácie. Popri lokálne spravovaných službách, može mať aplikácia služby spravované tretími stranami. Príklady zahŕňajú SMTP služby (napr. Postmark), služby na zbieranie metrík (napr. New Relic alebo Loggly), úložiskové služby (napr. Amazon S3), alebo dokonca služby prístupné cez API (napr. Twitter, Google Maps, alebo Last.fm).

Kód v dvanásť faktorovej aplikácii nerozlišuje medzi službou lokálnou a od tretej strany. Pre aplikáciu sú obidve pripojené zdroje, prístupné cez URL alebo iné prístupové/prihlasovacie údaje uložené v konfigurácii. Nasadenie dvanásť faktorovej aplikácie by malo byť schopné vymeniť lokálnu MySQL databázu s databázou spravovanou treťou stranou (napr. Amazon RDS) bez akýchkoľvek zmien v kóde aplikácie. Podobne, lokálny SMTP server môže by vymenený SMTP službou od tretej strany (napr. Postmark) bez zmeny v kóde. V obidvoch prípado sa zmenia len prístupové a prihlasovacie údaje v konfigurácii.

Každá podporná služba je osobitným zdrojom. Napríklad, MySQL databáza je zdroj; dve MySQL databázy (používané na sharding na úrovni aplikácie) sú dva rôzne zdroje. Dvanásť faktorová aplikácie považuje tieto databázy ako pripojené zdroje, čo znamená ich voľné spojenie so súvisiacim nasadením.



Zdroje je možné pripájať a odpájať od nasedení podľa ľubovôle. Napríklad, ak je databáza z dôvodu hardvérových problémov nestabilná, správca aplikácie môže rozbehnúť nový databázový server zo zálohy. Aktuálna produkčná databáza môže byť odpojená a nový databáza pripojená – všetko bez zmien v kóde.\n\n\n\nIV. Backing services

จัดการกับบริการสนับสนุน (backing service) ให้เป็นทรัพยากรที่แนบมา

บริการสนับสนุน (backing service)* เป็นบริการใดๆ ที่ app ใช้บริการผ่านระบบเครือข่ายซึ่งเป็นส่วนหนึ่งของการดำเนินงาน (operation) ตัวอย่างเช่น รวมที่เก็บข้อมูล (datastore) (เช่น MySQL หรือ CouchDB), ระบบ messaging/queueing (เช่น RabbitMQ หรือ Beanstalkd), บริการ SMTP สำหรับส่งอีเมล์ออก (เช่น Postfix), และระบบ caching (เช่น Memcached)

บริการสนับสนุนอย่างเช่นฐานข้อมูลเป็นการจัดการแบบดั่งเดิมด้วยผู้จัการระบบเดียวกันกับ app ที่ทำงานหลังจาก deploy เพิ่มเติมจากบริการจัดการภายใน, app อาจจะมีบริการที่ให้บริการและจัดการโดยบริการภายนอก (third parties) ตัวอย่างเช่น รวมบริการ SMTP (เช่น Postmark), บริการ metrics-gathering (เช่น New Relic หรือ Loggly), บริการ binary asset (เช่น Amazon S3), และแม้แต่บริการ API-accessible consumer (เช่น Twitter, Google Maps, หรือ Last.fm).

code สำหรับ twelve-factor app จะไม่มีความแตกต่างระหว่างบริการภายใน (local) และบริการภายนอก (third party) ใน app ทั้งสองบริการจะเป็นทรัพยากรที่แนบอยู่ใน app และเข้าถึงได้ด้วย URL หรือที่เก็บ locator/credentials อื่นๆใน การตั้งค่า. deploy ของ twelve-factor app ควรจะส่ามารถสลับสับเปลี่ยนฐานข้อมูล MySQL ใน app ด้วยบริการภายนอก (เช่น Amazon RDS) โดยไม่ต้องเปลี่ยน code ของ app เหมือนกับ SMTP ภายใน app ควรสามารถสลับสับเปลี่ยนด้วยบริการ SMTP ภายนอกได้ (เช่น Postmark) โดยไม่ต้องเปลี่ยน code ในทั้งสองกรณีทรัพยากรจัดการด้วยการตั้งค่าที่จะต้องเปลี่ยนเท่านั้น

สิ่งที่แตกต่างกันของบริการสนับสนุนคือ ทรัพยากร ตัวอย่างเช่น ฐานข้อมูล MySQL เป็นทรัพยากร; ฐานข้อมูล MySQL 2 ฐานข้อมูล (ใช้สำหรับ sharding ใน application layer) มีคุณสมบัติเป็นทรัพยากรที่แตกต่างกัน 2 แหล่ง, twelve-factor app จักการฐานข้อมูลเป็น ทรัพยากรแนบ (attached resouces) ซึ่งเป็นการระบุ loose coupling กับ deploy ที่ทรัพยากรเหล่านี้แนบใช้งาน



ทรัพยากรสามารถแนบและถอดออกจาก deploy ได้ ตัวอย่างเช่น ถ้าฐานข้อมูลของ app ทำงานผิดปรกติเนื่องจากปัญหาของฮาร์ดแวร์ ผู้ดูแลระบบของ app อาจจะ spin up เซิร์ฟเวอร์ฐานข้อมูลขึ้นมาใหม่จากการข้อมูลที่สำรองล่าสุด ฐานข้อมูลของ production ปัจจุบันควรจะถอดออกและแนบด้วยฐานข้อมูลใหม่ – ทั้งหมดนี้ไม่มีการเปลี่ยนแปลง code\n\n\n\nIV. Yardımcı servisler

Yardımcı servisleri iliştirilmiş kaynaklar olarak ele almak

Bir yardımcı servis uygulamanın kendi işlevselliğinin bir parçası olarak ağ üzerinden tükettiği herhangi bir servistir. Yardımcı servislere örnek olarak; veritabanları (MySQL veya CouchDB gibi), mesajlaşma/kuyruk sistemleri (RabbitMQ veya Beanstalkd), e-posta göndermek için SMTP servisleri (Postfix gibi) ve önbellekleme sistemleri (Memcached gibi) gösterilebilir.

Veritabanları gibi yardımcı servisler, geleneksel olarak uygulamayı da yöneten sistem yöneticileri tarafından yönetilirler. Ancak bu yerel servislere ilave olarak, uygulama üçüncü parti uygulamalar tarafından sağlanan ve yönetilen servislere de sahip olabilirler. Bunlardan bazıları; SMTP servisleri (Postmark gibi), metrik toplama servisleri (New Relic veya Loggly gibi), statik içerik barındırma servisleri (Amazon S3 gibi) ve hatta API-erişilebilir tüketici servisleridir (Twitter, Google Maps, ve Last.fm gibi).

On iki faktör uygulamaları için bir servisin yerel veya üçüncü parti olmasının farkı yoktur. Uygulama için, her ikisi de ek kaynaktır ve yapılandırmada saklanmış URL’ler veya yer belirleyici ve kimlik bilgileri ikilisi aracılığıyla erişilir. On iki faktör uygulamasının bir dağıtımı, uygulama kodunda hiçbir değişiklik yapmak zorunda kalmadan yerel bir MySQL veritabanı kullanmaktan üçüncü parti bir veritabanı (Amazon RDS gibi) kullanmaya geçebilmelidir. Aynı şekilde yerel bir SMTP servisinden (Postmark gibi), kod değişikliği olmaksızın bir üçüncü parti SMTP servisine geçiş yapılabilir. Her iki durumda da, değişmesi gereken şey sadece yapılandırma ayarlarındaki bağlantı bilgileridir.

Her bir destek servisi bir kaynaktır. Örneğin, bir MySQL veritabanı bir kaynaktır; iki MySQL veritabanı (uygulama katmanında parçalanma [İng. sharding] için kullanılan) iki farklı kaynak olarak nitelendirilir. On iki faktör uygulaması bu veritabanlarına, bağlı oldukları dağıtımlara gevşek bağlaşımlarını belirten ek kaynak olarak davranır.



Kaynaklar dağıtımlara istenilen zamanda eklenilip çıkartılabilir. Örneğin, eğer uygulamanın veritabanı donanımsal sorunlar yaşıyorsa, uygulamanın yöneticisi son yedeklemeden geri yüklenmiş yeni bir veritabanı sunucusu oluşturabilir. Problemli veritabanının uygulamadan bağlantısı kesilip, yeni veritabanı bağlanabilir, hem de hiçbir kod değişikliği olmadan.\n\n\n\nIV. Сторонні служби

Вважайте сторонні служби (backing services) підключеними ресурсами

Стороння служба — це будь-яка служба, яка доступна застосунку по мережі і необхідна для його нормальної роботи: бази даних (наприклад, MySQL або CouchDB), системи черг повідомлень (наприклад, RabbitMQ або Beanstalkd), служби SMTP для вихідної пошти (наприклад, Postfix), системи кешування (наприклад, Memcached) тощо.

Допоміжні служби, такі як бази даних, традиційно управляються тими ж системними адміністраторами, які розгортають застосунок. Окрім локальних служб, застосунок може також використовувати служби, що надаються і керуються третіми сторонами: SMTP-сервіси (наприклад, Postmark), сервіси збору метрик (наприклад, New Relic або Loggly), сховища бінарних даних (наприклад, Amazon S3), а також різні сервіси, що надають доступ через API (наприклад, Twitter, Google Maps, або Last.fm).

Код застосунку дванадцяти факторів не бачить жодних відмінностей між локальними і сторонніми сервісами. Для застосунку кожен з них є підключеним ресурсом, доступним за URL-адресою або іншими даними, що зберігаються в конфігурації. Розгортання застосунку дванадцяти факторів повинно мати можливість, наприклад, замінити локальну базу даних MySQL на будь-яку керовану третьою стороною (наприклад, Amazon RDS) без жодних змін в коді застосунку. Крім того, локальний сервер SMTP може бути замінений на сторонній SMTP-сервіс (наприклад, Postmark) без зміни коду. В обох випадках необхідно змінити лише налаштування відповідного ресурсу в конфігурації застосунку.

Кожна окрема стороння служба є ресурсом. Наприклад, база даних MySQL є ресурсом; дві бази даних MySQL (що використовуються для шардінгу на рівні застосунку) кваліфікуються як два різних ресурси. Застосунок дванадцяти факторів сприймає ці бази даних як підключені ресурси, що вказує на їхній слабкий зв’язок з розгортанням, в якому вони підключені.



Ресурси за необхідності можуть бути підключені та відключені до розгортання застосунку. Наприклад, якщо база даних застосунку функціонує некорекно у зв’язку з апаратними проблемами, адміністратор може запустити новий сервер бази даних, відновленої з останньої резервної копії. Поточна база даних може бути відключена, а нова база даних підключена — все це без будь-яких змін коду.\n\n\n\nIV. Dịch vụ hỗ trợ

Dịch vụ hỗ trợ như là tài nguyên bổ xung

Dịch vụ hỗ trợ là các dịch vụ mà ứng dụng sử dụng thông qua mạng như là một thành phần trong vận hành. Ví dụ bao gồm nơi lưu trữ dữ liệu (như là MySQL hoặc CouchDB), hệ thống tin nhắn/hàng đợi (như là RabbitMQ hoặc Beanstalkd), dịch vụ SMTP để gửi thư điện tử ra ngoài (như là Postfix), và hệ thống đệm (như là Memcached).

Dịch vụ hỗ trợ như cơ sở dữ liệu thường được quản lý bởi chính hệ thống quản trị của dịch vụ đó trong quá trình triển khai ứng dụng. Thêm vào đó, việc quản trị dịch vụ cục bộ, các ứng dụng có thể sử dụng các dịch vụ được cung cấp và quản lý bởi bên thứ ba. Ví dụ như các dịch vụ SMTP (như Postmark), các dịch vụ thu thập thông tin đo lường (metrics-gathering services) (như New Relic hay Loggly), dịch vụ tài sản nhị phân (binary assets services) (như Amazon S3), và các dịch vụ sử dụng API (như Twitter, Google Maps, hoặc Last.fm).

Mã nguồn của ứng dụng áp dụng mười hai-hệ số cho phép không có sự khác biệt giữa dịch vụ cục bộ và bên thứ ba. Đối với ứng dụng, cả tài nguyên bổ xung và có thể truy cập thông qua URL hoặc thông tin tài khoản được lưu trữ trong cấu hình. Một triển khai của ứng dụng áp dụng mười hai-hệ số có thể chuyển đổi giữa cơ sở dữ liệu MySQL cục bộ với một cơ sở dữ liệu được quản lý bởi bên thứ ba (như Amazon RDS) mà không phải thay đổi bất kỳ một đoạn mã nguồn nào của ứng dụng. Giống như, máy chủ SMTP cục bộ có thể được thay thế bởi dịch SMTP của bên thứ ba (như Postmark) mà không thay đổi mã nguồn. Trong cả hai trường hợp, chúng ta chỉ cần thay đổi các tài nguyên được quản lý trong cấu hình.

Mỗi dịch vụ hỗ trợ riêng biệt là một tài nguyên. Ví dụ, cơ sở dữ liệu MySQL là một tài nguyên, hai cơ sở dữ liệu MySQL (sử dụng cho việc phân tách ở tầng ứng dụng) được xác định là hai tài nguyên riêng biệt. Ứng dụng áp dụng mười hai-hệ số đối xử các cơ sở dữ liệu như là tài nguyên bổ sung, nhằm đảm bảo kết nối lỏng lẻo với triên khai mà chúng được bổ xung.



Tài nguyển có thể được thêm vào triển khai khi cần thiết. Ví dụ, nếu cơ sở dữ liệu của ứng dụng bị mất do lỗi phần cứng, quản trị viên của ứng dụng có thể thêm vào một máy chủ cơ sở dữ liệu được khôi phục từ các sao lưu trước đó. Các thay đổi bao gồm cơ sở dữ liệu chính đang sử dụng có thể được loại bỏ, và bổ xung cơ sở dữ liệu mới có thể xảy ra mà không cần thay đổi bất kỳ một đoạn mã nguồn nào.\n\n\n\nIV. 后端服务

把后端服务(backing services)当作附加资源

后端服务是指程序运行所需要的通过网络调用的各种服务，如数据库（MySQL，CouchDB），消息/队列系统（RabbitMQ，Beanstalkd），SMTP 邮件发送服务（Postfix），以及缓存系统（Memcached）。

类似数据库的后端服务，通常由部署应用程序的系统管理员一起管理。除了本地服务之外，应用程序有可能使用了第三方发布和管理的服务。示例包括 SMTP（例如 Postmark），数据收集服务（例如 New Relic 或 Loggly），数据存储服务（如 Amazon S3），以及使用 API 访问的服务（例如 Twitter, Google Maps, Last.fm）。

12-Factor 应用不会区别对待本地或第三方服务。 对应用程序而言，两种都是附加资源，通过一个 url 或是其他存储在 配置 中的服务定位/服务证书来获取数据。12-Factor 应用的任意 部署 ，都应该可以在不进行任何代码改动的情况下，将本地 MySQL 数据库换成第三方服务（例如 Amazon RDS）。类似的，本地 SMTP 服务应该也可以和第三方 SMTP 服务（例如 Postmark ）互换。上述 2 个例子中，仅需修改配置中的资源地址。

每个不同的后端服务是一份 资源 。例如，一个 MySQL 数据库是一个资源，两个 MySQL 数据库（用来数据分区）就被当作是 2 个不同的资源。12-Factor 应用将这些数据库都视作 附加资源 ，这些资源和它们附属的部署保持松耦合。



部署可以按需加载或卸载资源。例如，如果应用的数据库服务由于硬件问题出现异常，管理员可以从最近的备份中恢复一个数据库，卸载当前的数据库，然后加载新的数据库 – 整个过程都不需要修改代码。\n\n\n\nIV. Backing services

Treat backing services as attached resources

A backing service is any service the app consumes over the network as part of its normal operation. Examples include datastores (such as MySQL or CouchDB), messaging/queueing systems (such as RabbitMQ or Beanstalkd), SMTP services for outbound email (such as Postfix), and caching systems (such as Memcached).

Backing services like the database are traditionally managed by the same systems administrators who deploy the app’s runtime. In addition to these locally-managed services, the app may also have services provided and managed by third parties. Examples include SMTP services (such as Postmark), metrics-gathering services (such as New Relic or Loggly), binary asset services (such as Amazon S3), and even API-accessible consumer services (such as Twitter, Google Maps, or Last.fm).

The code for a twelve-factor app makes no distinction between local and third party services. To the app, both are attached resources, accessed via a URL or other locator/credentials stored in the config. A deploy of the twelve-factor app should be able to swap out a local MySQL database with one managed by a third party (such as Amazon RDS) without any changes to the app’s code. Likewise, a local SMTP server could be swapped with a third-party SMTP service (such as Postmark) without code changes. In both cases, only the resource handle in the config needs to change.

Each distinct backing service is a resource. For example, a MySQL database is a resource; two MySQL databases (used for sharding at the application layer) qualify as two distinct resources. The twelve-factor app treats these databases as attached resources, which indicates their loose coupling to the deploy they are attached to.



Resources can be attached to and detached from deploys at will. For example, if the app’s database is misbehaving due to a hardware issue, the app’s administrator might spin up a new database server restored from a recent backup. The current production database could be detached, and the new database attached – all without any code changes.\n\n\n\nII. Závislosti

Explicitně deklarujte a izololujte závislosti.

Většina programovacých jazyků poskytuje balíčkovací systém pro distribuci podpůrných knihoven, například CPAN pro Perl nebo Rubygems pro Ruby. Knihovny instalované skrze balíčkovací systém mohou být instalovány globálně pro celý systém (nazýváme “site packages”) nebo pouze lokálně v rámci adresáře dané aplikace (nazýváme “vendoring” nebo “bundling”).

Twelve-factor aplikace se nikdy nespoléhá na implicitní existenci globálních systémových balíčků. Svoje závislosti deklaruje úplně a přesně pomocí manifestu deklarovaných závislostí. Dále používá nástroje pro izolaci závislostí, aby bylo zajištěno, že při běhu aplikace žádné implicitní zavislosti neprosakují z okolního systému. Úplná explicitní deklarace závislostí je použita jednotně pro produkci i vývoj.

Například Bundler pro Ruby poskytuje Gemfile manifest formát pro deklaraci závislostí a bundle exec pro izolaci závislostí. Pro Python jsou to dva rozdílné nástroje, Pip je použit pro deklaraci závislostí a Virtualenv pro jejich izolaci. Dokonce i C má Autoconf pro deklaraci závislostí a statické linkování poskytuje izolaci závislostí. Nehledě na použitou sadu nástrojů, deklarace a izolace závislostí musí být vždy aplikovány společně, použití pouze jednoho nebo pouze druhého není dostatečné pro splnění podmínek twelve-factor metodiky.

Jednou z výhod explicitní deklarace závislostí je to, že zjednodušuje počáteční rozběhnutí aplikace pro nové vývojáře. Nový vývojář si jen naklonuje repozitář aplikace do svého vývojového prostředí a jako prerekvizity mu postačí nainstalované běhové prostředí jazyka a příslušný správce závislostí. Vše potřebné pro rozběhnutí aplikace se zajistí deterministicky build příkazem . Například, build příkaz pro Ruby/Bundler je bundle install, pro Cloujure/Leiningen je to lein deps.

Twelve-factor aplikace se nespoléhají na implicitní existenci jakýchkoli systémových nástrojů. Příkladem může být spouštění ImageMagick nebo curl přes shell. I když tyto nástroje existují na mnoha a možná i většině aktuálně používaných systémů, neexistuje žadná záruka, že tyto nástroje budou existovat na systémech, kde aplikace poběží v budoucnu a nebo že budou na budoucích systémech dostupné v kompatibilní verzi. Pokud aplikace potřebuje spouštět nějaký nástroj přes shell, tak by měl být daný nástroj součástí aplikace.\n\n\n\nIII. Konfigurace

Konfigurace ukládejte do prostředí.

Konfigurace aplikace je všechno, co se liší mezi nasazeními (testovací, produkční, vývojové prostředí, atd.). To zahrnuje:


Přihlašovací údaje k databázím, Memcached a dalším podpůrným službám.

Přístupové údaje k externím službám jako je Amazon S3 nebo Twitter.

Specifické hodnoty pro dané nasazení jako například kanonické názvy hostitelů.


Aplikace si někdy ukládají konfiguraci jako konstanty v kódu. To je porušení twelve-factor metodiky, která vyžaduje přísné oddělení konfigurace od kódu. Konfigurace se mezi nasazeními značně liší, kód však nikoliv.

Test lakmusovým papírkem na správné oddělení konfigurace od kódu je fakt, že aplikace by mohla být kdykoliv uvolněna jako open source bez kompromitace přístupových údajů.

Nutno podotknout, že do definice “konfigurace” nepatří interní nastavení aplikace jako je například config/routes.rb v Rails nebo nastavení propojení základních modulů ve Springu. Tento typ konfigurace se neliší mezi nasazeními a je nejlepší ho ponechat v kódu.

Další možností jak přistupovat ke konfiguracím je mít konfigurační soubory, které nejsou uložené ve verzovacím systému, jak je tomu například u config/database.yml v Rails. To je obrovské zlepšení oproti konstantám uloženým v repozitáři, tento přístup má však stále několik slabin: je velmi jednoduché omylem uložit tento soubor do repozitáře; chtě nechtě jsou tyto soubory obvykle rozmístěny na několika místech a v různých formátech, což komplikuje jejich centrální správu. Navíc jsou tyto konfigurační soubory často specifické pro daný jazyk či framework.

Twelve-factor aplikace ukládají konfiguraci do proměnných prostředí (často zkracováno jak env vars nebo env). Proměnné prostředí se dají jednoduše měnit mezi nasazeními bez zásahu do kódu. Oproti konfiguračním souborům je zde velmi malá šance, že by byly omylem uloženy do repozitáře a narozdíl od vlastních konfiguračních souborů a jiných konfiguračních mechanismů, jako například Java System Properties, jsou nezávislé na jazyce a operačním systému.

Dalším úskalím správy konfigurace je seskupování. Aplikace někdy seskupují konfigurace do pojmenovaných skupin (často nazývaných jako “prostředí”), rozlišených podle specifického nasazení, jako například vývojové, testovací nebo produkční prostředí. Tento přístup lze jen velmi težko čistě škálovat. Jak přibývají nasazení jsou zapotřebí nová prostředí, jako například staging nebo qa. Jakmile projekt začne narůstat, vývojáři přidávají svoje specifická prostředí jako třeba joes-staging, což má za následek kombinatorickou explozi konfigurací a správa nasazení se tak stáva velmi delikátní záležitostí.

Ve twelve-factor aplikaci jsou proměnné prostředí jako vzájemně nezávislé ovládací prvky. Ty nejsou nikdy seskupovány do “prostředí”, namísto toho jsou všechny spravovány nezávisle pro každé nasazení. Tento model plynule škáluje s přirozeně se rozrůstající aplikací a narůstajícím počtem nasazení během celého životního cyklu aplikace.\n\n\n\nII. Abhängigkeiten

Abhängigkeiten explizit deklarieren und isolieren

Die meisten Programmiersprachen bieten ein System an, um unterstützende Bibliotheken zu verbreiten, wie CPAN für Perl oder Rubygems für Ruby. Aus einem Paketsystem stammende Bibliotheken können systemweit installiert werden (auch “Site Packages” genannt) oder in ein Verzeichnis der App beschränkt werden (genannt “vendoring” oder “bundling” - deutsch auch “mitliefern”).

Eine Zwölf-Faktor-App verlässt sich nie auf die Existenz von systemweiten Paketen. Sie deklariert alle Abhängigkeiten vollständig und korrekt über eine Abhängigkeitsdeklaration. Weiter benutzt sie zur Laufzeit ein Werkzeug zur Isolation von Abhängigkeiten um sicherzustellen, dass keine impliziten Abhängigkeiten aus dem umgebenden System “hereinsickern”. Die vollständige und explizite Spezifikation der Abhängigkeiten wird gleichermaßen in Produktion und Entwicklung angewandt.

So bietet zum Beispiel Bundler für Ruby das Format Gemfile zur Abhängigkeitsdeklaration und bundle exec zur Isolation von Abhängigkeiten. In Python gibt es für diese Schritte zwei unterschiedliche Werkzeuge – Pip für die Deklaration und Virtualenv für die Isolation. Selbst C hat Autoconf zur Deklaration der Abhängigkeiten, und statisches Linken kann für Isolation sorgen. Unabhängig von den Werkzeugen müssen Abhängigkeitsdeklaration und Isolation immer zusammen benutzt werden – eines alleine genügt für die zwölf Faktoren nicht.

Ein Nutzen der expliziten Abhängigkeitsdeklaration ist das einfachere Aufsetzen der App für neue Entwickler. Neue Entwickler können die Codebase der App auf ihre Entwicklungsmaschine auschecken und brauchen dazu nur eine Sprach-Runtime und eine Abhängigkeitsverwaltung. Um die App zum Laufen zu bringen wird lediglich ein deterministisches Build-Kommando benötigt. So ist zum Beispiel das Build-Kommando für Ruby/Bundler bundle install und für Clojure/Leiningen ist es lein deps.

Zwölf-Faktor-Apps verlassen sich auch nicht auf die implizite Existenz irgendwelcher Systemwerkzeuge. Beispiele dafür sind Shell-Aufrufe von ImageMagick oder curl. Auch wenn diese Werkzeuge auf vielen und sogar den meisten Systemen vorhanden sind, gibt es keine Garantie, dass sie auf allen Systemen vorhanden sind, auf denen die App in Zukunft laufen wird, oder dass die Werkzeug-Version die in Zukunft auf einem System vorhanden sein wird, kompatibel ist. Wenn die App per Shell auf ein Systemwerkzeug zugreift, sollte die App das Werkzeug mitliefern.\n\n\n\nIII. Konfiguration

Die Konfiguration in Umgebungsvariablen ablegen

Die Konfiguration einer App ist alles, was sich wahrscheinlich zwischen den Deploys ändern wird (Staging, Produktion, Entwicklungsumgebungen, usw.). Dies umfasst:


Resource-Handles für Datenbanken, Memcached und andere unterstützende Dienste

Credentials für externe Dienste wie Amazon S3 oder Twitter

Direkt vom Deploy abhängige Werte wie der kanonische Hostname für den Deploy


Manchmal speichern Apps die Konfiguration als Konstanten im Code. Dies ist eine Verletzung der zwölf Faktoren. Sie fordern strikte Trennung der Konfiguration vom Code. Die Konfiguration ändert sich deutlich von Deploy zu Deploy, ganz im Gegensatz zu Code.

Ein Lackmustest, ob eine App die Konfiguration vollständig ausgelagert hat, ist, wenn die Codebase jederzeit als Open Source veröffentlicht werden könnte, ohne Credentials preiszugeben.

Es sei darauf hingewiesen, dass diese Definition von “Konfiguration” die interne Anwendungskonfiguration nicht einschließt, wie config/routes.rb in Rails oder wie Code-Module mit Spring verdrahtet sind. Diese Art von Konfiguration ändert sich nicht von Deploy zu Deploy und gehört daher zum Code.

Als Konfiguration könnte man auch Dateien verwenden, die nicht ins Versionsmanagement eingecheckt sind wie config/database.yml in Rails. Dies ist eine deutliche Verbesserung gegenüber der Verwendung von Konstanten, die ins Versionsmanagement eingecheckt sind, hat aber Schwächen. Es ist relativ einfach, versehentlich eine Konfigurationsdatei ins Repo einzuchecken. Zusätzlich gibt es Tendenzen, Konfigurationsdateien an verschiedenen Orten und in verschiedenen Formaten zu streuen. Das macht es schwer die Konfiguration von einem Punkt aus zu managen. Desweiteren sind diese Formate oft sprach- oder plattformspezifisch.

Die Zwölf-Faktor-App speichert die Konfiguration in Umgebungsvariablen (kurz auch env vars oder env). Umgebungsvariablen von Deploy zu Deploy zu ändern ist einfach; im Gegensatz zu Konfigurationsdateien ist es unwahrscheinlich, dass sie versehentlich ins Code Repository eingecheckt werden und im Gegensatz zu speziellen Konfigurationsdateien oder anderen Konfigurationsmechanismen wie den Java Properties sind sie Sprach- und Betriebssystemunabhängig.

Ein anderer Aspekt des Konfigurationsmanagements ist die Gruppierung. Manchmal sammeln Apps die Konfiguration in benamten Gruppen (oft “Umgebungen” genannt), benannt nach bestimmten Deploys wie zum Beispiel die Umgebungen development, test und production in Rails. Diese Methode skaliert nicht sauber: Je mehr Deploys einer App es gibt, desto mehr Umgebungsnamen werden benötigt, wie zum Beispiel staging oder qa. Wenn das Projekt noch weiter wächst, könnten Entwickler ihre eigenen speziellen Umgebungen wie joes-staging hinzufügen. Am Ende explodiert die Konfiguration kombinatorisch und die Verwaltung der Deploys wird fehleranfällig.

In einer Zwölf-Faktor-App sind Umgebungsvariablen granulare Stellschrauben und vollständig orthogonal zueinander. Sie werden nie als “Umgebungen” zusammengefasst, sondern können für jeden Deploy unabhängig verwaltet werden. Dieses Modell skaliert reibungslos aufwärts, wenn die App sich natürlicherweise über ihre Lebenszeit hinweg auf mehr Deploys ausdehnt.\n\n\n\nII. Εξαρτήσεις

Εξαρτήσεις εκπεφρασμένα δηλωμένες και απομονωμένες

Οι περισσότερες γλώσσες προγραμματισμού προσφέρουν ένα σύστημα πακεταρίσματος για διανομή των βιβλιοθηκών υποστήριξης, όπως το CPAN για την Perl ή το Rubygems για τη Ruby. Οι βιβλιοθήκες που εγκαθιστούνται μέσω του συστήματος πακεταρίσματος μπορουν να εγκατασταθούν είτε για όλο το σύστημα (γνωστές ως “καθολικά πακέτα”, “site packages”) είτε τοπικά μέσα στο φάκελο που περιέχει την εφαρμογή (γνωστές ως “προμηθευμένες”, “vendoring” ή ως “δέσμες”, “bundling”).

Μία εφαρμογή δώδεκα παραγόντων ποτέ δεν εξαρτάται απο την υπόρρητη ύπαρξη καθολικών πακέτων. Δηλώνει όλες τις εξαρτήσεις, ολοκληρωτικά και ακριβώς, μέσω ενός δηλωτικού αρχείου δήλωσης εξαρτήσεων (dependency declaration manifest). Επιπλέον, χρησιμοποιεί ένα εργαλείο απομόνωσης εξαρτήσεων (dependency isolation) κατά την διάρκεια της εκτέλεσης ώστε να εξασφαλίσει ότι καμία υπόρρητη εξάρτηση δεν θα “διαρρέυσει” απο το περιβάλλον σύστημα. Η πλήρης και εκπεφρασμένη δήλωση εξαρτήσεων εφαρμόζεται το ίδιο και στο περιβάλλον παραγωγής και στο περιβάλλον υλοποίησης (του προγραμματιστή).

Για παράδειγμα, το Bundler για τη Ruby προσφέρει τη δομή δηλωτικού Gemfile για δήλωση εξαρτήσεων και το bundle exec για απομόνωση εξαρτήσεων. Στην Python υπάρχουν δύο διαφορετικά εργαλεία για αυτά τα βήματα – το Pip χρησιμοποιείται για δήλωση και το Virtualenv για απομόνωση. Ακόμα και η C έχει το Autoconf για δήλωση εξαρτήσεων, και η στατική διασύνδεση μπορεί να προσφέρει απομόνωση εξαρτήσεων. Όποια και αν είναι η αλυσίδα εργαλείων, η δήλωση εξαρτήσεων και η απομόνωση πρέπει πάντα να χρησιμοποιούνται μαζί – μόνο η μία ή η άλλη δεν είναι ικανό για τους δώδεκα παράγοντες.

Ένα πλεονέκτημα της εκπεφρασμένης δήλωσης εξαρτήσεων είναι ότι απλοποιεί το στήσιμο της εφαρμογής για προγραμματιστές οι οποίοι είναι καινούργιοι στην εφαρμογή. Ο νέος προγραμματιστής μπορεί να κατεβάσει τη βάση κώδικα της εφαρμογής στο δικό του υπολογιστή, απαιτώντας να εγκατασταθούν μόνο το εκτελέσιμο της γλώσσας προγραμματισμού (language runtime) και ο διαχειριστής εξαρτήσεων (dependency manager) ως προαπαιτούμενα. Αυτά θα είναι ικανά να στήσουν οτιδήποτε χρειάζεται ώστε να τρέξει η εφαρμογή μέσω μιάς ντετερμινιστικής εντολής κατασκευής (build command). Για παράδειγμα, η εντολή κατασκευής για το Ruby/Bundler είναι bundle install, ενώ για την Clojure/Leiningen είναι lein deps.

Οι εφαρμογές δώδεκα παραγόντων επίσης δεν εξαρτώνται από την υπόρρητη ύπαρξη οποιουδήποτε εργαλείου συστήματος. Μερικά παραδείγματα είναι το ImageMagick ή το curl. Μπορεί αυτά τα εργαλεία να υπάρχουν σε πολλά ή στα περισσότερα συστήματα, αλλά κανείς δεν εγγυάται ότι θα υπάρχουν σε όλα τα συστήματα που θα τρέξουν την εφαρμογή στο μέλλον, ή ότι η έκδοση που θα υπάρχει θα είναι συμβατή με την εφαρμογή. Εάν η εφαρμογή χρειάζεται κάποιο τέτοιο εργαλείο συστήματος, αυτό το εργαλείο πρέπει να γίνει προμηθέυσιμο (vendored) μέσα στην εφαρμογή.\n\n\n\nIII. Παραμετροποίηση

Αποθήκευση παραμέτρων στο περιβάλλον

Οι παράμετροι (config) μιας εφαρμογής είναι όλα εκείνα που είναι πιθανό να αλλάζουν ανά ανάπτυξη της εφαρμογής (έλεγχος, παραγωγή, περιβάλλον προγραμματιστή, κλπ). Αυτό περιλαμβάνει:


Αναγνωριστικά πόρων (resource handles) στη βάση δεδομένων, στο Memcached, και άλλες υπηρεσίες υποστήριξης

Διαπιστευτήρια (credentials) για εξωτερικές υπηρεσίες όπως το Amazon S3 ή το Twitter

Τιμές σχετικές με μια συγκεκριμένη ανάπτυξη όπως το κανονικό όνομα φιλοξενητή (canonical hostname) της ανάπτυξης


Οι εφαρμογές μερικές φορές αποθηκέυουν τις παραμέτρους ως σταθερές στον κώδικα. Αυτό αποτελεί παραβίαση των δώδεκα παραγόντων, το οποίο απαιτεί αυστηρό διαχωρισμό παραμέτρων από τον κώδικα. Οι παράμετροι διαφοροποιούνται σημαντικά μεταξύ αναπτύξεων, ο κώδικας όχι.

Ένα τέστ litmus για το αν μία εφαρμογή έχει αφήσει έξω την παραμετροποίηση με σωστό τρόπο είναι εάν η βάση κώδικα μπορει να γίνει ανοιχτού κώδικα ανά πάσα στιγμή, χωρίς να γίνει γνωστό κανένα διαπιστευτήριο.

Σημειώστε ότι αυτός ο ορισμός της παραμετροποίησης δεν συμπεριλαμβάνει την εσωτερική παραμετροποίηση της εφαρμογής, όπως το config/routes.rb στο Rails, ή πως συνδέονται τα μέρη του κώδικα στο Spring. Αυτός ο τύπος παραμετροποίησης δεν μεταβάλλεται μεταξύ αναπτύξεων, οπότε είναι καλύτερα να γίνεται στον κώδικα.

Μια άλλη προσέγγιση στην παραμετροποίηση είναι η χρήση αρχείων παραμέτρων (config files) τα οποία δεν περιλαμβάνονται στο αποθετήριο της εφαρμογής, όπως το config/database.yml στο Rails. Αυτό αποτελεί μια μεγάλη βελτίωση από το να χρησιμοποιούνται σταθερές στον κώδικα, αλλά ακόμα έχει αδυναμίες: είναι εύκολο κατά λάθος να συμπεριληφθεί το αρχείο στο αποθετήριο, υπάρχει μία τάση τα αρχεία παραμέτρων να είναι διασκορπισμένα σε διάφορα μέρη και σε διαφορετικές μορφές, καθιστώντας έτσι δύσκολο να δει και να διαχειριστεί κάποιος όλες τις παραμέτρους σε ένα μέρος. Επιπλέον, αυτές οι μορφές τείνουν να είναι συγκεκριμένες ως προς τη γλώσσα προγραμματισμού ή το πλαισιο ανάπτυξης της εφαρμογής.

Η εφαρμογή δώδεκα παραγόντων αποθηκεύει την παραμετροποίηση σε μεταβλητές περιβάλλοντος (environment variables, env vars, env). Οι μεταβλητές περιβάλλοντος αλλάζουν έυκολα μεταξύ αναπτύξεων της εφαρμογής χωρίς να αλλάξει ο κώδικας, σε σχέση με τα αρχεία παραμέτρων, υπάρχει μικρή πιθανότητα κατά λάθος να εισαχθούν στο αποθετήριο του κώδικα, και επίσης πάλι σε σχέση με τα αρχεία παραμέτρων, ή άλλους μηχανισμούς παραμετροποίησης όπως τα Java System Properties, αποτελούν ένα πρότυπο ανεξάρτητο από τη γλώσσα προγραμματισμού και το λειτουργικό σύτημα.

Μια άλλη πλευρά της διαχείρισης παραμέτρων είναι η ομαδοποίηση. Μερικές φορές οι εφαρμογές στοιβάζουν παραμέτρους σε ονομαστικές ομάδες (συχνά καλούνται “περιβάλλοντα”) που παίρνουν το όνομά τους απο συγκεκριμένες αναπτύξεις, όπως τα περιβάλλοντα development (υλοποίηση), test (τέστ), και production (παραγωγή) στο Rails. Αυτή η μέθοδος δεν κλιμακώνεται καθαρά: καθώς περισσότερες αναπτύξεις της εφαρμογής δημιουργούνται, νέα ονόματα περιβαλλόντων γίνονται απαραίτητα, όπως staging (έλεγχος) ή qa. Καθώς το έργο επεκτείνεται περαιτέρω, οι προγραμματιστές μπορει να προσθέσουν τα δικά τους ειδικά περιβάλλοντα όπως joes-staging, συνεπαγόμενα μια συνδυαστική έκρηξη από παραμετροποιήσεις που κάνουν την διαχείριση αναπτύξεων της εφαρμογής πολύ εύθραυστη.

Σε μια εφαρμογή δώδεκα παραγόντων, οι μεταβλητές περιβάλλοντος αποτελούν στοιχεία λεπτοφυούς ελέγχου, το καθένα πλήρως ορθογώνιο σε άλλες μεταβλητές περιβάλλοντος. Ποτέ δεν ομαδοποιούνται μαζί ως “περιβάλλοντα”, αντιθέτως διαχειρίζονται ανεξάρτητα για κάθε ανάπτυξη της εφαρμογής. Αυτό είναι ένα μοντέλο που κλιμακώνεται ομαλά προς τα πάνω καθώς η εφαρμογή φυσικά διευρύνεται σε περισσότερες αναπτύξεις κατά της διάρκεια της ζωής της.\n\n\n\nII. Dependencias

Declarar y aislar explícitamente las dependencias

La mayoría de los lenguajes de programación tienen un sistema de gestión de paquetes para distribuir sus librerías, como CPAN en Perl o Rubygems en Ruby. Las librerías instaladas a través de estos sistemas se pueden instalar en el sistema (también conocido como “site packages”) o limitarse al directorio que contiene la aplicación (también conocido como “vendoring” o “bundling”).

Una aplicación “twelve-factor” no depende nunca de la existencia explícita de paquetes instalados en el sistema. Declara todas sus dependencias, completamente y explícitamente, mediante un manifiesto de declaración de dependencias. Además, usa herramientas de aislamiento de dependencias durante la ejecución para asegurar que las dependencias, implícitamente, no afectan al resto del sistema. La especificación de dependencias completa y explícita se aplica de la misma manera tanto en producción como en desarrollo.

Por ejemplo, la Bundler de Ruby tiene el formato de su manifiesto Gemfile para declarar sus dependencias y bundle exec para aislar sus dependencias. En Python existen dos herramientas independientes para estas tareas – Pip se usa para la declaración de dependencias y Virtualenv para el aislamiento. Incluso C tiene Autoconf para la declaración de sus dependencias, y el enlace estático proporciona aislamiento de sus dependencias. No importa qué conjunto de herramientas se use, la declaración y el aislamiento de dependencias se deben usar siempre juntas, usar solo una o la otra no es suficiente para satisfacer las condiciones de “twelve-factor”.

Uno de los beneficios de la declaración explícita de dependencias es que simplifica la configuración para los nuevos desarrolladores de la aplicación. Cualquier desarrollador que se incorpore al equipo debe poder probar el código base de la aplicación en su máquina de desarrollo. Tan solo debe tener instalados el entorno de ejecución del lenguaje y el gestor de dependencias como prerequisitos. Lo cual permitirá configurar todo lo necesario para ejecutar el código de la aplicación con un mandato para construir. Por ejemplo, el mandato para construir en Ruby/Bundler es bundle install, mientras que en Clojure/Leiningen es lein deps.

Las aplicaciones “Twelve-factor” tampoco dependen de la existencia de ninguna herramienta en el sistema. Por ejemplo, ejecutar mandatos como ImageMagick o curl. Aunque estas herramientas pueden existir en muchos, o incluso en la mayoría de los sistemas, no existen garantías de que vayan a existir en todos los sistemas donde la aplicación pueda ser ejecutada en un futuro, ni de que las versiones futuras de un sistema vayan a ser compatibles con la aplicación. Si la aplicación necesita ejecutar una herramienta del sistema, dicha herramienta debería estar incluida dentro de la aplicación.\n\n\n\nIII. Configuración

Guardar la configuración en el entorno

La configuración de una aplicación es todo lo que puede variar entre despliegues (entornos de preproducción, producción, desarrollo, etc), lo cual incluye:


Recursos que manejan la base de datos, Memcached, y otros “backing services”

Credenciales para servicios externos tales como Amazon S3 o Twitter

Valores de despliegue como por ejemplo el nombre canónico del equipo para el despliegue


A veces las aplicaciones guardan configuraciones como constantes en el código, lo que conduce a una violación de la metodología “twelve-factor”, que requiere una estricta separación de la configuración y el código. La configuración varía sustancialmente en cada despliegue, el código no.

La prueba de fuego para saber si una aplicación tiene toda su configuración correctamente separada del código es comprobar que el código base puede convertirse en código abierto en cualquier momento, sin comprometer las credenciales.

Hay que resaltar que la definición de “configuración” no incluye las configuraciones internas de la aplicación, como config/routes.rb en Rails, o como se conectan los módulos en Spring. Este tipo de configuraciones no varían entre despliegues, y es por eso que están mejor en el código.

Otra estrategia de configuración es el uso de ficheros de configuración que no se guardan en el control de versiones, como ocurre con el config/database.yml de Rails. Esto supone una gran mejora con respecto a las constantes que se guardan en el repositorio, aunque todavía tiene ciertas debilidades: es fácil guardar un fichero de configuración en el repo por error; se tiende a desperdigar los ficheros de configuración en diferentes sitios y con distintos formatos, siendo más difícil la tarea de ver y gestionar toda la configuración en un solo sitio. Además, el formato tiende a ser específico del lenguaje o del framework.

Las aplicaciones “twelve-factor” almacenan la configuración en variables de entorno (abreviadas normalmente como env vars o env). Las variables de entorno se modifican fácilmente entre despliegues sin realizar cambios en el código; a diferencia de los ficheros de configuración, en los que existe una pequeña posibilidad de que se guarden en el repositorio de código accidentalmente; y a diferencia de los ficheros de configuración personalizados u otros mecanismos de configuración, como los System Properties de Java, son un estándar independiente del lenguaje y del sistema operativo.

Otro aspecto de la gestión de la configuración es la clasificación. A veces, las aplicaciones clasifican las configuraciones en grupos identificados (a menudo llamados “entornos” o “environments”) identificando después despliegues específicos, como ocurre en Rails con los entornos development, test, y production. Este método no escala de una manera limpia: según se van creando despliegues de la aplicación, se van necesitando nuevos entornos, tales como staging o qa. Según va creciendo el proyecto, los desarrolladores van añadiendo sus propios entornos especiales como joes-staging, resultando en una explosión de combinaciones de configuraciones que hacen muy frágil la gestión de despliegues de la aplicación.

En una aplicación “twelve-factor”, las variables de entorno son controles granulares, cada una de ellas completamente ortogonales a las otras. Nunca se agrupan juntas como “entornos”, pero en su lugar se gestionan independientemente para cada despliegue. Este es un modelo que escala con facilidad según la aplicación se amplía, naturalmente, en más despliegues a lo largo de su vida.\n\n\n\nII. Dépendances

Déclarez explicitement et isolez les dépendances

La plupart des langages de programmation offrent des systèmes pour créer des paquets à partir de bibliothèques afin de les distribuer, tel que CPAN pour Perl ou Rubygems pour Ruby. Les bibliothèques installées à travers un système de packaging peuvent être installées à travers tout le système, ou bien limitées au répertoire contenant l’application (que l’on appelle les “vendor” ou “bundles”).

Une application 12 facteurs ne dépend jamais de l’existence implicite de packages au niveau du système. Elle déclare toutes ses dépendances, complètement et exactement, à travers un manifeste de déclaration de dépendances. De plus, elle utilise un outil d’isolation des dépendances durant l’exécution afin d’assurer qu’aucune dépendance implicite ne s’introduise depuis le système environnant. Les spécifications complètes et explicites sont appliquées uniformément en développement comme en production.

Par exemple, Bundler pour Ruby fournit le format de manifeste Gemfile pour la déclaration des dépendances, ainsi que la commande bundle exec pour l’isolation des dépendances. En python, il y a deux outils séparés pour ces étapes – Pip est utilisé pour la déclaration et Virtualenv pour l’isolation. Même le C dispose d’Autoconf pour les déclarations de dépendances, et la liaison statique peut fournir l’isolation des dépendances. Peu importe la chaîne d’outils, la déclaration et l’isolation des dépendances doivent toujours être utilisées ensemble – seulement l’un ou l’autre ne suffit pas à satisfaire les 12 facteurs.

Un des bénéfices de la déclaration explicite des dépendances est que cela simplifie la mise en place pour les développeurs qui découvrent l’application. Les nouveaux développeurs peuvent jeter un œil à la base de code de l’application sur leur machine de développement, en ayant besoin uniquement d’avoir de quoi exécuter le langage ainsi que le gestionnaire de dépendances installé en pré-requis. Ils pourront mettre en place tout ce qui est nécessaire pour faire fonctionner le code de l’application de manière déterministe grâce à une commande d’assemblage (commande de build). Par exemple, la commande d’assemblage pour Ruby/Bundler est bundle install, alors que pour Clojure/Leiningen c’est lein deps.

Les applications 12 facteurs ne s’appuient pas sur l’existence implicite d’outils système, par exemple ImageMagick ou curl. Bien que ces outils puissent exister sur beaucoup voire la plupart des systèmes d’exploitation, il n’y a pas de garantie qu’ils existeront sur tous les systèmes où l’application sera exécutée à l’avenir, ou si la version disponible sur un système futur sera compatible avec l’application. Si l’application dépend d’un outil système, cet outil doit être distribué avec l’application.\n\n\n\nIII. Configuration

Stockez la configuration dans l’environnement

La configuration d’une application est tout ce qui est susceptible de varier entre des déploiements (validation, production, environnement de développement, etc.). Cela inclut :


Les ressources gérées par la base de données, Memcached, ou tout autre service de stockage

Les identifiants pour des services externes, tel qu’Amazon S3 ou Twitter

Les valeurs spécifiques au déploiement, tel que son nom d’hôte canonique


Les applications stockent parfois la configuration avec des constantes dans le code. C’est une violation des 12 facteurs, qui requiert une stricte séparation de la configuration et du code. La configuration peut varier substantiellement à travers les déploiements, alors que ce n’est pas le cas du code.

Un bon moyen de tester si une application a correctement séparé son code, c’est de se demander si l’application pourrait être rendue open-source à tout instant, sans compromettre d’identifiants.

Notez que cette définition de “configuration” n’inclut pas la configuration interne de l’application, tel que config/routes.rb avec Rails, ou comment les modules du noyau sont connectés (en) dans Spring. Ce type de configuration ne varie pas à travers les déploiements, et est ainsi mieux réalisé dans le code.

Une autre approche de la configuration, c’est d’utiliser des fichiers de configuration qui ne sont pas inclus dans le système de contrôle de version, par exemple config/database.yml de Rails. C’est une amélioration considérable par rapport à l’utilisation de constantes qui sont versionnées dans le dépôt de code, mais a toujours des faiblesses : il est facile d’ajouter par inadvertance un fichier de configuration dans le dépôt. Il y a une tendance à ce que les fichiers de configuration soient dispersés à différents endroits et dans différents formats, rendant ainsi difficile de voir et gérer la configuration à un unique endroit. De plus, ces formats ont tendance à être spécifiques à un langage ou un framework.

Les applications 12 facteurs stockent la configuration dans des variables d’environnement (souvent raccourcies en variables d’env, ou env). Les variables d’environnement sont faciles à changer entre des déploiements sans changer le moindre code ; contrairement aux fichiers de configuration, il y a peu de chance pour qu’elles soient ajoutées au dépôt de code accidentellement ; et contrairement aux fichiers de configuration personnalisés, ou tout autre mécanisme de configuration comme les propriétés système Java, ce sont des standards agnostiques du langage ou du système d’exploitation.

Un autre aspect de la gestion de configuration est le groupage. Parfois, les applications regroupent la configuration dans des groupes nommés (souvent appelés les “environnements”), nommés ainsi d’après des déploiements spécifiques, comme les environnements development, test, et production de Rails. Cette méthode ne permet pas de grossir proprement : lorsque l’on ajoute de nouveaux déploiement à l’application, de nouveaux noms d’environnement sont nécessaires, comme validation ou qa. Quand le projet grossit encore plus, les développeurs vont avoir tendance à ajouter leurs propres environnements particuliers, comme joes-validation, ce qui entraîne une explosion combinatoire de la configuration qui rend la gestion des déploiements de l’application très fragile.

Dans une application 12 facteurs, les variables d’environnement permettent un contrôle granulaire, chacune complètement orthogonale aux autres variables d’environnement. Elles ne sont jamais groupées ensemble en “environnements”, mais sont plutôt gérées indépendamment pour chaque déploiement. C’est un modèle qui permet de grossir verticalement en souplesse, lorsque l’application grossit naturellement en un plus grand nombre de déploiements au cours de sa vie.\n\n\n\nII. Dipendenze

Dipendenze dichiarate e isolate

Molti linguaggi di programmazione offrono dei sistemi di packaging per la distribuzione delle proprie librerie, come CPAN per Perl o Rubygems per Ruby. Le librerie installate attraverso questi sistemi, inoltre, possono essere identificate come “system-wide” (attive a livello di sistema), oppure posizionate nella directory della singola applicazione (in questo caso si parla di “vendoring” o “bundling”).

Un’applicazione che aderisce alla twelve-factor non si basa mai sull’esistenza implicita di librerie system-wide. Le dipendenze vengono tutte dichiarate, tramite un manifest dedicato. Inoltre, viene contemplato anche l’uso di un tool di isolamento delle dipendenze durante l’esecuzione, in modo tale da assicurarsi che non ci siano delle “dipendenze implicite” che creino interferenze nel sistema in cui ci si trova. La specifica completa ed esplicita delle dipendenze si applica in modo uniforme: sia in production che in sviluppo.

Per esempio, Bundler per Ruby offre il supporto di un file-manifesto Gemfile da usare per la dichiarazione delle dipendenze e bundle exec per il loro isolamento. In Python invece troviamo altri due tool per questi scopi – Pip viene usato per la dichiarazione e Virtualenv per l’isolamento. Anche C ha Autoconf per la dichiarazione di dipendenze, mentre lo static linking si occupa dell’isolamento. Non importa quale sia il toolchain usato, le operazioni di dichiarazione e isolamento vanno sempre effettuate. In caso contrario, l’applicazione non aderisce più alla metodologia.

Un altro importante beneficio di una dichiarazione esplicita delle dipendenze sta nel fatto che semplifica di molto la configurazione iniziale per gli sviluppatori appena entrati a lavorare al progetto. Il nuovo arrivato non dovrà fare altro che effettuare un check out della codebase nella propria macchina di sviluppo, occupandosi di dover installare solo ed esclusivamente le dipendenze, appunto, dichiarate. Molto spesso è inoltre presente un build command che permette di automatizzare il processo. Per Ruby/Bundler si usa bundle install, mentre per Clojure/Leiningen c’è lein deps.

Ogni applicazione che aderisce alla metodologia twelve-factor, inoltre, non si basa mai sull’esistenza di un qualsiasi tool di sistema. Alcuni esempi sono ImageMagick o curl. Nonostante questi software esistano già su buona parte dei sistemi in circolazione, non è comunque detto che siano presenti su tutti quelli su cui girerà l’applicazione in futuro. Se l’app non può fare a meno di questo tool, si dovrebbe prendere in considerazione l’idea di “vendorizzarlo” nell’applicazione stessa.\n\n\n\nIII. Configurazione

Memorizza le informazioni di configurazione nell’ambiente

La “configurazione” di un’applicazione è tutto quello che può variare da un deployment all’altro (staging, production, ambienti di sviluppo). Ad esempio:


Valori da usare per connettersi a un database, Memcached, oppure altri backing service;

Credenziali per servizi esterni, come Amazon S3 o Twitter;

Valori eventualmente definiti per i singoli deployment, come l’hostname;


Molto spesso, queste informazioni vengono memorizzate come costanti nel codice: la cosa viola la metodologia twelve-factor, che richiede una separazione ben definita delle impostazioni di configurazione dal codice. Le impostazioni possono infatti variare da un deployment all’altro: il codice, invece, no.

Il codice dell’applicazione, infatti, potrebbe essere reso open-source in ogni momento: un buon motivo per separare le due cose.

Nota che comunque la definizione di “configurazione” non include eventuali configurazione interne dell’applicazione, come config/routes.rb in Rails, o come i moduli di codice sono connessi in Spring. Questo tipo di configurazione non varia da deployment a deployment: come giusto che sia, quindi, rimane nel codice.

Un ottimo approccio al “rispetto” di questo principio consiste nell’usare dei file di configurazione non coinvolti dal version control, come per esempio config/database.yml in Rails. Stiamo parlando di un miglioramento enorme rispetto all’uso di costanti nel codice, ma c’è da dire la cosa ha il suo lato negativo: basta poco per sbagliarsi e includere nel repo il file di configurazione che, invece, non dovrebbe essere lì. C’è una certa tendenza, infatti, a non avere tutti i file di configurazione necessari nello stesso posto. Inoltre, i vari formati tendono a essere collegati a un certo linguaggio/framework.

L’applicazione che rispetta la metodologia twelve-factor memorizza tutte le impostazioni in variabili d’ambiente (spesso dette env vars o env). Le variabili d’ambiente sono molto semplici da cambiare di deployment in deployment senza dover toccare il codice direttamente. Inoltre, a differenza dei file di configurazione classici, c’è una probabilità molto bassa di venire inclusi nel repo. Infine, questi file sono indipendenti sia dal linguaggio che dal sistema operativo utilizzato.

Un altro aspetto del config management è il raggruppamento. A volte, infatti, alcune applicazioni prevedono la memorizzazione delle impostazioni in gruppi (chiamati spesso “ambienti”) dal nome ben preciso: “development”, “test” e “production”, per esempio. Questo metodo non scala correttamente, se ci pensi: potrebbero essere necessari nuovi ambienti, come “staging” e “qa”. Oppure, i vari sviluppatori potrebbero aver bisogno di creare i propri ambienti “speciali”, come “joes-staging” e così via. Il risultato? Una quantità di combinazioni ingestibile e disordinata.

In una buona twelve-factor app, le variabili di ambiente sono controllate in modo più “granulare”, in modo totalmente ortogonale alle altre. Non sono mai raggruppate e classificate sotto “ambienti” specifici, ma vengono gestite in modo totalmente indipendente per ogni deployment. Il prodotto finale ne risente positivamente in termini di scalabilità.\n\n\n\nII. 依存関係

依存関係を明示的に宣言し分離する

ほとんどのプログラミング言語は、サポートライブラリを配布するためのパッケージ管理システムを提供している。例えば、PerlにおけるCPANやRubyにおけるRubygemsなどである。パッケージ管理システムでインストールされるライブラリは、システム全体（“site packages”と言われる）にインストールされる場合と、アプリケーションを含むディレクトリのスコープ（“vendoring”または“bundling”と言われる）にインストールされる場合がある。

Twelve-Factor Appは、システム全体にインストールされるパッケージが暗黙的に存在することに決して依存しない。 すべての依存関係を 依存関係宣言 マニフェストで完全かつ厳密に宣言する。さらに、実行時には 依存関係分離 ツールを使って、取り囲んでいるシステムから暗黙の依存関係が“漏れ出ない”ことを保証する。完全かつ明示的な依存関係の指定は、本番環境と開発環境の両方に対して同様に適用される。

例えば、Rubyで使われるBundler は、依存関係宣言のためのマニフェストのフォーマットであるGemfileと依存関係分離のためのbundle execを提供している。Pythonではこれらのステップで2つの別々のツールが使われる – Pipが宣言のために使われ、Virtualenvが分離のために使われる。C言語でもAutoconfで依存関係を宣言し、静的リンクで依存関係を分離することができる。ツールが何であれ、依存関係の宣言と分離は常に一緒に使わなければならない – どちらか片方だけではTwelve-Factorを満足するのに不十分である。

明示的に依存関係を宣言する利点の1つは、アプリケーションに新しい開発者が加わった際のセットアップを単純化できることである。新しい開発者は、言語のランタイムと依存関係管理ツールさえインストールされていれば、アプリケーションのコードベースを自分の開発マシンにチェックアウトすることができる。開発者は決められた ビルドコマンド で、アプリケーションのコードを実行するために必要なすべてのものをセットアップできる。例えば、Ruby/Bundlerのビルドコマンドはbundle installであり、Clojure/Leiningenではlein depsである。

また、Twelve-Factor Appは、いかなるシステムツールの暗黙的な存在にも依存しない。例として、アプリケーションからImageMagickやcurlを使う場合がある。これらのツールはほとんどのシステムに存在するだろうが、アプリケーションが将来に渡って実行され得るすべてのシステムに存在するかどうか、あるいは将来のシステムでこのアプリケーションと互換性のあるバージョンが見つかるかどうかについては何の保証もない。アプリケーションがシステムツールを必要とするならば、そのツールをアプリケーションに組み込むべきである。\n\n\n\nIII. 設定

設定を環境変数に格納する

アプリケーションの 設定 は、デプロイ（ステージング、本番、開発環境など）の間で異なり得る唯一のものである。設定には以下のものが含まれる。


データベース、Memcached、他のバックエンドサービスなどのリソースへのハンドル

Amazon S3やTwitterなどの外部サービスの認証情報

デプロイされたホストの正規化されたホスト名など、デプロイごとの値


アプリケーションは時に設定を定数としてコード内に格納する。これはTwelve-Factorに違反している。Twelve-Factorは 設定をコードから厳密に分離すること を要求する。設定はデプロイごとに大きく異なるが、コードはそうではない。

アプリケーションがすべての設定をコードの外部に正しく分離できているかどうかの簡単なテストは、認証情報を漏洩させることなく、コードベースを今すぐにでもオープンソースにすることができるかどうかである。

なお、この“設定”の定義には、アプリケーション内部の設定は 含まない ことに注意する。内部の設定とは、Railsにおけるconfig/routes.rbや、Springにおいてコードモジュールがどう接続されるかなどの設定を指す。この種の設定はデプロイの間で変わらないため、コードの内部で行うべきである。

設定に対するもう1つのアプローチは、バージョン管理システムにチェックインされない設定ファイルを使う方法である。例として、Railsにおけるconfig/database.ymlがある。この方法は、リポジトリにチェックインされる定数を使うことに比べると非常に大きな進歩であるが、まだ弱点がある。設定ファイルが誤ってリポジトリにチェックインされやすいことと、設定ファイルが異なる場所に異なるフォーマットで散乱し、すべての設定を一つの場所で見たり管理したりすることが難しくなりがちであることである。その上、これらのフォーマットは言語やフレームワークに固有のものになりがちである。

Twelve-Factor Appは設定を 環境変数 に格納する。 環境変数は、コードを変更することなくデプロイごとに簡単に変更できる。設定ファイルとは異なり、誤ってリポジトリにチェックインされる可能性はほとんどない。また、独自形式の設定ファイルやJava System Propertiesなど他の設定の仕組みとは異なり、環境変数は言語やOSに依存しない標準である。

設定管理のもう1つの側面はグルーピングである。アプリケーションは設定を名前付きのグループ（しばしば“環境”と呼ばれる）にまとめることがある。グループは、Railsにおけるdevelopment、test、production環境のように、デプロイの名前を取って名付けられる。この方法はうまくスケールしない。アプリケーションのデプロイが増えるにつれて、新しい環境名（stagingやqa）が必要になる。さらにプロジェクトが拡大すると、開発者はjoes-stagingのような自分用の環境を追加する。結果として設定が組み合わせ的に爆発し、アプリケーションのデプロイの管理が非常に不安定になる。

Twelve-Factor Appの場合、環境変数は粒度の細かい管理であり、それぞれの環境変数は互いに直交している。環境変数は“環境”としてまとめられることはないが、代わりにデプロイごとに独立して管理される。これは、アプリケーションのライフサイクルに渡って、アプリケーションが多くのデプロイへと自然に拡大していくにつれて、スムーズにスケールアップするモデルである。\n\n\n\nII. 종속성

명시적으로 선언되고 분리된 종속성

대부분의 프로그래밍 언어는 라이브러리 배포를 위한 패키징 시스템을 제공하고 있습니다. Perl의 CPAN 이나 Ruby의 Rubygems가 그 예입니다. 라이브러리는 패키징 시스템을 통해 시스템 전체(site pakages)나 애플리케이션을 포함한 디렉토리(vendoring 혹은 bundling)에 설치될 수 있습니다.

Twelve-Factor App은 전체 시스템에 특정 패키지가 암묵적으로 존재하는 것에 절대 의존하지 않습니다. 종속선 선언 mainifest를 이용하여 모든 종속성을 완전하고 엄격하게 선언합니다. 더나아가, 종속성 분리 툴을 사용하여 실행되는 동안 둘러싼 시스템으로 암묵적인 종속성 “유출”이 발생하지 않는 것을 보장합니다. 이런 완전하고 명시적인 종속성의 명시는 개발과 서비스 모두에게 동일하게 적용됩니다.

예를 들어, 루비에서 사용되는 Bundler는 종속성 선언을 위해 Gemfile manifest 포맷을 지원하며, 종속성 분리를 위해 bundle exec를 지원합니다. 파이썬에는 이를 지원하기 위한 2가지 도구가 있습니다. Pip은 종속성 선언을 위해 사용되며, Virtualenv는 종속성 분리를 위해 사용됩니다. 심지어 C언어에도 종속성 분리를 위해 Autoconf가 있으며, static link를 활용해 종속성 분리도 가능합니다. 어떤 툴체인을 사용하든, 종속성 선언과 분리는 항상 같이 사용되어야 합니다. 하나만 사용하는 것은 Twelve-Factor에 만족하는 데 불충분합니다.

명시적인 종속성 선언의 장점 중 하나는 애플리케이션 개발에 새로 참가하게 된 개발자가 설치를 간단하게 할 수 있다는 점입니다. 새로 참가한 개발자는 애플리케이션의 코드베이스를 개발 머신에 체크아웃 하고, 언어의 런타임과 종속성 매니저만 미리 설치하면 됩니다. 개발자는 정해져있는 빌드 명령어만 입력하면 응용 프로그램의 코드를 실행하는 데 필요한 모든 것을 설치할 수 있습니다. 예를 들어, Ruby의 빌드 명령어는 bundle install이며, Clojure/Leiningen에서는 lein deps입니다.

Twelve-Factor App은 어떠한 시스템 도구에도 암시적으로 의존하지 않습니다. 예를 들어, ImageMagick이나 curl을 사용하는 경우가 있습니다. 이러한 툴들은 대부분의 시스템에 존재하지만, 모든 시스템에 존재하는 것이 보장되는 것은 아닙니다. 미래의 시스템에서는 존재하지 않을 수 있으며, 호환되는 버전이 있으라는 보장도 없습니다. 애플리케이션에게 시스템 도구가 필요하다면, 그 도구를 애플리케이션과 통합해야 합니다.\n\n\n\nIII. 설정

환경(environment)에 저장된 설정

애플리케이션의 설정은 배포 (스테이징, 프로덕션, 개발 환경 등) 마다 달라질 수 있는 모든 것들입니다. 설정에는 다음이 포함됩니다.


데이터베이스, memcached 등 백엔드 서비스들의 리소스 핸들

Amazon S3 이나 트위터 등의 외부 서비스 인증 정보

배포된 호스트의 정규화된 호스트 이름(canonical hostname)처럼 각 배포마다 달라지는 값


애플리케이션은 종종 설정을 상수로 코드에 저장합니다. 이것은 Twelve-Factor를 위반하며, Twelve-Factor는 설정을 코드에서 엄격하게 분리하는 것을 요구합니다. 설정은 배치마다 크게 다르지만, 코드는 그렇지 않습니다.

애플리케이션의 모든 설정이 정상적으로 코드 바깥으로 분리되어 있는지 확인할 수 있는 간단한 테스트는 어떠한 인증정보도 유출시키지 않고 코드베이스가 지금 당장 오픈 소스가 될 수 있는지 확인하는 것입니다.

이 “설정”의 정의는 애플리케이션 내부 설정을 포함하지 않는다는 점에 유의해야 합니다. Rails의 config/routes.rb이나 Spring의 “어떻게 코드 모듈이 연결되는 가과 같은 설정들은 배치 사이에서 변하지 않기 때문에 코드의 내부에 있는 것이 가장 좋습니다.

설정에 대한 또 다른 접근방식은 Rails의 config/database.yaml처럼 버전 관리 시스템에 등록되지 않은 설정 파일을 이용하는 것입니다. 이 방법은 코드 저장소에 등록된 상수를 사용하는 것에 비하면 매우 큰 발전이지만, 설정 파일이 여러 위치에 여러 포맷으로 흝어지고 모든 설정을 한 곳에서 확인하고 관리하기 어렵게 만드는 경향이 있습니다. 게다가, 이러한 형식들은 언어와 프레임워크을 따라가는 경향이 있습니다.

Twelve-Factor App은 설정을 환경 변수 (envvars나 env라고도 불림)에 저장합니다. 환경 변수는 코드 변경 없이 쉽게 배포 때마다 쉽게 변경할 수 있습니다. 설정 파일과 달리, 잘못해서 코드 저장소에 올라갈 가능성도 낮습니다. 또한, 커스텀 설정 파일이나 Java System Property와 같은 다른 설정 매커니즘과 달리 언어나 OS에 의존하지 않는 표준입니다.

설정 관리의 다른 측면은 그룹핑입니다. 종종 애플리케이션은 설정을 명명된 그룹(“environments”라고도 함)으로 구성하기도 합니다. 해당 그룹은 Rails의 ‘development’, ‘test’, ‘production’ environments처럼, 배포의 이름을 따서 명명됩니다. 이 방법은 깔끔하게 확장하기 어렵습니다. 응용 프로그램의 배포가 증가함에 따라, ‘staging’이라던가 ‘qa’같은 새로운 그룹의 이름이 필요하게 됩니다. 프로젝트가 성장함에 따라, 개발자은 자기 자신의 그룹를 추가하게 됩니다. 결과적으로 설정이 각 그룹의 조합으로 폭발하게 되고, 애플리케이션의 배포를 불안정하게 만듭니다.

Twelve-Factor App에서 환경 변수는 매우 정교한 관리이며, 각각의 환경변수는 서로 직교합니다. 환경 변수는 “environments”로 절대 그룹으로 묶이지 않지만, 대신 각 배포마다 독립적으로 관리됩니다. 이 모델은 애플리케이션의 수명주기를 거치는 동안 더 많은 배포로 원활하게 확장해 나갈 수 있습니다.\n\n\n\nII. Dependencies

Jawnie zadeklaruj i wydziel zależności

Większość języków programowania oferuje narzędzia do dystrybucji dodatkowych bibliotek, takie jak CPAN dla Perla lub Rubygems dla języka Ruby. Biblioteki zainstalowane w ten sposób mogą być dostępne dla całego systemu (określane jako “site packages”) lub zakres ich działania może być ograniczony dla pojedynczego projektu lub aplikacji (określane jako “vendoring” lub “bundling”).

Aplikacja 12factor nigdy nie jest zależna od bibliotek zainstalowanych dla całego systemu. Wszystkie zależności są dokładnie określone przez dokument zawierający ich kompletną listę (dependency declaration manifest). Ponadto taka aplikacja korzysta z narzędzia służącego do izolacji tych zależności podczas działania aplikacji. W ten sposób ma się pewność, że np. jakaś biblioteka nie jest przypadkiem jedną z tych zainstalowanych w zewnętrznym środowisku, w którym działa aplikacja. Inaczej podobna sytuacja mogłaby uniemożliwiać poprawne działanie aplikacji w innym środowisku, gdzie takiej biblioteki by brakowało. Pełna i dokładna specyfikacja bibliotek używanych przez aplikację jest identyczna dla zarówno środowiska developerskiego jak i produkcyjnego.

Np. Bundler dla Ruby’ego używa pliku Gemfile dla deklaracji bibliotek z których korzysta aplikacja oraz komendę bundle exec do izolacji tych zależności. W Pythonie istnieją dwa oddzielne narzędzia dla tych zadań – Pip jest używany do deklaracji oraz Virtualenv do izolacji. Nawet język C posiada narzędzie Autoconf do deklaracji zależności, a statyczne wiązania mogą zapewnić izolację zależności. Bez względu na użyte narzędzia, deklaracja i izolacja zależności muszą być zawsze stosowane razem. Użycie tylko jednej z nich nie jest wystarczające by spełnić wymogi 12factor.

Jedną z niewątpliwych korzyści deklaracji zależności jest uproszczenie początkowej konfiguracji aplikacji dla developera. Nowy programista może pobrać kod źródłowy z repozytorium. Następnie, posiadając wcześniej skonfigurowane środowisko danego języka i narzędzie do zarządzania jego bibliotekami, jest w stanie zainstalować wszystkie moduły i biblioteki potrzebne dla działania aplikacji przy pomocy jednej komendy. Taką komendą np. dla Ruby’ego/Bundlera jest bundle install, a dla Clojure/Leiningen jest to lein deps.

Aplikacje zgodne z 12factor również nie są zależne od systemowych narzędzi. Wśród przykładów można wymienić ImageMagick czy też curl. Pomimo, że narzędzia te mogą być dostępne na wielu lub nawet większości systemów, nie ma gwarancji, że będą istniały na wszystkich środowiskach, w których będzie uruchamiana aplikacja w przyszłości lub że ich wersja będzie kompatybilna. Jeśli aplikacja korzysta z jakiegokolwiek systemowego narzędzia, powinno być ono osobno do niej dołączone.\n\n\n\nIII. Konfiguracja

Przechowuj konfigurację w środowisku

Konfiguracja to jedyny element, który może się różnić pomiędzy wdrożeniami aplikacji (staging, produkcja, środowisko developerskie, etc). W jej skład wchodzą:


Ustawienia połączeń do baz danych, Memcached, i innych usług wspierających

Dane uwierzytelniające zewnętrznych usług takich jak Amazon S3 czy Twitter

Wartości różne dla każdego wdrożenia, jak np. kanoniczna nazwa hosta


Aplikacja czasem przechowuje konfigurację jako stałe wartości w kodzie źródłowym. Niestety jest to złamanie zasady 12factor wg której konfiguracja jest ściśle oddzielona od kodu aplikacji.

Dowodem na to, czy aplikacja posiada swoją konfigurację oddzieloną od kodu jest to, czy można ją udostępnić na zasadach open source bez równoczesnego udostępniania np. danych uwierzytelniających.

Należy pamiętać, że definicja “konfiguracji” nie dotyczy wewnętrznych ustawień aplikacji takich jak np. plik config/routes.rb w Railsach lub to jak są połączone moduły kodu w Springu. Konfiguracja tego typu nie zmienia się pomiędzy wdrożeniami co sprawia, że najbardziej odpowiednim miejscem do jej przechowywania jest kod aplikacji.

Innym podejściem do konfiguacji jest korzystanie z plików, które nie znajdują się w repozytorium i nie są wersjonowane, jak np. config/database.yml w Railsach. Jest to duże usprawnienie względem używania stałych wartości, które są zapisywane w repozytorium. Minusem tego rozwiązania jest możliwość przypadkowego umieszczenia pliku konfiguracyjnego w repo. Ponadto można spotkać się z tendencją do rozrzucania takich plików w różnych katalogach i różnych formatach, co czyni je trudnymi do znalezienia i zarządzania z jednego miejsca.

Aplikacja 12factor przechowuje konfigurację w zmiennych środowiskowych (czasem nazywane z języka angielskiego env vars lub env). W tej sytuacji można łatwo modyfikować zmienne środowiskowe pomiędzy wdrożeniami bez zmiany kodu aplikacji. W odróżnieniu do plików konfiguracyjnych istnieje mała szansa by zostały umieszczone przypadkowo w repozytorium. Ich kolejną zaletą jest to, że nie są powiązane z językiem programowania, frameworkiem, jak np. Java System Properties, czy też systemem operacyjnym.

Kolejnym zagadnieniem zarządzania konfiguracją jest jej grupowanie. Czasem aplikacje gromadzą konfigurację w grupach (czasem nazywane “środowiskami”) nazywanych od nazwy wdrożenia, takie jak development, test, czy produkcja w Railsach. Ten sposób organizacji jest niestety nieskalowalny. Im więcej różnych wdrożeń, tym większa potrzeba nazw, jak np. staging czy qa. Wraz z rozwojem projektu programiści mogą dodawać swoje specjalne konfiguracje, jak staging-józefa. Efektem tego mogą być niezliczone kombinacje nazw plików konfiguracyjnych, co utrudniać będzie zarządzanie wdrożonymi aplikacji.

W aplikacji 12factor zmienne środowiskowe służą do precyzyjnej kontroli poszczególnych ustawień, posiadając różne, niemylące się ze sobą nazwy. Nigdy nie są zgrupowane w “środowiskach”, tylko niezależnie ustawiane dla każdego wdrożenia. Taki model konfiguracji skaluje się bez problemu, nawet jeśli aplikacja będzie potrzebowała w przyszłości więcej zróżnicowanych wdrożeń.\n\n\n\nII. Dependências

Declare e isole explicitamente as dependências

A maioria das linguagens de programação oferecem um sistema de pacotes para a distribuição de bibliotecas de apoio, como o CPAN para Perl ou Rubygems para Ruby. Bibliotecas instaladas por meio de um sistema de pacotes podem ser instaladas em todo o sistema (conhecidas como “site packages”) ou com escopo dentro do diretório contendo a aplicação (conhecidas como “vendoring” ou “building”).

Uma aplicação doze-fatores nunca confia na existência implícita de pacotes em todo o sistema. Ela declara todas as dependências, completa e exatamente, por meio de um manifesto de declaração de dependência. Além disso, ela usa uma ferramenta de isolamento de dependência durante a execução para garantir que não há dependências implícitas “vazamento” a partir do sistema circundante. A completa e explícita especificação de dependências é aplicada de maneira uniforme tanto para produção quanto para desenvolvimento.

Por exemplo, Bundler para Ruby oferece o formato de manifesto Gemfile para declaração de dependência e bundle exec para isolamento das mesmas. Em Python existem duas ferramentas separadas para estas etapas – Pip é utilizado para declaração e Virtualenv para isolamento. Mesmo C tem Autoconf para declaração de dependência, e vinculação estática pode fornecer o isolamento. Não importa qual o conjunto de ferramentas, declaração de dependência e isolamento devem ser sempre usados juntos – apenas um ou o outro não é suficiente para satisfazer doze-fatores.

Um dos beneficios da declaração de dependência explícita é que simplifica a configuração da aplicação para novos desenvolvedores. O novo desenvolvedor pode verificar a base de código do aplicativo em sua máquina de desenvolvimento, exigindo apenas runtime da linguagem e gerenciador de dependência instalado como pré-requisitos. Eles serão capazes de configurar tudo o que é necessário para rodar o código da aplicação com um determinístico comando de build. Por exemplo, o comando de build para Ruby/Bundler é bundle install, enquanto que para Clojure/Leiningen é lein deps.

Aplicações doze-fatores também não contam com a existência implícita de todas as ferramentas do sistema. Exemplos incluem executar algum comando externo como do ImageMagick ou curl. Embora possam existir essas ferramentas em muitos ou mesmo na maioria dos sistemas, não há garantia de que eles vão existir em todos os sistemas em que a aplicação pode rodar no futuro, ou se a versão encontrada em um futuro sistema será compatível com a aplicação. Se a aplicação precisa executar alguma ferramenta do sistema, essa ferramenta deve ser vendorizada na aplicação.\n\n\n\nIII. Configurações

Armazene as configurações no ambiente

A configuração de uma aplicação é tudo o que é provável variar entre deploys (homologação, produção, ambientes de desenvolvimento, etc). Isto inclui:


Recursos para a base de dados, Memcached, e outros serviços de apoio

Credenciais para serviços externos como Amazon S3 ou Twitter

Valores por deploy como o nome canônico do host para o deploy


Aplicações às vezes armazenam as configurações no código como constantes. Isto é uma violação da doze-fatores, a qual exige uma estrita separação entre configuração e código. Configuração varia substancialmente entre deploys, código não.

A prova de fogo para saber se uma aplicação tem todas as configurações corretamente consignadas fora do código é saber se a base de código poderia ter seu código aberto ao público a qualquer momento, sem comprometer as credenciais.

Note que esta definição de “configuração” não inclui configuração interna da aplicação, como config/routes.rb em Rails, ou como módulos de códigos são conectados em Spring. Este tipo de configuração não varia entre deploys, e por isso é melhor que seja feito no código.

Outra abordagem para configuração é o uso de arquivos de configuração que não são versionados no controle de versão, como config/database.yml em Rails. Isto é uma grande melhoria sobre o uso de constantes que são versionadas no repositório do código, mas ainda tem pontos fracos: é fácil de colocar por engano um arquivo de configuração no repositório; há uma tendência para que os arquivos de configuração sejam espelhados em diferentes lugares e diferentes formatos, tornando-se difícil de ver e gerenciar todas as configurações em um só lugar. Além disso estes formatos tendem a ser específicos da linguagem ou framework.

A aplicação doze-fatores armazena configuração em variáveis de ambiente (muitas vezes abreviadas para env vars ou env). Env vars são fáceis de mudar entre deploys sem alterar qualquer código; ao contrário de arquivos de configuração, há pouca chance de serem colocados acidentalmente no repositório do código; e ao contrário dos arquivos de configuração personalizados, ou outros mecanismos de configuração como Propriedades do Sistema Java, eles são por padrão agnósticos a linguagem e ao SO.

Outro aspecto do gerenciamento de configuração é o agrupamento. Às vezes, as aplicações incluem a configuração em grupos nomeados (muitas vezes chamados de ambientes) que remetem a deploys específicos, tais como os ambientes development, test, e production em Rails. Este método não escala de forma limpa: quanto mais deploys da aplicação são criados, novos nomes de ambiente são necessários, tais como staging ou qa. A medida que o projeto cresce ainda mais, desenvolvedores podem adicionar seus próprios ambientes especiais como joes-staging, resultando em uma explosão combinatória de configurações que torna o gerenciamento de deploys da aplicação muito frágil.

Em uma aplicação doze-fatores, env vars são controles granulares, cada um totalmente ortogonal às outras env vars. Elas nunca são agrupadas como “environments”, mas em vez disso são gerenciadas independentemente para cada deploy. Este é um modelo que escala sem problemas à medida que o app naturalmente se expande em muitos deploys durante seu ciclo de vida.\n\n\n\nII. Зависимости

Явно объявляйте и изолируйте зависимости

Большинство языков программирования поставляются вместе с менеджером пакетов для распространения библиотек, таким как CPAN в Perl или Rubygems в Ruby. Библиотеки, устанавливаемые менеджером пакетов, могут быть установлены доступными для всей системы (так называемые “системные пакеты”) или доступными только приложению в директорию содержащую приложение (так называемые “vendoring” и “bundling”).

Приложение двенадцати факторов никогда не зависит от неявно существующих, доступных всей системе пакетов. Приложение объявляет все свои зависимости полностью и точно с помощью манифеста декларации зависимостей. Кроме того, оно использует инструмент изоляции зависимостей во время выполнения для обеспечения того, что неявные зависимости не “просочились” из окружающей системы. Полная и явная спецификация зависимостей применяется равным образом как при разработке, так и при работе приложения.

Например, Bundler в Ruby использует Gemfile как формат манифеста для объявления зависимостей и bundle exec – для изоляции зависимостей. Python имеет два различных инструмента для этих задач: Pip используется для объявления и Virtualenv – для изоляции. Даже C имеет Autoconf для объявления зависимостей, и статическое связывание может обеспечить изоляцию зависимостей. Независимо от того, какой набор инструментов используется, объявление и изоляция зависимостей должны всегда использоваться совместно – только одного из них недостаточно, чтобы удовлетворить двенадцати факторам.

Одним из преимуществ явного объявления зависимостей является то, что это упрощает настройку приложения для новых разработчиков. Новый разработчик может скопировать кодовую базу приложения на свою машину, необходимыми требованиями для которой являются только наличие среды выполнения языка и менеджера пакетов. Всё необходимое для запуска кода приложения может быть настроено с помощью определённой команды настройки. Например, для Ruby/Bundler командой настройки является bundle install, для Clojure/Leiningen это lein deps.

Приложение двенадцати факторов также не полагается на неявное существование любых инструментов системы. Примером является запуск программ ImageMagick и curl. Хотя эти инструменты могут присутствовать во многих или даже в большинстве систем, нет никакой гарантии, что они будут присутствовать на всех системах, где приложение может работать в будущем, или будет ли версия найденная в другой системе совместима с приложением. Если приложению необходимо запустить инструмент системы, то этот инструмент должен быть включён в приложение.\n\n\n\nIII. Конфигурация

Сохраняйте конфигурацию в среде выполнения

Конфигурация приложения – это всё, что может меняться между развёртываниями (среда разработки, промежуточное и рабочее развёртывание). Это включает в себя:


Идентификаторы подключения к ресурсам типа базы данных, кэш-памяти и другим сторонним службам

Регистрационные данные для подключения к внешним сервисам, например, к Amazon S3 или Twitter

Значения зависимые от среды развёртывания такие, как каноническое имя хоста


Иногда приложения хранят конфигурации как константы в коде. Это нарушение методологии двенадцати факторов, которая требует строгого разделения конфигурации и кода. Конфигурация может существенно различаться между развёртываниями, код не должен различаться.

Лакмусовой бумажкой того, правильно ли разделены конфигурация и код приложения, является факт того, что кодовая база приложения может быть в любой момент открыта в свободный доступ без компрометации каких-либо приватных данных.

Обратите внимание, что это определение “конфигурации” не включает внутренние конфигурации приложения, например такие как ‘config/routes.rb’ в Rails, или того как основные модули будут связаны в Spring. Этот тип конфигурации не меняется между развёртываниями и поэтому лучше всего держать его в коде.

Другим подходом к конфигурации является использование конфигурационных файлов, которые не сохраняются в систему контроля версия, например ‘config/database.yml’ в Rails. Это огромное улучшение перед использованием констант, которые сохраняются в коде, но по-прежнему и у этого метода есть недостатки: легко по ошибке сохранить конфигурационный файл в репозиторий; существует тенденция когда конфигурационные файлы разбросаны в разных местах и в разных форматах, из за этого становится трудно просматривать и управлять всеми настройками в одном месте. Кроме того форматы этих файлов, как правило, специфичны для конкретного языка или фреймворка.

Приложение двенадцати факторов хранит конфигурацию в переменных окружения (часто сокращается до env vars или env). Переменные окружения легко изменить между развёртываниями, не изменяя код; в отличие от файлов конфигурации, менее вероятно случайно сохранить их в репозиторий кода; и в отличие от пользовательских конфигурационных файлов или других механизмов конфигурации, таких как Java System Properties, они являются независимым от языка и операционной системы стандартом.

Другим подходом к управлению конфигурациями является группировка. Иногда приложения группируют конфигурации в именованные группы (часто называемые “окружениями”) названые по названию конкретного развёртывания, например как development, test и production окружения в Rails. Этот метод не является достаточно масштабируемым: чем больше различных развёртываний приложения создаётся, тем больше новых имён окружений необходимо, например staging и qa. При дальнейшем росте проекта, разработчики могут добавлять свои собственные специальные окружения, такие как joes-staging, в результате происходит комбинаторный взрыв конфигураций, который делает управление развёртываниями приложения очень хрупким.

В приложении двенадцати факторов переменные окружения являются не связанными между собой средствами управления, где каждая переменная окружения полностью независима от других. Они никогда не группируются вместе в “окружения”, а вместо этого управляются независимо для каждого развёртывания. Эта модель которая масштабируется постепенно вместе с естественным появлением большего количества развёртываний приложения за время его жизни.\n\n\n\nII. Závislosti

Explicitne deklarované a izolované závislosti

Väčšina programovacích jazykov poskytuje distribučný systém knižníc, napríklad CPAN pre Perl alebo Rubygems pre Ruby. Knižnice nainštalované cez balíčkovací systém sa dajú nainštalovať pre celý systém (nazývané “site packages”) alebo len v rámci priečinka s aplikáciou (nazýva sa “vendoring” alebo “bundling”).

Dvanásť faktorová aplikácia sa nikdy nespolieha na implicitnú existenciou systémových balíčkov. Svoje závislosti deklaruje úplne a presne, pomocou deklaráciu závislostí. Ďalej používa nástroj na izoláciu závislostí, pre istotu, aby žiadne implicitné závislosti “nepretiekli” z vonkajšieho systému. Špecifikácia závislostí je úplná a explicitná a používa sa rovnako na produkcii tak aj pri vývoji.

Napríklad, Bundler pre Ruby poskytuje Gemfile manifest format na deklaráciu závislostí a bundle exec na izoláciu závislostí. V pythone sú na to dva rôzne nástroje – Pip sa používa na deklaráciu a Virtualenv na izoláciu. Dokonca aj C má Autoconf na deklaráciu závislostí, a statické linkovanie poskytuje izoláciu závislostí. Nezáleží na nástrojoch, deklarácia závislostí a izolácia sa musia vždy používať spolu – len jedno alebo druhé nestačí na splnenie dvanástich faktorov.

Jednou z výhod explicitnej deklarácie závislosí je to, že zjednodušuje rozbehanie aplikácie pre nových developerov. Nový developer si len naklonuje repozitár aplikácie do svojho vývojárskeho prostredia a ako prerekvizity mu stačí mať nainštalovaný kompilátor jazyka a manažér závislostí. Všetko potrebné na rozbehanie aplikácie sa dotiahne deterministickým build príkazom. Napríklad, build príkaz pre Ruby/Bundler je bundle install, pre Clojure/Leiningen je to lein deps.

Dvanásť faktorová aplikácia nezávisí na implicitnej existencii akéhokoľvek systémového nástroja. Príkladom môže byť spustenie ImageMagick alebo curl cez shell. Napriek tomu, že tieto nástroje môžu existovať na veľa alebo aj väčšine systémov, neexistuje záruka, že budú existovať na všetkých systémoch, na ktorých bude aplikácia bežať v budúcnosti, alebo, že verzia na budúcom systéme bude kompatibilná s aplikáciou. Ak aplikácia potrebuje spúšťať systémový nástroj cez shell, daný nástroj by mal byť zahrnutý do aplikácie.\n\n\n\nIII. Konfigurácia

Konfigurácia uložená v prostredí

Konfigurácia aplikácie je všetko, čo sa líši medzi nasadeniami (staging, produkcia, vývojárske prostredie, atď). To zahŕňa:


Pripojenia k databázam, Memcached a iným podporným službám

Prihlasovacie údaje k externým službám ako Amazon S3 alebo Twitter

Špeciálne hodnotu Per-nasadenie values such ako napríklad kanonické názvy hostov.


Aplikácia si niekedy ukladá konštanty v kóde. Toto je porušenie dvanástich faktorov, ktoré vyžaduje striktné oddelenie konfigurácie od kódu. Konfigurácia sa medzi nasadeniami podstatne odlišuje, kód nie.

Litmusovým testom správneho oddelenia konfigurácie, je to či by mohla byť v ktoromkoľvek momente open-sourcovaná bez úniku prihlasovacích údajov.

Všimnite si, že definícia “konfigurácie” nezahŕňa internú konfiguráciu aplikácie, ako napríklad config/routes.rb v Rails, alebo prepojenie modulov v Spring. Tento typ konfigurácie sa medzi nasadeniami nelíši, a preto je najlepšie ho nechať v kóde.

Ďalšou možnosťou, ako pristupovať ku konfiguráciám je mať konfiguračné súbory, ktoré nie sú uložené v revíznom systéme, ako napríklad config/database.yml v Rails. Je to obrovské zlepšenie oproti konštantám uloženým v repozitári, ale stále má slabosť: je veľmi jednoduché omylom tento súbor uložiť do repozitára; je tendencia mať konfiguračné súbory na rôznych miestach a v rôznych formátoch, a preto je ťažké ich spravovať z jedného miesta. Navyše, tieto formáty zvyknú byť špecifické pre jazyk alebo framework.

Dvanásť faktorová aplikácia konfiguráciu ukladá v premenných prostredia (často skrátané na env vars alebo env). Premenné prostredia sa dajú jednoducho meniť pri nasadeniach bez potreby zmeny v kóde; na rozdiel od konfiguračných súborov je minimálna šanca, že ich niekto omylom uloží do repozitára; a narozdiel od rôznych konfiguračných súborov, alebo iných konfiguračných mechanizmov ako napr. Java System Properties, premenné prostredia sú nezávislé na jazyku alebo OS.

Ďalším pohľadom na správu konfigurácie je zoskupovanie. Niekedy aplikácie zoskupia konfigurácie do pomenovaných skupín (často nazývaných called “prostredia”) a sú pomenované podľa jednotlivých typov nasadení, ako napríklad development, test, a production prostredia v Rails. Tento spôsob je náročné škálovať čistým spôsobom: ako pribúdajú ďalšie typy nasadení, je potrebné vytvárať nové názvy prostredí, ako napríklad staging alebo qa. Ako projekt ďalej rastie, developeri môžu pridávať ďalšie vlastné špeciálne prostredia ako joes-staging, a výsledkom je kombinatorická explózia konfiguračných prostredí a tým sa stáva spravovanie nasadení veľmi citlivé.

V dvanásť faktorovej aplikácii sú premenné prostredia granulárne nastavenia, každé ortogonálne k inej premennej prostredia. Nikdy sa nezoskupujú spolu do pomenovaných “prostredí”, ale namiesto toho sú nezávisle spravované pre každé nasadenie. Tento model sa plynule škáluje počas prirodzeného rastu aplikácie ako pribúdajú ďalšie typy nasadení.\n\n\n\nII. Dependencies

มีการประกาศและแยกการอ้างอิง (dependency) ทั้งหมดอย่างชัดเจน

ภาษาโปรแกรมส่วนใหญ่จะมีระบบ packaging สำหรับรองรับ library ต่างๆ อย่างเช่น CPAN สำหรับ Perl หรือ Rubygems สำหรับ Ruby, Library จะถูกติดตั้งผ่านทางระบบ packaging สามารถติดตั้ง system-wide (เรียกว่า “site packages”) หรือกำหนดขอบเขตเป็นไดเรกทรอรีที่มี app (เรียกว่า “vendoring” หรือ “bundling”)

twelve-factor app ไม่ขึ้นอยู่กับ implicit existence of system-wide packages. โดยประกาศการอ้างอิงทั้งหมด อย่างครบถ้วน และอย่างแน่นอน ด้วย dependency declaration manifest นอกจากนี้ใช้เครื่องมือ dependency isolation ระหว่างทำงานเพื่อให้แน่ใจว่าไม่มีการอ้างอิงแบบปริยาย “รั่ว (leak in)” จากระบบรอบๆ, รายละเอียดการอ้างอิงที่ครบถ้วนและชัดเจนใช้รูปแบบเดียวกันทั้ง production และ development

ตัวอย่างเช่น Bundler สำหรับ Ruby มีรูปบบ Gemfile manifest สำหรับประการการอ้างอิง และ bundle exec สำหรับแยกการอ้างอิง ใน Python มีเครื่องมือ 2 ตัวสำหรับแต่ละขั้นตอน – Pip ใช้สำหรับประกาศอ้างอิง และ Virtualenv สำหรับแยกการอ้างอิง แม้อย่าง C มี Autoconf สำหรับประการการอ้างอิง และ static linking สามารถทำแยกการอ้างอิงได้ ไม่ว่าจะใช้เครื่องมืออะไรก็ตามแต่การประการศและแยกการอ้างอิงจำเป็นเสมอที่ใช้ร่วมกัน – ถ้ามีเพียงหนึ่งหรืออื่นๆ ไม่เพียงพอที่ตรงตาม twelve-factor

ประโยชน์อย่างหนึ่งของการประกาศการอ้างอิงที่ชัดเจนคือลดความยุ่งยากในการติดตั้งสำหรับ developer ใหม่สำหรับ app, developer ใหม่สามารถ check out codebase ของ app มายังเครื่องที่ใช้ development ต้องการเพียงแค่ติดตั้ง language runtime และ dependency manager เป็นข้อกำหนดเบื้องต้น พวกเขาจะสามามารถติดตั้งทุกสิ่งที่ต้องการเพื่อจะรัน code ของ app ด้วย build command ตัวอย่างเช่น ใช้ build command สำหรับ Ruby/Bundler คือ bundle install ขณะที่ Clojure/Leiningen คือ lein deps

Twelve-factor app ยังคงไม่ขึ้นอยู่กับเครื่องมือที่มีอยู่แล้ว ตัวอย่างเช่นใช้ shell out ไปยัง ImageMagick หรือ curl ขณะที่เครื่องมือเหล่านี้อาจจะมีอยู่บนระบบส่วนใหญ่แล้ว ซึ่งจะไม่รับประกันว่าจะมีอยู่บนเครื่องทั้งหมดซึ่ง app จะทำงานในอนาคต หรือ version ที่หาเจอในเครื่องที่จะไปทำงานในอนาคตจะเข้ากันได้กับ app ถ้า app จำเป็น shell out ใช้เครื่องมือของเครื่อง ที่เครื่องมืออาจจะ vendord ให้ app\n\n\n\nIII. Config

จัดเก็บการตั้งค่า (config) ไว้ในสิ่งแวดล้อมของระบบ

การตั้งค่า (config) ของ app เป็นสิ่งที่เปลี่ยนแปลงระหว่าง deploys (staging, production, developer environments เป็นต้น) รวมทั้ง:


ทรัพยากรที่จัดการกับฐานข้อมูล, Memcached, และ backing services อื่นๆ

ข้อมูลประจำตัว (credentials) สำหรับบริการภายนอก อย่างเช่น Amazon S3 หรือ Twitter

ค่า Pre-deploy อย่างเช่น canonical hostname สำหรับ deploy


บางครั้ง app เก็บการตั้งค่าเป็นค่าคงทีใน code เป็นการละเมิด twelve-factor ซึ่งต้องการให้ แยกการตั้งค่าออกจาก code อย่างสมบูรณ์ การตั้งค่าสามารถเปลี่ยนแปลงได้ตาม deploy ที่ไม่อยู่ใน code

การทดสอบ litmus เพื่อดูว่า app มีการเอาการตั้งค่าทั้งหมดออกจาก code ถูกต้องหรือไม่ ทำให้ codebase สามารถ open source ได้ตลอดเวลา โดยไม่กระทบกับ credential ใดๆ

โปรดทราบว่าการนิยามนี้ของ “การตั้งค่า” ไม่รวมการตั้งค่า internal application อย่างเช่น config/routes.rb ใน Rails หรือ code modules เชื่อมต่อกันอย่างไร ใน Spring ชนิดของการตั้งค่าเหล่านี้ไม่เปลี่ยนแปลงตาม deploy และควรจะอยู่ใน code

อีกวิธีการหนึ่งของการตั้งค่าคือการใช้ไฟล์การตั้งค่าซึ่งไม่รวมไว้ใน revision control อย่างเช่น config/database.yml ใน Reals ซึ่งเป็นการพัฒนาสำหรับการใช้ค่าคงที่ซึ่งถูกรวมเข้าไปใน code repo แต่ก็ยังมีจุดอ่อนคือมันจะเกิดความผิดพลาดจากการที่รวมค่าการตั้งค่านี้เข้าไปใน repo จะทำให้มีแนวโน้มที่การไฟล์การตั้งค่าจะกระจายอยู่ในที่แตกต่างกันและแตกต่างรูปแบบ ทำให้มันยากที่จะดูแลและจัดการการตั้งค่าทั้งหมดในหนึ่งที่ นอกจากนี้รูปแบบเหล่านี้ยังขึ้นอยู่กับภาษาคอมพิวเตอร์ หรือ เฉพาะ framework.

Twelve-factor app เก็บการตั้งค่าไว้ใน environment variable (เรียกสั้นๆ ว่า env vars หรือ env) Env vars จะทำให้ง่ายที่จะเปลี่ยนแปลงระหว่าง deloy โดยปราศจากการเปลี่ยนแปลงของ code ใดๆ ไม่เหมือนกับไฟล์การตั้งค่าที่จะมีโอการผิดพลาดที่จะรวมเข้าไปใน code repo ได้ และไม่เหมือนกับไฟล์การตั้งค่าที่กำหนดเองหรือกลไกการตั้งค่าอื่นๆ อย่างเช่น Java System Properties ที่เป็ของภาษาคอมพิวเตอร์ และมาตรฐานของระบบปฏิบัติการ (OS-agnostic)

อีกแง่มุมของการจัดการการตั้งค่าคือการจัดกลุ่ม (Grouping) บางครั้งการตั้งค่า app แบบกลุ่ม (batch) ในชื่อของกลุ่ม (เรียกว่า “environment”) หลังจาก deploy เฉพาะ อย่างเช่น development, test และ production environment ใน Rails วิธีการนี้ทำให้การขยายไม่เรียบร้อยทำให้มี deploy ของ app ถูกสร้างมากขึ้น, จำเป็นต้องตั้งชื่อของ environment ใหม่ อย่างเช่น staging หรือ qa เป็นตั้น เมื่อ project โตขึ้น developer อาจจะเพิ่ม environments เฉพาะของตัวเองขึ้นมา เช่น joes-staging ผมก็คือมีการตั้งค่าจำนวนมากเกินไปซึ่งทำให้จัดการ deploy ของ app ทำได้ยากมาก

ใน twelve-factor app, env vars เป็นรากฐานการควบควมของแต่ล่ะ evn vars อื่นๆ ไม่เคยมีการจัดกลุ่มเป็น “environments” แต่จะจัดการแบบอิสระสำหรับแต่ล่ะ deploy แทน นี่เป็นรูปแบบที่การขยายทำได้อย่างราบรื่นของ app เป็นการขยายโดยธรรมชาติของ deploy มากขึ้นตลอดอายุการทำงานของ app.\n\n\n\nII. Bağımlıklar

Bağımlılıkların açıkça tanımlanması ve izole edilmesi

Çoğu programlama dili destek kütüphanelerini dağıtmak için bir paketleme sistemi sunar. Mesela Perl için CPAN, Ruby için Rubygems. Bir paketleme sistemi aracılığıyla yüklenen kütüphaneler, sistem genelinde (“site paketleri” olarak bilinir) yüklenebilir veya uygulamanın bulunduğu dizine (“sağlayıcı” veya “paketleme” olarak bilinir) dahil edilebilir.

On iki faktör bir uygulama asla bir sistem geneli paketin yüklü olduğunu varsaymaz. Bir bağımlılık bildirimi manifestosu ile tüm bağımlılıkları tam ve eksiksiz olarak bildirir. Üstelik bağımlılıkların çevredeki sistemden sızmamasını sağlamak için çalıştırma sırasında bir bağımlılık yalıtım aracı kullanılır. Tam ve açık bağımlılık belirtimi hem canlı yayın hem de geliştirme için eşit olarak uygulanmaktadır.

Örneğin, Ruby’nin Bundler‘ı, bağımlılık bildirimi için Gemfile manifesto formatını ve bağımlılık yalıtımı için bundle exec’i sunar. Python’da bu adımlar için iki ayrı araç bulunur: Pip bildirimde, Virtualenv de yalıtımda kullanılır. C bile bağımlılık bildirimi için Autoconf’a sahiptir ve bağımlılık yalıtımı statik link ile sağlanır. Ne olursa olsun birbiriyle uyumlu çalışan yazılım uygulaması, bağımlılık bildirimi ve bağımlılık yalıtımı birlikte kullanılmalıdır, sadece birinin olması on iki faktör için yeterli değildir.

Açık bağımlılık bildiriminin bir faydası da uygulamaya yeni katılan geliştiriciler için kurulumu kolaylaştırmasıdır. Yeni geliştirici bilgisayarında yalnızca programlama dilini ve bağımlılık yöneticisine sahip olarak uygulamanın kod tabanını indirebilir. Uygulamanın içindeki önceden belirlenmiş bir derleme komutu uygulama kodunun çalışması için ihtiyaç duyulan her şeyi yükleyebilecektir. Örneğin bu komut Clojure/Leiningen için lein deps iken, Ruby/Bundler için bundle install‘dur.

On iki faktör uygulamaları herhangi bir sistem aracının yüklü olduğunu varsaymaz. Örnekler ImageMagick yada curl kullanımını içerir. Bu araçlar çoğu sistemde var olabilse de, uygulamanın gelecekte çalışabileceği sistemlerde bu araçların var olup olmayacağının veya bu araçların sürümlerinin uygulamayla uyumlu olup olmayacağının garantisi yoktur. Uygulamanın bir sistem aracına ihtiyacı oluşuyorsa, o aracın uygulamanın içine dahil edilmesi gerekir.\n\n\n\nIII. Yapılandırma

Yapılandırma ayarlarını ortam değişkeni saklama

Bir uygulamanın yapılandırma ayarları dağıtımlar arasında farklı olma ihtimali olan her şeydir. Örneğin:


Veritabanlarının, önbellekleme servislerinin ve diğer yardımcı servislerin erişim bilgileri

Amazon S3 ve Twitter gibi dış servisler için kimlik bilgileri

Dağıtımlar için standart sunucu ismi gibi dağıtım-öncesi değerler


Uygulamalar bazen yapılandırma ayarlarını kod içerisinde saklar. Bu on iki faktörün, yapılandırmayı koddan mutlak ayrımını gerektiren kuralın ihlalidir. Yapılandırma ayarları dağıtımlar arasında değişir, ama kod değişmez.

Bir uygulamanın herhangi bir kimlik bilgisinin gizliliğini ihlal etmeden açık kaynak yapılabilip yapılamayacak olması, tüm yapılandırmaları koddan doğru bir biçimde çıkarılıp çıkarılmadığını belirleyebilecek bir litmus testidir.

Bu yapılandırma ayarı tanımının, Spring‘de kod modüllerinin bağlantısında olduğu gibi ve Rails’deki config/routes.rb gibi dahili uygulama yapılandırmasını içermediğini unutmayın. Bu tip yapılandırmalar, dağıtımlar arasında değişiklik göstermeyeceği için, kod içinde gerçekleştirilmeleri mantıklıdır.

Yapılandırmaya diğer bir yaklaşım da Rails’deki config/database.yml gibi dosyaların versiyon kontrol sistemine dahil edilmeden kullanımıdır. Bu, kod deposuna dahil edilmiş sabitler kullanmaya göre büyük bir gelişimdir, fakat hala zayıflıkları vardır: Bu dosyaların yanlışlıkla versiyon kontrol sistemine dahil edilme olasılığı oldukça yüksektir. Yapılandırma dosyalarının farklı yerlerde ve farklı formatlarda dağılmış olması eğilimi mevcuttur, ve bu durum bütün yapılandırmayı bir yerde görmeyi ve yönetmeyi zorlaştırır. Dahası, bu formatlar genelde dil veya çatı için özelleşmiştir.

On iki faktör uygulamalarında yapılandırma ortam değişkenlerinde kaydedilir (sıklıkla env vars veya env olarak kısaltılır). Ortam değişkenleri herhangi bir kod değişikliği olmadan, dağıtımlar arasında kolay değişebilir; Yapılandırma dosyalarının aksine, kod deposuna yanlışlıkla dahil edilme ihtimali düşüktür; ve özel yapılandırma dosyalarının veya Java sistem özellikleri gibi yapılandırma mekanizmalarının aksine, onlar dil ve işletim sisteminden etkilenmez.

Yapılandırma yönetiminin diğer bir açısı da gruplandırmadır. Bazen uygulamalar, Rails’deki geliştirme, test ve canlı ortamları gibi belirli dağıtımlardan sonra adlandırılmış gruplar içinde yapılandırılır. Bu yöntem temiz bir şekilde ölçeklenemez. Çünkü uygulamanın daha fazla dağıtımı oluştukça, yeni ortam isimleri gerekli olur, staging veya qa gibi. Projeler ilerde geliştikçe, geliştiriciler joes-staging kendi özel ortam değişkenlerini ekleyebilir. Bu da yapılandırma dosyalarının hızla artmasıyla sonuçlanarak dağıtım yönetimini oldukça kırılganlaştırır.

On iki faktör uygulamasında ortam değişkenleri parçacıklı kontrol edilirler, birbirlerinden bağımsızlardır. Asla gruplandırılmazlar, onun yerine her bir dağıtım için bağımsız olarak yönetilirler. Bu, uygulamayı yaşam süresi boyunca daha fazla dağıtıma genişletmeyi sorunsuzca ölçeklendiren bir modeldir.\n\n\n\nII. Залежності

Явно оголошуйте та ізолюйте залежності

Більшість мов програмування мають системи пакунків для розповсюдження бібліотек, такі як CPAN для Perl або Rubygems для Ruby. Бібліотеки, встановлені через систему пакунків, можуть бути доступними для всієї системи (так звані “site-packages”) або встановлені в каталог застосунку (так звані “vendoring” або “bundling”).

Застосунок дванадцяти факторів ніколи не залежить від неявно існуючих, досупних всій системі пакунків. Застосунок повно і точно вказує всі свої залежності за допомогою маніфесту оголошення залежностей. Крім того, він використовує інструмент ізоляції залежністей під час виконання, щоб гарантувати, що ніякі неявні залежності не “просочилися” з зовнішньої системи. Повна і явна специфікація залежностей використовується однаково як при розробці, так і в production.

Наприклад, Bundler в Ruby використовує Gemfile як формат маніфесту для оголошення залежностей і bundle exec для ізоляції залежностей. В Python є два окремі інструменти для цих задач - Pip використовується для оголошення і Virtualenv для ізоляції. Навіть C має Autoconf для оголошення залежностей, а статичне зв’язування може забезпечити ізоляцію залежностей. Який би не використовувався набір інструментів, оголошення і ізоляція залежностей завжди мають використовуватися разом — тільки одне або інше не є достатньою умовою для задоволення дванадцяти факторів.

Однією з переваг явного оголошення залежностей є те, що це спрощує налаштування застосунку для нових розробників. Новий розробник може скопіювати кодову базу застосунку на свою машину, необхідними вимогами для якої є тільки наявність середовища виконання мови програмування та наявність менеджера залежностей. Все необхідне для запуску коду застосунку може бути налаштоване за допомогою визначеної команди збірки. Наприклад, команда збірки для Ruby/Bundler є bundle install, а для Clojure/Leiningen це lein deps.

Застосунок дванадцяти факторів також ніколи не залежить від неявно існуючих будь-яких системних інструментів. Прикладом може бути запуск застосунком таких системних інструментів, як ImageMagick або curl. У той час, як ці інструменти можуть бути встановлені на багатьох або навіть більшості систем, немає жодної гарантії, що вони будуть встановлені на всіх системах, де застосунок може запускатися в майбутньому, або версія інструменту, встановлена в системі, буде сумісна з застосунком. Якщо застосунку потрібно запускати певні системні інструменти, то такі інструменти мають бути включені в сам застосунок.\n\n\n\nIII. Конфігурація

Зберігайте конфігурацію в середовищі виконання

Конфігурація застосунку — це все, що може змінюватися між розгортаннями (staging-розгортання, production-розгортання, локальне середовище розробника тощо). Це включає:


Параметри підключення до бази даних, Memcached і інших сторонніх сервісів;

Реєстраційні дані для підключення до зовнішніх сервісів, таких як Amazon S3 або Twitter;

Значення, що залежать від середовища розгортання, такі як канонічне ім’я хосту.


Застосунки іноді зберігають конфігурації як константи в коді. Це є порушенням методології дванадцяти факторів, яка вимагає обов’язкового відокремлення конфігурації від коду. Конфігурації застосунку в розгортаннях суттєво відрізняються, код — однаковий.

Лакмусовим папірцем того, чи правильно розділені конфігурація і код, є можливість в будь-який момент відкрити вихідний код застосунку у вільний доступ, при цьому не оприлюднюючи будь-яких приватних даних.

Зверніть увагу, що визначення “конфігурації” не включає в себе внутрішні налаштування застосунку, такі як сonfig/routes.rb в Rails, або як пов’язані основні модулі в Spring. Ці налаштування не змінюються між розгортаннями, і тому краще місце для них — саме в коді.

Іншим підходом до конфігурації є використання конфігураційних файлів, що не зберігаються в систему контролю версій, таких як сonfig/database.yml в Rails. Це перевага у порівнянні з використанням констант в коді, але все ж таки має суттєві недоліки: є ймовірність помилково зберегти файл конфігурації в репозиторій; існує тенденція коли конфігураційні файли розкидані в різних місцях і в різних форматах, і стає важко передивлятися всі налаштування і керувати ними в одному місці. Крім того, формати цих файлів, як правило, специфічні для конкретної мови програмування чи фреймворку.

Застосунок дванадцати факторів зберігає конфігурацію в змінних оточення (часто скорочується до env vars або env). Значення змінних оточення легко змінити між розгортаннями без зміни коду; на відміну від конфігураційних файлів, менш ймовірно випадково зберегти їх в репозиторій коду; і на відміну від конфігураційних файлів або інших механізмів конфігурації, таких як Java System Properties, вони є стандартом, незалежним від мови програмування чи фреймворку.

Іншим аспектом керування конфігурацією є групування. Іноді застосунки об’єднують конфігурації в іменовані групи (які часто називаються “оточеннями”), які називаються в залежності від конкретного розгортання, наприклад, development, test і production оточення в Rails. Цей метод погано масштабується: чим більше створюється різних розгортань застосунку, тим більше необхідно нових імен оточень, наприклад, staging або qa. При подальшому рості проекту розробники можуть додавати свої власні спеціальні оточення, наприклад, joes-staging, що призводить до комбінаторного вибуху конфігурації, який робить керування розгортанням застосунку нестабільним.

У застосунку дванадцяти факторів змінні оточення є незв’язаними між собою засобами керування. Кожна змінна повністю незалежна від інших. Вони ніколи не групуються разом в “оточення”, керування ними здійснюється незалежно для кожного розгортання. Ця модель добре масштабується разом з появою більшої кількості розгортань застосунку протягом його експлуатації.\n\n\n\nII. Các phụ thuộc

Khai báo rõ ràng và phân tách các phụ thuộc

Hầu hết các ngôn ngữ lập trình đều cung cấp hệ thống gói để phân phối các gói thư viện hỗ trợ, ví dụ như CPAN cho Perl hay Rubygems cho Ruby. Các thư viện cài đặt thông qua một hệ thống gói có thể được cài đặt ở mức phủ hệ thống (được biết đến với thuật ngữ “site packages”) hay được nhóm và trong một thư mục có kèm ứng dụng (được biết đến với thuật ngữ “vendoring” hay “bundling”).

Một ứng dụng 12-hệ số không bao giờ phụ thuộc vào sự hiện diện tuyệt đối của các gói hệ thống. Nó khai báo toàn bộ các phụ thuộc hoàn toàn thông qua bản kê khai khai báo phụ thuộc. Hơn thế nữa nó còn sử dụng công cụ phân cách phụ thuộc trong quá trình thực thi để đảm bảo rằng không có các phụ thuộc tuyệt đối nào bị “lọt” vào trong các hệ thống xung quanh. Khai báo đầy đủ và rõ ràng các phụ thuộc được áp dụng đồng đều cho cả hệ thống sản xuất và phát triển.

Lấy ví dụ Gem Bundler của Ruby cung cấp định dạng kê khai Gemfile để khai báo phụ thuộc và bundle exec để phân cách phụ thuộc. Với Python thì có công cụ riêng biệt cho các bước trên – Pip được dùng để khai báo Virtualenv để phân cách. Ngay cả C có Autoconf để khai báo phụ thuộc, và liên kết tĩnh (static linking) có thể cung cấp phân cách phụ thuộc. Bất kể công cụ gì, kê khai phụ thuộc và phân cách luôn phải đi đôi với nhau – chỉ cần thiếu một trong hai là không đạt yêu câu của của 12-hệ số.

Một ích lợi khác của khai báo phụ thuộc rõ ràng là nó đơn giản hoá quá trình cài đặt cho lập trình viên mới tiếp nhận dự án. Các lập trình viên mới có thể lấy về mã trên hệ thống phát triển của họ, chỉ với một yêu cầu là cài đặt trước ngôn ngữ lập trình và trình quản lý phụ thuộc. Chúng có thể được dùng để thiết lập mọi thứ cần để vận hành một ứng dụng với một lệnh biên dịch/xây dựng định sẵn. Lấy một ví dụ cụ thể là lệnh thiết lập cho Ruby/Bundler là bundle install, còn với Clojure/Leiningen là lein deps.

Các ứng dụng 12-hệ số đông thời có thể không phụ thuộc vào bất cứ sự hiện diện của các công cụ hệ thống tuyệt đối nào. Các ví dụ bao gồm các công cụ cài đặt sẵn như ImageMagick hay curl. Trong khi các công cụ trên có thể hiện diện trên đa số các hệ thống, nhưng không có gì bảo đảm là chúng sẽ hiện diện trên toàn bộ các hệ thống mà ứng dụng có thể chạy trong tương la, hoặc có chăng phiên bản tìm thấy trên các hệ thống tương lai sẽ tương thích với ứng dụng. Nếu ứng dụng cần được cài sẵn như một công cụ hệ thống, các công cụ đó nên được đi kèm cùng với ứng dụng.\n\n\n\nIII. Cấu hình

Lưu trữ cấu hình trong môi trường

Cấu hình của ứng dụng là những thứ có thể thay đổi qua các triển khai (hệ thống thử, hệ thống sản xuất, môi trường phát triển, etc). Nó bao gồm: * Tài nguyên xử lý cơ sở dữ liệu, Memcached, và dịch vụ lớp dưới khác * Thông tin đăng nhập đến các dịch vụ như là Amazon S3 hay Twitter * Các giá trị ứng với từng triển khai như như là tên của máy chủ để triển khai

Các ứng dụng thường lưu trữ các cấu hình như là hằng số trong mã nguồn. Điều này không phù hợp với nguyên tắc của 12-thừa số, yêu cầu giới hạn tách biệt các cấu hình khỏi mã nguồn. Các cấu hình thay đổi qua các triển khai, mã nguồn thì không.

Một litmus test cho ứng dụng có các cấu hình được thừa số hoá chính xác là mã gốc có khả năng nguồn mở hoá bất kỳ lúc nào mà không lo sợ bị mất các thông tin đăng nhập.

Chú ý rằng, định nghĩa của “cấu hình” không bao gồm các cấu hình nội tại của ứng dụng, như là config/routes.rb trong Rails, hoặc các thành phần được kết nối trong Spring. Những cấu hình kiểu này thường không thay đổi giữa các triển khai, và do đó đã thực hiện tốt trong mã nguồn.

Một cách tiếp cận khác với các cấu hình là việc sử dụng tệp tin cấu hình mà tệp tin đó không được quản lý phiên bản, như là config/database.yml trong Rails. Đây là một cải tiến lớn so với việc sử dụng hằng số trong mã nguồn đã được quản lý phiên bản, nhưng vẫn có điểm yếu: dễ bị thêm nhầm vào quản lý phiên bản, các tệp tin cấu hình dễ bị phân tán ở những nơi khác nhau và các định dạng khác nhau, làm cho nó trở nên khó đọc và quản lý tất các cấu hỉnh một cách tập trung. Ngoài ra, định dạng của các tệp tin chứa cấu hình thường do đặc tả của ngôn ngữ- hoặc framework-.

Ứng dụng áp dụng mười hai thừa số chứa các cấu hình trong environment variables (biến môi trường) (thường viết tắt là env vars hoặc env). Các biến môi trường rất dễ để thay đổi giữa các triển khai mà không phải thay đổi mã nguồn; không giống như tệp tin cấu hình, vẫn có khả năng để bị thêm vào kho mã (code repository); và không giống như các tệp tin cấu hình tuỳ chỉnh, hoặc cơ chế quảnl lý cấu hình như là Java System Properties, các biến môi trường là agnostic standard theo ngôn ngữ và hệ điều hành.

Một khía cạnh khác của quản lý cấu hình là nhóm các cấu hình. Đôi khi, các ứng dụng tổ chức các cấu hình theo nhóm (thường được gọi là “các môi trường”) được đặt tên theo các triển khai, như là các môi trườngdevelopment, test, and production trong Rails. Phương pháp này không mở rộng rõ ràng: nếu như có nhiều triển khải của ứng dụng được tạo ra, tên của các môi trường rất quan trọng, như là staging hoặc qa. Nếu một dự án phát triển sau này, lập trình viên có thể thêm các môi trường của riêng họ như là joes-staging, kết quả là một sự bùng nổ về các cấu hình, làm cho việc quản lý các triển khai trở nên không ổn định.

Trong một ứng dụng áp dụng mười hai thừa số, các biến môi trường được quản lý chi tiết, hoàn toàn độc lập với các biến môi trường khác. Chúng không được nhóm với nhau như là các “môi trường”, nhưng thay vào đó được quản lý độc lập theo các triển khai. Mô hình này giúp cho việc mở rộng trở nên trơn tru như là việc thêm vào các triển khai theo vòng đời của phần mềm được mở rộng một cách tự nhiên.\n\n\n\nII. 依赖

显式声明依赖关系（ dependency ）

大多数编程语言都会提供一个打包系统，用来为各个类库提供打包服务，就像 Perl 的 CPAN 或是 Ruby 的 Rubygems 。通过打包系统安装的类库可以是系统级的（称之为 “site packages”），或仅供某个应用程序使用，部署在相应的目录中（称之为 “vendoring” 或 “bundling”）。

12-Factor规则下的应用程序不会隐式依赖系统级的类库。 它一定通过 依赖清单 ，确切地声明所有依赖项。此外，在运行过程中通过 依赖隔离 工具来确保程序不会调用系统中存在但清单中未声明的依赖项。这一做法会统一应用到生产和开发环境。

例如， Ruby 的 Bundler 使用 Gemfile 作为依赖项声明清单，使用 bundle exec 来进行依赖隔离。Python 中则可分别使用两种工具 – Pip 用作依赖声明， Virtualenv 用作依赖隔离。甚至 C 语言也有类似工具， Autoconf 用作依赖声明，静态链接库用作依赖隔离。无论用什么工具，依赖声明和依赖隔离必须一起使用，否则无法满足 12-Factor 规范。

显式声明依赖的优点之一是为新进开发者简化了环境配置流程。新进开发者可以检出应用程序的基准代码，安装编程语言环境和它对应的依赖管理工具，只需通过一个 构建命令 来安装所有的依赖项，即可开始工作。例如，Ruby/Bundler 下使用 bundle install，而 Clojure/Leiningen 则是 lein deps。

12-Factor 应用同样不会隐式依赖某些系统工具，如 ImageMagick 或是curl。即使这些工具存在于几乎所有系统，但终究无法保证所有未来的系统都能支持应用顺利运行，或是能够和应用兼容。如果应用必须使用到某些系统工具，那么这些工具应该被包含在应用之中。\n\n\n\nIII. 配置

在环境中存储配置

通常，应用的 配置 在不同 部署 (预发布、生产环境、开发环境等等)间会有很大差异。这其中包括：


数据库，Memcached，以及其他 后端服务 的配置

第三方服务的证书，如 Amazon S3、Twitter 等

每份部署特有的配置，如域名等


有些应用在代码中使用常量保存配置，这与 12-Factor 所要求的代码和配置严格分离显然大相径庭。配置文件在各部署间存在大幅差异，代码却完全一致。

判断一个应用是否正确地将配置排除在代码之外，一个简单的方法是看该应用的基准代码是否可以立刻开源，而不用担心会暴露任何敏感的信息。

需要指出的是，这里定义的“配置”并不包括应用的内部配置，比如 Rails 的 config/routes.rb，或是使用 Spring 时 代码模块间的依赖注入关系 。这类配置在不同部署间不存在差异，所以应该写入代码。

另外一个解决方法是使用配置文件，但不把它们纳入版本控制系统，就像 Rails 的 config/database.yml 。这相对于在代码中使用常量已经是长足进步，但仍然有缺点：总是会不小心将配置文件签入了代码库；配置文件的可能会分散在不同的目录，并有着不同的格式，这让找出一个地方来统一管理所有配置变的不太现实。更糟的是，这些格式通常是语言或框架特定的。

12-Factor推荐将应用的配置存储于 环境变量 中（ env vars, env ）。环境变量可以非常方便地在不同的部署间做修改，却不动一行代码；与配置文件不同，不小心把它们签入代码库的概率微乎其微；与一些传统的解决配置问题的机制（比如 Java 的属性配置文件）相比，环境变量与语言和系统无关。

配置管理的另一个方面是分组。有时应用会将配置按照特定部署进行分组（或叫做“环境”），例如Rails中的 development,test, 和 production 环境。这种方法无法轻易扩展：更多部署意味着更多新的环境，例如 staging 或 qa 。 随着项目的不断深入，开发人员可能还会添加他们自己的环境，比如 joes-staging ，这将导致各种配置组合的激增，从而给管理部署增加了很多不确定因素。

12-Factor 应用中，环境变量的粒度要足够小，且相对独立。它们永远也不会组合成一个所谓的“环境”，而是独立存在于每个部署之中。当应用程序不断扩展，需要更多种类的部署时，这种配置管理方式能够做到平滑过渡。\n\n\n\nII. Dependencies

Explicitly declare and isolate dependencies

Most programming languages offer a packaging system for distributing support libraries, such as CPAN for Perl or Rubygems for Ruby. Libraries installed through a packaging system can be installed system-wide (known as “site packages”) or scoped into the directory containing the app (known as “vendoring” or “bundling”).

A twelve-factor app never relies on implicit existence of system-wide packages. It declares all dependencies, completely and exactly, via a dependency declaration manifest. Furthermore, it uses a dependency isolation tool during execution to ensure that no implicit dependencies “leak in” from the surrounding system. The full and explicit dependency specification is applied uniformly to both production and development.

For example, Bundler for Ruby offers the Gemfile manifest format for dependency declaration and bundle exec for dependency isolation. In Python there are two separate tools for these steps – Pip is used for declaration and Virtualenv for isolation. Even C has Autoconf for dependency declaration, and static linking can provide dependency isolation. No matter what the toolchain, dependency declaration and isolation must always be used together – only one or the other is not sufficient to satisfy twelve-factor.

One benefit of explicit dependency declaration is that it simplifies setup for developers new to the app. The new developer can check out the app’s codebase onto their development machine, requiring only the language runtime and dependency manager installed as prerequisites. They will be able to set up everything needed to run the app’s code with a deterministic build command. For example, the build command for Ruby/Bundler is bundle install, while for Clojure/Leiningen it is lein deps.

Twelve-factor apps also do not rely on the implicit existence of any system tools. Examples include shelling out to ImageMagick or curl. While these tools may exist on many or even most systems, there is no guarantee that they will exist on all systems where the app may run in the future, or whether the version found on a future system will be compatible with the app. If the app needs to shell out to a system tool, that tool should be vendored into the app.\n\n\n\nV. Sestavení, vydání, spuštění

Striktně oddělte fáze sestavení, vydání a spuštění.

Zdrojový kód je transformován do (nevývojářského) nasazení ve třech fázích:


Fáze sestavení (build) je transformace, která převede zdrojový kód do spustitelného balíčku zvaného sestavení. Z verze kódu v čase příslušného commitu a dle postupu nasazení, dojde ve fázi sestavení ke stažení závislostí, zkompilování binárek a připojení assetů.

Fáze vydání (release) vezme sestavení vytvořené v předchozím kroku a zkombinuje ho konfigurací pro dané nasazení. Výsledná kombinace je vydáním, které je připravené k okamžitému spuštění v běhovém prostředí.

Fáze spuštění (run) (známá též jako “runtime”) spustí aplikaci v běhovém prostředí nastartováním aplikačních procesů oproti danému vydání.




Twelve-factor aplikace striktně rozlišují mezi fází sestavení, vydání a spuštění. Je například nemožné provedět změny ve spuštěném kódu, protože není cesty, jak tyto změny propagovat zpět do fáze sestavení.

Nástroje pro nasazení obvykle poskytují i správu vydání a zejména pak schopnost vrátit se zpět k předchozímu vydání. Například nástroj Capistrano si ukládá nasazení v podadresáři zvaném releases a aktuální vydání je pak symlink na příslušný adresář s aktuální verzí. Příkaz rollback pak velmi snadno zajistí návrat k předchozímu vydání.

Každé vydaní by mělo mít vždy unikátní ID, jako je například časová značka ( 2011-04-06-20:32:17) nebo inkrementální číslo (například v100). Vydání již nelze po vytvoření jakkoliv upravovat, libovolná změna musí vždy vytvořit nové vydání.

Sestavení iniciují vývojáři aplikace, kdykoliv se nasazuje nový kód. Naopak ke spuštění v běhovém prostředí může dojít automaticky v případě restartu serveru nebo restartem havarovaného procesu pomocí správce procesů. Proto by měla mít fáze spuštění co nejméně pohyblivých částí, jelikož problémy bránící aplikaci v běhu mohou nastat uprostřed noci, kdy nejsou žádní vývojáři k dispozici. Fáze sestavení pak může být složitější, protože chyby jsou více na očích pro vývojáře kontrolující nasazení aplikace.\n\n\n\nV. Build, release, run

Build- und Run-Phase strikt trennen

Eine Codebase wird durch drei Phasen in einen (Nicht-Entwicklungs)-Deploy transformiert:



Die Build-Phase ist eine Transformation, die ein Code-Repository in ein ausführbarers Code-Bündel übersetzt, das man auch Build nennt. Ausgehend von einer Code-Version eines Commits, der im Deployment-Prozess festgelegt wurde, holt sie Abhängigkeiten, verpackt sie zum Mitliefern, und kompiliert Binaries und Assets.



Die Release-Phase übernimmt den Build von der Build-Phase und kombiniert ihn mit der zum Deploy passenden Konfiguration. Der so erzeugte Release enthält sowohl den Build, als auch die Konfiguration und kann direkt in einer Ausführungsumgebung ausgeführt werden.



Die Run-Phase (auch “Laufzeit” genannt) führt die App in einer Ausführungsumgebung aus, indem sie eine Menge der Prozesse der App gegen einen ausgewählten Release ausführt. 



Die Zwölf-Faktor-App trennt strikt zwischen Build-, Release- und Run-Phase. Es ist nicht möglich, Code-Änderungen zur Laufzeit zu machen, weil es keinen Weg gibt, diese Änderungen zurück in die Build-Phase zu schicken.

Deployment-Werkzeuge bieten meist eine Release-Verwaltung an. Am bekanntesten ist die Funktion auf einen früheren Release zurückzusetzen. Zum Beispiel speichert das Deployment-Werkzeug Capistrano Releases in einem Unterverzeichnis mit Namen releases. Der aktuelle Release ist ein symbolischer Link auf aktuelle Release-Verzeichnis. Mit dem Kommando rollback kann einfach und schnell auf einen früheren Release zurückgesetzt werden.

Jeder Release sollte eine eindeutige Release-ID haben, wie zum Beispiel einen Zeitstempel des Releases (2011-04-06-20:32:17) oder eine laufende Nummer (v100). Releases werden nie gelöscht und ein Release kann nicht verändert werden, wenn er einmal angelegt ist. Jede Änderung erzeugt einen neuen Release.

Builds werden durch die Entwickler der App angestoßen, wenn neuer Code deployt wird. Im Gegensatz dazu kann die Ausführung zur Laufzeit automatisch erfolgen, wenn ein Server neu gebootet wird oder ein abgestürzter Prozess von der Prozessverwaltung neu gestartet wird. Deswegen sollte die Run-Phase auf so wenig bewegliche Teile wie möglich beschränkt sein, denn Probleme, die eine App vom Laufen abhalten, können sie mitten in der Nacht zusammenbrechen lassen, wenn keine Entwickler zur Verfügung stehen. Die Build-Phase kann komplexer sein, denn Fehler sind immer sichtbar für den Entwickler, der den Deploy vorantreibt.\n\n\n\nV. Κατασκευή, έκδοση, εκτέλεση

Αυστηρός διαχωρισμός μεταξύ των σταδίων μεταγλώττισης/κατασκευής και εκτέλεσης

Μια βάση κώδικα μετασχηματίζεται σε μια ανάπτυξη εφαρμογής (deploy) (όχι για υλοποίηση) μέσω τριών σταδίων:


Το στάδιο κατασκευής (build stage) είναι ένας μετασχηματισμός που μετατρέπει ένα αποθετήριο κώδικα σε μία εκτελέσιμη δέσμη γνωστή ως κατασκευή (build). Χρησιμοποιώντας μια έκδοση του κώδικα σε κάποιο σημείο δοσμένο απο τη διεργασία ανάπτυξης, το στάδιο κατασκευής μαζέυει τις όποιες εξαρτήσεις που πρέπει να προμηθευθούν στην εφαρμογή και μεταγλωττίζει και συνενώνει τα δυαδικά αρχεια και άλλα πρόσθετα.

Το στάδιο έκδοσης (release stage) παίρνει το αποτέλεσμα του σταδίου κατασκευής και το συνδυάζει με τις τρέχουσες παραμέτρους της ανάπτυξης της εφαρμογής. Η τελική έκδοση (release) περιέχει την κατασκευή και τις παραμέτρους και είναι έτοιμη για άμεση εκτέλεση στο περιβάλλον εκτέλεσης.

Το στάδιο εκτέλεσης (run stage) (επίσης γνωστό ως “εκτελέσιμο”, “runtime”) τρέχει την εφαρμογή στο περιβάλλον εκτέλεσης, ξεκινώντας ένα σύνολο απο τις διεργασίες της εφαρμογής με βάση μια επιλεγμένη έκδοση της εφαρμογής.




Η εφαρμογή δώδεκα παραγόντων διαχωρίζει αυστηρά τα στάδια κατασκευής, έκδοσης και εκτέλεσης. Για παράδειγμα, είναι αδύνατο να πραγματοποιηθούν αλλαγές στον κώδικα κατά την εκτέλεση, καθώς δεν υπάρχει τρόπος να περάσουν αυτές οι αλλαγές πίσω στο στάδιο κατασκευής.

Τα εργαλεία ανάπτυξης εφαρμογών (deployment tools) τυπικά προσφέρουν εργαλεία διαχείρισης εκδόσεων (release management tools), κυρίως την ικανότητα να γυρίσουν πίσω σε μία προηγούμενη έκδοση της εφαρμογής. Για παράδειγμα, το εργαλείο Capistrano αποθηκέυει τις εκδόσεις σε ένα υποφάκελο με όνομα releases, όπου η τρέχουσα έκδοση είναι ένας συμβολικός σύνδεσμος στο φάκελο της τρέχουσας έκδοσης. Με την εντολή του rollback έυκολα και γρήγορα γυρίζει πίσω σε μία προηγούμενη έκδοση της εφαρμογής.

Κάθε έκδοση της εφαρμογής θα πρέπει πάντα να φέρει ένα μοναδικό αναγνωριστικό έκδοσης (release ID), όπως μια χρονοσφραγίδα της έκδοσης (όπως το 2011-04-06-20:32:17) ή έναν άυξοντα αριθμό (όπως το v100). Οι εκδόσεις της εφαρμογής είναι σαν ένα λογιστικό βιβλίο όπου μόνο προσθέσεις μπορούν να γίνουν και μία έκδοση δεν μπορεί να μεταβληθεί αφού έχει δημιουργηθεί. Κάθε μεταβολή πρέπει να δημιουργήσει μια νέα έκδοση της εφαρμογής.

Οι κατασκευές (builds) ξεκινούν απο τους προγραμματιστές της εφαρμογής όποια στιγμή καινούργιος κώδικας αναπτύσσεται (deployed). Η εκτέλεση, αντιθέτως, μπορεί να συμβεί αυτόματα σε περιπτώσεις όπως επανεκκίνηση εξυπηρετητή (server restart), ή όταν μια διεργασία που έχει καταρρέυσει επανεκκινείται από τον διαχειριστή διεργασιών (process manager). Επομένως, το στάδιο εκτέλεσης θα πρέπει να έχει όσο πιο λίγα κινούμενα μέρη γίνεται, καθώς προβλήματα που μπορεί να εμποδίσουν μία εφαρμογή απο το να τρέξει μπορεί να την κάνουν να καταρρέυσει εν τω μέσω της νυκτός όπου δεν θα υπάρχει κανένας προγραμματιστής διαθέσιμος. Το στάδιο κατασκευής μπορεί να είναι πιο περίπλοκο, καθώς τα σφάλματα είναι πάντα στο προσκήνιο για ένα προγραμματιστή που καθοδηγεί την ανάπτυξη της εφαρμογής (deploy).\n\n\n\nV. Construir, distribuir, ejecutar

Separar completamente la etapa de construcción de la etapa de ejecución

El código base se transforma en un despliegue (que no es de desarrollo) al completar las siguientes tres etapas:


La etapa de construcción es una transformación que convierte un repositorio de código en un paquete ejecutable llamado construcción (una “build”). En la etapa de construcción se traen todas las dependencias y se compilan los binarios y las herramientas usando una versión concreta del código correspondiente a un commit especificado por el proceso de despliegue.

En la fase de distribución se usa la construcción creada en la fase de construcción y se combina con la configuración del despliegue actual. Por tanto, la distribución resultante contiene tanto la construcción como la configuración y está lista para ejecutarse inmediatamente en el entorno de ejecución.

La fase de ejecución (también conocida como “runtime”) ejecuta la aplicación en el entorno de ejecución, lanzando un conjunto de procesos de una distribución concreta de la aplicación.




Las aplicaciones “twelve-factor” hacen una separación completa de las fases de construcción, de distribución y de ejecución. Por ejemplo, es imposible hacer cambios en el código en la fase de ejecución, porque no hay una manera de propagar dichos cambios a la fase de construcción.

Las herramientas de despliegue ofrecen, normalmente, herramientas de gestión de distribuciones (releases). La capacidad de volver a una versión anterior es especialmente útil. Por ejemplo, la herramienta de despliegues Capistrano almacena distribuciones en un subdirectorio llamado releases, donde la distribución actual es un enlace simbólico al directorio de la distribución actual. Su mandato rollback hace fácil y rápidamente el trabajo de volver a la versión anterior.

Cada distribución debería tener siempre un identificador único de distribución, como por ejemplo una marca de tiempo (timestamp) de la distribución (2011-04-06-20:32:17) o un número incremental (como v100). Las distribuciones son como un libro de contabilidad, al que solo se le pueden agregar registros y no pueden ser modificados una vez son creados. Cualquier cambio debe crear una nueva distribución.

Cada vez que un desarrollador despliega código nuevo se crea una construcción nueva de la aplicación. La fase de ejecución, en cambio, puede suceder automáticamente, por ejemplo, cuando se reinicia un servidor, o cuando un proceso termina inesperadamente siendo reiniciado por el gestor de procesos. Por tanto, la fase de ejecución debería mantenerse lo más estática posible, ya que evita que una aplicación en ejecución pueda causar una interrupción inesperada, en mitad de la noche, cuando no hay desarrolladores a mano. La fase de construcción puede ser más compleja, ya que los errores siempre están en la mente de un desarrollador que dirige un despliegue.\n\n\n\nV. Assemblez, publiez, exécutez

Séparez strictement les étapes d’assemblage et d’exécution

Une base de code est transformée en un déploiement (non-développement) à travers les étapes suivantes :


L’étape d’assemblage (ou “build”) est une transformation qui convertit un dépôt de code en un paquet autonome exécutable appelé l’assemblage (ou “build”). En utilisant une version du code référencée par un commit spécifié lors du processus de déploiement, l’étape d’assemblage va chercher toutes les dépendances externes et compile les fichiers binaires et les ressources.

L’étape de publication (ou “release”) prend l’assemblage produit à l’étape précédente et le combine avec la configuration de déploiement courante. La release résultante contient à la fois l’assemblage et la configuration, et elle est prête pour une exécution immédiate dans l’environnement d’exécution.

L’étape d’exécution (ou “runtime”) fait fonctionner l’application dans l’environnement d’exécution, en lançant un ensemble de processus de l’application associée à la release considérée.




Les applications 12 facteurs ont une séparation stricte entre les étapes d’assemblage, de publication et d’exécution. Par exemple, il est impossible de faire des changements dans le code au moment de son exécution, car il n’y a pas moyen de propager ces changements vers l’étape de build.

Les outils de déploiement offrent généralement des outils de gestion de release, permettant notamment de revenir à une release antérieure. Par exemple, l’outil de déploiement Capistrano stocke les releases dans un sous-répertoire appelé releases, où la release courante est un lien symbolique vers le répertoire de release courante. Sa commande rollback permet de facilement revenir à une release précédente.

Chaque release devrait toujours avoir un identifiant unique, comme un horodatage (timestamp) de la release (tel que 2011-04-06-20:32:17) ou un nombre incrémental (tel que v100). La liste des releases est accessible en écriture incrémentale uniquement, et il n’est pas possible de modifier une release une fois qu’elle a été réalisée. Tout changement doit créer une nouvelle release.

Les assemblages sont initiés par le développeur de l’application dès que du nouveau code est déployé. Son exécution, au contraire, peut avoir lieu automatiquement en cas d’un reboot du serveur, ou du crash d’un processus qui est relancé par le gestionnaire de processus. De ce fait, l’étape d’exécution doit se limiter à un nombre minimal de parties mobiles, car les problèmes qui empêchent une application de fonctionner peuvent entraîner des dysfonctionnements au milieu de la nuit alors qu’aucun développeur ne sera là pour les corriger. L’étape d’assemblage peut être plus complexe, car les erreurs pourront toujours être résolues par le développeur qui réalise le déploiement.\n\n\n\nV. Build, release, esecuzione

Separare in modo netto lo stadio di build dall’esecuzione

Una codebase viene “trasformata” in deployment attraverso tre fasi:


la fase di build, che converte il codice del repo in una build “eseguibile”. Usando una certa versione del codice, a una specifica commit, nella fase di build vengono compilati i binari con gli asset appropriati includendo anche le eventuali dipendenze;

la fase di release prende la build prodotta nella fase precedente e la combina con l’attuale insieme di impostazioni di configurazione del deployment specifico. La release risultante contiene sia la build che le impostazioni;

la fase di esecuzione (conosciuta anche come “runtime”) vede l’applicazione in esecuzione nell’ambiente di destinazione, attraverso l’avvio di processi della release scelta;




Un’app twelve-factor definisce una separazione netta tra build, release ed esecuzione. Per esempio, è impossibile effettuare dei cambiamenti del codice a runtime, dato che non c’è modo di propagare queste modifiche all’“indietro”, verso la fase di build.

I tool di deployment offrono tipicamente dei tool di gestione delle release, in particolare alcuni dedicati a un rollback verso una release precedente. Per esempio, Capistrano memorizza le varie release in una sotto-directory chiamata releases, in cui la release attuale non è che un symlink verso la directory della release attuale. Il comando di rollback permette di tornare indietro a una certa release velocemente.

Ogni release dovrebbe inoltre possedere un ID univoco di rilascio, come per esempio un timestamp (es. 2011-04-06-20:32:17) o un numero incrementale (es. v100). In un certo senso, la creazione di una release è una procedura “a senso unico” e una certa release non può essere modificata dopo la sua creazione. Qualsiasi cambiamento deve quindi prevedere una nuova release.

Una fase di build è sempre avviata da uno sviluppatore, non appena il codice viene modificato. Al contrario, l’esecuzione può essere anche gestita in modo automatico (si pensi al riavvio del server oppure a un crash con successivo riavvio del processo). A ogni modo, una volta in esecuzione, la regola aurea è di evitare il più possibile (se non del tutto) modifiche che potrebbero rompere qualche equilibrio. Magari nel bel mezzo della notte, quando non c’è nessuno disponibile. La fase di build può essere sicuramente più “faticosa”, comunque, visto che possono verificarsi degli errori da risolvere prima di proseguire.\n\n\n\nV. ビルド、リリース、実行

ビルド、リリース、実行の3つのステージを厳密に分離する

コードベースは3つのステージを経て、（開発環境ではない）デプロイへと変換される。


ビルドステージ は、コードリポジトリを ビルド と呼ばれる実行可能な塊へと変える変換である。デプロイプロセスで指定したコミットのコードで指定されたバージョンを使って、ビルドステージは依存関係を取得してローカル環境に配置し、バイナリやアセットファイルをコンパイルする。

リリースステージ は、ビルドステージで生成されたビルドを受け取り、それをデプロイの現在の設定と結合する。出来上がる リリース にはビルドと設定の両方が含まれ、実行環境の中ですぐにでも実行できるよう準備が整う。

実行ステージ （ランタイムとも呼ばれる）は、選択されたリリースに対して、アプリケーションのいくつかのプロセスを起動することで、アプリケーションを実行環境の中で実行する。




Twelve-Factor Appは、ビルド、リリース、実行の3つのステージを厳密に分離する。 例えば、実行ステージにあるコードを変更してもその変更をビルドステージに伝える方法がないため、コードを実行中に変更することはあり得ない。

デプロイツールは通常、リリース管理ツールを提供する。中でも注目すべきは、以前のリリースにロールバックする機能である。例えばデプロイツールのCapistranoは、リリースをreleasesという名前のサブディレクトリに格納し、現在のリリースは現在のリリースのディレクトリへのシンボリックリンクとなる。Capistranoのrollbackコマンドを使うと、簡単かつ即座に以前のリリースにロールバックできる。

すべてのリリースは常に一意のリリースIDを持つべきである。リリースIDの例としては、リリースのタイムスタンプ（例：2011-04-06-20:32:17）や連番（例：v100）がある。リリースは追記専用の台帳であり、一度作られたリリースは変更することができない。変更する場合は新しいリリースを作らなければならない。

ビルドステージは、新しいコードがデプロイされるときに必ずアプリケーションの開発者によって開始される。一方実行ステージは、サーバーの再起動時や、クラッシュしたプロセスがプロセスマネージャーによって再起動された時に自動で開始される。このため、実行ステージはできるだけ可変部分を持たないようにするべきである。なぜなら、アプリケーションの実行を妨げるような問題が起きると、開発者が待機していない真夜中にアプリケーションが壊れる結果になるためである。ビルドステージはもっと複雑でも構わない。なぜなら、ビルドステージのエラーは常にデプロイを実行している開発者の目の前で発生するためである。\n\n\n\nV. 빌드, 릴리즈, 실행

철저하게 분리된 빌드와 실행 단계

코드베이스는 3 단계를 거쳐 (개발용이 아닌) 배포로 변환됩니다.


빌드 단계는 코드 저장소를 빌드라는 실행 가능한 번들로 변환시키는 단계입니다. 빌드 단계에서는 커밋된 코드 중 배포 프로세스에서 지정된 버전을 사용하며, 종속성을 가져와 바이너리와 에셋들을 컴파일합니다.

릴리즈 단계에서는 빌드 단계에서 만들어진 빌드와 배포의 현재 설정을 결합 합니다. 완성된 릴리즈는 빌드와 설정을 모두 포함하며 실행 환경에서 바로 실행될 수 있도록 준비됩니다.

실행 단계(런타임이라고도 하는)에서는 선택된 릴리즈에 대한 애플리케이션 프로세스의 집합을 시작하여, 애플리케이션을 실행 환경에서 돌아가도록 합니다.




Twelve-Factor App은 빌드, 릴리즈, 실행 단계를 엄격하게 서로 분리합니다. 예를 들어, 실행 단계에서 코드를 변경할 수는 없습니다. 변경을 실행 단계보다 앞에 있는 빌드 단계로 전달할 수 있는 방법이 없기 때문입니다.

배포 도구는 일반적으로 릴리즈 관리 도구를 제공합니다. 특히 주목할만한 점은 이전 릴리즈로 되돌릴 수 있는 롤백 기능입니다. 예를 들어, Capistrano는 배포 툴은 릴리즈를 releases라는 하위 디렉토리에 저장시키고, 현재 릴리즈는 현재 릴리즈 디렉토리로 심볼릭 링크로 연결합니다. 이 툴의 rollback 명령어는 이전 버전으로 쉽고 빠르게 이전 릴리즈로 롤백할 수 있도록 해줍니다.

모든 릴리즈는 항상 유니크한 릴리즈 아이디를 지녀야 합니다. 예를 들어, 릴리즈의 타임 스템프(예: 2011-04-06-20:32:17)나 증가하는 번호(예: v100, v101)가 있습니다. 릴리즈는 추가만 될 수 있으며, 한번 만들어진 릴리즈는 변경될 수 없습니다. 모든 변경은 새로운 릴리즈를 만들어야 합니다.

빌드는 새로운 코드가 배포 될 때마다 개발자에 의해 시작됩니다. 반면, 실행 단계는 서버가 재부팅되거나 충돌이 발생한 프로세스가 프로세스 매니저에 의해 재시작 되었을 때 자동으로 실행될 수 있습니다. 따라서 대응할 수 있는 개발자가 없는 한밤중에 문제가 발생하는 것을 방지하기 위해, 실행 단계는 최대한 변화가 적어야합니다. 빌드 단계는 좀 더 복잡해져도 괜찮습니다. 항상 배포를 진행하고 있는 개발자의 눈 앞에서 에러가 발생하기 때문입니다.\n\n\n\nV. Buduj, publikuj, uruchamiaj

Oddzielaj etap budowania od uruchamiania

Codebase jest przetwarzany we wdrożenie w trzech etapach (poza lokalnym środowiskiem).


Podczas etapu budowania kod z repozytorium konwertowany jest do wykonywalnej paczki tzw. buildu. Używając wersji kodu zdefiniowanej przez commit w procesie deploymentu, w tym etapie pobiera i dołącza się do projektu zależności oraz kompiluje niezbędne zasoby.

Podczas etapu publikacji aplikacji używany jest build stworzony w poprzednim etapie i konfigurowany na podstawie ustawień obecnego wdrożenia. Stworzony w ten sposób release zawiera zbudowane źródło kodu, jego konfigurację i jest gotowy do uruchomienia w wybranym środowisku.

Etap uruchamiania (znany również jako “runtime”) startuje aplikację w środowisku wykonawczym przez uruchomienie zestawu procesów w oparciu o wcześniej przygotowany release.




Aplikacja 12factor ściśle rozgranicza etapy budowy, publikacji i uruchamiania. Kiedy aplikacja została już uruchomiona, nie można zmienić jej kodu w inny sposób niż zbudować ją na nowo na podstawie wcześniej naniesionych zmian.

Narzędzia do obsługi wdrożeń zazwyczaj oferują moduły do zarządzania releasami, w tym możliwość do powrotu do poprzedniej wersji (rollback). Np. narzędzie Capistrano przechowuje releasy w podkatalogu releases, gdzie obecna wersja opublikowanej aplikacji jest symlinkowana do jednej z wersji przechowywanej w katalogu Capistrano. Komenda rollback pozwala na szybką zmianę wersji opublikowanej aplikacji na jedną z poprzednich.

Każdy release powinien zawsze posiadać unikalny identyfikator, jak np. data publikacji aplikacji (taka jak 2011-04-06-20:32:17) lub inkrementowany numer (np. v100). Do rejestru opublikowanych wersji aplikacji można jedynie dodawać jej nowe wersje, jego zawartość nie może być zmieniana w żaden inny sposób.

Aplikacja może zostać zbudowana, gdy developer zdecyduje o wdrożeniu zmian do kodu. Uruchomienie aplikacji może natomiast nastąpić automatycznie po restarcie serwera lub jednego z procesów aplikacji po błędzie krytycznym. Dlatego też etap uruchamiania aplikacji powinien być jak najbardziej jednolity minimalizując równocześnie ryzyko wystąpienia problemów ze startem aplikacji - mogą one spowodować zaprzestanie działania aplikacji np. w nocy, kiedy to nie ma żadnego developera “pod ręką”. Etap budowy aplikacji może być bardziej złożony, ponieważ ewentualne błędy są zawsze widoczne dla developera, który nadzoruje ten proces.\n\n\n\nV. Construa, lance, execute

Separe estritamente os estágios de construção e execução

Uma base de código é transformada num deploy (de não-desenvolvimento) através de três estágios:


O estágio de construção é uma transformação que converte um repositório de código em um pacote executável conhecido como construção. Usando uma versão do código de um commit especificado pelo processo de desenvolvimento, o estágio de construção obtém e fornece dependências e compila binários e ativos.

O estágio de lançamento pega a construção produzida pelo estágio de construção e a combina com a atual configuração do deploy. O lançamento resultante contém tanto a construção quanto a configuração e está pronta para execução imediata no ambiente de execução.

O estágio de execução roda o app no ambiente de execução, através do início de alguns dos processos do app com um determinado lançamento.




O app doze-fatores usa separação estrita entre os estágios de construção, lançamento e execução. Por exemplo, é impossível alterar código em tempo de execução, já que não há meios de se propagar tais mudanças de volta ao estágio de construção.

Ferramentas para deploy tipicamente oferecem ferramentas de gestão de lançamento, mais notadamente a habilidade de se reverter à um lançamento prévio. Por exemplo, a ferramenta de deploy Capistrano armazena lançamentos em um subdiretório chamado releases, onde o lançamento atual é um link simbólico para o diretório de lançamento atual. Seu comando rollback torna fácil reverter para um lançamento prévio.

Cada lançamento deve sempre ter um identificador de lançamento único, tal qual o timestamp do lançamento (como 2011-04-06-20:32:17) ou um número incremental (como v100). Lançamentos são livro-razões onde apenas se acrescenta informações, ou seja, uma vez criado o lançamento não pode ser alterado. Qualquer mudança deve gerar um novo lançamento.

Construções são iniciadas pelos desenvolvedores do app sempre que novos códigos entram no deploy. A execução de um executável, todavia, pode acontecer automaticamente em casos como o reinício do servidor, ou um processo travado sendo reiniciado pelo gerenciador de processos. Assim, no estágio de execução deve haver quanto menos partes móveis quanto possível, já que problemas que previnem um app de rodar pode causá-lo a travar no meio da noite quando não há desenvolvedores por perto. O estágio de construção pode ser mais complexo, já que os erros estão sempre à vista do desenvolvedor que está cuidando do deploy.\n\n\n\nV. Сборка, релиз, выполнение

Строго разделяйте стадии сборки и выполнения

Кодовая база трансформируется в развёртывание (не учитывая развёртывание для разработки) за три этапа:


Этап сборки – это трансформация, которая преобразует репозиторий кода в исполняемый пакет, называемый сборка. Используя версию кода по указанному процессом развёртывания коммиту, этап сборки загружает сторонние зависимости и компилирует двоичные файлы и ресурсы (assets).

Этап релиза принимает сборку, полученную на этапе сборки, и объединяет её с текущей конфигурацией развёртывания. Полученный релиз содержит сборку и конфигурацию и готов к немедленному запуску в среде выполнения.

Этап выполнения (также известный как “runtime”) запускает приложение в среде выполнения путём запуска некоторого набора процессов приложения из определённого релиза.




Приложение двенадцати факторов использует строгое разделение между этапами сборки, релиза и выполнения. Например, невозможно внести изменения в код во время выполнения, так как нет способа распространить эти изменения обратно на этап сборки.

Инструменты развёртывания, как правило, представляют собой инструменты управления релизами, и что немаловажно, дают возможность отката к предыдущему релизу. Например инструмент развёртывания Capistrano сохраняет релизы в подкаталогах каталога с именем releases, где текущий релиз является символической ссылкой на каталог текущего релиза. Команда Capistrano rollback даёт возможность быстро откатится к предыдущему релизу.

Каждый релиз должен иметь уникальный идентификатор, такой как отметка времени релиза (например 2015-04-06-15:42:17) или увеличивающееся число (например v100). Релизы могут только добавляться и каждый релиз невозможно изменить после его создания. Любые изменения обязаны создавать новый релиз.

Сборка инициируется разработчиком приложения всякий раз, когда разворачивается новый код. Запуск этапа выполнения, напротив, может происходить автоматически в таких случаях, как перезагрузка сервера, или перезапуск упавшего процесса менеджером процессов. Таким образом, этап выполнения должен быть как можно более технически простым, так как проблемы, которые могут помешать приложению запуститься могут возникнуть в середине ночи, когда нет доступных разработчиков. Этап сборки может быть более сложным, так как возможные ошибки всегда видимы разработчику, который запустил развёртывание.\n\n\n\nV. Build, release, run

Jasne oddelené fázy build, release a run

Kód sa transformuje do (nevývojárskeho) nasadenia troma krokmi:


Krok build transformuje kód v repozitári na vykonateľný balík nazývaný build. Použitím verzie kódu v čase commitu špecifikovaného nasadzovacím procesom, krok build stiahne závislosti a skompiluje binárky a assets.

Krok release zoberie build vytvorený predchádzajúcim krokom a skombinuje ho s aktuálnou konfiguráciou pre dané nasadenie. Výsledok release obsahuje build a konfiguráciu pripravené na okamžité vykonanie v exekučnom prostredí.

Krok run (alebo “runtime”) spustí aplikáciu v exekučnom prostredí naštartovaním aplikačných procesov voči danému release.




Dvanásť faktorová aplikácia striktne oddeľuje fázy build, release a run. Napríklad: je nemožné spraviť zmeny v kóde počas jeho behu, keďže neexistuje spôsob, ako by sa tieto zmeny dostali späť do fázy build.

Nástroje na nasadzovanie zvyčajne ponúkajú spôsoby na správu release, hlavne teda možnosť vrátiť sa na predchádzajúci release. Napríklad Capistrano si ukladá release v podpriečinku s názvom releases, kde je aktuálny release symlink na priečinok s aktuálnym releasom. Tento príkaz rollback umožňuje jednoducho a rýchlo vrátiť sa na predchádzajúci release.

Každý release by mal vždy mať unikátne release ID, ako napríklad timestamp release (napríklad 2019-04-06-20:32:17) alebo inkrementálne číslo (napr. v100). Releasy sú záznamy, ktoré iba pribúdajú a release sa nedá zmeniť potom jeho vytvorení. Každá zmenu musí vytvoriť nový release.

Buildy inicializujú developeri aplikácie kedykoľvek sa nasadzuje nový kód. Vykonávanie behu sa na rozdiel od buildov vykonáva automaticky v prípade reštartu servera, alebo pri reštarte padnutého procesu správcom procesov. Preto by fáza spustenia mala mať čo najmenej pohyblivých častí, keďže problémy, ktoré so spustením aplikácie môžu nastať v strede noci, keď developeri nie sú k dispozícii. Fáza build môže byť komplexnejšia, keďže chyby sú vždy viditeľné developerom, ktorí spustili nasadenie.\n\n\n\nV. Build, release, run

แยกขั้นตอนของการ build และ run อย่างเคร่งครัด

codebase จะเปลี่ยนแปลงไปเป็น (non-development) deploy ด้วย 3 ขั้นตอน:


ขั้นตอนการ build เป็นการแปลงซึ่งเป็นการเปลี่ยน code repo ไปเป็นโปรแกรมที่ทำงานได้ (executable bundle) เรียกว่าการ build ใช้ version ของ code ที่ระบุ commit ด้วยกระบวนการ deployment ซึ่งขั้นตอนการ build นี้จะดึงการอ้างอิง และ compile เป็น binariy และ assets.

ขั้นตอนการ release จะนำ build ที่ได้จากขั้นตอนการ build และรวามเข้ากับ การตั้งค่า ของ deploy ซึ่งจะได้ release ที่มีทั้ง build และ การตั้งค่า ที่พร้อมจะทำงานได้ในสิ่งแวดล้อมการทำงาน

ขั้นตอนการ run (หรือเรียกว่า “runtime”) เป็นการทำให้ app ทำงานในสิ่งแวดล้อมการทำงาน ด้วยการเริ่มใช้งานบางเซตของ app processes ด้วย release ที่ถูกเลือก




Twelve-factor app ใช้การแยกขั้นตอนการ build, release และ run ออกจากกันอย่างเคร่งครัด ตัวอย่างเช่น เป็นไปไม่ได้ที่ทำการเปลี่ยนแปลงของ code ในขณะทำงาน เนื่องจากไม่มีวิธีใดในการเผยแพร่การเปลี่ยนแปลงกลับสู่สถานะ build

เครื่องมื่อสำหรับ deployment โดยทั่วไปจะมีเครื่องมือจัดการการ release อยู่แล้ว และส่วนใหญ่จะมีความสามารถ roll back กลับสู่ release ก่อนหน้าได้ ตัวอย่างเช่น Capistrano เป็นเครื่องมือ deployment ที่เก็บการ release ในไดเรกทอรีย่อยชื่อว่า releases ที่ซึ่ง release ปัจจุบันเชื่อมโยงเข้ากับไดเรกทอรี release ปัจจุบัน สามารถใช้คำสั่ง rollback เพื่อทำให้มัน roll back กลับไปเป็น release ก่อนหน้าอย่างรวดเร็ว

ทุกๆ release ควรจะมี release ID เฉพาะเสมอ เช่น timestamp ของ release (เช่น 2011-04-06-20:32:17) หรือจำนวนนับที่เพิ่มขึ้น (เช่น v100), release เป็นบัญชีแยกประเภทที่เพิ่มขึ้นได้เท่านั้นและ release ไม่สามารถแก้ไขได้เมื่อถูกสร้างขึ้นแล้ว ทุกๆ การเปลี่ยนแปลงจำเป็นต้องสร้าง release ใหม่เสมอ

การ build เริ่มต้นโดย developer ของ app เมื่อไรก็ตามที่ code ใหม่ถูก deploy, การทำงานในขณะทำงาน ในทางตรงกันข้าม สามารถเกิดขึ้นได้โดยอัตโนมัติในกรณีที่ server reboot หรือ crashed process ถูก restart โดย process manager ดังนั้นขั้นตอนการ run ถูกทำให้มีขั้นตอนน้อยที่สุดเท่าที่จะเป็นไปได้ เพื่อป้องกันปัญหา app สามารถหยุดการทำงานได้ในเวลาตอนกลางคืนเมื่อไม่มี developer อยู่ทำงาน ขั้นตอนการ build สามารถเป็นขั้นตอนที่ซับซ้อนได้ ในเมื่อ error จะแสดงต่อ developer ผู้ซึ่งทำการ deploy มัน\n\n\n\nV. Derleme, yayınlama, çalıştırma

Derleme ve çalıştırma aşamalarını tam olarak ayırma

Bir kod tabanı üç aşamada (geliştirme dağıtımı olmayan) dağıtıma dönüşür:


Derleme aşaması kod deposunun derleme olarak bilinen çalıştırılabilir bir pakete çevrilmesidir. Dağıtım evresi tarafından seçilen commit’teki kod kullanılır. Sistem, üçüncü parti bağımlılıkları toparlar ve çalıştırılabilirleri ve statik dosyaları derler.

Yayınlama aşaması, derleme aşaması tarafından üretilmiş derlemeyi alır ve dağıtımı güncel yapılandırmasıyla birleştirir. Son durumda oluşan yayın derleme ve yapılandırmanın ikisini de içerir ve çalışma ortamında çalıştırmak için hazırdır.

Çalıştırma evresi (aynı zamanda “runtime” olarak bilinir) seçili yayının karşılığındaki süreçleri başlatarak, çalıştırma ortamındaki uygulamayı çalıştırır.




On iki faktör uygulamalarının derleme, yayınlama ve çalıştırma aşamaları tamamen birbirinden bağımsızdır. Örneğin, koddaki değişiklikleri derleme aşamasına geri döndürmenin bir yolu olmadığı için çalışma zamanında kodda değişiklik yapmak imkansızdır.

Dağıtım araçları genelde yayın yönetim araçları da sunar. En dikkat çeken yetenekleri ise bir önceki yayına geri dönebilmeleridir. Örneğin, Capistrano farklı yayınları releases adındaki bir alt dizinde depolar. Çalışıyor olan yayın ise bu alt dizinlerden birine oluşturulmuş bir kısayol dosyasıdır. Capistrano’nun rollback komutu, kısayol dosyasının işaret ettiği dizini değiştirerek önceki bir yayına dönüş yapmayı kolaylaştırır.

Her yayın zaman damgası gibi (2011-04-06-20:32:17 gibi) özel bir ID’ye veya her yeni yayında artan bir numaraya (v100 gibi) sahip olmalıdır. Yayınlar yalnızca eklemeli bir defterdir ve bir kere oluşturulduğu zaman değiştirilemez. Herhangi bir değişiklik yeni bir yayın oluşturmalıdır.

Derlemeler, geliştiricilerin kod değişikliklerini kod depolarına yüklemesiyle başlatılır. Çalıştırma evresi ise, sunucuların yeniden başlatılması veya çökmüş süreçlerin tekrar ayağa kaldırılması gibi durumlarda otomatik olarak gerçekleştirilir. Bu yüzden çalıştırma evresi olabildiği kadar az sayıda hareketli parçaya sahip olmalıdır ki, gecenin bir yarısında, işinin başında olan hiçbir geliştirici yokken bozulmasın. Derleme evresi ise daha karmaşık olabilir, çünkü hatalar dağıtımı çalıştıran geliştiricilerin her zaman önündedir.\n\n\n\nV. Збірка, реліз, виконання

Суворо відокремлюйте етапи збірки та виконання

Кодова база перетворюється в розгортання (крім розгортання для розробки) у три етапи:


Етап збірки — це трансформація, яка перетворює код в репозиторії у пакунок, що може бути запущений, і який називається збірка. Використовуючи версію коду за вказаним у процесі розгортання коммітом, етап збірки завантажує залежності та компілює бінарні файли і ресурси (assets).

Етап релізу приймає збірку, отриману на етапі збірки, і об’єднує її з поточною конфігурацією розгортання. Отриманий реліз містить збірку і конфігурацію і готовий до негайного запуску в середовищі виконання.

Етап виконання (також відомий як “runtime”) запускає застосунок у середовищі виконання, увімкнувши деякий набір процесів застосунку з певного релізу.




Застосунок дванадцяти факторів дотримується суворого відокремлення етапів збірки, релізу і виконання. Наприклад, не можна вносити зміни в код під час етапу виконання, оскільки немає способу поширити ці зміни назад на етап збірки.

Інструменти розгортання, як правило, надають засоби керування релізами, які дають можливість відкату до попередньої версії. Наприклад, інструмент розгортання Capistrano зберігає релізи в підкаталог з назвою releases, де поточний реліз є символічним посиланням на каталог поточного релізу. Команда Capistrano rollback дає можливість швидко виконати відкат до попередньої версії.

Кожен реліз повинен завжди мати унікальний ідентифікатор, наприклад, мітку часу релізу (наприклад, 2011-04-06-20:32:17) або номер, що зростає (наприклад, v100). Релізи можуть тільки додаватися, неможливо змінити реліз після його створення. Будь-які зміни мають створювати новий реліз.

Збірка ініцюється розробником застосунку щоразу при розгортанні нового коду. Запуск етапу виконання, навпаки, може відбуватися автоматично в таких випадках, як перезавантаження сервера або перезапуск процесу, шо впав, менеджером процесів. Таким чином, етап виконання має бути максимально технічно простим, бо проблеми, які заважають застосунку запуститися, можуть призвести до його зупинки посеред ночі, коли розробників немає на місці. Етап збірки може бути більш складним, бо можливі помилки завжди видимі розробнику, який запустив процес розгортання.\n\n\n\nV. Xây dựng, phát hành, vận hành

Tách biệt hoàn toàn giữa bước xây dựng và vận hành

Mã gốc được chuyển sang (tạm dừng phát triển) triển khai thông qua ba bước:


Bước xây dựng* là bước chuyển các đoạn mã thành các gói có khả năng thực thi được gọi là một bản xảy dựng. Sử dụng phiên bản của mã nguồn ở một bản cam kết (commit) quy định bở quy trình triển khai, bước xây dựng lấy về và cung cấp các phụ thuộc và biên dịch các thành phần và tài nguyên.

Bước phát hành* sử dụng các kết quả của bước xây dựng và kết hợp với các cấu hình triển khai hiện tại. Kết quả của phát hành bao gồm cả bản xây dựng và các câu hình cho phép ứng dụng có thể được vận hành trong môi trường vận hành.

Bước vận hành* (được biết như là “thời gian vận hành” (runtime)) vận hành ứng dụng trong môi trường thực thi, bằng việc thực thi một tập các tiến trình của của ứng dụng với một phiên bản phát hành cụ thể.




Ứng dụng sử dụng mười hai-hệ số tách biệt hoàn toàn giữa các bước xây dựng, phát hành và vận hành. Ví dụ, chúng ta không thể tạo ra các thay đổi của mã nguồn khi đang vận hành, do đó không có khả năng quay ngược lại bước xây dựng.

Công cụ triển khai thường cung cấp công cụ quản lý phát hành, cùng với các ký pháp cho phép quay ngược lại bản phat hành trước đó. Ví dụ, công cụ triển khai Capistrano lưu trữ các phát hành trong thư mục con tên là releases, nơi mà phiên bản hiện tại được liên kết giả đến thư mục phát hành hiện tại. Lệnh rollback làm cho việc quay trở lại phiên bản trước trở nên dễ dàng.

Mỗi phát hành đều có một định danh duy nhất ID, như là dựa vào thời gian phát hành (như 2011-04-06-20:32:17) hoặc một số tự tăng (như v100). Các phiên bản được tạo ra thành một chuỗi liên tục và một phiên bản không thể thay đổi sau khi nó được tạo ra. Bất cứ thay đổi nào đểu tạo ra một bản phát hành mới.

Các bước xây dựng được khởi tạo với nhà phát triển ứng dụng khi mà mã nguồn được triển khai. Thời gian thực thi, ngược lại, có thể tự động xảy ra trong trường hợp các máy chủ được khởi động lại, hoặc tiến trình tạm dừng được khởi động lại bởi bộ quản lý các tiến trình. Do đó, bước vận hành nên được giữ các thành phần thay đổi càng ít càng tốt, vì các sự cố xảy ra làm ứng dụng không vận hành được có thể gây ra các thiệt hại lúc nửa đêm khi mà không có bất kỳ lập trình viên nào có thể khắc phục sự cố. Bước xây dựng có thể phức tạp hơn, vì các lỗi có thể xuất hiện trước mắt cho lập trình viên, người đang thực hiện triển khai biết được.\n\n\n\nV. 构建，发布，运行

严格分离构建和运行

基准代码 转化为一份部署(非开发环境)需要以下三个阶段：


构建阶段 是指将代码仓库转化为可执行包的过程。构建时会使用指定版本的代码，获取和打包 依赖项，编译成二进制文件和资源文件。

发布阶段 会将构建的结果和当前部署所需 配置 相结合，并能够立刻在运行环境中投入使用。

运行阶段 （或者说“运行时”）是指针对选定的发布版本，在执行环境中启动一系列应用程序 进程。




12-factor 应用严格区分构建，发布，运行这三个步骤。 举例来说，直接修改处于运行状态的代码是非常不可取的做法，因为这些修改很难再同步回构建步骤。

部署工具通常都提供了发布管理工具，最引人注目的功能是退回至较旧的发布版本。比如， Capistrano 将所有发布版本都存储在一个叫 releases 的子目录中，当前的在线版本只需映射至对应的目录即可。该工具的 rollback 命令可以很容易地实现回退版本的功能。

每一个发布版本必须对应一个唯一的发布 ID，例如可以使用发布时的时间戳（2011-04-06-20:32:17），亦或是一个增长的数字（v100）。发布的版本就像一本只能追加的账本，一旦发布就不可修改，任何的变动都应该产生一个新的发布版本。

新的代码在部署之前，需要开发人员触发构建操作。但是，运行阶段不一定需要人为触发，而是可以自动进行。如服务器重启，或是进程管理器重启了一个崩溃的进程。因此，运行阶段应该保持尽可能少的模块，这样假设半夜发生系统故障而开发人员又捉襟见肘也不会引起太大问题。构建阶段是可以相对复杂一些的，因为错误信息能够立刻展示在开发人员面前，从而得到妥善处理。\n\n\n\nV. Build, release, run

Strictly separate build and run stages

A codebase is transformed into a (non-development) deploy through three stages:


The build stage is a transform which converts a code repo into an executable bundle known as a build. Using a version of the code at a commit specified by the deployment process, the build stage fetches vendors dependencies and compiles binaries and assets.

The release stage takes the build produced by the build stage and combines it with the deploy’s current config. The resulting release contains both the build and the config and is ready for immediate execution in the execution environment.

The run stage (also known as “runtime”) runs the app in the execution environment, by launching some set of the app’s processes against a selected release.




The twelve-factor app uses strict separation between the build, release, and run stages. For example, it is impossible to make changes to the code at runtime, since there is no way to propagate those changes back to the build stage.

Deployment tools typically offer release management tools, most notably the ability to roll back to a previous release. For example, the Capistrano deployment tool stores releases in a subdirectory named releases, where the current release is a symlink to the current release directory. Its rollback command makes it easy to quickly roll back to a previous release.

Every release should always have a unique release ID, such as a timestamp of the release (such as 2011-04-06-20:32:17) or an incrementing number (such as v100). Releases are an append-only ledger and a release cannot be mutated once it is created. Any change must create a new release.

Builds are initiated by the app’s developers whenever new code is deployed. Runtime execution, by contrast, can happen automatically in cases such as a server reboot, or a crashed process being restarted by the process manager. Therefore, the run stage should be kept to as few moving parts as possible, since problems that prevent an app from running can cause it to break in the middle of the night when no developers are on hand. The build stage can be more complex, since errors are always in the foreground for a developer who is driving the deploy.\n\n\n\nVI. Procesy

Spouštějte aplikaci jako jeden nebo více bezestavových procesů.

Aplikace je vykonávána v běhovém prostředí jako jeden nebo více procesů.

V nejjednodušším případě je kód samostatný skript, běhové prostředí je laptop vývojáře s naistalovaným interpreterem daného jazyka a proces je spouštěn z příkazové řádky (například jako python my_script.py). Na druhé straně spektra je produkční nasazení sofistikované aplikace využívající vícero typů procesu, instancovaných do nula nebo více běžících procesů.

Twelve-factor procesy jsou bezestavové a nic nesdílejí. Jakákoliv data, která potřebují být uchována, musí být uložena ve stavové podpůrné službě, typicky v databázi.

Paměť nebo souborový systém procesu mohou být využity jako krátkodobá cache pro jednu transakci. Například ke stažení velkého souboru, práce s ním a následné uložení výsledku do databáze. Twelve-factor aplikace nikdy nespoléhá, že cokoliv je nacachované v paměti nebo na disku, bude dostupné i v dalším požadavku. Při velkém počtu běžících procesů je vysoká pravděpodobnost, že další požadavek bude odbaven jiným procesem. I kdyby běžel pouze jeden proces, restart (způsobený nasazením nového kódu, změnou konfigurace nebo přemístěním procesu na jiné fyzické umístění) obvykle smaže všechny lokální (například pamět nebo souborový systém) stavy.

Balíčkovače jako je django-assetpackager používají souborový systém jako dočasné uložiště pro zkompilované soubory. Twelve-factor aplikace preferují kompilaci během fáze sestavení. Balíčkovače jako jsou Jammit a Rails asset pipeline mohou být nastaveny tak, že soubory zabalí již během fáze sestavení.

Některé webové aplikace spoléhají na “sticky sessions”, tedy cachování uživatelských session v paměti procesu a směrování budoucích požadavků stejného návštěvníka na stejný proces. Sticky session jsou porušením twelve-factor metodiky a neměli by se používat a ani by se na ně nemělo jakkoliv spoléhat. Sticky session data jsou vhodným kandidátem pro uložiště, která podporují časovou expiraci dat, jako jsou například Memcached nebo Redis.\n\n\n\nVI. Prozesse

Die App als einen oder mehrere Prozesse ausführen

Die App wird als ein oder mehrere Prozesse ausgeführt.

Im einfachsten Fall ist der Code ein Stand-alone-Skript, die Ausführungsumgebung ist der lokale Laptop eines Entwicklers mit einer installierten Laufzeitumgebung einer Sprache, und der Prozess wird von der Kommandozeile gestartet (zum Beispiel python my_script.py). Am anderen Ende des Spektrums kann eine hochentwickelte App viele Prozesstypen benutzen, die in keinen oder mehreren Prozessen laufen.

Zwölf-Faktor-Apps sind zustandslos und Shared Nothing. Alle Daten werden in unterstützenden Diensten gespeichert, normalerweise einer Datenbank.

Der RAM oder das Dateisystem des Prozesses kann als kurzfristiger Cache für die Dauer einer Transaktion verwendet werden. Zum Beispiel kann ein Prozess eine Datei herunterladen, sie verarbeiten und die Ergebnisse in einer Datenbank speichern. Die Zwölf-Faktor-App geht nie davon aus, dass irgendetwas aus dem RAM oder im Dateisystem zwischengespeichertes für einen künftigen Request oder Job verfügbar sein wird. Es ist gut möglich, dass ein künftiger Request von einem anderen Prozess bedient wird. Selbst wenn nur ein Prozess läuft, wird ein Neustart (verursacht durch Code Deployment, Konfigurationsänderung oder der Verlagerung der Ausführungsumgebung auf einen anderen physikalischen Ort) den gesamten lokalen Zustand (RAM und Dateisystem) löschen.

Asset-Paketierer (wie Jammit oder django-compressor) benutzen das Dateisystem als Cache für kompilierte Assets. Eine Zwölf-Faktor-App wie die Rails asset pipeline würde diese Art von Kompilation eher in der Build-Phase erledigen anstatt zur Laufzeit.

Manche Web-Systeme verlassen sich auf “Sticky Sessions” – sie cachen Benutzer-Session-Daten im RAM des App-Prozesses und erwarten, dass künftige Requests desselben Benutzers zum selben Prozess geschickt werden. Sticky Sessions sind eine Verletzung der zwölf Faktoren und eine guter Kandidat für einen Datenspeicher, der ein zeitabhängiges Löschen anbietet, wie Memcached oder Redis.\n\n\n\nVI. Διεργασίες

Εκτέλεση εφαρμογής ως μία ή περισσότερες διεργασίες χωρίς κατάσταση

Η εφαρμογή εκτελείται στο περιβάλλον εκτέλεσης ως μία ή περισσότερες διεργασίες (processes).

Στην απλούστερη των περιπτώσεων, ο κώδικας είναι ένα αυτόνομο σενάριο εντολών (script), το περιβάλλον εκτέλεσης είναι ο φορητός υπολογιστής του προγραμματιστή με εγκατεστημένο ένα εκτελέσιμο της γλώσσας προγραμματισμού, και η διεργασία κινείται μέσω της γραμμής εντολών (command line) (για παράδειγμα, python my_script.py). Στην άλλη πλευρά του φάσματος, μια ανάπτυξη εφαρμογής για παραγωγή μιας σύνθετης εφαρμογής μπορεί να χρησιμοποιήσει πολλούς τύπους διεργασιών, ενσαρκωμένων σε μερικές διεργασίες.

Οι διεργασίες δώδεκα παραγόντων είναι χωρίς κατάσταση (stateless) και δεν μοιράζονται τίποτα. Οποιαδήποτε δεδομένα πρέπει να παραμείνουν πρέπει να aποθηκευθούν σε μία υπηρεσία υποστήριξης με κατάσταση (stateful), τυπικά μια βάση δεδομένων.

Ο χώρος μνήμης ή το σύστημα αρχείων μιας διεργασίας μπορούν να χρησιμοποιηθούν ως μία σύντομη, μια και έξω προσωρινή μνήμη. Για παράδειγμα, να κατεβάσει ένα μεγάλο αρχείο, να δράσει πάνω σε αυτό, και να αποθηκέυσει τα αποτελέσματα στη βάση δεδομένων. Η εφαρμογή δώδεκα παραγόντων ποτέ δεν θεωρεί ως δεδομένο πως οτιδήποτε αποθηκέυτηκε προσωρινά στη μνήμη της ή στο δίσκο θα είναι διαθέσιμο και σε μια μελλοντική αίτηση για εξυπηρέτηση ή εργασία – με πολλές διεργασίες κάθε τύπου να τρέχουν, οι πιθανότητες είναι υψηλές πως μια μελλοντική αίτηση για εξυπηρέτηση θα εξυπηρετηθεί από μια άλλη διεργασία. Ακόμα και εάν τρέχει μόνο μία διεργασία, μια επανεκκίνηση (πυροδοτημένη απο μια ανάπτυξη κώδικα, αλλαγή παραμέτρων, ή από το περιβάλλον εκτέλεσης που αλλάζει τη φυσική τοποθεσία της διεργασίας) συνήθως θα σβήσει όλη την τοπική (π.χ, μνήμη και σύστημα αρχείων) κατάσταση (state).

Οι συσκευαστές περιουσιακών στοιχείων της εφαρμογής (asset packagers) όπως το django-assetpackager χρησιμοποιούν το σύστημα αρχείων σαν προσωρινή μνήμη για μεταγλωττισμένα στοιχεία (compiled assets). Μια εφαρμογή δώδεκα παραγόντων προτιμά να κάνει αυτή τη μεταγλώττιση κατά το στάδιο κατασκευής (build stage). Μερικοί συσκευαστές όπως το Jammit και το Rails asset pipeline μπορούν να ρυθμιστούν ώστε να συσκευάσουν τα assets κατά το στάδιο κατασκευής.

Μερικά συστήματα ιστού (web systems) βασίζονται σε “επίμονες συνεδρίες” (“sticky sessions”) – δηλαδή, αποθηκέυουν προσωρινά τη συνεδρία χρήστη στη μνήμη της διεργασίας της εφαρμογής και θεωρούν πως οι μελλοντικές αιτήσεις για εξυπηρέτηση απο τον ίδιο χρήστη θα δρομολογηθούν στην ίδια διεργασία. Οι επίμονες συνεδρίες συνιστούν παράβαση των δώδεκα παραγόντων και δεν θα πρέπει ποτέ να χρησιμοποιούνται ή η εφαρμογή να βασίζεται σε αυτές. Τα δεδομένα κατάστασης συνεδρίας είναι καλύτερα να αποθηκευτούν σε μια αποθήκη δεδομένων (datastore) που διαθέτει χρόνο λήξης, όπως το Memcached ή το Redis.\n\n\n\nVI. Procesos

Ejecutar la aplicación como uno o más procesos sin estado

La aplicación se ejecuta como uno o más procesos en el entorno de ejecución.

El caso más sencillo que podemos plantear es que el código es un script independiente, el entorno de ejecución es un portátil de un desarrollador, el compilador o interprete correspondiente del lenguaje está instalado, y el proceso se lanza mediante la linea de mandatos (por ejemplo, python my_script.py). Por otro lado podemos encontrar el caso de un despliegue en producción de una aplicación compleja que puede usar muchos tipos de procesos, instanciados como cero o más procesos en ejecución.

Los procesos “twelve-factor” no tienen estado y son “share-nothing”. Cualquier información que necesite persistencia se debe almacenar en un ‘backing service’ con estado, habitualmente una base de datos.

Tanto el espacio de memoria de un proceso como el sistema de ficheros se pueden usar como si fueran una cache temporal para hacer transacciones. Por ejemplo, descargar un fichero de gran tamaño, realizar alguna operación sobre él, y almacenar sus resultados en una base de datos. Las aplicaciones “twelve-factor” nunca dan por hecho que cualquier cosa cacheada en memoria o en el disco vaya a estar disponible al realizar una petición al ejecutar diferentes procesos. Con muchos procesos de cada tipo ejecutándose al mismo tiempo, existe una gran probabilidad de que otro proceso distinto sirva una petición en el futuro. Incluso cuando solo está corriendo un solo proceso, un reinicio (provocado por el despliegue de código, un cambio de configuración o un cambio de contexto del proceso) normalmente elimina todo el estado local (e.g. memoria y sistema de ficheros).

Los compresores de estáticos (como Jammit o django-compressor) usan el sistema de ficheros como una cache para ficheros compilados. En las aplicaciones “twelve-factor” es preferible realizar esta compilación durante la fase de construcción, como con el asset pipeline de Rails, en lugar de hacerlo en tiempo de ejecución.

Algunos sistemas webs dependen de “sticky sessions”, esto quiere decir que cachean la información de la sesión de usuario en la memoria del proceso de la aplicación y esperan peticiones futuras del mismo visitante para redirigirle al mismo proceso. Las “sticky sessions” son una violación de “twelve-factor” y no deberían usarse nunca ni depender de ellas. La información del estado de la sesión es un candidato perfecto para almacenes de información que ofrecen mecanismos de tiempo de expiración, como Memcached o Redis.\n\n\n\nVI. Processus

Exécutez l’application comme un ou plusieurs processus sans état

L’application est exécutée dans l’environnement d’exécution comme un ou plusieurs processus.

Dans la situation la plus simple, le code est un script indépendant, l’environnement d’exécution est l’ordinateur portable du développeur sur lequel est installé de quoi exécuter le langage, et le processus est lancé depuis la ligne de commande. (par exemple, python mon_script.py). De l’autre côté du spectre, un déploiement de production d’une application sophistiquée peut utiliser plusieurs types de processus, instanciés dans zéro ou plus processus en fonctionnement.

Les processus 12 facteurs sont sans état et ne partagent rien (en). Toute donnée qui doit être persistée doit être stockée dans un service externe stateful, typiquement une base de données.

L’espace mémoire ou le système de fichier du processus peut être utilisé comme cache momentané pour des transactions uniques. Par exemple, télécharger un gros fichier, effectuer une opération dessus, puis stocker le résultat de l’opération dans la base de données. Les applications 12 facteurs ne supposent jamais que quelque chose ayant été mis en cache en mémoire ou sur le disque sera disponible dans une future requête ou job — avec plusieurs processus de chaque type qui s’exécutent, il y a de grandes chances qu’une future requête soit effectuée par un processus différent. Même lorsque l’on fait tourner seulement un processus, un redémarrage (déclenché par le déploiement du code, un changement de configuration, ou l’environnement d’exécution qui déplace le processus vers un lieu physique différent) va généralement balayer toutes les modifications locales (c’est-à-dire en mémoire et sur le disque).

Des outils de création de paquets de ressources (ou “asset packagers”) (tel que Jammit ou django-compressor) utilisent le système de fichier comme cache pour les ressources compilées. Une application 12 facteurs préfère faire cette compilation durant l’étape d’assemblage, comme avec le pipeline des ressources de Rails, plutôt que durant l’exécution.

Certains systèmes web s’appuient sur des “sessions persistantes” (en) – c’est-à-dire, mettre en cache les données de session utilisateur dans le processus de l’application et attendre que les requêtes futures du même visiteur seront routées dans le même processus. Les sessions persistantes sont une violation des 12 facteurs, qu’il ne faudrait jamais utiliser. Les états de session sont de bons candidats pour un datastore qui offre des dates d’expiration, comme Memcached ou Redis.\n\n\n\nVI. Processi

Esegui l’applicazione come uno o più processi stateless

L’app viene eseguita nell’ambiente di esecuzione come uno o più processi.

Nel caso più semplice, il codice non è che uno script stand-alone, l’ambiente di esecuzione è il laptop dello sviluppatore e il processo viene lanciato tramite linea di comando (per esempio, python my_script.py). Tuttavia, il deployment in produzione di un’app sofisticata potrebbe usare più tipologie di processo, istanziate in zero o più processi.

I processi twelve-factor sono stateless (senza stato) e share-nothing.** Tutti i dati che devono persistere devono essere memorizzati in un backing service, come per esempio un database.

Lo spazio di memoria o il filesystem di un processo possono essere visti come una “singola transazione” breve. Come il download di un file, le successive operazioni su di esso e infine la memorizzazione del risultato sul database. Un’app twelve-factor non assume mai che qualsiasi cosa messa in cache sarà poi disponibile successivamente – con tanti processi in esecuzione, le possibilità che una certa richiesta venga servita da un altro processo sono molto alte. Comunque, anche nel caso in cui si usi un singolo processo in esecuzione, un riavvio (dovuto a deployment di codice, cambio di file di configurazione e così via) resetterà lo stato in cui si trova il sistema.

I packager di asset (come Jammit o django-compressor) usano il filesystem come cache per gli asset compilati. Un’app twelve-factor vuole questa compilazione durante la fase di build, così come l’asset pipeline di Rails, e non a runtime.

Alcuni sistemi web si basano inoltre sulle cosiddette “sticky sessions” – che consistono nel mettere in cache i dati di sessione dell’utente presenti nella memoria del processo, aspettandosi future richieste identiche dallo stesso visitatore, venendo quindi reindirizzati allo stesso processo. Le sticky session sono una palese violazione della metodologia twelve-factor. I dati di sessione sono un ottimo candidato per quei sistemi di datastore che offrono la feature di scadenza, come Memcached o Redis.\n\n\n\nVI. プロセス

アプリケーションを1つもしくは複数のステートレスなプロセスとして実行する

アプリケーションは、実行環境の中で1つもしくは複数の プロセス として実行される。

最も単純な場合では、コードは単体のスクリプトであり、実行環境は言語ランタイムがインストールされた開発者のローカルノートPCであり、プロセスはコマンドラインから実行される（例：python my_script.py）。対極にあるのは、複数の実行プロセスとしてインスタンス化される多くのプロセスタイプを使う洗練されたアプリケーションの本番デプロイである。

Twelve-Factorのプロセスはステートレスかつシェアードナッシング である。永続化する必要のあるすべてのデータは、ステートフルなバックエンドサービス（典型的にはデータベース）に格納しなければならない。

プロセスのメモリ空間やファイルシステムは、短い単一のトランザクション内でのキャッシュとして利用してもよい。例えば、大きなファイルをダウンロードし、そのファイルを処理し、結果をデータベースに格納するという一連の処理において、ファイルシステムをキャッシュとして利用できる。Twelve-Factor Appは、メモリやディスクにキャッシュされたものが将来のリクエストやジョブにおいて利用できることを決して仮定しない – それぞれのプロセスタイプのプロセスが多く実行されている場合、将来のリクエストやジョブが別のプロセスで処理される可能性が高い。1つのプロセスしか実行されていない場合であっても、プロセスが再起動すると、すべての局所的な状態（メモリやファイルシステムなど）が消えてしまうことがある。プロセスの再起動の要因としては、コードのデプロイ、設定の変更、プロセスを別の物理位置に再配置する実行環境などがある。

アセットパッケージャー（例：Jammit や django-compressor）は、コンパイルされたアセットをキャッシュするためにファイルシステムを利用する。Twelve-Factor Appは、このコンパイル処理を実行時に行うよりも、Rails asset pipelineのようにビルドステージで行うほうが、望ましいと考えている。

Webシステムの中には、“スティッキーセッション”に頼るものがある – これはユーザーのセッションデータをアプリケーションプロセスのメモリにキャッシュし、同じ訪問者からの将来のリクエストが同じプロセスに送られることを期待するものである。スティッキーセッションはTwelve-Factorに違反しており、決して使ったり頼ったりしてはならない。セッション状態のデータは、有効期限を持つデータストア（例：Memcached や Redis）に格納すべきである。\n\n\n\nVI. 프로세스

애플리케이션을 하나 혹은 여러개의 무상태(stateless) 프로세스로 실행

실행 환경에서 앱은 하나 이상의 프로세스로 실행됩니다.

가장 간단한 케이스는 코드가 stand-alone 스크립트인 경우입니다. 이 경우, 실행 환경은 개발자의 언어 런타임이 설치된 로컬 노트북이며, 프로세스는 커맨드 라인 명령어에 의해서 실행됩니다.(예: python my_script.py) 복잡한 케이스로는 많은 프로세스 타입별로 여러개의 프로세스가 사용되는 복잡한 애플리케이션이 있습니다.

Twelve-Factor 프로세스는 무상태(stateless)이며, 아무 것도 공유하지 않습니다. 유지될 필요가 있는 모든 데이터는 데이터베이스 같은 안정된 백엔드 서비스에 저장되어야 합니다.

짧은 단일 트랙잭션 내에서 캐시로 프로세스의 메모리 공간이나 파일시스템을 사용해도 됩니다. 예를 들자면 큰 파일을 받고, 해당 파일을 처리하고, 그 결과를 데이터베이스에 저장하는 경우가 있습니다. Twelve-Factor 앱에서 절대로 메모리나 디스크에 캐시된 내용이 미래의 요청이나 작업에서도 유효할 것이라고 가정해서는 안됩니다. 각 프로세스 타입의 프로세스가 여러개 돌아가고 있는 경우, 미래의 요청은 다른 프로세스에 의해서 처리될 가능성이 높습니다. 하나의 프로세스만 돌고 있는 경우에도 여러 요인(코드 배포, 설정 변경, 프로세스를 다른 물리적 장소에 재배치 등)에 의해서 발생하는 재실행은 보통 모든 로컬의 상태(메모리와 파일 시스템 등)를 없애버립니다.

에셋 패키징 도구 (예: Jammit, django-assetpackager)는 컴파일된 에셋을 저장할 캐시로 파일 시스템을 사용합니다. Twelve-Factor App은 이러한 컴파일을 런타임에 진행하기보다는, Rails asset pipeline처럼 빌드 단계에서 수행하는 것을 권장합니다.

웹 시스템 중에서는 “Sticky Session”에 의존하는 것도 있습니다. 이는 유저의 세션 데이터를 앱의 프로세스 메모리에 캐싱하고, 같은 유저의 이후 요청도 같은 프로세스로 전달될 것을 가정하는 것입니다. Sticky Session은 Twelve-Factor에 위반되며, 절대로 사용하거나 의존해서는 안됩니다. 세션 상태 데이터는 Memcached나 Redis처럼 유효기간을 제공하는 데이터 저장소에 저장하는 것이 적합합니다.\n\n\n\nVI. Procesy

Uruchamiaj aplikację jako jeden lub więcej bezstanowych procesów

Aplikacja jest uruchamiana w środowisku wykonawczym w postaci jednego lub kilku procesów.

W najprostszym przypadku kod aplikacji jest samodzielnym skryptem, środowiskiem wykonawczym jest laptop developera z wsparciem dla języka programowania, a proces jest uruchamiany za pomocą linii komend (na przykład python my_script.py). Innym razem wdrożenie produkcyjne mocno rozwiniętej aplikacji może wymagać wielu różnych rodzajów procesów.

Wg zasad 12factor, procesy są bezstanowe i niewspółdzielące. Jakiekolwiek dane wymagające zapisu muszą być zmagazynowane w “trwałej” usłudze wspierającej, najczęściej będącą bazą danych.

Przestrzeń adresowa lub system plików procesu mogą być używane jako tymczasowy cache dla pojedynczych operacji. Przykładem jest pobieranie dużych plików, działanie na nich, a następnie zapisywanie wyników operacji w bazie danych. Aplikacja dwunastu aspektów nigdy nie zakłada, że jakiś fragment informacji zapisany w pamięci lub dysku będzie dostępny w przyszłości podczas jakiegokolwiek zapytania – wraz z wieloma aktywnymi procesami rośnie szansa, że przyszłe zapytanie zostanie obsłużone przez zupełnie inny proces. Nawet w przypadku pojedynczego procesu, restart (spowodowany przez deployment kodu, zmianę konfiguracji lub przeniesienie procesu do innej fizycznej lokalizacji przez środowisko wykonawcze) zazwyczaj usunie wszystkie dane z lokalnego stanu aplikacji (system plików, pamięć podręczna).

Narzędzie do pakowania plików, z których korzysta aplikacja (takie jak Jammit lub django-compressor) używają systemu plików jako cache dla skompilowanych zasobów. Wg 12factor taka kompilacja powinna mieć miejsce podczas etapu budowy aplikacji, jak to się dzieje np. w Rails asset pipeline.

Niektóre systemy sieciowe polegają na tzw. “sticky sessions” – oznacza to, że sesja użytkownika jest zapisywana tymczasowo w pamięci procesu aplikacji, zakładając, że kolejne zapytania dotyczące użytkownika będą kierowane do tego samego procesu. “Sticky sessions” są złamaniem zasad aplikacji 12factor i nigdy nie powinny być używane jako źródło informacji. Dane sesji nadają się bardziej do zapisu w magazynie oferującym wygasanie danych w czasie, jak np. Memcached czy Redis.\n\n\n\nVI. Processos

Execute a aplicação como um ou mais processos que não armazenam estado

A aplicação é executada em um ambiente de execução como um ou mais processos.

No caso mais simples, o código é um script autônomo, o ambiente de execução é o laptop local de um desenvolvedor com o runtime da linguagem instalado, e o processo é iniciado pela linha de comando (por exemplo, python my_script). Na outra extremidade do espectro, o deploy em produção de uma aplicação sofisticada pode utilizar vários tipos de processos, instanciado em zero ou mais processos em andamento.

Processos doze-fatores são stateless(não armazenam estado) e share-nothing. Quaisquer dados que precise persistir deve ser armazenado em um serviço de apoio stateful(que armazena o seu estado), tipicamente uma base de dados.

O espaço de memória ou sistema de arquivos do processo pode ser usado como um breve, cache de transação única. Por exemplo, o download de um arquivo grande, operando sobre ele, e armazenando os resultados da operação no banco de dados. A aplicação doze-fatores nunca assume que qualquer coisa cacheada na memória ou no disco estará disponível em uma futura solicitação ou job – com muitos processos de cada tipo rodando, as chances são altas de que uma futura solicitação será servida por um processo diferente. Mesmo quando rodando em apenas um processo, um restart (desencadeado pelo deploy de um código, mudança de configuração, ou o ambiente de execução realocando o processo para uma localização física diferente) geralmente vai acabar com todo o estado local (por exemplo, memória e sistema de arquivos).

Empacotadores de assets (como Jammit ou django-compressor) usa o sistema de arquivos como um cache para assets compilados. Uma aplicação doze-fatores prefere fazer isto compilando durante a fase de build, tal como o Rails asset pipeline, do que em tempo de execução.

Alguns sistemas web dependem de “sessões persistentes” – ou seja, fazem cache dos dados da sessão do usuário na memória do processo da aplicação, esperando futuras requisições do mesmo visitante para serem encaminhadas para o mesmo processo. Sessões persistentes são uma violação do doze-fatores e nunca devem ser utilizadas ou invocadas. Dados do estado da sessão são bons candidatos para um datastore que oferece tempo de expiração, tal como Memcached ou Redis.\n\n\n\nVI. Процессы

Запускайте приложение как один или несколько процессов, не сохраняющих внутреннее состояние (stateless)

Приложение выполняется в среде выполнения как один или несколько процессов.

В простейшем случае код является независимым скриптом, среда выполнения – ноутбуком разработчика с установленной средой исполнения языка, а процесс запускается из командной строки (например, как python my_script.py). Другой крайний вариант – это рабочее развёртывание сложного приложения, которое может использовать много типов процессов, каждый из которых запущен в необходимом количестве экземпляров.

Процессы приложения двенадцати факторов не сохраняют внутреннее состояние (stateless) и не имеют разделяемых данных (share-nothing). Любые данные, которые требуется сохранить, должны быть сохранены в хранящей состояние сторонней службе, обычно, в базе данных.

Память и файловая система процесса может быть использована в качестве временного кэша для одной транзакции. Например, загрузка, обработка и сохранение большого файла в базе данных. Приложение двенадцати факторов не предполагает, что что-либо закэшированное в памяти или на диске будет доступно следующим запросам или задачам – с большим количеством разноплановых процессов высока вероятность, что следующий запрос будет обработан другим процессом. Даже с одним запущенным процессом перезапуск (вызванный развёртыванием, изменением конфигураций или переносом процесса на другое физическое устройство) приведёт к уничтожению всех локальных (памяти, файловой системы) состояний.

Упаковщики ресурсов (asset) (например, Jammit или django-compressor) используют файловую систему как кэш для скомпилированных ресурсов. Приложение двенадцати факторов предпочитает делать данную компиляцию во время этапа сборки, например, как в Rails asset pipeline, а не во время выполнения.

Некоторые веб-системы полагаются на “липкие сессии” – то есть кэшируют данные пользовательских сессии в памяти процесса приложения и ожидают того, что последующие запросы того же пользователя будут перенаправлены к тому же процессу. Липкие сессии являются нарушением двенадцати факторов и их никогда не следует использовать или полагаться на них. Данные пользовательской сессии являются хорошими кандидатами для хранилища данных, которое предоставляет функцию ограничения времени хранения, например, Memcached и Redis.\n\n\n\nVI. Procesy

Execute the app as one or more stateless processes

Aplikácia sa vykonáva v exekučnom prostredí ako jeden alebo viac procesov.

V najjednoduchšom prípade je kód jednoduchý skript, exekučné prostredie je laptop developera s nainštalovaným kompilátorom/interpretrom jazyka, a proces sa spúšta z príkazového riadka (napríklad, python my_script.py). Na druhej strane spektra, produkčné nasadenie sofistikovanej aplikácie môže mať viacero typov procesov, inštancovaných do jedného alebo viacerých procesov.

Dvanásť faktorové procesy sú bezstavové a share-nothing. Akékoľvek dáta, ktoré treba zachovať, musia byť uložené v stavovej podpornej službe, typicky databáze.

Priestor pamäte alebo súborového systému procesu sa môže použiť ako krátka cache pre jednu transakciu. Napríklad, stiahnutie veľkého súboru, práca nad ním a uloženie výsledkov operácie do databázy. Dvanásť faktorová aplikácia nikdy neočakáva, že by bolo čokoľvek nacachované v pamäti alebo na disku pre budúce požiadavky alebo úlohy – je vysoká šanca, že pri viacerých bežiacich procesoch bude ďalšia požiadavka vykonaná iným procesom. Aj keď beží len jeden process, reštart (spustený nasadením kódu, zmenou konfigurácie, alebo exekučným prostredím premiestni proces na iné fyzické miesto) zvyčajne vymaže všetky lokálne (napr. pamäť a súborový systém) stavy.

Balíčkovače ako napríklad django-assetpackager používajú súborový systém ako cache na kompilované súbory. Dvanásť faktorová aplikácia preferuje túto kompiláciu počas fázy build. Balíčkovače Jammit a Rails asset pipeline sa dajú nakonfigurovať, tak, že zabalia súbory počas fázy build.

Niektoré webové systémy sa spoliehajú na “sticky sessions” – teda cachovanie údajov o používateľskom sedení v pamäti procesu a očakávajú, že ďalšie požiadavky od daného návštevníka budú presmerované na ten istý proces. Sticky sessions sú porušením dvanástich faktorov a nemali by sa nikdy používať ani na ne spoliehať. Stav sedenia je dobrým kandidátom pre úložisko, ktoré poskytuje vypršanie po čase, ako napr. Memcached alebo Redis.\n\n\n\nVI. Processes

รันแอพพลิเคชันเป็นหนึ่งหรือมากกว่าให้เป็น stateless processes

App ทำงานในสภาพแวดล้อมการดำเนินงานด้วยหนึ่งหรือมากกว่า processes

ในกรณีที่ง่ายที่สุดคือ code คือ stand-alone script, สภาพแวดล้อมการดำเนินงานคือเครื่องคอมพิวเตอร์อง developer ที่ติดตั้ง language runtime และวิธีการคือเปิด app ด้วยคำสั่ง (ตัวอย่างเช่น python my_script.py) ในอีกด้านหนึ่ง app ที่ซับซ้อนที่ deploy บน production ใช้หลาย process types, instantiated into zero or more running processes

Twelve-factor processes เป็น stateless และ share-nothing. ข้อมูลใดๆที่จำเป็นต้องเก็บแบบถาวรจำเป็นต้องเก็บไว้ใน stateful backing service โดยปรกติจะเป็นฐานข้อมูล

พื้นที่หน่วยความจำหรือระบบไฟล์ของ process สามารถใช้เป็นช่วงสั้นๆ ได้, single-transaction cache. ตัวอย่างเช่น, การดาวน์โหลดไฟล์ขนาดใหญ่, ดำเนินงานกับไฟล์นั้น และเก็บผลลัพธ์ของการดำเนินงานไว้ในฐานข้อมูล twelve-factor app ไม่เคยสมมติว่ามีอะไรแคชในหน่วยความจำหรือบน disk จะพร้อมใช้งานใน request หรือ job ในอนาคต – มีหลาย process ทำงานมีโอกาสสูงมากที่ในอนาคต request จะทำงานบน process ที่แตกต่างกัน แม้ว่าทำงาน process เดียว เมื่อมีการ restart (trigger โดย code deploy, config change หรือเปลี่ยนสภาพแวดล้อมการทำงาน) จะลบสภานะของ app ทั้งหมดอย่างสมบูรณ์ (เช่น หน่วยความจำ และระบบไฟล์)

Asset packagers อย่างเช่น django-assetpackager ใช้ระบบไฟล์เป็นแคชของการ compiled asset. Twelve-factor app ชอบที่จะทำ compiling เช่นนี้ในระหว่าง ขั้นตอนการ build Asset packagers อย่างเช่น Jammit และ Rails asset pipeline สามารถตั้งค่าให้ pacakge asset ระหว่างขั้นตอนการ build ได้

บางระบบเว็บขึ้นอยู่กับ “sticky sessions” – นั้นคือ, ทำการแคชขอมูล user session ในหน่วยความจำของ app สำหรับดำเนินการในอนาคตจากผู้เยี่ยมชมเดียวกันที่เชื่อมโยงกับ process เดียวกัน, Sticky session เป็นการละเมิด twelve-factor และไม่ควรใช้หรือพึ่งพา, ข้อมูลสถานะ Session เป็นสิ่งที่เหมาะสมอย่างมากสำหรับที่เก็บข้อมูลที่มีการหมดเวลา (time-expireation) อย่างเช่น Memcached หรือ Redis\n\n\n\nVI. Süreçler

Uygulamayı bir veya daha fazla bağımsız süreç olarak çalıştırma

Uygulama bir veya birden fazla süreç olarak çalıştırma ortamında çalıştırılır.

En basit senaryoda, kod bağımsız çalışan bir betiktir, çalışma ortamı ise geliştiricinin dil çalışma zamanı yüklenmiş bilgisayarıdır ve süreç komut satırı aracılığıyla başlatılır (Örneğin, python my_script.py). Spekturumun diğer ucunda, gelişmiş bir uygulamanın canlı yayın dağıtımı birden fazla sıfır veya daha fazla aktif süreci bulunan bir süreç tipine sahip olabilir.

On iki faktör süreçleri durumsuz ve paylaşımsızdır. Saklanmasına ihtiyaç duyulan herhangi bir veri, durum-sahibi bir yardımcı serviste saklanmalıdır. Bu servis genelde bir veritabanı olur.

Süreçler, bellekleri ve dosya sistemini, kısa süreli tek süreçli önbellekler olarak kullanabilirler. Örneğin, büyük bir dosya indiririp, üzerinde bir operasyon uygulayıp, operasyonun sonuçlarını veri tabanında saklayabilir. On iki faktör uygulaması, bellek veya diskte depolanmış hiçbir şeyin gelecekteki istek veya işlerde erişilebilir olacağını varsaymaz. Birden çok süreç çalıştıran sistemlerde, gelecekteki bir isteğin farklı bir süreç tarafından sunulma şansı yüksektir. Sadece bir süreç çalıştırıldığında bile, tekrar başlatma (kod dağıtımı, yapılandırma değişikliği veya çalışma ortamı sürecin farklı fiziksel adrese tekrar yerleştirimi tarafından tetiklenebilir) genellikle bütün yerel (bellek ve dosya sistemi v.b gibi) durumları temizler.

django-assetpackager gibi statik içerik paketleyicileri dosya sistemini derlenmiş statikleri önbelleklemek için kullanır. On iki faktör uygulaması, bu derlemeyi uygulamanın derlenmesi aşamasında yapmayı tercih eder. Jammit ve Rails asset pipeline gibi paketleyiciler derleme aşamasında çalışmak için yapılandırılabilir.

Bazı web sistemleri yapışkan oturum (İng. sticky sessions) denilen giriş yapmış kullanıcı bilgisini uygulamanın belleğinde tutan yöntemi kullanır. “Sticky sessions” on iki faktör kurallarını ihlal eden bir yöntemdir ve asla kullanılmamalıdır. Oturum verisi Memcached ve Redisgibi zaman aşımı özelliği sunan veritabanları için iyi bir veri adayıdır.\n\n\n\nVI. Процеси

Запускайте застосунок як один або декілька процесів без збереження внутрішньго стану (stateless)

Застосунок запускається в середовищі виконання у вигляді одного або декількох процесів.

У найпростішому випадку код є окремим скриптом, середовище виконання — ноутбук розробника зі встановленим середовищем виконання мови програмування, а процес запускається за допомогою командного рядка (наприклад, python my_script.py). В іншому випадку, це може бути production-розгортання складного застосунку, яке може використовувати багато типів процесів, кожен з яких запущений у необхідній кількості екземплярів.

Процеси застосунку дванадцяти факторів не зберігають внутрішній стан (stateless) і не розділяють ресурси. Будь-які дані, що підлягають збереженню, мають зберігатися в сторонній службі зі збереженням внутрішнього стану (stateful) (як правило, в базі даних).

Пам’ять та файлова система процесу можуть бути використані як короткостроковий кеш. Наприклад, завантаження, обробка і збереження великого файлу в базі даних. Застосунок дванадцяти факторів ніколи не припускає, що щось, закешоване в пам’яті або на диску, буде доступне при наступному запиті — за наявності багатьох запущених процесів різних типів є велика ймовірність, що наступний запит буде оброблений іншим процесом. Навіть при роботі тільки одного процесу перезапуск (викликаний розгортанням, змінами конфігурації або переміщенням процесу в інше фізичне місце розташування середовищем виконання), як правило, призведе до знищення всіх локальних (у пам’яті і файловій системі) станів.

Пакувальники ресурсів (наприклад, Jammit або django-compressor) використовують файлову систему як кеш для скомпільованих ресурсів. Застосунок дванадцяти факторів надає перевагу здійсненню такої компіляції під час етапу збірки, наприклад, як в Rails asset pipeline, а не під час виконання.

Деякі веб-системи покладаються на “липкі сесії” — тобто кешують дані сесії користувача в пам’яті процесу застосунку і очікують, що наступні запити від того ж самого користувача будуть спрямовані до того ж самого процесу. Липкі сесії є порушенням дванадцяти факторів і їх ніколи не слід використовувати та покладатися на них. Дані сесії користувача є хорошим кандидатом для сховища даних, яке надає функцію обмеження терміну зберігання, наприклад, Memcached або Redis.\n\n\n\nVI. Tiến trình

Vận hành ứng dụng như là một hoặc nhiều tiến trình phi trạng thái

Ứng dụng được vận hành trong môi trường vận hành như là một hoặc nhiều tiến trình.

Trong trường hợp đơn giản, mã nguồn là các kịch bản độc lập, môi trường vận hành chính là máy tính của nhà phát triển với ngôn ngữ thực thi được cài đặt, và tiến trình được khởi chạy thông qua dòng lệnh (ví dụ, python my_script.py). Ở một khía cạnh khác, triển khai thực tế của ứng dụng phức tạp có thể sử dụng nhiều xử lý từ không đến nhiều kiểu tiến trình ngay lập tức.

Tiến trình áp dụng mười hai hệ số là phi trạng thái và không chia sẻ bất cứ tài nguyên nào](http://en.wikipedia.org/wiki/Shared_nothing_architecture). Bất kỳ dữ liệu nào cần lưu trữ lâu dài cần được lưu trữ trong dịch vụ hỗ trợ đầy đủ trạng thái, thông thường là cơ sở dữ liệu.

Không gian bộ nhớ hoặc hệ thống tệp tin của tiến trình có thể được sử dụng như là bộ đệm tạm thời, thông qua luồng xử lý duy nhất. Ví dụ, việc tải một tệp tin lớn, tiến trình tải xuống và lưu trữ kết quả của tiến trình được lưu trữ trong cơ sở dữ liệu. Ứng dụng theo mười hai hệ số không bao giờ giả sử rằng có bất cứ cơ chế đệm nào của bộ nhớ hay ổ đĩa cứng sẵn sàng cho các yêu cầu hoặc công việc trong tương lai – với nhiều tiến trình mà mỗi kiểu vận hành, mà tỷ cao các yêu cầu trong tương lai được xử lý bởi tiến trình khác. Mặc dù chỉ chạy một tiến trình, việc khởi động lại (được kích hoạt bởi mã nguồn triển khai, thay đổi cấu hình hoặc môi trường thực thi được thay đổi lại đến một tài nguyên vật lý khác), thường sẽ loại bỏ toàn bộ trạng thái cục bộ (như là bộ nhớ và hệ thống tệp tin).

Bộ đóng gói tài nguyên (như Jammit hoặc django-compressor) sử dụng hệ thống tệp tin như là bộ đệm cho việc biên dịch các tài nguyên. Ứng dụng sử dụng mười hai hệ số thường thực thi việc biên dịch này trong bước xây dựng, như Rails asset pipeline, hơn là ở bước vận hành.

Một vài hệ thống web dựa vào “sticky sessions” – đó là cơ chế lưu trữ tạm thời các dữ liệu của người dùng theo phiên làm việc trong bộ nhớ của các tiến trình vận hành ứng dụng và trông đợi các yêu cầu từ cùng một người dùng được định hướng tới cùng tiến trình. Sticky sessions đã vi phạm nguyên tắc của mười hai hệ số và không nên được sử dụng hoặc áp dụng theo. Dữ liệu trạng thái của các phiên làm việc là nên được lưu trữ trong các nơi lưu trữ cung cấp khả năng hết hạn theo thời gian như là Memcached hoặc Redis.\n\n\n\nVI. 进程

以一个或多个无状态进程运行应用

运行环境中，应用程序通常是以一个和多个 进程 运行的。

最简单的场景中，代码是一个独立的脚本，运行环境是开发人员自己的笔记本电脑，进程由一条命令行（例如python my_script.py）。另外一个极端情况是，复杂的应用可能会使用很多 进程类型 ，也就是零个或多个进程实例。

12-Factor 应用的进程必须无状态且 无共享 。 任何需要持久化的数据都要存储在 后端服务 内，比如数据库。

内存区域或磁盘空间可以作为进程在做某种事务型操作时的缓存，例如下载一个很大的文件，对其操作并将结果写入数据库的过程。12-Factor应用根本不用考虑这些缓存的内容是不是可以保留给之后的请求来使用，这是因为应用启动了多种类型的进程，将来的请求多半会由其他进程来服务。即使在只有一个进程的情形下，先前保存的数据（内存或文件系统中）也会因为重启（如代码部署、配置更改、或运行环境将进程调度至另一个物理区域执行）而丢失。

源文件打包工具（Jammit, django-compressor） 使用文件系统来缓存编译过的源文件。12-Factor 应用更倾向于在 构建步骤 做此动作——正如 Rails资源管道 ，而不是在运行阶段。

一些互联网系统依赖于 “粘性 session”， 这是指将用户 session 中的数据缓存至某进程的内存中，并将同一用户的后续请求路由到同一个进程。粘性 session 是 12-Factor 极力反对的。Session 中的数据应该保存在诸如 Memcached 或 Redis 这样的带有过期时间的缓存中。\n\n\n\nVI. Processes

Execute the app as one or more stateless processes

The app is executed in the execution environment as one or more processes.

In the simplest case, the code is a stand-alone script, the execution environment is a developer’s local laptop with an installed language runtime, and the process is launched via the command line (for example, python my_script.py). On the other end of the spectrum, a production deploy of a sophisticated app may use many process types, instantiated into zero or more running processes.

Twelve-factor processes are stateless and share-nothing. Any data that needs to persist must be stored in a stateful backing service, typically a database.

The memory space or filesystem of the process can be used as a brief, single-transaction cache. For example, downloading a large file, operating on it, and storing the results of the operation in the database. The twelve-factor app never assumes that anything cached in memory or on disk will be available on a future request or job – with many processes of each type running, chances are high that a future request will be served by a different process. Even when running only one process, a restart (triggered by code deploy, config change, or the execution environment relocating the process to a different physical location) will usually wipe out all local (e.g., memory and filesystem) state.

Asset packagers like django-assetpackager use the filesystem as a cache for compiled assets. A twelve-factor app prefers to do this compiling during the build stage. Asset packagers such as Jammit and the Rails asset pipeline can be configured to package assets during the build stage.

Some web systems rely on “sticky sessions” – that is, caching user session data in memory of the app’s process and expecting future requests from the same visitor to be routed to the same process. Sticky sessions are a violation of twelve-factor and should never be used or relied upon. Session state data is a good candidate for a datastore that offers time-expiration, such as Memcached or Redis.\n\n\n\nVII. Vazba s portem

Exportujte služby pomocí vazby na port.

Webové aplikace jsou někdy vykonávány uvnitř webového serveru. Například PHP aplikace mohou běžet jako modul uvnitř Apache HTTPD nebo Java aplikace mohou běžet uvnitř Tomcatu.

Twelve-factor aplikace jsou úplně soběstačné a nespoléhají se na vsunutí webserveru do běhového prostředí k vytvoření webové služby. Webová aplikace exportuje HTTP jako službu vázanou na port a naslouchá požadavkům přicházejícím na daný port.

V lokálním vývojovém prostředí přistupuje vývojář na službu exportovanou jeho aplikací přes URL jako je http://localhost:5000/. U nasazení přesměrovává směrovací vrstva požadavky z veřejně dostupné domény na port webového procesu.

To se typicky realizuje přidáním knihovny webserveru přímo do aplikace za pomoci deklarace závislostí. Například Tornado pro Python, Thin pro Ruby, nebo Jetty pro Javu a jiné jazyky založené na JVM. Toto se děje výhradně v uživatelském prostoru, tedy v kódu aplikace. Dohoda s běhovým prostředím je pak pouze vazba na port pro obsluhu požadavků.

HTTP není jediná služba, kterou je možné exportovat přes port. Téměř libovolný serverový software může běžet na otevřeném portu a naslouchat příchozím požadavkům. Například ejabberd (komunikující pomocí XMPP) nebo Redis (komunikující Redis protokolem).

Všimněte si také, že přístupem pomocí vazby na port se jedna aplikace může stát podpůrnou službou pro jinou aplikaci, poskytnutím URL podpůrné služby jako zdroje pro konfiguraci konzumující aplikace.\n\n\n\nVII. Bindung an Ports

Dienste durch das Binden von Ports exportieren

Web-Apps laufen manchmal in einem Webserver als Container. Zum Beispiel laufen PHP-Apps als Modul in Apache HTTPD, oder Java-Apps laufen manchmal in Tomcat.

Die Zwölf-Faktor-App ist vollständig eigenständig und verlässt sich nicht darauf, dass ein externer Webserver zur Laufzeit injiziert wird, um dem Web einen Dienst zur Verfügung zu stellen. Die Web-App exportiert HTTP als Dienst, indem sie sich an einen Port bindet und wartet an diesem Port auf Requests.

In einer lokalen Entwicklungsumgebung öffnet ein Entwickler eine Dienst-URL wie http://localhost:5000/, um auf den Dienst der App zuzugreifen. Beim Deployment sorgt eine Routing-Schicht dafür, dass Requests von einem öffentlich sichtbaren Hostnamen zu den an die Ports gebundenen Prozessen kommen.

Üblicherweise wird dies mittels Abhängigkeitsdeklaration implementiert. Zu der App fügt man eine Webserver-Bibliothek hinzu wie Tornado für Python, Thin für Ruby oder Jetty für Java und andere JVM-basierenden Sprachen. Dies findet vollständig im User Space statt, also im Code der App. Der Vertrag mit der Laufzeitumgebung ist das Binden an einen Port um Requests zu bedienen.

HTTP ist nicht der einzige Dienst, der durch Portbindung exportiert werden kann. Fast jede Server-Software kann betrieben werden, indem ein Prozess an einen Port gebunden wird und auf ankommende Requests wartet. Einige Beispiele sind ejabberd (spricht XMPP) und Redis (spricht das Redis-Protokoll).

Es sei auch erwähnt, dass durch Portbindung eine App ein unterstützender Dienst für eine andere App werden kann, indem die URL der unterstützenden App der konsumierenden App als Resource-Handle zur Verfügung gestellt wird.\n\n\n\nVII. Πρόσδεση θυρών

Εξαγωγή υπηρεσιών μέσω πρόσδεσης θυρών

Οι εφαρμογές (παγκόσμιου) ιστού (web apps) μερικές φορές εκτελούνται μέσα σε ένα εξυπηρετητή ιστού (webserver container). Για παράδειγμα, εφαρμογές PHP μπορεί να τρέχουν ως ένα κομμάτι μέσα στο Apache HTTPD, ή εφαρμογές Java μπορεί να τρέχουν μέσα στο Tomcat.

Η εφαρμογή δώδεκα παραγόντων είναι εντελώς αυτοτελής (self-contained) και δεν βασίζεται στην εισδοχή ενός εξυπηρετηή ιστού (webserver) κατά την εκτέλεση από το περιβάλλον εκτέλεσης για να δημιουργήσει μια υπηρεσία ιστού (web-facing service). Η εφαρμογή ιστου (web app) εξάγει το HTTP ως υπηρεσία μέσω πρόσδεσης σε μια θύρα (binding to a port), και αναμένοντας αιτήσεις εξυπηρέτησης που έρχονται από αυτή τη θύρα.

Σε ένα τοπικό περιβάλλον υλοποίησης, ο προγραμματιστής επισκέπτεται ένα URL υπηρεσίας όπως το http://localhost:5000/ για να έχει πρόσβαση στην υπηρεσία που εξάγεται απο την εφαρμογή του. Στην παραγωγή, ένα επίπεδο δρομολόγησης χειρίζεται τις αιτήσεις δρομολόγησης από ένα δημόσιο φιλοξενητή πρός τις διεργασίες ιστού προσδεδεμένες σε θύρα (port-bound web processes).

Αυτό τυπικά υλοποιείται χρησιμοποιώντας δήλωση εξαρτήσεων για να προστεθεί μια βιβλιοθήκη εξυπηρετητή ιστου (webserver library) στην εφαρμογή, όπως το Tornado για τη Python, το Thin για τη Ruby, ή το Jetty για τη Java και άλλες γλώσσες που βασίζονται στη JVM. Αυτό συμβαίνει εξ’ ολοκλήρου στο χώρο χρήστη (user space), δηλαδή, μέσα στον κώδικα της εφαρμογής. Το συμβόλαιο (contract) με το περιβάλλον εκτέλεσης είναι η πρόσδεση σε μια θύρα για να εξυπηρετηθούν αιτήσεις.

Το HTTP δεν είναι η μόνη υπηρεσία που μπορεί να εξαχθεί μέσω πρόσδεσης θυρών (port binding). Σχεδόν κάθε είδος λογισμικού εξυπηρετητή (server software) μπορέι να τρέξει μέσω μιας διεργασίας που προσδένεται σε θύρα και αναμένει εισερχόμενα αιτήματα εξυπηρέτησης. Παραδείγματα περιλαμβάνουν το ejabberd (που μιλάει XMPP), και το Redis (που μιλάει το πρωτόκολλο Redis).

Σημειώστε επίσης ότι η προσέγγιση της πρόσδεσης θυρών σημαίνει ότι μία εφαρμογή μπορεί να γίνει υπηρεσία υποστήριξης για μια άλλη εφαρμογή, παρέχοντας το URL της εφαρμογής υποστήριξης ως ένα αναγνωριστικό πόρου (resource handle) στις παραμέτρους (config) της εφαρμογής που θα την καταναλώσει.\n\n\n\nVII. Asignación de puertos

Publicar servicios mediante asignación de puertos

Las aplicaciones web se ejecutan a menudo mediante contenedores web. Por ejemplo, las aplicaciones de PHP se suelen ejecutar como módulos del HTTPD de Apache, y las aplicaciones Java en Tomcat.

Las aplicaciones “twelve factor” son completamente auto-contenidas y no dependen de un servidor web en ejecución para crear un servicio web público. Una aplicación web usa HTTP como un servicio al que se le asigna un puerto, y escucha las peticiones que recibe por dicho puerto.

En los entornos de desarrollo, los desarrolladores usan una URL del servicio (por ejemplo http://localhost:5000/), para acceder al servicio que ofrece la aplicación. En la fase de despliegue, existe una capa de enrutamiento que se encarga de que las peticiones que llegan a una dirección pública se redirijan hacia el proceso web que tiene asignado su puerto correspondiente.

Esto se implementa, normalmente, usando una declaración de dependencias donde se incluyen librerías de las aplicaciones web, como Tornado para Python, Thin para Ruby, o Jetty para Java y otros lenguajes basados en la Máquina Virtual de Java (JVM). Esto ocurre totalmente en el entorno del usuario, es decir, dentro del código de la aplicación. El contrato con el entorno de ejecución obliga al puerto a servir las peticiones.

HTTP no es el único servicio que usa asignación de puertos. La verdad, es que cualquier servicio puede ejecutarse mediante un proceso al que se le asigna un puerto y queda a la espera de peticiones. Entre otros ejemplos podemos encontrar ejabberd (que usa XMPP), y Redis (que usa el protocolo Redis).

También es cierto que la aproximación de asignación de puertos ofrece la posibilidad de que una aplicación pueda llegar a ser un “backing service” para otra aplicación, usando la URL de la aplicación correspondiente como un recurso declarado en la configuración de la aplicación que consume este “backing service”.\n\n\n\nVII. Associations de ports

Exportez les services via des associations de ports

Les applications web sont parfois exécutées à l’intérieur d’un container de serveur web. Par exemple, les applications PHP peuvent fonctionner comme un module à l’intérieur de HTTPD, d’Apache, ou bien les applications Java peuvent fonctionner à l’intérieur de Tomcat.

Les applications 12 facteurs sont complètement auto-contenues et ne se basent pas sur l’injection au moment de l’exécution d’un serveur web dans l’environnement d’exécution pour créer les services exposés au web. L’application web expose HTTP comme un service en l’associant à un port et écoute les requêtes qui arrivent sur ce port.

Dans un environnement de développement local, le développeur visite l’URL d’un service tel que http://localhost:5000/ pour accéder au service exporté par leur application. Durant le déploiement, une couche de routage gère le routage des requêtes depuis un nom d’hôte qui s’expose au public, vers les processus sur lequel est associé le port.

Ceci est typiquement implémenté en utilisant la déclaration de dépendances pour ajouter une bibliothèque de serveur web, tel que Tornado pour Python, Thin pour Ruby, ou Jetty pour Java et autres langages basés sur la JVM. Cela se déroule entièrement dans l’espace utilisateur, c’est-à-dire, dans le code de l’application. Le contrat avec l’environnement d’exécution, c’est l’association de port pour servir les requêtes.

HTTP n’est pas le seul service qui peut être exporté à l’aide d’association de ports. Presque tout type de serveur peut fonctionner à travers l’association à un port et l’écoute des requêtes entrantes. Il y a par exemple ejabberd (qui parle XMPP), et Redis (qui parle le protocole Redis).

Notez également que l’approche par association de port signifie qu’une application peut devenir le service externe d’une autre application, en fournissant l’URL de l’application externe dans la configuration de l’application qui la consomme.\n\n\n\nVII. Binding delle Porte

Esporta i servizi tramite binding delle porte

Normalmente, le applicazioni web sono qualcosa di eseguito all’interno di un server web, che fa da contenitore. Per esempio, le applicazioni PHP possono venire eseguite come modulo all’interno di Apache HTTPD, così come un’applicazione Java viene eseguita in Tomcat.

L’applicazione twelve-factor è completamente self-contained (contenuta in se stessa) e non si affida a un altro servizio (come appunto un webserver) nell’ambiente di esecuzione. La web app esporta HTTP come un servizio effettuando un binding specifico a una porta, rimanendo in ascolto su tale porta per le richieste in entrata.

In un ambiente di sviluppo locale, lo sviluppatore accede al servizio tramite un URL come http://localhost:5000/. In fase di deployment, invece, un layer di routing gestisce le richieste da un hostname pubblico alla specifica porta desiderata.

Tale funzionalità viene, frequentemente, implementata tramite dichiarazione delle opportune dipendenze, aggiungendo una libreria webserver all’applicazionecome Tornado per Python, Thin per Ruby, o Jetty per Java e altri linguaggi basati su JVM. L’evento, nella sua interezza, “ha luogo” nello spazio dell’utente, nel codice dell’applicazione.

HTTP non è l’unico servizio che può essere esportato tramite port binding. In realtà quasi ogni tipo di software può essere eseguito tramite uno specifico binding tra processo e porta dedicata. Alcuni esempi includono ejabberd (a tal proposito, leggere su XMPP), e Redis (a proposito del protoccolo Redis).

Nota inoltre che usare il binding delle porte permette a un’applicazione di diventare il backing service di un’altra applicazione, tramite un URL dedicato o comunque come una risorsa la cui configurazione si può gestire tramite appositi file di config dell’app consumer del servizio.\n\n\n\nVII. ポートバインディング

ポートバインディングを通してサービスを公開する

WebアプリケーションはWebサーバーコンテナの内部で実行されることがある。例えば、PHPアプリケーションはApache HTTPD内部のモジュールとして実行されるかもしれないし、JavaアプリケーションはTomcatの内部で実行されるかもしれない。

Twelve-Factor Appは完全に自己完結 し、Webに公開されるサービスを作成するために、コンテナが実行環境にWebサーバーランタイムを注入することを頼りにしない。Webアプリケーションは ポートにバインドすることでHTTPをサービスとして公開し、 そのポートにリクエストが来るのを待つ。

ローカルの開発環境では、開発者はアプリケーションによって公開されたサービスにアクセスするために、http://localhost:5000/のようなサービスのURLにアクセスする。本番環境ではルーティング層が、外向きのホスト名からポートにバインドされたWebプロセスへとリクエストをルーティングする。

これは一般に、依存関係宣言を使ってWebサーバーライブラリをアプリケーションに追加することで実装される。Webサーバーライブラリの例として、PythonにおけるTornado、RubyにおけるThin、Javaやその他のJVMベースの言語におけるJettyなどがある。これは ユーザー空間 すなわちアプリケーションのコード内で完結する。リクエストを処理するための実行環境との契約は、ポートをバインドすることである。

ポートバインディングによって公開されるサービスはHTTPだけではない。ほぼすべてのサーバーソフトウェアは、ポートをバインドするプロセスを用いて動作し、リクエストが来るのを待つ。例として、ejabberd（XMPPを話す）や Redis（Redisプロトコルを話す）などがある。

ここで注目すべきは、ポートバインディングの方法によって、あるアプリケーションが他のアプリケーションにとってのバックエンドサービスになれる点である。バックエンドアプリケーションへのURLを提供し、利用するアプリケーションの設定にリソースハンドルとして格納すればよい。\n\n\n\nVII. 포트 바인딩

포트 바인딩을 사용해서 서비스를 공개함

웹앱은 웹서버 컨테이너 내부에서 실행되기도 합니다. 예를 들어, PHP 앱은 Apache HTTPD의 모듈로 실행될 수도 있고, Java 앱은 Tomcat 내부에서 실행될 수도 있습니다.

Twelve-Factor 앱은 완전히 독립적이며 웹서버가 웹 서비스를 만들기 위해 처리하는 실행환경에 대한 런타임 인젝션에 의존하지 않습니다. Twelve-Factor 웹 앱은 포트를 바인딩하여 HTTP 서비스로 공개되며 그 포트로 들어오는 요청을 기다립니다.

로컬 개발 환경에서는 http://localhost:5000과 같은 주소를 통해 개발자가 애플리케이션 서비스에 접근할 수 있습니다. 배포에서는 라우팅 레이어가 외부에 공개된 호스트명으로 들어온 요청을 포트에 바인딩된 웹 프로세스에 전달 합니다.

이는 일반적으로 종속선 선언에 웹서버 라이브러리를 추가함으로써 구현됩니다. 예를 들어, 파이썬의 Tornado나 루비의 Thin이나 자바와 JVM 기반 언어들을 위한 Jetty가 있습니다. 이것들은 전적으로 유저 스페이스 즉, 애플리케이션의 코드 내에서 처리됩니다. 실행 환경과의 규약은 요청을 처리하기 위해 포트를 바인딩하는 것입니다.

포트 바인딩에 의해 공개되는 서비스는 HTTP 뿐만이 아닙니다. 거의 모든 종류의 서버 소프트웨어는 포트를 바인딩하고 요청이 들어오길 기다리는 프로세스를 통해 실행될 수 있습니다. 예를 들면, ejabberd (XMPP을 따름)나 Redis (Redis protocol을 따름) 등이 있습니다.

포트 바인딩을 사용한다는 것은 하나의 앱이 다른 앱을 위한 백엔드 서비스가 될 수 있다는 것을 의미한다는 점에 주목합시다. 백엔드 앱의 URL을 사용할 앱의 설정의 리소스 핸들로 추가하는 방식으로 앱이 다른 앱을 백엔드 서비스로 사용할 수 있습니다.\n\n\n\nVII. Przydzielanie portów

Udostępniaj usługi przez przydzielanie portów

Zdarza się, że aplikacje internetowe uruchamiane są w ramach serwera web. Napisane w PHP np. działają jako moduł Apache HTTPD, natomiast aplikacje w Javie mogą być uruchomiane wewnątrz serwera aplikacji, np. Tomcat.

Aplikacja 12factor nie posiada zewnętrznych zależności co czyni ją niezależną wobec innych modułów znajdujących się na serwerze. Aplikacja internetowa udostępniać będzie np. HTTP w formie usługi przez przydzielenie portu. Umożliwia jej to obsługę zapytań przychodzących do wybranego portu.

Aby skorzystać z usługi udostępnionej przez aplikację, developer może otworzyć adres URL jak np. http://localhost:5000/. W przypadku aplikacji wdrożonej w środowisku produkcyjnym zapytania do udostępnionej publicznie nazwy hosta są obsługiwane przez warstwę nawigacji. Kierowane są one później do procesu sieciowego udostępnionego na danym porcie.

Kwestię obsługi takich zapytań można rozwiązać dodając bibliotekę webservera jako kolejną zewnętrzną zależność, jak np. Tornado w Pythonie, Thin w Ruby, lub Jetty dla Javy i innych języków opierających się na JVM. Obsługa zapytania jest całkowicie oprogramowana przez kod aplikacji, natomiast kontraktem ze środowiskiem wykonawczym jest przydzielenie portu w celu obsłużenia tego zapytania.

HTTP nie jest jedyną usługą, którą możną eksportować przez przydzielenie portu. Niemal każdy rodzaj oprogramowania serwerowego może być uruchomiony przez przydzielenie portu na którym jest uruchomiony proces i oczekiwać na przychodzące zapytania. Do przykładów należą ejabberd (komunikujący się przez XMPP), oraz Redis (komunikujący się przez Redis protocol).

Warto również zauważyć, że przez przydzielenie portu aplikacja może pełnić funkcję usługi wspierającej dla innej aplikacji przez udostępnienie swojego adresu URL jako adres zasobu w konfiguracji tejże aplikacji.\n\n\n\nVII. Vínculo de Portas

Exporte serviços via vínculo de portas

Apps web as vezes são executadas dentro de container de servidor web. Por exemplo, apps PHP podem rodar como um módulo dentro do Apache HTTPD, ou apps Java podem rodar dentro do Tomcat.

O aplicativo doze-fatores é completamente auto-contido e não depende de injeções de tempo de execução de um servidor web em um ambiente de execução para criar um serviço que defronte a web. O app web exporta o HTTP como um serviço através da vínculação a uma porta, e escuta as requisições que chegam na mesma.

Num ambiente de desenvolvimento local, o desenvolvedor visita a URL de um serviço como http://localhost:5000/ para acessar o serviço exportado pelo seu app. Num deploy, uma camada de roteamento manipula as requisições de rotas vindas de um hostname público para os processos web atrelados às portas.

Isso é tipicamente implementado usando declaração de dependências para adicionar uma biblioteca de servidor ao app, tal como Tornado para Python, Thin para Ruby, ou Jetty para Java e outra linguagens baseadas na JVM. Isso acontece completamente no espaço do usuário, isso é, dentro do código do app. O contrato com o ambiente de execução é vincular a uma porta para servir requisições.

HTTP não é o único serviço que pode ser exportado via vínculo de portas. Quase todos os tipos de software servidores podem rodar via um processo vinculado a uma porta e aguardar as requisições chegar. Exemplos incluem ejabberd (comunicando via XMPP), e Redis (comunicando via protocolo Redis).

Note que a abordagem de vincular portas significa que um app pode se tornar o serviço de apoio para um outro app, provendo a URL do app de apoio como um identificador de recurso na configuração para o app consumidor.\n\n\n\nVII. Привязка портов (Port binding)

Экспортируйте сервисы через привязку портов

Иногда веб-приложения запускают внутри контейнера веб-сервера. Например, PHP-приложение может быть запущено как модуль внутри Apache HTTPD, или Java-приложение может быть запущено внутри Tomcat.

Приложение двенадцати факторов является полностью самодостаточным и не полагается на инъекцию веб-сервера во время выполнения для того, чтобы создать веб-сервис. Веб-приложение экспортирует HTTP-сервис путём привязки к порту и прослушивает запросы, поступающих на этот порт.

Во время локальной разработки разработчик переходит по URL-адресу вида http://localhost:5000/, чтобы получить доступ к сервису, предоставляемым его приложением. При развёртывании слой маршрутизации обрабатывает запросы к общедоступному хосту и перенаправляет их к привязанному к порту веб приложению.

Это обычно реализуется с помощью объявления зависимости для добавления библиотеки веб-сервера к приложению такой, как Tornado в Python, Thin в Ruby, и Jetty в Java и других языках на основе JVM. Это происходит полностью в пространстве пользователя, то есть в коде приложения. Контрактом со средой исполнения является привязка приложения к порту для обработки запросов.

HTTP – это не единственный сервис, который может быть экспортирован посредством привязки порта. Почти любой тип серверного ПО может быть запущен как процесс, привязанный к порту и ожидающий входящих запросов. Примеры этого включают ejabberd (предоставляет XMPP протокол) и Redis (предоставляет Redis протокол).

Также обратите внимание, что подход привязки к порту означает, что одно приложение может выступать сторонней службой для другого приложения путём предоставления URL-адреса стороннего приложения как идентификатор ресурса в конфигурации потребляющего приложения.\n\n\n\nVII. Port binding

Export služieb cez port binding

Webové aplikácie sú niekedy vykonávané vnútri webserverového kontainera. Napríklad PHP aplikácie bežia ako modul vnútri Apache HTTPD, alebo Java aplikácie môžu bežať vnútri Tomcat.

Dvanásť faktorová aplikácia je úplne sebestačn a nespolieha sa na vsunutie webservera v exekučnom prostredí na to, aby vytvorila webovú službu. Webová aplikácia exportuje HTTP ako službu bindovaním na port, a počúvaním požiadaviek prichádzajúcich na daný port.

V lokálnom vývojárskom prostredí developer pristupuje na službu exportovanú jeho aplikáciou cez URL napríklad http://localhost:5000/. Pri nasadení, smerovacia vrstva presmerúva požiadavky z verejnej domény na port web procesu.

Toto sa typicky implementuje použitím deklarácie závislostí a pridá sa tak knižnica webservera do aplikácie. Napríklad Tornado pre Python, Thin pre Ruby, alebo Jetty pre Javu a iných jazykoch bežiacich na JVM. Deje sa to úplne v používateľskom priestore, takže v kóde aplikácie. Dohoda s exekučným prostredím je je bindovanie na port na ktorom bude obsluhovať požiadavky.

HTTP nie je jediná služba, ktorú je možné exportovať bindovaním na port. Skoro každý serverový softvér môže bežať na otvorenom porte a čakať na prichádzajúce požiadavky. Príklady zahŕňajú ejabberd (protokol XMPP), a Redis (protokol Redis).

Všimnite si, že pripojenie na port znamená, že aplikácia sa môže stať podpornou službou pre inú aplikáciu, poskytnutím URL na podpornú službu ako zdroj v configu pre konzumujúcu aplikáciu.\n\n\n\nVII. Port binding

นำออกบริการด้วยการเชื่อมโยง port

เว็บแอพ (Web App) บางครั้งทำงานข้างใน webserver container. ตัวอย่างเช่น PHP app จะทำงานเป็นโมดูลข้างใน Apache HTTPD หรือ Java app จะทำงานข้างใน Tomcat เป็นต้น

Twelve-factor app เป็น self-contained โดยสมบูรณ์ และไม่ขึ้นอยู่กับ runtime injection ของ webserver เข้ามายังสภาพแวดล้อมการดำเนินงานเพิ่อสร้าง web-facing service. เว็บแอพ นำออก HTTP เป็นบริการโดยเชื่อมโยงกับ port และคอยตรวจสอบ request ที่เข้ามาจาก port นั้น

นี้เป็นการทำงานปรกติโดยใช้ ประกาศการอ้างอิง เพื่อเพิ่ม webserver library ของ app, เช่น Tornado สำหรับ Python, Thin สำหรับ Ruby หรือ Jetty สำหรับ Java และภาษา JVM-based อื่นๆ เกิดขึ้นใน user space นั้นคือภายใน code ของ app ซึ่งสัญญากับสภาพแวดล้อมการดำเนินงานที่เชื่อมโยงกับ port เพื่อบริการ request ที่เข้ามา

HTTP ไม่เป็นเพียง service ที่สามารถนำออกโดยการเชื่อมโยง port, server software เกือบทุกชนิดสามารถทำงานผ่านการเชื่อมโยง process ไปยัง port และรอ request ที่เข้ามา, ตัวอย่างรวมทั้ง ejabberd](http://www.ejabberd.im/) (speaking XMPP), และ Redis (speaking the Redis protocol)

หมายเหตุ, วิธีการเชื่อมโยง port หมายความว่า app จะกลายเป็น backing service สำหรับ app อื่นๆ โดยการให้ URL กับ backing app เป็นตัวจัดการทรัพยากรใน การตั้งค่า สำหรับใช้งาน app\n\n\n\n