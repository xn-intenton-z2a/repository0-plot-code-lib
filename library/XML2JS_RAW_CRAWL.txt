node-xml2js
Ever had the urge to parse XML? And wanted to access the data in some sane,
easy way? Don't want to compile a C parser, for whatever reason? Then xml2js is
what you're looking for!
Description
Simple XML to JavaScript object converter. It supports bi-directional conversion.
Uses sax-js and
xmlbuilder-js.
Note: If you're looking for a full DOM parser, you probably want
JSDom.
Installation
Simplest way to install xml2js is to use npm, just npm install xml2js which will download xml2js and all dependencies.
xml2js is also available via Bower, just bower install xml2js which will download xml2js and all dependencies.
Usage
No extensive tutorials required because you are a smart developer! The task of
parsing XML should be an easy one, so let's make it so! Here's some examples.
Shoot-and-forget usage
You want to parse XML as simple and easy as possible? It's dangerous to go
alone, take this:
var parseString = require('xml2js').parseString;
var xml = "<root>Hello xml2js!</root>"
parseString(xml, function (err, result) {
    console.dir(result);
});
Can't get easier than this, right? This works starting with xml2js 0.2.3.
With CoffeeScript it looks like this:
{parseString} = require 'xml2js'
xml = "<root>Hello xml2js!</root>"
parseString xml, (err, result) ->
    console.dir result
If you need some special options, fear not, xml2js supports a number of
options (see below), you can specify these as second argument:
parseString(xml, {trim: true}, function (err, result) {
});
Simple as pie usage
That's right, if you have been using xml-simple or a home-grown
wrapper, this was added in 0.1.11 just for you:
var fs = require('fs'),
    xml2js = require('xml2js');

var parser = new xml2js.Parser();
fs.readFile(__dirname + '/foo.xml', function(err, data) {
    parser.parseString(data, function (err, result) {
        console.dir(result);
        console.log('Done');
    });
});
Look ma, no event listeners!
You can also use xml2js from
CoffeeScript, further reducing
the clutter:
fs = require 'fs',
xml2js = require 'xml2js'

parser = new xml2js.Parser()
fs.readFile __dirname + '/foo.xml', (err, data) ->
  parser.parseString data, (err, result) ->
    console.dir result
    console.log 'Done.'
But what happens if you forget the new keyword to create a new Parser? In
the middle of a nightly coding session, it might get lost, after all. Worry
not, we got you covered! Starting with 0.2.8 you can also leave it out, in
which case xml2js will helpfully add it for you, no bad surprises and
inexplicable bugs!
Promise usage
var xml2js = require('xml2js');
var xml = '<foo></foo>';

// With parser
var parser = new xml2js.Parser(/* options */);
parser.parseStringPromise(xml).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});

// Without parser
xml2js.parseStringPromise(xml /*, options */).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});
Parsing multiple files
If you want to parse multiple files, you have multiple possibilities:

You can create one xml2js.Parser per file. That's the recommended one
and is promised to always just work.
You can call reset() on your parser object.
You can hope everything goes well anyway. This behaviour is not
guaranteed work always, if ever. Use option #1 if possible. Thanks!

So you wanna some JSON?
Just wrap the result object in a call to JSON.stringify like this
JSON.stringify(result). You get a string containing the JSON representation
of the parsed object that you can feed to JSON-hungry consumers.
Displaying results
You might wonder why, using console.dir or console.log the output at some
level is only [Object]. Don't worry, this is not because xml2js got lazy.
That's because Node uses util.inspect to convert the object into strings and
that function stops after depth=2 which is a bit low for most XML.
To display the whole deal, you can use console.log(util.inspect(result, false, null)), which displays the whole result.
So much for that, but what if you use
eyes for nice colored output and it
truncates the output with …? Don't fear, there's also a solution for that,
you just need to increase the maxLength limit by creating a custom inspector
var inspect = require('eyes').inspector({maxLength: false}) and then you can
easily inspect(result).
XML builder usage
Since 0.4.0, objects can be also be used to build XML:
var xml2js = require('xml2js');

var obj = {name: "Super", Surname: "Man", age: 23};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root>
  <name>Super</name>
  <Surname>Man</Surname>
  <age>23</age>
</root>
At the moment, a one to one bi-directional conversion is guaranteed only for
default configuration, except for attrkey, charkey and explicitArray options
you can redefine to your taste. Writing CDATA is supported via setting the cdata
option to true.
To specify attributes:
var xml2js = require('xml2js');

var obj = {root: {$: {id: "my id"}, _: "my inner text"}};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root id="my id">my inner text</root>
Adding xmlns attributes
You can generate XML that declares XML namespace prefix / URI pairs with xmlns attributes.
Example declaring a default namespace on the root element:
let obj = { 
  Foo: {
    $: {
      "xmlns": "http://foo.com"
    }   
  }
};  
Result of buildObject(obj):
<Foo xmlns="http://foo.com"/>
Example declaring non-default namespaces on non-root elements:
let obj = {
  'foo:Foo': {
    $: {
      'xmlns:foo': 'http://foo.com'
    },
    'bar:Bar': {
      $: {
        'xmlns:bar': 'http://bar.com'
      }
    }
  }
}
Result of buildObject(obj):
<foo:Foo xmlns:foo="http://foo.com">
  <bar:Bar xmlns:bar="http://bar.com"/>
</foo:Foo>
Processing attribute, tag names and values
Since 0.4.1 you can optionally provide the parser with attribute name and tag name processors as well as element value processors (Since 0.4.14, you can also optionally provide the parser with attribute value processors):
function nameToUpperCase(name){
    return name.toUpperCase();
}

//transform all attribute and tag names and values to uppercase
parseString(xml, {
  tagNameProcessors: [nameToUpperCase],
  attrNameProcessors: [nameToUpperCase],
  valueProcessors: [nameToUpperCase],
  attrValueProcessors: [nameToUpperCase]},
  function (err, result) {
    // processed data
});
The tagNameProcessors and attrNameProcessors options
accept an Array of functions with the following signature:
function (name){
  //do something with `name`
  return name
}
The attrValueProcessors and valueProcessors options
accept an Array of functions with the following signature:
function (value, name) {
  //`name` will be the node name or attribute name
  //do something with `value`, (optionally) dependent on the node/attr name
  return value
}
Some processors are provided out-of-the-box and can be found in lib/processors.js:


normalize: transforms the name to lowercase.
(Automatically used when options.normalize is set to true)


firstCharLowerCase: transforms the first character to lower case.
E.g. 'MyTagName' becomes 'myTagName'


stripPrefix: strips the xml namespace prefix. E.g <foo:Bar/> will become 'Bar'.
(N.B.: the xmlns prefix is NOT stripped.)


parseNumbers: parses integer-like strings as integers and float-like strings as floats
E.g. "0" becomes 0 and "15.56" becomes 15.56


parseBooleans: parses boolean-like strings to booleans
E.g. "true" becomes true and "False" becomes false


Options
Apart from the default settings, there are a number of options that can be
specified for the parser. Options are specified by new Parser({optionName: value}). Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

explicitCharkey (default: false) Determines whether or not to use
a charkey prefix for elements with no attributes.

trim (default: false): Trim the whitespace at the beginning and end of
text nodes.

normalizeTags (default: false): Normalize all tag names to lowercase.

normalize (default: false): Trim whitespaces inside text nodes.

explicitRoot (default: true): Set this if you want to get the root
node in the resulting object.

emptyTag (default: ''): what will the value of empty nodes be. In case
you want to use an empty object as a default value, it is better to provide a factory
function () => ({}) instead. Without this function a plain object would
become a shared reference across all occurrences with unwanted behavior.

explicitArray (default: true): Always put child nodes in an array if
true; otherwise an array is created only if there is more than one.

ignoreAttrs (default: false): Ignore all XML attributes and only create
text nodes.

mergeAttrs (default: false): Merge attributes and child elements as
properties of the parent, instead of keying attributes off a child
attribute object. This option is ignored if ignoreAttrs is true.

validator (default null): You can specify a callable that validates
the resulting structure somehow, however you want. See unit tests
for an example.

xmlns (default false): Give each element a field usually called '$ns'
(the first character is the same as attrkey) that contains its local name
and namespace URI.

explicitChildren (default false): Put child elements to separate
property. Doesn't work with mergeAttrs = true. If element has no children
then "children" won't be created. Added in 0.2.5.

childkey (default $$): Prefix that is used to access child elements if
explicitChildren is set to true. Added in 0.2.5.

preserveChildrenOrder (default false): Modifies the behavior of
explicitChildren so that the value of the "children" property becomes an
ordered array. When this is true, every node will also get a #name field
whose value will correspond to the XML nodeName, so that you may iterate
the "children" array and still be able to determine node names. The named
(and potentially unordered) properties are also retained in this
configuration at the same level as the ordered "children" array. Added in
0.4.9.

charsAsChildren (default false): Determines whether chars should be
considered children if explicitChildren is on. Added in 0.2.5.

includeWhiteChars (default false): Determines whether whitespace-only
text nodes should be included. Added in 0.4.17.

async (default false): Should the callbacks be async? This might be
an incompatible change if your code depends on sync execution of callbacks.
Future versions of xml2js might change this default, so the recommendation
is to not depend on sync execution anyway. Added in 0.2.6.

strict (default true): Set sax-js to strict or non-strict parsing mode.
Defaults to true which is highly recommended, since parsing HTML which
is not well-formed XML might yield just about anything. Added in 0.2.7.

attrNameProcessors (default: null): Allows the addition of attribute
name processing functions. Accepts an Array of functions with following
signature:
function (name){
    //do something with `name`
    return name
}
Added in 0.4.14

attrValueProcessors (default: null): Allows the addition of attribute
value processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.1

tagNameProcessors (default: null): Allows the addition of tag name
processing functions. Accepts an Array of functions with following
signature:
function (name){
  //do something with `name`
  return name
}
Added in 0.4.1

valueProcessors (default: null): Allows the addition of element value
processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.6

Options for the Builder class
These options are specified by new Builder({optionName: value}).
Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

rootName (default root or the root key name): root element name to be used in case
explicitRoot is false or to override the root element name.

renderOpts (default { 'pretty': true, 'indent': '  ', 'newline': '\n' }):
Rendering options for xmlbuilder-js.

pretty: prettify generated XML
indent: whitespace for indentation (only when pretty)
newline: newline char (only when pretty)



xmldec (default { 'version': '1.0', 'encoding': 'UTF-8', 'standalone': true }:
XML declaration attributes.


xmldec.version A version number string, e.g. 1.0

xmldec.encoding Encoding declaration, e.g. UTF-8

xmldec.standalone standalone document declaration: true or false



doctype (default null): optional DTD. Eg. {'ext': 'hello.dtd'}


headless (default: false): omit the XML header. Added in 0.4.3.

allowSurrogateChars (default: false): allows using characters from the Unicode
surrogate blocks.

cdata (default: false): wrap text nodes in <![CDATA[ ... ]]> instead of
escaping when necessary. Does not add <![CDATA[ ... ]]> if it is not required.
Added in 0.4.5.

renderOpts, xmldec,doctype and headless pass through to
xmlbuilder-js.
Updating to new version
Version 0.2 changed the default parsing settings, but version 0.1.14 introduced
the default settings for version 0.2, so these settings can be tried before the
migration.
var xml2js = require('xml2js');
var parser = new xml2js.Parser(xml2js.defaults["0.2"]);
To get the 0.1 defaults in version 0.2 you can just use
xml2js.defaults["0.1"] in the same place. This provides you with enough time
to migrate to the saner way of parsing in xml2js 0.2. We try to make the
migration as simple and gentle as possible, but some breakage cannot be
avoided.
So, what exactly did change and why? In 0.2 we changed some defaults to parse
the XML in a more universal and sane way. So we disabled normalize and trim
so xml2js does not cut out any text content. You can reenable this at will of
course. A more important change is that we return the root tag in the resulting
JavaScript structure via the explicitRoot setting, so you need to access the
first element. This is useful for anybody who wants to know what the root node
is and preserves more information. The last major change was to enable
explicitArray, so everytime it is possible that one might embed more than one
sub-tag into a tag, xml2js >= 0.2 returns an array even if the array just
includes one element. This is useful when dealing with APIs that return
variable amounts of subtags.
Running tests, development



The development requirements are handled by npm, you just need to install them.
We also have a number of unit tests, they can be run using npm test directly
from the project root. This runs zap to discover all the tests and execute
them.
If you like to contribute, keep in mind that xml2js is written in
CoffeeScript, so don't develop on the JavaScript files that are checked into
the repository for convenience reasons. Also, please write some unit test to
check your behaviour and if it is some user-facing thing, add some
documentation to this README, so people will know it exists. Thanks in advance!
Getting support
Please, if you have a problem with the library, first make sure you read this
README. If you read this far, thanks, you're good. Then, please make sure your
problem really is with xml2js. It is? Okay, then I'll look at it. Send me a
mail and we can talk. Please don't open issues, as I don't think that is the
proper forum for support problems. Some problems might as well really be bugs
in xml2js, if so I'll let you know to open an issue instead :)
But if you know you really found a bug, feel free to open an issue instead.\n\nxml2js0.6.2 • Public • Published 2 years ago ReadmeCode Beta2 Dependencies10,262 Dependents52 Versionsnode-xml2js
Ever had the urge to parse XML? And wanted to access the data in some sane,
easy way? Don't want to compile a C parser, for whatever reason? Then xml2js is
what you're looking for!
Description
Simple XML to JavaScript object converter. It supports bi-directional conversion.
Uses sax-js and
xmlbuilder-js.
Note: If you're looking for a full DOM parser, you probably want
JSDom.
Installation
Simplest way to install xml2js is to use npm, just npm install xml2js which will download xml2js and all dependencies.
xml2js is also available via Bower, just bower install xml2js which will download xml2js and all dependencies.
Usage
No extensive tutorials required because you are a smart developer! The task of
parsing XML should be an easy one, so let's make it so! Here's some examples.
Shoot-and-forget usage
You want to parse XML as simple and easy as possible? It's dangerous to go
alone, take this:
var parseString = require('xml2js').parseString;
var xml = "<root>Hello xml2js!</root>"
parseString(xml, function (err, result) {
    console.dir(result);
});
Can't get easier than this, right? This works starting with xml2js 0.2.3.
With CoffeeScript it looks like this:
{parseString} = require 'xml2js'
xml = "<root>Hello xml2js!</root>"
parseString xml, (err, result) ->
    console.dir result
If you need some special options, fear not, xml2js supports a number of
options (see below), you can specify these as second argument:
parseString(xml, {trim: true}, function (err, result) {
});
Simple as pie usage
That's right, if you have been using xml-simple or a home-grown
wrapper, this was added in 0.1.11 just for you:
var fs = require('fs'),
    xml2js = require('xml2js');

var parser = new xml2js.Parser();
fs.readFile(__dirname + '/foo.xml', function(err, data) {
    parser.parseString(data, function (err, result) {
        console.dir(result);
        console.log('Done');
    });
});
Look ma, no event listeners!
You can also use xml2js from
CoffeeScript, further reducing
the clutter:
fs = require 'fs',
xml2js = require 'xml2js'

parser = new xml2js.Parser()
fs.readFile __dirname + '/foo.xml', (err, data) ->
  parser.parseString data, (err, result) ->
    console.dir result
    console.log 'Done.'
But what happens if you forget the new keyword to create a new Parser? In
the middle of a nightly coding session, it might get lost, after all. Worry
not, we got you covered! Starting with 0.2.8 you can also leave it out, in
which case xml2js will helpfully add it for you, no bad surprises and
inexplicable bugs!
Promise usage
var xml2js = require('xml2js');
var xml = '<foo></foo>';

// With parser
var parser = new xml2js.Parser(/* options */);
parser.parseStringPromise(xml).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});

// Without parser
xml2js.parseStringPromise(xml /*, options */).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});
Parsing multiple files
If you want to parse multiple files, you have multiple possibilities:

You can create one xml2js.Parser per file. That's the recommended one
and is promised to always just work.
You can call reset() on your parser object.
You can hope everything goes well anyway. This behaviour is not
guaranteed work always, if ever. Use option #1 if possible. Thanks!

So you wanna some JSON?
Just wrap the result object in a call to JSON.stringify like this
JSON.stringify(result). You get a string containing the JSON representation
of the parsed object that you can feed to JSON-hungry consumers.
Displaying results
You might wonder why, using console.dir or console.log the output at some
level is only [Object]. Don't worry, this is not because xml2js got lazy.
That's because Node uses util.inspect to convert the object into strings and
that function stops after depth=2 which is a bit low for most XML.
To display the whole deal, you can use console.log(util.inspect(result, false, null)), which displays the whole result.
So much for that, but what if you use
eyes for nice colored output and it
truncates the output with …? Don't fear, there's also a solution for that,
you just need to increase the maxLength limit by creating a custom inspector
var inspect = require('eyes').inspector({maxLength: false}) and then you can
easily inspect(result).
XML builder usage
Since 0.4.0, objects can be also be used to build XML:
var xml2js = require('xml2js');

var obj = {name: "Super", Surname: "Man", age: 23};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root>
  <name>Super</name>
  <Surname>Man</Surname>
  <age>23</age>
</root>
At the moment, a one to one bi-directional conversion is guaranteed only for
default configuration, except for attrkey, charkey and explicitArray options
you can redefine to your taste. Writing CDATA is supported via setting the cdata
option to true.
To specify attributes:
var xml2js = require('xml2js');

var obj = {root: {$: {id: "my id"}, _: "my inner text"}};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root id="my id">my inner text</root>
Adding xmlns attributes
You can generate XML that declares XML namespace prefix / URI pairs with xmlns attributes.
Example declaring a default namespace on the root element:
let obj = { 
  Foo: {
    $: {
      "xmlns": "http://foo.com"
    }   
  }
};  
Result of buildObject(obj):
<Foo xmlns="http://foo.com"/>
Example declaring non-default namespaces on non-root elements:
let obj = {
  'foo:Foo': {
    $: {
      'xmlns:foo': 'http://foo.com'
    },
    'bar:Bar': {
      $: {
        'xmlns:bar': 'http://bar.com'
      }
    }
  }
}
Result of buildObject(obj):
<foo:Foo xmlns:foo="http://foo.com">
  <bar:Bar xmlns:bar="http://bar.com"/>
</foo:Foo>
Processing attribute, tag names and values
Since 0.4.1 you can optionally provide the parser with attribute name and tag name processors as well as element value processors (Since 0.4.14, you can also optionally provide the parser with attribute value processors):
function nameToUpperCase(name){
    return name.toUpperCase();
}

//transform all attribute and tag names and values to uppercase
parseString(xml, {
  tagNameProcessors: [nameToUpperCase],
  attrNameProcessors: [nameToUpperCase],
  valueProcessors: [nameToUpperCase],
  attrValueProcessors: [nameToUpperCase]},
  function (err, result) {
    // processed data
});
The tagNameProcessors and attrNameProcessors options
accept an Array of functions with the following signature:
function (name){
  //do something with `name`
  return name
}
The attrValueProcessors and valueProcessors options
accept an Array of functions with the following signature:
function (value, name) {
  //`name` will be the node name or attribute name
  //do something with `value`, (optionally) dependent on the node/attr name
  return value
}
Some processors are provided out-of-the-box and can be found in lib/processors.js:


normalize: transforms the name to lowercase.
(Automatically used when options.normalize is set to true)


firstCharLowerCase: transforms the first character to lower case.
E.g. 'MyTagName' becomes 'myTagName'


stripPrefix: strips the xml namespace prefix. E.g <foo:Bar/> will become 'Bar'.
(N.B.: the xmlns prefix is NOT stripped.)


parseNumbers: parses integer-like strings as integers and float-like strings as floats
E.g. "0" becomes 0 and "15.56" becomes 15.56


parseBooleans: parses boolean-like strings to booleans
E.g. "true" becomes true and "False" becomes false


Options
Apart from the default settings, there are a number of options that can be
specified for the parser. Options are specified by new Parser({optionName: value}). Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

explicitCharkey (default: false) Determines whether or not to use
a charkey prefix for elements with no attributes.

trim (default: false): Trim the whitespace at the beginning and end of
text nodes.

normalizeTags (default: false): Normalize all tag names to lowercase.

normalize (default: false): Trim whitespaces inside text nodes.

explicitRoot (default: true): Set this if you want to get the root
node in the resulting object.

emptyTag (default: ''): what will the value of empty nodes be. In case
you want to use an empty object as a default value, it is better to provide a factory
function () => ({}) instead. Without this function a plain object would
become a shared reference across all occurrences with unwanted behavior.

explicitArray (default: true): Always put child nodes in an array if
true; otherwise an array is created only if there is more than one.

ignoreAttrs (default: false): Ignore all XML attributes and only create
text nodes.

mergeAttrs (default: false): Merge attributes and child elements as
properties of the parent, instead of keying attributes off a child
attribute object. This option is ignored if ignoreAttrs is true.

validator (default null): You can specify a callable that validates
the resulting structure somehow, however you want. See unit tests
for an example.

xmlns (default false): Give each element a field usually called '$ns'
(the first character is the same as attrkey) that contains its local name
and namespace URI.

explicitChildren (default false): Put child elements to separate
property. Doesn't work with mergeAttrs = true. If element has no children
then "children" won't be created. Added in 0.2.5.

childkey (default $$): Prefix that is used to access child elements if
explicitChildren is set to true. Added in 0.2.5.

preserveChildrenOrder (default false): Modifies the behavior of
explicitChildren so that the value of the "children" property becomes an
ordered array. When this is true, every node will also get a #name field
whose value will correspond to the XML nodeName, so that you may iterate
the "children" array and still be able to determine node names. The named
(and potentially unordered) properties are also retained in this
configuration at the same level as the ordered "children" array. Added in
0.4.9.

charsAsChildren (default false): Determines whether chars should be
considered children if explicitChildren is on. Added in 0.2.5.

includeWhiteChars (default false): Determines whether whitespace-only
text nodes should be included. Added in 0.4.17.

async (default false): Should the callbacks be async? This might be
an incompatible change if your code depends on sync execution of callbacks.
Future versions of xml2js might change this default, so the recommendation
is to not depend on sync execution anyway. Added in 0.2.6.

strict (default true): Set sax-js to strict or non-strict parsing mode.
Defaults to true which is highly recommended, since parsing HTML which
is not well-formed XML might yield just about anything. Added in 0.2.7.

attrNameProcessors (default: null): Allows the addition of attribute
name processing functions. Accepts an Array of functions with following
signature:
function (name){
    //do something with `name`
    return name
}
Added in 0.4.14

attrValueProcessors (default: null): Allows the addition of attribute
value processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.1

tagNameProcessors (default: null): Allows the addition of tag name
processing functions. Accepts an Array of functions with following
signature:
function (name){
  //do something with `name`
  return name
}
Added in 0.4.1

valueProcessors (default: null): Allows the addition of element value
processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.6

Options for the Builder class
These options are specified by new Builder({optionName: value}).
Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

rootName (default root or the root key name): root element name to be used in case
explicitRoot is false or to override the root element name.

renderOpts (default { 'pretty': true, 'indent': '  ', 'newline': '\n' }):
Rendering options for xmlbuilder-js.

pretty: prettify generated XML
indent: whitespace for indentation (only when pretty)
newline: newline char (only when pretty)



xmldec (default { 'version': '1.0', 'encoding': 'UTF-8', 'standalone': true }:
XML declaration attributes.


xmldec.version A version number string, e.g. 1.0

xmldec.encoding Encoding declaration, e.g. UTF-8

xmldec.standalone standalone document declaration: true or false



doctype (default null): optional DTD. Eg. {'ext': 'hello.dtd'}


headless (default: false): omit the XML header. Added in 0.4.3.

allowSurrogateChars (default: false): allows using characters from the Unicode
surrogate blocks.

cdata (default: false): wrap text nodes in <![CDATA[ ... ]]> instead of
escaping when necessary. Does not add <![CDATA[ ... ]]> if it is not required.
Added in 0.4.5.

renderOpts, xmldec,doctype and headless pass through to
xmlbuilder-js.
Updating to new version
Version 0.2 changed the default parsing settings, but version 0.1.14 introduced
the default settings for version 0.2, so these settings can be tried before the
migration.
var xml2js = require('xml2js');
var parser = new xml2js.Parser(xml2js.defaults["0.2"]);
To get the 0.1 defaults in version 0.2 you can just use
xml2js.defaults["0.1"] in the same place. This provides you with enough time
to migrate to the saner way of parsing in xml2js 0.2. We try to make the
migration as simple and gentle as possible, but some breakage cannot be
avoided.
So, what exactly did change and why? In 0.2 we changed some defaults to parse
the XML in a more universal and sane way. So we disabled normalize and trim
so xml2js does not cut out any text content. You can reenable this at will of
course. A more important change is that we return the root tag in the resulting
JavaScript structure via the explicitRoot setting, so you need to access the
first element. This is useful for anybody who wants to know what the root node
is and preserves more information. The last major change was to enable
explicitArray, so everytime it is possible that one might embed more than one
sub-tag into a tag, xml2js >= 0.2 returns an array even if the array just
includes one element. This is useful when dealing with APIs that return
variable amounts of subtags.
Running tests, development



The development requirements are handled by npm, you just need to install them.
We also have a number of unit tests, they can be run using npm test directly
from the project root. This runs zap to discover all the tests and execute
them.
If you like to contribute, keep in mind that xml2js is written in
CoffeeScript, so don't develop on the JavaScript files that are checked into
the repository for convenience reasons. Also, please write some unit test to
check your behaviour and if it is some user-facing thing, add some
documentation to this README, so people will know it exists. Thanks in advance!
Getting support
Please, if you have a problem with the library, first make sure you read this
README. If you read this far, thanks, you're good. Then, please make sure your
problem really is with xml2js. It is? Okay, then I'll look at it. Send me a
mail and we can talk. Please don't open issues, as I don't think that is the
proper forum for support problems. Some problems might as well really be bugs
in xml2js, if so I'll let you know to open an issue instead :)
But if you know you really found a bug, feel free to open an issue instead.
ReadmeKeywordsxmljsonPackage SidebarInstallnpm i xml2jsRepositorygithub.com/Leonidas-from-XIV/node-xml2jsHomepagegithub.com/Leonidas-from-XIV/node-xml2jsWeekly Downloads22,667,333Version0.6.2LicenseMITUnpacked Size3.44 MBTotal Files10Last publish2 years agoCollaboratorsTry on RunKitReport malware\n\nxml2js0.6.2 • Public • Published 2 years ago ReadmeCode Beta2 Dependencies10,262 Dependents52 Versionsnode-xml2js
Ever had the urge to parse XML? And wanted to access the data in some sane,
easy way? Don't want to compile a C parser, for whatever reason? Then xml2js is
what you're looking for!
Description
Simple XML to JavaScript object converter. It supports bi-directional conversion.
Uses sax-js and
xmlbuilder-js.
Note: If you're looking for a full DOM parser, you probably want
JSDom.
Installation
Simplest way to install xml2js is to use npm, just npm install xml2js which will download xml2js and all dependencies.
xml2js is also available via Bower, just bower install xml2js which will download xml2js and all dependencies.
Usage
No extensive tutorials required because you are a smart developer! The task of
parsing XML should be an easy one, so let's make it so! Here's some examples.
Shoot-and-forget usage
You want to parse XML as simple and easy as possible? It's dangerous to go
alone, take this:
var parseString = require('xml2js').parseString;
var xml = "<root>Hello xml2js!</root>"
parseString(xml, function (err, result) {
    console.dir(result);
});
Can't get easier than this, right? This works starting with xml2js 0.2.3.
With CoffeeScript it looks like this:
{parseString} = require 'xml2js'
xml = "<root>Hello xml2js!</root>"
parseString xml, (err, result) ->
    console.dir result
If you need some special options, fear not, xml2js supports a number of
options (see below), you can specify these as second argument:
parseString(xml, {trim: true}, function (err, result) {
});
Simple as pie usage
That's right, if you have been using xml-simple or a home-grown
wrapper, this was added in 0.1.11 just for you:
var fs = require('fs'),
    xml2js = require('xml2js');

var parser = new xml2js.Parser();
fs.readFile(__dirname + '/foo.xml', function(err, data) {
    parser.parseString(data, function (err, result) {
        console.dir(result);
        console.log('Done');
    });
});
Look ma, no event listeners!
You can also use xml2js from
CoffeeScript, further reducing
the clutter:
fs = require 'fs',
xml2js = require 'xml2js'

parser = new xml2js.Parser()
fs.readFile __dirname + '/foo.xml', (err, data) ->
  parser.parseString data, (err, result) ->
    console.dir result
    console.log 'Done.'
But what happens if you forget the new keyword to create a new Parser? In
the middle of a nightly coding session, it might get lost, after all. Worry
not, we got you covered! Starting with 0.2.8 you can also leave it out, in
which case xml2js will helpfully add it for you, no bad surprises and
inexplicable bugs!
Promise usage
var xml2js = require('xml2js');
var xml = '<foo></foo>';

// With parser
var parser = new xml2js.Parser(/* options */);
parser.parseStringPromise(xml).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});

// Without parser
xml2js.parseStringPromise(xml /*, options */).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});
Parsing multiple files
If you want to parse multiple files, you have multiple possibilities:

You can create one xml2js.Parser per file. That's the recommended one
and is promised to always just work.
You can call reset() on your parser object.
You can hope everything goes well anyway. This behaviour is not
guaranteed work always, if ever. Use option #1 if possible. Thanks!

So you wanna some JSON?
Just wrap the result object in a call to JSON.stringify like this
JSON.stringify(result). You get a string containing the JSON representation
of the parsed object that you can feed to JSON-hungry consumers.
Displaying results
You might wonder why, using console.dir or console.log the output at some
level is only [Object]. Don't worry, this is not because xml2js got lazy.
That's because Node uses util.inspect to convert the object into strings and
that function stops after depth=2 which is a bit low for most XML.
To display the whole deal, you can use console.log(util.inspect(result, false, null)), which displays the whole result.
So much for that, but what if you use
eyes for nice colored output and it
truncates the output with …? Don't fear, there's also a solution for that,
you just need to increase the maxLength limit by creating a custom inspector
var inspect = require('eyes').inspector({maxLength: false}) and then you can
easily inspect(result).
XML builder usage
Since 0.4.0, objects can be also be used to build XML:
var xml2js = require('xml2js');

var obj = {name: "Super", Surname: "Man", age: 23};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root>
  <name>Super</name>
  <Surname>Man</Surname>
  <age>23</age>
</root>
At the moment, a one to one bi-directional conversion is guaranteed only for
default configuration, except for attrkey, charkey and explicitArray options
you can redefine to your taste. Writing CDATA is supported via setting the cdata
option to true.
To specify attributes:
var xml2js = require('xml2js');

var obj = {root: {$: {id: "my id"}, _: "my inner text"}};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root id="my id">my inner text</root>
Adding xmlns attributes
You can generate XML that declares XML namespace prefix / URI pairs with xmlns attributes.
Example declaring a default namespace on the root element:
let obj = { 
  Foo: {
    $: {
      "xmlns": "http://foo.com"
    }   
  }
};  
Result of buildObject(obj):
<Foo xmlns="http://foo.com"/>
Example declaring non-default namespaces on non-root elements:
let obj = {
  'foo:Foo': {
    $: {
      'xmlns:foo': 'http://foo.com'
    },
    'bar:Bar': {
      $: {
        'xmlns:bar': 'http://bar.com'
      }
    }
  }
}
Result of buildObject(obj):
<foo:Foo xmlns:foo="http://foo.com">
  <bar:Bar xmlns:bar="http://bar.com"/>
</foo:Foo>
Processing attribute, tag names and values
Since 0.4.1 you can optionally provide the parser with attribute name and tag name processors as well as element value processors (Since 0.4.14, you can also optionally provide the parser with attribute value processors):
function nameToUpperCase(name){
    return name.toUpperCase();
}

//transform all attribute and tag names and values to uppercase
parseString(xml, {
  tagNameProcessors: [nameToUpperCase],
  attrNameProcessors: [nameToUpperCase],
  valueProcessors: [nameToUpperCase],
  attrValueProcessors: [nameToUpperCase]},
  function (err, result) {
    // processed data
});
The tagNameProcessors and attrNameProcessors options
accept an Array of functions with the following signature:
function (name){
  //do something with `name`
  return name
}
The attrValueProcessors and valueProcessors options
accept an Array of functions with the following signature:
function (value, name) {
  //`name` will be the node name or attribute name
  //do something with `value`, (optionally) dependent on the node/attr name
  return value
}
Some processors are provided out-of-the-box and can be found in lib/processors.js:


normalize: transforms the name to lowercase.
(Automatically used when options.normalize is set to true)


firstCharLowerCase: transforms the first character to lower case.
E.g. 'MyTagName' becomes 'myTagName'


stripPrefix: strips the xml namespace prefix. E.g <foo:Bar/> will become 'Bar'.
(N.B.: the xmlns prefix is NOT stripped.)


parseNumbers: parses integer-like strings as integers and float-like strings as floats
E.g. "0" becomes 0 and "15.56" becomes 15.56


parseBooleans: parses boolean-like strings to booleans
E.g. "true" becomes true and "False" becomes false


Options
Apart from the default settings, there are a number of options that can be
specified for the parser. Options are specified by new Parser({optionName: value}). Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

explicitCharkey (default: false) Determines whether or not to use
a charkey prefix for elements with no attributes.

trim (default: false): Trim the whitespace at the beginning and end of
text nodes.

normalizeTags (default: false): Normalize all tag names to lowercase.

normalize (default: false): Trim whitespaces inside text nodes.

explicitRoot (default: true): Set this if you want to get the root
node in the resulting object.

emptyTag (default: ''): what will the value of empty nodes be. In case
you want to use an empty object as a default value, it is better to provide a factory
function () => ({}) instead. Without this function a plain object would
become a shared reference across all occurrences with unwanted behavior.

explicitArray (default: true): Always put child nodes in an array if
true; otherwise an array is created only if there is more than one.

ignoreAttrs (default: false): Ignore all XML attributes and only create
text nodes.

mergeAttrs (default: false): Merge attributes and child elements as
properties of the parent, instead of keying attributes off a child
attribute object. This option is ignored if ignoreAttrs is true.

validator (default null): You can specify a callable that validates
the resulting structure somehow, however you want. See unit tests
for an example.

xmlns (default false): Give each element a field usually called '$ns'
(the first character is the same as attrkey) that contains its local name
and namespace URI.

explicitChildren (default false): Put child elements to separate
property. Doesn't work with mergeAttrs = true. If element has no children
then "children" won't be created. Added in 0.2.5.

childkey (default $$): Prefix that is used to access child elements if
explicitChildren is set to true. Added in 0.2.5.

preserveChildrenOrder (default false): Modifies the behavior of
explicitChildren so that the value of the "children" property becomes an
ordered array. When this is true, every node will also get a #name field
whose value will correspond to the XML nodeName, so that you may iterate
the "children" array and still be able to determine node names. The named
(and potentially unordered) properties are also retained in this
configuration at the same level as the ordered "children" array. Added in
0.4.9.

charsAsChildren (default false): Determines whether chars should be
considered children if explicitChildren is on. Added in 0.2.5.

includeWhiteChars (default false): Determines whether whitespace-only
text nodes should be included. Added in 0.4.17.

async (default false): Should the callbacks be async? This might be
an incompatible change if your code depends on sync execution of callbacks.
Future versions of xml2js might change this default, so the recommendation
is to not depend on sync execution anyway. Added in 0.2.6.

strict (default true): Set sax-js to strict or non-strict parsing mode.
Defaults to true which is highly recommended, since parsing HTML which
is not well-formed XML might yield just about anything. Added in 0.2.7.

attrNameProcessors (default: null): Allows the addition of attribute
name processing functions. Accepts an Array of functions with following
signature:
function (name){
    //do something with `name`
    return name
}
Added in 0.4.14

attrValueProcessors (default: null): Allows the addition of attribute
value processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.1

tagNameProcessors (default: null): Allows the addition of tag name
processing functions. Accepts an Array of functions with following
signature:
function (name){
  //do something with `name`
  return name
}
Added in 0.4.1

valueProcessors (default: null): Allows the addition of element value
processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.6

Options for the Builder class
These options are specified by new Builder({optionName: value}).
Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

rootName (default root or the root key name): root element name to be used in case
explicitRoot is false or to override the root element name.

renderOpts (default { 'pretty': true, 'indent': '  ', 'newline': '\n' }):
Rendering options for xmlbuilder-js.

pretty: prettify generated XML
indent: whitespace for indentation (only when pretty)
newline: newline char (only when pretty)



xmldec (default { 'version': '1.0', 'encoding': 'UTF-8', 'standalone': true }:
XML declaration attributes.


xmldec.version A version number string, e.g. 1.0

xmldec.encoding Encoding declaration, e.g. UTF-8

xmldec.standalone standalone document declaration: true or false



doctype (default null): optional DTD. Eg. {'ext': 'hello.dtd'}


headless (default: false): omit the XML header. Added in 0.4.3.

allowSurrogateChars (default: false): allows using characters from the Unicode
surrogate blocks.

cdata (default: false): wrap text nodes in <![CDATA[ ... ]]> instead of
escaping when necessary. Does not add <![CDATA[ ... ]]> if it is not required.
Added in 0.4.5.

renderOpts, xmldec,doctype and headless pass through to
xmlbuilder-js.
Updating to new version
Version 0.2 changed the default parsing settings, but version 0.1.14 introduced
the default settings for version 0.2, so these settings can be tried before the
migration.
var xml2js = require('xml2js');
var parser = new xml2js.Parser(xml2js.defaults["0.2"]);
To get the 0.1 defaults in version 0.2 you can just use
xml2js.defaults["0.1"] in the same place. This provides you with enough time
to migrate to the saner way of parsing in xml2js 0.2. We try to make the
migration as simple and gentle as possible, but some breakage cannot be
avoided.
So, what exactly did change and why? In 0.2 we changed some defaults to parse
the XML in a more universal and sane way. So we disabled normalize and trim
so xml2js does not cut out any text content. You can reenable this at will of
course. A more important change is that we return the root tag in the resulting
JavaScript structure via the explicitRoot setting, so you need to access the
first element. This is useful for anybody who wants to know what the root node
is and preserves more information. The last major change was to enable
explicitArray, so everytime it is possible that one might embed more than one
sub-tag into a tag, xml2js >= 0.2 returns an array even if the array just
includes one element. This is useful when dealing with APIs that return
variable amounts of subtags.
Running tests, development



The development requirements are handled by npm, you just need to install them.
We also have a number of unit tests, they can be run using npm test directly
from the project root. This runs zap to discover all the tests and execute
them.
If you like to contribute, keep in mind that xml2js is written in
CoffeeScript, so don't develop on the JavaScript files that are checked into
the repository for convenience reasons. Also, please write some unit test to
check your behaviour and if it is some user-facing thing, add some
documentation to this README, so people will know it exists. Thanks in advance!
Getting support
Please, if you have a problem with the library, first make sure you read this
README. If you read this far, thanks, you're good. Then, please make sure your
problem really is with xml2js. It is? Okay, then I'll look at it. Send me a
mail and we can talk. Please don't open issues, as I don't think that is the
proper forum for support problems. Some problems might as well really be bugs
in xml2js, if so I'll let you know to open an issue instead :)
But if you know you really found a bug, feel free to open an issue instead.
ReadmeKeywordsxmljsonPackage SidebarInstallnpm i xml2jsRepositorygithub.com/Leonidas-from-XIV/node-xml2jsHomepagegithub.com/Leonidas-from-XIV/node-xml2jsWeekly Downloads22,667,333Version0.6.2LicenseMITUnpacked Size3.44 MBTotal Files10Last publish2 years agoCollaboratorsTry on RunKitReport malware\n\n\n\nnode-xml2js
Ever had the urge to parse XML? And wanted to access the data in some sane,
easy way? Don't want to compile a C parser, for whatever reason? Then xml2js is
what you're looking for!
Description
Simple XML to JavaScript object converter. It supports bi-directional conversion.
Uses sax-js and
xmlbuilder-js.
Note: If you're looking for a full DOM parser, you probably want
JSDom.
Installation
Simplest way to install xml2js is to use npm, just npm install xml2js which will download xml2js and all dependencies.
xml2js is also available via Bower, just bower install xml2js which will download xml2js and all dependencies.
Usage
No extensive tutorials required because you are a smart developer! The task of
parsing XML should be an easy one, so let's make it so! Here's some examples.
Shoot-and-forget usage
You want to parse XML as simple and easy as possible? It's dangerous to go
alone, take this:
var parseString = require('xml2js').parseString;
var xml = "<root>Hello xml2js!</root>"
parseString(xml, function (err, result) {
    console.dir(result);
});
Can't get easier than this, right? This works starting with xml2js 0.2.3.
With CoffeeScript it looks like this:
{parseString} = require 'xml2js'
xml = "<root>Hello xml2js!</root>"
parseString xml, (err, result) ->
    console.dir result
If you need some special options, fear not, xml2js supports a number of
options (see below), you can specify these as second argument:
parseString(xml, {trim: true}, function (err, result) {
});
Simple as pie usage
That's right, if you have been using xml-simple or a home-grown
wrapper, this was added in 0.1.11 just for you:
var fs = require('fs'),
    xml2js = require('xml2js');

var parser = new xml2js.Parser();
fs.readFile(__dirname + '/foo.xml', function(err, data) {
    parser.parseString(data, function (err, result) {
        console.dir(result);
        console.log('Done');
    });
});
Look ma, no event listeners!
You can also use xml2js from
CoffeeScript, further reducing
the clutter:
fs = require 'fs',
xml2js = require 'xml2js'

parser = new xml2js.Parser()
fs.readFile __dirname + '/foo.xml', (err, data) ->
  parser.parseString data, (err, result) ->
    console.dir result
    console.log 'Done.'
But what happens if you forget the new keyword to create a new Parser? In
the middle of a nightly coding session, it might get lost, after all. Worry
not, we got you covered! Starting with 0.2.8 you can also leave it out, in
which case xml2js will helpfully add it for you, no bad surprises and
inexplicable bugs!
Promise usage
var xml2js = require('xml2js');
var xml = '<foo></foo>';

// With parser
var parser = new xml2js.Parser(/* options */);
parser.parseStringPromise(xml).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});

// Without parser
xml2js.parseStringPromise(xml /*, options */).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});
Parsing multiple files
If you want to parse multiple files, you have multiple possibilities:

You can create one xml2js.Parser per file. That's the recommended one
and is promised to always just work.
You can call reset() on your parser object.
You can hope everything goes well anyway. This behaviour is not
guaranteed work always, if ever. Use option #1 if possible. Thanks!

So you wanna some JSON?
Just wrap the result object in a call to JSON.stringify like this
JSON.stringify(result). You get a string containing the JSON representation
of the parsed object that you can feed to JSON-hungry consumers.
Displaying results
You might wonder why, using console.dir or console.log the output at some
level is only [Object]. Don't worry, this is not because xml2js got lazy.
That's because Node uses util.inspect to convert the object into strings and
that function stops after depth=2 which is a bit low for most XML.
To display the whole deal, you can use console.log(util.inspect(result, false, null)), which displays the whole result.
So much for that, but what if you use
eyes for nice colored output and it
truncates the output with …? Don't fear, there's also a solution for that,
you just need to increase the maxLength limit by creating a custom inspector
var inspect = require('eyes').inspector({maxLength: false}) and then you can
easily inspect(result).
XML builder usage
Since 0.4.0, objects can be also be used to build XML:
var xml2js = require('xml2js');

var obj = {name: "Super", Surname: "Man", age: 23};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root>
  <name>Super</name>
  <Surname>Man</Surname>
  <age>23</age>
</root>
At the moment, a one to one bi-directional conversion is guaranteed only for
default configuration, except for attrkey, charkey and explicitArray options
you can redefine to your taste. Writing CDATA is supported via setting the cdata
option to true.
To specify attributes:
var xml2js = require('xml2js');

var obj = {root: {$: {id: "my id"}, _: "my inner text"}};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root id="my id">my inner text</root>
Adding xmlns attributes
You can generate XML that declares XML namespace prefix / URI pairs with xmlns attributes.
Example declaring a default namespace on the root element:
let obj = { 
  Foo: {
    $: {
      "xmlns": "http://foo.com"
    }   
  }
};  
Result of buildObject(obj):
<Foo xmlns="http://foo.com"/>
Example declaring non-default namespaces on non-root elements:
let obj = {
  'foo:Foo': {
    $: {
      'xmlns:foo': 'http://foo.com'
    },
    'bar:Bar': {
      $: {
        'xmlns:bar': 'http://bar.com'
      }
    }
  }
}
Result of buildObject(obj):
<foo:Foo xmlns:foo="http://foo.com">
  <bar:Bar xmlns:bar="http://bar.com"/>
</foo:Foo>
Processing attribute, tag names and values
Since 0.4.1 you can optionally provide the parser with attribute name and tag name processors as well as element value processors (Since 0.4.14, you can also optionally provide the parser with attribute value processors):
function nameToUpperCase(name){
    return name.toUpperCase();
}

//transform all attribute and tag names and values to uppercase
parseString(xml, {
  tagNameProcessors: [nameToUpperCase],
  attrNameProcessors: [nameToUpperCase],
  valueProcessors: [nameToUpperCase],
  attrValueProcessors: [nameToUpperCase]},
  function (err, result) {
    // processed data
});
The tagNameProcessors and attrNameProcessors options
accept an Array of functions with the following signature:
function (name){
  //do something with `name`
  return name
}
The attrValueProcessors and valueProcessors options
accept an Array of functions with the following signature:
function (value, name) {
  //`name` will be the node name or attribute name
  //do something with `value`, (optionally) dependent on the node/attr name
  return value
}
Some processors are provided out-of-the-box and can be found in lib/processors.js:


normalize: transforms the name to lowercase.
(Automatically used when options.normalize is set to true)


firstCharLowerCase: transforms the first character to lower case.
E.g. 'MyTagName' becomes 'myTagName'


stripPrefix: strips the xml namespace prefix. E.g <foo:Bar/> will become 'Bar'.
(N.B.: the xmlns prefix is NOT stripped.)


parseNumbers: parses integer-like strings as integers and float-like strings as floats
E.g. "0" becomes 0 and "15.56" becomes 15.56


parseBooleans: parses boolean-like strings to booleans
E.g. "true" becomes true and "False" becomes false


Options
Apart from the default settings, there are a number of options that can be
specified for the parser. Options are specified by new Parser({optionName: value}). Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

explicitCharkey (default: false) Determines whether or not to use
a charkey prefix for elements with no attributes.

trim (default: false): Trim the whitespace at the beginning and end of
text nodes.

normalizeTags (default: false): Normalize all tag names to lowercase.

normalize (default: false): Trim whitespaces inside text nodes.

explicitRoot (default: true): Set this if you want to get the root
node in the resulting object.

emptyTag (default: ''): what will the value of empty nodes be. In case
you want to use an empty object as a default value, it is better to provide a factory
function () => ({}) instead. Without this function a plain object would
become a shared reference across all occurrences with unwanted behavior.

explicitArray (default: true): Always put child nodes in an array if
true; otherwise an array is created only if there is more than one.

ignoreAttrs (default: false): Ignore all XML attributes and only create
text nodes.

mergeAttrs (default: false): Merge attributes and child elements as
properties of the parent, instead of keying attributes off a child
attribute object. This option is ignored if ignoreAttrs is true.

validator (default null): You can specify a callable that validates
the resulting structure somehow, however you want. See unit tests
for an example.

xmlns (default false): Give each element a field usually called '$ns'
(the first character is the same as attrkey) that contains its local name
and namespace URI.

explicitChildren (default false): Put child elements to separate
property. Doesn't work with mergeAttrs = true. If element has no children
then "children" won't be created. Added in 0.2.5.

childkey (default $$): Prefix that is used to access child elements if
explicitChildren is set to true. Added in 0.2.5.

preserveChildrenOrder (default false): Modifies the behavior of
explicitChildren so that the value of the "children" property becomes an
ordered array. When this is true, every node will also get a #name field
whose value will correspond to the XML nodeName, so that you may iterate
the "children" array and still be able to determine node names. The named
(and potentially unordered) properties are also retained in this
configuration at the same level as the ordered "children" array. Added in
0.4.9.

charsAsChildren (default false): Determines whether chars should be
considered children if explicitChildren is on. Added in 0.2.5.

includeWhiteChars (default false): Determines whether whitespace-only
text nodes should be included. Added in 0.4.17.

async (default false): Should the callbacks be async? This might be
an incompatible change if your code depends on sync execution of callbacks.
Future versions of xml2js might change this default, so the recommendation
is to not depend on sync execution anyway. Added in 0.2.6.

strict (default true): Set sax-js to strict or non-strict parsing mode.
Defaults to true which is highly recommended, since parsing HTML which
is not well-formed XML might yield just about anything. Added in 0.2.7.

attrNameProcessors (default: null): Allows the addition of attribute
name processing functions. Accepts an Array of functions with following
signature:
function (name){
    //do something with `name`
    return name
}
Added in 0.4.14

attrValueProcessors (default: null): Allows the addition of attribute
value processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.1

tagNameProcessors (default: null): Allows the addition of tag name
processing functions. Accepts an Array of functions with following
signature:
function (name){
  //do something with `name`
  return name
}
Added in 0.4.1

valueProcessors (default: null): Allows the addition of element value
processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.6

Options for the Builder class
These options are specified by new Builder({optionName: value}).
Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

rootName (default root or the root key name): root element name to be used in case
explicitRoot is false or to override the root element name.

renderOpts (default { 'pretty': true, 'indent': '  ', 'newline': '\n' }):
Rendering options for xmlbuilder-js.

pretty: prettify generated XML
indent: whitespace for indentation (only when pretty)
newline: newline char (only when pretty)



xmldec (default { 'version': '1.0', 'encoding': 'UTF-8', 'standalone': true }:
XML declaration attributes.


xmldec.version A version number string, e.g. 1.0

xmldec.encoding Encoding declaration, e.g. UTF-8

xmldec.standalone standalone document declaration: true or false



doctype (default null): optional DTD. Eg. {'ext': 'hello.dtd'}


headless (default: false): omit the XML header. Added in 0.4.3.

allowSurrogateChars (default: false): allows using characters from the Unicode
surrogate blocks.

cdata (default: false): wrap text nodes in <![CDATA[ ... ]]> instead of
escaping when necessary. Does not add <![CDATA[ ... ]]> if it is not required.
Added in 0.4.5.

renderOpts, xmldec,doctype and headless pass through to
xmlbuilder-js.
Updating to new version
Version 0.2 changed the default parsing settings, but version 0.1.14 introduced
the default settings for version 0.2, so these settings can be tried before the
migration.
var xml2js = require('xml2js');
var parser = new xml2js.Parser(xml2js.defaults["0.2"]);
To get the 0.1 defaults in version 0.2 you can just use
xml2js.defaults["0.1"] in the same place. This provides you with enough time
to migrate to the saner way of parsing in xml2js 0.2. We try to make the
migration as simple and gentle as possible, but some breakage cannot be
avoided.
So, what exactly did change and why? In 0.2 we changed some defaults to parse
the XML in a more universal and sane way. So we disabled normalize and trim
so xml2js does not cut out any text content. You can reenable this at will of
course. A more important change is that we return the root tag in the resulting
JavaScript structure via the explicitRoot setting, so you need to access the
first element. This is useful for anybody who wants to know what the root node
is and preserves more information. The last major change was to enable
explicitArray, so everytime it is possible that one might embed more than one
sub-tag into a tag, xml2js >= 0.2 returns an array even if the array just
includes one element. This is useful when dealing with APIs that return
variable amounts of subtags.
Running tests, development



The development requirements are handled by npm, you just need to install them.
We also have a number of unit tests, they can be run using npm test directly
from the project root. This runs zap to discover all the tests and execute
them.
If you like to contribute, keep in mind that xml2js is written in
CoffeeScript, so don't develop on the JavaScript files that are checked into
the repository for convenience reasons. Also, please write some unit test to
check your behaviour and if it is some user-facing thing, add some
documentation to this README, so people will know it exists. Thanks in advance!
Getting support
Please, if you have a problem with the library, first make sure you read this
README. If you read this far, thanks, you're good. Then, please make sure your
problem really is with xml2js. It is? Okay, then I'll look at it. Send me a
mail and we can talk. Please don't open issues, as I don't think that is the
proper forum for support problems. Some problems might as well really be bugs
in xml2js, if so I'll let you know to open an issue instead :)
But if you know you really found a bug, feel free to open an issue instead.\n\nxml2js0.6.2 • Public • Published 2 years ago ReadmeCode Beta2 Dependencies10,262 Dependents52 Versionsnode-xml2js
Ever had the urge to parse XML? And wanted to access the data in some sane,
easy way? Don't want to compile a C parser, for whatever reason? Then xml2js is
what you're looking for!
Description
Simple XML to JavaScript object converter. It supports bi-directional conversion.
Uses sax-js and
xmlbuilder-js.
Note: If you're looking for a full DOM parser, you probably want
JSDom.
Installation
Simplest way to install xml2js is to use npm, just npm install xml2js which will download xml2js and all dependencies.
xml2js is also available via Bower, just bower install xml2js which will download xml2js and all dependencies.
Usage
No extensive tutorials required because you are a smart developer! The task of
parsing XML should be an easy one, so let's make it so! Here's some examples.
Shoot-and-forget usage
You want to parse XML as simple and easy as possible? It's dangerous to go
alone, take this:
var parseString = require('xml2js').parseString;
var xml = "<root>Hello xml2js!</root>"
parseString(xml, function (err, result) {
    console.dir(result);
});
Can't get easier than this, right? This works starting with xml2js 0.2.3.
With CoffeeScript it looks like this:
{parseString} = require 'xml2js'
xml = "<root>Hello xml2js!</root>"
parseString xml, (err, result) ->
    console.dir result
If you need some special options, fear not, xml2js supports a number of
options (see below), you can specify these as second argument:
parseString(xml, {trim: true}, function (err, result) {
});
Simple as pie usage
That's right, if you have been using xml-simple or a home-grown
wrapper, this was added in 0.1.11 just for you:
var fs = require('fs'),
    xml2js = require('xml2js');

var parser = new xml2js.Parser();
fs.readFile(__dirname + '/foo.xml', function(err, data) {
    parser.parseString(data, function (err, result) {
        console.dir(result);
        console.log('Done');
    });
});
Look ma, no event listeners!
You can also use xml2js from
CoffeeScript, further reducing
the clutter:
fs = require 'fs',
xml2js = require 'xml2js'

parser = new xml2js.Parser()
fs.readFile __dirname + '/foo.xml', (err, data) ->
  parser.parseString data, (err, result) ->
    console.dir result
    console.log 'Done.'
But what happens if you forget the new keyword to create a new Parser? In
the middle of a nightly coding session, it might get lost, after all. Worry
not, we got you covered! Starting with 0.2.8 you can also leave it out, in
which case xml2js will helpfully add it for you, no bad surprises and
inexplicable bugs!
Promise usage
var xml2js = require('xml2js');
var xml = '<foo></foo>';

// With parser
var parser = new xml2js.Parser(/* options */);
parser.parseStringPromise(xml).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});

// Without parser
xml2js.parseStringPromise(xml /*, options */).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});
Parsing multiple files
If you want to parse multiple files, you have multiple possibilities:

You can create one xml2js.Parser per file. That's the recommended one
and is promised to always just work.
You can call reset() on your parser object.
You can hope everything goes well anyway. This behaviour is not
guaranteed work always, if ever. Use option #1 if possible. Thanks!

So you wanna some JSON?
Just wrap the result object in a call to JSON.stringify like this
JSON.stringify(result). You get a string containing the JSON representation
of the parsed object that you can feed to JSON-hungry consumers.
Displaying results
You might wonder why, using console.dir or console.log the output at some
level is only [Object]. Don't worry, this is not because xml2js got lazy.
That's because Node uses util.inspect to convert the object into strings and
that function stops after depth=2 which is a bit low for most XML.
To display the whole deal, you can use console.log(util.inspect(result, false, null)), which displays the whole result.
So much for that, but what if you use
eyes for nice colored output and it
truncates the output with …? Don't fear, there's also a solution for that,
you just need to increase the maxLength limit by creating a custom inspector
var inspect = require('eyes').inspector({maxLength: false}) and then you can
easily inspect(result).
XML builder usage
Since 0.4.0, objects can be also be used to build XML:
var xml2js = require('xml2js');

var obj = {name: "Super", Surname: "Man", age: 23};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root>
  <name>Super</name>
  <Surname>Man</Surname>
  <age>23</age>
</root>
At the moment, a one to one bi-directional conversion is guaranteed only for
default configuration, except for attrkey, charkey and explicitArray options
you can redefine to your taste. Writing CDATA is supported via setting the cdata
option to true.
To specify attributes:
var xml2js = require('xml2js');

var obj = {root: {$: {id: "my id"}, _: "my inner text"}};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root id="my id">my inner text</root>
Adding xmlns attributes
You can generate XML that declares XML namespace prefix / URI pairs with xmlns attributes.
Example declaring a default namespace on the root element:
let obj = { 
  Foo: {
    $: {
      "xmlns": "http://foo.com"
    }   
  }
};  
Result of buildObject(obj):
<Foo xmlns="http://foo.com"/>
Example declaring non-default namespaces on non-root elements:
let obj = {
  'foo:Foo': {
    $: {
      'xmlns:foo': 'http://foo.com'
    },
    'bar:Bar': {
      $: {
        'xmlns:bar': 'http://bar.com'
      }
    }
  }
}
Result of buildObject(obj):
<foo:Foo xmlns:foo="http://foo.com">
  <bar:Bar xmlns:bar="http://bar.com"/>
</foo:Foo>
Processing attribute, tag names and values
Since 0.4.1 you can optionally provide the parser with attribute name and tag name processors as well as element value processors (Since 0.4.14, you can also optionally provide the parser with attribute value processors):
function nameToUpperCase(name){
    return name.toUpperCase();
}

//transform all attribute and tag names and values to uppercase
parseString(xml, {
  tagNameProcessors: [nameToUpperCase],
  attrNameProcessors: [nameToUpperCase],
  valueProcessors: [nameToUpperCase],
  attrValueProcessors: [nameToUpperCase]},
  function (err, result) {
    // processed data
});
The tagNameProcessors and attrNameProcessors options
accept an Array of functions with the following signature:
function (name){
  //do something with `name`
  return name
}
The attrValueProcessors and valueProcessors options
accept an Array of functions with the following signature:
function (value, name) {
  //`name` will be the node name or attribute name
  //do something with `value`, (optionally) dependent on the node/attr name
  return value
}
Some processors are provided out-of-the-box and can be found in lib/processors.js:


normalize: transforms the name to lowercase.
(Automatically used when options.normalize is set to true)


firstCharLowerCase: transforms the first character to lower case.
E.g. 'MyTagName' becomes 'myTagName'


stripPrefix: strips the xml namespace prefix. E.g <foo:Bar/> will become 'Bar'.
(N.B.: the xmlns prefix is NOT stripped.)


parseNumbers: parses integer-like strings as integers and float-like strings as floats
E.g. "0" becomes 0 and "15.56" becomes 15.56


parseBooleans: parses boolean-like strings to booleans
E.g. "true" becomes true and "False" becomes false


Options
Apart from the default settings, there are a number of options that can be
specified for the parser. Options are specified by new Parser({optionName: value}). Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

explicitCharkey (default: false) Determines whether or not to use
a charkey prefix for elements with no attributes.

trim (default: false): Trim the whitespace at the beginning and end of
text nodes.

normalizeTags (default: false): Normalize all tag names to lowercase.

normalize (default: false): Trim whitespaces inside text nodes.

explicitRoot (default: true): Set this if you want to get the root
node in the resulting object.

emptyTag (default: ''): what will the value of empty nodes be. In case
you want to use an empty object as a default value, it is better to provide a factory
function () => ({}) instead. Without this function a plain object would
become a shared reference across all occurrences with unwanted behavior.

explicitArray (default: true): Always put child nodes in an array if
true; otherwise an array is created only if there is more than one.

ignoreAttrs (default: false): Ignore all XML attributes and only create
text nodes.

mergeAttrs (default: false): Merge attributes and child elements as
properties of the parent, instead of keying attributes off a child
attribute object. This option is ignored if ignoreAttrs is true.

validator (default null): You can specify a callable that validates
the resulting structure somehow, however you want. See unit tests
for an example.

xmlns (default false): Give each element a field usually called '$ns'
(the first character is the same as attrkey) that contains its local name
and namespace URI.

explicitChildren (default false): Put child elements to separate
property. Doesn't work with mergeAttrs = true. If element has no children
then "children" won't be created. Added in 0.2.5.

childkey (default $$): Prefix that is used to access child elements if
explicitChildren is set to true. Added in 0.2.5.

preserveChildrenOrder (default false): Modifies the behavior of
explicitChildren so that the value of the "children" property becomes an
ordered array. When this is true, every node will also get a #name field
whose value will correspond to the XML nodeName, so that you may iterate
the "children" array and still be able to determine node names. The named
(and potentially unordered) properties are also retained in this
configuration at the same level as the ordered "children" array. Added in
0.4.9.

charsAsChildren (default false): Determines whether chars should be
considered children if explicitChildren is on. Added in 0.2.5.

includeWhiteChars (default false): Determines whether whitespace-only
text nodes should be included. Added in 0.4.17.

async (default false): Should the callbacks be async? This might be
an incompatible change if your code depends on sync execution of callbacks.
Future versions of xml2js might change this default, so the recommendation
is to not depend on sync execution anyway. Added in 0.2.6.

strict (default true): Set sax-js to strict or non-strict parsing mode.
Defaults to true which is highly recommended, since parsing HTML which
is not well-formed XML might yield just about anything. Added in 0.2.7.

attrNameProcessors (default: null): Allows the addition of attribute
name processing functions. Accepts an Array of functions with following
signature:
function (name){
    //do something with `name`
    return name
}
Added in 0.4.14

attrValueProcessors (default: null): Allows the addition of attribute
value processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.1

tagNameProcessors (default: null): Allows the addition of tag name
processing functions. Accepts an Array of functions with following
signature:
function (name){
  //do something with `name`
  return name
}
Added in 0.4.1

valueProcessors (default: null): Allows the addition of element value
processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.6

Options for the Builder class
These options are specified by new Builder({optionName: value}).
Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

rootName (default root or the root key name): root element name to be used in case
explicitRoot is false or to override the root element name.

renderOpts (default { 'pretty': true, 'indent': '  ', 'newline': '\n' }):
Rendering options for xmlbuilder-js.

pretty: prettify generated XML
indent: whitespace for indentation (only when pretty)
newline: newline char (only when pretty)



xmldec (default { 'version': '1.0', 'encoding': 'UTF-8', 'standalone': true }:
XML declaration attributes.


xmldec.version A version number string, e.g. 1.0

xmldec.encoding Encoding declaration, e.g. UTF-8

xmldec.standalone standalone document declaration: true or false



doctype (default null): optional DTD. Eg. {'ext': 'hello.dtd'}


headless (default: false): omit the XML header. Added in 0.4.3.

allowSurrogateChars (default: false): allows using characters from the Unicode
surrogate blocks.

cdata (default: false): wrap text nodes in <![CDATA[ ... ]]> instead of
escaping when necessary. Does not add <![CDATA[ ... ]]> if it is not required.
Added in 0.4.5.

renderOpts, xmldec,doctype and headless pass through to
xmlbuilder-js.
Updating to new version
Version 0.2 changed the default parsing settings, but version 0.1.14 introduced
the default settings for version 0.2, so these settings can be tried before the
migration.
var xml2js = require('xml2js');
var parser = new xml2js.Parser(xml2js.defaults["0.2"]);
To get the 0.1 defaults in version 0.2 you can just use
xml2js.defaults["0.1"] in the same place. This provides you with enough time
to migrate to the saner way of parsing in xml2js 0.2. We try to make the
migration as simple and gentle as possible, but some breakage cannot be
avoided.
So, what exactly did change and why? In 0.2 we changed some defaults to parse
the XML in a more universal and sane way. So we disabled normalize and trim
so xml2js does not cut out any text content. You can reenable this at will of
course. A more important change is that we return the root tag in the resulting
JavaScript structure via the explicitRoot setting, so you need to access the
first element. This is useful for anybody who wants to know what the root node
is and preserves more information. The last major change was to enable
explicitArray, so everytime it is possible that one might embed more than one
sub-tag into a tag, xml2js >= 0.2 returns an array even if the array just
includes one element. This is useful when dealing with APIs that return
variable amounts of subtags.
Running tests, development



The development requirements are handled by npm, you just need to install them.
We also have a number of unit tests, they can be run using npm test directly
from the project root. This runs zap to discover all the tests and execute
them.
If you like to contribute, keep in mind that xml2js is written in
CoffeeScript, so don't develop on the JavaScript files that are checked into
the repository for convenience reasons. Also, please write some unit test to
check your behaviour and if it is some user-facing thing, add some
documentation to this README, so people will know it exists. Thanks in advance!
Getting support
Please, if you have a problem with the library, first make sure you read this
README. If you read this far, thanks, you're good. Then, please make sure your
problem really is with xml2js. It is? Okay, then I'll look at it. Send me a
mail and we can talk. Please don't open issues, as I don't think that is the
proper forum for support problems. Some problems might as well really be bugs
in xml2js, if so I'll let you know to open an issue instead :)
But if you know you really found a bug, feel free to open an issue instead.
ReadmeKeywordsxmljsonPackage SidebarInstallnpm i xml2jsRepositorygithub.com/Leonidas-from-XIV/node-xml2jsHomepagegithub.com/Leonidas-from-XIV/node-xml2jsWeekly Downloads22,667,333Version0.6.2LicenseMITUnpacked Size3.44 MBTotal Files10Last publish2 years agoCollaboratorsTry on RunKitReport malware\n\nxml2js0.6.2 • Public • Published 2 years ago ReadmeCode Beta2 Dependencies10,262 Dependents52 Versionsnode-xml2js
Ever had the urge to parse XML? And wanted to access the data in some sane,
easy way? Don't want to compile a C parser, for whatever reason? Then xml2js is
what you're looking for!
Description
Simple XML to JavaScript object converter. It supports bi-directional conversion.
Uses sax-js and
xmlbuilder-js.
Note: If you're looking for a full DOM parser, you probably want
JSDom.
Installation
Simplest way to install xml2js is to use npm, just npm install xml2js which will download xml2js and all dependencies.
xml2js is also available via Bower, just bower install xml2js which will download xml2js and all dependencies.
Usage
No extensive tutorials required because you are a smart developer! The task of
parsing XML should be an easy one, so let's make it so! Here's some examples.
Shoot-and-forget usage
You want to parse XML as simple and easy as possible? It's dangerous to go
alone, take this:
var parseString = require('xml2js').parseString;
var xml = "<root>Hello xml2js!</root>"
parseString(xml, function (err, result) {
    console.dir(result);
});
Can't get easier than this, right? This works starting with xml2js 0.2.3.
With CoffeeScript it looks like this:
{parseString} = require 'xml2js'
xml = "<root>Hello xml2js!</root>"
parseString xml, (err, result) ->
    console.dir result
If you need some special options, fear not, xml2js supports a number of
options (see below), you can specify these as second argument:
parseString(xml, {trim: true}, function (err, result) {
});
Simple as pie usage
That's right, if you have been using xml-simple or a home-grown
wrapper, this was added in 0.1.11 just for you:
var fs = require('fs'),
    xml2js = require('xml2js');

var parser = new xml2js.Parser();
fs.readFile(__dirname + '/foo.xml', function(err, data) {
    parser.parseString(data, function (err, result) {
        console.dir(result);
        console.log('Done');
    });
});
Look ma, no event listeners!
You can also use xml2js from
CoffeeScript, further reducing
the clutter:
fs = require 'fs',
xml2js = require 'xml2js'

parser = new xml2js.Parser()
fs.readFile __dirname + '/foo.xml', (err, data) ->
  parser.parseString data, (err, result) ->
    console.dir result
    console.log 'Done.'
But what happens if you forget the new keyword to create a new Parser? In
the middle of a nightly coding session, it might get lost, after all. Worry
not, we got you covered! Starting with 0.2.8 you can also leave it out, in
which case xml2js will helpfully add it for you, no bad surprises and
inexplicable bugs!
Promise usage
var xml2js = require('xml2js');
var xml = '<foo></foo>';

// With parser
var parser = new xml2js.Parser(/* options */);
parser.parseStringPromise(xml).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});

// Without parser
xml2js.parseStringPromise(xml /*, options */).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});
Parsing multiple files
If you want to parse multiple files, you have multiple possibilities:

You can create one xml2js.Parser per file. That's the recommended one
and is promised to always just work.
You can call reset() on your parser object.
You can hope everything goes well anyway. This behaviour is not
guaranteed work always, if ever. Use option #1 if possible. Thanks!

So you wanna some JSON?
Just wrap the result object in a call to JSON.stringify like this
JSON.stringify(result). You get a string containing the JSON representation
of the parsed object that you can feed to JSON-hungry consumers.
Displaying results
You might wonder why, using console.dir or console.log the output at some
level is only [Object]. Don't worry, this is not because xml2js got lazy.
That's because Node uses util.inspect to convert the object into strings and
that function stops after depth=2 which is a bit low for most XML.
To display the whole deal, you can use console.log(util.inspect(result, false, null)), which displays the whole result.
So much for that, but what if you use
eyes for nice colored output and it
truncates the output with …? Don't fear, there's also a solution for that,
you just need to increase the maxLength limit by creating a custom inspector
var inspect = require('eyes').inspector({maxLength: false}) and then you can
easily inspect(result).
XML builder usage
Since 0.4.0, objects can be also be used to build XML:
var xml2js = require('xml2js');

var obj = {name: "Super", Surname: "Man", age: 23};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root>
  <name>Super</name>
  <Surname>Man</Surname>
  <age>23</age>
</root>
At the moment, a one to one bi-directional conversion is guaranteed only for
default configuration, except for attrkey, charkey and explicitArray options
you can redefine to your taste. Writing CDATA is supported via setting the cdata
option to true.
To specify attributes:
var xml2js = require('xml2js');

var obj = {root: {$: {id: "my id"}, _: "my inner text"}};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root id="my id">my inner text</root>
Adding xmlns attributes
You can generate XML that declares XML namespace prefix / URI pairs with xmlns attributes.
Example declaring a default namespace on the root element:
let obj = { 
  Foo: {
    $: {
      "xmlns": "http://foo.com"
    }   
  }
};  
Result of buildObject(obj):
<Foo xmlns="http://foo.com"/>
Example declaring non-default namespaces on non-root elements:
let obj = {
  'foo:Foo': {
    $: {
      'xmlns:foo': 'http://foo.com'
    },
    'bar:Bar': {
      $: {
        'xmlns:bar': 'http://bar.com'
      }
    }
  }
}
Result of buildObject(obj):
<foo:Foo xmlns:foo="http://foo.com">
  <bar:Bar xmlns:bar="http://bar.com"/>
</foo:Foo>
Processing attribute, tag names and values
Since 0.4.1 you can optionally provide the parser with attribute name and tag name processors as well as element value processors (Since 0.4.14, you can also optionally provide the parser with attribute value processors):
function nameToUpperCase(name){
    return name.toUpperCase();
}

//transform all attribute and tag names and values to uppercase
parseString(xml, {
  tagNameProcessors: [nameToUpperCase],
  attrNameProcessors: [nameToUpperCase],
  valueProcessors: [nameToUpperCase],
  attrValueProcessors: [nameToUpperCase]},
  function (err, result) {
    // processed data
});
The tagNameProcessors and attrNameProcessors options
accept an Array of functions with the following signature:
function (name){
  //do something with `name`
  return name
}
The attrValueProcessors and valueProcessors options
accept an Array of functions with the following signature:
function (value, name) {
  //`name` will be the node name or attribute name
  //do something with `value`, (optionally) dependent on the node/attr name
  return value
}
Some processors are provided out-of-the-box and can be found in lib/processors.js:


normalize: transforms the name to lowercase.
(Automatically used when options.normalize is set to true)


firstCharLowerCase: transforms the first character to lower case.
E.g. 'MyTagName' becomes 'myTagName'


stripPrefix: strips the xml namespace prefix. E.g <foo:Bar/> will become 'Bar'.
(N.B.: the xmlns prefix is NOT stripped.)


parseNumbers: parses integer-like strings as integers and float-like strings as floats
E.g. "0" becomes 0 and "15.56" becomes 15.56


parseBooleans: parses boolean-like strings to booleans
E.g. "true" becomes true and "False" becomes false


Options
Apart from the default settings, there are a number of options that can be
specified for the parser. Options are specified by new Parser({optionName: value}). Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

explicitCharkey (default: false) Determines whether or not to use
a charkey prefix for elements with no attributes.

trim (default: false): Trim the whitespace at the beginning and end of
text nodes.

normalizeTags (default: false): Normalize all tag names to lowercase.

normalize (default: false): Trim whitespaces inside text nodes.

explicitRoot (default: true): Set this if you want to get the root
node in the resulting object.

emptyTag (default: ''): what will the value of empty nodes be. In case
you want to use an empty object as a default value, it is better to provide a factory
function () => ({}) instead. Without this function a plain object would
become a shared reference across all occurrences with unwanted behavior.

explicitArray (default: true): Always put child nodes in an array if
true; otherwise an array is created only if there is more than one.

ignoreAttrs (default: false): Ignore all XML attributes and only create
text nodes.

mergeAttrs (default: false): Merge attributes and child elements as
properties of the parent, instead of keying attributes off a child
attribute object. This option is ignored if ignoreAttrs is true.

validator (default null): You can specify a callable that validates
the resulting structure somehow, however you want. See unit tests
for an example.

xmlns (default false): Give each element a field usually called '$ns'
(the first character is the same as attrkey) that contains its local name
and namespace URI.

explicitChildren (default false): Put child elements to separate
property. Doesn't work with mergeAttrs = true. If element has no children
then "children" won't be created. Added in 0.2.5.

childkey (default $$): Prefix that is used to access child elements if
explicitChildren is set to true. Added in 0.2.5.

preserveChildrenOrder (default false): Modifies the behavior of
explicitChildren so that the value of the "children" property becomes an
ordered array. When this is true, every node will also get a #name field
whose value will correspond to the XML nodeName, so that you may iterate
the "children" array and still be able to determine node names. The named
(and potentially unordered) properties are also retained in this
configuration at the same level as the ordered "children" array. Added in
0.4.9.

charsAsChildren (default false): Determines whether chars should be
considered children if explicitChildren is on. Added in 0.2.5.

includeWhiteChars (default false): Determines whether whitespace-only
text nodes should be included. Added in 0.4.17.

async (default false): Should the callbacks be async? This might be
an incompatible change if your code depends on sync execution of callbacks.
Future versions of xml2js might change this default, so the recommendation
is to not depend on sync execution anyway. Added in 0.2.6.

strict (default true): Set sax-js to strict or non-strict parsing mode.
Defaults to true which is highly recommended, since parsing HTML which
is not well-formed XML might yield just about anything. Added in 0.2.7.

attrNameProcessors (default: null): Allows the addition of attribute
name processing functions. Accepts an Array of functions with following
signature:
function (name){
    //do something with `name`
    return name
}
Added in 0.4.14

attrValueProcessors (default: null): Allows the addition of attribute
value processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.1

tagNameProcessors (default: null): Allows the addition of tag name
processing functions. Accepts an Array of functions with following
signature:
function (name){
  //do something with `name`
  return name
}
Added in 0.4.1

valueProcessors (default: null): Allows the addition of element value
processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.6

Options for the Builder class
These options are specified by new Builder({optionName: value}).
Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

rootName (default root or the root key name): root element name to be used in case
explicitRoot is false or to override the root element name.

renderOpts (default { 'pretty': true, 'indent': '  ', 'newline': '\n' }):
Rendering options for xmlbuilder-js.

pretty: prettify generated XML
indent: whitespace for indentation (only when pretty)
newline: newline char (only when pretty)



xmldec (default { 'version': '1.0', 'encoding': 'UTF-8', 'standalone': true }:
XML declaration attributes.


xmldec.version A version number string, e.g. 1.0

xmldec.encoding Encoding declaration, e.g. UTF-8

xmldec.standalone standalone document declaration: true or false



doctype (default null): optional DTD. Eg. {'ext': 'hello.dtd'}


headless (default: false): omit the XML header. Added in 0.4.3.

allowSurrogateChars (default: false): allows using characters from the Unicode
surrogate blocks.

cdata (default: false): wrap text nodes in <![CDATA[ ... ]]> instead of
escaping when necessary. Does not add <![CDATA[ ... ]]> if it is not required.
Added in 0.4.5.

renderOpts, xmldec,doctype and headless pass through to
xmlbuilder-js.
Updating to new version
Version 0.2 changed the default parsing settings, but version 0.1.14 introduced
the default settings for version 0.2, so these settings can be tried before the
migration.
var xml2js = require('xml2js');
var parser = new xml2js.Parser(xml2js.defaults["0.2"]);
To get the 0.1 defaults in version 0.2 you can just use
xml2js.defaults["0.1"] in the same place. This provides you with enough time
to migrate to the saner way of parsing in xml2js 0.2. We try to make the
migration as simple and gentle as possible, but some breakage cannot be
avoided.
So, what exactly did change and why? In 0.2 we changed some defaults to parse
the XML in a more universal and sane way. So we disabled normalize and trim
so xml2js does not cut out any text content. You can reenable this at will of
course. A more important change is that we return the root tag in the resulting
JavaScript structure via the explicitRoot setting, so you need to access the
first element. This is useful for anybody who wants to know what the root node
is and preserves more information. The last major change was to enable
explicitArray, so everytime it is possible that one might embed more than one
sub-tag into a tag, xml2js >= 0.2 returns an array even if the array just
includes one element. This is useful when dealing with APIs that return
variable amounts of subtags.
Running tests, development



The development requirements are handled by npm, you just need to install them.
We also have a number of unit tests, they can be run using npm test directly
from the project root. This runs zap to discover all the tests and execute
them.
If you like to contribute, keep in mind that xml2js is written in
CoffeeScript, so don't develop on the JavaScript files that are checked into
the repository for convenience reasons. Also, please write some unit test to
check your behaviour and if it is some user-facing thing, add some
documentation to this README, so people will know it exists. Thanks in advance!
Getting support
Please, if you have a problem with the library, first make sure you read this
README. If you read this far, thanks, you're good. Then, please make sure your
problem really is with xml2js. It is? Okay, then I'll look at it. Send me a
mail and we can talk. Please don't open issues, as I don't think that is the
proper forum for support problems. Some problems might as well really be bugs
in xml2js, if so I'll let you know to open an issue instead :)
But if you know you really found a bug, feel free to open an issue instead.
ReadmeKeywordsxmljsonPackage SidebarInstallnpm i xml2jsRepositorygithub.com/Leonidas-from-XIV/node-xml2jsHomepagegithub.com/Leonidas-from-XIV/node-xml2jsWeekly Downloads22,667,333Version0.6.2LicenseMITUnpacked Size3.44 MBTotal Files10Last publish2 years agoCollaboratorsTry on RunKitReport malware\n\n\n\nnode-xml2js
Ever had the urge to parse XML? And wanted to access the data in some sane,
easy way? Don't want to compile a C parser, for whatever reason? Then xml2js is
what you're looking for!
Description
Simple XML to JavaScript object converter. It supports bi-directional conversion.
Uses sax-js and
xmlbuilder-js.
Note: If you're looking for a full DOM parser, you probably want
JSDom.
Installation
Simplest way to install xml2js is to use npm, just npm install xml2js which will download xml2js and all dependencies.
xml2js is also available via Bower, just bower install xml2js which will download xml2js and all dependencies.
Usage
No extensive tutorials required because you are a smart developer! The task of
parsing XML should be an easy one, so let's make it so! Here's some examples.
Shoot-and-forget usage
You want to parse XML as simple and easy as possible? It's dangerous to go
alone, take this:
var parseString = require('xml2js').parseString;
var xml = "<root>Hello xml2js!</root>"
parseString(xml, function (err, result) {
    console.dir(result);
});
Can't get easier than this, right? This works starting with xml2js 0.2.3.
With CoffeeScript it looks like this:
{parseString} = require 'xml2js'
xml = "<root>Hello xml2js!</root>"
parseString xml, (err, result) ->
    console.dir result
If you need some special options, fear not, xml2js supports a number of
options (see below), you can specify these as second argument:
parseString(xml, {trim: true}, function (err, result) {
});
Simple as pie usage
That's right, if you have been using xml-simple or a home-grown
wrapper, this was added in 0.1.11 just for you:
var fs = require('fs'),
    xml2js = require('xml2js');

var parser = new xml2js.Parser();
fs.readFile(__dirname + '/foo.xml', function(err, data) {
    parser.parseString(data, function (err, result) {
        console.dir(result);
        console.log('Done');
    });
});
Look ma, no event listeners!
You can also use xml2js from
CoffeeScript, further reducing
the clutter:
fs = require 'fs',
xml2js = require 'xml2js'

parser = new xml2js.Parser()
fs.readFile __dirname + '/foo.xml', (err, data) ->
  parser.parseString data, (err, result) ->
    console.dir result
    console.log 'Done.'
But what happens if you forget the new keyword to create a new Parser? In
the middle of a nightly coding session, it might get lost, after all. Worry
not, we got you covered! Starting with 0.2.8 you can also leave it out, in
which case xml2js will helpfully add it for you, no bad surprises and
inexplicable bugs!
Promise usage
var xml2js = require('xml2js');
var xml = '<foo></foo>';

// With parser
var parser = new xml2js.Parser(/* options */);
parser.parseStringPromise(xml).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});

// Without parser
xml2js.parseStringPromise(xml /*, options */).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});
Parsing multiple files
If you want to parse multiple files, you have multiple possibilities:

You can create one xml2js.Parser per file. That's the recommended one
and is promised to always just work.
You can call reset() on your parser object.
You can hope everything goes well anyway. This behaviour is not
guaranteed work always, if ever. Use option #1 if possible. Thanks!

So you wanna some JSON?
Just wrap the result object in a call to JSON.stringify like this
JSON.stringify(result). You get a string containing the JSON representation
of the parsed object that you can feed to JSON-hungry consumers.
Displaying results
You might wonder why, using console.dir or console.log the output at some
level is only [Object]. Don't worry, this is not because xml2js got lazy.
That's because Node uses util.inspect to convert the object into strings and
that function stops after depth=2 which is a bit low for most XML.
To display the whole deal, you can use console.log(util.inspect(result, false, null)), which displays the whole result.
So much for that, but what if you use
eyes for nice colored output and it
truncates the output with …? Don't fear, there's also a solution for that,
you just need to increase the maxLength limit by creating a custom inspector
var inspect = require('eyes').inspector({maxLength: false}) and then you can
easily inspect(result).
XML builder usage
Since 0.4.0, objects can be also be used to build XML:
var xml2js = require('xml2js');

var obj = {name: "Super", Surname: "Man", age: 23};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root>
  <name>Super</name>
  <Surname>Man</Surname>
  <age>23</age>
</root>
At the moment, a one to one bi-directional conversion is guaranteed only for
default configuration, except for attrkey, charkey and explicitArray options
you can redefine to your taste. Writing CDATA is supported via setting the cdata
option to true.
To specify attributes:
var xml2js = require('xml2js');

var obj = {root: {$: {id: "my id"}, _: "my inner text"}};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root id="my id">my inner text</root>
Adding xmlns attributes
You can generate XML that declares XML namespace prefix / URI pairs with xmlns attributes.
Example declaring a default namespace on the root element:
let obj = { 
  Foo: {
    $: {
      "xmlns": "http://foo.com"
    }   
  }
};  
Result of buildObject(obj):
<Foo xmlns="http://foo.com"/>
Example declaring non-default namespaces on non-root elements:
let obj = {
  'foo:Foo': {
    $: {
      'xmlns:foo': 'http://foo.com'
    },
    'bar:Bar': {
      $: {
        'xmlns:bar': 'http://bar.com'
      }
    }
  }
}
Result of buildObject(obj):
<foo:Foo xmlns:foo="http://foo.com">
  <bar:Bar xmlns:bar="http://bar.com"/>
</foo:Foo>
Processing attribute, tag names and values
Since 0.4.1 you can optionally provide the parser with attribute name and tag name processors as well as element value processors (Since 0.4.14, you can also optionally provide the parser with attribute value processors):
function nameToUpperCase(name){
    return name.toUpperCase();
}

//transform all attribute and tag names and values to uppercase
parseString(xml, {
  tagNameProcessors: [nameToUpperCase],
  attrNameProcessors: [nameToUpperCase],
  valueProcessors: [nameToUpperCase],
  attrValueProcessors: [nameToUpperCase]},
  function (err, result) {
    // processed data
});
The tagNameProcessors and attrNameProcessors options
accept an Array of functions with the following signature:
function (name){
  //do something with `name`
  return name
}
The attrValueProcessors and valueProcessors options
accept an Array of functions with the following signature:
function (value, name) {
  //`name` will be the node name or attribute name
  //do something with `value`, (optionally) dependent on the node/attr name
  return value
}
Some processors are provided out-of-the-box and can be found in lib/processors.js:


normalize: transforms the name to lowercase.
(Automatically used when options.normalize is set to true)


firstCharLowerCase: transforms the first character to lower case.
E.g. 'MyTagName' becomes 'myTagName'


stripPrefix: strips the xml namespace prefix. E.g <foo:Bar/> will become 'Bar'.
(N.B.: the xmlns prefix is NOT stripped.)


parseNumbers: parses integer-like strings as integers and float-like strings as floats
E.g. "0" becomes 0 and "15.56" becomes 15.56


parseBooleans: parses boolean-like strings to booleans
E.g. "true" becomes true and "False" becomes false


Options
Apart from the default settings, there are a number of options that can be
specified for the parser. Options are specified by new Parser({optionName: value}). Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

explicitCharkey (default: false) Determines whether or not to use
a charkey prefix for elements with no attributes.

trim (default: false): Trim the whitespace at the beginning and end of
text nodes.

normalizeTags (default: false): Normalize all tag names to lowercase.

normalize (default: false): Trim whitespaces inside text nodes.

explicitRoot (default: true): Set this if you want to get the root
node in the resulting object.

emptyTag (default: ''): what will the value of empty nodes be. In case
you want to use an empty object as a default value, it is better to provide a factory
function () => ({}) instead. Without this function a plain object would
become a shared reference across all occurrences with unwanted behavior.

explicitArray (default: true): Always put child nodes in an array if
true; otherwise an array is created only if there is more than one.

ignoreAttrs (default: false): Ignore all XML attributes and only create
text nodes.

mergeAttrs (default: false): Merge attributes and child elements as
properties of the parent, instead of keying attributes off a child
attribute object. This option is ignored if ignoreAttrs is true.

validator (default null): You can specify a callable that validates
the resulting structure somehow, however you want. See unit tests
for an example.

xmlns (default false): Give each element a field usually called '$ns'
(the first character is the same as attrkey) that contains its local name
and namespace URI.

explicitChildren (default false): Put child elements to separate
property. Doesn't work with mergeAttrs = true. If element has no children
then "children" won't be created. Added in 0.2.5.

childkey (default $$): Prefix that is used to access child elements if
explicitChildren is set to true. Added in 0.2.5.

preserveChildrenOrder (default false): Modifies the behavior of
explicitChildren so that the value of the "children" property becomes an
ordered array. When this is true, every node will also get a #name field
whose value will correspond to the XML nodeName, so that you may iterate
the "children" array and still be able to determine node names. The named
(and potentially unordered) properties are also retained in this
configuration at the same level as the ordered "children" array. Added in
0.4.9.

charsAsChildren (default false): Determines whether chars should be
considered children if explicitChildren is on. Added in 0.2.5.

includeWhiteChars (default false): Determines whether whitespace-only
text nodes should be included. Added in 0.4.17.

async (default false): Should the callbacks be async? This might be
an incompatible change if your code depends on sync execution of callbacks.
Future versions of xml2js might change this default, so the recommendation
is to not depend on sync execution anyway. Added in 0.2.6.

strict (default true): Set sax-js to strict or non-strict parsing mode.
Defaults to true which is highly recommended, since parsing HTML which
is not well-formed XML might yield just about anything. Added in 0.2.7.

attrNameProcessors (default: null): Allows the addition of attribute
name processing functions. Accepts an Array of functions with following
signature:
function (name){
    //do something with `name`
    return name
}
Added in 0.4.14

attrValueProcessors (default: null): Allows the addition of attribute
value processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.1

tagNameProcessors (default: null): Allows the addition of tag name
processing functions. Accepts an Array of functions with following
signature:
function (name){
  //do something with `name`
  return name
}
Added in 0.4.1

valueProcessors (default: null): Allows the addition of element value
processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.6

Options for the Builder class
These options are specified by new Builder({optionName: value}).
Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

rootName (default root or the root key name): root element name to be used in case
explicitRoot is false or to override the root element name.

renderOpts (default { 'pretty': true, 'indent': '  ', 'newline': '\n' }):
Rendering options for xmlbuilder-js.

pretty: prettify generated XML
indent: whitespace for indentation (only when pretty)
newline: newline char (only when pretty)



xmldec (default { 'version': '1.0', 'encoding': 'UTF-8', 'standalone': true }:
XML declaration attributes.


xmldec.version A version number string, e.g. 1.0

xmldec.encoding Encoding declaration, e.g. UTF-8

xmldec.standalone standalone document declaration: true or false



doctype (default null): optional DTD. Eg. {'ext': 'hello.dtd'}


headless (default: false): omit the XML header. Added in 0.4.3.

allowSurrogateChars (default: false): allows using characters from the Unicode
surrogate blocks.

cdata (default: false): wrap text nodes in <![CDATA[ ... ]]> instead of
escaping when necessary. Does not add <![CDATA[ ... ]]> if it is not required.
Added in 0.4.5.

renderOpts, xmldec,doctype and headless pass through to
xmlbuilder-js.
Updating to new version
Version 0.2 changed the default parsing settings, but version 0.1.14 introduced
the default settings for version 0.2, so these settings can be tried before the
migration.
var xml2js = require('xml2js');
var parser = new xml2js.Parser(xml2js.defaults["0.2"]);
To get the 0.1 defaults in version 0.2 you can just use
xml2js.defaults["0.1"] in the same place. This provides you with enough time
to migrate to the saner way of parsing in xml2js 0.2. We try to make the
migration as simple and gentle as possible, but some breakage cannot be
avoided.
So, what exactly did change and why? In 0.2 we changed some defaults to parse
the XML in a more universal and sane way. So we disabled normalize and trim
so xml2js does not cut out any text content. You can reenable this at will of
course. A more important change is that we return the root tag in the resulting
JavaScript structure via the explicitRoot setting, so you need to access the
first element. This is useful for anybody who wants to know what the root node
is and preserves more information. The last major change was to enable
explicitArray, so everytime it is possible that one might embed more than one
sub-tag into a tag, xml2js >= 0.2 returns an array even if the array just
includes one element. This is useful when dealing with APIs that return
variable amounts of subtags.
Running tests, development



The development requirements are handled by npm, you just need to install them.
We also have a number of unit tests, they can be run using npm test directly
from the project root. This runs zap to discover all the tests and execute
them.
If you like to contribute, keep in mind that xml2js is written in
CoffeeScript, so don't develop on the JavaScript files that are checked into
the repository for convenience reasons. Also, please write some unit test to
check your behaviour and if it is some user-facing thing, add some
documentation to this README, so people will know it exists. Thanks in advance!
Getting support
Please, if you have a problem with the library, first make sure you read this
README. If you read this far, thanks, you're good. Then, please make sure your
problem really is with xml2js. It is? Okay, then I'll look at it. Send me a
mail and we can talk. Please don't open issues, as I don't think that is the
proper forum for support problems. Some problems might as well really be bugs
in xml2js, if so I'll let you know to open an issue instead :)
But if you know you really found a bug, feel free to open an issue instead.\n\nxml2js0.6.2 • Public • Published 2 years ago ReadmeCode Beta2 Dependencies10,262 Dependents52 Versionsnode-xml2js
Ever had the urge to parse XML? And wanted to access the data in some sane,
easy way? Don't want to compile a C parser, for whatever reason? Then xml2js is
what you're looking for!
Description
Simple XML to JavaScript object converter. It supports bi-directional conversion.
Uses sax-js and
xmlbuilder-js.
Note: If you're looking for a full DOM parser, you probably want
JSDom.
Installation
Simplest way to install xml2js is to use npm, just npm install xml2js which will download xml2js and all dependencies.
xml2js is also available via Bower, just bower install xml2js which will download xml2js and all dependencies.
Usage
No extensive tutorials required because you are a smart developer! The task of
parsing XML should be an easy one, so let's make it so! Here's some examples.
Shoot-and-forget usage
You want to parse XML as simple and easy as possible? It's dangerous to go
alone, take this:
var parseString = require('xml2js').parseString;
var xml = "<root>Hello xml2js!</root>"
parseString(xml, function (err, result) {
    console.dir(result);
});
Can't get easier than this, right? This works starting with xml2js 0.2.3.
With CoffeeScript it looks like this:
{parseString} = require 'xml2js'
xml = "<root>Hello xml2js!</root>"
parseString xml, (err, result) ->
    console.dir result
If you need some special options, fear not, xml2js supports a number of
options (see below), you can specify these as second argument:
parseString(xml, {trim: true}, function (err, result) {
});
Simple as pie usage
That's right, if you have been using xml-simple or a home-grown
wrapper, this was added in 0.1.11 just for you:
var fs = require('fs'),
    xml2js = require('xml2js');

var parser = new xml2js.Parser();
fs.readFile(__dirname + '/foo.xml', function(err, data) {
    parser.parseString(data, function (err, result) {
        console.dir(result);
        console.log('Done');
    });
});
Look ma, no event listeners!
You can also use xml2js from
CoffeeScript, further reducing
the clutter:
fs = require 'fs',
xml2js = require 'xml2js'

parser = new xml2js.Parser()
fs.readFile __dirname + '/foo.xml', (err, data) ->
  parser.parseString data, (err, result) ->
    console.dir result
    console.log 'Done.'
But what happens if you forget the new keyword to create a new Parser? In
the middle of a nightly coding session, it might get lost, after all. Worry
not, we got you covered! Starting with 0.2.8 you can also leave it out, in
which case xml2js will helpfully add it for you, no bad surprises and
inexplicable bugs!
Promise usage
var xml2js = require('xml2js');
var xml = '<foo></foo>';

// With parser
var parser = new xml2js.Parser(/* options */);
parser.parseStringPromise(xml).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});

// Without parser
xml2js.parseStringPromise(xml /*, options */).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});
Parsing multiple files
If you want to parse multiple files, you have multiple possibilities:

You can create one xml2js.Parser per file. That's the recommended one
and is promised to always just work.
You can call reset() on your parser object.
You can hope everything goes well anyway. This behaviour is not
guaranteed work always, if ever. Use option #1 if possible. Thanks!

So you wanna some JSON?
Just wrap the result object in a call to JSON.stringify like this
JSON.stringify(result). You get a string containing the JSON representation
of the parsed object that you can feed to JSON-hungry consumers.
Displaying results
You might wonder why, using console.dir or console.log the output at some
level is only [Object]. Don't worry, this is not because xml2js got lazy.
That's because Node uses util.inspect to convert the object into strings and
that function stops after depth=2 which is a bit low for most XML.
To display the whole deal, you can use console.log(util.inspect(result, false, null)), which displays the whole result.
So much for that, but what if you use
eyes for nice colored output and it
truncates the output with …? Don't fear, there's also a solution for that,
you just need to increase the maxLength limit by creating a custom inspector
var inspect = require('eyes').inspector({maxLength: false}) and then you can
easily inspect(result).
XML builder usage
Since 0.4.0, objects can be also be used to build XML:
var xml2js = require('xml2js');

var obj = {name: "Super", Surname: "Man", age: 23};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root>
  <name>Super</name>
  <Surname>Man</Surname>
  <age>23</age>
</root>
At the moment, a one to one bi-directional conversion is guaranteed only for
default configuration, except for attrkey, charkey and explicitArray options
you can redefine to your taste. Writing CDATA is supported via setting the cdata
option to true.
To specify attributes:
var xml2js = require('xml2js');

var obj = {root: {$: {id: "my id"}, _: "my inner text"}};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root id="my id">my inner text</root>
Adding xmlns attributes
You can generate XML that declares XML namespace prefix / URI pairs with xmlns attributes.
Example declaring a default namespace on the root element:
let obj = { 
  Foo: {
    $: {
      "xmlns": "http://foo.com"
    }   
  }
};  
Result of buildObject(obj):
<Foo xmlns="http://foo.com"/>
Example declaring non-default namespaces on non-root elements:
let obj = {
  'foo:Foo': {
    $: {
      'xmlns:foo': 'http://foo.com'
    },
    'bar:Bar': {
      $: {
        'xmlns:bar': 'http://bar.com'
      }
    }
  }
}
Result of buildObject(obj):
<foo:Foo xmlns:foo="http://foo.com">
  <bar:Bar xmlns:bar="http://bar.com"/>
</foo:Foo>
Processing attribute, tag names and values
Since 0.4.1 you can optionally provide the parser with attribute name and tag name processors as well as element value processors (Since 0.4.14, you can also optionally provide the parser with attribute value processors):
function nameToUpperCase(name){
    return name.toUpperCase();
}

//transform all attribute and tag names and values to uppercase
parseString(xml, {
  tagNameProcessors: [nameToUpperCase],
  attrNameProcessors: [nameToUpperCase],
  valueProcessors: [nameToUpperCase],
  attrValueProcessors: [nameToUpperCase]},
  function (err, result) {
    // processed data
});
The tagNameProcessors and attrNameProcessors options
accept an Array of functions with the following signature:
function (name){
  //do something with `name`
  return name
}
The attrValueProcessors and valueProcessors options
accept an Array of functions with the following signature:
function (value, name) {
  //`name` will be the node name or attribute name
  //do something with `value`, (optionally) dependent on the node/attr name
  return value
}
Some processors are provided out-of-the-box and can be found in lib/processors.js:


normalize: transforms the name to lowercase.
(Automatically used when options.normalize is set to true)


firstCharLowerCase: transforms the first character to lower case.
E.g. 'MyTagName' becomes 'myTagName'


stripPrefix: strips the xml namespace prefix. E.g <foo:Bar/> will become 'Bar'.
(N.B.: the xmlns prefix is NOT stripped.)


parseNumbers: parses integer-like strings as integers and float-like strings as floats
E.g. "0" becomes 0 and "15.56" becomes 15.56


parseBooleans: parses boolean-like strings to booleans
E.g. "true" becomes true and "False" becomes false


Options
Apart from the default settings, there are a number of options that can be
specified for the parser. Options are specified by new Parser({optionName: value}). Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

explicitCharkey (default: false) Determines whether or not to use
a charkey prefix for elements with no attributes.

trim (default: false): Trim the whitespace at the beginning and end of
text nodes.

normalizeTags (default: false): Normalize all tag names to lowercase.

normalize (default: false): Trim whitespaces inside text nodes.

explicitRoot (default: true): Set this if you want to get the root
node in the resulting object.

emptyTag (default: ''): what will the value of empty nodes be. In case
you want to use an empty object as a default value, it is better to provide a factory
function () => ({}) instead. Without this function a plain object would
become a shared reference across all occurrences with unwanted behavior.

explicitArray (default: true): Always put child nodes in an array if
true; otherwise an array is created only if there is more than one.

ignoreAttrs (default: false): Ignore all XML attributes and only create
text nodes.

mergeAttrs (default: false): Merge attributes and child elements as
properties of the parent, instead of keying attributes off a child
attribute object. This option is ignored if ignoreAttrs is true.

validator (default null): You can specify a callable that validates
the resulting structure somehow, however you want. See unit tests
for an example.

xmlns (default false): Give each element a field usually called '$ns'
(the first character is the same as attrkey) that contains its local name
and namespace URI.

explicitChildren (default false): Put child elements to separate
property. Doesn't work with mergeAttrs = true. If element has no children
then "children" won't be created. Added in 0.2.5.

childkey (default $$): Prefix that is used to access child elements if
explicitChildren is set to true. Added in 0.2.5.

preserveChildrenOrder (default false): Modifies the behavior of
explicitChildren so that the value of the "children" property becomes an
ordered array. When this is true, every node will also get a #name field
whose value will correspond to the XML nodeName, so that you may iterate
the "children" array and still be able to determine node names. The named
(and potentially unordered) properties are also retained in this
configuration at the same level as the ordered "children" array. Added in
0.4.9.

charsAsChildren (default false): Determines whether chars should be
considered children if explicitChildren is on. Added in 0.2.5.

includeWhiteChars (default false): Determines whether whitespace-only
text nodes should be included. Added in 0.4.17.

async (default false): Should the callbacks be async? This might be
an incompatible change if your code depends on sync execution of callbacks.
Future versions of xml2js might change this default, so the recommendation
is to not depend on sync execution anyway. Added in 0.2.6.

strict (default true): Set sax-js to strict or non-strict parsing mode.
Defaults to true which is highly recommended, since parsing HTML which
is not well-formed XML might yield just about anything. Added in 0.2.7.

attrNameProcessors (default: null): Allows the addition of attribute
name processing functions. Accepts an Array of functions with following
signature:
function (name){
    //do something with `name`
    return name
}
Added in 0.4.14

attrValueProcessors (default: null): Allows the addition of attribute
value processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.1

tagNameProcessors (default: null): Allows the addition of tag name
processing functions. Accepts an Array of functions with following
signature:
function (name){
  //do something with `name`
  return name
}
Added in 0.4.1

valueProcessors (default: null): Allows the addition of element value
processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.6

Options for the Builder class
These options are specified by new Builder({optionName: value}).
Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

rootName (default root or the root key name): root element name to be used in case
explicitRoot is false or to override the root element name.

renderOpts (default { 'pretty': true, 'indent': '  ', 'newline': '\n' }):
Rendering options for xmlbuilder-js.

pretty: prettify generated XML
indent: whitespace for indentation (only when pretty)
newline: newline char (only when pretty)



xmldec (default { 'version': '1.0', 'encoding': 'UTF-8', 'standalone': true }:
XML declaration attributes.


xmldec.version A version number string, e.g. 1.0

xmldec.encoding Encoding declaration, e.g. UTF-8

xmldec.standalone standalone document declaration: true or false



doctype (default null): optional DTD. Eg. {'ext': 'hello.dtd'}


headless (default: false): omit the XML header. Added in 0.4.3.

allowSurrogateChars (default: false): allows using characters from the Unicode
surrogate blocks.

cdata (default: false): wrap text nodes in <![CDATA[ ... ]]> instead of
escaping when necessary. Does not add <![CDATA[ ... ]]> if it is not required.
Added in 0.4.5.

renderOpts, xmldec,doctype and headless pass through to
xmlbuilder-js.
Updating to new version
Version 0.2 changed the default parsing settings, but version 0.1.14 introduced
the default settings for version 0.2, so these settings can be tried before the
migration.
var xml2js = require('xml2js');
var parser = new xml2js.Parser(xml2js.defaults["0.2"]);
To get the 0.1 defaults in version 0.2 you can just use
xml2js.defaults["0.1"] in the same place. This provides you with enough time
to migrate to the saner way of parsing in xml2js 0.2. We try to make the
migration as simple and gentle as possible, but some breakage cannot be
avoided.
So, what exactly did change and why? In 0.2 we changed some defaults to parse
the XML in a more universal and sane way. So we disabled normalize and trim
so xml2js does not cut out any text content. You can reenable this at will of
course. A more important change is that we return the root tag in the resulting
JavaScript structure via the explicitRoot setting, so you need to access the
first element. This is useful for anybody who wants to know what the root node
is and preserves more information. The last major change was to enable
explicitArray, so everytime it is possible that one might embed more than one
sub-tag into a tag, xml2js >= 0.2 returns an array even if the array just
includes one element. This is useful when dealing with APIs that return
variable amounts of subtags.
Running tests, development



The development requirements are handled by npm, you just need to install them.
We also have a number of unit tests, they can be run using npm test directly
from the project root. This runs zap to discover all the tests and execute
them.
If you like to contribute, keep in mind that xml2js is written in
CoffeeScript, so don't develop on the JavaScript files that are checked into
the repository for convenience reasons. Also, please write some unit test to
check your behaviour and if it is some user-facing thing, add some
documentation to this README, so people will know it exists. Thanks in advance!
Getting support
Please, if you have a problem with the library, first make sure you read this
README. If you read this far, thanks, you're good. Then, please make sure your
problem really is with xml2js. It is? Okay, then I'll look at it. Send me a
mail and we can talk. Please don't open issues, as I don't think that is the
proper forum for support problems. Some problems might as well really be bugs
in xml2js, if so I'll let you know to open an issue instead :)
But if you know you really found a bug, feel free to open an issue instead.
ReadmeKeywordsxmljsonPackage SidebarInstallnpm i xml2jsRepositorygithub.com/Leonidas-from-XIV/node-xml2jsHomepagegithub.com/Leonidas-from-XIV/node-xml2jsWeekly Downloads22,667,333Version0.6.2LicenseMITUnpacked Size3.44 MBTotal Files10Last publish2 years agoCollaboratorsTry on RunKitReport malware\n\nxml2js0.6.2 • Public • Published 2 years ago ReadmeCode Beta2 Dependencies10,262 Dependents52 Versionsnode-xml2js
Ever had the urge to parse XML? And wanted to access the data in some sane,
easy way? Don't want to compile a C parser, for whatever reason? Then xml2js is
what you're looking for!
Description
Simple XML to JavaScript object converter. It supports bi-directional conversion.
Uses sax-js and
xmlbuilder-js.
Note: If you're looking for a full DOM parser, you probably want
JSDom.
Installation
Simplest way to install xml2js is to use npm, just npm install xml2js which will download xml2js and all dependencies.
xml2js is also available via Bower, just bower install xml2js which will download xml2js and all dependencies.
Usage
No extensive tutorials required because you are a smart developer! The task of
parsing XML should be an easy one, so let's make it so! Here's some examples.
Shoot-and-forget usage
You want to parse XML as simple and easy as possible? It's dangerous to go
alone, take this:
var parseString = require('xml2js').parseString;
var xml = "<root>Hello xml2js!</root>"
parseString(xml, function (err, result) {
    console.dir(result);
});
Can't get easier than this, right? This works starting with xml2js 0.2.3.
With CoffeeScript it looks like this:
{parseString} = require 'xml2js'
xml = "<root>Hello xml2js!</root>"
parseString xml, (err, result) ->
    console.dir result
If you need some special options, fear not, xml2js supports a number of
options (see below), you can specify these as second argument:
parseString(xml, {trim: true}, function (err, result) {
});
Simple as pie usage
That's right, if you have been using xml-simple or a home-grown
wrapper, this was added in 0.1.11 just for you:
var fs = require('fs'),
    xml2js = require('xml2js');

var parser = new xml2js.Parser();
fs.readFile(__dirname + '/foo.xml', function(err, data) {
    parser.parseString(data, function (err, result) {
        console.dir(result);
        console.log('Done');
    });
});
Look ma, no event listeners!
You can also use xml2js from
CoffeeScript, further reducing
the clutter:
fs = require 'fs',
xml2js = require 'xml2js'

parser = new xml2js.Parser()
fs.readFile __dirname + '/foo.xml', (err, data) ->
  parser.parseString data, (err, result) ->
    console.dir result
    console.log 'Done.'
But what happens if you forget the new keyword to create a new Parser? In
the middle of a nightly coding session, it might get lost, after all. Worry
not, we got you covered! Starting with 0.2.8 you can also leave it out, in
which case xml2js will helpfully add it for you, no bad surprises and
inexplicable bugs!
Promise usage
var xml2js = require('xml2js');
var xml = '<foo></foo>';

// With parser
var parser = new xml2js.Parser(/* options */);
parser.parseStringPromise(xml).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});

// Without parser
xml2js.parseStringPromise(xml /*, options */).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});
Parsing multiple files
If you want to parse multiple files, you have multiple possibilities:

You can create one xml2js.Parser per file. That's the recommended one
and is promised to always just work.
You can call reset() on your parser object.
You can hope everything goes well anyway. This behaviour is not
guaranteed work always, if ever. Use option #1 if possible. Thanks!

So you wanna some JSON?
Just wrap the result object in a call to JSON.stringify like this
JSON.stringify(result). You get a string containing the JSON representation
of the parsed object that you can feed to JSON-hungry consumers.
Displaying results
You might wonder why, using console.dir or console.log the output at some
level is only [Object]. Don't worry, this is not because xml2js got lazy.
That's because Node uses util.inspect to convert the object into strings and
that function stops after depth=2 which is a bit low for most XML.
To display the whole deal, you can use console.log(util.inspect(result, false, null)), which displays the whole result.
So much for that, but what if you use
eyes for nice colored output and it
truncates the output with …? Don't fear, there's also a solution for that,
you just need to increase the maxLength limit by creating a custom inspector
var inspect = require('eyes').inspector({maxLength: false}) and then you can
easily inspect(result).
XML builder usage
Since 0.4.0, objects can be also be used to build XML:
var xml2js = require('xml2js');

var obj = {name: "Super", Surname: "Man", age: 23};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root>
  <name>Super</name>
  <Surname>Man</Surname>
  <age>23</age>
</root>
At the moment, a one to one bi-directional conversion is guaranteed only for
default configuration, except for attrkey, charkey and explicitArray options
you can redefine to your taste. Writing CDATA is supported via setting the cdata
option to true.
To specify attributes:
var xml2js = require('xml2js');

var obj = {root: {$: {id: "my id"}, _: "my inner text"}};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root id="my id">my inner text</root>
Adding xmlns attributes
You can generate XML that declares XML namespace prefix / URI pairs with xmlns attributes.
Example declaring a default namespace on the root element:
let obj = { 
  Foo: {
    $: {
      "xmlns": "http://foo.com"
    }   
  }
};  
Result of buildObject(obj):
<Foo xmlns="http://foo.com"/>
Example declaring non-default namespaces on non-root elements:
let obj = {
  'foo:Foo': {
    $: {
      'xmlns:foo': 'http://foo.com'
    },
    'bar:Bar': {
      $: {
        'xmlns:bar': 'http://bar.com'
      }
    }
  }
}
Result of buildObject(obj):
<foo:Foo xmlns:foo="http://foo.com">
  <bar:Bar xmlns:bar="http://bar.com"/>
</foo:Foo>
Processing attribute, tag names and values
Since 0.4.1 you can optionally provide the parser with attribute name and tag name processors as well as element value processors (Since 0.4.14, you can also optionally provide the parser with attribute value processors):
function nameToUpperCase(name){
    return name.toUpperCase();
}

//transform all attribute and tag names and values to uppercase
parseString(xml, {
  tagNameProcessors: [nameToUpperCase],
  attrNameProcessors: [nameToUpperCase],
  valueProcessors: [nameToUpperCase],
  attrValueProcessors: [nameToUpperCase]},
  function (err, result) {
    // processed data
});
The tagNameProcessors and attrNameProcessors options
accept an Array of functions with the following signature:
function (name){
  //do something with `name`
  return name
}
The attrValueProcessors and valueProcessors options
accept an Array of functions with the following signature:
function (value, name) {
  //`name` will be the node name or attribute name
  //do something with `value`, (optionally) dependent on the node/attr name
  return value
}
Some processors are provided out-of-the-box and can be found in lib/processors.js:


normalize: transforms the name to lowercase.
(Automatically used when options.normalize is set to true)


firstCharLowerCase: transforms the first character to lower case.
E.g. 'MyTagName' becomes 'myTagName'


stripPrefix: strips the xml namespace prefix. E.g <foo:Bar/> will become 'Bar'.
(N.B.: the xmlns prefix is NOT stripped.)


parseNumbers: parses integer-like strings as integers and float-like strings as floats
E.g. "0" becomes 0 and "15.56" becomes 15.56


parseBooleans: parses boolean-like strings to booleans
E.g. "true" becomes true and "False" becomes false


Options
Apart from the default settings, there are a number of options that can be
specified for the parser. Options are specified by new Parser({optionName: value}). Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

explicitCharkey (default: false) Determines whether or not to use
a charkey prefix for elements with no attributes.

trim (default: false): Trim the whitespace at the beginning and end of
text nodes.

normalizeTags (default: false): Normalize all tag names to lowercase.

normalize (default: false): Trim whitespaces inside text nodes.

explicitRoot (default: true): Set this if you want to get the root
node in the resulting object.

emptyTag (default: ''): what will the value of empty nodes be. In case
you want to use an empty object as a default value, it is better to provide a factory
function () => ({}) instead. Without this function a plain object would
become a shared reference across all occurrences with unwanted behavior.

explicitArray (default: true): Always put child nodes in an array if
true; otherwise an array is created only if there is more than one.

ignoreAttrs (default: false): Ignore all XML attributes and only create
text nodes.

mergeAttrs (default: false): Merge attributes and child elements as
properties of the parent, instead of keying attributes off a child
attribute object. This option is ignored if ignoreAttrs is true.

validator (default null): You can specify a callable that validates
the resulting structure somehow, however you want. See unit tests
for an example.

xmlns (default false): Give each element a field usually called '$ns'
(the first character is the same as attrkey) that contains its local name
and namespace URI.

explicitChildren (default false): Put child elements to separate
property. Doesn't work with mergeAttrs = true. If element has no children
then "children" won't be created. Added in 0.2.5.

childkey (default $$): Prefix that is used to access child elements if
explicitChildren is set to true. Added in 0.2.5.

preserveChildrenOrder (default false): Modifies the behavior of
explicitChildren so that the value of the "children" property becomes an
ordered array. When this is true, every node will also get a #name field
whose value will correspond to the XML nodeName, so that you may iterate
the "children" array and still be able to determine node names. The named
(and potentially unordered) properties are also retained in this
configuration at the same level as the ordered "children" array. Added in
0.4.9.

charsAsChildren (default false): Determines whether chars should be
considered children if explicitChildren is on. Added in 0.2.5.

includeWhiteChars (default false): Determines whether whitespace-only
text nodes should be included. Added in 0.4.17.

async (default false): Should the callbacks be async? This might be
an incompatible change if your code depends on sync execution of callbacks.
Future versions of xml2js might change this default, so the recommendation
is to not depend on sync execution anyway. Added in 0.2.6.

strict (default true): Set sax-js to strict or non-strict parsing mode.
Defaults to true which is highly recommended, since parsing HTML which
is not well-formed XML might yield just about anything. Added in 0.2.7.

attrNameProcessors (default: null): Allows the addition of attribute
name processing functions. Accepts an Array of functions with following
signature:
function (name){
    //do something with `name`
    return name
}
Added in 0.4.14

attrValueProcessors (default: null): Allows the addition of attribute
value processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.1

tagNameProcessors (default: null): Allows the addition of tag name
processing functions. Accepts an Array of functions with following
signature:
function (name){
  //do something with `name`
  return name
}
Added in 0.4.1

valueProcessors (default: null): Allows the addition of element value
processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.6

Options for the Builder class
These options are specified by new Builder({optionName: value}).
Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

rootName (default root or the root key name): root element name to be used in case
explicitRoot is false or to override the root element name.

renderOpts (default { 'pretty': true, 'indent': '  ', 'newline': '\n' }):
Rendering options for xmlbuilder-js.

pretty: prettify generated XML
indent: whitespace for indentation (only when pretty)
newline: newline char (only when pretty)



xmldec (default { 'version': '1.0', 'encoding': 'UTF-8', 'standalone': true }:
XML declaration attributes.


xmldec.version A version number string, e.g. 1.0

xmldec.encoding Encoding declaration, e.g. UTF-8

xmldec.standalone standalone document declaration: true or false



doctype (default null): optional DTD. Eg. {'ext': 'hello.dtd'}


headless (default: false): omit the XML header. Added in 0.4.3.

allowSurrogateChars (default: false): allows using characters from the Unicode
surrogate blocks.

cdata (default: false): wrap text nodes in <![CDATA[ ... ]]> instead of
escaping when necessary. Does not add <![CDATA[ ... ]]> if it is not required.
Added in 0.4.5.

renderOpts, xmldec,doctype and headless pass through to
xmlbuilder-js.
Updating to new version
Version 0.2 changed the default parsing settings, but version 0.1.14 introduced
the default settings for version 0.2, so these settings can be tried before the
migration.
var xml2js = require('xml2js');
var parser = new xml2js.Parser(xml2js.defaults["0.2"]);
To get the 0.1 defaults in version 0.2 you can just use
xml2js.defaults["0.1"] in the same place. This provides you with enough time
to migrate to the saner way of parsing in xml2js 0.2. We try to make the
migration as simple and gentle as possible, but some breakage cannot be
avoided.
So, what exactly did change and why? In 0.2 we changed some defaults to parse
the XML in a more universal and sane way. So we disabled normalize and trim
so xml2js does not cut out any text content. You can reenable this at will of
course. A more important change is that we return the root tag in the resulting
JavaScript structure via the explicitRoot setting, so you need to access the
first element. This is useful for anybody who wants to know what the root node
is and preserves more information. The last major change was to enable
explicitArray, so everytime it is possible that one might embed more than one
sub-tag into a tag, xml2js >= 0.2 returns an array even if the array just
includes one element. This is useful when dealing with APIs that return
variable amounts of subtags.
Running tests, development



The development requirements are handled by npm, you just need to install them.
We also have a number of unit tests, they can be run using npm test directly
from the project root. This runs zap to discover all the tests and execute
them.
If you like to contribute, keep in mind that xml2js is written in
CoffeeScript, so don't develop on the JavaScript files that are checked into
the repository for convenience reasons. Also, please write some unit test to
check your behaviour and if it is some user-facing thing, add some
documentation to this README, so people will know it exists. Thanks in advance!
Getting support
Please, if you have a problem with the library, first make sure you read this
README. If you read this far, thanks, you're good. Then, please make sure your
problem really is with xml2js. It is? Okay, then I'll look at it. Send me a
mail and we can talk. Please don't open issues, as I don't think that is the
proper forum for support problems. Some problems might as well really be bugs
in xml2js, if so I'll let you know to open an issue instead :)
But if you know you really found a bug, feel free to open an issue instead.
ReadmeKeywordsxmljsonPackage SidebarInstallnpm i xml2jsRepositorygithub.com/Leonidas-from-XIV/node-xml2jsHomepagegithub.com/Leonidas-from-XIV/node-xml2jsWeekly Downloads22,667,333Version0.6.2LicenseMITUnpacked Size3.44 MBTotal Files10Last publish2 years agoCollaboratorsTry on RunKitReport malware\n\n\n\nnode-xml2js
Ever had the urge to parse XML? And wanted to access the data in some sane,
easy way? Don't want to compile a C parser, for whatever reason? Then xml2js is
what you're looking for!
Description
Simple XML to JavaScript object converter. It supports bi-directional conversion.
Uses sax-js and
xmlbuilder-js.
Note: If you're looking for a full DOM parser, you probably want
JSDom.
Installation
Simplest way to install xml2js is to use npm, just npm install xml2js which will download xml2js and all dependencies.
xml2js is also available via Bower, just bower install xml2js which will download xml2js and all dependencies.
Usage
No extensive tutorials required because you are a smart developer! The task of
parsing XML should be an easy one, so let's make it so! Here's some examples.
Shoot-and-forget usage
You want to parse XML as simple and easy as possible? It's dangerous to go
alone, take this:
var parseString = require('xml2js').parseString;
var xml = "<root>Hello xml2js!</root>"
parseString(xml, function (err, result) {
    console.dir(result);
});
Can't get easier than this, right? This works starting with xml2js 0.2.3.
With CoffeeScript it looks like this:
{parseString} = require 'xml2js'
xml = "<root>Hello xml2js!</root>"
parseString xml, (err, result) ->
    console.dir result
If you need some special options, fear not, xml2js supports a number of
options (see below), you can specify these as second argument:
parseString(xml, {trim: true}, function (err, result) {
});
Simple as pie usage
That's right, if you have been using xml-simple or a home-grown
wrapper, this was added in 0.1.11 just for you:
var fs = require('fs'),
    xml2js = require('xml2js');

var parser = new xml2js.Parser();
fs.readFile(__dirname + '/foo.xml', function(err, data) {
    parser.parseString(data, function (err, result) {
        console.dir(result);
        console.log('Done');
    });
});
Look ma, no event listeners!
You can also use xml2js from
CoffeeScript, further reducing
the clutter:
fs = require 'fs',
xml2js = require 'xml2js'

parser = new xml2js.Parser()
fs.readFile __dirname + '/foo.xml', (err, data) ->
  parser.parseString data, (err, result) ->
    console.dir result
    console.log 'Done.'
But what happens if you forget the new keyword to create a new Parser? In
the middle of a nightly coding session, it might get lost, after all. Worry
not, we got you covered! Starting with 0.2.8 you can also leave it out, in
which case xml2js will helpfully add it for you, no bad surprises and
inexplicable bugs!
Promise usage
var xml2js = require('xml2js');
var xml = '<foo></foo>';

// With parser
var parser = new xml2js.Parser(/* options */);
parser.parseStringPromise(xml).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});

// Without parser
xml2js.parseStringPromise(xml /*, options */).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});
Parsing multiple files
If you want to parse multiple files, you have multiple possibilities:

You can create one xml2js.Parser per file. That's the recommended one
and is promised to always just work.
You can call reset() on your parser object.
You can hope everything goes well anyway. This behaviour is not
guaranteed work always, if ever. Use option #1 if possible. Thanks!

So you wanna some JSON?
Just wrap the result object in a call to JSON.stringify like this
JSON.stringify(result). You get a string containing the JSON representation
of the parsed object that you can feed to JSON-hungry consumers.
Displaying results
You might wonder why, using console.dir or console.log the output at some
level is only [Object]. Don't worry, this is not because xml2js got lazy.
That's because Node uses util.inspect to convert the object into strings and
that function stops after depth=2 which is a bit low for most XML.
To display the whole deal, you can use console.log(util.inspect(result, false, null)), which displays the whole result.
So much for that, but what if you use
eyes for nice colored output and it
truncates the output with …? Don't fear, there's also a solution for that,
you just need to increase the maxLength limit by creating a custom inspector
var inspect = require('eyes').inspector({maxLength: false}) and then you can
easily inspect(result).
XML builder usage
Since 0.4.0, objects can be also be used to build XML:
var xml2js = require('xml2js');

var obj = {name: "Super", Surname: "Man", age: 23};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root>
  <name>Super</name>
  <Surname>Man</Surname>
  <age>23</age>
</root>
At the moment, a one to one bi-directional conversion is guaranteed only for
default configuration, except for attrkey, charkey and explicitArray options
you can redefine to your taste. Writing CDATA is supported via setting the cdata
option to true.
To specify attributes:
var xml2js = require('xml2js');

var obj = {root: {$: {id: "my id"}, _: "my inner text"}};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root id="my id">my inner text</root>
Adding xmlns attributes
You can generate XML that declares XML namespace prefix / URI pairs with xmlns attributes.
Example declaring a default namespace on the root element:
let obj = { 
  Foo: {
    $: {
      "xmlns": "http://foo.com"
    }   
  }
};  
Result of buildObject(obj):
<Foo xmlns="http://foo.com"/>
Example declaring non-default namespaces on non-root elements:
let obj = {
  'foo:Foo': {
    $: {
      'xmlns:foo': 'http://foo.com'
    },
    'bar:Bar': {
      $: {
        'xmlns:bar': 'http://bar.com'
      }
    }
  }
}
Result of buildObject(obj):
<foo:Foo xmlns:foo="http://foo.com">
  <bar:Bar xmlns:bar="http://bar.com"/>
</foo:Foo>
Processing attribute, tag names and values
Since 0.4.1 you can optionally provide the parser with attribute name and tag name processors as well as element value processors (Since 0.4.14, you can also optionally provide the parser with attribute value processors):
function nameToUpperCase(name){
    return name.toUpperCase();
}

//transform all attribute and tag names and values to uppercase
parseString(xml, {
  tagNameProcessors: [nameToUpperCase],
  attrNameProcessors: [nameToUpperCase],
  valueProcessors: [nameToUpperCase],
  attrValueProcessors: [nameToUpperCase]},
  function (err, result) {
    // processed data
});
The tagNameProcessors and attrNameProcessors options
accept an Array of functions with the following signature:
function (name){
  //do something with `name`
  return name
}
The attrValueProcessors and valueProcessors options
accept an Array of functions with the following signature:
function (value, name) {
  //`name` will be the node name or attribute name
  //do something with `value`, (optionally) dependent on the node/attr name
  return value
}
Some processors are provided out-of-the-box and can be found in lib/processors.js:


normalize: transforms the name to lowercase.
(Automatically used when options.normalize is set to true)


firstCharLowerCase: transforms the first character to lower case.
E.g. 'MyTagName' becomes 'myTagName'


stripPrefix: strips the xml namespace prefix. E.g <foo:Bar/> will become 'Bar'.
(N.B.: the xmlns prefix is NOT stripped.)


parseNumbers: parses integer-like strings as integers and float-like strings as floats
E.g. "0" becomes 0 and "15.56" becomes 15.56


parseBooleans: parses boolean-like strings to booleans
E.g. "true" becomes true and "False" becomes false


Options
Apart from the default settings, there are a number of options that can be
specified for the parser. Options are specified by new Parser({optionName: value}). Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

explicitCharkey (default: false) Determines whether or not to use
a charkey prefix for elements with no attributes.

trim (default: false): Trim the whitespace at the beginning and end of
text nodes.

normalizeTags (default: false): Normalize all tag names to lowercase.

normalize (default: false): Trim whitespaces inside text nodes.

explicitRoot (default: true): Set this if you want to get the root
node in the resulting object.

emptyTag (default: ''): what will the value of empty nodes be. In case
you want to use an empty object as a default value, it is better to provide a factory
function () => ({}) instead. Without this function a plain object would
become a shared reference across all occurrences with unwanted behavior.

explicitArray (default: true): Always put child nodes in an array if
true; otherwise an array is created only if there is more than one.

ignoreAttrs (default: false): Ignore all XML attributes and only create
text nodes.

mergeAttrs (default: false): Merge attributes and child elements as
properties of the parent, instead of keying attributes off a child
attribute object. This option is ignored if ignoreAttrs is true.

validator (default null): You can specify a callable that validates
the resulting structure somehow, however you want. See unit tests
for an example.

xmlns (default false): Give each element a field usually called '$ns'
(the first character is the same as attrkey) that contains its local name
and namespace URI.

explicitChildren (default false): Put child elements to separate
property. Doesn't work with mergeAttrs = true. If element has no children
then "children" won't be created. Added in 0.2.5.

childkey (default $$): Prefix that is used to access child elements if
explicitChildren is set to true. Added in 0.2.5.

preserveChildrenOrder (default false): Modifies the behavior of
explicitChildren so that the value of the "children" property becomes an
ordered array. When this is true, every node will also get a #name field
whose value will correspond to the XML nodeName, so that you may iterate
the "children" array and still be able to determine node names. The named
(and potentially unordered) properties are also retained in this
configuration at the same level as the ordered "children" array. Added in
0.4.9.

charsAsChildren (default false): Determines whether chars should be
considered children if explicitChildren is on. Added in 0.2.5.

includeWhiteChars (default false): Determines whether whitespace-only
text nodes should be included. Added in 0.4.17.

async (default false): Should the callbacks be async? This might be
an incompatible change if your code depends on sync execution of callbacks.
Future versions of xml2js might change this default, so the recommendation
is to not depend on sync execution anyway. Added in 0.2.6.

strict (default true): Set sax-js to strict or non-strict parsing mode.
Defaults to true which is highly recommended, since parsing HTML which
is not well-formed XML might yield just about anything. Added in 0.2.7.

attrNameProcessors (default: null): Allows the addition of attribute
name processing functions. Accepts an Array of functions with following
signature:
function (name){
    //do something with `name`
    return name
}
Added in 0.4.14

attrValueProcessors (default: null): Allows the addition of attribute
value processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.1

tagNameProcessors (default: null): Allows the addition of tag name
processing functions. Accepts an Array of functions with following
signature:
function (name){
  //do something with `name`
  return name
}
Added in 0.4.1

valueProcessors (default: null): Allows the addition of element value
processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.6

Options for the Builder class
These options are specified by new Builder({optionName: value}).
Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

rootName (default root or the root key name): root element name to be used in case
explicitRoot is false or to override the root element name.

renderOpts (default { 'pretty': true, 'indent': '  ', 'newline': '\n' }):
Rendering options for xmlbuilder-js.

pretty: prettify generated XML
indent: whitespace for indentation (only when pretty)
newline: newline char (only when pretty)



xmldec (default { 'version': '1.0', 'encoding': 'UTF-8', 'standalone': true }:
XML declaration attributes.


xmldec.version A version number string, e.g. 1.0

xmldec.encoding Encoding declaration, e.g. UTF-8

xmldec.standalone standalone document declaration: true or false



doctype (default null): optional DTD. Eg. {'ext': 'hello.dtd'}


headless (default: false): omit the XML header. Added in 0.4.3.

allowSurrogateChars (default: false): allows using characters from the Unicode
surrogate blocks.

cdata (default: false): wrap text nodes in <![CDATA[ ... ]]> instead of
escaping when necessary. Does not add <![CDATA[ ... ]]> if it is not required.
Added in 0.4.5.

renderOpts, xmldec,doctype and headless pass through to
xmlbuilder-js.
Updating to new version
Version 0.2 changed the default parsing settings, but version 0.1.14 introduced
the default settings for version 0.2, so these settings can be tried before the
migration.
var xml2js = require('xml2js');
var parser = new xml2js.Parser(xml2js.defaults["0.2"]);
To get the 0.1 defaults in version 0.2 you can just use
xml2js.defaults["0.1"] in the same place. This provides you with enough time
to migrate to the saner way of parsing in xml2js 0.2. We try to make the
migration as simple and gentle as possible, but some breakage cannot be
avoided.
So, what exactly did change and why? In 0.2 we changed some defaults to parse
the XML in a more universal and sane way. So we disabled normalize and trim
so xml2js does not cut out any text content. You can reenable this at will of
course. A more important change is that we return the root tag in the resulting
JavaScript structure via the explicitRoot setting, so you need to access the
first element. This is useful for anybody who wants to know what the root node
is and preserves more information. The last major change was to enable
explicitArray, so everytime it is possible that one might embed more than one
sub-tag into a tag, xml2js >= 0.2 returns an array even if the array just
includes one element. This is useful when dealing with APIs that return
variable amounts of subtags.
Running tests, development



The development requirements are handled by npm, you just need to install them.
We also have a number of unit tests, they can be run using npm test directly
from the project root. This runs zap to discover all the tests and execute
them.
If you like to contribute, keep in mind that xml2js is written in
CoffeeScript, so don't develop on the JavaScript files that are checked into
the repository for convenience reasons. Also, please write some unit test to
check your behaviour and if it is some user-facing thing, add some
documentation to this README, so people will know it exists. Thanks in advance!
Getting support
Please, if you have a problem with the library, first make sure you read this
README. If you read this far, thanks, you're good. Then, please make sure your
problem really is with xml2js. It is? Okay, then I'll look at it. Send me a
mail and we can talk. Please don't open issues, as I don't think that is the
proper forum for support problems. Some problems might as well really be bugs
in xml2js, if so I'll let you know to open an issue instead :)
But if you know you really found a bug, feel free to open an issue instead.\n\nxml2js0.6.2 • Public • Published 2 years ago ReadmeCode Beta2 Dependencies10,262 Dependents52 Versionsnode-xml2js
Ever had the urge to parse XML? And wanted to access the data in some sane,
easy way? Don't want to compile a C parser, for whatever reason? Then xml2js is
what you're looking for!
Description
Simple XML to JavaScript object converter. It supports bi-directional conversion.
Uses sax-js and
xmlbuilder-js.
Note: If you're looking for a full DOM parser, you probably want
JSDom.
Installation
Simplest way to install xml2js is to use npm, just npm install xml2js which will download xml2js and all dependencies.
xml2js is also available via Bower, just bower install xml2js which will download xml2js and all dependencies.
Usage
No extensive tutorials required because you are a smart developer! The task of
parsing XML should be an easy one, so let's make it so! Here's some examples.
Shoot-and-forget usage
You want to parse XML as simple and easy as possible? It's dangerous to go
alone, take this:
var parseString = require('xml2js').parseString;
var xml = "<root>Hello xml2js!</root>"
parseString(xml, function (err, result) {
    console.dir(result);
});
Can't get easier than this, right? This works starting with xml2js 0.2.3.
With CoffeeScript it looks like this:
{parseString} = require 'xml2js'
xml = "<root>Hello xml2js!</root>"
parseString xml, (err, result) ->
    console.dir result
If you need some special options, fear not, xml2js supports a number of
options (see below), you can specify these as second argument:
parseString(xml, {trim: true}, function (err, result) {
});
Simple as pie usage
That's right, if you have been using xml-simple or a home-grown
wrapper, this was added in 0.1.11 just for you:
var fs = require('fs'),
    xml2js = require('xml2js');

var parser = new xml2js.Parser();
fs.readFile(__dirname + '/foo.xml', function(err, data) {
    parser.parseString(data, function (err, result) {
        console.dir(result);
        console.log('Done');
    });
});
Look ma, no event listeners!
You can also use xml2js from
CoffeeScript, further reducing
the clutter:
fs = require 'fs',
xml2js = require 'xml2js'

parser = new xml2js.Parser()
fs.readFile __dirname + '/foo.xml', (err, data) ->
  parser.parseString data, (err, result) ->
    console.dir result
    console.log 'Done.'
But what happens if you forget the new keyword to create a new Parser? In
the middle of a nightly coding session, it might get lost, after all. Worry
not, we got you covered! Starting with 0.2.8 you can also leave it out, in
which case xml2js will helpfully add it for you, no bad surprises and
inexplicable bugs!
Promise usage
var xml2js = require('xml2js');
var xml = '<foo></foo>';

// With parser
var parser = new xml2js.Parser(/* options */);
parser.parseStringPromise(xml).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});

// Without parser
xml2js.parseStringPromise(xml /*, options */).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});
Parsing multiple files
If you want to parse multiple files, you have multiple possibilities:

You can create one xml2js.Parser per file. That's the recommended one
and is promised to always just work.
You can call reset() on your parser object.
You can hope everything goes well anyway. This behaviour is not
guaranteed work always, if ever. Use option #1 if possible. Thanks!

So you wanna some JSON?
Just wrap the result object in a call to JSON.stringify like this
JSON.stringify(result). You get a string containing the JSON representation
of the parsed object that you can feed to JSON-hungry consumers.
Displaying results
You might wonder why, using console.dir or console.log the output at some
level is only [Object]. Don't worry, this is not because xml2js got lazy.
That's because Node uses util.inspect to convert the object into strings and
that function stops after depth=2 which is a bit low for most XML.
To display the whole deal, you can use console.log(util.inspect(result, false, null)), which displays the whole result.
So much for that, but what if you use
eyes for nice colored output and it
truncates the output with …? Don't fear, there's also a solution for that,
you just need to increase the maxLength limit by creating a custom inspector
var inspect = require('eyes').inspector({maxLength: false}) and then you can
easily inspect(result).
XML builder usage
Since 0.4.0, objects can be also be used to build XML:
var xml2js = require('xml2js');

var obj = {name: "Super", Surname: "Man", age: 23};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root>
  <name>Super</name>
  <Surname>Man</Surname>
  <age>23</age>
</root>
At the moment, a one to one bi-directional conversion is guaranteed only for
default configuration, except for attrkey, charkey and explicitArray options
you can redefine to your taste. Writing CDATA is supported via setting the cdata
option to true.
To specify attributes:
var xml2js = require('xml2js');

var obj = {root: {$: {id: "my id"}, _: "my inner text"}};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root id="my id">my inner text</root>
Adding xmlns attributes
You can generate XML that declares XML namespace prefix / URI pairs with xmlns attributes.
Example declaring a default namespace on the root element:
let obj = { 
  Foo: {
    $: {
      "xmlns": "http://foo.com"
    }   
  }
};  
Result of buildObject(obj):
<Foo xmlns="http://foo.com"/>
Example declaring non-default namespaces on non-root elements:
let obj = {
  'foo:Foo': {
    $: {
      'xmlns:foo': 'http://foo.com'
    },
    'bar:Bar': {
      $: {
        'xmlns:bar': 'http://bar.com'
      }
    }
  }
}
Result of buildObject(obj):
<foo:Foo xmlns:foo="http://foo.com">
  <bar:Bar xmlns:bar="http://bar.com"/>
</foo:Foo>
Processing attribute, tag names and values
Since 0.4.1 you can optionally provide the parser with attribute name and tag name processors as well as element value processors (Since 0.4.14, you can also optionally provide the parser with attribute value processors):
function nameToUpperCase(name){
    return name.toUpperCase();
}

//transform all attribute and tag names and values to uppercase
parseString(xml, {
  tagNameProcessors: [nameToUpperCase],
  attrNameProcessors: [nameToUpperCase],
  valueProcessors: [nameToUpperCase],
  attrValueProcessors: [nameToUpperCase]},
  function (err, result) {
    // processed data
});
The tagNameProcessors and attrNameProcessors options
accept an Array of functions with the following signature:
function (name){
  //do something with `name`
  return name
}
The attrValueProcessors and valueProcessors options
accept an Array of functions with the following signature:
function (value, name) {
  //`name` will be the node name or attribute name
  //do something with `value`, (optionally) dependent on the node/attr name
  return value
}
Some processors are provided out-of-the-box and can be found in lib/processors.js:


normalize: transforms the name to lowercase.
(Automatically used when options.normalize is set to true)


firstCharLowerCase: transforms the first character to lower case.
E.g. 'MyTagName' becomes 'myTagName'


stripPrefix: strips the xml namespace prefix. E.g <foo:Bar/> will become 'Bar'.
(N.B.: the xmlns prefix is NOT stripped.)


parseNumbers: parses integer-like strings as integers and float-like strings as floats
E.g. "0" becomes 0 and "15.56" becomes 15.56


parseBooleans: parses boolean-like strings to booleans
E.g. "true" becomes true and "False" becomes false


Options
Apart from the default settings, there are a number of options that can be
specified for the parser. Options are specified by new Parser({optionName: value}). Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

explicitCharkey (default: false) Determines whether or not to use
a charkey prefix for elements with no attributes.

trim (default: false): Trim the whitespace at the beginning and end of
text nodes.

normalizeTags (default: false): Normalize all tag names to lowercase.

normalize (default: false): Trim whitespaces inside text nodes.

explicitRoot (default: true): Set this if you want to get the root
node in the resulting object.

emptyTag (default: ''): what will the value of empty nodes be. In case
you want to use an empty object as a default value, it is better to provide a factory
function () => ({}) instead. Without this function a plain object would
become a shared reference across all occurrences with unwanted behavior.

explicitArray (default: true): Always put child nodes in an array if
true; otherwise an array is created only if there is more than one.

ignoreAttrs (default: false): Ignore all XML attributes and only create
text nodes.

mergeAttrs (default: false): Merge attributes and child elements as
properties of the parent, instead of keying attributes off a child
attribute object. This option is ignored if ignoreAttrs is true.

validator (default null): You can specify a callable that validates
the resulting structure somehow, however you want. See unit tests
for an example.

xmlns (default false): Give each element a field usually called '$ns'
(the first character is the same as attrkey) that contains its local name
and namespace URI.

explicitChildren (default false): Put child elements to separate
property. Doesn't work with mergeAttrs = true. If element has no children
then "children" won't be created. Added in 0.2.5.

childkey (default $$): Prefix that is used to access child elements if
explicitChildren is set to true. Added in 0.2.5.

preserveChildrenOrder (default false): Modifies the behavior of
explicitChildren so that the value of the "children" property becomes an
ordered array. When this is true, every node will also get a #name field
whose value will correspond to the XML nodeName, so that you may iterate
the "children" array and still be able to determine node names. The named
(and potentially unordered) properties are also retained in this
configuration at the same level as the ordered "children" array. Added in
0.4.9.

charsAsChildren (default false): Determines whether chars should be
considered children if explicitChildren is on. Added in 0.2.5.

includeWhiteChars (default false): Determines whether whitespace-only
text nodes should be included. Added in 0.4.17.

async (default false): Should the callbacks be async? This might be
an incompatible change if your code depends on sync execution of callbacks.
Future versions of xml2js might change this default, so the recommendation
is to not depend on sync execution anyway. Added in 0.2.6.

strict (default true): Set sax-js to strict or non-strict parsing mode.
Defaults to true which is highly recommended, since parsing HTML which
is not well-formed XML might yield just about anything. Added in 0.2.7.

attrNameProcessors (default: null): Allows the addition of attribute
name processing functions. Accepts an Array of functions with following
signature:
function (name){
    //do something with `name`
    return name
}
Added in 0.4.14

attrValueProcessors (default: null): Allows the addition of attribute
value processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.1

tagNameProcessors (default: null): Allows the addition of tag name
processing functions. Accepts an Array of functions with following
signature:
function (name){
  //do something with `name`
  return name
}
Added in 0.4.1

valueProcessors (default: null): Allows the addition of element value
processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.6

Options for the Builder class
These options are specified by new Builder({optionName: value}).
Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

rootName (default root or the root key name): root element name to be used in case
explicitRoot is false or to override the root element name.

renderOpts (default { 'pretty': true, 'indent': '  ', 'newline': '\n' }):
Rendering options for xmlbuilder-js.

pretty: prettify generated XML
indent: whitespace for indentation (only when pretty)
newline: newline char (only when pretty)



xmldec (default { 'version': '1.0', 'encoding': 'UTF-8', 'standalone': true }:
XML declaration attributes.


xmldec.version A version number string, e.g. 1.0

xmldec.encoding Encoding declaration, e.g. UTF-8

xmldec.standalone standalone document declaration: true or false



doctype (default null): optional DTD. Eg. {'ext': 'hello.dtd'}


headless (default: false): omit the XML header. Added in 0.4.3.

allowSurrogateChars (default: false): allows using characters from the Unicode
surrogate blocks.

cdata (default: false): wrap text nodes in <![CDATA[ ... ]]> instead of
escaping when necessary. Does not add <![CDATA[ ... ]]> if it is not required.
Added in 0.4.5.

renderOpts, xmldec,doctype and headless pass through to
xmlbuilder-js.
Updating to new version
Version 0.2 changed the default parsing settings, but version 0.1.14 introduced
the default settings for version 0.2, so these settings can be tried before the
migration.
var xml2js = require('xml2js');
var parser = new xml2js.Parser(xml2js.defaults["0.2"]);
To get the 0.1 defaults in version 0.2 you can just use
xml2js.defaults["0.1"] in the same place. This provides you with enough time
to migrate to the saner way of parsing in xml2js 0.2. We try to make the
migration as simple and gentle as possible, but some breakage cannot be
avoided.
So, what exactly did change and why? In 0.2 we changed some defaults to parse
the XML in a more universal and sane way. So we disabled normalize and trim
so xml2js does not cut out any text content. You can reenable this at will of
course. A more important change is that we return the root tag in the resulting
JavaScript structure via the explicitRoot setting, so you need to access the
first element. This is useful for anybody who wants to know what the root node
is and preserves more information. The last major change was to enable
explicitArray, so everytime it is possible that one might embed more than one
sub-tag into a tag, xml2js >= 0.2 returns an array even if the array just
includes one element. This is useful when dealing with APIs that return
variable amounts of subtags.
Running tests, development



The development requirements are handled by npm, you just need to install them.
We also have a number of unit tests, they can be run using npm test directly
from the project root. This runs zap to discover all the tests and execute
them.
If you like to contribute, keep in mind that xml2js is written in
CoffeeScript, so don't develop on the JavaScript files that are checked into
the repository for convenience reasons. Also, please write some unit test to
check your behaviour and if it is some user-facing thing, add some
documentation to this README, so people will know it exists. Thanks in advance!
Getting support
Please, if you have a problem with the library, first make sure you read this
README. If you read this far, thanks, you're good. Then, please make sure your
problem really is with xml2js. It is? Okay, then I'll look at it. Send me a
mail and we can talk. Please don't open issues, as I don't think that is the
proper forum for support problems. Some problems might as well really be bugs
in xml2js, if so I'll let you know to open an issue instead :)
But if you know you really found a bug, feel free to open an issue instead.
ReadmeKeywordsxmljsonPackage SidebarInstallnpm i xml2jsRepositorygithub.com/Leonidas-from-XIV/node-xml2jsHomepagegithub.com/Leonidas-from-XIV/node-xml2jsWeekly Downloads22,667,333Version0.6.2LicenseMITUnpacked Size3.44 MBTotal Files10Last publish2 years agoCollaboratorsTry on RunKitReport malware\n\nxml2js0.6.2 • Public • Published 2 years ago ReadmeCode Beta2 Dependencies10,262 Dependents52 Versionsnode-xml2js
Ever had the urge to parse XML? And wanted to access the data in some sane,
easy way? Don't want to compile a C parser, for whatever reason? Then xml2js is
what you're looking for!
Description
Simple XML to JavaScript object converter. It supports bi-directional conversion.
Uses sax-js and
xmlbuilder-js.
Note: If you're looking for a full DOM parser, you probably want
JSDom.
Installation
Simplest way to install xml2js is to use npm, just npm install xml2js which will download xml2js and all dependencies.
xml2js is also available via Bower, just bower install xml2js which will download xml2js and all dependencies.
Usage
No extensive tutorials required because you are a smart developer! The task of
parsing XML should be an easy one, so let's make it so! Here's some examples.
Shoot-and-forget usage
You want to parse XML as simple and easy as possible? It's dangerous to go
alone, take this:
var parseString = require('xml2js').parseString;
var xml = "<root>Hello xml2js!</root>"
parseString(xml, function (err, result) {
    console.dir(result);
});
Can't get easier than this, right? This works starting with xml2js 0.2.3.
With CoffeeScript it looks like this:
{parseString} = require 'xml2js'
xml = "<root>Hello xml2js!</root>"
parseString xml, (err, result) ->
    console.dir result
If you need some special options, fear not, xml2js supports a number of
options (see below), you can specify these as second argument:
parseString(xml, {trim: true}, function (err, result) {
});
Simple as pie usage
That's right, if you have been using xml-simple or a home-grown
wrapper, this was added in 0.1.11 just for you:
var fs = require('fs'),
    xml2js = require('xml2js');

var parser = new xml2js.Parser();
fs.readFile(__dirname + '/foo.xml', function(err, data) {
    parser.parseString(data, function (err, result) {
        console.dir(result);
        console.log('Done');
    });
});
Look ma, no event listeners!
You can also use xml2js from
CoffeeScript, further reducing
the clutter:
fs = require 'fs',
xml2js = require 'xml2js'

parser = new xml2js.Parser()
fs.readFile __dirname + '/foo.xml', (err, data) ->
  parser.parseString data, (err, result) ->
    console.dir result
    console.log 'Done.'
But what happens if you forget the new keyword to create a new Parser? In
the middle of a nightly coding session, it might get lost, after all. Worry
not, we got you covered! Starting with 0.2.8 you can also leave it out, in
which case xml2js will helpfully add it for you, no bad surprises and
inexplicable bugs!
Promise usage
var xml2js = require('xml2js');
var xml = '<foo></foo>';

// With parser
var parser = new xml2js.Parser(/* options */);
parser.parseStringPromise(xml).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});

// Without parser
xml2js.parseStringPromise(xml /*, options */).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});
Parsing multiple files
If you want to parse multiple files, you have multiple possibilities:

You can create one xml2js.Parser per file. That's the recommended one
and is promised to always just work.
You can call reset() on your parser object.
You can hope everything goes well anyway. This behaviour is not
guaranteed work always, if ever. Use option #1 if possible. Thanks!

So you wanna some JSON?
Just wrap the result object in a call to JSON.stringify like this
JSON.stringify(result). You get a string containing the JSON representation
of the parsed object that you can feed to JSON-hungry consumers.
Displaying results
You might wonder why, using console.dir or console.log the output at some
level is only [Object]. Don't worry, this is not because xml2js got lazy.
That's because Node uses util.inspect to convert the object into strings and
that function stops after depth=2 which is a bit low for most XML.
To display the whole deal, you can use console.log(util.inspect(result, false, null)), which displays the whole result.
So much for that, but what if you use
eyes for nice colored output and it
truncates the output with …? Don't fear, there's also a solution for that,
you just need to increase the maxLength limit by creating a custom inspector
var inspect = require('eyes').inspector({maxLength: false}) and then you can
easily inspect(result).
XML builder usage
Since 0.4.0, objects can be also be used to build XML:
var xml2js = require('xml2js');

var obj = {name: "Super", Surname: "Man", age: 23};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root>
  <name>Super</name>
  <Surname>Man</Surname>
  <age>23</age>
</root>
At the moment, a one to one bi-directional conversion is guaranteed only for
default configuration, except for attrkey, charkey and explicitArray options
you can redefine to your taste. Writing CDATA is supported via setting the cdata
option to true.
To specify attributes:
var xml2js = require('xml2js');

var obj = {root: {$: {id: "my id"}, _: "my inner text"}};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root id="my id">my inner text</root>
Adding xmlns attributes
You can generate XML that declares XML namespace prefix / URI pairs with xmlns attributes.
Example declaring a default namespace on the root element:
let obj = { 
  Foo: {
    $: {
      "xmlns": "http://foo.com"
    }   
  }
};  
Result of buildObject(obj):
<Foo xmlns="http://foo.com"/>
Example declaring non-default namespaces on non-root elements:
let obj = {
  'foo:Foo': {
    $: {
      'xmlns:foo': 'http://foo.com'
    },
    'bar:Bar': {
      $: {
        'xmlns:bar': 'http://bar.com'
      }
    }
  }
}
Result of buildObject(obj):
<foo:Foo xmlns:foo="http://foo.com">
  <bar:Bar xmlns:bar="http://bar.com"/>
</foo:Foo>
Processing attribute, tag names and values
Since 0.4.1 you can optionally provide the parser with attribute name and tag name processors as well as element value processors (Since 0.4.14, you can also optionally provide the parser with attribute value processors):
function nameToUpperCase(name){
    return name.toUpperCase();
}

//transform all attribute and tag names and values to uppercase
parseString(xml, {
  tagNameProcessors: [nameToUpperCase],
  attrNameProcessors: [nameToUpperCase],
  valueProcessors: [nameToUpperCase],
  attrValueProcessors: [nameToUpperCase]},
  function (err, result) {
    // processed data
});
The tagNameProcessors and attrNameProcessors options
accept an Array of functions with the following signature:
function (name){
  //do something with `name`
  return name
}
The attrValueProcessors and valueProcessors options
accept an Array of functions with the following signature:
function (value, name) {
  //`name` will be the node name or attribute name
  //do something with `value`, (optionally) dependent on the node/attr name
  return value
}
Some processors are provided out-of-the-box and can be found in lib/processors.js:


normalize: transforms the name to lowercase.
(Automatically used when options.normalize is set to true)


firstCharLowerCase: transforms the first character to lower case.
E.g. 'MyTagName' becomes 'myTagName'


stripPrefix: strips the xml namespace prefix. E.g <foo:Bar/> will become 'Bar'.
(N.B.: the xmlns prefix is NOT stripped.)


parseNumbers: parses integer-like strings as integers and float-like strings as floats
E.g. "0" becomes 0 and "15.56" becomes 15.56


parseBooleans: parses boolean-like strings to booleans
E.g. "true" becomes true and "False" becomes false


Options
Apart from the default settings, there are a number of options that can be
specified for the parser. Options are specified by new Parser({optionName: value}). Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

explicitCharkey (default: false) Determines whether or not to use
a charkey prefix for elements with no attributes.

trim (default: false): Trim the whitespace at the beginning and end of
text nodes.

normalizeTags (default: false): Normalize all tag names to lowercase.

normalize (default: false): Trim whitespaces inside text nodes.

explicitRoot (default: true): Set this if you want to get the root
node in the resulting object.

emptyTag (default: ''): what will the value of empty nodes be. In case
you want to use an empty object as a default value, it is better to provide a factory
function () => ({}) instead. Without this function a plain object would
become a shared reference across all occurrences with unwanted behavior.

explicitArray (default: true): Always put child nodes in an array if
true; otherwise an array is created only if there is more than one.

ignoreAttrs (default: false): Ignore all XML attributes and only create
text nodes.

mergeAttrs (default: false): Merge attributes and child elements as
properties of the parent, instead of keying attributes off a child
attribute object. This option is ignored if ignoreAttrs is true.

validator (default null): You can specify a callable that validates
the resulting structure somehow, however you want. See unit tests
for an example.

xmlns (default false): Give each element a field usually called '$ns'
(the first character is the same as attrkey) that contains its local name
and namespace URI.

explicitChildren (default false): Put child elements to separate
property. Doesn't work with mergeAttrs = true. If element has no children
then "children" won't be created. Added in 0.2.5.

childkey (default $$): Prefix that is used to access child elements if
explicitChildren is set to true. Added in 0.2.5.

preserveChildrenOrder (default false): Modifies the behavior of
explicitChildren so that the value of the "children" property becomes an
ordered array. When this is true, every node will also get a #name field
whose value will correspond to the XML nodeName, so that you may iterate
the "children" array and still be able to determine node names. The named
(and potentially unordered) properties are also retained in this
configuration at the same level as the ordered "children" array. Added in
0.4.9.

charsAsChildren (default false): Determines whether chars should be
considered children if explicitChildren is on. Added in 0.2.5.

includeWhiteChars (default false): Determines whether whitespace-only
text nodes should be included. Added in 0.4.17.

async (default false): Should the callbacks be async? This might be
an incompatible change if your code depends on sync execution of callbacks.
Future versions of xml2js might change this default, so the recommendation
is to not depend on sync execution anyway. Added in 0.2.6.

strict (default true): Set sax-js to strict or non-strict parsing mode.
Defaults to true which is highly recommended, since parsing HTML which
is not well-formed XML might yield just about anything. Added in 0.2.7.

attrNameProcessors (default: null): Allows the addition of attribute
name processing functions. Accepts an Array of functions with following
signature:
function (name){
    //do something with `name`
    return name
}
Added in 0.4.14

attrValueProcessors (default: null): Allows the addition of attribute
value processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.1

tagNameProcessors (default: null): Allows the addition of tag name
processing functions. Accepts an Array of functions with following
signature:
function (name){
  //do something with `name`
  return name
}
Added in 0.4.1

valueProcessors (default: null): Allows the addition of element value
processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.6

Options for the Builder class
These options are specified by new Builder({optionName: value}).
Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

rootName (default root or the root key name): root element name to be used in case
explicitRoot is false or to override the root element name.

renderOpts (default { 'pretty': true, 'indent': '  ', 'newline': '\n' }):
Rendering options for xmlbuilder-js.

pretty: prettify generated XML
indent: whitespace for indentation (only when pretty)
newline: newline char (only when pretty)



xmldec (default { 'version': '1.0', 'encoding': 'UTF-8', 'standalone': true }:
XML declaration attributes.


xmldec.version A version number string, e.g. 1.0

xmldec.encoding Encoding declaration, e.g. UTF-8

xmldec.standalone standalone document declaration: true or false



doctype (default null): optional DTD. Eg. {'ext': 'hello.dtd'}


headless (default: false): omit the XML header. Added in 0.4.3.

allowSurrogateChars (default: false): allows using characters from the Unicode
surrogate blocks.

cdata (default: false): wrap text nodes in <![CDATA[ ... ]]> instead of
escaping when necessary. Does not add <![CDATA[ ... ]]> if it is not required.
Added in 0.4.5.

renderOpts, xmldec,doctype and headless pass through to
xmlbuilder-js.
Updating to new version
Version 0.2 changed the default parsing settings, but version 0.1.14 introduced
the default settings for version 0.2, so these settings can be tried before the
migration.
var xml2js = require('xml2js');
var parser = new xml2js.Parser(xml2js.defaults["0.2"]);
To get the 0.1 defaults in version 0.2 you can just use
xml2js.defaults["0.1"] in the same place. This provides you with enough time
to migrate to the saner way of parsing in xml2js 0.2. We try to make the
migration as simple and gentle as possible, but some breakage cannot be
avoided.
So, what exactly did change and why? In 0.2 we changed some defaults to parse
the XML in a more universal and sane way. So we disabled normalize and trim
so xml2js does not cut out any text content. You can reenable this at will of
course. A more important change is that we return the root tag in the resulting
JavaScript structure via the explicitRoot setting, so you need to access the
first element. This is useful for anybody who wants to know what the root node
is and preserves more information. The last major change was to enable
explicitArray, so everytime it is possible that one might embed more than one
sub-tag into a tag, xml2js >= 0.2 returns an array even if the array just
includes one element. This is useful when dealing with APIs that return
variable amounts of subtags.
Running tests, development



The development requirements are handled by npm, you just need to install them.
We also have a number of unit tests, they can be run using npm test directly
from the project root. This runs zap to discover all the tests and execute
them.
If you like to contribute, keep in mind that xml2js is written in
CoffeeScript, so don't develop on the JavaScript files that are checked into
the repository for convenience reasons. Also, please write some unit test to
check your behaviour and if it is some user-facing thing, add some
documentation to this README, so people will know it exists. Thanks in advance!
Getting support
Please, if you have a problem with the library, first make sure you read this
README. If you read this far, thanks, you're good. Then, please make sure your
problem really is with xml2js. It is? Okay, then I'll look at it. Send me a
mail and we can talk. Please don't open issues, as I don't think that is the
proper forum for support problems. Some problems might as well really be bugs
in xml2js, if so I'll let you know to open an issue instead :)
But if you know you really found a bug, feel free to open an issue instead.
ReadmeKeywordsxmljsonPackage SidebarInstallnpm i xml2jsRepositorygithub.com/Leonidas-from-XIV/node-xml2jsHomepagegithub.com/Leonidas-from-XIV/node-xml2jsWeekly Downloads22,667,333Version0.6.2LicenseMITUnpacked Size3.44 MBTotal Files10Last publish2 years agoCollaboratorsTry on RunKitReport malware\n\n\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\n\n\nnpm Teams
      
        Share code and collaborate with the tools that make JavaScript the world's best software ecosystem
      
      
        Get started
      
    
  
  
    
      
        
          
        
        Unlimited public packages
        Bring the best of open source JavaScript development to your own projects.
      
      
        
          
        
        Unlimited private packages
        Seamlessly integrate public and private packages into your development cycle.
      
      
        
          
        
        Package-based permissions
        Add collaborators to work on your public and private packages together.
      
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      
        Get Started\n\nnpm Teams
      
        Share code and collaborate with the tools that make JavaScript the world's best software ecosystem
      
      
        Get started
      
    
  
  
    
      
        
          
        
        Unlimited public packages
        Bring the best of open source JavaScript development to your own projects.
      
      
        
          
        
        Unlimited private packages
        Seamlessly integrate public and private packages into your development cycle.
      
      
        
          
        
        Package-based permissions
        Add collaborators to work on your public and private packages together.
      
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      
        Get Started\n\nnpm Teams
      
        Share code and collaborate with the tools that make JavaScript the world's best software ecosystem
      
      
        Get started
      
    
  
  
    
      
        
          
        
        Unlimited public packages
        Bring the best of open source JavaScript development to your own projects.
      
      
        
          
        
        Unlimited private packages
        Seamlessly integrate public and private packages into your development cycle.
      
      
        
          
        
        Package-based permissions
        Add collaborators to work on your public and private packages together.
      
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      
        Get Started\n\n\n\nPricing
    
    
      
        
          
            For Public Package Authors
          
          
            
              
            
          
          
            Free
            
              $
              0
            
            
              
                Unlimited 
                  public packages
              
            
             Create 
          
        
      
      
        
          
            For Individual 
            Creators
          
          
            
          
          
            Pro
            
              $
              7
            
            per month
             
            
              
                Unlimited 
                  public packages
              
              
                Unlimited 
                  private packages
              
              
                Package-based 
                  permissions
              
            
            
              Get Started With Pro
            
          
        
      
      
        
          
            For Teams & 
            Organizations
          
          
            
          
          
            Teams
            
              $
              7
            
            per user 
              per month
            
              
                Unlimited 
                  public packages
              
              
                Unlimited 
                  private packages
              
              
                Team-based 
                  permissions
              
            
            
              Get Started With Teams
            
          
        
      
    
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support\n\nPricing
    
    
      
        
          
            For Public Package Authors
          
          
            
              
            
          
          
            Free
            
              $
              0
            
            
              
                Unlimited 
                  public packages
              
            
             Create 
          
        
      
      
        
          
            For Individual 
            Creators
          
          
            
          
          
            Pro
            
              $
              7
            
            per month
             
            
              
                Unlimited 
                  public packages
              
              
                Unlimited 
                  private packages
              
              
                Package-based 
                  permissions
              
            
            
              Get Started With Pro
            
          
        
      
      
        
          
            For Teams & 
            Organizations
          
          
            
          
          
            Teams
            
              $
              7
            
            per user 
              per month
            
              
                Unlimited 
                  public packages
              
              
                Unlimited 
                  private packages
              
              
                Team-based 
                  permissions
              
            
            
              Get Started With Teams
            
          
        
      
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support\n\nPricing
    
    
      
        
          
            For Public Package Authors
          
          
            
              
            
          
          
            Free
            
              $
              0
            
            
              
                Unlimited 
                  public packages
              
            
             Create 
          
        
      
      
        
          
            For Individual 
            Creators
          
          
            
          
          
            Pro
            
              $
              7
            
            per month
             
            
              
                Unlimited 
                  public packages
              
              
                Unlimited 
                  private packages
              
              
                Package-based 
                  permissions
              
            
            
              Get Started With Pro
            
          
        
      
      
        
          
            For Teams & 
            Organizations
          
          
            
          
          
            Teams
            
              $
              7
            
            per user 
              per month
            
              
                Unlimited 
                  public packages
              
              
                Unlimited 
                  private packages
              
              
                Team-based 
                  permissions
              
            
            
              Get Started With Teams
            
          
        
      
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support\n\n\n\nBuild amazing thingsWe're GitHub, the company behind the npm Registry and npm CLI. We offer those to the community for free, but our day job is building and selling useful tools for developers like you.Take your JavaScript development up a notchGet started today for free, or step up to npm Pro to enjoy a premium JavaScript development experience, with features like private packages.Sign up for freeLearn about ProBring the best of open source to you, your team, and your companyRelied upon by more than 17 million developers worldwide, npm is committed to making JavaScript development elegant, productive, and safe. The free npm Registry has become the center of JavaScript code sharing, and with more than two million packages, the largest software registry in the world. Our other tools and services take the Registry, and the work you do around it, to the next level.\n\nBuild amazing thingsWe're GitHub, the company behind the npm Registry and npm CLI. We offer those to the community for free, but our day job is building and selling useful tools for developers like you.Take your JavaScript development up a notchGet started today for free, or step up to npm Pro to enjoy a premium JavaScript development experience, with features like private packages.Sign up for freeLearn about ProBring the best of open source to you, your team, and your companyRelied upon by more than 17 million developers worldwide, npm is committed to making JavaScript development elegant, productive, and safe. The free npm Registry has become the center of JavaScript code sharing, and with more than two million packages, the largest software registry in the world. Our other tools and services take the Registry, and the work you do around it, to the next level.\n\nBuild amazing thingsWe're GitHub, the company behind the npm Registry and npm CLI. We offer those to the community for free, but our day job is building and selling useful tools for developers like you.Take your JavaScript development up a notchGet started today for free, or step up to npm Pro to enjoy a premium JavaScript development experience, with features like private packages.Sign up for freeLearn about ProBring the best of open source to you, your team, and your companyRelied upon by more than 17 million developers worldwide, npm is committed to making JavaScript development elegant, productive, and safe. The free npm Registry has become the center of JavaScript code sharing, and with more than two million packages, the largest software registry in the world. Our other tools and services take the Registry, and the work you do around it, to the next level.\n\n\n\nSign UpUsername *Email addressYour email address will be added to the metadata of packages that you publish, so it may be seen publicly.PasswordShowMinimum of 10 characters and must meet our  password guidelinesI agree to the End User License Agreement and the Privacy Policy. *Create an AccountAlready have an account?Sign In\n\nSign UpUsername *Email addressYour email address will be added to the metadata of packages that you publish, so it may be seen publicly.PasswordShowMinimum of 10 characters and must meet our  password guidelinesI agree to the End User License Agreement and the Privacy Policy. *Create an AccountAlready have an account?Sign In\n\n\n\nSign InUsernameForgot password?PasswordShowSign InCreate Account\n\nSign InUsernameForgot password?PasswordShowSign InCreate Account\n\n\n\nInstallation

npm install --save @types/xml2js

Summary
This package contains type definitions for xml2js (https://github.com/Leonidas-from-XIV/node-xml2js).
Details
Files were exported from https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/xml2js.
Additional Details

Last updated: Tue, 07 Nov 2023 15:11:36 GMT
Dependencies: @types/node


Credits
These definitions were written by Michel Salib, Jason McNeil, Christopher Currens, Edward Hinkle, Claas Ahlrichs, Grzegorz Redlicki, and Ryan Ling.\n\n@types/xml2js0.4.14 • Public • Published a year ago ReadmeCode Beta1 Dependency351 Dependents31 VersionsInstallation

npm install --save @types/xml2js

Summary
This package contains type definitions for xml2js (https://github.com/Leonidas-from-XIV/node-xml2js).
Details
Files were exported from https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/xml2js.
Additional Details

Last updated: Tue, 07 Nov 2023 15:11:36 GMT
Dependencies: @types/node


Credits
These definitions were written by Michel Salib, Jason McNeil, Christopher Currens, Edward Hinkle, Claas Ahlrichs, Grzegorz Redlicki, and Ryan Ling.
ReadmeKeywordsnonePackage SidebarInstallnpm i @types/xml2jsRepositorygithub.com/DefinitelyTyped/DefinitelyTypedHomepagegithub.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/xml2jsWeekly Downloads1,744,378Version0.4.14LicenseMITUnpacked Size7 kBTotal Files7Last publisha year agoCollaboratorsTry on RunKitReport malware\n\n@types/xml2js0.4.14 • Public • Published a year ago ReadmeCode Beta1 Dependency351 Dependents31 VersionsInstallation

npm install --save @types/xml2js

Summary
This package contains type definitions for xml2js (https://github.com/Leonidas-from-XIV/node-xml2js).
Details
Files were exported from https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/xml2js.
Additional Details

Last updated: Tue, 07 Nov 2023 15:11:36 GMT
Dependencies: @types/node


Credits
These definitions were written by Michel Salib, Jason McNeil, Christopher Currens, Edward Hinkle, Claas Ahlrichs, Grzegorz Redlicki, and Ryan Ling.
ReadmeKeywordsnonePackage SidebarInstallnpm i @types/xml2jsRepositorygithub.com/DefinitelyTyped/DefinitelyTypedHomepagegithub.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/xml2jsWeekly Downloads1,744,378Version0.4.14LicenseMITUnpacked Size7 kBTotal Files7Last publisha year agoCollaboratorsTry on RunKitReport malware\n\n\n\nnode-xml2js
Ever had the urge to parse XML? And wanted to access the data in some sane,
easy way? Don't want to compile a C parser, for whatever reason? Then xml2js is
what you're looking for!
Description
Simple XML to JavaScript object converter. It supports bi-directional conversion.
Uses sax-js and
xmlbuilder-js.
Note: If you're looking for a full DOM parser, you probably want
JSDom.
Installation
Simplest way to install xml2js is to use npm, just npm install xml2js which will download xml2js and all dependencies.
xml2js is also available via Bower, just bower install xml2js which will download xml2js and all dependencies.
Usage
No extensive tutorials required because you are a smart developer! The task of
parsing XML should be an easy one, so let's make it so! Here's some examples.
Shoot-and-forget usage
You want to parse XML as simple and easy as possible? It's dangerous to go
alone, take this:
var parseString = require('xml2js').parseString;
var xml = "<root>Hello xml2js!</root>"
parseString(xml, function (err, result) {
    console.dir(result);
});
Can't get easier than this, right? This works starting with xml2js 0.2.3.
With CoffeeScript it looks like this:
{parseString} = require 'xml2js'
xml = "<root>Hello xml2js!</root>"
parseString xml, (err, result) ->
    console.dir result
If you need some special options, fear not, xml2js supports a number of
options (see below), you can specify these as second argument:
parseString(xml, {trim: true}, function (err, result) {
});
Simple as pie usage
That's right, if you have been using xml-simple or a home-grown
wrapper, this was added in 0.1.11 just for you:
var fs = require('fs'),
    xml2js = require('xml2js');

var parser = new xml2js.Parser();
fs.readFile(__dirname + '/foo.xml', function(err, data) {
    parser.parseString(data, function (err, result) {
        console.dir(result);
        console.log('Done');
    });
});
Look ma, no event listeners!
You can also use xml2js from
CoffeeScript, further reducing
the clutter:
fs = require 'fs',
xml2js = require 'xml2js'

parser = new xml2js.Parser()
fs.readFile __dirname + '/foo.xml', (err, data) ->
  parser.parseString data, (err, result) ->
    console.dir result
    console.log 'Done.'
But what happens if you forget the new keyword to create a new Parser? In
the middle of a nightly coding session, it might get lost, after all. Worry
not, we got you covered! Starting with 0.2.8 you can also leave it out, in
which case xml2js will helpfully add it for you, no bad surprises and
inexplicable bugs!
Promise usage
var xml2js = require('xml2js');
var xml = '<foo></foo>';

// With parser
var parser = new xml2js.Parser(/* options */);
parser.parseStringPromise(xml).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});

// Without parser
xml2js.parseStringPromise(xml /*, options */).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});
Parsing multiple files
If you want to parse multiple files, you have multiple possibilities:

You can create one xml2js.Parser per file. That's the recommended one
and is promised to always just work.
You can call reset() on your parser object.
You can hope everything goes well anyway. This behaviour is not
guaranteed work always, if ever. Use option #1 if possible. Thanks!

So you wanna some JSON?
Just wrap the result object in a call to JSON.stringify like this
JSON.stringify(result). You get a string containing the JSON representation
of the parsed object that you can feed to JSON-hungry consumers.
Displaying results
You might wonder why, using console.dir or console.log the output at some
level is only [Object]. Don't worry, this is not because xml2js got lazy.
That's because Node uses util.inspect to convert the object into strings and
that function stops after depth=2 which is a bit low for most XML.
To display the whole deal, you can use console.log(util.inspect(result, false, null)), which displays the whole result.
So much for that, but what if you use
eyes for nice colored output and it
truncates the output with …? Don't fear, there's also a solution for that,
you just need to increase the maxLength limit by creating a custom inspector
var inspect = require('eyes').inspector({maxLength: false}) and then you can
easily inspect(result).
XML builder usage
Since 0.4.0, objects can be also be used to build XML:
var xml2js = require('xml2js');

var obj = {name: "Super", Surname: "Man", age: 23};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root>
  <name>Super</name>
  <Surname>Man</Surname>
  <age>23</age>
</root>
At the moment, a one to one bi-directional conversion is guaranteed only for
default configuration, except for attrkey, charkey and explicitArray options
you can redefine to your taste. Writing CDATA is supported via setting the cdata
option to true.
To specify attributes:
var xml2js = require('xml2js');

var obj = {root: {$: {id: "my id"}, _: "my inner text"}};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root id="my id">my inner text</root>
Adding xmlns attributes
You can generate XML that declares XML namespace prefix / URI pairs with xmlns attributes.
Example declaring a default namespace on the root element:
let obj = { 
  Foo: {
    $: {
      "xmlns": "http://foo.com"
    }   
  }
};  
Result of buildObject(obj):
<Foo xmlns="http://foo.com"/>
Example declaring non-default namespaces on non-root elements:
let obj = {
  'foo:Foo': {
    $: {
      'xmlns:foo': 'http://foo.com'
    },
    'bar:Bar': {
      $: {
        'xmlns:bar': 'http://bar.com'
      }
    }
  }
}
Result of buildObject(obj):
<foo:Foo xmlns:foo="http://foo.com">
  <bar:Bar xmlns:bar="http://bar.com"/>
</foo:Foo>
Processing attribute, tag names and values
Since 0.4.1 you can optionally provide the parser with attribute name and tag name processors as well as element value processors (Since 0.4.14, you can also optionally provide the parser with attribute value processors):
function nameToUpperCase(name){
    return name.toUpperCase();
}

//transform all attribute and tag names and values to uppercase
parseString(xml, {
  tagNameProcessors: [nameToUpperCase],
  attrNameProcessors: [nameToUpperCase],
  valueProcessors: [nameToUpperCase],
  attrValueProcessors: [nameToUpperCase]},
  function (err, result) {
    // processed data
});
The tagNameProcessors and attrNameProcessors options
accept an Array of functions with the following signature:
function (name){
  //do something with `name`
  return name
}
The attrValueProcessors and valueProcessors options
accept an Array of functions with the following signature:
function (value, name) {
  //`name` will be the node name or attribute name
  //do something with `value`, (optionally) dependent on the node/attr name
  return value
}
Some processors are provided out-of-the-box and can be found in lib/processors.js:


normalize: transforms the name to lowercase.
(Automatically used when options.normalize is set to true)


firstCharLowerCase: transforms the first character to lower case.
E.g. 'MyTagName' becomes 'myTagName'


stripPrefix: strips the xml namespace prefix. E.g <foo:Bar/> will become 'Bar'.
(N.B.: the xmlns prefix is NOT stripped.)


parseNumbers: parses integer-like strings as integers and float-like strings as floats
E.g. "0" becomes 0 and "15.56" becomes 15.56


parseBooleans: parses boolean-like strings to booleans
E.g. "true" becomes true and "False" becomes false


Options
Apart from the default settings, there are a number of options that can be
specified for the parser. Options are specified by new Parser({optionName: value}). Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

explicitCharkey (default: false) Determines whether or not to use
a charkey prefix for elements with no attributes.

trim (default: false): Trim the whitespace at the beginning and end of
text nodes.

normalizeTags (default: false): Normalize all tag names to lowercase.

normalize (default: false): Trim whitespaces inside text nodes.

explicitRoot (default: true): Set this if you want to get the root
node in the resulting object.

emptyTag (default: ''): what will the value of empty nodes be. In case
you want to use an empty object as a default value, it is better to provide a factory
function () => ({}) instead. Without this function a plain object would
become a shared reference across all occurrences with unwanted behavior.

explicitArray (default: true): Always put child nodes in an array if
true; otherwise an array is created only if there is more than one.

ignoreAttrs (default: false): Ignore all XML attributes and only create
text nodes.

mergeAttrs (default: false): Merge attributes and child elements as
properties of the parent, instead of keying attributes off a child
attribute object. This option is ignored if ignoreAttrs is true.

validator (default null): You can specify a callable that validates
the resulting structure somehow, however you want. See unit tests
for an example.

xmlns (default false): Give each element a field usually called '$ns'
(the first character is the same as attrkey) that contains its local name
and namespace URI.

explicitChildren (default false): Put child elements to separate
property. Doesn't work with mergeAttrs = true. If element has no children
then "children" won't be created. Added in 0.2.5.

childkey (default $$): Prefix that is used to access child elements if
explicitChildren is set to true. Added in 0.2.5.

preserveChildrenOrder (default false): Modifies the behavior of
explicitChildren so that the value of the "children" property becomes an
ordered array. When this is true, every node will also get a #name field
whose value will correspond to the XML nodeName, so that you may iterate
the "children" array and still be able to determine node names. The named
(and potentially unordered) properties are also retained in this
configuration at the same level as the ordered "children" array. Added in
0.4.9.

charsAsChildren (default false): Determines whether chars should be
considered children if explicitChildren is on. Added in 0.2.5.

includeWhiteChars (default false): Determines whether whitespace-only
text nodes should be included. Added in 0.4.17.

async (default false): Should the callbacks be async? This might be
an incompatible change if your code depends on sync execution of callbacks.
Future versions of xml2js might change this default, so the recommendation
is to not depend on sync execution anyway. Added in 0.2.6.

strict (default true): Set sax-js to strict or non-strict parsing mode.
Defaults to true which is highly recommended, since parsing HTML which
is not well-formed XML might yield just about anything. Added in 0.2.7.

attrNameProcessors (default: null): Allows the addition of attribute
name processing functions. Accepts an Array of functions with following
signature:
function (name){
    //do something with `name`
    return name
}
Added in 0.4.14

attrValueProcessors (default: null): Allows the addition of attribute
value processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.1

tagNameProcessors (default: null): Allows the addition of tag name
processing functions. Accepts an Array of functions with following
signature:
function (name){
  //do something with `name`
  return name
}
Added in 0.4.1

valueProcessors (default: null): Allows the addition of element value
processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.6

Options for the Builder class
These options are specified by new Builder({optionName: value}).
Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

rootName (default root or the root key name): root element name to be used in case
explicitRoot is false or to override the root element name.

renderOpts (default { 'pretty': true, 'indent': '  ', 'newline': '\n' }):
Rendering options for xmlbuilder-js.

pretty: prettify generated XML
indent: whitespace for indentation (only when pretty)
newline: newline char (only when pretty)



xmldec (default { 'version': '1.0', 'encoding': 'UTF-8', 'standalone': true }:
XML declaration attributes.


xmldec.version A version number string, e.g. 1.0

xmldec.encoding Encoding declaration, e.g. UTF-8

xmldec.standalone standalone document declaration: true or false



doctype (default null): optional DTD. Eg. {'ext': 'hello.dtd'}


headless (default: false): omit the XML header. Added in 0.4.3.

allowSurrogateChars (default: false): allows using characters from the Unicode
surrogate blocks.

cdata (default: false): wrap text nodes in <![CDATA[ ... ]]> instead of
escaping when necessary. Does not add <![CDATA[ ... ]]> if it is not required.
Added in 0.4.5.

renderOpts, xmldec,doctype and headless pass through to
xmlbuilder-js.
Updating to new version
Version 0.2 changed the default parsing settings, but version 0.1.14 introduced
the default settings for version 0.2, so these settings can be tried before the
migration.
var xml2js = require('xml2js');
var parser = new xml2js.Parser(xml2js.defaults["0.2"]);
To get the 0.1 defaults in version 0.2 you can just use
xml2js.defaults["0.1"] in the same place. This provides you with enough time
to migrate to the saner way of parsing in xml2js 0.2. We try to make the
migration as simple and gentle as possible, but some breakage cannot be
avoided.
So, what exactly did change and why? In 0.2 we changed some defaults to parse
the XML in a more universal and sane way. So we disabled normalize and trim
so xml2js does not cut out any text content. You can reenable this at will of
course. A more important change is that we return the root tag in the resulting
JavaScript structure via the explicitRoot setting, so you need to access the
first element. This is useful for anybody who wants to know what the root node
is and preserves more information. The last major change was to enable
explicitArray, so everytime it is possible that one might embed more than one
sub-tag into a tag, xml2js >= 0.2 returns an array even if the array just
includes one element. This is useful when dealing with APIs that return
variable amounts of subtags.
Running tests, development



The development requirements are handled by npm, you just need to install them.
We also have a number of unit tests, they can be run using npm test directly
from the project root. This runs zap to discover all the tests and execute
them.
If you like to contribute, keep in mind that xml2js is written in
CoffeeScript, so don't develop on the JavaScript files that are checked into
the repository for convenience reasons. Also, please write some unit test to
check your behaviour and if it is some user-facing thing, add some
documentation to this README, so people will know it exists. Thanks in advance!
Getting support
Please, if you have a problem with the library, first make sure you read this
README. If you read this far, thanks, you're good. Then, please make sure your
problem really is with xml2js. It is? Okay, then I'll look at it. Send me a
mail and we can talk. Please don't open issues, as I don't think that is the
proper forum for support problems. Some problems might as well really be bugs
in xml2js, if so I'll let you know to open an issue instead :)
But if you know you really found a bug, feel free to open an issue instead.\n\nxml2js0.6.2 • Public • Published 2 years ago ReadmeCode Beta2 Dependencies10,263 Dependents52 Versionsnode-xml2js
Ever had the urge to parse XML? And wanted to access the data in some sane,
easy way? Don't want to compile a C parser, for whatever reason? Then xml2js is
what you're looking for!
Description
Simple XML to JavaScript object converter. It supports bi-directional conversion.
Uses sax-js and
xmlbuilder-js.
Note: If you're looking for a full DOM parser, you probably want
JSDom.
Installation
Simplest way to install xml2js is to use npm, just npm install xml2js which will download xml2js and all dependencies.
xml2js is also available via Bower, just bower install xml2js which will download xml2js and all dependencies.
Usage
No extensive tutorials required because you are a smart developer! The task of
parsing XML should be an easy one, so let's make it so! Here's some examples.
Shoot-and-forget usage
You want to parse XML as simple and easy as possible? It's dangerous to go
alone, take this:
var parseString = require('xml2js').parseString;
var xml = "<root>Hello xml2js!</root>"
parseString(xml, function (err, result) {
    console.dir(result);
});
Can't get easier than this, right? This works starting with xml2js 0.2.3.
With CoffeeScript it looks like this:
{parseString} = require 'xml2js'
xml = "<root>Hello xml2js!</root>"
parseString xml, (err, result) ->
    console.dir result
If you need some special options, fear not, xml2js supports a number of
options (see below), you can specify these as second argument:
parseString(xml, {trim: true}, function (err, result) {
});
Simple as pie usage
That's right, if you have been using xml-simple or a home-grown
wrapper, this was added in 0.1.11 just for you:
var fs = require('fs'),
    xml2js = require('xml2js');

var parser = new xml2js.Parser();
fs.readFile(__dirname + '/foo.xml', function(err, data) {
    parser.parseString(data, function (err, result) {
        console.dir(result);
        console.log('Done');
    });
});
Look ma, no event listeners!
You can also use xml2js from
CoffeeScript, further reducing
the clutter:
fs = require 'fs',
xml2js = require 'xml2js'

parser = new xml2js.Parser()
fs.readFile __dirname + '/foo.xml', (err, data) ->
  parser.parseString data, (err, result) ->
    console.dir result
    console.log 'Done.'
But what happens if you forget the new keyword to create a new Parser? In
the middle of a nightly coding session, it might get lost, after all. Worry
not, we got you covered! Starting with 0.2.8 you can also leave it out, in
which case xml2js will helpfully add it for you, no bad surprises and
inexplicable bugs!
Promise usage
var xml2js = require('xml2js');
var xml = '<foo></foo>';

// With parser
var parser = new xml2js.Parser(/* options */);
parser.parseStringPromise(xml).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});

// Without parser
xml2js.parseStringPromise(xml /*, options */).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});
Parsing multiple files
If you want to parse multiple files, you have multiple possibilities:

You can create one xml2js.Parser per file. That's the recommended one
and is promised to always just work.
You can call reset() on your parser object.
You can hope everything goes well anyway. This behaviour is not
guaranteed work always, if ever. Use option #1 if possible. Thanks!

So you wanna some JSON?
Just wrap the result object in a call to JSON.stringify like this
JSON.stringify(result). You get a string containing the JSON representation
of the parsed object that you can feed to JSON-hungry consumers.
Displaying results
You might wonder why, using console.dir or console.log the output at some
level is only [Object]. Don't worry, this is not because xml2js got lazy.
That's because Node uses util.inspect to convert the object into strings and
that function stops after depth=2 which is a bit low for most XML.
To display the whole deal, you can use console.log(util.inspect(result, false, null)), which displays the whole result.
So much for that, but what if you use
eyes for nice colored output and it
truncates the output with …? Don't fear, there's also a solution for that,
you just need to increase the maxLength limit by creating a custom inspector
var inspect = require('eyes').inspector({maxLength: false}) and then you can
easily inspect(result).
XML builder usage
Since 0.4.0, objects can be also be used to build XML:
var xml2js = require('xml2js');

var obj = {name: "Super", Surname: "Man", age: 23};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root>
  <name>Super</name>
  <Surname>Man</Surname>
  <age>23</age>
</root>
At the moment, a one to one bi-directional conversion is guaranteed only for
default configuration, except for attrkey, charkey and explicitArray options
you can redefine to your taste. Writing CDATA is supported via setting the cdata
option to true.
To specify attributes:
var xml2js = require('xml2js');

var obj = {root: {$: {id: "my id"}, _: "my inner text"}};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root id="my id">my inner text</root>
Adding xmlns attributes
You can generate XML that declares XML namespace prefix / URI pairs with xmlns attributes.
Example declaring a default namespace on the root element:
let obj = { 
  Foo: {
    $: {
      "xmlns": "http://foo.com"
    }   
  }
};  
Result of buildObject(obj):
<Foo xmlns="http://foo.com"/>
Example declaring non-default namespaces on non-root elements:
let obj = {
  'foo:Foo': {
    $: {
      'xmlns:foo': 'http://foo.com'
    },
    'bar:Bar': {
      $: {
        'xmlns:bar': 'http://bar.com'
      }
    }
  }
}
Result of buildObject(obj):
<foo:Foo xmlns:foo="http://foo.com">
  <bar:Bar xmlns:bar="http://bar.com"/>
</foo:Foo>
Processing attribute, tag names and values
Since 0.4.1 you can optionally provide the parser with attribute name and tag name processors as well as element value processors (Since 0.4.14, you can also optionally provide the parser with attribute value processors):
function nameToUpperCase(name){
    return name.toUpperCase();
}

//transform all attribute and tag names and values to uppercase
parseString(xml, {
  tagNameProcessors: [nameToUpperCase],
  attrNameProcessors: [nameToUpperCase],
  valueProcessors: [nameToUpperCase],
  attrValueProcessors: [nameToUpperCase]},
  function (err, result) {
    // processed data
});
The tagNameProcessors and attrNameProcessors options
accept an Array of functions with the following signature:
function (name){
  //do something with `name`
  return name
}
The attrValueProcessors and valueProcessors options
accept an Array of functions with the following signature:
function (value, name) {
  //`name` will be the node name or attribute name
  //do something with `value`, (optionally) dependent on the node/attr name
  return value
}
Some processors are provided out-of-the-box and can be found in lib/processors.js:


normalize: transforms the name to lowercase.
(Automatically used when options.normalize is set to true)


firstCharLowerCase: transforms the first character to lower case.
E.g. 'MyTagName' becomes 'myTagName'


stripPrefix: strips the xml namespace prefix. E.g <foo:Bar/> will become 'Bar'.
(N.B.: the xmlns prefix is NOT stripped.)


parseNumbers: parses integer-like strings as integers and float-like strings as floats
E.g. "0" becomes 0 and "15.56" becomes 15.56


parseBooleans: parses boolean-like strings to booleans
E.g. "true" becomes true and "False" becomes false


Options
Apart from the default settings, there are a number of options that can be
specified for the parser. Options are specified by new Parser({optionName: value}). Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

explicitCharkey (default: false) Determines whether or not to use
a charkey prefix for elements with no attributes.

trim (default: false): Trim the whitespace at the beginning and end of
text nodes.

normalizeTags (default: false): Normalize all tag names to lowercase.

normalize (default: false): Trim whitespaces inside text nodes.

explicitRoot (default: true): Set this if you want to get the root
node in the resulting object.

emptyTag (default: ''): what will the value of empty nodes be. In case
you want to use an empty object as a default value, it is better to provide a factory
function () => ({}) instead. Without this function a plain object would
become a shared reference across all occurrences with unwanted behavior.

explicitArray (default: true): Always put child nodes in an array if
true; otherwise an array is created only if there is more than one.

ignoreAttrs (default: false): Ignore all XML attributes and only create
text nodes.

mergeAttrs (default: false): Merge attributes and child elements as
properties of the parent, instead of keying attributes off a child
attribute object. This option is ignored if ignoreAttrs is true.

validator (default null): You can specify a callable that validates
the resulting structure somehow, however you want. See unit tests
for an example.

xmlns (default false): Give each element a field usually called '$ns'
(the first character is the same as attrkey) that contains its local name
and namespace URI.

explicitChildren (default false): Put child elements to separate
property. Doesn't work with mergeAttrs = true. If element has no children
then "children" won't be created. Added in 0.2.5.

childkey (default $$): Prefix that is used to access child elements if
explicitChildren is set to true. Added in 0.2.5.

preserveChildrenOrder (default false): Modifies the behavior of
explicitChildren so that the value of the "children" property becomes an
ordered array. When this is true, every node will also get a #name field
whose value will correspond to the XML nodeName, so that you may iterate
the "children" array and still be able to determine node names. The named
(and potentially unordered) properties are also retained in this
configuration at the same level as the ordered "children" array. Added in
0.4.9.

charsAsChildren (default false): Determines whether chars should be
considered children if explicitChildren is on. Added in 0.2.5.

includeWhiteChars (default false): Determines whether whitespace-only
text nodes should be included. Added in 0.4.17.

async (default false): Should the callbacks be async? This might be
an incompatible change if your code depends on sync execution of callbacks.
Future versions of xml2js might change this default, so the recommendation
is to not depend on sync execution anyway. Added in 0.2.6.

strict (default true): Set sax-js to strict or non-strict parsing mode.
Defaults to true which is highly recommended, since parsing HTML which
is not well-formed XML might yield just about anything. Added in 0.2.7.

attrNameProcessors (default: null): Allows the addition of attribute
name processing functions. Accepts an Array of functions with following
signature:
function (name){
    //do something with `name`
    return name
}
Added in 0.4.14

attrValueProcessors (default: null): Allows the addition of attribute
value processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.1

tagNameProcessors (default: null): Allows the addition of tag name
processing functions. Accepts an Array of functions with following
signature:
function (name){
  //do something with `name`
  return name
}
Added in 0.4.1

valueProcessors (default: null): Allows the addition of element value
processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.6

Options for the Builder class
These options are specified by new Builder({optionName: value}).
Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

rootName (default root or the root key name): root element name to be used in case
explicitRoot is false or to override the root element name.

renderOpts (default { 'pretty': true, 'indent': '  ', 'newline': '\n' }):
Rendering options for xmlbuilder-js.

pretty: prettify generated XML
indent: whitespace for indentation (only when pretty)
newline: newline char (only when pretty)



xmldec (default { 'version': '1.0', 'encoding': 'UTF-8', 'standalone': true }:
XML declaration attributes.


xmldec.version A version number string, e.g. 1.0

xmldec.encoding Encoding declaration, e.g. UTF-8

xmldec.standalone standalone document declaration: true or false



doctype (default null): optional DTD. Eg. {'ext': 'hello.dtd'}


headless (default: false): omit the XML header. Added in 0.4.3.

allowSurrogateChars (default: false): allows using characters from the Unicode
surrogate blocks.

cdata (default: false): wrap text nodes in <![CDATA[ ... ]]> instead of
escaping when necessary. Does not add <![CDATA[ ... ]]> if it is not required.
Added in 0.4.5.

renderOpts, xmldec,doctype and headless pass through to
xmlbuilder-js.
Updating to new version
Version 0.2 changed the default parsing settings, but version 0.1.14 introduced
the default settings for version 0.2, so these settings can be tried before the
migration.
var xml2js = require('xml2js');
var parser = new xml2js.Parser(xml2js.defaults["0.2"]);
To get the 0.1 defaults in version 0.2 you can just use
xml2js.defaults["0.1"] in the same place. This provides you with enough time
to migrate to the saner way of parsing in xml2js 0.2. We try to make the
migration as simple and gentle as possible, but some breakage cannot be
avoided.
So, what exactly did change and why? In 0.2 we changed some defaults to parse
the XML in a more universal and sane way. So we disabled normalize and trim
so xml2js does not cut out any text content. You can reenable this at will of
course. A more important change is that we return the root tag in the resulting
JavaScript structure via the explicitRoot setting, so you need to access the
first element. This is useful for anybody who wants to know what the root node
is and preserves more information. The last major change was to enable
explicitArray, so everytime it is possible that one might embed more than one
sub-tag into a tag, xml2js >= 0.2 returns an array even if the array just
includes one element. This is useful when dealing with APIs that return
variable amounts of subtags.
Running tests, development



The development requirements are handled by npm, you just need to install them.
We also have a number of unit tests, they can be run using npm test directly
from the project root. This runs zap to discover all the tests and execute
them.
If you like to contribute, keep in mind that xml2js is written in
CoffeeScript, so don't develop on the JavaScript files that are checked into
the repository for convenience reasons. Also, please write some unit test to
check your behaviour and if it is some user-facing thing, add some
documentation to this README, so people will know it exists. Thanks in advance!
Getting support
Please, if you have a problem with the library, first make sure you read this
README. If you read this far, thanks, you're good. Then, please make sure your
problem really is with xml2js. It is? Okay, then I'll look at it. Send me a
mail and we can talk. Please don't open issues, as I don't think that is the
proper forum for support problems. Some problems might as well really be bugs
in xml2js, if so I'll let you know to open an issue instead :)
But if you know you really found a bug, feel free to open an issue instead.
ReadmeKeywordsxmljsonPackage SidebarInstallnpm i xml2jsRepositorygithub.com/Leonidas-from-XIV/node-xml2jsHomepagegithub.com/Leonidas-from-XIV/node-xml2jsWeekly Downloads22,667,333Version0.6.2LicenseMITUnpacked Size3.44 MBTotal Files10Last publish2 years agoCollaboratorsTry on RunKitReport malware\n\nxml2js0.6.2 • Public • Published 2 years ago ReadmeCode Beta2 Dependencies10,263 Dependents52 Versionsnode-xml2js
Ever had the urge to parse XML? And wanted to access the data in some sane,
easy way? Don't want to compile a C parser, for whatever reason? Then xml2js is
what you're looking for!
Description
Simple XML to JavaScript object converter. It supports bi-directional conversion.
Uses sax-js and
xmlbuilder-js.
Note: If you're looking for a full DOM parser, you probably want
JSDom.
Installation
Simplest way to install xml2js is to use npm, just npm install xml2js which will download xml2js and all dependencies.
xml2js is also available via Bower, just bower install xml2js which will download xml2js and all dependencies.
Usage
No extensive tutorials required because you are a smart developer! The task of
parsing XML should be an easy one, so let's make it so! Here's some examples.
Shoot-and-forget usage
You want to parse XML as simple and easy as possible? It's dangerous to go
alone, take this:
var parseString = require('xml2js').parseString;
var xml = "<root>Hello xml2js!</root>"
parseString(xml, function (err, result) {
    console.dir(result);
});
Can't get easier than this, right? This works starting with xml2js 0.2.3.
With CoffeeScript it looks like this:
{parseString} = require 'xml2js'
xml = "<root>Hello xml2js!</root>"
parseString xml, (err, result) ->
    console.dir result
If you need some special options, fear not, xml2js supports a number of
options (see below), you can specify these as second argument:
parseString(xml, {trim: true}, function (err, result) {
});
Simple as pie usage
That's right, if you have been using xml-simple or a home-grown
wrapper, this was added in 0.1.11 just for you:
var fs = require('fs'),
    xml2js = require('xml2js');

var parser = new xml2js.Parser();
fs.readFile(__dirname + '/foo.xml', function(err, data) {
    parser.parseString(data, function (err, result) {
        console.dir(result);
        console.log('Done');
    });
});
Look ma, no event listeners!
You can also use xml2js from
CoffeeScript, further reducing
the clutter:
fs = require 'fs',
xml2js = require 'xml2js'

parser = new xml2js.Parser()
fs.readFile __dirname + '/foo.xml', (err, data) ->
  parser.parseString data, (err, result) ->
    console.dir result
    console.log 'Done.'
But what happens if you forget the new keyword to create a new Parser? In
the middle of a nightly coding session, it might get lost, after all. Worry
not, we got you covered! Starting with 0.2.8 you can also leave it out, in
which case xml2js will helpfully add it for you, no bad surprises and
inexplicable bugs!
Promise usage
var xml2js = require('xml2js');
var xml = '<foo></foo>';

// With parser
var parser = new xml2js.Parser(/* options */);
parser.parseStringPromise(xml).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});

// Without parser
xml2js.parseStringPromise(xml /*, options */).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});
Parsing multiple files
If you want to parse multiple files, you have multiple possibilities:

You can create one xml2js.Parser per file. That's the recommended one
and is promised to always just work.
You can call reset() on your parser object.
You can hope everything goes well anyway. This behaviour is not
guaranteed work always, if ever. Use option #1 if possible. Thanks!

So you wanna some JSON?
Just wrap the result object in a call to JSON.stringify like this
JSON.stringify(result). You get a string containing the JSON representation
of the parsed object that you can feed to JSON-hungry consumers.
Displaying results
You might wonder why, using console.dir or console.log the output at some
level is only [Object]. Don't worry, this is not because xml2js got lazy.
That's because Node uses util.inspect to convert the object into strings and
that function stops after depth=2 which is a bit low for most XML.
To display the whole deal, you can use console.log(util.inspect(result, false, null)), which displays the whole result.
So much for that, but what if you use
eyes for nice colored output and it
truncates the output with …? Don't fear, there's also a solution for that,
you just need to increase the maxLength limit by creating a custom inspector
var inspect = require('eyes').inspector({maxLength: false}) and then you can
easily inspect(result).
XML builder usage
Since 0.4.0, objects can be also be used to build XML:
var xml2js = require('xml2js');

var obj = {name: "Super", Surname: "Man", age: 23};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root>
  <name>Super</name>
  <Surname>Man</Surname>
  <age>23</age>
</root>
At the moment, a one to one bi-directional conversion is guaranteed only for
default configuration, except for attrkey, charkey and explicitArray options
you can redefine to your taste. Writing CDATA is supported via setting the cdata
option to true.
To specify attributes:
var xml2js = require('xml2js');

var obj = {root: {$: {id: "my id"}, _: "my inner text"}};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root id="my id">my inner text</root>
Adding xmlns attributes
You can generate XML that declares XML namespace prefix / URI pairs with xmlns attributes.
Example declaring a default namespace on the root element:
let obj = { 
  Foo: {
    $: {
      "xmlns": "http://foo.com"
    }   
  }
};  
Result of buildObject(obj):
<Foo xmlns="http://foo.com"/>
Example declaring non-default namespaces on non-root elements:
let obj = {
  'foo:Foo': {
    $: {
      'xmlns:foo': 'http://foo.com'
    },
    'bar:Bar': {
      $: {
        'xmlns:bar': 'http://bar.com'
      }
    }
  }
}
Result of buildObject(obj):
<foo:Foo xmlns:foo="http://foo.com">
  <bar:Bar xmlns:bar="http://bar.com"/>
</foo:Foo>
Processing attribute, tag names and values
Since 0.4.1 you can optionally provide the parser with attribute name and tag name processors as well as element value processors (Since 0.4.14, you can also optionally provide the parser with attribute value processors):
function nameToUpperCase(name){
    return name.toUpperCase();
}

//transform all attribute and tag names and values to uppercase
parseString(xml, {
  tagNameProcessors: [nameToUpperCase],
  attrNameProcessors: [nameToUpperCase],
  valueProcessors: [nameToUpperCase],
  attrValueProcessors: [nameToUpperCase]},
  function (err, result) {
    // processed data
});
The tagNameProcessors and attrNameProcessors options
accept an Array of functions with the following signature:
function (name){
  //do something with `name`
  return name
}
The attrValueProcessors and valueProcessors options
accept an Array of functions with the following signature:
function (value, name) {
  //`name` will be the node name or attribute name
  //do something with `value`, (optionally) dependent on the node/attr name
  return value
}
Some processors are provided out-of-the-box and can be found in lib/processors.js:


normalize: transforms the name to lowercase.
(Automatically used when options.normalize is set to true)


firstCharLowerCase: transforms the first character to lower case.
E.g. 'MyTagName' becomes 'myTagName'


stripPrefix: strips the xml namespace prefix. E.g <foo:Bar/> will become 'Bar'.
(N.B.: the xmlns prefix is NOT stripped.)


parseNumbers: parses integer-like strings as integers and float-like strings as floats
E.g. "0" becomes 0 and "15.56" becomes 15.56


parseBooleans: parses boolean-like strings to booleans
E.g. "true" becomes true and "False" becomes false


Options
Apart from the default settings, there are a number of options that can be
specified for the parser. Options are specified by new Parser({optionName: value}). Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

explicitCharkey (default: false) Determines whether or not to use
a charkey prefix for elements with no attributes.

trim (default: false): Trim the whitespace at the beginning and end of
text nodes.

normalizeTags (default: false): Normalize all tag names to lowercase.

normalize (default: false): Trim whitespaces inside text nodes.

explicitRoot (default: true): Set this if you want to get the root
node in the resulting object.

emptyTag (default: ''): what will the value of empty nodes be. In case
you want to use an empty object as a default value, it is better to provide a factory
function () => ({}) instead. Without this function a plain object would
become a shared reference across all occurrences with unwanted behavior.

explicitArray (default: true): Always put child nodes in an array if
true; otherwise an array is created only if there is more than one.

ignoreAttrs (default: false): Ignore all XML attributes and only create
text nodes.

mergeAttrs (default: false): Merge attributes and child elements as
properties of the parent, instead of keying attributes off a child
attribute object. This option is ignored if ignoreAttrs is true.

validator (default null): You can specify a callable that validates
the resulting structure somehow, however you want. See unit tests
for an example.

xmlns (default false): Give each element a field usually called '$ns'
(the first character is the same as attrkey) that contains its local name
and namespace URI.

explicitChildren (default false): Put child elements to separate
property. Doesn't work with mergeAttrs = true. If element has no children
then "children" won't be created. Added in 0.2.5.

childkey (default $$): Prefix that is used to access child elements if
explicitChildren is set to true. Added in 0.2.5.

preserveChildrenOrder (default false): Modifies the behavior of
explicitChildren so that the value of the "children" property becomes an
ordered array. When this is true, every node will also get a #name field
whose value will correspond to the XML nodeName, so that you may iterate
the "children" array and still be able to determine node names. The named
(and potentially unordered) properties are also retained in this
configuration at the same level as the ordered "children" array. Added in
0.4.9.

charsAsChildren (default false): Determines whether chars should be
considered children if explicitChildren is on. Added in 0.2.5.

includeWhiteChars (default false): Determines whether whitespace-only
text nodes should be included. Added in 0.4.17.

async (default false): Should the callbacks be async? This might be
an incompatible change if your code depends on sync execution of callbacks.
Future versions of xml2js might change this default, so the recommendation
is to not depend on sync execution anyway. Added in 0.2.6.

strict (default true): Set sax-js to strict or non-strict parsing mode.
Defaults to true which is highly recommended, since parsing HTML which
is not well-formed XML might yield just about anything. Added in 0.2.7.

attrNameProcessors (default: null): Allows the addition of attribute
name processing functions. Accepts an Array of functions with following
signature:
function (name){
    //do something with `name`
    return name
}
Added in 0.4.14

attrValueProcessors (default: null): Allows the addition of attribute
value processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.1

tagNameProcessors (default: null): Allows the addition of tag name
processing functions. Accepts an Array of functions with following
signature:
function (name){
  //do something with `name`
  return name
}
Added in 0.4.1

valueProcessors (default: null): Allows the addition of element value
processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.6

Options for the Builder class
These options are specified by new Builder({optionName: value}).
Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

rootName (default root or the root key name): root element name to be used in case
explicitRoot is false or to override the root element name.

renderOpts (default { 'pretty': true, 'indent': '  ', 'newline': '\n' }):
Rendering options for xmlbuilder-js.

pretty: prettify generated XML
indent: whitespace for indentation (only when pretty)
newline: newline char (only when pretty)



xmldec (default { 'version': '1.0', 'encoding': 'UTF-8', 'standalone': true }:
XML declaration attributes.


xmldec.version A version number string, e.g. 1.0

xmldec.encoding Encoding declaration, e.g. UTF-8

xmldec.standalone standalone document declaration: true or false



doctype (default null): optional DTD. Eg. {'ext': 'hello.dtd'}


headless (default: false): omit the XML header. Added in 0.4.3.

allowSurrogateChars (default: false): allows using characters from the Unicode
surrogate blocks.

cdata (default: false): wrap text nodes in <![CDATA[ ... ]]> instead of
escaping when necessary. Does not add <![CDATA[ ... ]]> if it is not required.
Added in 0.4.5.

renderOpts, xmldec,doctype and headless pass through to
xmlbuilder-js.
Updating to new version
Version 0.2 changed the default parsing settings, but version 0.1.14 introduced
the default settings for version 0.2, so these settings can be tried before the
migration.
var xml2js = require('xml2js');
var parser = new xml2js.Parser(xml2js.defaults["0.2"]);
To get the 0.1 defaults in version 0.2 you can just use
xml2js.defaults["0.1"] in the same place. This provides you with enough time
to migrate to the saner way of parsing in xml2js 0.2. We try to make the
migration as simple and gentle as possible, but some breakage cannot be
avoided.
So, what exactly did change and why? In 0.2 we changed some defaults to parse
the XML in a more universal and sane way. So we disabled normalize and trim
so xml2js does not cut out any text content. You can reenable this at will of
course. A more important change is that we return the root tag in the resulting
JavaScript structure via the explicitRoot setting, so you need to access the
first element. This is useful for anybody who wants to know what the root node
is and preserves more information. The last major change was to enable
explicitArray, so everytime it is possible that one might embed more than one
sub-tag into a tag, xml2js >= 0.2 returns an array even if the array just
includes one element. This is useful when dealing with APIs that return
variable amounts of subtags.
Running tests, development



The development requirements are handled by npm, you just need to install them.
We also have a number of unit tests, they can be run using npm test directly
from the project root. This runs zap to discover all the tests and execute
them.
If you like to contribute, keep in mind that xml2js is written in
CoffeeScript, so don't develop on the JavaScript files that are checked into
the repository for convenience reasons. Also, please write some unit test to
check your behaviour and if it is some user-facing thing, add some
documentation to this README, so people will know it exists. Thanks in advance!
Getting support
Please, if you have a problem with the library, first make sure you read this
README. If you read this far, thanks, you're good. Then, please make sure your
problem really is with xml2js. It is? Okay, then I'll look at it. Send me a
mail and we can talk. Please don't open issues, as I don't think that is the
proper forum for support problems. Some problems might as well really be bugs
in xml2js, if so I'll let you know to open an issue instead :)
But if you know you really found a bug, feel free to open an issue instead.
ReadmeKeywordsxmljsonPackage SidebarInstallnpm i xml2jsRepositorygithub.com/Leonidas-from-XIV/node-xml2jsHomepagegithub.com/Leonidas-from-XIV/node-xml2jsWeekly Downloads22,667,333Version0.6.2LicenseMITUnpacked Size3.44 MBTotal Files10Last publish2 years agoCollaboratorsTry on RunKitReport malware\n\n\n\nnode-xml2js
Ever had the urge to parse XML? And wanted to access the data in some sane,
easy way? Don't want to compile a C parser, for whatever reason? Then xml2js is
what you're looking for!
Description
Simple XML to JavaScript object converter. It supports bi-directional conversion.
Uses sax-js and
xmlbuilder-js.
Note: If you're looking for a full DOM parser, you probably want
JSDom.
Installation
Simplest way to install xml2js is to use npm, just npm install xml2js which will download xml2js and all dependencies.
xml2js is also available via Bower, just bower install xml2js which will download xml2js and all dependencies.
Usage
No extensive tutorials required because you are a smart developer! The task of
parsing XML should be an easy one, so let's make it so! Here's some examples.
Shoot-and-forget usage
You want to parse XML as simple and easy as possible? It's dangerous to go
alone, take this:
var parseString = require('xml2js').parseString;
var xml = "<root>Hello xml2js!</root>"
parseString(xml, function (err, result) {
    console.dir(result);
});
Can't get easier than this, right? This works starting with xml2js 0.2.3.
With CoffeeScript it looks like this:
{parseString} = require 'xml2js'
xml = "<root>Hello xml2js!</root>"
parseString xml, (err, result) ->
    console.dir result
If you need some special options, fear not, xml2js supports a number of
options (see below), you can specify these as second argument:
parseString(xml, {trim: true}, function (err, result) {
});
Simple as pie usage
That's right, if you have been using xml-simple or a home-grown
wrapper, this was added in 0.1.11 just for you:
var fs = require('fs'),
    xml2js = require('xml2js');

var parser = new xml2js.Parser();
fs.readFile(__dirname + '/foo.xml', function(err, data) {
    parser.parseString(data, function (err, result) {
        console.dir(result);
        console.log('Done');
    });
});
Look ma, no event listeners!
You can also use xml2js from
CoffeeScript, further reducing
the clutter:
fs = require 'fs',
xml2js = require 'xml2js'

parser = new xml2js.Parser()
fs.readFile __dirname + '/foo.xml', (err, data) ->
  parser.parseString data, (err, result) ->
    console.dir result
    console.log 'Done.'
But what happens if you forget the new keyword to create a new Parser? In
the middle of a nightly coding session, it might get lost, after all. Worry
not, we got you covered! Starting with 0.2.8 you can also leave it out, in
which case xml2js will helpfully add it for you, no bad surprises and
inexplicable bugs!
Promise usage
var xml2js = require('xml2js');
var xml = '<foo></foo>';

// With parser
var parser = new xml2js.Parser(/* options */);
parser.parseStringPromise(xml).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});

// Without parser
xml2js.parseStringPromise(xml /*, options */).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});
Parsing multiple files
If you want to parse multiple files, you have multiple possibilities:

You can create one xml2js.Parser per file. That's the recommended one
and is promised to always just work.
You can call reset() on your parser object.
You can hope everything goes well anyway. This behaviour is not
guaranteed work always, if ever. Use option #1 if possible. Thanks!

So you wanna some JSON?
Just wrap the result object in a call to JSON.stringify like this
JSON.stringify(result). You get a string containing the JSON representation
of the parsed object that you can feed to JSON-hungry consumers.
Displaying results
You might wonder why, using console.dir or console.log the output at some
level is only [Object]. Don't worry, this is not because xml2js got lazy.
That's because Node uses util.inspect to convert the object into strings and
that function stops after depth=2 which is a bit low for most XML.
To display the whole deal, you can use console.log(util.inspect(result, false, null)), which displays the whole result.
So much for that, but what if you use
eyes for nice colored output and it
truncates the output with …? Don't fear, there's also a solution for that,
you just need to increase the maxLength limit by creating a custom inspector
var inspect = require('eyes').inspector({maxLength: false}) and then you can
easily inspect(result).
XML builder usage
Since 0.4.0, objects can be also be used to build XML:
var xml2js = require('xml2js');

var obj = {name: "Super", Surname: "Man", age: 23};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root>
  <name>Super</name>
  <Surname>Man</Surname>
  <age>23</age>
</root>
At the moment, a one to one bi-directional conversion is guaranteed only for
default configuration, except for attrkey, charkey and explicitArray options
you can redefine to your taste. Writing CDATA is supported via setting the cdata
option to true.
To specify attributes:
var xml2js = require('xml2js');

var obj = {root: {$: {id: "my id"}, _: "my inner text"}};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root id="my id">my inner text</root>
Adding xmlns attributes
You can generate XML that declares XML namespace prefix / URI pairs with xmlns attributes.
Example declaring a default namespace on the root element:
let obj = { 
  Foo: {
    $: {
      "xmlns": "http://foo.com"
    }   
  }
};  
Result of buildObject(obj):
<Foo xmlns="http://foo.com"/>
Example declaring non-default namespaces on non-root elements:
let obj = {
  'foo:Foo': {
    $: {
      'xmlns:foo': 'http://foo.com'
    },
    'bar:Bar': {
      $: {
        'xmlns:bar': 'http://bar.com'
      }
    }
  }
}
Result of buildObject(obj):
<foo:Foo xmlns:foo="http://foo.com">
  <bar:Bar xmlns:bar="http://bar.com"/>
</foo:Foo>
Processing attribute, tag names and values
Since 0.4.1 you can optionally provide the parser with attribute name and tag name processors as well as element value processors (Since 0.4.14, you can also optionally provide the parser with attribute value processors):
function nameToUpperCase(name){
    return name.toUpperCase();
}

//transform all attribute and tag names and values to uppercase
parseString(xml, {
  tagNameProcessors: [nameToUpperCase],
  attrNameProcessors: [nameToUpperCase],
  valueProcessors: [nameToUpperCase],
  attrValueProcessors: [nameToUpperCase]},
  function (err, result) {
    // processed data
});
The tagNameProcessors and attrNameProcessors options
accept an Array of functions with the following signature:
function (name){
  //do something with `name`
  return name
}
The attrValueProcessors and valueProcessors options
accept an Array of functions with the following signature:
function (value, name) {
  //`name` will be the node name or attribute name
  //do something with `value`, (optionally) dependent on the node/attr name
  return value
}
Some processors are provided out-of-the-box and can be found in lib/processors.js:


normalize: transforms the name to lowercase.
(Automatically used when options.normalize is set to true)


firstCharLowerCase: transforms the first character to lower case.
E.g. 'MyTagName' becomes 'myTagName'


stripPrefix: strips the xml namespace prefix. E.g <foo:Bar/> will become 'Bar'.
(N.B.: the xmlns prefix is NOT stripped.)


parseNumbers: parses integer-like strings as integers and float-like strings as floats
E.g. "0" becomes 0 and "15.56" becomes 15.56


parseBooleans: parses boolean-like strings to booleans
E.g. "true" becomes true and "False" becomes false


Options
Apart from the default settings, there are a number of options that can be
specified for the parser. Options are specified by new Parser({optionName: value}). Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

explicitCharkey (default: false) Determines whether or not to use
a charkey prefix for elements with no attributes.

trim (default: false): Trim the whitespace at the beginning and end of
text nodes.

normalizeTags (default: false): Normalize all tag names to lowercase.

normalize (default: false): Trim whitespaces inside text nodes.

explicitRoot (default: true): Set this if you want to get the root
node in the resulting object.

emptyTag (default: ''): what will the value of empty nodes be. In case
you want to use an empty object as a default value, it is better to provide a factory
function () => ({}) instead. Without this function a plain object would
become a shared reference across all occurrences with unwanted behavior.

explicitArray (default: true): Always put child nodes in an array if
true; otherwise an array is created only if there is more than one.

ignoreAttrs (default: false): Ignore all XML attributes and only create
text nodes.

mergeAttrs (default: false): Merge attributes and child elements as
properties of the parent, instead of keying attributes off a child
attribute object. This option is ignored if ignoreAttrs is true.

validator (default null): You can specify a callable that validates
the resulting structure somehow, however you want. See unit tests
for an example.

xmlns (default false): Give each element a field usually called '$ns'
(the first character is the same as attrkey) that contains its local name
and namespace URI.

explicitChildren (default false): Put child elements to separate
property. Doesn't work with mergeAttrs = true. If element has no children
then "children" won't be created. Added in 0.2.5.

childkey (default $$): Prefix that is used to access child elements if
explicitChildren is set to true. Added in 0.2.5.

preserveChildrenOrder (default false): Modifies the behavior of
explicitChildren so that the value of the "children" property becomes an
ordered array. When this is true, every node will also get a #name field
whose value will correspond to the XML nodeName, so that you may iterate
the "children" array and still be able to determine node names. The named
(and potentially unordered) properties are also retained in this
configuration at the same level as the ordered "children" array. Added in
0.4.9.

charsAsChildren (default false): Determines whether chars should be
considered children if explicitChildren is on. Added in 0.2.5.

includeWhiteChars (default false): Determines whether whitespace-only
text nodes should be included. Added in 0.4.17.

async (default false): Should the callbacks be async? This might be
an incompatible change if your code depends on sync execution of callbacks.
Future versions of xml2js might change this default, so the recommendation
is to not depend on sync execution anyway. Added in 0.2.6.

strict (default true): Set sax-js to strict or non-strict parsing mode.
Defaults to true which is highly recommended, since parsing HTML which
is not well-formed XML might yield just about anything. Added in 0.2.7.

attrNameProcessors (default: null): Allows the addition of attribute
name processing functions. Accepts an Array of functions with following
signature:
function (name){
    //do something with `name`
    return name
}
Added in 0.4.14

attrValueProcessors (default: null): Allows the addition of attribute
value processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.1

tagNameProcessors (default: null): Allows the addition of tag name
processing functions. Accepts an Array of functions with following
signature:
function (name){
  //do something with `name`
  return name
}
Added in 0.4.1

valueProcessors (default: null): Allows the addition of element value
processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.6

Options for the Builder class
These options are specified by new Builder({optionName: value}).
Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

rootName (default root or the root key name): root element name to be used in case
explicitRoot is false or to override the root element name.

renderOpts (default { 'pretty': true, 'indent': '  ', 'newline': '\n' }):
Rendering options for xmlbuilder-js.

pretty: prettify generated XML
indent: whitespace for indentation (only when pretty)
newline: newline char (only when pretty)



xmldec (default { 'version': '1.0', 'encoding': 'UTF-8', 'standalone': true }:
XML declaration attributes.


xmldec.version A version number string, e.g. 1.0

xmldec.encoding Encoding declaration, e.g. UTF-8

xmldec.standalone standalone document declaration: true or false



doctype (default null): optional DTD. Eg. {'ext': 'hello.dtd'}


headless (default: false): omit the XML header. Added in 0.4.3.

allowSurrogateChars (default: false): allows using characters from the Unicode
surrogate blocks.

cdata (default: false): wrap text nodes in <![CDATA[ ... ]]> instead of
escaping when necessary. Does not add <![CDATA[ ... ]]> if it is not required.
Added in 0.4.5.

renderOpts, xmldec,doctype and headless pass through to
xmlbuilder-js.
Updating to new version
Version 0.2 changed the default parsing settings, but version 0.1.14 introduced
the default settings for version 0.2, so these settings can be tried before the
migration.
var xml2js = require('xml2js');
var parser = new xml2js.Parser(xml2js.defaults["0.2"]);
To get the 0.1 defaults in version 0.2 you can just use
xml2js.defaults["0.1"] in the same place. This provides you with enough time
to migrate to the saner way of parsing in xml2js 0.2. We try to make the
migration as simple and gentle as possible, but some breakage cannot be
avoided.
So, what exactly did change and why? In 0.2 we changed some defaults to parse
the XML in a more universal and sane way. So we disabled normalize and trim
so xml2js does not cut out any text content. You can reenable this at will of
course. A more important change is that we return the root tag in the resulting
JavaScript structure via the explicitRoot setting, so you need to access the
first element. This is useful for anybody who wants to know what the root node
is and preserves more information. The last major change was to enable
explicitArray, so everytime it is possible that one might embed more than one
sub-tag into a tag, xml2js >= 0.2 returns an array even if the array just
includes one element. This is useful when dealing with APIs that return
variable amounts of subtags.
Running tests, development



The development requirements are handled by npm, you just need to install them.
We also have a number of unit tests, they can be run using npm test directly
from the project root. This runs zap to discover all the tests and execute
them.
If you like to contribute, keep in mind that xml2js is written in
CoffeeScript, so don't develop on the JavaScript files that are checked into
the repository for convenience reasons. Also, please write some unit test to
check your behaviour and if it is some user-facing thing, add some
documentation to this README, so people will know it exists. Thanks in advance!
Getting support
Please, if you have a problem with the library, first make sure you read this
README. If you read this far, thanks, you're good. Then, please make sure your
problem really is with xml2js. It is? Okay, then I'll look at it. Send me a
mail and we can talk. Please don't open issues, as I don't think that is the
proper forum for support problems. Some problems might as well really be bugs
in xml2js, if so I'll let you know to open an issue instead :)
But if you know you really found a bug, feel free to open an issue instead.\n\nxml2js0.6.2 • Public • Published 2 years ago ReadmeCode Beta2 Dependencies10,263 Dependents52 Versionsnode-xml2js
Ever had the urge to parse XML? And wanted to access the data in some sane,
easy way? Don't want to compile a C parser, for whatever reason? Then xml2js is
what you're looking for!
Description
Simple XML to JavaScript object converter. It supports bi-directional conversion.
Uses sax-js and
xmlbuilder-js.
Note: If you're looking for a full DOM parser, you probably want
JSDom.
Installation
Simplest way to install xml2js is to use npm, just npm install xml2js which will download xml2js and all dependencies.
xml2js is also available via Bower, just bower install xml2js which will download xml2js and all dependencies.
Usage
No extensive tutorials required because you are a smart developer! The task of
parsing XML should be an easy one, so let's make it so! Here's some examples.
Shoot-and-forget usage
You want to parse XML as simple and easy as possible? It's dangerous to go
alone, take this:
var parseString = require('xml2js').parseString;
var xml = "<root>Hello xml2js!</root>"
parseString(xml, function (err, result) {
    console.dir(result);
});
Can't get easier than this, right? This works starting with xml2js 0.2.3.
With CoffeeScript it looks like this:
{parseString} = require 'xml2js'
xml = "<root>Hello xml2js!</root>"
parseString xml, (err, result) ->
    console.dir result
If you need some special options, fear not, xml2js supports a number of
options (see below), you can specify these as second argument:
parseString(xml, {trim: true}, function (err, result) {
});
Simple as pie usage
That's right, if you have been using xml-simple or a home-grown
wrapper, this was added in 0.1.11 just for you:
var fs = require('fs'),
    xml2js = require('xml2js');

var parser = new xml2js.Parser();
fs.readFile(__dirname + '/foo.xml', function(err, data) {
    parser.parseString(data, function (err, result) {
        console.dir(result);
        console.log('Done');
    });
});
Look ma, no event listeners!
You can also use xml2js from
CoffeeScript, further reducing
the clutter:
fs = require 'fs',
xml2js = require 'xml2js'

parser = new xml2js.Parser()
fs.readFile __dirname + '/foo.xml', (err, data) ->
  parser.parseString data, (err, result) ->
    console.dir result
    console.log 'Done.'
But what happens if you forget the new keyword to create a new Parser? In
the middle of a nightly coding session, it might get lost, after all. Worry
not, we got you covered! Starting with 0.2.8 you can also leave it out, in
which case xml2js will helpfully add it for you, no bad surprises and
inexplicable bugs!
Promise usage
var xml2js = require('xml2js');
var xml = '<foo></foo>';

// With parser
var parser = new xml2js.Parser(/* options */);
parser.parseStringPromise(xml).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});

// Without parser
xml2js.parseStringPromise(xml /*, options */).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});
Parsing multiple files
If you want to parse multiple files, you have multiple possibilities:

You can create one xml2js.Parser per file. That's the recommended one
and is promised to always just work.
You can call reset() on your parser object.
You can hope everything goes well anyway. This behaviour is not
guaranteed work always, if ever. Use option #1 if possible. Thanks!

So you wanna some JSON?
Just wrap the result object in a call to JSON.stringify like this
JSON.stringify(result). You get a string containing the JSON representation
of the parsed object that you can feed to JSON-hungry consumers.
Displaying results
You might wonder why, using console.dir or console.log the output at some
level is only [Object]. Don't worry, this is not because xml2js got lazy.
That's because Node uses util.inspect to convert the object into strings and
that function stops after depth=2 which is a bit low for most XML.
To display the whole deal, you can use console.log(util.inspect(result, false, null)), which displays the whole result.
So much for that, but what if you use
eyes for nice colored output and it
truncates the output with …? Don't fear, there's also a solution for that,
you just need to increase the maxLength limit by creating a custom inspector
var inspect = require('eyes').inspector({maxLength: false}) and then you can
easily inspect(result).
XML builder usage
Since 0.4.0, objects can be also be used to build XML:
var xml2js = require('xml2js');

var obj = {name: "Super", Surname: "Man", age: 23};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root>
  <name>Super</name>
  <Surname>Man</Surname>
  <age>23</age>
</root>
At the moment, a one to one bi-directional conversion is guaranteed only for
default configuration, except for attrkey, charkey and explicitArray options
you can redefine to your taste. Writing CDATA is supported via setting the cdata
option to true.
To specify attributes:
var xml2js = require('xml2js');

var obj = {root: {$: {id: "my id"}, _: "my inner text"}};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root id="my id">my inner text</root>
Adding xmlns attributes
You can generate XML that declares XML namespace prefix / URI pairs with xmlns attributes.
Example declaring a default namespace on the root element:
let obj = { 
  Foo: {
    $: {
      "xmlns": "http://foo.com"
    }   
  }
};  
Result of buildObject(obj):
<Foo xmlns="http://foo.com"/>
Example declaring non-default namespaces on non-root elements:
let obj = {
  'foo:Foo': {
    $: {
      'xmlns:foo': 'http://foo.com'
    },
    'bar:Bar': {
      $: {
        'xmlns:bar': 'http://bar.com'
      }
    }
  }
}
Result of buildObject(obj):
<foo:Foo xmlns:foo="http://foo.com">
  <bar:Bar xmlns:bar="http://bar.com"/>
</foo:Foo>
Processing attribute, tag names and values
Since 0.4.1 you can optionally provide the parser with attribute name and tag name processors as well as element value processors (Since 0.4.14, you can also optionally provide the parser with attribute value processors):
function nameToUpperCase(name){
    return name.toUpperCase();
}

//transform all attribute and tag names and values to uppercase
parseString(xml, {
  tagNameProcessors: [nameToUpperCase],
  attrNameProcessors: [nameToUpperCase],
  valueProcessors: [nameToUpperCase],
  attrValueProcessors: [nameToUpperCase]},
  function (err, result) {
    // processed data
});
The tagNameProcessors and attrNameProcessors options
accept an Array of functions with the following signature:
function (name){
  //do something with `name`
  return name
}
The attrValueProcessors and valueProcessors options
accept an Array of functions with the following signature:
function (value, name) {
  //`name` will be the node name or attribute name
  //do something with `value`, (optionally) dependent on the node/attr name
  return value
}
Some processors are provided out-of-the-box and can be found in lib/processors.js:


normalize: transforms the name to lowercase.
(Automatically used when options.normalize is set to true)


firstCharLowerCase: transforms the first character to lower case.
E.g. 'MyTagName' becomes 'myTagName'


stripPrefix: strips the xml namespace prefix. E.g <foo:Bar/> will become 'Bar'.
(N.B.: the xmlns prefix is NOT stripped.)


parseNumbers: parses integer-like strings as integers and float-like strings as floats
E.g. "0" becomes 0 and "15.56" becomes 15.56


parseBooleans: parses boolean-like strings to booleans
E.g. "true" becomes true and "False" becomes false


Options
Apart from the default settings, there are a number of options that can be
specified for the parser. Options are specified by new Parser({optionName: value}). Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

explicitCharkey (default: false) Determines whether or not to use
a charkey prefix for elements with no attributes.

trim (default: false): Trim the whitespace at the beginning and end of
text nodes.

normalizeTags (default: false): Normalize all tag names to lowercase.

normalize (default: false): Trim whitespaces inside text nodes.

explicitRoot (default: true): Set this if you want to get the root
node in the resulting object.

emptyTag (default: ''): what will the value of empty nodes be. In case
you want to use an empty object as a default value, it is better to provide a factory
function () => ({}) instead. Without this function a plain object would
become a shared reference across all occurrences with unwanted behavior.

explicitArray (default: true): Always put child nodes in an array if
true; otherwise an array is created only if there is more than one.

ignoreAttrs (default: false): Ignore all XML attributes and only create
text nodes.

mergeAttrs (default: false): Merge attributes and child elements as
properties of the parent, instead of keying attributes off a child
attribute object. This option is ignored if ignoreAttrs is true.

validator (default null): You can specify a callable that validates
the resulting structure somehow, however you want. See unit tests
for an example.

xmlns (default false): Give each element a field usually called '$ns'
(the first character is the same as attrkey) that contains its local name
and namespace URI.

explicitChildren (default false): Put child elements to separate
property. Doesn't work with mergeAttrs = true. If element has no children
then "children" won't be created. Added in 0.2.5.

childkey (default $$): Prefix that is used to access child elements if
explicitChildren is set to true. Added in 0.2.5.

preserveChildrenOrder (default false): Modifies the behavior of
explicitChildren so that the value of the "children" property becomes an
ordered array. When this is true, every node will also get a #name field
whose value will correspond to the XML nodeName, so that you may iterate
the "children" array and still be able to determine node names. The named
(and potentially unordered) properties are also retained in this
configuration at the same level as the ordered "children" array. Added in
0.4.9.

charsAsChildren (default false): Determines whether chars should be
considered children if explicitChildren is on. Added in 0.2.5.

includeWhiteChars (default false): Determines whether whitespace-only
text nodes should be included. Added in 0.4.17.

async (default false): Should the callbacks be async? This might be
an incompatible change if your code depends on sync execution of callbacks.
Future versions of xml2js might change this default, so the recommendation
is to not depend on sync execution anyway. Added in 0.2.6.

strict (default true): Set sax-js to strict or non-strict parsing mode.
Defaults to true which is highly recommended, since parsing HTML which
is not well-formed XML might yield just about anything. Added in 0.2.7.

attrNameProcessors (default: null): Allows the addition of attribute
name processing functions. Accepts an Array of functions with following
signature:
function (name){
    //do something with `name`
    return name
}
Added in 0.4.14

attrValueProcessors (default: null): Allows the addition of attribute
value processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.1

tagNameProcessors (default: null): Allows the addition of tag name
processing functions. Accepts an Array of functions with following
signature:
function (name){
  //do something with `name`
  return name
}
Added in 0.4.1

valueProcessors (default: null): Allows the addition of element value
processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.6

Options for the Builder class
These options are specified by new Builder({optionName: value}).
Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

rootName (default root or the root key name): root element name to be used in case
explicitRoot is false or to override the root element name.

renderOpts (default { 'pretty': true, 'indent': '  ', 'newline': '\n' }):
Rendering options for xmlbuilder-js.

pretty: prettify generated XML
indent: whitespace for indentation (only when pretty)
newline: newline char (only when pretty)



xmldec (default { 'version': '1.0', 'encoding': 'UTF-8', 'standalone': true }:
XML declaration attributes.


xmldec.version A version number string, e.g. 1.0

xmldec.encoding Encoding declaration, e.g. UTF-8

xmldec.standalone standalone document declaration: true or false



doctype (default null): optional DTD. Eg. {'ext': 'hello.dtd'}


headless (default: false): omit the XML header. Added in 0.4.3.

allowSurrogateChars (default: false): allows using characters from the Unicode
surrogate blocks.

cdata (default: false): wrap text nodes in <![CDATA[ ... ]]> instead of
escaping when necessary. Does not add <![CDATA[ ... ]]> if it is not required.
Added in 0.4.5.

renderOpts, xmldec,doctype and headless pass through to
xmlbuilder-js.
Updating to new version
Version 0.2 changed the default parsing settings, but version 0.1.14 introduced
the default settings for version 0.2, so these settings can be tried before the
migration.
var xml2js = require('xml2js');
var parser = new xml2js.Parser(xml2js.defaults["0.2"]);
To get the 0.1 defaults in version 0.2 you can just use
xml2js.defaults["0.1"] in the same place. This provides you with enough time
to migrate to the saner way of parsing in xml2js 0.2. We try to make the
migration as simple and gentle as possible, but some breakage cannot be
avoided.
So, what exactly did change and why? In 0.2 we changed some defaults to parse
the XML in a more universal and sane way. So we disabled normalize and trim
so xml2js does not cut out any text content. You can reenable this at will of
course. A more important change is that we return the root tag in the resulting
JavaScript structure via the explicitRoot setting, so you need to access the
first element. This is useful for anybody who wants to know what the root node
is and preserves more information. The last major change was to enable
explicitArray, so everytime it is possible that one might embed more than one
sub-tag into a tag, xml2js >= 0.2 returns an array even if the array just
includes one element. This is useful when dealing with APIs that return
variable amounts of subtags.
Running tests, development



The development requirements are handled by npm, you just need to install them.
We also have a number of unit tests, they can be run using npm test directly
from the project root. This runs zap to discover all the tests and execute
them.
If you like to contribute, keep in mind that xml2js is written in
CoffeeScript, so don't develop on the JavaScript files that are checked into
the repository for convenience reasons. Also, please write some unit test to
check your behaviour and if it is some user-facing thing, add some
documentation to this README, so people will know it exists. Thanks in advance!
Getting support
Please, if you have a problem with the library, first make sure you read this
README. If you read this far, thanks, you're good. Then, please make sure your
problem really is with xml2js. It is? Okay, then I'll look at it. Send me a
mail and we can talk. Please don't open issues, as I don't think that is the
proper forum for support problems. Some problems might as well really be bugs
in xml2js, if so I'll let you know to open an issue instead :)
But if you know you really found a bug, feel free to open an issue instead.
/xml2js//xml2js/Package SidebarInstallnpm i xml2jsRepositorygithub.com/Leonidas-from-XIV/node-xml2jsHomepagegithub.com/Leonidas-from-XIV/node-xml2jsWeekly Downloads22,667,333Version0.6.2LicenseMITUnpacked Size3.44 MBTotal Files10Last publish2 years agoCollaboratorsTry on RunKitReport malware\n\nxml2js0.6.2 • Public • Published 2 years ago ReadmeCode Beta2 Dependencies10,263 Dependents52 Versionsnode-xml2js
Ever had the urge to parse XML? And wanted to access the data in some sane,
easy way? Don't want to compile a C parser, for whatever reason? Then xml2js is
what you're looking for!
Description
Simple XML to JavaScript object converter. It supports bi-directional conversion.
Uses sax-js and
xmlbuilder-js.
Note: If you're looking for a full DOM parser, you probably want
JSDom.
Installation
Simplest way to install xml2js is to use npm, just npm install xml2js which will download xml2js and all dependencies.
xml2js is also available via Bower, just bower install xml2js which will download xml2js and all dependencies.
Usage
No extensive tutorials required because you are a smart developer! The task of
parsing XML should be an easy one, so let's make it so! Here's some examples.
Shoot-and-forget usage
You want to parse XML as simple and easy as possible? It's dangerous to go
alone, take this:
var parseString = require('xml2js').parseString;
var xml = "<root>Hello xml2js!</root>"
parseString(xml, function (err, result) {
    console.dir(result);
});
Can't get easier than this, right? This works starting with xml2js 0.2.3.
With CoffeeScript it looks like this:
{parseString} = require 'xml2js'
xml = "<root>Hello xml2js!</root>"
parseString xml, (err, result) ->
    console.dir result
If you need some special options, fear not, xml2js supports a number of
options (see below), you can specify these as second argument:
parseString(xml, {trim: true}, function (err, result) {
});
Simple as pie usage
That's right, if you have been using xml-simple or a home-grown
wrapper, this was added in 0.1.11 just for you:
var fs = require('fs'),
    xml2js = require('xml2js');

var parser = new xml2js.Parser();
fs.readFile(__dirname + '/foo.xml', function(err, data) {
    parser.parseString(data, function (err, result) {
        console.dir(result);
        console.log('Done');
    });
});
Look ma, no event listeners!
You can also use xml2js from
CoffeeScript, further reducing
the clutter:
fs = require 'fs',
xml2js = require 'xml2js'

parser = new xml2js.Parser()
fs.readFile __dirname + '/foo.xml', (err, data) ->
  parser.parseString data, (err, result) ->
    console.dir result
    console.log 'Done.'
But what happens if you forget the new keyword to create a new Parser? In
the middle of a nightly coding session, it might get lost, after all. Worry
not, we got you covered! Starting with 0.2.8 you can also leave it out, in
which case xml2js will helpfully add it for you, no bad surprises and
inexplicable bugs!
Promise usage
var xml2js = require('xml2js');
var xml = '<foo></foo>';

// With parser
var parser = new xml2js.Parser(/* options */);
parser.parseStringPromise(xml).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});

// Without parser
xml2js.parseStringPromise(xml /*, options */).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});
Parsing multiple files
If you want to parse multiple files, you have multiple possibilities:

You can create one xml2js.Parser per file. That's the recommended one
and is promised to always just work.
You can call reset() on your parser object.
You can hope everything goes well anyway. This behaviour is not
guaranteed work always, if ever. Use option #1 if possible. Thanks!

So you wanna some JSON?
Just wrap the result object in a call to JSON.stringify like this
JSON.stringify(result). You get a string containing the JSON representation
of the parsed object that you can feed to JSON-hungry consumers.
Displaying results
You might wonder why, using console.dir or console.log the output at some
level is only [Object]. Don't worry, this is not because xml2js got lazy.
That's because Node uses util.inspect to convert the object into strings and
that function stops after depth=2 which is a bit low for most XML.
To display the whole deal, you can use console.log(util.inspect(result, false, null)), which displays the whole result.
So much for that, but what if you use
eyes for nice colored output and it
truncates the output with …? Don't fear, there's also a solution for that,
you just need to increase the maxLength limit by creating a custom inspector
var inspect = require('eyes').inspector({maxLength: false}) and then you can
easily inspect(result).
XML builder usage
Since 0.4.0, objects can be also be used to build XML:
var xml2js = require('xml2js');

var obj = {name: "Super", Surname: "Man", age: 23};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root>
  <name>Super</name>
  <Surname>Man</Surname>
  <age>23</age>
</root>
At the moment, a one to one bi-directional conversion is guaranteed only for
default configuration, except for attrkey, charkey and explicitArray options
you can redefine to your taste. Writing CDATA is supported via setting the cdata
option to true.
To specify attributes:
var xml2js = require('xml2js');

var obj = {root: {$: {id: "my id"}, _: "my inner text"}};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root id="my id">my inner text</root>
Adding xmlns attributes
You can generate XML that declares XML namespace prefix / URI pairs with xmlns attributes.
Example declaring a default namespace on the root element:
let obj = { 
  Foo: {
    $: {
      "xmlns": "http://foo.com"
    }   
  }
};  
Result of buildObject(obj):
<Foo xmlns="http://foo.com"/>
Example declaring non-default namespaces on non-root elements:
let obj = {
  'foo:Foo': {
    $: {
      'xmlns:foo': 'http://foo.com'
    },
    'bar:Bar': {
      $: {
        'xmlns:bar': 'http://bar.com'
      }
    }
  }
}
Result of buildObject(obj):
<foo:Foo xmlns:foo="http://foo.com">
  <bar:Bar xmlns:bar="http://bar.com"/>
</foo:Foo>
Processing attribute, tag names and values
Since 0.4.1 you can optionally provide the parser with attribute name and tag name processors as well as element value processors (Since 0.4.14, you can also optionally provide the parser with attribute value processors):
function nameToUpperCase(name){
    return name.toUpperCase();
}

//transform all attribute and tag names and values to uppercase
parseString(xml, {
  tagNameProcessors: [nameToUpperCase],
  attrNameProcessors: [nameToUpperCase],
  valueProcessors: [nameToUpperCase],
  attrValueProcessors: [nameToUpperCase]},
  function (err, result) {
    // processed data
});
The tagNameProcessors and attrNameProcessors options
accept an Array of functions with the following signature:
function (name){
  //do something with `name`
  return name
}
The attrValueProcessors and valueProcessors options
accept an Array of functions with the following signature:
function (value, name) {
  //`name` will be the node name or attribute name
  //do something with `value`, (optionally) dependent on the node/attr name
  return value
}
Some processors are provided out-of-the-box and can be found in lib/processors.js:


normalize: transforms the name to lowercase.
(Automatically used when options.normalize is set to true)


firstCharLowerCase: transforms the first character to lower case.
E.g. 'MyTagName' becomes 'myTagName'


stripPrefix: strips the xml namespace prefix. E.g <foo:Bar/> will become 'Bar'.
(N.B.: the xmlns prefix is NOT stripped.)


parseNumbers: parses integer-like strings as integers and float-like strings as floats
E.g. "0" becomes 0 and "15.56" becomes 15.56


parseBooleans: parses boolean-like strings to booleans
E.g. "true" becomes true and "False" becomes false


Options
Apart from the default settings, there are a number of options that can be
specified for the parser. Options are specified by new Parser({optionName: value}). Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

explicitCharkey (default: false) Determines whether or not to use
a charkey prefix for elements with no attributes.

trim (default: false): Trim the whitespace at the beginning and end of
text nodes.

normalizeTags (default: false): Normalize all tag names to lowercase.

normalize (default: false): Trim whitespaces inside text nodes.

explicitRoot (default: true): Set this if you want to get the root
node in the resulting object.

emptyTag (default: ''): what will the value of empty nodes be. In case
you want to use an empty object as a default value, it is better to provide a factory
function () => ({}) instead. Without this function a plain object would
become a shared reference across all occurrences with unwanted behavior.

explicitArray (default: true): Always put child nodes in an array if
true; otherwise an array is created only if there is more than one.

ignoreAttrs (default: false): Ignore all XML attributes and only create
text nodes.

mergeAttrs (default: false): Merge attributes and child elements as
properties of the parent, instead of keying attributes off a child
attribute object. This option is ignored if ignoreAttrs is true.

validator (default null): You can specify a callable that validates
the resulting structure somehow, however you want. See unit tests
for an example.

xmlns (default false): Give each element a field usually called '$ns'
(the first character is the same as attrkey) that contains its local name
and namespace URI.

explicitChildren (default false): Put child elements to separate
property. Doesn't work with mergeAttrs = true. If element has no children
then "children" won't be created. Added in 0.2.5.

childkey (default $$): Prefix that is used to access child elements if
explicitChildren is set to true. Added in 0.2.5.

preserveChildrenOrder (default false): Modifies the behavior of
explicitChildren so that the value of the "children" property becomes an
ordered array. When this is true, every node will also get a #name field
whose value will correspond to the XML nodeName, so that you may iterate
the "children" array and still be able to determine node names. The named
(and potentially unordered) properties are also retained in this
configuration at the same level as the ordered "children" array. Added in
0.4.9.

charsAsChildren (default false): Determines whether chars should be
considered children if explicitChildren is on. Added in 0.2.5.

includeWhiteChars (default false): Determines whether whitespace-only
text nodes should be included. Added in 0.4.17.

async (default false): Should the callbacks be async? This might be
an incompatible change if your code depends on sync execution of callbacks.
Future versions of xml2js might change this default, so the recommendation
is to not depend on sync execution anyway. Added in 0.2.6.

strict (default true): Set sax-js to strict or non-strict parsing mode.
Defaults to true which is highly recommended, since parsing HTML which
is not well-formed XML might yield just about anything. Added in 0.2.7.

attrNameProcessors (default: null): Allows the addition of attribute
name processing functions. Accepts an Array of functions with following
signature:
function (name){
    //do something with `name`
    return name
}
Added in 0.4.14

attrValueProcessors (default: null): Allows the addition of attribute
value processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.1

tagNameProcessors (default: null): Allows the addition of tag name
processing functions. Accepts an Array of functions with following
signature:
function (name){
  //do something with `name`
  return name
}
Added in 0.4.1

valueProcessors (default: null): Allows the addition of element value
processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.6

Options for the Builder class
These options are specified by new Builder({optionName: value}).
Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

rootName (default root or the root key name): root element name to be used in case
explicitRoot is false or to override the root element name.

renderOpts (default { 'pretty': true, 'indent': '  ', 'newline': '\n' }):
Rendering options for xmlbuilder-js.

pretty: prettify generated XML
indent: whitespace for indentation (only when pretty)
newline: newline char (only when pretty)



xmldec (default { 'version': '1.0', 'encoding': 'UTF-8', 'standalone': true }:
XML declaration attributes.


xmldec.version A version number string, e.g. 1.0

xmldec.encoding Encoding declaration, e.g. UTF-8

xmldec.standalone standalone document declaration: true or false



doctype (default null): optional DTD. Eg. {'ext': 'hello.dtd'}


headless (default: false): omit the XML header. Added in 0.4.3.

allowSurrogateChars (default: false): allows using characters from the Unicode
surrogate blocks.

cdata (default: false): wrap text nodes in <![CDATA[ ... ]]> instead of
escaping when necessary. Does not add <![CDATA[ ... ]]> if it is not required.
Added in 0.4.5.

renderOpts, xmldec,doctype and headless pass through to
xmlbuilder-js.
Updating to new version
Version 0.2 changed the default parsing settings, but version 0.1.14 introduced
the default settings for version 0.2, so these settings can be tried before the
migration.
var xml2js = require('xml2js');
var parser = new xml2js.Parser(xml2js.defaults["0.2"]);
To get the 0.1 defaults in version 0.2 you can just use
xml2js.defaults["0.1"] in the same place. This provides you with enough time
to migrate to the saner way of parsing in xml2js 0.2. We try to make the
migration as simple and gentle as possible, but some breakage cannot be
avoided.
So, what exactly did change and why? In 0.2 we changed some defaults to parse
the XML in a more universal and sane way. So we disabled normalize and trim
so xml2js does not cut out any text content. You can reenable this at will of
course. A more important change is that we return the root tag in the resulting
JavaScript structure via the explicitRoot setting, so you need to access the
first element. This is useful for anybody who wants to know what the root node
is and preserves more information. The last major change was to enable
explicitArray, so everytime it is possible that one might embed more than one
sub-tag into a tag, xml2js >= 0.2 returns an array even if the array just
includes one element. This is useful when dealing with APIs that return
variable amounts of subtags.
Running tests, development



The development requirements are handled by npm, you just need to install them.
We also have a number of unit tests, they can be run using npm test directly
from the project root. This runs zap to discover all the tests and execute
them.
If you like to contribute, keep in mind that xml2js is written in
CoffeeScript, so don't develop on the JavaScript files that are checked into
the repository for convenience reasons. Also, please write some unit test to
check your behaviour and if it is some user-facing thing, add some
documentation to this README, so people will know it exists. Thanks in advance!
Getting support
Please, if you have a problem with the library, first make sure you read this
README. If you read this far, thanks, you're good. Then, please make sure your
problem really is with xml2js. It is? Okay, then I'll look at it. Send me a
mail and we can talk. Please don't open issues, as I don't think that is the
proper forum for support problems. Some problems might as well really be bugs
in xml2js, if so I'll let you know to open an issue instead :)
But if you know you really found a bug, feel free to open an issue instead.
/xml2js//xml2js/Package SidebarInstallnpm i xml2jsRepositorygithub.com/Leonidas-from-XIV/node-xml2jsHomepagegithub.com/Leonidas-from-XIV/node-xml2jsWeekly Downloads22,667,333Version0.6.2LicenseMITUnpacked Size3.44 MBTotal Files10Last publish2 years agoCollaboratorsTry on RunKitReport malware\n\n\n\nnode-xml2js
Ever had the urge to parse XML? And wanted to access the data in some sane,
easy way? Don't want to compile a C parser, for whatever reason? Then xml2js is
what you're looking for!
Description
Simple XML to JavaScript object converter. It supports bi-directional conversion.
Uses sax-js and
xmlbuilder-js.
Note: If you're looking for a full DOM parser, you probably want
JSDom.
Installation
Simplest way to install xml2js is to use npm, just npm install xml2js which will download xml2js and all dependencies.
xml2js is also available via Bower, just bower install xml2js which will download xml2js and all dependencies.
Usage
No extensive tutorials required because you are a smart developer! The task of
parsing XML should be an easy one, so let's make it so! Here's some examples.
Shoot-and-forget usage
You want to parse XML as simple and easy as possible? It's dangerous to go
alone, take this:
var parseString = require('xml2js').parseString;
var xml = "<root>Hello xml2js!</root>"
parseString(xml, function (err, result) {
    console.dir(result);
});
Can't get easier than this, right? This works starting with xml2js 0.2.3.
With CoffeeScript it looks like this:
{parseString} = require 'xml2js'
xml = "<root>Hello xml2js!</root>"
parseString xml, (err, result) ->
    console.dir result
If you need some special options, fear not, xml2js supports a number of
options (see below), you can specify these as second argument:
parseString(xml, {trim: true}, function (err, result) {
});
Simple as pie usage
That's right, if you have been using xml-simple or a home-grown
wrapper, this was added in 0.1.11 just for you:
var fs = require('fs'),
    xml2js = require('xml2js');

var parser = new xml2js.Parser();
fs.readFile(__dirname + '/foo.xml', function(err, data) {
    parser.parseString(data, function (err, result) {
        console.dir(result);
        console.log('Done');
    });
});
Look ma, no event listeners!
You can also use xml2js from
CoffeeScript, further reducing
the clutter:
fs = require 'fs',
xml2js = require 'xml2js'

parser = new xml2js.Parser()
fs.readFile __dirname + '/foo.xml', (err, data) ->
  parser.parseString data, (err, result) ->
    console.dir result
    console.log 'Done.'
But what happens if you forget the new keyword to create a new Parser? In
the middle of a nightly coding session, it might get lost, after all. Worry
not, we got you covered! Starting with 0.2.8 you can also leave it out, in
which case xml2js will helpfully add it for you, no bad surprises and
inexplicable bugs!
Promise usage
var xml2js = require('xml2js');
var xml = '<foo></foo>';

// With parser
var parser = new xml2js.Parser(/* options */);
parser.parseStringPromise(xml).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});

// Without parser
xml2js.parseStringPromise(xml /*, options */).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});
Parsing multiple files
If you want to parse multiple files, you have multiple possibilities:

You can create one xml2js.Parser per file. That's the recommended one
and is promised to always just work.
You can call reset() on your parser object.
You can hope everything goes well anyway. This behaviour is not
guaranteed work always, if ever. Use option #1 if possible. Thanks!

So you wanna some JSON?
Just wrap the result object in a call to JSON.stringify like this
JSON.stringify(result). You get a string containing the JSON representation
of the parsed object that you can feed to JSON-hungry consumers.
Displaying results
You might wonder why, using console.dir or console.log the output at some
level is only [Object]. Don't worry, this is not because xml2js got lazy.
That's because Node uses util.inspect to convert the object into strings and
that function stops after depth=2 which is a bit low for most XML.
To display the whole deal, you can use console.log(util.inspect(result, false, null)), which displays the whole result.
So much for that, but what if you use
eyes for nice colored output and it
truncates the output with …? Don't fear, there's also a solution for that,
you just need to increase the maxLength limit by creating a custom inspector
var inspect = require('eyes').inspector({maxLength: false}) and then you can
easily inspect(result).
XML builder usage
Since 0.4.0, objects can be also be used to build XML:
var xml2js = require('xml2js');

var obj = {name: "Super", Surname: "Man", age: 23};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root>
  <name>Super</name>
  <Surname>Man</Surname>
  <age>23</age>
</root>
At the moment, a one to one bi-directional conversion is guaranteed only for
default configuration, except for attrkey, charkey and explicitArray options
you can redefine to your taste. Writing CDATA is supported via setting the cdata
option to true.
To specify attributes:
var xml2js = require('xml2js');

var obj = {root: {$: {id: "my id"}, _: "my inner text"}};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root id="my id">my inner text</root>
Adding xmlns attributes
You can generate XML that declares XML namespace prefix / URI pairs with xmlns attributes.
Example declaring a default namespace on the root element:
let obj = { 
  Foo: {
    $: {
      "xmlns": "http://foo.com"
    }   
  }
};  
Result of buildObject(obj):
<Foo xmlns="http://foo.com"/>
Example declaring non-default namespaces on non-root elements:
let obj = {
  'foo:Foo': {
    $: {
      'xmlns:foo': 'http://foo.com'
    },
    'bar:Bar': {
      $: {
        'xmlns:bar': 'http://bar.com'
      }
    }
  }
}
Result of buildObject(obj):
<foo:Foo xmlns:foo="http://foo.com">
  <bar:Bar xmlns:bar="http://bar.com"/>
</foo:Foo>
Processing attribute, tag names and values
Since 0.4.1 you can optionally provide the parser with attribute name and tag name processors as well as element value processors (Since 0.4.14, you can also optionally provide the parser with attribute value processors):
function nameToUpperCase(name){
    return name.toUpperCase();
}

//transform all attribute and tag names and values to uppercase
parseString(xml, {
  tagNameProcessors: [nameToUpperCase],
  attrNameProcessors: [nameToUpperCase],
  valueProcessors: [nameToUpperCase],
  attrValueProcessors: [nameToUpperCase]},
  function (err, result) {
    // processed data
});
The tagNameProcessors and attrNameProcessors options
accept an Array of functions with the following signature:
function (name){
  //do something with `name`
  return name
}
The attrValueProcessors and valueProcessors options
accept an Array of functions with the following signature:
function (value, name) {
  //`name` will be the node name or attribute name
  //do something with `value`, (optionally) dependent on the node/attr name
  return value
}
Some processors are provided out-of-the-box and can be found in lib/processors.js:


normalize: transforms the name to lowercase.
(Automatically used when options.normalize is set to true)


firstCharLowerCase: transforms the first character to lower case.
E.g. 'MyTagName' becomes 'myTagName'


stripPrefix: strips the xml namespace prefix. E.g <foo:Bar/> will become 'Bar'.
(N.B.: the xmlns prefix is NOT stripped.)


parseNumbers: parses integer-like strings as integers and float-like strings as floats
E.g. "0" becomes 0 and "15.56" becomes 15.56


parseBooleans: parses boolean-like strings to booleans
E.g. "true" becomes true and "False" becomes false


Options
Apart from the default settings, there are a number of options that can be
specified for the parser. Options are specified by new Parser({optionName: value}). Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

explicitCharkey (default: false) Determines whether or not to use
a charkey prefix for elements with no attributes.

trim (default: false): Trim the whitespace at the beginning and end of
text nodes.

normalizeTags (default: false): Normalize all tag names to lowercase.

normalize (default: false): Trim whitespaces inside text nodes.

explicitRoot (default: true): Set this if you want to get the root
node in the resulting object.

emptyTag (default: ''): what will the value of empty nodes be. In case
you want to use an empty object as a default value, it is better to provide a factory
function () => ({}) instead. Without this function a plain object would
become a shared reference across all occurrences with unwanted behavior.

explicitArray (default: true): Always put child nodes in an array if
true; otherwise an array is created only if there is more than one.

ignoreAttrs (default: false): Ignore all XML attributes and only create
text nodes.

mergeAttrs (default: false): Merge attributes and child elements as
properties of the parent, instead of keying attributes off a child
attribute object. This option is ignored if ignoreAttrs is true.

validator (default null): You can specify a callable that validates
the resulting structure somehow, however you want. See unit tests
for an example.

xmlns (default false): Give each element a field usually called '$ns'
(the first character is the same as attrkey) that contains its local name
and namespace URI.

explicitChildren (default false): Put child elements to separate
property. Doesn't work with mergeAttrs = true. If element has no children
then "children" won't be created. Added in 0.2.5.

childkey (default $$): Prefix that is used to access child elements if
explicitChildren is set to true. Added in 0.2.5.

preserveChildrenOrder (default false): Modifies the behavior of
explicitChildren so that the value of the "children" property becomes an
ordered array. When this is true, every node will also get a #name field
whose value will correspond to the XML nodeName, so that you may iterate
the "children" array and still be able to determine node names. The named
(and potentially unordered) properties are also retained in this
configuration at the same level as the ordered "children" array. Added in
0.4.9.

charsAsChildren (default false): Determines whether chars should be
considered children if explicitChildren is on. Added in 0.2.5.

includeWhiteChars (default false): Determines whether whitespace-only
text nodes should be included. Added in 0.4.17.

async (default false): Should the callbacks be async? This might be
an incompatible change if your code depends on sync execution of callbacks.
Future versions of xml2js might change this default, so the recommendation
is to not depend on sync execution anyway. Added in 0.2.6.

strict (default true): Set sax-js to strict or non-strict parsing mode.
Defaults to true which is highly recommended, since parsing HTML which
is not well-formed XML might yield just about anything. Added in 0.2.7.

attrNameProcessors (default: null): Allows the addition of attribute
name processing functions. Accepts an Array of functions with following
signature:
function (name){
    //do something with `name`
    return name
}
Added in 0.4.14

attrValueProcessors (default: null): Allows the addition of attribute
value processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.1

tagNameProcessors (default: null): Allows the addition of tag name
processing functions. Accepts an Array of functions with following
signature:
function (name){
  //do something with `name`
  return name
}
Added in 0.4.1

valueProcessors (default: null): Allows the addition of element value
processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.6

Options for the Builder class
These options are specified by new Builder({optionName: value}).
Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

rootName (default root or the root key name): root element name to be used in case
explicitRoot is false or to override the root element name.

renderOpts (default { 'pretty': true, 'indent': '  ', 'newline': '\n' }):
Rendering options for xmlbuilder-js.

pretty: prettify generated XML
indent: whitespace for indentation (only when pretty)
newline: newline char (only when pretty)



xmldec (default { 'version': '1.0', 'encoding': 'UTF-8', 'standalone': true }:
XML declaration attributes.


xmldec.version A version number string, e.g. 1.0

xmldec.encoding Encoding declaration, e.g. UTF-8

xmldec.standalone standalone document declaration: true or false



doctype (default null): optional DTD. Eg. {'ext': 'hello.dtd'}


headless (default: false): omit the XML header. Added in 0.4.3.

allowSurrogateChars (default: false): allows using characters from the Unicode
surrogate blocks.

cdata (default: false): wrap text nodes in <![CDATA[ ... ]]> instead of
escaping when necessary. Does not add <![CDATA[ ... ]]> if it is not required.
Added in 0.4.5.

renderOpts, xmldec,doctype and headless pass through to
xmlbuilder-js.
Updating to new version
Version 0.2 changed the default parsing settings, but version 0.1.14 introduced
the default settings for version 0.2, so these settings can be tried before the
migration.
var xml2js = require('xml2js');
var parser = new xml2js.Parser(xml2js.defaults["0.2"]);
To get the 0.1 defaults in version 0.2 you can just use
xml2js.defaults["0.1"] in the same place. This provides you with enough time
to migrate to the saner way of parsing in xml2js 0.2. We try to make the
migration as simple and gentle as possible, but some breakage cannot be
avoided.
So, what exactly did change and why? In 0.2 we changed some defaults to parse
the XML in a more universal and sane way. So we disabled normalize and trim
so xml2js does not cut out any text content. You can reenable this at will of
course. A more important change is that we return the root tag in the resulting
JavaScript structure via the explicitRoot setting, so you need to access the
first element. This is useful for anybody who wants to know what the root node
is and preserves more information. The last major change was to enable
explicitArray, so everytime it is possible that one might embed more than one
sub-tag into a tag, xml2js >= 0.2 returns an array even if the array just
includes one element. This is useful when dealing with APIs that return
variable amounts of subtags.
Running tests, development



The development requirements are handled by npm, you just need to install them.
We also have a number of unit tests, they can be run using npm test directly
from the project root. This runs zap to discover all the tests and execute
them.
If you like to contribute, keep in mind that xml2js is written in
CoffeeScript, so don't develop on the JavaScript files that are checked into
the repository for convenience reasons. Also, please write some unit test to
check your behaviour and if it is some user-facing thing, add some
documentation to this README, so people will know it exists. Thanks in advance!
Getting support
Please, if you have a problem with the library, first make sure you read this
README. If you read this far, thanks, you're good. Then, please make sure your
problem really is with xml2js. It is? Okay, then I'll look at it. Send me a
mail and we can talk. Please don't open issues, as I don't think that is the
proper forum for support problems. Some problems might as well really be bugs
in xml2js, if so I'll let you know to open an issue instead :)
But if you know you really found a bug, feel free to open an issue instead.\n\nxml2js0.6.2 • Public • Published 2 years ago ReadmeCode Beta2 Dependencies10,263 Dependents52 Versionsnode-xml2js
Ever had the urge to parse XML? And wanted to access the data in some sane,
easy way? Don't want to compile a C parser, for whatever reason? Then xml2js is
what you're looking for!
Description
Simple XML to JavaScript object converter. It supports bi-directional conversion.
Uses sax-js and
xmlbuilder-js.
Note: If you're looking for a full DOM parser, you probably want
JSDom.
Installation
Simplest way to install xml2js is to use npm, just npm install xml2js which will download xml2js and all dependencies.
xml2js is also available via Bower, just bower install xml2js which will download xml2js and all dependencies.
Usage
No extensive tutorials required because you are a smart developer! The task of
parsing XML should be an easy one, so let's make it so! Here's some examples.
Shoot-and-forget usage
You want to parse XML as simple and easy as possible? It's dangerous to go
alone, take this:
var parseString = require('xml2js').parseString;
var xml = "<root>Hello xml2js!</root>"
parseString(xml, function (err, result) {
    console.dir(result);
});
Can't get easier than this, right? This works starting with xml2js 0.2.3.
With CoffeeScript it looks like this:
{parseString} = require 'xml2js'
xml = "<root>Hello xml2js!</root>"
parseString xml, (err, result) ->
    console.dir result
If you need some special options, fear not, xml2js supports a number of
options (see below), you can specify these as second argument:
parseString(xml, {trim: true}, function (err, result) {
});
Simple as pie usage
That's right, if you have been using xml-simple or a home-grown
wrapper, this was added in 0.1.11 just for you:
var fs = require('fs'),
    xml2js = require('xml2js');

var parser = new xml2js.Parser();
fs.readFile(__dirname + '/foo.xml', function(err, data) {
    parser.parseString(data, function (err, result) {
        console.dir(result);
        console.log('Done');
    });
});
Look ma, no event listeners!
You can also use xml2js from
CoffeeScript, further reducing
the clutter:
fs = require 'fs',
xml2js = require 'xml2js'

parser = new xml2js.Parser()
fs.readFile __dirname + '/foo.xml', (err, data) ->
  parser.parseString data, (err, result) ->
    console.dir result
    console.log 'Done.'
But what happens if you forget the new keyword to create a new Parser? In
the middle of a nightly coding session, it might get lost, after all. Worry
not, we got you covered! Starting with 0.2.8 you can also leave it out, in
which case xml2js will helpfully add it for you, no bad surprises and
inexplicable bugs!
Promise usage
var xml2js = require('xml2js');
var xml = '<foo></foo>';

// With parser
var parser = new xml2js.Parser(/* options */);
parser.parseStringPromise(xml).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});

// Without parser
xml2js.parseStringPromise(xml /*, options */).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});
Parsing multiple files
If you want to parse multiple files, you have multiple possibilities:

You can create one xml2js.Parser per file. That's the recommended one
and is promised to always just work.
You can call reset() on your parser object.
You can hope everything goes well anyway. This behaviour is not
guaranteed work always, if ever. Use option #1 if possible. Thanks!

So you wanna some JSON?
Just wrap the result object in a call to JSON.stringify like this
JSON.stringify(result). You get a string containing the JSON representation
of the parsed object that you can feed to JSON-hungry consumers.
Displaying results
You might wonder why, using console.dir or console.log the output at some
level is only [Object]. Don't worry, this is not because xml2js got lazy.
That's because Node uses util.inspect to convert the object into strings and
that function stops after depth=2 which is a bit low for most XML.
To display the whole deal, you can use console.log(util.inspect(result, false, null)), which displays the whole result.
So much for that, but what if you use
eyes for nice colored output and it
truncates the output with …? Don't fear, there's also a solution for that,
you just need to increase the maxLength limit by creating a custom inspector
var inspect = require('eyes').inspector({maxLength: false}) and then you can
easily inspect(result).
XML builder usage
Since 0.4.0, objects can be also be used to build XML:
var xml2js = require('xml2js');

var obj = {name: "Super", Surname: "Man", age: 23};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root>
  <name>Super</name>
  <Surname>Man</Surname>
  <age>23</age>
</root>
At the moment, a one to one bi-directional conversion is guaranteed only for
default configuration, except for attrkey, charkey and explicitArray options
you can redefine to your taste. Writing CDATA is supported via setting the cdata
option to true.
To specify attributes:
var xml2js = require('xml2js');

var obj = {root: {$: {id: "my id"}, _: "my inner text"}};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root id="my id">my inner text</root>
Adding xmlns attributes
You can generate XML that declares XML namespace prefix / URI pairs with xmlns attributes.
Example declaring a default namespace on the root element:
let obj = { 
  Foo: {
    $: {
      "xmlns": "http://foo.com"
    }   
  }
};  
Result of buildObject(obj):
<Foo xmlns="http://foo.com"/>
Example declaring non-default namespaces on non-root elements:
let obj = {
  'foo:Foo': {
    $: {
      'xmlns:foo': 'http://foo.com'
    },
    'bar:Bar': {
      $: {
        'xmlns:bar': 'http://bar.com'
      }
    }
  }
}
Result of buildObject(obj):
<foo:Foo xmlns:foo="http://foo.com">
  <bar:Bar xmlns:bar="http://bar.com"/>
</foo:Foo>
Processing attribute, tag names and values
Since 0.4.1 you can optionally provide the parser with attribute name and tag name processors as well as element value processors (Since 0.4.14, you can also optionally provide the parser with attribute value processors):
function nameToUpperCase(name){
    return name.toUpperCase();
}

//transform all attribute and tag names and values to uppercase
parseString(xml, {
  tagNameProcessors: [nameToUpperCase],
  attrNameProcessors: [nameToUpperCase],
  valueProcessors: [nameToUpperCase],
  attrValueProcessors: [nameToUpperCase]},
  function (err, result) {
    // processed data
});
The tagNameProcessors and attrNameProcessors options
accept an Array of functions with the following signature:
function (name){
  //do something with `name`
  return name
}
The attrValueProcessors and valueProcessors options
accept an Array of functions with the following signature:
function (value, name) {
  //`name` will be the node name or attribute name
  //do something with `value`, (optionally) dependent on the node/attr name
  return value
}
Some processors are provided out-of-the-box and can be found in lib/processors.js:


normalize: transforms the name to lowercase.
(Automatically used when options.normalize is set to true)


firstCharLowerCase: transforms the first character to lower case.
E.g. 'MyTagName' becomes 'myTagName'


stripPrefix: strips the xml namespace prefix. E.g <foo:Bar/> will become 'Bar'.
(N.B.: the xmlns prefix is NOT stripped.)


parseNumbers: parses integer-like strings as integers and float-like strings as floats
E.g. "0" becomes 0 and "15.56" becomes 15.56


parseBooleans: parses boolean-like strings to booleans
E.g. "true" becomes true and "False" becomes false


Options
Apart from the default settings, there are a number of options that can be
specified for the parser. Options are specified by new Parser({optionName: value}). Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

explicitCharkey (default: false) Determines whether or not to use
a charkey prefix for elements with no attributes.

trim (default: false): Trim the whitespace at the beginning and end of
text nodes.

normalizeTags (default: false): Normalize all tag names to lowercase.

normalize (default: false): Trim whitespaces inside text nodes.

explicitRoot (default: true): Set this if you want to get the root
node in the resulting object.

emptyTag (default: ''): what will the value of empty nodes be. In case
you want to use an empty object as a default value, it is better to provide a factory
function () => ({}) instead. Without this function a plain object would
become a shared reference across all occurrences with unwanted behavior.

explicitArray (default: true): Always put child nodes in an array if
true; otherwise an array is created only if there is more than one.

ignoreAttrs (default: false): Ignore all XML attributes and only create
text nodes.

mergeAttrs (default: false): Merge attributes and child elements as
properties of the parent, instead of keying attributes off a child
attribute object. This option is ignored if ignoreAttrs is true.

validator (default null): You can specify a callable that validates
the resulting structure somehow, however you want. See unit tests
for an example.

xmlns (default false): Give each element a field usually called '$ns'
(the first character is the same as attrkey) that contains its local name
and namespace URI.

explicitChildren (default false): Put child elements to separate
property. Doesn't work with mergeAttrs = true. If element has no children
then "children" won't be created. Added in 0.2.5.

childkey (default $$): Prefix that is used to access child elements if
explicitChildren is set to true. Added in 0.2.5.

preserveChildrenOrder (default false): Modifies the behavior of
explicitChildren so that the value of the "children" property becomes an
ordered array. When this is true, every node will also get a #name field
whose value will correspond to the XML nodeName, so that you may iterate
the "children" array and still be able to determine node names. The named
(and potentially unordered) properties are also retained in this
configuration at the same level as the ordered "children" array. Added in
0.4.9.

charsAsChildren (default false): Determines whether chars should be
considered children if explicitChildren is on. Added in 0.2.5.

includeWhiteChars (default false): Determines whether whitespace-only
text nodes should be included. Added in 0.4.17.

async (default false): Should the callbacks be async? This might be
an incompatible change if your code depends on sync execution of callbacks.
Future versions of xml2js might change this default, so the recommendation
is to not depend on sync execution anyway. Added in 0.2.6.

strict (default true): Set sax-js to strict or non-strict parsing mode.
Defaults to true which is highly recommended, since parsing HTML which
is not well-formed XML might yield just about anything. Added in 0.2.7.

attrNameProcessors (default: null): Allows the addition of attribute
name processing functions. Accepts an Array of functions with following
signature:
function (name){
    //do something with `name`
    return name
}
Added in 0.4.14

attrValueProcessors (default: null): Allows the addition of attribute
value processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.1

tagNameProcessors (default: null): Allows the addition of tag name
processing functions. Accepts an Array of functions with following
signature:
function (name){
  //do something with `name`
  return name
}
Added in 0.4.1

valueProcessors (default: null): Allows the addition of element value
processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.6

Options for the Builder class
These options are specified by new Builder({optionName: value}).
Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

rootName (default root or the root key name): root element name to be used in case
explicitRoot is false or to override the root element name.

renderOpts (default { 'pretty': true, 'indent': '  ', 'newline': '\n' }):
Rendering options for xmlbuilder-js.

pretty: prettify generated XML
indent: whitespace for indentation (only when pretty)
newline: newline char (only when pretty)



xmldec (default { 'version': '1.0', 'encoding': 'UTF-8', 'standalone': true }:
XML declaration attributes.


xmldec.version A version number string, e.g. 1.0

xmldec.encoding Encoding declaration, e.g. UTF-8

xmldec.standalone standalone document declaration: true or false



doctype (default null): optional DTD. Eg. {'ext': 'hello.dtd'}


headless (default: false): omit the XML header. Added in 0.4.3.

allowSurrogateChars (default: false): allows using characters from the Unicode
surrogate blocks.

cdata (default: false): wrap text nodes in <![CDATA[ ... ]]> instead of
escaping when necessary. Does not add <![CDATA[ ... ]]> if it is not required.
Added in 0.4.5.

renderOpts, xmldec,doctype and headless pass through to
xmlbuilder-js.
Updating to new version
Version 0.2 changed the default parsing settings, but version 0.1.14 introduced
the default settings for version 0.2, so these settings can be tried before the
migration.
var xml2js = require('xml2js');
var parser = new xml2js.Parser(xml2js.defaults["0.2"]);
To get the 0.1 defaults in version 0.2 you can just use
xml2js.defaults["0.1"] in the same place. This provides you with enough time
to migrate to the saner way of parsing in xml2js 0.2. We try to make the
migration as simple and gentle as possible, but some breakage cannot be
avoided.
So, what exactly did change and why? In 0.2 we changed some defaults to parse
the XML in a more universal and sane way. So we disabled normalize and trim
so xml2js does not cut out any text content. You can reenable this at will of
course. A more important change is that we return the root tag in the resulting
JavaScript structure via the explicitRoot setting, so you need to access the
first element. This is useful for anybody who wants to know what the root node
is and preserves more information. The last major change was to enable
explicitArray, so everytime it is possible that one might embed more than one
sub-tag into a tag, xml2js >= 0.2 returns an array even if the array just
includes one element. This is useful when dealing with APIs that return
variable amounts of subtags.
Running tests, development



The development requirements are handled by npm, you just need to install them.
We also have a number of unit tests, they can be run using npm test directly
from the project root. This runs zap to discover all the tests and execute
them.
If you like to contribute, keep in mind that xml2js is written in
CoffeeScript, so don't develop on the JavaScript files that are checked into
the repository for convenience reasons. Also, please write some unit test to
check your behaviour and if it is some user-facing thing, add some
documentation to this README, so people will know it exists. Thanks in advance!
Getting support
Please, if you have a problem with the library, first make sure you read this
README. If you read this far, thanks, you're good. Then, please make sure your
problem really is with xml2js. It is? Okay, then I'll look at it. Send me a
mail and we can talk. Please don't open issues, as I don't think that is the
proper forum for support problems. Some problems might as well really be bugs
in xml2js, if so I'll let you know to open an issue instead :)
But if you know you really found a bug, feel free to open an issue instead.
Dependencies (2)saxxmlbuilderDev Dependencies (6)coffeescriptcoverallsdiffdocconyczapPackage SidebarInstallnpm i xml2jsRepositorygithub.com/Leonidas-from-XIV/node-xml2jsHomepagegithub.com/Leonidas-from-XIV/node-xml2jsWeekly Downloads22,667,333Version0.6.2LicenseMITUnpacked Size3.44 MBTotal Files10Last publish2 years agoCollaboratorsTry on RunKitReport malware\n\nxml2js0.6.2 • Public • Published 2 years ago ReadmeCode Beta2 Dependencies10,263 Dependents52 Versionsnode-xml2js
Ever had the urge to parse XML? And wanted to access the data in some sane,
easy way? Don't want to compile a C parser, for whatever reason? Then xml2js is
what you're looking for!
Description
Simple XML to JavaScript object converter. It supports bi-directional conversion.
Uses sax-js and
xmlbuilder-js.
Note: If you're looking for a full DOM parser, you probably want
JSDom.
Installation
Simplest way to install xml2js is to use npm, just npm install xml2js which will download xml2js and all dependencies.
xml2js is also available via Bower, just bower install xml2js which will download xml2js and all dependencies.
Usage
No extensive tutorials required because you are a smart developer! The task of
parsing XML should be an easy one, so let's make it so! Here's some examples.
Shoot-and-forget usage
You want to parse XML as simple and easy as possible? It's dangerous to go
alone, take this:
var parseString = require('xml2js').parseString;
var xml = "<root>Hello xml2js!</root>"
parseString(xml, function (err, result) {
    console.dir(result);
});
Can't get easier than this, right? This works starting with xml2js 0.2.3.
With CoffeeScript it looks like this:
{parseString} = require 'xml2js'
xml = "<root>Hello xml2js!</root>"
parseString xml, (err, result) ->
    console.dir result
If you need some special options, fear not, xml2js supports a number of
options (see below), you can specify these as second argument:
parseString(xml, {trim: true}, function (err, result) {
});
Simple as pie usage
That's right, if you have been using xml-simple or a home-grown
wrapper, this was added in 0.1.11 just for you:
var fs = require('fs'),
    xml2js = require('xml2js');

var parser = new xml2js.Parser();
fs.readFile(__dirname + '/foo.xml', function(err, data) {
    parser.parseString(data, function (err, result) {
        console.dir(result);
        console.log('Done');
    });
});
Look ma, no event listeners!
You can also use xml2js from
CoffeeScript, further reducing
the clutter:
fs = require 'fs',
xml2js = require 'xml2js'

parser = new xml2js.Parser()
fs.readFile __dirname + '/foo.xml', (err, data) ->
  parser.parseString data, (err, result) ->
    console.dir result
    console.log 'Done.'
But what happens if you forget the new keyword to create a new Parser? In
the middle of a nightly coding session, it might get lost, after all. Worry
not, we got you covered! Starting with 0.2.8 you can also leave it out, in
which case xml2js will helpfully add it for you, no bad surprises and
inexplicable bugs!
Promise usage
var xml2js = require('xml2js');
var xml = '<foo></foo>';

// With parser
var parser = new xml2js.Parser(/* options */);
parser.parseStringPromise(xml).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});

// Without parser
xml2js.parseStringPromise(xml /*, options */).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});
Parsing multiple files
If you want to parse multiple files, you have multiple possibilities:

You can create one xml2js.Parser per file. That's the recommended one
and is promised to always just work.
You can call reset() on your parser object.
You can hope everything goes well anyway. This behaviour is not
guaranteed work always, if ever. Use option #1 if possible. Thanks!

So you wanna some JSON?
Just wrap the result object in a call to JSON.stringify like this
JSON.stringify(result). You get a string containing the JSON representation
of the parsed object that you can feed to JSON-hungry consumers.
Displaying results
You might wonder why, using console.dir or console.log the output at some
level is only [Object]. Don't worry, this is not because xml2js got lazy.
That's because Node uses util.inspect to convert the object into strings and
that function stops after depth=2 which is a bit low for most XML.
To display the whole deal, you can use console.log(util.inspect(result, false, null)), which displays the whole result.
So much for that, but what if you use
eyes for nice colored output and it
truncates the output with …? Don't fear, there's also a solution for that,
you just need to increase the maxLength limit by creating a custom inspector
var inspect = require('eyes').inspector({maxLength: false}) and then you can
easily inspect(result).
XML builder usage
Since 0.4.0, objects can be also be used to build XML:
var xml2js = require('xml2js');

var obj = {name: "Super", Surname: "Man", age: 23};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root>
  <name>Super</name>
  <Surname>Man</Surname>
  <age>23</age>
</root>
At the moment, a one to one bi-directional conversion is guaranteed only for
default configuration, except for attrkey, charkey and explicitArray options
you can redefine to your taste. Writing CDATA is supported via setting the cdata
option to true.
To specify attributes:
var xml2js = require('xml2js');

var obj = {root: {$: {id: "my id"}, _: "my inner text"}};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root id="my id">my inner text</root>
Adding xmlns attributes
You can generate XML that declares XML namespace prefix / URI pairs with xmlns attributes.
Example declaring a default namespace on the root element:
let obj = { 
  Foo: {
    $: {
      "xmlns": "http://foo.com"
    }   
  }
};  
Result of buildObject(obj):
<Foo xmlns="http://foo.com"/>
Example declaring non-default namespaces on non-root elements:
let obj = {
  'foo:Foo': {
    $: {
      'xmlns:foo': 'http://foo.com'
    },
    'bar:Bar': {
      $: {
        'xmlns:bar': 'http://bar.com'
      }
    }
  }
}
Result of buildObject(obj):
<foo:Foo xmlns:foo="http://foo.com">
  <bar:Bar xmlns:bar="http://bar.com"/>
</foo:Foo>
Processing attribute, tag names and values
Since 0.4.1 you can optionally provide the parser with attribute name and tag name processors as well as element value processors (Since 0.4.14, you can also optionally provide the parser with attribute value processors):
function nameToUpperCase(name){
    return name.toUpperCase();
}

//transform all attribute and tag names and values to uppercase
parseString(xml, {
  tagNameProcessors: [nameToUpperCase],
  attrNameProcessors: [nameToUpperCase],
  valueProcessors: [nameToUpperCase],
  attrValueProcessors: [nameToUpperCase]},
  function (err, result) {
    // processed data
});
The tagNameProcessors and attrNameProcessors options
accept an Array of functions with the following signature:
function (name){
  //do something with `name`
  return name
}
The attrValueProcessors and valueProcessors options
accept an Array of functions with the following signature:
function (value, name) {
  //`name` will be the node name or attribute name
  //do something with `value`, (optionally) dependent on the node/attr name
  return value
}
Some processors are provided out-of-the-box and can be found in lib/processors.js:


normalize: transforms the name to lowercase.
(Automatically used when options.normalize is set to true)


firstCharLowerCase: transforms the first character to lower case.
E.g. 'MyTagName' becomes 'myTagName'


stripPrefix: strips the xml namespace prefix. E.g <foo:Bar/> will become 'Bar'.
(N.B.: the xmlns prefix is NOT stripped.)


parseNumbers: parses integer-like strings as integers and float-like strings as floats
E.g. "0" becomes 0 and "15.56" becomes 15.56


parseBooleans: parses boolean-like strings to booleans
E.g. "true" becomes true and "False" becomes false


Options
Apart from the default settings, there are a number of options that can be
specified for the parser. Options are specified by new Parser({optionName: value}). Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

explicitCharkey (default: false) Determines whether or not to use
a charkey prefix for elements with no attributes.

trim (default: false): Trim the whitespace at the beginning and end of
text nodes.

normalizeTags (default: false): Normalize all tag names to lowercase.

normalize (default: false): Trim whitespaces inside text nodes.

explicitRoot (default: true): Set this if you want to get the root
node in the resulting object.

emptyTag (default: ''): what will the value of empty nodes be. In case
you want to use an empty object as a default value, it is better to provide a factory
function () => ({}) instead. Without this function a plain object would
become a shared reference across all occurrences with unwanted behavior.

explicitArray (default: true): Always put child nodes in an array if
true; otherwise an array is created only if there is more than one.

ignoreAttrs (default: false): Ignore all XML attributes and only create
text nodes.

mergeAttrs (default: false): Merge attributes and child elements as
properties of the parent, instead of keying attributes off a child
attribute object. This option is ignored if ignoreAttrs is true.

validator (default null): You can specify a callable that validates
the resulting structure somehow, however you want. See unit tests
for an example.

xmlns (default false): Give each element a field usually called '$ns'
(the first character is the same as attrkey) that contains its local name
and namespace URI.

explicitChildren (default false): Put child elements to separate
property. Doesn't work with mergeAttrs = true. If element has no children
then "children" won't be created. Added in 0.2.5.

childkey (default $$): Prefix that is used to access child elements if
explicitChildren is set to true. Added in 0.2.5.

preserveChildrenOrder (default false): Modifies the behavior of
explicitChildren so that the value of the "children" property becomes an
ordered array. When this is true, every node will also get a #name field
whose value will correspond to the XML nodeName, so that you may iterate
the "children" array and still be able to determine node names. The named
(and potentially unordered) properties are also retained in this
configuration at the same level as the ordered "children" array. Added in
0.4.9.

charsAsChildren (default false): Determines whether chars should be
considered children if explicitChildren is on. Added in 0.2.5.

includeWhiteChars (default false): Determines whether whitespace-only
text nodes should be included. Added in 0.4.17.

async (default false): Should the callbacks be async? This might be
an incompatible change if your code depends on sync execution of callbacks.
Future versions of xml2js might change this default, so the recommendation
is to not depend on sync execution anyway. Added in 0.2.6.

strict (default true): Set sax-js to strict or non-strict parsing mode.
Defaults to true which is highly recommended, since parsing HTML which
is not well-formed XML might yield just about anything. Added in 0.2.7.

attrNameProcessors (default: null): Allows the addition of attribute
name processing functions. Accepts an Array of functions with following
signature:
function (name){
    //do something with `name`
    return name
}
Added in 0.4.14

attrValueProcessors (default: null): Allows the addition of attribute
value processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.1

tagNameProcessors (default: null): Allows the addition of tag name
processing functions. Accepts an Array of functions with following
signature:
function (name){
  //do something with `name`
  return name
}
Added in 0.4.1

valueProcessors (default: null): Allows the addition of element value
processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.6

Options for the Builder class
These options are specified by new Builder({optionName: value}).
Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

rootName (default root or the root key name): root element name to be used in case
explicitRoot is false or to override the root element name.

renderOpts (default { 'pretty': true, 'indent': '  ', 'newline': '\n' }):
Rendering options for xmlbuilder-js.

pretty: prettify generated XML
indent: whitespace for indentation (only when pretty)
newline: newline char (only when pretty)



xmldec (default { 'version': '1.0', 'encoding': 'UTF-8', 'standalone': true }:
XML declaration attributes.


xmldec.version A version number string, e.g. 1.0

xmldec.encoding Encoding declaration, e.g. UTF-8

xmldec.standalone standalone document declaration: true or false



doctype (default null): optional DTD. Eg. {'ext': 'hello.dtd'}


headless (default: false): omit the XML header. Added in 0.4.3.

allowSurrogateChars (default: false): allows using characters from the Unicode
surrogate blocks.

cdata (default: false): wrap text nodes in <![CDATA[ ... ]]> instead of
escaping when necessary. Does not add <![CDATA[ ... ]]> if it is not required.
Added in 0.4.5.

renderOpts, xmldec,doctype and headless pass through to
xmlbuilder-js.
Updating to new version
Version 0.2 changed the default parsing settings, but version 0.1.14 introduced
the default settings for version 0.2, so these settings can be tried before the
migration.
var xml2js = require('xml2js');
var parser = new xml2js.Parser(xml2js.defaults["0.2"]);
To get the 0.1 defaults in version 0.2 you can just use
xml2js.defaults["0.1"] in the same place. This provides you with enough time
to migrate to the saner way of parsing in xml2js 0.2. We try to make the
migration as simple and gentle as possible, but some breakage cannot be
avoided.
So, what exactly did change and why? In 0.2 we changed some defaults to parse
the XML in a more universal and sane way. So we disabled normalize and trim
so xml2js does not cut out any text content. You can reenable this at will of
course. A more important change is that we return the root tag in the resulting
JavaScript structure via the explicitRoot setting, so you need to access the
first element. This is useful for anybody who wants to know what the root node
is and preserves more information. The last major change was to enable
explicitArray, so everytime it is possible that one might embed more than one
sub-tag into a tag, xml2js >= 0.2 returns an array even if the array just
includes one element. This is useful when dealing with APIs that return
variable amounts of subtags.
Running tests, development



The development requirements are handled by npm, you just need to install them.
We also have a number of unit tests, they can be run using npm test directly
from the project root. This runs zap to discover all the tests and execute
them.
If you like to contribute, keep in mind that xml2js is written in
CoffeeScript, so don't develop on the JavaScript files that are checked into
the repository for convenience reasons. Also, please write some unit test to
check your behaviour and if it is some user-facing thing, add some
documentation to this README, so people will know it exists. Thanks in advance!
Getting support
Please, if you have a problem with the library, first make sure you read this
README. If you read this far, thanks, you're good. Then, please make sure your
problem really is with xml2js. It is? Okay, then I'll look at it. Send me a
mail and we can talk. Please don't open issues, as I don't think that is the
proper forum for support problems. Some problems might as well really be bugs
in xml2js, if so I'll let you know to open an issue instead :)
But if you know you really found a bug, feel free to open an issue instead.
Dependencies (2)saxxmlbuilderDev Dependencies (6)coffeescriptcoverallsdiffdocconyczapPackage SidebarInstallnpm i xml2jsRepositorygithub.com/Leonidas-from-XIV/node-xml2jsHomepagegithub.com/Leonidas-from-XIV/node-xml2jsWeekly Downloads22,667,333Version0.6.2LicenseMITUnpacked Size3.44 MBTotal Files10Last publish2 years agoCollaboratorsTry on RunKitReport malware\n\n\n\nnode-xml2js
Ever had the urge to parse XML? And wanted to access the data in some sane,
easy way? Don't want to compile a C parser, for whatever reason? Then xml2js is
what you're looking for!
Description
Simple XML to JavaScript object converter. It supports bi-directional conversion.
Uses sax-js and
xmlbuilder-js.
Note: If you're looking for a full DOM parser, you probably want
JSDom.
Installation
Simplest way to install xml2js is to use npm, just npm install xml2js which will download xml2js and all dependencies.
xml2js is also available via Bower, just bower install xml2js which will download xml2js and all dependencies.
Usage
No extensive tutorials required because you are a smart developer! The task of
parsing XML should be an easy one, so let's make it so! Here's some examples.
Shoot-and-forget usage
You want to parse XML as simple and easy as possible? It's dangerous to go
alone, take this:
var parseString = require('xml2js').parseString;
var xml = "<root>Hello xml2js!</root>"
parseString(xml, function (err, result) {
    console.dir(result);
});
Can't get easier than this, right? This works starting with xml2js 0.2.3.
With CoffeeScript it looks like this:
{parseString} = require 'xml2js'
xml = "<root>Hello xml2js!</root>"
parseString xml, (err, result) ->
    console.dir result
If you need some special options, fear not, xml2js supports a number of
options (see below), you can specify these as second argument:
parseString(xml, {trim: true}, function (err, result) {
});
Simple as pie usage
That's right, if you have been using xml-simple or a home-grown
wrapper, this was added in 0.1.11 just for you:
var fs = require('fs'),
    xml2js = require('xml2js');

var parser = new xml2js.Parser();
fs.readFile(__dirname + '/foo.xml', function(err, data) {
    parser.parseString(data, function (err, result) {
        console.dir(result);
        console.log('Done');
    });
});
Look ma, no event listeners!
You can also use xml2js from
CoffeeScript, further reducing
the clutter:
fs = require 'fs',
xml2js = require 'xml2js'

parser = new xml2js.Parser()
fs.readFile __dirname + '/foo.xml', (err, data) ->
  parser.parseString data, (err, result) ->
    console.dir result
    console.log 'Done.'
But what happens if you forget the new keyword to create a new Parser? In
the middle of a nightly coding session, it might get lost, after all. Worry
not, we got you covered! Starting with 0.2.8 you can also leave it out, in
which case xml2js will helpfully add it for you, no bad surprises and
inexplicable bugs!
Promise usage
var xml2js = require('xml2js');
var xml = '<foo></foo>';

// With parser
var parser = new xml2js.Parser(/* options */);
parser.parseStringPromise(xml).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});

// Without parser
xml2js.parseStringPromise(xml /*, options */).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});
Parsing multiple files
If you want to parse multiple files, you have multiple possibilities:

You can create one xml2js.Parser per file. That's the recommended one
and is promised to always just work.
You can call reset() on your parser object.
You can hope everything goes well anyway. This behaviour is not
guaranteed work always, if ever. Use option #1 if possible. Thanks!

So you wanna some JSON?
Just wrap the result object in a call to JSON.stringify like this
JSON.stringify(result). You get a string containing the JSON representation
of the parsed object that you can feed to JSON-hungry consumers.
Displaying results
You might wonder why, using console.dir or console.log the output at some
level is only [Object]. Don't worry, this is not because xml2js got lazy.
That's because Node uses util.inspect to convert the object into strings and
that function stops after depth=2 which is a bit low for most XML.
To display the whole deal, you can use console.log(util.inspect(result, false, null)), which displays the whole result.
So much for that, but what if you use
eyes for nice colored output and it
truncates the output with …? Don't fear, there's also a solution for that,
you just need to increase the maxLength limit by creating a custom inspector
var inspect = require('eyes').inspector({maxLength: false}) and then you can
easily inspect(result).
XML builder usage
Since 0.4.0, objects can be also be used to build XML:
var xml2js = require('xml2js');

var obj = {name: "Super", Surname: "Man", age: 23};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root>
  <name>Super</name>
  <Surname>Man</Surname>
  <age>23</age>
</root>
At the moment, a one to one bi-directional conversion is guaranteed only for
default configuration, except for attrkey, charkey and explicitArray options
you can redefine to your taste. Writing CDATA is supported via setting the cdata
option to true.
To specify attributes:
var xml2js = require('xml2js');

var obj = {root: {$: {id: "my id"}, _: "my inner text"}};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root id="my id">my inner text</root>
Adding xmlns attributes
You can generate XML that declares XML namespace prefix / URI pairs with xmlns attributes.
Example declaring a default namespace on the root element:
let obj = { 
  Foo: {
    $: {
      "xmlns": "http://foo.com"
    }   
  }
};  
Result of buildObject(obj):
<Foo xmlns="http://foo.com"/>
Example declaring non-default namespaces on non-root elements:
let obj = {
  'foo:Foo': {
    $: {
      'xmlns:foo': 'http://foo.com'
    },
    'bar:Bar': {
      $: {
        'xmlns:bar': 'http://bar.com'
      }
    }
  }
}
Result of buildObject(obj):
<foo:Foo xmlns:foo="http://foo.com">
  <bar:Bar xmlns:bar="http://bar.com"/>
</foo:Foo>
Processing attribute, tag names and values
Since 0.4.1 you can optionally provide the parser with attribute name and tag name processors as well as element value processors (Since 0.4.14, you can also optionally provide the parser with attribute value processors):
function nameToUpperCase(name){
    return name.toUpperCase();
}

//transform all attribute and tag names and values to uppercase
parseString(xml, {
  tagNameProcessors: [nameToUpperCase],
  attrNameProcessors: [nameToUpperCase],
  valueProcessors: [nameToUpperCase],
  attrValueProcessors: [nameToUpperCase]},
  function (err, result) {
    // processed data
});
The tagNameProcessors and attrNameProcessors options
accept an Array of functions with the following signature:
function (name){
  //do something with `name`
  return name
}
The attrValueProcessors and valueProcessors options
accept an Array of functions with the following signature:
function (value, name) {
  //`name` will be the node name or attribute name
  //do something with `value`, (optionally) dependent on the node/attr name
  return value
}
Some processors are provided out-of-the-box and can be found in lib/processors.js:


normalize: transforms the name to lowercase.
(Automatically used when options.normalize is set to true)


firstCharLowerCase: transforms the first character to lower case.
E.g. 'MyTagName' becomes 'myTagName'


stripPrefix: strips the xml namespace prefix. E.g <foo:Bar/> will become 'Bar'.
(N.B.: the xmlns prefix is NOT stripped.)


parseNumbers: parses integer-like strings as integers and float-like strings as floats
E.g. "0" becomes 0 and "15.56" becomes 15.56


parseBooleans: parses boolean-like strings to booleans
E.g. "true" becomes true and "False" becomes false


Options
Apart from the default settings, there are a number of options that can be
specified for the parser. Options are specified by new Parser({optionName: value}). Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

explicitCharkey (default: false) Determines whether or not to use
a charkey prefix for elements with no attributes.

trim (default: false): Trim the whitespace at the beginning and end of
text nodes.

normalizeTags (default: false): Normalize all tag names to lowercase.

normalize (default: false): Trim whitespaces inside text nodes.

explicitRoot (default: true): Set this if you want to get the root
node in the resulting object.

emptyTag (default: ''): what will the value of empty nodes be. In case
you want to use an empty object as a default value, it is better to provide a factory
function () => ({}) instead. Without this function a plain object would
become a shared reference across all occurrences with unwanted behavior.

explicitArray (default: true): Always put child nodes in an array if
true; otherwise an array is created only if there is more than one.

ignoreAttrs (default: false): Ignore all XML attributes and only create
text nodes.

mergeAttrs (default: false): Merge attributes and child elements as
properties of the parent, instead of keying attributes off a child
attribute object. This option is ignored if ignoreAttrs is true.

validator (default null): You can specify a callable that validates
the resulting structure somehow, however you want. See unit tests
for an example.

xmlns (default false): Give each element a field usually called '$ns'
(the first character is the same as attrkey) that contains its local name
and namespace URI.

explicitChildren (default false): Put child elements to separate
property. Doesn't work with mergeAttrs = true. If element has no children
then "children" won't be created. Added in 0.2.5.

childkey (default $$): Prefix that is used to access child elements if
explicitChildren is set to true. Added in 0.2.5.

preserveChildrenOrder (default false): Modifies the behavior of
explicitChildren so that the value of the "children" property becomes an
ordered array. When this is true, every node will also get a #name field
whose value will correspond to the XML nodeName, so that you may iterate
the "children" array and still be able to determine node names. The named
(and potentially unordered) properties are also retained in this
configuration at the same level as the ordered "children" array. Added in
0.4.9.

charsAsChildren (default false): Determines whether chars should be
considered children if explicitChildren is on. Added in 0.2.5.

includeWhiteChars (default false): Determines whether whitespace-only
text nodes should be included. Added in 0.4.17.

async (default false): Should the callbacks be async? This might be
an incompatible change if your code depends on sync execution of callbacks.
Future versions of xml2js might change this default, so the recommendation
is to not depend on sync execution anyway. Added in 0.2.6.

strict (default true): Set sax-js to strict or non-strict parsing mode.
Defaults to true which is highly recommended, since parsing HTML which
is not well-formed XML might yield just about anything. Added in 0.2.7.

attrNameProcessors (default: null): Allows the addition of attribute
name processing functions. Accepts an Array of functions with following
signature:
function (name){
    //do something with `name`
    return name
}
Added in 0.4.14

attrValueProcessors (default: null): Allows the addition of attribute
value processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.1

tagNameProcessors (default: null): Allows the addition of tag name
processing functions. Accepts an Array of functions with following
signature:
function (name){
  //do something with `name`
  return name
}
Added in 0.4.1

valueProcessors (default: null): Allows the addition of element value
processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.6

Options for the Builder class
These options are specified by new Builder({optionName: value}).
Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

rootName (default root or the root key name): root element name to be used in case
explicitRoot is false or to override the root element name.

renderOpts (default { 'pretty': true, 'indent': '  ', 'newline': '\n' }):
Rendering options for xmlbuilder-js.

pretty: prettify generated XML
indent: whitespace for indentation (only when pretty)
newline: newline char (only when pretty)



xmldec (default { 'version': '1.0', 'encoding': 'UTF-8', 'standalone': true }:
XML declaration attributes.


xmldec.version A version number string, e.g. 1.0

xmldec.encoding Encoding declaration, e.g. UTF-8

xmldec.standalone standalone document declaration: true or false



doctype (default null): optional DTD. Eg. {'ext': 'hello.dtd'}


headless (default: false): omit the XML header. Added in 0.4.3.

allowSurrogateChars (default: false): allows using characters from the Unicode
surrogate blocks.

cdata (default: false): wrap text nodes in <![CDATA[ ... ]]> instead of
escaping when necessary. Does not add <![CDATA[ ... ]]> if it is not required.
Added in 0.4.5.

renderOpts, xmldec,doctype and headless pass through to
xmlbuilder-js.
Updating to new version
Version 0.2 changed the default parsing settings, but version 0.1.14 introduced
the default settings for version 0.2, so these settings can be tried before the
migration.
var xml2js = require('xml2js');
var parser = new xml2js.Parser(xml2js.defaults["0.2"]);
To get the 0.1 defaults in version 0.2 you can just use
xml2js.defaults["0.1"] in the same place. This provides you with enough time
to migrate to the saner way of parsing in xml2js 0.2. We try to make the
migration as simple and gentle as possible, but some breakage cannot be
avoided.
So, what exactly did change and why? In 0.2 we changed some defaults to parse
the XML in a more universal and sane way. So we disabled normalize and trim
so xml2js does not cut out any text content. You can reenable this at will of
course. A more important change is that we return the root tag in the resulting
JavaScript structure via the explicitRoot setting, so you need to access the
first element. This is useful for anybody who wants to know what the root node
is and preserves more information. The last major change was to enable
explicitArray, so everytime it is possible that one might embed more than one
sub-tag into a tag, xml2js >= 0.2 returns an array even if the array just
includes one element. This is useful when dealing with APIs that return
variable amounts of subtags.
Running tests, development



The development requirements are handled by npm, you just need to install them.
We also have a number of unit tests, they can be run using npm test directly
from the project root. This runs zap to discover all the tests and execute
them.
If you like to contribute, keep in mind that xml2js is written in
CoffeeScript, so don't develop on the JavaScript files that are checked into
the repository for convenience reasons. Also, please write some unit test to
check your behaviour and if it is some user-facing thing, add some
documentation to this README, so people will know it exists. Thanks in advance!
Getting support
Please, if you have a problem with the library, first make sure you read this
README. If you read this far, thanks, you're good. Then, please make sure your
problem really is with xml2js. It is? Okay, then I'll look at it. Send me a
mail and we can talk. Please don't open issues, as I don't think that is the
proper forum for support problems. Some problems might as well really be bugs
in xml2js, if so I'll let you know to open an issue instead :)
But if you know you really found a bug, feel free to open an issue instead.\n\nxml2js0.6.2 • Public • Published 2 years ago ReadmeCode Beta2 Dependencies10,263 Dependents52 Versionsnode-xml2js
Ever had the urge to parse XML? And wanted to access the data in some sane,
easy way? Don't want to compile a C parser, for whatever reason? Then xml2js is
what you're looking for!
Description
Simple XML to JavaScript object converter. It supports bi-directional conversion.
Uses sax-js and
xmlbuilder-js.
Note: If you're looking for a full DOM parser, you probably want
JSDom.
Installation
Simplest way to install xml2js is to use npm, just npm install xml2js which will download xml2js and all dependencies.
xml2js is also available via Bower, just bower install xml2js which will download xml2js and all dependencies.
Usage
No extensive tutorials required because you are a smart developer! The task of
parsing XML should be an easy one, so let's make it so! Here's some examples.
Shoot-and-forget usage
You want to parse XML as simple and easy as possible? It's dangerous to go
alone, take this:
var parseString = require('xml2js').parseString;
var xml = "<root>Hello xml2js!</root>"
parseString(xml, function (err, result) {
    console.dir(result);
});
Can't get easier than this, right? This works starting with xml2js 0.2.3.
With CoffeeScript it looks like this:
{parseString} = require 'xml2js'
xml = "<root>Hello xml2js!</root>"
parseString xml, (err, result) ->
    console.dir result
If you need some special options, fear not, xml2js supports a number of
options (see below), you can specify these as second argument:
parseString(xml, {trim: true}, function (err, result) {
});
Simple as pie usage
That's right, if you have been using xml-simple or a home-grown
wrapper, this was added in 0.1.11 just for you:
var fs = require('fs'),
    xml2js = require('xml2js');

var parser = new xml2js.Parser();
fs.readFile(__dirname + '/foo.xml', function(err, data) {
    parser.parseString(data, function (err, result) {
        console.dir(result);
        console.log('Done');
    });
});
Look ma, no event listeners!
You can also use xml2js from
CoffeeScript, further reducing
the clutter:
fs = require 'fs',
xml2js = require 'xml2js'

parser = new xml2js.Parser()
fs.readFile __dirname + '/foo.xml', (err, data) ->
  parser.parseString data, (err, result) ->
    console.dir result
    console.log 'Done.'
But what happens if you forget the new keyword to create a new Parser? In
the middle of a nightly coding session, it might get lost, after all. Worry
not, we got you covered! Starting with 0.2.8 you can also leave it out, in
which case xml2js will helpfully add it for you, no bad surprises and
inexplicable bugs!
Promise usage
var xml2js = require('xml2js');
var xml = '<foo></foo>';

// With parser
var parser = new xml2js.Parser(/* options */);
parser.parseStringPromise(xml).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});

// Without parser
xml2js.parseStringPromise(xml /*, options */).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});
Parsing multiple files
If you want to parse multiple files, you have multiple possibilities:

You can create one xml2js.Parser per file. That's the recommended one
and is promised to always just work.
You can call reset() on your parser object.
You can hope everything goes well anyway. This behaviour is not
guaranteed work always, if ever. Use option #1 if possible. Thanks!

So you wanna some JSON?
Just wrap the result object in a call to JSON.stringify like this
JSON.stringify(result). You get a string containing the JSON representation
of the parsed object that you can feed to JSON-hungry consumers.
Displaying results
You might wonder why, using console.dir or console.log the output at some
level is only [Object]. Don't worry, this is not because xml2js got lazy.
That's because Node uses util.inspect to convert the object into strings and
that function stops after depth=2 which is a bit low for most XML.
To display the whole deal, you can use console.log(util.inspect(result, false, null)), which displays the whole result.
So much for that, but what if you use
eyes for nice colored output and it
truncates the output with …? Don't fear, there's also a solution for that,
you just need to increase the maxLength limit by creating a custom inspector
var inspect = require('eyes').inspector({maxLength: false}) and then you can
easily inspect(result).
XML builder usage
Since 0.4.0, objects can be also be used to build XML:
var xml2js = require('xml2js');

var obj = {name: "Super", Surname: "Man", age: 23};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root>
  <name>Super</name>
  <Surname>Man</Surname>
  <age>23</age>
</root>
At the moment, a one to one bi-directional conversion is guaranteed only for
default configuration, except for attrkey, charkey and explicitArray options
you can redefine to your taste. Writing CDATA is supported via setting the cdata
option to true.
To specify attributes:
var xml2js = require('xml2js');

var obj = {root: {$: {id: "my id"}, _: "my inner text"}};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root id="my id">my inner text</root>
Adding xmlns attributes
You can generate XML that declares XML namespace prefix / URI pairs with xmlns attributes.
Example declaring a default namespace on the root element:
let obj = { 
  Foo: {
    $: {
      "xmlns": "http://foo.com"
    }   
  }
};  
Result of buildObject(obj):
<Foo xmlns="http://foo.com"/>
Example declaring non-default namespaces on non-root elements:
let obj = {
  'foo:Foo': {
    $: {
      'xmlns:foo': 'http://foo.com'
    },
    'bar:Bar': {
      $: {
        'xmlns:bar': 'http://bar.com'
      }
    }
  }
}
Result of buildObject(obj):
<foo:Foo xmlns:foo="http://foo.com">
  <bar:Bar xmlns:bar="http://bar.com"/>
</foo:Foo>
Processing attribute, tag names and values
Since 0.4.1 you can optionally provide the parser with attribute name and tag name processors as well as element value processors (Since 0.4.14, you can also optionally provide the parser with attribute value processors):
function nameToUpperCase(name){
    return name.toUpperCase();
}

//transform all attribute and tag names and values to uppercase
parseString(xml, {
  tagNameProcessors: [nameToUpperCase],
  attrNameProcessors: [nameToUpperCase],
  valueProcessors: [nameToUpperCase],
  attrValueProcessors: [nameToUpperCase]},
  function (err, result) {
    // processed data
});
The tagNameProcessors and attrNameProcessors options
accept an Array of functions with the following signature:
function (name){
  //do something with `name`
  return name
}
The attrValueProcessors and valueProcessors options
accept an Array of functions with the following signature:
function (value, name) {
  //`name` will be the node name or attribute name
  //do something with `value`, (optionally) dependent on the node/attr name
  return value
}
Some processors are provided out-of-the-box and can be found in lib/processors.js:


normalize: transforms the name to lowercase.
(Automatically used when options.normalize is set to true)


firstCharLowerCase: transforms the first character to lower case.
E.g. 'MyTagName' becomes 'myTagName'


stripPrefix: strips the xml namespace prefix. E.g <foo:Bar/> will become 'Bar'.
(N.B.: the xmlns prefix is NOT stripped.)


parseNumbers: parses integer-like strings as integers and float-like strings as floats
E.g. "0" becomes 0 and "15.56" becomes 15.56


parseBooleans: parses boolean-like strings to booleans
E.g. "true" becomes true and "False" becomes false


Options
Apart from the default settings, there are a number of options that can be
specified for the parser. Options are specified by new Parser({optionName: value}). Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

explicitCharkey (default: false) Determines whether or not to use
a charkey prefix for elements with no attributes.

trim (default: false): Trim the whitespace at the beginning and end of
text nodes.

normalizeTags (default: false): Normalize all tag names to lowercase.

normalize (default: false): Trim whitespaces inside text nodes.

explicitRoot (default: true): Set this if you want to get the root
node in the resulting object.

emptyTag (default: ''): what will the value of empty nodes be. In case
you want to use an empty object as a default value, it is better to provide a factory
function () => ({}) instead. Without this function a plain object would
become a shared reference across all occurrences with unwanted behavior.

explicitArray (default: true): Always put child nodes in an array if
true; otherwise an array is created only if there is more than one.

ignoreAttrs (default: false): Ignore all XML attributes and only create
text nodes.

mergeAttrs (default: false): Merge attributes and child elements as
properties of the parent, instead of keying attributes off a child
attribute object. This option is ignored if ignoreAttrs is true.

validator (default null): You can specify a callable that validates
the resulting structure somehow, however you want. See unit tests
for an example.

xmlns (default false): Give each element a field usually called '$ns'
(the first character is the same as attrkey) that contains its local name
and namespace URI.

explicitChildren (default false): Put child elements to separate
property. Doesn't work with mergeAttrs = true. If element has no children
then "children" won't be created. Added in 0.2.5.

childkey (default $$): Prefix that is used to access child elements if
explicitChildren is set to true. Added in 0.2.5.

preserveChildrenOrder (default false): Modifies the behavior of
explicitChildren so that the value of the "children" property becomes an
ordered array. When this is true, every node will also get a #name field
whose value will correspond to the XML nodeName, so that you may iterate
the "children" array and still be able to determine node names. The named
(and potentially unordered) properties are also retained in this
configuration at the same level as the ordered "children" array. Added in
0.4.9.

charsAsChildren (default false): Determines whether chars should be
considered children if explicitChildren is on. Added in 0.2.5.

includeWhiteChars (default false): Determines whether whitespace-only
text nodes should be included. Added in 0.4.17.

async (default false): Should the callbacks be async? This might be
an incompatible change if your code depends on sync execution of callbacks.
Future versions of xml2js might change this default, so the recommendation
is to not depend on sync execution anyway. Added in 0.2.6.

strict (default true): Set sax-js to strict or non-strict parsing mode.
Defaults to true which is highly recommended, since parsing HTML which
is not well-formed XML might yield just about anything. Added in 0.2.7.

attrNameProcessors (default: null): Allows the addition of attribute
name processing functions. Accepts an Array of functions with following
signature:
function (name){
    //do something with `name`
    return name
}
Added in 0.4.14

attrValueProcessors (default: null): Allows the addition of attribute
value processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.1

tagNameProcessors (default: null): Allows the addition of tag name
processing functions. Accepts an Array of functions with following
signature:
function (name){
  //do something with `name`
  return name
}
Added in 0.4.1

valueProcessors (default: null): Allows the addition of element value
processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.6

Options for the Builder class
These options are specified by new Builder({optionName: value}).
Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

rootName (default root or the root key name): root element name to be used in case
explicitRoot is false or to override the root element name.

renderOpts (default { 'pretty': true, 'indent': '  ', 'newline': '\n' }):
Rendering options for xmlbuilder-js.

pretty: prettify generated XML
indent: whitespace for indentation (only when pretty)
newline: newline char (only when pretty)



xmldec (default { 'version': '1.0', 'encoding': 'UTF-8', 'standalone': true }:
XML declaration attributes.


xmldec.version A version number string, e.g. 1.0

xmldec.encoding Encoding declaration, e.g. UTF-8

xmldec.standalone standalone document declaration: true or false



doctype (default null): optional DTD. Eg. {'ext': 'hello.dtd'}


headless (default: false): omit the XML header. Added in 0.4.3.

allowSurrogateChars (default: false): allows using characters from the Unicode
surrogate blocks.

cdata (default: false): wrap text nodes in <![CDATA[ ... ]]> instead of
escaping when necessary. Does not add <![CDATA[ ... ]]> if it is not required.
Added in 0.4.5.

renderOpts, xmldec,doctype and headless pass through to
xmlbuilder-js.
Updating to new version
Version 0.2 changed the default parsing settings, but version 0.1.14 introduced
the default settings for version 0.2, so these settings can be tried before the
migration.
var xml2js = require('xml2js');
var parser = new xml2js.Parser(xml2js.defaults["0.2"]);
To get the 0.1 defaults in version 0.2 you can just use
xml2js.defaults["0.1"] in the same place. This provides you with enough time
to migrate to the saner way of parsing in xml2js 0.2. We try to make the
migration as simple and gentle as possible, but some breakage cannot be
avoided.
So, what exactly did change and why? In 0.2 we changed some defaults to parse
the XML in a more universal and sane way. So we disabled normalize and trim
so xml2js does not cut out any text content. You can reenable this at will of
course. A more important change is that we return the root tag in the resulting
JavaScript structure via the explicitRoot setting, so you need to access the
first element. This is useful for anybody who wants to know what the root node
is and preserves more information. The last major change was to enable
explicitArray, so everytime it is possible that one might embed more than one
sub-tag into a tag, xml2js >= 0.2 returns an array even if the array just
includes one element. This is useful when dealing with APIs that return
variable amounts of subtags.
Running tests, development



The development requirements are handled by npm, you just need to install them.
We also have a number of unit tests, they can be run using npm test directly
from the project root. This runs zap to discover all the tests and execute
them.
If you like to contribute, keep in mind that xml2js is written in
CoffeeScript, so don't develop on the JavaScript files that are checked into
the repository for convenience reasons. Also, please write some unit test to
check your behaviour and if it is some user-facing thing, add some
documentation to this README, so people will know it exists. Thanks in advance!
Getting support
Please, if you have a problem with the library, first make sure you read this
README. If you read this far, thanks, you're good. Then, please make sure your
problem really is with xml2js. It is? Okay, then I'll look at it. Send me a
mail and we can talk. Please don't open issues, as I don't think that is the
proper forum for support problems. Some problems might as well really be bugs
in xml2js, if so I'll let you know to open an issue instead :)
But if you know you really found a bug, feel free to open an issue instead.
Dependents (10263)mc_generic_methods@pinweb/clinode-pom-parser-forkwechat.plusgreenqloud-awssumnode_workbookkaltura-ad-servericecast-adminsweet-jumpscoffeenode-rssnextbus-live-feeddart-authrelated-readingncbi-eutil-servergideros-broomwarmapnoflo-basecampmvnrscormcloud-api-nodecasv2wddxcurrencyjssvn-utilscarwebmergeatronrssparser2gcshilinkazure-publishsettings-parserstack-overflow-rsskarotzfortumoparser-sportsnetworknTunesgchempaint2jsoncore-teststullerexpress-jslint-reporterhubot-schneierx2js-cliavoscloud-code-mock-sdkgamesdbnode-jivesbs-restworldnettpsvipetern-jquery-api-docclassify2douchetiversionapis.isand more...Package SidebarInstallnpm i xml2jsRepositorygithub.com/Leonidas-from-XIV/node-xml2jsHomepagegithub.com/Leonidas-from-XIV/node-xml2jsWeekly Downloads22,667,333Version0.6.2LicenseMITUnpacked Size3.44 MBTotal Files10Last publish2 years agoCollaboratorsTry on RunKitReport malware\n\nxml2js0.6.2 • Public • Published 2 years ago ReadmeCode Beta2 Dependencies10,263 Dependents52 Versionsnode-xml2js
Ever had the urge to parse XML? And wanted to access the data in some sane,
easy way? Don't want to compile a C parser, for whatever reason? Then xml2js is
what you're looking for!
Description
Simple XML to JavaScript object converter. It supports bi-directional conversion.
Uses sax-js and
xmlbuilder-js.
Note: If you're looking for a full DOM parser, you probably want
JSDom.
Installation
Simplest way to install xml2js is to use npm, just npm install xml2js which will download xml2js and all dependencies.
xml2js is also available via Bower, just bower install xml2js which will download xml2js and all dependencies.
Usage
No extensive tutorials required because you are a smart developer! The task of
parsing XML should be an easy one, so let's make it so! Here's some examples.
Shoot-and-forget usage
You want to parse XML as simple and easy as possible? It's dangerous to go
alone, take this:
var parseString = require('xml2js').parseString;
var xml = "<root>Hello xml2js!</root>"
parseString(xml, function (err, result) {
    console.dir(result);
});
Can't get easier than this, right? This works starting with xml2js 0.2.3.
With CoffeeScript it looks like this:
{parseString} = require 'xml2js'
xml = "<root>Hello xml2js!</root>"
parseString xml, (err, result) ->
    console.dir result
If you need some special options, fear not, xml2js supports a number of
options (see below), you can specify these as second argument:
parseString(xml, {trim: true}, function (err, result) {
});
Simple as pie usage
That's right, if you have been using xml-simple or a home-grown
wrapper, this was added in 0.1.11 just for you:
var fs = require('fs'),
    xml2js = require('xml2js');

var parser = new xml2js.Parser();
fs.readFile(__dirname + '/foo.xml', function(err, data) {
    parser.parseString(data, function (err, result) {
        console.dir(result);
        console.log('Done');
    });
});
Look ma, no event listeners!
You can also use xml2js from
CoffeeScript, further reducing
the clutter:
fs = require 'fs',
xml2js = require 'xml2js'

parser = new xml2js.Parser()
fs.readFile __dirname + '/foo.xml', (err, data) ->
  parser.parseString data, (err, result) ->
    console.dir result
    console.log 'Done.'
But what happens if you forget the new keyword to create a new Parser? In
the middle of a nightly coding session, it might get lost, after all. Worry
not, we got you covered! Starting with 0.2.8 you can also leave it out, in
which case xml2js will helpfully add it for you, no bad surprises and
inexplicable bugs!
Promise usage
var xml2js = require('xml2js');
var xml = '<foo></foo>';

// With parser
var parser = new xml2js.Parser(/* options */);
parser.parseStringPromise(xml).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});

// Without parser
xml2js.parseStringPromise(xml /*, options */).then(function (result) {
  console.dir(result);
  console.log('Done');
})
.catch(function (err) {
  // Failed
});
Parsing multiple files
If you want to parse multiple files, you have multiple possibilities:

You can create one xml2js.Parser per file. That's the recommended one
and is promised to always just work.
You can call reset() on your parser object.
You can hope everything goes well anyway. This behaviour is not
guaranteed work always, if ever. Use option #1 if possible. Thanks!

So you wanna some JSON?
Just wrap the result object in a call to JSON.stringify like this
JSON.stringify(result). You get a string containing the JSON representation
of the parsed object that you can feed to JSON-hungry consumers.
Displaying results
You might wonder why, using console.dir or console.log the output at some
level is only [Object]. Don't worry, this is not because xml2js got lazy.
That's because Node uses util.inspect to convert the object into strings and
that function stops after depth=2 which is a bit low for most XML.
To display the whole deal, you can use console.log(util.inspect(result, false, null)), which displays the whole result.
So much for that, but what if you use
eyes for nice colored output and it
truncates the output with …? Don't fear, there's also a solution for that,
you just need to increase the maxLength limit by creating a custom inspector
var inspect = require('eyes').inspector({maxLength: false}) and then you can
easily inspect(result).
XML builder usage
Since 0.4.0, objects can be also be used to build XML:
var xml2js = require('xml2js');

var obj = {name: "Super", Surname: "Man", age: 23};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root>
  <name>Super</name>
  <Surname>Man</Surname>
  <age>23</age>
</root>
At the moment, a one to one bi-directional conversion is guaranteed only for
default configuration, except for attrkey, charkey and explicitArray options
you can redefine to your taste. Writing CDATA is supported via setting the cdata
option to true.
To specify attributes:
var xml2js = require('xml2js');

var obj = {root: {$: {id: "my id"}, _: "my inner text"}};

var builder = new xml2js.Builder();
var xml = builder.buildObject(obj);
will result in:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<root id="my id">my inner text</root>
Adding xmlns attributes
You can generate XML that declares XML namespace prefix / URI pairs with xmlns attributes.
Example declaring a default namespace on the root element:
let obj = { 
  Foo: {
    $: {
      "xmlns": "http://foo.com"
    }   
  }
};  
Result of buildObject(obj):
<Foo xmlns="http://foo.com"/>
Example declaring non-default namespaces on non-root elements:
let obj = {
  'foo:Foo': {
    $: {
      'xmlns:foo': 'http://foo.com'
    },
    'bar:Bar': {
      $: {
        'xmlns:bar': 'http://bar.com'
      }
    }
  }
}
Result of buildObject(obj):
<foo:Foo xmlns:foo="http://foo.com">
  <bar:Bar xmlns:bar="http://bar.com"/>
</foo:Foo>
Processing attribute, tag names and values
Since 0.4.1 you can optionally provide the parser with attribute name and tag name processors as well as element value processors (Since 0.4.14, you can also optionally provide the parser with attribute value processors):
function nameToUpperCase(name){
    return name.toUpperCase();
}

//transform all attribute and tag names and values to uppercase
parseString(xml, {
  tagNameProcessors: [nameToUpperCase],
  attrNameProcessors: [nameToUpperCase],
  valueProcessors: [nameToUpperCase],
  attrValueProcessors: [nameToUpperCase]},
  function (err, result) {
    // processed data
});
The tagNameProcessors and attrNameProcessors options
accept an Array of functions with the following signature:
function (name){
  //do something with `name`
  return name
}
The attrValueProcessors and valueProcessors options
accept an Array of functions with the following signature:
function (value, name) {
  //`name` will be the node name or attribute name
  //do something with `value`, (optionally) dependent on the node/attr name
  return value
}
Some processors are provided out-of-the-box and can be found in lib/processors.js:


normalize: transforms the name to lowercase.
(Automatically used when options.normalize is set to true)


firstCharLowerCase: transforms the first character to lower case.
E.g. 'MyTagName' becomes 'myTagName'


stripPrefix: strips the xml namespace prefix. E.g <foo:Bar/> will become 'Bar'.
(N.B.: the xmlns prefix is NOT stripped.)


parseNumbers: parses integer-like strings as integers and float-like strings as floats
E.g. "0" becomes 0 and "15.56" becomes 15.56


parseBooleans: parses boolean-like strings to booleans
E.g. "true" becomes true and "False" becomes false


Options
Apart from the default settings, there are a number of options that can be
specified for the parser. Options are specified by new Parser({optionName: value}). Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

explicitCharkey (default: false) Determines whether or not to use
a charkey prefix for elements with no attributes.

trim (default: false): Trim the whitespace at the beginning and end of
text nodes.

normalizeTags (default: false): Normalize all tag names to lowercase.

normalize (default: false): Trim whitespaces inside text nodes.

explicitRoot (default: true): Set this if you want to get the root
node in the resulting object.

emptyTag (default: ''): what will the value of empty nodes be. In case
you want to use an empty object as a default value, it is better to provide a factory
function () => ({}) instead. Without this function a plain object would
become a shared reference across all occurrences with unwanted behavior.

explicitArray (default: true): Always put child nodes in an array if
true; otherwise an array is created only if there is more than one.

ignoreAttrs (default: false): Ignore all XML attributes and only create
text nodes.

mergeAttrs (default: false): Merge attributes and child elements as
properties of the parent, instead of keying attributes off a child
attribute object. This option is ignored if ignoreAttrs is true.

validator (default null): You can specify a callable that validates
the resulting structure somehow, however you want. See unit tests
for an example.

xmlns (default false): Give each element a field usually called '$ns'
(the first character is the same as attrkey) that contains its local name
and namespace URI.

explicitChildren (default false): Put child elements to separate
property. Doesn't work with mergeAttrs = true. If element has no children
then "children" won't be created. Added in 0.2.5.

childkey (default $$): Prefix that is used to access child elements if
explicitChildren is set to true. Added in 0.2.5.

preserveChildrenOrder (default false): Modifies the behavior of
explicitChildren so that the value of the "children" property becomes an
ordered array. When this is true, every node will also get a #name field
whose value will correspond to the XML nodeName, so that you may iterate
the "children" array and still be able to determine node names. The named
(and potentially unordered) properties are also retained in this
configuration at the same level as the ordered "children" array. Added in
0.4.9.

charsAsChildren (default false): Determines whether chars should be
considered children if explicitChildren is on. Added in 0.2.5.

includeWhiteChars (default false): Determines whether whitespace-only
text nodes should be included. Added in 0.4.17.

async (default false): Should the callbacks be async? This might be
an incompatible change if your code depends on sync execution of callbacks.
Future versions of xml2js might change this default, so the recommendation
is to not depend on sync execution anyway. Added in 0.2.6.

strict (default true): Set sax-js to strict or non-strict parsing mode.
Defaults to true which is highly recommended, since parsing HTML which
is not well-formed XML might yield just about anything. Added in 0.2.7.

attrNameProcessors (default: null): Allows the addition of attribute
name processing functions. Accepts an Array of functions with following
signature:
function (name){
    //do something with `name`
    return name
}
Added in 0.4.14

attrValueProcessors (default: null): Allows the addition of attribute
value processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.1

tagNameProcessors (default: null): Allows the addition of tag name
processing functions. Accepts an Array of functions with following
signature:
function (name){
  //do something with `name`
  return name
}
Added in 0.4.1

valueProcessors (default: null): Allows the addition of element value
processing functions. Accepts an Array of functions with following
signature:
function (value, name){
  //do something with `name`
  return name
}
Added in 0.4.6

Options for the Builder class
These options are specified by new Builder({optionName: value}).
Possible options are:


attrkey (default: $): Prefix that is used to access the attributes.
Version 0.1 default was @.

charkey (default: _): Prefix that is used to access the character
content. Version 0.1 default was #.

rootName (default root or the root key name): root element name to be used in case
explicitRoot is false or to override the root element name.

renderOpts (default { 'pretty': true, 'indent': '  ', 'newline': '\n' }):
Rendering options for xmlbuilder-js.

pretty: prettify generated XML
indent: whitespace for indentation (only when pretty)
newline: newline char (only when pretty)



xmldec (default { 'version': '1.0', 'encoding': 'UTF-8', 'standalone': true }:
XML declaration attributes.


xmldec.version A version number string, e.g. 1.0

xmldec.encoding Encoding declaration, e.g. UTF-8

xmldec.standalone standalone document declaration: true or false



doctype (default null): optional DTD. Eg. {'ext': 'hello.dtd'}


headless (default: false): omit the XML header. Added in 0.4.3.

allowSurrogateChars (default: false): allows using characters from the Unicode
surrogate blocks.

cdata (default: false): wrap text nodes in <![CDATA[ ... ]]> instead of
escaping when necessary. Does not add <![CDATA[ ... ]]> if it is not required.
Added in 0.4.5.

renderOpts, xmldec,doctype and headless pass through to
xmlbuilder-js.
Updating to new version
Version 0.2 changed the default parsing settings, but version 0.1.14 introduced
the default settings for version 0.2, so these settings can be tried before the
migration.
var xml2js = require('xml2js');
var parser = new xml2js.Parser(xml2js.defaults["0.2"]);
To get the 0.1 defaults in version 0.2 you can just use
xml2js.defaults["0.1"] in the same place. This provides you with enough time
to migrate to the saner way of parsing in xml2js 0.2. We try to make the
migration as simple and gentle as possible, but some breakage cannot be
avoided.
So, what exactly did change and why? In 0.2 we changed some defaults to parse
the XML in a more universal and sane way. So we disabled normalize and trim
so xml2js does not cut out any text content. You can reenable this at will of
course. A more important change is that we return the root tag in the resulting
JavaScript structure via the explicitRoot setting, so you need to access the
first element. This is useful for anybody who wants to know what the root node
is and preserves more information. The last major change was to enable
explicitArray, so everytime it is possible that one might embed more than one
sub-tag into a tag, xml2js >= 0.2 returns an array even if the array just
includes one element. This is useful when dealing with APIs that return
variable amounts of subtags.
Running tests, development



The development requirements are handled by npm, you just need to install them.
We also have a number of unit tests, they can be run using npm test directly
from the project root. This runs zap to discover all the tests and execute
them.
If you like to contribute, keep in mind that xml2js is written in
CoffeeScript, so don't develop on the JavaScript files that are checked into
the repository for convenience reasons. Also, please write some unit test to
check your behaviour and if it is some user-facing thing, add some
documentation to this README, so people will know it exists. Thanks in advance!
Getting support
Please, if you have a problem with the library, first make sure you read this
README. If you read this far, thanks, you're good. Then, please make sure your
problem really is with xml2js. It is? Okay, then I'll look at it. Send me a
mail and we can talk. Please don't open issues, as I don't think that is the
proper forum for support problems. Some problems might as well really be bugs
in xml2js, if so I'll let you know to open an issue instead :)
But if you know you really found a bug, feel free to open an issue instead.
Dependents (10263)mc_generic_methods@pinweb/clinode-pom-parser-forkwechat.plusgreenqloud-awssumnode_workbookkaltura-ad-servericecast-adminsweet-jumpscoffeenode-rssnextbus-live-feeddart-authrelated-readingncbi-eutil-servergideros-broomwarmapnoflo-basecampmvnrscormcloud-api-nodecasv2wddxcurrencyjssvn-utilscarwebmergeatronrssparser2gcshilinkazure-publishsettings-parserstack-overflow-rsskarotzfortumoparser-sportsnetworknTunesgchempaint2jsoncore-teststullerexpress-jslint-reporterhubot-schneierx2js-cliavoscloud-code-mock-sdkgamesdbnode-jivesbs-restworldnettpsvipetern-jquery-api-docclassify2douchetiversionapis.isand more...Package SidebarInstallnpm i xml2jsRepositorygithub.com/Leonidas-from-XIV/node-xml2jsHomepagegithub.com/Leonidas-from-XIV/node-xml2jsWeekly Downloads22,667,333Version0.6.2LicenseMITUnpacked Size3.44 MBTotal Files10Last publish2 years agoCollaboratorsTry on RunKitReport malware\n\n\n\nSearch results1000+ packages foundSort by: DefaultDefaultMost downloaded this weekMost downloaded this monthMost dependentsRecently publisheddom-serializerrender domhandler DOM nodes to a stringhtmlxmlrenderfeedic• 2.0.0 • 3 years ago •  787 dependents •  MITpublished version 2.0.0, 3 years ago787 dependents licensed under $MIT201,799,652fast-xml-parserValidate XML, Parse XML, Build XML without C/C++ based librariesfastxmljsonparserxml2jsx2jsxml2jsonjsclivalidatorvalidatetransformerassertjs2xmlView moreamitgupta• 5.2.0 • 14 days ago •  2,972 dependents •  MITpublished version 5.2.0, 14 days ago2972 dependents licensed under $MIT132,015,489xml2jsSimple XML to JavaScript object converter.xmljsonleonidas• 0.6.2 • 2 years ago •  10,260 dependents •  MITpublished version 0.6.2, 2 years ago10260 dependents licensed under $MIT98,938,166xmlbuilderAn XML builder for node.jsxmlxmlbuilderoozcitak• 15.1.1 • 5 years ago •  1,975 dependents •  MITpublished version 15.1.1, 5 years ago1975 dependents licensed under $MIT129,213,930htmlparser2Fast & forgiving HTML/XML parserhtmlparserstreamsxmldomrssfeedatomfeedic• 10.0.0 • 4 months ago •  2,588 dependents •  MITpublished version 10.0.0, 4 months ago2588 dependents licensed under $MIT156,622,960interpretA dictionary of file extensions and associated module loaders.coffeecoffee.mdcoffeescripteses6jsjsonjson5jsxreactlitcoffeetomltstypescriptView morephated• 3.1.1 • 3 years ago •  1,382 dependents •  MITpublished version 3.1.1, 3 years ago1382 dependents licensed under $MIT95,860,542xml-name-validatorValidates whether a string matches the production for an XML name or qualified namexmlnameqnamedomenic• 5.0.0 • a year ago •  720 dependents •  Apache-2.0published version 5.0.0, a year ago720 dependents licensed under $Apache-2.0123,061,586file-typeDetect the file type of a file, stream, or datamimefiletypemagicarchiveimageimgpicpictureflashphotovideodetectcheckView moresindresorhus• 20.4.1 • a month ago •  2,348 dependents •  MITpublished version 20.4.1, a month ago2348 dependents licensed under $MIT99,424,780w3c-xmlserializerA per-spec XML serializer implementationdomw3cxmlxmlserializerdomenic• 5.0.0 • a year ago •  637 dependents •  MITpublished version 5.0.0, a year ago637 dependents licensed under $MIT110,880,074@xmldom/xmldomA pure JavaScript W3C standard-based (XML DOM Level 2 Core) DOMParser and XMLSerializer module.w3cdomxmlparserjavascriptDOMParserXMLSerializerponyfillkarfau• 0.9.8 • 2 months ago •  815 dependents •  MITpublished version 0.9.8, 2 months ago815 dependents licensed under $MIT45,096,474cheerioThe fast, flexible & elegant library for parsing and manipulating HTML and XML.htmlparserjqueryselectorscraperparserdomxmlhtmlfeedic• 1.0.0 • 8 months ago •  17,623 dependents •  MITpublished version 1.0.0, 8 months ago17623 dependents licensed under $MIT44,983,066unist-util-visitunist utility to visit nodesunistunist-utilutilutilityremarkretextrehypemdasthastxastnlcstnaturallanguagemarkdownView morewooorm• 5.0.0 • 2 years ago •  2,774 dependents •  MITpublished version 5.0.0, 2 years ago2774 dependents licensed under $MIT67,877,773xmlFast and simple xml generator. Supports attributes, CDATA, etc. Includes tests and examples.xmlcreatebuilderjsonsimpledylang• 1.0.1 • 9 years ago •  652 dependents •  MITpublished version 1.0.1, 9 years ago652 dependents licensed under $MIT36,963,222remark-mdxremark plugin to support MDX syntaxjavascriptjsxmarkdownmdastmdxpluginremarkremark-pluginunifiedxmlwooorm• 3.1.0 • 6 months ago •  178 dependents •  MITpublished version 3.1.0, 6 months ago178 dependents licensed under $MIT14,106,017xpathDOM 3 XPath implemention and helper for node.js and the webxpathxmljlrishe• 0.0.34 • a year ago •  963 dependents •  MITpublished version 0.0.34, a year ago963 dependents licensed under $MIT15,094,910xmlcreateSimple XML builder for Node.jsbuildbuildercreatecreatorxmlmichaelkourlas• 2.0.4 • 3 years ago •  26 dependents •  Apache-2.0published version 2.0.4, 3 years ago26 dependents licensed under $Apache-2.011,667,385plistApple's property list parser/builder for Node.js and browsersapplebrowsermacplistparserxmlmreinstein• 3.1.0 • 2 years ago •  1,475 dependents •  MITpublished version 3.1.0, 2 years ago1475 dependents licensed under $MIT14,142,568js2xmlparserParses JavaScript objects into XMLconvertconverterjavascriptjsjsonobjectobjectsparseparserxmlmichaelkourlas• 5.0.0 • 3 years ago •  464 dependents •  Apache-2.0published version 5.0.0, 3 years ago464 dependents licensed under $Apache-2.011,836,186simple-plistA wrapper utility for interacting with plist data.plistbinarybplistxmlwollardj• 1.3.1 • 3 years ago •  293 dependents •  MITpublished version 1.3.1, 3 years ago293 dependents licensed under $MIT7,852,355xml-jsA convertor between XML text and Javascript object / JSON text.XMLxmljsJSONjsoncdataCDATAdoctypeprocessing instructionJavascriptjs2xmljson2xmlxml2jsxml2jsonView morenashwaan• 1.6.11 • 6 years ago •  1,915 dependents •  MITpublished version 1.6.11, 6 years ago1915 dependents licensed under $MIT10,780,249123…50»\n\nSearch results1000+ packages foundSort by: DefaultDefaultMost downloaded this weekMost downloaded this monthMost dependentsRecently publisheddom-serializerrender domhandler DOM nodes to a stringhtmlxmlrenderfeedic• 2.0.0 • 3 years ago •  787 dependents •  MITpublished version 2.0.0, 3 years ago787 dependents licensed under $MIT201,799,652fast-xml-parserValidate XML, Parse XML, Build XML without C/C++ based librariesfastxmljsonparserxml2jsx2jsxml2jsonjsclivalidatorvalidatetransformerassertjs2xmlView moreamitgupta• 5.2.0 • 14 days ago •  2,972 dependents •  MITpublished version 5.2.0, 14 days ago2972 dependents licensed under $MIT132,015,489xml2jsSimple XML to JavaScript object converter.xmljsonleonidas• 0.6.2 • 2 years ago •  10,260 dependents •  MITpublished version 0.6.2, 2 years ago10260 dependents licensed under $MIT98,938,166xmlbuilderAn XML builder for node.jsxmlxmlbuilderoozcitak• 15.1.1 • 5 years ago •  1,975 dependents •  MITpublished version 15.1.1, 5 years ago1975 dependents licensed under $MIT129,213,930htmlparser2Fast & forgiving HTML/XML parserhtmlparserstreamsxmldomrssfeedatomfeedic• 10.0.0 • 4 months ago •  2,588 dependents •  MITpublished version 10.0.0, 4 months ago2588 dependents licensed under $MIT156,622,960interpretA dictionary of file extensions and associated module loaders.coffeecoffee.mdcoffeescripteses6jsjsonjson5jsxreactlitcoffeetomltstypescriptView morephated• 3.1.1 • 3 years ago •  1,382 dependents •  MITpublished version 3.1.1, 3 years ago1382 dependents licensed under $MIT95,860,542xml-name-validatorValidates whether a string matches the production for an XML name or qualified namexmlnameqnamedomenic• 5.0.0 • a year ago •  720 dependents •  Apache-2.0published version 5.0.0, a year ago720 dependents licensed under $Apache-2.0123,061,586file-typeDetect the file type of a file, stream, or datamimefiletypemagicarchiveimageimgpicpictureflashphotovideodetectcheckView moresindresorhus• 20.4.1 • a month ago •  2,348 dependents •  MITpublished version 20.4.1, a month ago2348 dependents licensed under $MIT99,424,780w3c-xmlserializerA per-spec XML serializer implementationdomw3cxmlxmlserializerdomenic• 5.0.0 • a year ago •  637 dependents •  MITpublished version 5.0.0, a year ago637 dependents licensed under $MIT110,880,074@xmldom/xmldomA pure JavaScript W3C standard-based (XML DOM Level 2 Core) DOMParser and XMLSerializer module.w3cdomxmlparserjavascriptDOMParserXMLSerializerponyfillkarfau• 0.9.8 • 2 months ago •  815 dependents •  MITpublished version 0.9.8, 2 months ago815 dependents licensed under $MIT45,096,474cheerioThe fast, flexible & elegant library for parsing and manipulating HTML and XML.htmlparserjqueryselectorscraperparserdomxmlhtmlfeedic• 1.0.0 • 8 months ago •  17,623 dependents •  MITpublished version 1.0.0, 8 months ago17623 dependents licensed under $MIT44,983,066unist-util-visitunist utility to visit nodesunistunist-utilutilutilityremarkretextrehypemdasthastxastnlcstnaturallanguagemarkdownView morewooorm• 5.0.0 • 2 years ago •  2,774 dependents •  MITpublished version 5.0.0, 2 years ago2774 dependents licensed under $MIT67,877,773xmlFast and simple xml generator. Supports attributes, CDATA, etc. Includes tests and examples.xmlcreatebuilderjsonsimpledylang• 1.0.1 • 9 years ago •  652 dependents •  MITpublished version 1.0.1, 9 years ago652 dependents licensed under $MIT36,963,222remark-mdxremark plugin to support MDX syntaxjavascriptjsxmarkdownmdastmdxpluginremarkremark-pluginunifiedxmlwooorm• 3.1.0 • 6 months ago •  178 dependents •  MITpublished version 3.1.0, 6 months ago178 dependents licensed under $MIT14,106,017xpathDOM 3 XPath implemention and helper for node.js and the webxpathxmljlrishe• 0.0.34 • a year ago •  963 dependents •  MITpublished version 0.0.34, a year ago963 dependents licensed under $MIT15,094,910xmlcreateSimple XML builder for Node.jsbuildbuildercreatecreatorxmlmichaelkourlas• 2.0.4 • 3 years ago •  26 dependents •  Apache-2.0published version 2.0.4, 3 years ago26 dependents licensed under $Apache-2.011,667,385plistApple's property list parser/builder for Node.js and browsersapplebrowsermacplistparserxmlmreinstein• 3.1.0 • 2 years ago •  1,475 dependents •  MITpublished version 3.1.0, 2 years ago1475 dependents licensed under $MIT14,142,568js2xmlparserParses JavaScript objects into XMLconvertconverterjavascriptjsjsonobjectobjectsparseparserxmlmichaelkourlas• 5.0.0 • 3 years ago •  464 dependents •  Apache-2.0published version 5.0.0, 3 years ago464 dependents licensed under $Apache-2.011,836,186simple-plistA wrapper utility for interacting with plist data.plistbinarybplistxmlwollardj• 1.3.1 • 3 years ago •  293 dependents •  MITpublished version 1.3.1, 3 years ago293 dependents licensed under $MIT7,852,355xml-jsA convertor between XML text and Javascript object / JSON text.XMLxmljsJSONjsoncdataCDATAdoctypeprocessing instructionJavascriptjs2xmljson2xmlxml2jsxml2jsonView morenashwaan• 1.6.11 • 6 years ago •  1,915 dependents •  MITpublished version 1.6.11, 6 years ago1915 dependents licensed under $MIT10,780,249123…50»\n\n\n\nSearch results1000+ packages foundSort by: DefaultDefaultMost downloaded this weekMost downloaded this monthMost dependentsRecently publishedtype-festA collection of essential TypeScript typestypescripttstypesutilityutilutilitiesomitmergejsongenericssindresorhus• 4.40.0 • 2 days ago •  5,373 dependents •  (MIT OR CC0-1.0)published version 4.40.0, 2 days ago5373 dependents licensed under $(MIT OR CC0-1.0)878,523,388fs-extrafs-extra contains methods that aren't included in the vanilla Node.js fs package. Such as recursive mkdir, copy, and remove.fsfilefile systemcopydirectoryextramkdirpmkdirmkdirsrecursivejsonreadwritedeleteView moreryanzim• 11.3.0 • 3 months ago •  71,971 dependents •  MITpublished version 11.3.0, 3 months ago71971 dependents licensed under $MIT484,663,593jsescGiven some data, jsesc returns the shortest possible stringified & ASCII-safe representation of that data.bufferescapejavascriptjsonmapsetstringstringifytoolmathias• 3.1.0 • 4 months ago •  2,073 dependents •  MITpublished version 3.1.0, 4 months ago2073 dependents licensed under $MIT332,080,637json5JSON for Humansjsonjson5es5es2015ecmascriptjordanbtucker• 2.2.3 • 2 years ago •  5,689 dependents •  MITpublished version 2.2.3, 2 years ago5689 dependents licensed under $MIT372,956,583parse-jsonParse JSON with more helpful errorsparsejsongracefulerrormessagehumanizefriendlyhelpfulstringsindresorhus• 8.3.0 • 8 days ago •  1,897 dependents •  MITpublished version 8.3.0, 8 days ago1897 dependents licensed under $MIT304,701,242strip-json-commentsStrip comments from JSON. Lets you use comments in your JSON files!jsonstripcommentsremovedeletetrimmultilineparseconfigconfigurationsettingsutilenvenvironmentsindresorhus• 5.0.1 • 2 years ago •  3,134 dependents •  MITpublished version 5.0.1, 2 years ago3134 dependents licensed under $MIT322,992,823pkg-dirFind the root directory of a Node.js project or npm packagepackagejsonrootnpmentryfindupfind-upfinduplook-uplookfilesearchmatchView moresindresorhus• 8.0.0 • a year ago •  3,289 dependents •  MITpublished version 8.0.0, a year ago3289 dependents licensed under $MIT282,816,202levnLight ECMAScript (JavaScript) Value Notation - human written, concise, typed, flexiblelevnlightecmascriptvaluenotationjsontypedhumanconciseflexiblegkz• 0.4.1 • 5 years ago •  1,674 dependents •  MITpublished version 0.4.1, 5 years ago1674 dependents licensed under $MIT240,601,644fast-json-stable-stringifydeterministic `JSON.stringify()` - a faster version of substack's json-stable-strigify without jsonifyjsonstringifydeterministichashstableesp• 2.1.0 • 5 years ago •  2,637 dependents •  MITpublished version 2.1.0, 5 years ago2637 dependents licensed under $MIT225,980,882jsonfileEasily read/write JSON files.readwritefilejsonfsfs-extraryanzim• 6.1.0 • 4 years ago •  4,191 dependents •  MITpublished version 6.1.0, 4 years ago4191 dependents licensed under $MIT274,262,907diffA JavaScript text diff implementation.diffjsdiffcomparepatchtextjsoncssjavascriptexplodingcabbage• 7.0.0 • 7 months ago •  6,744 dependents •  BSD-3-Clausepublished version 7.0.0, 7 months ago6744 dependents licensed under $BSD-3-Clause219,793,699binary-extensionsList of binary file extensionsbinaryextensionsextensionfilejsonlistarraysindresorhus• 3.0.0 • a year ago •  1,600 dependents •  MITpublished version 3.0.0, a year ago1600 dependents licensed under $MIT226,658,750serialize-javascriptSerialize JavaScript to a superset of JSON that includes regular expressions and functions.serializeserializationjavascriptjsjsonredonkulus• 6.0.2 • a year ago •  2,396 dependents •  BSD-3-Clausepublished version 6.0.2, a year ago2396 dependents licensed under $BSD-3-Clause176,429,371json-stable-stringify-without-jsonifydeterministic JSON.stringify() with custom sorting to get deterministic hashes from stringified results, with no public domain dependenciesjsonstringifydeterministichashsortstablesamn• 1.0.1 • 8 years ago •  1,523 dependents •  MITpublished version 1.0.1, 8 years ago1523 dependents licensed under $MIT185,659,460jwsImplementation of JSON Web Signaturesjwsjsonwebsignaturesomsmith• 4.0.0 • 5 years ago •  440 dependents •  MITpublished version 4.0.0, 5 years ago440 dependents licensed under $MIT130,979,643read-pkgRead a package.json filejsonreadparsefilefsgracefulloadpackagenormalizesindresorhus• 9.0.1 • a year ago •  1,931 dependents •  MITpublished version 9.0.1, a year ago1931 dependents licensed under $MIT168,569,828cli-spinnersSpinners for use in the terminalclispinnerspinnersterminaltermconsoleasciiunicodeloadingindicatorprogressbusywaitidlesindresorhus• 3.2.0 • 7 months ago •  2,236 dependents •  MITpublished version 3.2.0, 7 months ago2236 dependents licensed under $MIT122,271,903fast-xml-parserValidate XML, Parse XML, Build XML without C/C++ based librariesfastxmljsonparserxml2jsx2jsxml2jsonjsclivalidatorvalidatetransformerassertjs2xmlView moreamitgupta• 5.2.0 • 14 days ago •  2,972 dependents •  MITpublished version 5.2.0, 14 days ago2972 dependents licensed under $MIT132,015,489spdx-license-idsA list of SPDX license identifiersspdxlicenselicensesididentifieridentifiersjsonarrayosskemitchell• 3.0.21 • 3 months ago •  1,103 dependents •  CC0-1.0published version 3.0.21, 3 months ago1103 dependents licensed under $CC0-1.0131,525,521xml2jsSimple XML to JavaScript object converter.xmljsonleonidas• 0.6.2 • 2 years ago •  10,260 dependents •  MITpublished version 0.6.2, 2 years ago10260 dependents licensed under $MIT98,938,166123…50»\n\nSearch results1000+ packages foundSort by: DefaultDefaultMost downloaded this weekMost downloaded this monthMost dependentsRecently publishedtype-festA collection of essential TypeScript typestypescripttstypesutilityutilutilitiesomitmergejsongenericssindresorhus• 4.40.0 • 2 days ago •  5,373 dependents •  (MIT OR CC0-1.0)published version 4.40.0, 2 days ago5373 dependents licensed under $(MIT OR CC0-1.0)878,523,388fs-extrafs-extra contains methods that aren't included in the vanilla Node.js fs package. Such as recursive mkdir, copy, and remove.fsfilefile systemcopydirectoryextramkdirpmkdirmkdirsrecursivejsonreadwritedeleteView moreryanzim• 11.3.0 • 3 months ago •  71,971 dependents •  MITpublished version 11.3.0, 3 months ago71971 dependents licensed under $MIT484,663,593jsescGiven some data, jsesc returns the shortest possible stringified & ASCII-safe representation of that data.bufferescapejavascriptjsonmapsetstringstringifytoolmathias• 3.1.0 • 4 months ago •  2,073 dependents •  MITpublished version 3.1.0, 4 months ago2073 dependents licensed under $MIT332,080,637json5JSON for Humansjsonjson5es5es2015ecmascriptjordanbtucker• 2.2.3 • 2 years ago •  5,689 dependents •  MITpublished version 2.2.3, 2 years ago5689 dependents licensed under $MIT372,956,583parse-jsonParse JSON with more helpful errorsparsejsongracefulerrormessagehumanizefriendlyhelpfulstringsindresorhus• 8.3.0 • 8 days ago •  1,897 dependents •  MITpublished version 8.3.0, 8 days ago1897 dependents licensed under $MIT304,701,242strip-json-commentsStrip comments from JSON. Lets you use comments in your JSON files!jsonstripcommentsremovedeletetrimmultilineparseconfigconfigurationsettingsutilenvenvironmentsindresorhus• 5.0.1 • 2 years ago •  3,134 dependents •  MITpublished version 5.0.1, 2 years ago3134 dependents licensed under $MIT322,992,823pkg-dirFind the root directory of a Node.js project or npm packagepackagejsonrootnpmentryfindupfind-upfinduplook-uplookfilesearchmatchView moresindresorhus• 8.0.0 • a year ago •  3,289 dependents •  MITpublished version 8.0.0, a year ago3289 dependents licensed under $MIT282,816,202levnLight ECMAScript (JavaScript) Value Notation - human written, concise, typed, flexiblelevnlightecmascriptvaluenotationjsontypedhumanconciseflexiblegkz• 0.4.1 • 5 years ago •  1,674 dependents •  MITpublished version 0.4.1, 5 years ago1674 dependents licensed under $MIT240,601,644fast-json-stable-stringifydeterministic `JSON.stringify()` - a faster version of substack's json-stable-strigify without jsonifyjsonstringifydeterministichashstableesp• 2.1.0 • 5 years ago •  2,637 dependents •  MITpublished version 2.1.0, 5 years ago2637 dependents licensed under $MIT225,980,882jsonfileEasily read/write JSON files.readwritefilejsonfsfs-extraryanzim• 6.1.0 • 4 years ago •  4,191 dependents •  MITpublished version 6.1.0, 4 years ago4191 dependents licensed under $MIT274,262,907diffA JavaScript text diff implementation.diffjsdiffcomparepatchtextjsoncssjavascriptexplodingcabbage• 7.0.0 • 7 months ago •  6,744 dependents •  BSD-3-Clausepublished version 7.0.0, 7 months ago6744 dependents licensed under $BSD-3-Clause219,793,699binary-extensionsList of binary file extensionsbinaryextensionsextensionfilejsonlistarraysindresorhus• 3.0.0 • a year ago •  1,600 dependents •  MITpublished version 3.0.0, a year ago1600 dependents licensed under $MIT226,658,750serialize-javascriptSerialize JavaScript to a superset of JSON that includes regular expressions and functions.serializeserializationjavascriptjsjsonredonkulus• 6.0.2 • a year ago •  2,396 dependents •  BSD-3-Clausepublished version 6.0.2, a year ago2396 dependents licensed under $BSD-3-Clause176,429,371json-stable-stringify-without-jsonifydeterministic JSON.stringify() with custom sorting to get deterministic hashes from stringified results, with no public domain dependenciesjsonstringifydeterministichashsortstablesamn• 1.0.1 • 8 years ago •  1,523 dependents •  MITpublished version 1.0.1, 8 years ago1523 dependents licensed under $MIT185,659,460jwsImplementation of JSON Web Signaturesjwsjsonwebsignaturesomsmith• 4.0.0 • 5 years ago •  440 dependents •  MITpublished version 4.0.0, 5 years ago440 dependents licensed under $MIT130,979,643read-pkgRead a package.json filejsonreadparsefilefsgracefulloadpackagenormalizesindresorhus• 9.0.1 • a year ago •  1,931 dependents •  MITpublished version 9.0.1, a year ago1931 dependents licensed under $MIT168,569,828cli-spinnersSpinners for use in the terminalclispinnerspinnersterminaltermconsoleasciiunicodeloadingindicatorprogressbusywaitidlesindresorhus• 3.2.0 • 7 months ago •  2,236 dependents •  MITpublished version 3.2.0, 7 months ago2236 dependents licensed under $MIT122,271,903fast-xml-parserValidate XML, Parse XML, Build XML without C/C++ based librariesfastxmljsonparserxml2jsx2jsxml2jsonjsclivalidatorvalidatetransformerassertjs2xmlView moreamitgupta• 5.2.0 • 14 days ago •  2,972 dependents •  MITpublished version 5.2.0, 14 days ago2972 dependents licensed under $MIT132,015,489spdx-license-idsA list of SPDX license identifiersspdxlicenselicensesididentifieridentifiersjsonarrayosskemitchell• 3.0.21 • 3 months ago •  1,103 dependents •  CC0-1.0published version 3.0.21, 3 months ago1103 dependents licensed under $CC0-1.0131,525,521xml2jsSimple XML to JavaScript object converter.xmljsonleonidas• 0.6.2 • 2 years ago •  10,260 dependents •  MITpublished version 0.6.2, 2 years ago10260 dependents licensed under $MIT98,938,166123…50»\n\n\n\nleonidasMarek Kubica@Leonidas-from-XIV1 Package0 OrganizationsPackage 1xml2jsSimple XML to JavaScript object converter.leonidaspublished 0.6.2 • 2 years agopublished version 0.6.2, 2 years ago\n\nleonidasMarek Kubica@Leonidas-from-XIV1 Package0 OrganizationsPackage 1xml2jsSimple XML to JavaScript object converter.leonidaspublished 0.6.2 • 2 years agopublished version 0.6.2, 2 years ago\n\n\n\nContact UsGet help with the npm registry or your npm account.Please contact us if you need help with the npm registry or with your npm account, if you are reporting security concerns in an npm product, or if you need to report malicious or abusive behavior in a package in the registry.How can we help?I'm reporting spam, abuse or a security issueMy Security IssueI am reporting malware in a package on npmjs.comAsterisk (*) Indicates Required Field Name *Email *Subject *Package *Version *How can we help? *Verify you are a humanSubmitnpm command-lineIf you're having trouble using the npm command-line interface, or you need help with a project that you’re working on, we recommend that you check out the Software Development board of the GitHub Community forums.Giving FeedbackIf you have suggestions for how we can improve npm please open a discussion in our feedback forum.Press RelationsPress inquiries should be addressed to  press@npmjs.comPress inquiries should be addressed to press@npmjs.com\n\nContact UsGet help with the npm registry or your npm account.Please contact us if you need help with the npm registry or with your npm account, if you are reporting security concerns in an npm product, or if you need to report malicious or abusive behavior in a package in the registry.How can we help?I'm reporting spam, abuse or a security issueMy Security IssueI am reporting malware in a package on npmjs.comAsterisk (*) Indicates Required Field Name *Email *Subject *Package *Version *How can we help? *Verify you are a humanSubmitnpm command-lineIf you're having trouble using the npm command-line interface, or you need help with a project that you’re working on, we recommend that you check out the Software Development board of the GitHub Community forums.Giving FeedbackIf you have suggestions for how we can improve npm please open a discussion in our feedback forum.Press RelationsPress inquiries should be addressed to  press@npmjs.comPress inquiries should be addressed to press@npmjs.com\n\n\n\nContact UsYou need to be signed in to get help with npm.Sign in for assistanceCan't sign in, or don't have an account?Choose one of these categories to continue.Account or billing issuesCopyright or trademark data removalDispute a package, org, or usernameReport a security issue or abusenpm command-lineIf you're having trouble using the npm command-line interface, or you need help with a project that you’re working on, we recommend that you check out the Software Development board of the GitHub Community forums.Giving FeedbackIf you have suggestions for how we can improve npm please open a discussion in our feedback forum.Press RelationsPress inquiries should be addressed to  press@npmjs.comPress inquiries should be addressed to press@npmjs.com\n\nContact UsYou need to be signed in to get help with npm.Sign in for assistanceCan't sign in, or don't have an account?Choose one of these categories to continue.Account or billing issuesCopyright or trademark data removalDispute a package, org, or usernameReport a security issue or abusenpm command-lineIf you're having trouble using the npm command-line interface, or you need help with a project that you’re working on, we recommend that you check out the Software Development board of the GitHub Community forums.Giving FeedbackIf you have suggestions for how we can improve npm please open a discussion in our feedback forum.Press RelationsPress inquiries should be addressed to  press@npmjs.comPress inquiries should be addressed to press@npmjs.com\n\n\n\nAbout npm
      
        npm, Inc. is a company founded in 2014, and was acquired by GitHub in 2020. npm is a critical part of the
        JavaScript community and helps support one of the largest developer ecosystems in the world.
      
      npm is lots of things.
      
        
          
            npm is the package manager for Node.js. It was created in
            2009 as an open source project  to help JavaScript
            developers easily share packaged modules of code.
          
        
        
          
            The npm Registry is a public collection of packages of open-source code for Node.js, front-end web apps,
            mobile apps, robots, routers, and countless other needs of the JavaScript community.
          
        
        
          
            npm is the command line client that allows developers to install and publish those packages.\n\nAbout npm
      
        npm, Inc. is a company founded in 2014, and was acquired by GitHub in 2020. npm is a critical part of the
        JavaScript community and helps support one of the largest developer ecosystems in the world.
      
      npm is lots of things.
      
        
          
            npm is the package manager for Node.js. It was created in
            2009 as an open source project  to help JavaScript
            developers easily share packaged modules of code.
          
        
        
          
            The npm Registry is a public collection of packages of open-source code for Node.js, front-end web apps,
            mobile apps, robots, routers, and countless other needs of the JavaScript community.
          
        
        
          
            npm is the command line client that allows developers to install and publish those packages.\n\n\n\nAbout
      Press
  



    
    
    
    

    Press

    


  
    
  
    

    
        Founded in February, 2008
    
  

  
    

    
      HQ in San Francisco
    
  

  
    

    
      Product updates
    
  

  
    

    
      GitHub glossary
    
  

  
    

    
      Media resources
    
  

  
    

    
       press@github.com
     
  


  

  
      
  
    
      ZDNet Korea
      [현장] 깃허브 "코파일럿, 개발 패러다임 바꿔…ROI 달성 가능"
    
    Mar 26, 2025


      
  
    
      Practical AI Podcast
      AI-assisted coding with GitHub's COO
    
    Mar 21, 2025


      
  
    
      No Priors 
      Episode 106: GitHub CEO Thomas Dohmke
    
    Mar 13, 2025


      
  
    
      The Guardian
      How ‘AI agents’ will change the internet 
    
    Mar 9, 2025


      
  
    
      WirtschaftsWoche
      Ein Büro? Gibt’s bei uns nicht
    
    Mar 4, 2025


      
  
    
      Wall Street Journal
      How AI Tools Are Reshaping the Coding Workforce
    
    Mar 4, 2025


      
  
    
      TI Inside
      Exposição total: uma abordagem prática para lidar com vazamentos de dados sensíveis
    
    Mar 3, 2025


      
  
    
      The New York Times 
      A.I. is Prompting an Evolution, Not Extinction, for Coders 
    
    Feb 20, 2025


      
  
    
      itforum
      Boticário inova com uso do GitHub Copilot, gera menos tarefas repetitivas e foca em valor ao negócio
    
    Feb 19, 2025


      
  
    
      IT Forum
      Boticário inova com uso do GitHub Copilot, gera menos tarefas repetitivas e foca em valor ao negócio
    
    Feb 19, 2025


      
  
    
      Infosecurity Magazine
      Full Exposure: A Practical Approach to Handling Sensitive Data Leaks
    
    Feb 7, 2025


      
  
    
      TechCrunch
      GitHub Copilot brings mockups to life by generating code from images
    
    Feb 6, 2025


      
  
    
      Forbes
      GitHub code now has ‘data residency’ in Australia
    
    Feb 5, 2025


      
  
    
      Accessibility and GenAI 
      Ep 5 - Ed Summers - Head of Accessibility, GitHub
    
    Feb 4, 2025


      
  
    
      FAZ
      DLD: Technologien und Talente prägen den Arbeitsmarkt im KI-Zeitalter
    
    Jan 22, 2025


      
  
    
      Financial Express
      ‘Where developers reside, innovation blooms’
    
    Jan 20, 2025


      
  
    
      Inforchannel
      GitHub anuncia três tendências de desenvolvimento de software para 2025
    
    Jan 17, 2025


      
  
    
      Help Net Security 
      GitHub CISO on security strategy and collaborating with the open source community
    
    Jan 13, 2025


  

    
      
        Previous 1 2 3 4 5 … 58 59 Next\n\n\n\nPoliciesThese are the legal policies of npm, Inc.
Terms of UseOpen Source TermsPrivate TermsCode of ConductPackage Name Disputesnpm LicensePrivacy PolicyUnpublish PolicyCopyright and DMCA PolicyLogos and UsageSecurityReplication and web crawler policy
These are updated from time to time. Their sources are stored in a git repository at https://github.com/npm/documentation/tree/main/content/policies.\n\n\n\nPoliciesTerms of UseTerms and LicensesSee DetailsTable of contentsSoftware from npmFree to use npm servicesPaid npm servicesnpm, Inc. offers software and services under a few different licenses and terms of use.
Software from npm
License terms and notices for the npm command-line program can be found in the LICENSE file of the project's source code at https://www.github.com/npm/cli.
Free to use npm services
Free usage of https://www.npmjs.com, and the npm public registry are covered by the npm Open Source Terms at https://docs.npmjs.com/policies/open-source-terms. These terms include several important policies, including:


What npm considers acceptable package content.


npm's Code of Conduct, which includes our policy on harassment.


npm's Privacy Policy, which limits use and sharing of information about you collected by npm Services.


npm's policy on copyright including how to report violations thereof.


npm's Dispute Policy which addresses how to resolve disputes over the control of a package name, user name, or organization name in the Public Registry. This includes our policy on users "squatting" on these names.


Use of npm's trademarks is governed by our Trademark Policy. If you have concerns about your own trademark's use on npm please see our Disputes Policy.


Paid npm services
npm's paid products, including the npm Solo and Orgs plans, are covered by the npm Paid Services Terms at https://docs.npmjs.com/policies/private-terms.
The npm Solo Payment Plan and the npm Orgs Payment Plan govern payment for these services.\n\n\n\nPoliciesCode of Conductnpm Code of ConductSee DetailsTable of contentstl;drScopeFriendly Harassment-Free SpaceAcceptable UseReporting Violations of this Code of ConductConsequencesAppeal and ReinstatementContact InfoChangesCredit and Licensenpm exists to facilitate sharing code, by making it easy for JavaScript module developers to publish and distribute packages.
npm is a piece of technology, but more importantly, it is a community.
We believe that our mission is best served in an environment that is friendly, safe, and accepting; free from intimidation or harassment.
Towards this end, certain behaviors and practices will not be tolerated.
tl;dr

Be respectful.
We're here to help
Abusive behavior is never tolerated.
Data published to npm is hosted at the discretion of the service administrators, and may be removed.
Violations of this code may result in swift and permanent expulsion from the npm community.

Scope
We expect all members of the npm community, including paid and unpaid agents, administrators, users, and customers of npm, Inc., to abide by this Code of Conduct at all times in all npm community venues, online and in person, and in one-on-one communications pertaining to npm affairs.
This policy covers the usage of the npm registry, as well as the npm website, npm related events, and any other services offered by or on behalf of npm, Inc. (collectively, the "Service"). It also applies to behavior in the context of the npm Open Source project communities, including but not limited to public GitHub repositories, IRC channels, social media, mailing lists, and public events.
This Code of Conduct is in addition to, and does not in any way nullify or invalidate, any other terms or conditions related to use of the Service.
The definitions of various subjective terms such as "discriminatory", "hateful", or "confusing" will be decided at the sole discretion of the npm abuse team.
Friendly Harassment-Free Space
We are committed to providing a friendly, safe and welcoming environment for all, regardless of gender identity, sexual orientation, ability, ethnicity, religion, age, physical appearance, body size, race, or similar personal characteristics.
We ask that you please respect that people have differences of opinion regarding technical choices, and that every design or implementation choice carries a trade-off and numerous costs. There is seldom a single right answer. A difference of technology preferences is not a license to be rude.
Disputes over package rights must be handled respectfully, according to the terms described in the Disputes Policy. There is never a good reason to be rude over package name disputes.
Any spamming, trolling, flaming, baiting, or other attention-stealing behavior is not welcome, and will not be tolerated.
Harassing other users of the Service is never tolerated, whether via public or private media.
Avoid using offensive or harassing package names, nicknames, or other identifiers that might detract from a friendly, safe, and welcoming environment for all.
Harassment includes, but is not limited to: harmful or prejudicial verbal or written comments related to gender identity, sexual orientation, ability, ethnicity, religion, age, physical appearance, body size, race, or similar personal characteristics; inappropriate use of nudity, sexual images, and/or sexually explicit language in public spaces; threats of physical or non-physical harm; deliberate intimidation, stalking or following; harassing photography or recording; sustained disruption of talks or other events; inappropriate physical contact; and unwelcome sexual attention.
Acceptable Use
The Service administrators reserve the right to make judgment calls about what is and isn't appropriate in published packages, package names, user and organization names, and other public content. Package that violates the npm Service's Acceptable Use rules including its Acceptable Content rules will be deleted, at the discretion of npm.
Reporting Violations of this Code of Conduct
Please select the method of contact you think is most appropriate for the form of violation:


For urgent security issues, please open a ticket at https://npmjs.com/support. Requests to un-publish packages are not usually considered urgent security issues, as it is possible to un-publish a package within 24 hours of its first publish. Any publicly published package is immediately replicated to thousands of third-party mirrors, so any confidential information contained in a package should be considered immediately compromised.


If you believe someone is harassing you or is demonstrating some other form of malicious or inappropriate behavior, open a support ticket at https://npmjs.com/support. If this is the initial report of a problem, please include as much detail as possible. It is easiest for us to address issues when we have more context.


If you have concerns about a potential copyright violation, please refer to our Copyright Policy and take action as recommended by that policy.


If you think a package or other content is "squatting" on a name, follow the process described in the Disputes Policy.


For any other issues, or if in doubt, contact support.
Consequences
All content published to the Service, including user account credentials, is hosted at the sole discretion of the npm administrators.
Unacceptable behavior from any community member, including sponsors, employees, customers, or others with decision-making authority, will not be tolerated.
Anyone asked to stop unacceptable behavior is expected to comply immediately.
If a community member engages in unacceptable behavior, the npm administrators may take any action they deem appropriate, up to and including a temporary ban or permanent expulsion from the community without warning (and without refund in the case of a paid event or service).
Appeal and Reinstatement
If your content or account has been disabled or restricted and you seek reinstatement or wish to appeal, please review GitHub's Appeal and Reinstatement page for information about the process and use the Appeal and Reinstatement form to submit a request.
Contact Info
Please open a support ticket at https://npmjs.com/support if you need to report a problem or address a grievance related to an abuse report.
You are also encouraged to contact us if you are curious about something that might be "on the line" between appropriate and inappropriate content. We are happy to provide guidance to help you be a successful part of our community.
Changes
This is a living document and may be updated from time to time. Please refer to the git history for this document to view the changes.
Credit and License
This Code of Conduct borrows heavily from the Stumptown Syndicate Citizen's Code of Conduct, and the Rust Project Code of Conduct.
This document may be reused under a Creative Commons Attribution-ShareAlike License.\n\n\n\nPoliciesPrivacy PolicyPrivacy Questions and AnswersSee DetailsTable of contentsWhat's most important?How does npm collect data about me?What data does npm collect about me, and why?npm collects data about how you use npm software and registriesnpm collects data about how you use the websitenpm collects account datanpm collects package datanpm collects payment card datanpm collects data about correspondencenpm collects data about use of npm.communityDoes npm share data about me with others?npm uses cookiesHow can I make choices about data collection?Where does npm keep data about me?How does npm handle data under the EU General Data Protection Regulation?How does npm handle data under the California Consumer Privacy Act?How can I see what data is publicly available about me?How can I change data about me?What is npm's policy on unpublishing packages?How does npm notify others about published data that's erased?What happens if npm merges with or is bought by another company?What are npm's information practices regarding information belonging to children?Who can I contact about npm and my privacy?How can I find out about changes?This notice describes how npm, Inc., or npm for short, collects and uses data about you.
What's most important?
That depends on your personal situation, which is why you should read on and decide for yourself. But at a minimum, absolutely every npm user should understand:
The npm public registry is for making software available to everyone online.
But: Software comes from people, and says something about us.
So: Think carefully about what packages to publish, what data you put in those packages, and what others might do with that data.
When you create an account, certain contact information is displayed publicly in the npm platform. And when you upload a package, your name and contact information may become associated with that package.
If you find yourself in a jam, open a support ticket.
How does npm collect data about me?
npm collects data about you:


when you use the npm command, the npx command or another program to access the npm public registry, Enterprise registries that npm hosts, private packages, such as when you're publishing a software package, and APIs for functionality like account and permissions management


when you browse the npm website, npmjs.com


when you use either the npm command or the website to create an npm account, update your account, and sign up for npm services


when you send support, privacy, legal, and other requests to npm


when working with and researching current and potential customers


When researching potential customers, npm staff sometimes search the public World Wide Web or paid business databases. Otherwise, npm doesn't buy or receive data about you from data brokers or other private services.
npm may inadvertently collect data about you if it is included in software packages that you or others upload.
What data does npm collect about me, and why?
npm collects data about how you use npm software and registries
When you use the npm command, the npx command, or other software to work with the npm public registry, an Enterprise registry that npm hosts, or private packages, npm logs data that might be identified to you:


a random, unique identifier, called npm-session, for each time you run commands like npm install


the names and versions of your project's dependencies, their dependencies, and so on, that come from the npm public registry, but not of other dependencies, like Git dependencies


the versions of Node.js, the npm command, and the operating system you are using


an npm-in-ci header, showing whether the command was run on a continuous integration server


the scope of the package for which you ran npm install, as an npm-scope header


a referrer header that shows the command you ran, with any file or directory paths redacted


data about the software you're using to access the registry, such as the User-Agent string


network request data, such as the date and time, your IP address, and the URL


npm uses this data to:


fulfill your requests, such as by sending the packages you ask for


send you alerts about security vulnerabilities that may affect the software you're building, when you run npm install or npm audit


keep registries working quickly and reliably


debug and develop the npm command and other software


defend registries from abuse and technical attacks


compile statistics on package usage and popularity


prepare reports on trends in the developer community


improve search results on the website


recommend packages that may be relevant to your work


npm collects data about how you use the website
When you visit www.npmjs.com, docs.npmjs.com, and other npm websites, npm uses cookies, server logs, and other methods to collect data about what pages you visit, and when. npm also collects technical information about the software and computer you use, such as:


your IP address


your preferred language


the web browser software you use


the kind of computer you use


the website that referred you


npm uses data about how you use the website to:


optimize the website, so that it's quick and easy to use


diagnose and debug technical errors


defend the website from abuse and technical attacks


compile statistics on package popularity


compile statistics on the kinds of software and computers visitors use


compile statistics on visitor searches and needs, to guide development of new website pages and functionality


decide who to contact about about product announcements, service changes, and new features


npm collects account data
Many features of npm services require an npm account. For example, you must have an npm account to publish packages to the npm public registry.
To create an npm account, npm requires a working email address and an available user name. npm uses this data to provide you access to features and identify you across npm services, publicly and within npm.
You do not have to give your personal or legal name to create an npm account. You can use a pseudonym instead. You can also open more than one account.
If you sign up for an account, then npm will publish account data for the whole world to see on user pages like this one. npm also publishes account data through the npm public registry, which is available for everyone to see, and Enterprise registries that npm hosts for others to find with commands like npm owner ls tap.
If you give npm a personal name or names on social media like GitHub and Twitter through the website, like when you include this on your profile or user page, npm publishes that data along with the email address and user name for the account. You don't have to give npm a personal name or any social media names, and you can remove this data at any time by updating your user page.
npm uses your email to:


notify you about packages published using your account


reset your password and help keep your account secure


add metadata to packages that you publish


contact you in special circumstances related to your account or packages


contact you about support requests


contact you about legal requests, like DMCA takedown requests and privacy complaints


announce new npm product offerings, service changes, and features


send you tips about how to better use free and paid services


send you messages about paid services you might want


npm collects package data
When you use npm publish or other software to publish packages to the npm public registry, an Enterprise registry that npm hosts, or as a private package, npm collects the contents of the package, plus metadata, including your account data. Other npm users may also publish packages that include data about you, such as the fact that you contributed code to a package.
npm uses data in packages to provide those packages to you and others who request them:


When you publish a package to the npm public registry, or change a package from private to public, npm makes the package and metadata available to everyone, online.


When you publish a package to an Enterprise registry that npm hosts, or as a private package, npm makes all of that data available to other users according to how the registry or the private packages account is configured. You may be able to configure who can access the package, or that may be up to others, such as the administrator of your company's Enterprise registry.


Making package data available to others allows them to download, build on, and depend on your work.
npm collects payment card data
To sign up for paid services, npm requires your payment card data. npm itself does not collect or store enough information to charge your card itself. Rather, Stripe collects that data on npm's behalf, and gives npm security tokens that allow npm to create charges and subscriptions.
npm uses your payment card data only to charge for npm services.
npm instructs Stripe to store your payment card data only as long as you use paid npm services.
npm collects data about correspondence
npm collects data about you when you send npm support requests, legal complaints, privacy inquiries, and business inquiries. Those data usually include your name and email address, and may include your company or other affiliation.
npm uses contact data to:


respond to you


compile aggregate statistics about correspondence


train support staff and other npm personnel


review the performance of npm personnel who respond


defend npm from legal claims


npm collects data about use of npm.community
npm collects data about visits, user accounts, and forum data on npm.community, the discussion forum for users of npm products and services. npm uses data from npm.community to collaborate with the development community, and to inform development decisions about the command-line interface and other software.
Does npm share data about me with others?
npm shares account data with others as mentioned in the section about account data.
npm shares package data with others as mentioned in the section about package data.
npm publishes posts and other content you submit to npm.community.
npm does not sell information about you to others. However, npm uses services provided by other companies to provide npm services. The types of service providers that npm uses include:


Companies that enable us to offer features on our website, such as to display your avatar


Companies that facilitate the efficient distribution of content


Cloud computing platforms and services that host our discussion forums


Services that assist with the detection of spam, scams, abuse others, or other violations of our terms of service


Payment processors


Platforms to help us receive, manage, and respond to support requests


Platforms for internal communication


npm uses cookies
npm's website only uses cookies strictly necessary to provide, optimize and secure the website. For example, we use them to keep you logged in, remember your preferences, authenticate your device for security purposes, analyze your use of the service, compile statistical reports, and provide information for future development of npm. The website uses internal cookies for analytics purposes, not any third-party analytics or service providers.
By using the website, you agree that we can place these types of cookies on your computer or device. If you disable your browser or device’s ability to accept these cookies, you will not be able to log in or use the website.
How can I make choices about data collection?
You choose what data the npm publish command includes in package data. You can use an .npmignore file in your package to keep specific files out of the package. You can also use a files list in package.json files to instruct npm to include only specific files that you name, in addition to standard files like README files, LICENSE files, and package.json.
To double check the data that you will share in a package that you plan to publish, run the npm publish --dry-run command. If you are running an older version of the npm command, run the npm pack command to create a tarball, then check its contents, such as with tar tvzf $tarball.
To publish a package to the npm public registry, npm's terms of service require you to license npm to share it. If a package is made public, it is available for everyone online to see. However, your choice of public license for your package may affect what others can do with data about you in your package.
npm does not respond to the Do Not Track HTTP header.
Where does npm keep data about me?
npm stores account data, data about website use, data about registry use, and private packages on servers in the United States of America. metadata about those packages worldwide, via content delivery networks.
npm stores package data published to Enterprise registries that npm hosts, plus metadata about them, in cloud computing zones of customers' choosing.
By using the npm platform, you consent to the collection and storage of your data as outlined in this section.
How does npm handle data under the EU General Data Protection Regulation?
npm respects privacy rights under Regulation (EU) 2016/679, the European Union's General Data Protection Regulation (GDPR). npm processes "Personal Data" on the following legal bases: (1) with your consent; (2) as necessary to perform our agreement to provide our services; and (3) as necessary for our legitimate interests in providing our services where those interests do not override your fundamental rights and freedom related to data privacy. Information we collect may be transferred to, and stored and processed in, the United States or any other country in which we or our affiliates or subcontractors maintain facilities, as described above.
If you reside in the EEA, Switzerland, or United Kingdom, you are entitled to certain rights, like the right to:


complain about our data collection or processing actions with the supervisor authority concerned. You can find a list of data protection authorities here.


access to information held about you.


ask us to correct or amend inaccurate or incomplete information we have about you.


ask us to erase data that under certain circumstances, like (1) when it is no longer necessary for the purpose for which it was collected, (2) you withdraw consent and no other legal basis for processing exists, or (3) you believe your fundamental rights to data privacy and protection outweigh our legitimate interest in continuing the processing.


request that we restrict our processing if we are processing your data based on legitimate interests or the performance of a task in the public interest as an exercise of official authority (including profiling); using your data for direct marketing (including profiling); or processing your data for purposes of scientific or historical research and statistics.


When you exercise your rights, npm may need to verify your identity and provide us with information before we access records containing your information. If you want to exercise your rights, please contact npm by opening a support ticket. We may have a reason under the law why we do not have to comply with your request or may comply with it in a more limited way than you anticipated. If we do, we will explain that to you in our response.
How does npm handle data under the California Consumer Privacy Act?
npm respects the rights of California residents under the California Consumer Privacy Act (CCPA). Where we collect information that is subject to the CCPA, that information we collect and your rights are described below.
Categories of personal information we collect:


Personal Identifiers:


Name and email address when you create an account. You will also be asked to create a username and we will assign one or more unique identifiers to your profile. We use this information to provide our services, respond to your requests, and send information to you.


We also collect your social media handle and basic account information if you provide it to us or interact with our services, such as our help desk, through social media.


We collect your payment information through our service provider, Stripe, as described above.




Internet or Other Electronic Network Activity Information: device identifiers such as IP address and user agent; the assigned unique IDs in cookies (as described below); information about how you arrived at and navigated through our Services.


Geolocation Data: We do not collect your specific longitude and latitude. However, we do collect imprecise location (e.g., your IP address).


Professional or employment-related information: If you apply for employment with us, information about your employment history.


Education information: If you apply for employment with us, information about your educational history.


We may collect any other information about you contained in software packages uploaded to our site, as described above under the "npm collects package data" section. We also collect the contents of your communications with us, e.g., when you submit a question to us through a web form or comments to us on social media.
We may disclose any of the categories of personal information listed above and use them for the above-listed purposes or for other business or operational purposes compatible with the context in which the personal information was collected. Our disclosures of personal information include disclosures to our "service providers," which are companies that we engage for business purposes to conduct activities on our behalf. The categories of service providers with whom we share information and the services they provide are described below.
Rights under CCPA:


Access/Right to Know: You have the right to request access to personal information we collected about you and information regarding the source of that personal information, the purposes for which we collect it, and the third parties and service providers with whom we share it.


Deletion: You have the right to request that we erase data we have collected from you. Please note that we may have a reason to deny your deletion request or delete data in a more limited way than you anticipated, e.g., because of a legal obligation to retain it.


To exercise your rights above, you can open a support ticket. When we process your request, we must verify your identity by asking you to (1) provide personal identifiers that we can match against information we may have collected from you previously; and (2) confirm your request using the email stated in the request.
Opt-out of sale:
California residents have the right to request that we stop "selling" their personal information. A "sale" of personal information is defined broadly: "selling, renting, releasing, disclosing, disseminating, making available, transferring, or otherwise communicating orally, in writing, or by electronic or other means, a consumer's personal information by the business to another business or a third party for monetary or other valuable consideration." We do not sell your information as defined by the CCPA.
Please note that your right to opt out does not apply to our sharing of personal information with service providers, who are parties we engage to perform a function on our behalf and are contractually obligated to use the Personal Information only for that function.
We may also disclose information to other entities who are not listed here when required by law or to protect our Company or other persons, as described in our Privacy Policy.
How can I see what data is publicly available about me?
You can access your account data at any time by visiting your account page on www.npmjs.com. Your account page also lists all the packages published under your account or other accounts.
You can access package data by downloading the packages, as long as they're public or you have permission to access them.
You can see metadata about packages by running npm info $package, or by accessing the appropriate registry's API. Registry APIs provide metadata in standard JSON format, and packages as tarballs.
How can I change data about me?
You can change your personal account data and payment card data at any time by visiting your account settings page on www.npmjs.com. You can change account and payment data for Enterprise by contacting support.
You can close your npm account at any time by e-mailing contacting support. Closing your account removes the profile from the public registry but does not automatically erase packages published under your account. We may retain some data about you internally even where you close your account.
npm's unpublish policy determines when you can erase packages from the npm public registry. The unpublish policy strikes a difficult balance between the purpose of publishing and hosting packages, others' reliance on what has been made public, and individual rights and freedoms.
If another user improperly publishes personal data about you, in a package or otherwise, open a support ticket.
Please note that while npm publishes notices about published data that's been erased, npm can't make everyone who has downloaded published package data or account data erase that data on your behalf. Choosing a public license, such as an open source software license, may encourage and allow storage, distribution, and use of package data indefinitely. Nearly all popular open source software licenses actually require preserving personal data that attributes the software to you, such as copyright notices, as a condition of permission for the software.
What is npm's policy on unpublishing packages?
Please see our policy on "unpublishing" packages or our terms of service for more information on erasing packages.
If you accidentally publish a package that threatens your privacy, or discover someone else has published a package that does, open a support ticket. npm can and will take down packages in specific, exceptional situations to protect you, especially if others violate your privacy. Using npm to violate others' privacy is against our terms of service.
How does npm notify others about published data that's erased?
npm takes a few steps to notify others who may be copying data from the npm public registry that published data has been erased:


npm publishes new placeholder versions of some erased packages, with README files that mention the package has been erased, and why.


npm's registry APIs, special software services that others use to copy data from the npm public registry, send update messages about packages that have been erased.


What happens if npm merges with or is bought by another company?
We may transfer to another entity or its affiliates or service providers some or all information about you in connection with, or during negotiations of, any merger, acquisition, sale of assets or any line of business, change in ownership control, or financing transaction. We cannot promise that an acquiring party or the merged entity will have the same privacy practices or treat your information the same as described in this Policy.
What are npm's information practices regarding information belonging to children?
npm's site and services are intended for users age sixteen and older. npm does not knowingly collect information from children. If we discover that we have inadvertently collected information from anyone younger than the age of 16, we will delete that information.
Who can I contact about npm and my privacy?
Please open a support ticket. You may also contact our Data Protection Officer directly.
Our United States HQ:
GitHub Data Protection Officer
Attention: npm Data Protection
88 Colin P. Kelly Jr. St.
San Francisco, CA 94107
United States
or our EU Office:
GitHub BV
Vijzelstraat 68-72
1017 HL Amsterdam
The Netherlands
How can I find out about changes?
This version of npm's privacy questions and answers took effect June 3, 2020.
npm will announce the next version on the npm blog. In the meantime, npm may update its contact information by updating the page at https://docs.npmjs.com/privacy, without an announcement. npm may change how it announces changes in future privacy versions.
You can review the history of changes in the Git repository for npm's public policies.\n\n\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\n\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\n\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\n\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\n\n\nSign InUsernameForgot password?PasswordShowSign InCreate Account\n\nSign InUsernameForgot password?PasswordShowSign InCreate Account\n\n\n\n