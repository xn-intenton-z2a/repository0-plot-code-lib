Documentation
                

                Table of Contents
    
        
                
                    
                    Use ESLint in Your Project
            		

                    Extend ESLint
            		

                    Integrate ESLint
            		

                    Contribute to ESLint
            		

                    Maintain ESLint
            		
                
            
    


                Welcome to our documentation pages! What would you like to view?
Use ESLint in Your Project
Intended for end users of ESLint. Contains information about core rules, configuration, command line options, formatters, and integrations,
as well as guides for migrating from earlier versions of ESLint.
Extend ESLint
Intended for people who wish to extend ESLint. Contains information about creating custom rules, configurations, plugins, and formatters.
Integrate ESLint
Intended for people who wish to create integrations with ESLint. Contains information about creating integrations and using the Node.js API.
Contribute to ESLint
Intended for people who wish to contribute to the ESLint project. Contains information about ways you can contribute, the project structure, and setting up the development environment.
Maintain ESLint
Intended for maintainers of ESLint.

            

            
                Edit this page\n\nDocumentation
                

                Table of Contents
    
        
                
                    
                    Use ESLint in Your Project
            		

                    Extend ESLint
            		

                    Integrate ESLint
            		

                    Contribute to ESLint
            		

                    Maintain ESLint
            		
                
            
    


                Welcome to our documentation pages! What would you like to view?
Use ESLint in Your Project
Intended for end users of ESLint. Contains information about core rules, configuration, command line options, formatters, and integrations,
as well as guides for migrating from earlier versions of ESLint.
Extend ESLint
Intended for people who wish to extend ESLint. Contains information about creating custom rules, configurations, plugins, and formatters.
Integrate ESLint
Intended for people who wish to create integrations with ESLint. Contains information about creating integrations and using the Node.js API.
Contribute to ESLint
Intended for people who wish to contribute to the ESLint project. Contains information about ways you can contribute, the project structure, and setting up the development environment.
Maintain ESLint
Intended for maintainers of ESLint.

            

            
                Edit this page\n\n\n\nDocumentation
                

                Table of Contents
    
        
                
                    
                    Use ESLint in Your Project
            		

                    Extend ESLint
            		

                    Integrate ESLint
            		

                    Contribute to ESLint
            		

                    Maintain ESLint
            		
                
            
    


                Welcome to our documentation pages! What would you like to view?
Use ESLint in Your Project
Intended for end users of ESLint. Contains information about core rules, configuration, command line options, formatters, and integrations,
as well as guides for migrating from earlier versions of ESLint.
Extend ESLint
Intended for people who wish to extend ESLint. Contains information about creating custom rules, configurations, plugins, and formatters.
Integrate ESLint
Intended for people who wish to create integrations with ESLint. Contains information about creating integrations and using the Node.js API.
Contribute to ESLint
Intended for people who wish to contribute to the ESLint project. Contains information about ways you can contribute, the project structure, and setting up the development environment.
Maintain ESLint
Intended for maintainers of ESLint.

            

            
                Edit this page\n\nDocumentation
                

                Table of Contents
    
        
                
                    
                    Use ESLint in Your Project
            		

                    Extend ESLint
            		

                    Integrate ESLint
            		

                    Contribute to ESLint
            		

                    Maintain ESLint
            		
                
            
    


                Welcome to our documentation pages! What would you like to view?
Use ESLint in Your Project
Intended for end users of ESLint. Contains information about core rules, configuration, command line options, formatters, and integrations,
as well as guides for migrating from earlier versions of ESLint.
Extend ESLint
Intended for people who wish to extend ESLint. Contains information about creating custom rules, configurations, plugins, and formatters.
Integrate ESLint
Intended for people who wish to create integrations with ESLint. Contains information about creating integrations and using the Node.js API.
Contribute to ESLint
Intended for people who wish to contribute to the ESLint project. Contains information about ways you can contribute, the project structure, and setting up the development environment.
Maintain ESLint
Intended for maintainers of ESLint.

            

            
                Edit this page\n\n\n\nFind issues
                    ESLint statically analyzes your code to quickly find problems. ESLint is built into most text editors and you can run ESLint as part of your continuous integration pipeline.

                    
                        Learn more about finding issues with ESLint

                        

                    
                
                    Fix problems automatically
                    Many problems ESLint finds can be automatically fixed. ESLint fixes are syntax-aware so you won't experience errors introduced by traditional find-and-replace algorithms.

                    
                        Learn more about fixing problems automatically with ESLint

                        

                    
                
                    Configure everything
                    Preprocess code, use custom parsers, and write your own rules that work alongside ESLint's built-in rules. Customize ESLint to work exactly the way you need it for your project.

                    
                        Learn more about configuring ESLint

                        

                    
                
    
        
            
                Published under: Announcements
            
            
                3 min read
            
        

        
            
                Introducing bulk suppressions
        
        
            How to enable stricter linting incrementally
        
        
            
            
            
                Iacovos Constantinou
                04 Apr, 2025
            
        
    

    
        
            
                Published under: Release Notes
            
            
                3 min read
            
        

        
            
                ESLint v9.24.0 released
        
        
            We just pushed ESLint v9.24.0, which is a minor release upgrade of ESLint. This release adds some new features and fixes several bugs found in the previous release.
        
        
            
            
            
                Milos Djermanovic
                04 Apr, 2025
            
        
    

    
        
            
                Published under: Release Notes
            
            
                3 min read
            
        

        
            
                ESLint v9.23.0 released
        
        
            We just pushed ESLint v9.23.0, which is a minor release upgrade of ESLint. This release adds some new features and fixes several bugs found in the previous release.
        
        
            
            
            
                Francesco Trotta
                21 Mar, 2025\n\nFind and fix problems in your JavaScript code
                        
  
  
  
    
  
  

    
      
        Find
      
    
      
        and
      
    
      
        fix
      
    
      
        
          problems
          
            
            
            
          
        
      
    
      
        in
      
    
      
        your
      
    
      
        JavaScript
      
    
      
        code
      
    
  


                    
                    
                        ESLint statically analyzes your code to quickly find problems. It is built into most text editors and you can run ESLint as part of your continuous integration pipeline.

                    
                
                
                    
                        ESLint quick install code
                        
                            ESLint quick install code
                            
                        
                        
                    
                    
                
                
                    Get Started
                    Become a Sponsor
                

                

                
                    Sponsored by:
                    
                        
                        
                            
                        
                        
                        
                            
                        
                        
                        
                            
                        
                        
                        
                            
                        
                        
                        
                            
                        
                        
                        
                            
                        
                        
                        and more...
                    
                
            
        
        
            
                






            
            
                
                    ESLint Versions
                    Latest Version
                    
                        
                        
                        
                        v9.24.0 on 4 Apr
                    
                    
                    Upcoming Version
                    
                        
                        
                        
                        v9.25.0 on 18 Apr
                    
                    Development
                    
                        
                        

                        
                        HEAD on 16 Apr
                    
                
                Version Support
            
        
    



    
        
            The pluggable linting utility for JavaScript and JSX
            
                ESLint is an open source project that helps you find and fix problems with your JavaScript code. It doesn't matter if you're writing JavaScript in the browser or on the server, with or without a framework, ESLint can help your code live its best life.

            
        
        
            
                    Find issues
                    ESLint statically analyzes your code to quickly find problems. ESLint is built into most text editors and you can run ESLint as part of your continuous integration pipeline.

                    
                        Learn more about finding issues with ESLint

                        

                    
                
                    Fix problems automatically
                    Many problems ESLint finds can be automatically fixed. ESLint fixes are syntax-aware so you won't experience errors introduced by traditional find-and-replace algorithms.

                    
                        Learn more about fixing problems automatically with ESLint

                        

                    
                
                    Configure everything
                    Preprocess code, use custom parsers, and write your own rules that work alongside ESLint's built-in rules. Customize ESLint to work exactly the way you need it for your project.

                    
                        Learn more about configuring ESLint

                        

                    
                

            
                
            
        
    



    
        
            News and Updates
            
                The latest ESLint news, case studies, tutorials, and resources.
            
        
        
            
            
            
            
            

            
            
            

            
    
        
            
                Published under: Announcements
            
            
                3 min read
            
        

        
            
                Introducing bulk suppressions
        
        
            How to enable stricter linting incrementally
        
        
            
            
            
                Iacovos Constantinou
                04 Apr, 2025
            
        
    

            
            
            
            
            

            
            
            

            
    
        
            
                Published under: Release Notes
            
            
                3 min read
            
        

        
            
                ESLint v9.24.0 released
        
        
            We just pushed ESLint v9.24.0, which is a minor release upgrade of ESLint. This release adds some new features and fixes several bugs found in the previous release.
        
        
            
            
            
                Milos Djermanovic
                04 Apr, 2025
            
        
    

            
            
            
            
            

            
            
            

            
    
        
            
                Published under: Release Notes
            
            
                3 min read
            
        

        
            
                ESLint v9.23.0 released
        
        
            We just pushed ESLint v9.23.0, which is a minor release upgrade of ESLint. This release adds some new features and fixes several bugs found in the previous release.
        
        
            
            
            
                Francesco Trotta
                21 Mar, 2025
            
        
    

            
        

        
            View all posts
        
    



    
        
            Welcome to the community
            
            
            
                ESLint is the #1 JavaScript linter by downloads on npm (over 53.0M downloads / week) and is used at companies like Microsoft, Airbnb, Netflix, and Facebook.

            
        
        
            
                26.0M
                Dependents
            
            
                53.0M
                Weekly Downloads
            
            
                25.8K
                Stars
            
        
    



    
        
            Sponsored by fantastic people
            
            
            
                We receive $213,484.47 / year in donations from 184 sponsors.

            
        
        
            
                
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                
                
                
                    
                    
                    
                    
                        
                    
                    
                    
                
                
                
                    
                    
                    
                    
                        
                    
                    
                    
                
                
                
                    
                    
                    
                    
                        
                    
                    
                    
                
                
            
            View all sponsors
        
        
            
                Recent One-time Donations

                
                    
                    
                        
                        
                        
                        
                        

                        

    

    
        Raul Silveira
        April 15, 2025
    

    
        + $1.00
    

                    
                    
                    
                        
                        
                        
                        
                        

                        

    

    
        Rafael Vaz
        April 11, 2025
    

    
        + $5.00
    

                    
                    
                    
                        
                        
                        
                        
                        

                        

    

    
        Rafael Vaz
        April 10, 2025
    

    
        + $5.00
    

                    
                    
                    
                        
                        
                        
                        
                        

                        

    

    
        HolyFata
        April 8, 2025
    

    
        + $5.00
    

                    
                    
                    
                        
                        
                        
                        
                        

                        

    

    
        heliosfr
        April 7, 2025
    

    
        + $5.00
    

                    
                    
                    
                        
                        
                        
                        
                        

                        

    

    
        Peter Dave Hello
        March 26, 2025
    

    
        + $1.00
    

                    
                    
                
            
            
                View all donations
            
        
    




    testimonials
    
        
    
        
                
                    
                        ESLint has been critical in helping developers write high-quality JavaScript for years. We love that it catches common issues early and often. With a high level of extensibility, ESLint's ability to let teams enforce custom rules that work for them has been excellent for open-source projects and more. Chrome is happy to sponsor ESLint to help web developers write consistently high-quality code. It's an essential piece of the modern web development toolkit.

                    
                    
                        
                            
                            
                                Addy Osmani
                                Senior Staff Eng. Manager, Chrome
                            
                        
                    
                
                
                    
                        
                        
                        
                    
                
            
                
                    
                        Nx uses ESLint to enforce code quality, library boundaries, and project visibility constraints. ESLint makes Nx more powerful, so on behalf of the Nx.dev community, we're proud to do our part and sponsor ESLint's continued success!

                    
                    
                        
                            
                            
                                Jeff Cross
                                Co-founder and Principal Architect, Nx
                            
                        
                    
                
                
                    
                        
                        
                        
                    
                
            
                
                    
                        ESLint is an extremely useful tool for any JavaScript project. This tool allows us to set up consistent code formatting rules adopted by the whole team from the beginning of the project, greatly facilitates code reviews, and makes it easy to integrate new developers into the team. I know I am not alone in appreciating its flexibility and ease-of-use.

                    
                    
                        
                            
                            
                                Médédé Raymond KPATCHAA
                                Technical Architect, Salesforce
                            
                        
                    
                
                
                    
                        
                        
                        
                    
                
            
                
                    
                        Most JavaScript projects directly or transitively depend on ESLint. An Indeed employee nominated ESLint to receive a donation from the FOSS Contributor Fund, and their colleagues clearly agreed. We're happy to support the open source technologies that allow us to develop, protect, and maintain the digital infrastructure that supports our products and helps people get jobs.

                    
                    
                        
                            
                            
                                Duane O'Brien
                                Head of Open Source, Indeed
                            
                        
                    
                
                
                    
                        
                        
                        
                    
                
            
                
                    
                        ESLint plays a major role in helping us create a safe and consistent experience across a growing number of codebases and engineers. We are grateful for all the open-source projects that are helping us build Contra, and ESLint is the first of many open-source projects that we are committed to back.

                    
                    
                        
                            
                            
                                Gajus Kuizinas
                                Co-Founder / CTO, Contra\n\nFind and fix problems in your JavaScript code
                        
  
  
  
    
  
  

    
      
        Find
      
    
      
        and
      
    
      
        fix
      
    
      
        
          problems
          
            
            
            
          
        
      
    
      
        in
      
    
      
        your
      
    
      
        JavaScript
      
    
      
        code
      
    
  


                    
                    
                        ESLint statically analyzes your code to quickly find problems. It is built into most text editors and you can run ESLint as part of your continuous integration pipeline.

                    
                
                
                    
                        ESLint quick install code
                        
                            ESLint quick install code
                            
                        
                        
                    
                    
                
                
                    Get Started
                    Become a Sponsor
                

                

                
                    Sponsored by:
                    
                        
                        
                            
                        
                        
                        
                            
                        
                        
                        
                            
                        
                        
                        
                            
                        
                        
                        
                            
                        
                        
                        
                            
                        
                        
                        and more...
                    
                
            
        
        
            
                






            
            
                
                    ESLint Versions
                    Latest Version
                    
                        
                        
                        
                        v9.24.0 on 4 Apr
                    
                    
                    Upcoming Version
                    
                        
                        
                        
                        v9.25.0 on 18 Apr
                    
                    Development
                    
                        
                        

                        
                        HEAD on 16 Apr
                    
                
                Version Support
            
        
    



    
        
            The pluggable linting utility for JavaScript and JSX
            
                ESLint is an open source project that helps you find and fix problems with your JavaScript code. It doesn't matter if you're writing JavaScript in the browser or on the server, with or without a framework, ESLint can help your code live its best life.

            
        
        
            
                    Find issues
                    ESLint statically analyzes your code to quickly find problems. ESLint is built into most text editors and you can run ESLint as part of your continuous integration pipeline.

                    
                        Learn more about finding issues with ESLint

                        

                    
                
                    Fix problems automatically
                    Many problems ESLint finds can be automatically fixed. ESLint fixes are syntax-aware so you won't experience errors introduced by traditional find-and-replace algorithms.

                    
                        Learn more about fixing problems automatically with ESLint

                        

                    
                
                    Configure everything
                    Preprocess code, use custom parsers, and write your own rules that work alongside ESLint's built-in rules. Customize ESLint to work exactly the way you need it for your project.

                    
                        Learn more about configuring ESLint

                        

                    
                

            
                
            
        
    



    
        
            News and Updates
            
                The latest ESLint news, case studies, tutorials, and resources.
            
        
        
            
            
            
            
            

            
            
            

            
    
        
            
                Published under: Announcements
            
            
                3 min read
            
        

        
            
                Introducing bulk suppressions
        
        
            How to enable stricter linting incrementally
        
        
            
            
            
                Iacovos Constantinou
                04 Apr, 2025
            
        
    

            
            
            
            
            

            
            
            

            
    
        
            
                Published under: Release Notes
            
            
                3 min read
            
        

        
            
                ESLint v9.24.0 released
        
        
            We just pushed ESLint v9.24.0, which is a minor release upgrade of ESLint. This release adds some new features and fixes several bugs found in the previous release.
        
        
            
            
            
                Milos Djermanovic
                04 Apr, 2025
            
        
    

            
            
            
            
            

            
            
            

            
    
        
            
                Published under: Release Notes
            
            
                3 min read
            
        

        
            
                ESLint v9.23.0 released
        
        
            We just pushed ESLint v9.23.0, which is a minor release upgrade of ESLint. This release adds some new features and fixes several bugs found in the previous release.
        
        
            
            
            
                Francesco Trotta
                21 Mar, 2025
            
        
    

            
        

        
            View all posts
        
    



    
        
            Welcome to the community
            
            
            
                ESLint is the #1 JavaScript linter by downloads on npm (over 53.0M downloads / week) and is used at companies like Microsoft, Airbnb, Netflix, and Facebook.

            
        
        
            
                26.0M
                Dependents
            
            
                53.0M
                Weekly Downloads
            
            
                25.8K
                Stars
            
        
    



    
        
            Sponsored by fantastic people
            
            
            
                We receive $213,484.47 / year in donations from 184 sponsors.

            
        
        
            
                
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                        
                        
                    
                        
                        
                        
                            
                        
                        
                        
                    
                    
                
                
                
                    
                    
                    
                    
                        
                    
                    
                    
                
                
                
                    
                    
                    
                    
                        
                    
                    
                    
                
                
                
                    
                    
                    
                    
                        
                    
                    
                    
                
                
            
            View all sponsors
        
        
            
                Recent One-time Donations

                
                    
                    
                        
                        
                        
                        
                        

                        

    

    
        Raul Silveira
        April 15, 2025
    

    
        + $1.00
    

                    
                    
                    
                        
                        
                        
                        
                        

                        

    

    
        Rafael Vaz
        April 11, 2025
    

    
        + $5.00
    

                    
                    
                    
                        
                        
                        
                        
                        

                        

    

    
        Rafael Vaz
        April 10, 2025
    

    
        + $5.00
    

                    
                    
                    
                        
                        
                        
                        
                        

                        

    

    
        HolyFata
        April 8, 2025
    

    
        + $5.00
    

                    
                    
                    
                        
                        
                        
                        
                        

                        

    

    
        heliosfr
        April 7, 2025
    

    
        + $5.00
    

                    
                    
                    
                        
                        
                        
                        
                        

                        

    

    
        Peter Dave Hello
        March 26, 2025
    

    
        + $1.00
    

                    
                    
                
            
            
                View all donations
            
        
    




    testimonials
    
        
    
        
                
                    
                        ESLint has been critical in helping developers write high-quality JavaScript for years. We love that it catches common issues early and often. With a high level of extensibility, ESLint's ability to let teams enforce custom rules that work for them has been excellent for open-source projects and more. Chrome is happy to sponsor ESLint to help web developers write consistently high-quality code. It's an essential piece of the modern web development toolkit.

                    
                    
                        
                            
                            
                                Addy Osmani
                                Senior Staff Eng. Manager, Chrome
                            
                        
                    
                
                
                    
                        
                        
                        
                    
                
            
                
                    
                        Nx uses ESLint to enforce code quality, library boundaries, and project visibility constraints. ESLint makes Nx more powerful, so on behalf of the Nx.dev community, we're proud to do our part and sponsor ESLint's continued success!

                    
                    
                        
                            
                            
                                Jeff Cross
                                Co-founder and Principal Architect, Nx
                            
                        
                    
                
                
                    
                        
                        
                        
                    
                
            
                
                    
                        ESLint is an extremely useful tool for any JavaScript project. This tool allows us to set up consistent code formatting rules adopted by the whole team from the beginning of the project, greatly facilitates code reviews, and makes it easy to integrate new developers into the team. I know I am not alone in appreciating its flexibility and ease-of-use.

                    
                    
                        
                            
                            
                                Médédé Raymond KPATCHAA
                                Technical Architect, Salesforce
                            
                        
                    
                
                
                    
                        
                        
                        
                    
                
            
                
                    
                        Most JavaScript projects directly or transitively depend on ESLint. An Indeed employee nominated ESLint to receive a donation from the FOSS Contributor Fund, and their colleagues clearly agreed. We're happy to support the open source technologies that allow us to develop, protect, and maintain the digital infrastructure that supports our products and helps people get jobs.

                    
                    
                        
                            
                            
                                Duane O'Brien
                                Head of Open Source, Indeed
                            
                        
                    
                
                
                    
                        
                        
                        
                    
                
            
                
                    
                        ESLint plays a major role in helping us create a safe and consistent experience across a growing number of codebases and engineers. We are grateful for all the open-source projects that are helping us build Contra, and ESLint is the first of many open-source projects that we are committed to back.

                    
                    
                        
                            
                            
                                Gajus Kuizinas
                                Co-Founder / CTO, Contra\n\n\n\nOpen Collective
                        
                        
                            Our most popular plan for companies.
                        
                    
                
                
                            
                            Donate directly to a 501(c)(6) non-profit
                        
                            
                            One-time and recurring donations
                        
                            
                            Pay by credit card, bank transfer, or PayPal
                        
                            
                            Set up an open source fund to donate to multiple projects
                        
                            
                            Available in most countries
                        
                
                    
                        
                        Contribute on Open Collective
                    
                
            
                
                    
                    
                        
                            GitHub Sponsors
                        
                        
                            Advanced features and reporting.
                        
                    
                
                
                        
                        Donate through GitHub billing
                    
                        
                        One-time and recurring donations
                    
                        
                        Pay by credit card or use your existing billing relationship with GitHub (including invoicing)
                    
                        
                        Show a “sponsor” badge on your GitHub profile
                    
                        
                        Use your existing GitHub login
                    
                
                    
                        
                        Contribute on GitHub
                    
                
            
                         Team Development 
                         We pay our team members an hourly rate based on their seniority, currently $80.00 USD/hour for TSC members and Reviewers and $50.00 USD/hour for committers.
 
                    
                         Contributor Pool 
                         We set aside $1,000.00 USD each month to pay outside contributors who have made significant contributions to the project. Contributions include submitting code, writing documentation, answering questions in our Discord server, and more. This money is allocated each month by the TSC.
 
                    
                         Dependencies 
                         We set aside $1,500.00 USD each month to help support our dependencies. We believe that open source projects who are lucky enough to get funded have a responsibility to help support the smaller projects they rely on.
 
                    
                         Community Projects 
                         We set aside $1,500.00 USD each month to help support plugins, parsers, and other projects that are of benefit to the ESLint ecosystem as a whole. We believe the strength of the project is in its ecosystem and we want to ensure important projects remain well-maintained.
 
                    
                         Support Systems 
                         We use a small amount each month to pay for software the team uses to help manage the project, which includes things like Google Workspace and cloud storage.\n\nDonate
            
                ESLint relies on donations for ongoing maintenance and development. There are currently 184 companies, organizations, and individuals donating $17,790.37 each month to help us out.

            
            
            
                
                    See our Sponsors
                
                
            

            
        
        
            






        
    



    
        
            Ways to donate
            
                We accept donations through the following sites.
            
        
        
            
                
                    
                    
                        
                            Open Collective
                        
                        
                            Our most popular plan for companies.
                        
                    
                
                
                            
                            Donate directly to a 501(c)(6) non-profit
                        
                            
                            One-time and recurring donations
                        
                            
                            Pay by credit card, bank transfer, or PayPal
                        
                            
                            Set up an open source fund to donate to multiple projects
                        
                            
                            Available in most countries
                        
                
                    
                        
                        Contribute on Open Collective
                    
                
            
            
                
                    
                    
                        
                            GitHub Sponsors
                        
                        
                            Advanced features and reporting.
                        
                    
                
                
                        
                        Donate through GitHub billing
                    
                        
                        One-time and recurring donations
                    
                        
                        Pay by credit card or use your existing billing relationship with GitHub (including invoicing)
                    
                        
                        Show a “sponsor” badge on your GitHub profile
                    
                        
                        Use your existing GitHub login
                    
                
                    
                        
                        Contribute on GitHub
                    
                
            
        
    



    
        
            How the money is used
            
                The ESLint project uses donated money to benefit the project and the ESLint community as a whole. In general, we spend money on these areas each month.

            
        
        
            
                    
                    
                    
                    
                    
                    
                         Team Development 
                         We pay our team members an hourly rate based on their seniority, currently $80.00 USD/hour for TSC members and Reviewers and $50.00 USD/hour for committers.
 
                    
                    
                    
                    
                    
                    
                    
                         Contributor Pool 
                         We set aside $1,000.00 USD each month to pay outside contributors who have made significant contributions to the project. Contributions include submitting code, writing documentation, answering questions in our Discord server, and more. This money is allocated each month by the TSC.
 
                    
                    
                    
                    
                    
                    
                    
                         Dependencies 
                         We set aside $1,500.00 USD each month to help support our dependencies. We believe that open source projects who are lucky enough to get funded have a responsibility to help support the smaller projects they rely on.
 
                    
                    
                    
                    
                    
                    
                    
                         Community Projects 
                         We set aside $1,500.00 USD each month to help support plugins, parsers, and other projects that are of benefit to the ESLint ecosystem as a whole. We believe the strength of the project is in its ecosystem and we want to ensure important projects remain well-maintained.
 
                    
                    
                    
                    
                    
                    
                    
                         Support Systems 
                         We use a small amount each month to pay for software the team uses to help manage the project, which includes things like Google Workspace and cloud storage.
 
                    
            
                
            
        
        
            
                Additionally, from time to time we use the funds to pay contractors to work on things that are important to the project and where the team doesn’t have the time or expertise to complete the work on their own. For example, we recently hired a designer and developer to redesign this website. We ensure that we spend less than we take in each month so we can save for such projects.

            
        
    



    
        
            Donation tiers
            
                While we accept donations of any size, we do have a tier system with different rewards at each level.
            
        
        
                    
                         Diamond Sponsor 
                        $5000+
                        per month
                    
                    
                        Highest logo placement on homepage and readme and everything in Platinum tier.
                    
                    
                        
                            
                            Donate on Open Collective

                        
                        
                            
                            Donate on GitHub

                        
                    
                
                    
                         Platinum Sponsor 
                        $2000-4999
                        per month
                    
                    
                        Second highest logo placement on homepage and readme and everything in Gold tier.
                    
                    
                        
                            
                            Donate on Open Collective

                        
                        
                            
                            Donate on GitHub

                        
                    
                
                    
                         Gold Sponsor 
                        $1000–1999
                        per month
                    
                    
                        Third highest logo placement on homepage and readme, a Thank you tweet from our Twitter account (38,000 followers) and a optional thank you blog post.
                    
                    
                        
                            
                            Donate on Open Collective

                        
                        
                            
                            Donate on GitHub

                        
                    
                
                    
                         Silver Sponsor 
                        $500–999
                        per month
                    
                    
                        Fourth highest logo placement on homepage and readme.
                    
                    
                        
                            
                            Donate on Open Collective

                        
                        
                            
                            Donate on GitHub

                        
                    
                
                    
                         Bronze Sponsor 
                        $200–499
                        per month
                    
                    
                        Fifth highest logo placement on homepage and readme.
                    
                    
                        
                            
                            Donate on Open Collective

                        
                        
                            
                            Donate on GitHub

                        
                    
                
    



    
        
            testimonials
        
        
            
                
                        
                            
                                
                                    ESLint has been critical in helping developers write high-quality JavaScript for years. We love that it catches common issues early and often. With a high level of extensibility, ESLint's ability to let teams enforce custom rules that work for them has been excellent for open-source projects and more. Chrome is happy to sponsor ESLint to help web developers write consistently high-quality code. It's an essential piece of the modern web development toolkit.

                                
                            
                            
                                
                                    
                                    
                                        Addy Osmani
                                        Senior Staff Eng. Manager, Chrome
                                    
                                
                            
                        
                    
                        
                            
                                
                                    Nx uses ESLint to enforce code quality, library boundaries, and project visibility constraints. ESLint makes Nx more powerful, so on behalf of the Nx.dev community, we're proud to do our part and sponsor ESLint's continued success!

                                
                            
                            
                                
                                    
                                    
                                        Jeff Cross
                                        Co-founder and Principal Architect, Nx
                                    
                                
                            
                        
                    
                        
                            
                                
                                    ESLint is an extremely useful tool for any JavaScript project. This tool allows us to set up consistent code formatting rules adopted by the whole team from the beginning of the project, greatly facilitates code reviews, and makes it easy to integrate new developers into the team. I know I am not alone in appreciating its flexibility and ease-of-use.

                                
                            
                            
                                
                                    
                                    
                                        Médédé Raymond KPATCHAA
                                        Technical Architect, Salesforce
                                    
                                
                            
                        
                    
                        
                            
                                
                                    Most JavaScript projects directly or transitively depend on ESLint. An Indeed employee nominated ESLint to receive a donation from the FOSS Contributor Fund, and their colleagues clearly agreed. We're happy to support the open source technologies that allow us to develop, protect, and maintain the digital infrastructure that supports our products and helps people get jobs.

                                
                            
                            
                                
                                    
                                    
                                        Duane O'Brien
                                        Head of Open Source, Indeed
                                    
                                
                            
                        
                    
                        
                            
                                
                                    ESLint plays a major role in helping us create a safe and consistent experience across a growing number of codebases and engineers. We are grateful for all the open-source projects that are helping us build Contra, and ESLint is the first of many open-source projects that we are committed to back.

                                
                            
                            
                                
                                    
                                    
                                        Gajus Kuizinas
                                        Co-Founder / CTO, Contra
                                    
                                
                            
                        
                    
            
        
    



    
        
            Frequently Asked Questions
            Everything you need to know about the product and billing. Can’t find the answer you’re looking for? Please chat to our friendly team.
        
        
            Who receives the money that is donated?
    All contributions, whether donated through Open Collective or GitHub, are received by the Open Source Collective, which is a 501(c)(6) non-profit organization. The Open Source Collective acts as a fiscal host for ESLint and keeps track of all donations.
    Will I get a record of my donations?
    Yes. If you donate through Open Collective, you will receive a PDF receipt via email; if you donate through GitHub, the donation will appear on your receipt or invoice.
    Is my donation tax deductible?
    No. Even though the Open Source Collective is a 501(c)(6) non-profit organization, the IRS doesn't consider development of open source software to be a charitable activity and therefore doesn’t grant tax-exempt status.
    Who decides how the money is distributed?
    The TSC makes all decisions regarding who receives the money and how much is distributed.
    Can I see how the money is being used?
    Yes. By going to our Open Collective page, you can see every expense that has been submitted and paid. All transactions are completely open and publicly visible.
    Can I cancel my recurring donation at any time?
    Yes. There is no long-term commitment. You can cancel your donation at any time by logging into either Open Collective or GitHub sponsors.
    How long does it take for my logo to appear on the homepage, GitHub, and npm package?
    The logos on the homepage and GitHub are automatically updated every day so it should take no longer than 24 hours to appear. The logos on the npm package are only updated when we publish a new release, which is typically every two weeks. However, major releases often take several months to complete and during that time logos on the npm package will not be updated.
    Where do my logo and URL come from?
    We pull the logo and URL from your Open Collective or GitHub profiles, depending on which site you used to donate. You can update these at any time from within Open Collective or GitHub and those changes will be reflected on the homepage and GitHub README within 24 hours. We aren't able to manually override logos or URLs on the site.
    Is it possible to make a one-time donation?
    Yes. The easiest way to make a one-time donation is through Open Collective, which allows any amount. GitHub one-time donations may have a limit on the amount you can donate.\n\nDonate
            
                ESLint relies on donations for ongoing maintenance and development. There are currently 184 companies, organizations, and individuals donating $17,790.37 each month to help us out.

            
            
            
                
                    See our Sponsors
                
                
            

            
        
        
            






        
    



    
        
            Ways to donate
            
                We accept donations through the following sites.
            
        
        
            
                
                    
                    
                        
                            Open Collective
                        
                        
                            Our most popular plan for companies.
                        
                    
                
                
                            
                            Donate directly to a 501(c)(6) non-profit
                        
                            
                            One-time and recurring donations
                        
                            
                            Pay by credit card, bank transfer, or PayPal
                        
                            
                            Set up an open source fund to donate to multiple projects
                        
                            
                            Available in most countries
                        
                
                    
                        
                        Contribute on Open Collective
                    
                
            
            
                
                    
                    
                        
                            GitHub Sponsors
                        
                        
                            Advanced features and reporting.
                        
                    
                
                
                        
                        Donate through GitHub billing
                    
                        
                        One-time and recurring donations
                    
                        
                        Pay by credit card or use your existing billing relationship with GitHub (including invoicing)
                    
                        
                        Show a “sponsor” badge on your GitHub profile
                    
                        
                        Use your existing GitHub login
                    
                
                    
                        
                        Contribute on GitHub
                    
                
            
        
    



    
        
            How the money is used
            
                The ESLint project uses donated money to benefit the project and the ESLint community as a whole. In general, we spend money on these areas each month.

            
        
        
            
                    
                    
                    
                    
                    
                    
                         Team Development 
                         We pay our team members an hourly rate based on their seniority, currently $80.00 USD/hour for TSC members and Reviewers and $50.00 USD/hour for committers.
 
                    
                    
                    
                    
                    
                    
                    
                         Contributor Pool 
                         We set aside $1,000.00 USD each month to pay outside contributors who have made significant contributions to the project. Contributions include submitting code, writing documentation, answering questions in our Discord server, and more. This money is allocated each month by the TSC.
 
                    
                    
                    
                    
                    
                    
                    
                         Dependencies 
                         We set aside $1,500.00 USD each month to help support our dependencies. We believe that open source projects who are lucky enough to get funded have a responsibility to help support the smaller projects they rely on.
 
                    
                    
                    
                    
                    
                    
                    
                         Community Projects 
                         We set aside $1,500.00 USD each month to help support plugins, parsers, and other projects that are of benefit to the ESLint ecosystem as a whole. We believe the strength of the project is in its ecosystem and we want to ensure important projects remain well-maintained.
 
                    
                    
                    
                    
                    
                    
                    
                         Support Systems 
                         We use a small amount each month to pay for software the team uses to help manage the project, which includes things like Google Workspace and cloud storage.
 
                    
            
                
            
        
        
            
                Additionally, from time to time we use the funds to pay contractors to work on things that are important to the project and where the team doesn’t have the time or expertise to complete the work on their own. For example, we recently hired a designer and developer to redesign this website. We ensure that we spend less than we take in each month so we can save for such projects.

            
        
    



    
        
            Donation tiers
            
                While we accept donations of any size, we do have a tier system with different rewards at each level.
            
        
        
                    
                         Diamond Sponsor 
                        $5000+
                        per month
                    
                    
                        Highest logo placement on homepage and readme and everything in Platinum tier.
                    
                    
                        
                            
                            Donate on Open Collective

                        
                        
                            
                            Donate on GitHub

                        
                    
                
                    
                         Platinum Sponsor 
                        $2000-4999
                        per month
                    
                    
                        Second highest logo placement on homepage and readme and everything in Gold tier.
                    
                    
                        
                            
                            Donate on Open Collective

                        
                        
                            
                            Donate on GitHub

                        
                    
                
                    
                         Gold Sponsor 
                        $1000–1999
                        per month
                    
                    
                        Third highest logo placement on homepage and readme, a Thank you tweet from our Twitter account (38,000 followers) and a optional thank you blog post.
                    
                    
                        
                            
                            Donate on Open Collective

                        
                        
                            
                            Donate on GitHub

                        
                    
                
                    
                         Silver Sponsor 
                        $500–999
                        per month
                    
                    
                        Fourth highest logo placement on homepage and readme.
                    
                    
                        
                            
                            Donate on Open Collective

                        
                        
                            
                            Donate on GitHub

                        
                    
                
                    
                         Bronze Sponsor 
                        $200–499
                        per month
                    
                    
                        Fifth highest logo placement on homepage and readme.
                    
                    
                        
                            
                            Donate on Open Collective

                        
                        
                            
                            Donate on GitHub

                        
                    
                
    



    
        
            testimonials
        
        
            
                
                        
                            
                                
                                    ESLint has been critical in helping developers write high-quality JavaScript for years. We love that it catches common issues early and often. With a high level of extensibility, ESLint's ability to let teams enforce custom rules that work for them has been excellent for open-source projects and more. Chrome is happy to sponsor ESLint to help web developers write consistently high-quality code. It's an essential piece of the modern web development toolkit.

                                
                            
                            
                                
                                    
                                    
                                        Addy Osmani
                                        Senior Staff Eng. Manager, Chrome
                                    
                                
                            
                        
                    
                        
                            
                                
                                    Nx uses ESLint to enforce code quality, library boundaries, and project visibility constraints. ESLint makes Nx more powerful, so on behalf of the Nx.dev community, we're proud to do our part and sponsor ESLint's continued success!

                                
                            
                            
                                
                                    
                                    
                                        Jeff Cross
                                        Co-founder and Principal Architect, Nx
                                    
                                
                            
                        
                    
                        
                            
                                
                                    ESLint is an extremely useful tool for any JavaScript project. This tool allows us to set up consistent code formatting rules adopted by the whole team from the beginning of the project, greatly facilitates code reviews, and makes it easy to integrate new developers into the team. I know I am not alone in appreciating its flexibility and ease-of-use.

                                
                            
                            
                                
                                    
                                    
                                        Médédé Raymond KPATCHAA
                                        Technical Architect, Salesforce
                                    
                                
                            
                        
                    
                        
                            
                                
                                    Most JavaScript projects directly or transitively depend on ESLint. An Indeed employee nominated ESLint to receive a donation from the FOSS Contributor Fund, and their colleagues clearly agreed. We're happy to support the open source technologies that allow us to develop, protect, and maintain the digital infrastructure that supports our products and helps people get jobs.

                                
                            
                            
                                
                                    
                                    
                                        Duane O'Brien
                                        Head of Open Source, Indeed
                                    
                                
                            
                        
                    
                        
                            
                                
                                    ESLint plays a major role in helping us create a safe and consistent experience across a growing number of codebases and engineers. We are grateful for all the open-source projects that are helping us build Contra, and ESLint is the first of many open-source projects that we are committed to back.

                                
                            
                            
                                
                                    
                                    
                                        Gajus Kuizinas
                                        Co-Founder / CTO, Contra
                                    
                                
                            
                        
                    
            
        
    



    
        
            Frequently Asked Questions
            Everything you need to know about the product and billing. Can’t find the answer you’re looking for? Please chat to our friendly team.
        
        
            Who receives the money that is donated?
    All contributions, whether donated through Open Collective or GitHub, are received by the Open Source Collective, which is a 501(c)(6) non-profit organization. The Open Source Collective acts as a fiscal host for ESLint and keeps track of all donations.
    Will I get a record of my donations?
    Yes. If you donate through Open Collective, you will receive a PDF receipt via email; if you donate through GitHub, the donation will appear on your receipt or invoice.
    Is my donation tax deductible?
    No. Even though the Open Source Collective is a 501(c)(6) non-profit organization, the IRS doesn't consider development of open source software to be a charitable activity and therefore doesn’t grant tax-exempt status.
    Who decides how the money is distributed?
    The TSC makes all decisions regarding who receives the money and how much is distributed.
    Can I see how the money is being used?
    Yes. By going to our Open Collective page, you can see every expense that has been submitted and paid. All transactions are completely open and publicly visible.
    Can I cancel my recurring donation at any time?
    Yes. There is no long-term commitment. You can cancel your donation at any time by logging into either Open Collective or GitHub sponsors.
    How long does it take for my logo to appear on the homepage, GitHub, and npm package?
    The logos on the homepage and GitHub are automatically updated every day so it should take no longer than 24 hours to appear. The logos on the npm package are only updated when we publish a new release, which is typically every two weeks. However, major releases often take several months to complete and during that time logos on the npm package will not be updated.
    Where do my logo and URL come from?
    We pull the logo and URL from your Open Collective or GitHub profiles, depending on which site you used to donate. You can update these at any time from within Open Collective or GitHub and those changes will be reflected on the homepage and GitHub README within 24 hours. We aren't able to manually override logos or URLs on the site.
    Is it possible to make a one-time donation?
    Yes. The easiest way to make a one-time donation is through Open Collective, which allows any amount. GitHub one-time donations may have a limit on the amount you can donate.\n\n\n\nMeet our Team
            
                These are the people who build and maintain ESLint.

            
            
        
        
            






        
    



    
        
            
                Technical Steering Committee
                
                    The people who manage releases, review feature requests, and meet regularly to ensure ESLint is properly maintained.

                
            
            
                
                    
                    
                    

                    
                    
                    
                    
                    
                    

                    
                        
    
    
        
            Nicholas C. Zakas
        
        
            @nzakas
        

        
            
                Creator of ESLint, independent software developer, consultant, coach, and author.
            
        

        
            
                
                
                    
                        
                    
                
                
                
                
                    
                        
                    
                
                
                
                
                
                    
                        
                    
                
                
                
                
                    
                        
                    
                
                
            
        
    

                    
                
                    
                    
                    

                    
                    
                    
                    
                    
                    

                    
                        
    
    
        
            Francesco Trotta
        
        
            @fasttime
        

        
            
                
            
        

        
            
                
                
                
                    
                        
                    
                
                
                
                
                
            
        
    

                    
                
                    
                    
                    

                    
                    
                    
                    
                    
                    

                    
                        
    
    
        
            Milos Djermanovic
        
        
            @mdjermanovic
        

        
            
                
            
        

        
            
                
                
                
                    
                        
                    
                
                
                
                
                
            
        
    

                    
                
            
        
    



    
        
            
                Reviewers
                
                    The people who review and implement new features.

                
            
            
                
                    
                    
                    

                    
                    
                    
                    
                    
                    

                    
                        
    
    
        
            唯然
        
        
            @aladdin-add
        

        
            
                Available for hire/contract
            
        

        
            
                
                
                
                    
                        
                    
                
                
                
                
                
            
        
    

                    
                
                    
                    
                    

                    
                    
                    
                    
                    
                    

                    
                        
    
    
        
            Nitin Kumar
        
        
            @snitin315
        

        
            
                Helping maintain @webpack and @eslint
            
        

        
            
                
                
                    
                        
                    
                
                
                
                
                    
                        
                    
                
                
                
                
                
                
                    
                        
                    
                
                
            
        
    

                    
                
            
        
    



    
        
            
                Committers
                
                    The people who review and fix bugs and help triage issues.

                
            
            
                
                    
                    
                    

                    
                    
                    
                    
                    
                    

                    
                        
    
    
        
            Josh Goldberg ✨
        
        
            @JoshuaKGoldberg
        

        
            
                Full time open source 💖✨ 

@typescript-eslint maintainer; 
@LearningTypeScript author;
Microsoft MVP 🌟
            
        

        
            
                
                
                    
                        
                    
                
                
                
                
                    
                        
                    
                
                
                
                
                
                    
                        
                    
                
                
                
                
                    
                        
                    
                
                
            
        
    

                    
                
                    
                    
                    

                    
                    
                    
                    
                    
                    

                    
                        
    
    
        
            Tanuj Kanti
        
        
            @Tanujkanti4441
        

        
            
                
            
        

        
            
                
                
                
                    
                        
                    
                
                
                
                
                
            
        
    

                    
                
            
        
    



    
        
            
                Website Team
                
                    Team members who focus specifically on eslint.org

                
            
            
                
                
                
                

                
                
                
                
                
                

                
                    
    
    
        
            Amaresh  S M 
        
        
            @amareshsm
        

        
            
                
            
        

        
            
                
                
                    
                        
                    
                
                
                
                
                    
                        
                    
                
                
                
                
                
                
                    
                        
                    
                
                
            
        
    

                
                
                
                
                

                
                
                
                
                
                

                
                    
    
    
        
            Strek
        
        
            @harish-sethuraman
        

        
            
                I try to code
            
        

        
            
                
                
                    
                        
                    
                
                
                
                
                    
                        
                    
                
                
                
                
                
                
                    
                        
                    
                
                
            
        
    

                
                
                
                
                

                
                
                
                
                
                

                
                    
    
    
        
            Percy Ma
        
        
            @kecrily
        

        
            
                让世界听到你的声音
            
        

        
            
                
                
                    
                        
                    
                
                
                
                
                    
                        
                    
                
                
                
                
                
                    
                        
                    
                
                
                
                
                    
                        
                    
                
                
            
        
    

                
                
            
        
    



    
        
            
                Support Team
                
                    Folks who help in Discord and discussions.

                
            
            
                
                
                
                

                
                
                
                
                
                

                
                    
    
    
        
            Samuel Roldan
        
        
            @sam3k
        

        
            
                I am a frontend lead engineer with over two decades of experience architecting
frontend web applications.
            
        

        
            
                
                
                    
                        
                    
                
                
                
                
                    
                        
                    
                
                
                
                
                
            
        
    

                
                
                
                
                

                
                
                
                
                
                

                
                    
    
    
        
            Joel Mathew Koshy
        
        
            @Rec0iL99
        

        
            
                SE @ Scelta | Team @eslint
            
        

        
            
                
                
                    
                        
                    
                
                
                
                
                    
                        
                    
                
                
                
                
                
                
                    
                        
                    
                
                
            
        
    

                
                
            
        
    
    
        
            
                Alumni
                
                    Former team members who previously helped maintain ESLint.

                
            
            
                
                    
                    
                    

                    
                        
    
    
        Brett Zamir
      @brettz9
    

                    
                
                    
                    
                    

                    
                        
    
    
        alberto
      @alberto
    

                    
                
                    
                    
                    

                    
                        
    
    
        Burak Yigit Kaya
      @BYK
    

                    
                
                    
                    
                    

                    
                        
    
    
        Mathias Schreck
      @lo1tuma
    

                    
                
                    
                    
                    

                    
                        
    
    
        Michael Ficarra
      @michaelficarra
    

                    
                
                    
                    
                    

                    
                        
    
    
        Jamund Ferguson
      @xjamundx
    

                    
                
                    
                    
                    

                    
                        
    
    
        Kevin Partington
      @platinumazure
    

                    
                
                    
                    
                    

                    
                        
    
    
        Mike Sherov
      @mikesherov
    

                    
                
                    
                    
                    

                    
                        
    
    
        Henry
      @hzoo
    

                    
                
                    
                    
                    

                    
                        
    
    
        Vitor Balocco
      @vitorbal
    

                    
                
                    
                    
                    

                    
                        
    
    
        Bryan Mishkin
      @bmish
    

                    
                
                    
                    
                    

                    
                        
    
    
        James Henry
      @JamesHenry
    

                    
                
                    
                    
                    

                    
                        
    
    
        Oleg Gaidarenko
      @markelog
    

                    
                
                    
                    
                    

                    
                        
    
    
        Michael Robinson
      @faceleg
    

                    
                
                    
                    
                    

                    
                        
    
    
        Ilya Volodin
      @ilyavolodin
    

                    
                
                    
                    
                    

                    
                        
    
    
        Brandon Mills
      @btmills
    

                    
                
                    
                    
                    

                    
                        
    
    
        Toru Nagashima
      @mysticatea
    

                    
                
                    
                    
                    

                    
                        
    
    
        Reyad Attiyat
      @soda0289
    

                    
                
                    
                    
                    

                    
                        
    
    
        Victor Hom
      @VictorHom
    

                    
                
                    
                    
                    

                    
                        
    
    
        Ian VanSchooten
      @IanVS
    

                    
                
                    
                    
                    

                    
                        
    
    
        Gyandeep Singh
      @gyandeeps
    

                    
                
                    
                    
                    

                    
                        
    
    
        Kai Cataldo
      @kaicataldo
    

                    
                
                    
                    
                    

                    
                        
    
    
        Teddy Katz
      @not-an-aardvark
    

                    
                
                    
                    
                    

                    
                        
    
    
        Mark Pedrotti
      @pedrottimark
    

                    
                
                    
                    
                    

                    
                        
    
    
        Yosuke Ota
      @ota-meshi
    

                    
                
                    
                    
                    

                    
                        
    
    
        Pig Fang
      @g-plane
    

                    
                
                    
                    
                    

                    
                        
    
    
        Anix
      @anikethsaha
    

                    
                
                    
                    
                    

                    
                        
    
    
        YeonJuan
      @yeonjuan\n\nMeet our Team
            
                These are the people who build and maintain ESLint.

            
            
        
        
            






        
    



    
        
            
                Technical Steering Committee
                
                    The people who manage releases, review feature requests, and meet regularly to ensure ESLint is properly maintained.

                
            
            
                
                    
                    
                    

                    
                    
                    
                    
                    
                    

                    
                        
    
    
        
            Nicholas C. Zakas
        
        
            @nzakas
        

        
            
                Creator of ESLint, independent software developer, consultant, coach, and author.
            
        

        
            
                
                
                    
                        
                    
                
                
                
                
                    
                        
                    
                
                
                
                
                
                    
                        
                    
                
                
                
                
                    
                        
                    
                
                
            
        
    

                    
                
                    
                    
                    

                    
                    
                    
                    
                    
                    

                    
                        
    
    
        
            Francesco Trotta
        
        
            @fasttime
        

        
            
                
            
        

        
            
                
                
                
                    
                        
                    
                
                
                
                
                
            
        
    

                    
                
                    
                    
                    

                    
                    
                    
                    
                    
                    

                    
                        
    
    
        
            Milos Djermanovic
        
        
            @mdjermanovic
        

        
            
                
            
        

        
            
                
                
                
                    
                        
                    
                
                
                
                
                
            
        
    

                    
                
            
        
    



    
        
            
                Reviewers
                
                    The people who review and implement new features.

                
            
            
                
                    
                    
                    

                    
                    
                    
                    
                    
                    

                    
                        
    
    
        
            唯然
        
        
            @aladdin-add
        

        
            
                Available for hire/contract
            
        

        
            
                
                
                
                    
                        
                    
                
                
                
                
                
            
        
    

                    
                
                    
                    
                    

                    
                    
                    
                    
                    
                    

                    
                        
    
    
        
            Nitin Kumar
        
        
            @snitin315
        

        
            
                Helping maintain @webpack and @eslint
            
        

        
            
                
                
                    
                        
                    
                
                
                
                
                    
                        
                    
                
                
                
                
                
                
                    
                        
                    
                
                
            
        
    

                    
                
            
        
    



    
        
            
                Committers
                
                    The people who review and fix bugs and help triage issues.

                
            
            
                
                    
                    
                    

                    
                    
                    
                    
                    
                    

                    
                        
    
    
        
            Josh Goldberg ✨
        
        
            @JoshuaKGoldberg
        

        
            
                Full time open source 💖✨ 

@typescript-eslint maintainer; 
@LearningTypeScript author;
Microsoft MVP 🌟
            
        

        
            
                
                
                    
                        
                    
                
                
                
                
                    
                        
                    
                
                
                
                
                
                    
                        
                    
                
                
                
                
                    
                        
                    
                
                
            
        
    

                    
                
                    
                    
                    

                    
                    
                    
                    
                    
                    

                    
                        
    
    
        
            Tanuj Kanti
        
        
            @Tanujkanti4441
        

        
            
                
            
        

        
            
                
                
                
                    
                        
                    
                
                
                
                
                
            
        
    

                    
                
            
        
    



    
        
            
                Website Team
                
                    Team members who focus specifically on eslint.org

                
            
            
                
                
                
                

                
                
                
                
                
                

                
                    
    
    
        
            Amaresh  S M 
        
        
            @amareshsm
        

        
            
                
            
        

        
            
                
                
                    
                        
                    
                
                
                
                
                    
                        
                    
                
                
                
                
                
                
                    
                        
                    
                
                
            
        
    

                
                
                
                
                

                
                
                
                
                
                

                
                    
    
    
        
            Strek
        
        
            @harish-sethuraman
        

        
            
                I try to code
            
        

        
            
                
                
                    
                        
                    
                
                
                
                
                    
                        
                    
                
                
                
                
                
                
                    
                        
                    
                
                
            
        
    

                
                
                
                
                

                
                
                
                
                
                

                
                    
    
    
        
            Percy Ma
        
        
            @kecrily
        

        
            
                让世界听到你的声音
            
        

        
            
                
                
                    
                        
                    
                
                
                
                
                    
                        
                    
                
                
                
                
                
                    
                        
                    
                
                
                
                
                    
                        
                    
                
                
            
        
    

                
                
            
        
    



    
        
            
                Support Team
                
                    Folks who help in Discord and discussions.

                
            
            
                
                
                
                

                
                
                
                
                
                

                
                    
    
    
        
            Samuel Roldan
        
        
            @sam3k
        

        
            
                I am a frontend lead engineer with over two decades of experience architecting
frontend web applications.
            
        

        
            
                
                
                    
                        
                    
                
                
                
                
                    
                        
                    
                
                
                
                
                
            
        
    

                
                
                
                
                

                
                
                
                
                
                

                
                    
    
    
        
            Joel Mathew Koshy
        
        
            @Rec0iL99
        

        
            
                SE @ Scelta | Team @eslint
            
        

        
            
                
                
                    
                        
                    
                
                
                
                
                    
                        
                    
                
                
                
                
                
                
                    
                        
                    
                
                
            
        
    

                
                
            
        
    
    
        
            
                Alumni
                
                    Former team members who previously helped maintain ESLint.

                
            
            
                
                    
                    
                    

                    
                        
    
    
        Brett Zamir
      @brettz9
    

                    
                
                    
                    
                    

                    
                        
    
    
        alberto
      @alberto
    

                    
                
                    
                    
                    

                    
                        
    
    
        Burak Yigit Kaya
      @BYK
    

                    
                
                    
                    
                    

                    
                        
    
    
        Mathias Schreck
      @lo1tuma
    

                    
                
                    
                    
                    

                    
                        
    
    
        Michael Ficarra
      @michaelficarra
    

                    
                
                    
                    
                    

                    
                        
    
    
        Jamund Ferguson
      @xjamundx
    

                    
                
                    
                    
                    

                    
                        
    
    
        Kevin Partington
      @platinumazure
    

                    
                
                    
                    
                    

                    
                        
    
    
        Mike Sherov
      @mikesherov
    

                    
                
                    
                    
                    

                    
                        
    
    
        Henry
      @hzoo
    

                    
                
                    
                    
                    

                    
                        
    
    
        Vitor Balocco
      @vitorbal
    

                    
                
                    
                    
                    

                    
                        
    
    
        Bryan Mishkin
      @bmish
    

                    
                
                    
                    
                    

                    
                        
    
    
        James Henry
      @JamesHenry
    

                    
                
                    
                    
                    

                    
                        
    
    
        Oleg Gaidarenko
      @markelog
    

                    
                
                    
                    
                    

                    
                        
    
    
        Michael Robinson
      @faceleg
    

                    
                
                    
                    
                    

                    
                        
    
    
        Ilya Volodin
      @ilyavolodin
    

                    
                
                    
                    
                    

                    
                        
    
    
        Brandon Mills
      @btmills
    

                    
                
                    
                    
                    

                    
                        
    
    
        Toru Nagashima
      @mysticatea
    

                    
                
                    
                    
                    

                    
                        
    
    
        Reyad Attiyat
      @soda0289
    

                    
                
                    
                    
                    

                    
                        
    
    
        Victor Hom
      @VictorHom
    

                    
                
                    
                    
                    

                    
                        
    
    
        Ian VanSchooten
      @IanVS
    

                    
                
                    
                    
                    

                    
                        
    
    
        Gyandeep Singh
      @gyandeeps
    

                    
                
                    
                    
                    

                    
                        
    
    
        Kai Cataldo
      @kaicataldo
    

                    
                
                    
                    
                    

                    
                        
    
    
        Teddy Katz
      @not-an-aardvark
    

                    
                
                    
                    
                    

                    
                        
    
    
        Mark Pedrotti
      @pedrottimark
    

                    
                
                    
                    
                    

                    
                        
    
    
        Yosuke Ota
      @ota-meshi
    

                    
                
                    
                    
                    

                    
                        
    
    
        Pig Fang
      @g-plane
    

                    
                
                    
                    
                    

                    
                        
    
    
        Anix
      @anikethsaha
    

                    
                
                    
                    
                    

                    
                        
    
    
        YeonJuan
      @yeonjuan\n\n\n\nPublished under: Announcements
            
            
                3 min read
            
        

        
            
                Introducing bulk suppressions
        
        
            How to enable stricter linting incrementally
        
        
            
            
            
                Iacovos Constantinou
                04 Apr, 2025
            
        
    

    
        
            
                Published under: Release Notes
            
            
                3 min read
            
        

        
            
                ESLint v9.24.0 released
        
        
            We just pushed ESLint v9.24.0, which is a minor release upgrade of ESLint. This release adds some new features and fixes several bugs found in the previous release.
        
        
            
            
            
                Milos Djermanovic
                04 Apr, 2025
            
        
    

    
        
            
                Published under: Release Notes
            
            
                3 min read
            
        

        
            
                ESLint v9.23.0 released
        
        
            We just pushed ESLint v9.23.0, which is a minor release upgrade of ESLint. This release adds some new features and fixes several bugs found in the previous release.
        
        
            
            
            
                Francesco Trotta
                21 Mar, 2025
            
        
    

    
        
            
                Published under: Announcements
            
            
                5 min read
            
        

        
            
                Evolving flat config with extends
        
        
            Your eslint.config.js files can now use extends to simplify your configuration.
        
        
            
            
            
                Nicholas C. Zakas
                07 Mar, 2025
            
        
    

    
        
            
                Published under: Release Notes
            
            
                1 min read
            
        

        
            
                ESLint v9.22.0 released
        
        
            We just pushed ESLint v9.22.0, which is a minor release upgrade of ESLint. This release adds some new features and fixes several bugs found in the previous release.
        
        
            
            
            
                Milos Djermanovic
                07 Mar, 2025
            
        
    

    
        
            
                Published under: Release Notes
            
            
                2 min read
            
        

        
            
                ESLint v9.21.0 released
        
        
            We just pushed ESLint v9.21.0, which is a minor release upgrade of ESLint. This release adds some new features and fixes several bugs found in the previous release.
        
        
            
            
            
                Francesco Trotta
                21 Feb, 2025
            
        
    

    
        
            
                Published under: Announcements
            
            
                3 min read
            
        

        
            
                ESLint now officially supports linting of CSS
        
        
            Taking our next step towards providing a language-agnostic platform for source code linting.
        
        
            
            
            
                Nicholas C. Zakas
                18 Feb, 2025
            
        
    

    
        
            
                Published under: Release Notes
            
            
                1 min read
            
        

        
            
                ESLint v9.20.1 released
        
        
            We just pushed ESLint v9.20.1, which is a patch release upgrade of ESLint. This release fixes several bugs found in the previous release.
        
        
            
            
            
                Nicholas C. Zakas
                11 Feb, 2025
            
        
    

    
        
            
                Published under: Release Notes
            
            
                2 min read
            
        

        
            
                ESLint v9.20.0 released
        
        
            We just pushed ESLint v9.20.0, which is a minor release upgrade of ESLint. This release adds some new features and fixes several bugs found in the previous release.
        
        
            
            
            
                Francesco Trotta
                07 Feb, 2025\n\nNews and Updates
            
                The latest ESLint news, case studies, tutorials, and resources.
            
            
        
        
            






        
    


    
        
            
    
        Search
    
    
        
        Results will be shown and updated as you type.
        
            
            
            
                Clear Search
                
            
            
                
                    Powered by
                    
                
            
        
    
    



            
    Categories
    
        
        Everything
        
            

                

                Announcements
            
        
            

                

                API Changes
            
        
            

                

                Case Studies
            
        
            

                

                Financials
            
        
            

                

                Policy Updates
            
        
            

                

                Postmortems
            
        
            

                

                Release Notes
            
        
            

                

                Sponsorships
            
        
            

                

                Storytime
            
        
        
    


        

        
            



    
    


    
    
    
    
    


    
    
    

    
    
        
            
                Published under: Announcements
            
            
                3 min read
            
        

        
            
                Introducing bulk suppressions
        
        
            How to enable stricter linting incrementally
        
        
            
            
            
                Iacovos Constantinou
                04 Apr, 2025
            
        
    

    


    
    
    
    
    


    
    
    

    
    
        
            
                Published under: Release Notes
            
            
                3 min read
            
        

        
            
                ESLint v9.24.0 released
        
        
            We just pushed ESLint v9.24.0, which is a minor release upgrade of ESLint. This release adds some new features and fixes several bugs found in the previous release.
        
        
            
            
            
                Milos Djermanovic
                04 Apr, 2025
            
        
    

    


    
    
    
    
    


    
    
    

    
    
        
            
                Published under: Release Notes
            
            
                3 min read
            
        

        
            
                ESLint v9.23.0 released
        
        
            We just pushed ESLint v9.23.0, which is a minor release upgrade of ESLint. This release adds some new features and fixes several bugs found in the previous release.
        
        
            
            
            
                Francesco Trotta
                21 Mar, 2025
            
        
    

    


    
    
    
    
    


    
    
    

    
    
        
            
                Published under: Announcements
            
            
                5 min read
            
        

        
            
                Evolving flat config with extends
        
        
            Your eslint.config.js files can now use extends to simplify your configuration.
        
        
            
            
            
                Nicholas C. Zakas
                07 Mar, 2025
            
        
    

    


    
    
    
    
    


    
    
    

    
    
        
            
                Published under: Release Notes
            
            
                1 min read
            
        

        
            
                ESLint v9.22.0 released
        
        
            We just pushed ESLint v9.22.0, which is a minor release upgrade of ESLint. This release adds some new features and fixes several bugs found in the previous release.
        
        
            
            
            
                Milos Djermanovic
                07 Mar, 2025
            
        
    

    


    
    
    
    
    


    
    
    

    
    
        
            
                Published under: Release Notes
            
            
                2 min read
            
        

        
            
                ESLint v9.21.0 released
        
        
            We just pushed ESLint v9.21.0, which is a minor release upgrade of ESLint. This release adds some new features and fixes several bugs found in the previous release.
        
        
            
            
            
                Francesco Trotta
                21 Feb, 2025
            
        
    

    


    
    
    
    
    


    
    
    

    
    
        
            
                Published under: Announcements
            
            
                3 min read
            
        

        
            
                ESLint now officially supports linting of CSS
        
        
            Taking our next step towards providing a language-agnostic platform for source code linting.
        
        
            
            
            
                Nicholas C. Zakas
                18 Feb, 2025
            
        
    

    


    
    
    
    
    


    
    
    

    
    
        
            
                Published under: Release Notes
            
            
                1 min read
            
        

        
            
                ESLint v9.20.1 released
        
        
            We just pushed ESLint v9.20.1, which is a patch release upgrade of ESLint. This release fixes several bugs found in the previous release.
        
        
            
            
            
                Nicholas C. Zakas
                11 Feb, 2025
            
        
    

    


    
    
    
    
    


    
    
    

    
    
        
            
                Published under: Release Notes
            
            
                2 min read
            
        

        
            
                ESLint v9.20.0 released
        
        
            We just pushed ESLint v9.20.0, which is a minor release upgrade of ESLint. This release adds some new features and fixes several bugs found in the previous release.
        
        
            
            
            
                Francesco Trotta
                07 Feb, 2025
            
        
    

    


        
        
            
    Pagination
    
        
    Page 1 of 48
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
        
        First
        
        
        
            
            Previous
        

    
    
        
        
            Next
            
        
        
        Last\n\nNews and Updates
            
                The latest ESLint news, case studies, tutorials, and resources.
            
            
        
        
            






        
    


    
        
            
    
        Search
    
    
        
        Results will be shown and updated as you type.
        
            
            
            
                Clear Search
                
            
            
                
                    Powered by
                    
                
            
        
    
    



            
    Categories
    
        
        Everything
        
            

                

                Announcements
            
        
            

                

                API Changes
            
        
            

                

                Case Studies
            
        
            

                

                Financials
            
        
            

                

                Policy Updates
            
        
            

                

                Postmortems
            
        
            

                

                Release Notes
            
        
            

                

                Sponsorships
            
        
            

                

                Storytime
            
        
        
    


        

        
            



    
    


    
    
    
    
    


    
    
    

    
    
        
            
                Published under: Announcements
            
            
                3 min read
            
        

        
            
                Introducing bulk suppressions
        
        
            How to enable stricter linting incrementally
        
        
            
            
            
                Iacovos Constantinou
                04 Apr, 2025
            
        
    

    


    
    
    
    
    


    
    
    

    
    
        
            
                Published under: Release Notes
            
            
                3 min read
            
        

        
            
                ESLint v9.24.0 released
        
        
            We just pushed ESLint v9.24.0, which is a minor release upgrade of ESLint. This release adds some new features and fixes several bugs found in the previous release.
        
        
            
            
            
                Milos Djermanovic
                04 Apr, 2025
            
        
    

    


    
    
    
    
    


    
    
    

    
    
        
            
                Published under: Release Notes
            
            
                3 min read
            
        

        
            
                ESLint v9.23.0 released
        
        
            We just pushed ESLint v9.23.0, which is a minor release upgrade of ESLint. This release adds some new features and fixes several bugs found in the previous release.
        
        
            
            
            
                Francesco Trotta
                21 Mar, 2025
            
        
    

    


    
    
    
    
    


    
    
    

    
    
        
            
                Published under: Announcements
            
            
                5 min read
            
        

        
            
                Evolving flat config with extends
        
        
            Your eslint.config.js files can now use extends to simplify your configuration.
        
        
            
            
            
                Nicholas C. Zakas
                07 Mar, 2025
            
        
    

    


    
    
    
    
    


    
    
    

    
    
        
            
                Published under: Release Notes
            
            
                1 min read
            
        

        
            
                ESLint v9.22.0 released
        
        
            We just pushed ESLint v9.22.0, which is a minor release upgrade of ESLint. This release adds some new features and fixes several bugs found in the previous release.
        
        
            
            
            
                Milos Djermanovic
                07 Mar, 2025
            
        
    

    


    
    
    
    
    


    
    
    

    
    
        
            
                Published under: Release Notes
            
            
                2 min read
            
        

        
            
                ESLint v9.21.0 released
        
        
            We just pushed ESLint v9.21.0, which is a minor release upgrade of ESLint. This release adds some new features and fixes several bugs found in the previous release.
        
        
            
            
            
                Francesco Trotta
                21 Feb, 2025
            
        
    

    


    
    
    
    
    


    
    
    

    
    
        
            
                Published under: Announcements
            
            
                3 min read
            
        

        
            
                ESLint now officially supports linting of CSS
        
        
            Taking our next step towards providing a language-agnostic platform for source code linting.
        
        
            
            
            
                Nicholas C. Zakas
                18 Feb, 2025
            
        
    

    


    
    
    
    
    


    
    
    

    
    
        
            
                Published under: Release Notes
            
            
                1 min read
            
        

        
            
                ESLint v9.20.1 released
        
        
            We just pushed ESLint v9.20.1, which is a patch release upgrade of ESLint. This release fixes several bugs found in the previous release.
        
        
            
            
            
                Nicholas C. Zakas
                11 Feb, 2025
            
        
    

    


    
    
    
    
    


    
    
    

    
    
        
            
                Published under: Release Notes
            
            
                2 min read
            
        

        
            
                ESLint v9.20.0 released
        
        
            We just pushed ESLint v9.20.0, which is a minor release upgrade of ESLint. This release adds some new features and fixes several bugs found in the previous release.
        
        
            
            
            
                Francesco Trotta
                07 Feb, 2025
            
        
    

    


        
        
            
    Pagination
    
        
    Page 1 of 48
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
        
        First
        
        
        
            
            Previous
        

    
    
        
        
            Next
            
        
        
        Last\n\n\n\n\n\n\n\n\n\nESLint Versions
            
                Choose the documentation version
            







    
        
            
HEAD
v9.24.0
v8.57.1Previous Versions\n\nESLint Versions
            
                Choose the documentation version
            







    
        
            
HEAD
v9.24.0
v8.57.1Previous Versions\n\n\n\nUse ESLint in Your Project
                

                Table of Contents
    
        
                
                    
                    Getting Started
            		

                    Core Concepts
            		

                    Configure ESLint
            		

                    Command Line Interface Reference
            		

                    Rules Reference
            		

                    Formatters Reference
            		

                    Integrations
            		

                    Rule Deprecation
            		

                    Migrating
            		
                
            
    


                This guide is intended for those who wish to use ESLint as an end-user. If you’re looking for how to extend ESLint or work with the ESLint source code, please see the Extend ESLint documentation.
Getting Started
Want to skip ahead and just start using ESLint? This section gives a high-level overview of installation, setup, and configuration options.
Core Concepts
Understand the main components of ESLint and how to use them in your project.
Configure ESLint
Once you’ve got ESLint running, you’ll probably want to adjust the configuration to better suit your project. This section explains all the different ways you can configure ESLint.
Command Line Interface Reference
There are a lot of command line flags for ESLint and this section explains what they do.
Rules Reference
ESLint has a lot of rules that you can configure to fine-tune it to your project. This section is an exhaustive list of every rule and link to each rule’s documentation.
Formatters Reference
Control the appearance of the linting results with formatters. View all built-in formatters on this page.
Integrations
Wondering if ESLint will work with your favorite editor or build system? This page has a list of integrations (submitted by their authors).
Rule Deprecation
The ESLint team is committed to making upgrading as easy and painless as possible. This section outlines the guidelines the team has set in place for the deprecation of rules in future releases.
Migrating
If you were using a prior version of ESLint, you can get help with the transition by reading:

migrating-to-1.0.0
migrating-to-2.0.0
migrating-to-3.0.0
migrating-to-4.0.0
migrating-to-5.0.0
migrating-to-6.0.0
migrating-to-7.0.0
migrate-to-8.0.0
migrate-to-9.x


            

            
                Edit this page\n\nUse ESLint in Your Project
                

                Table of Contents
    
        
                
                    
                    Getting Started
            		

                    Core Concepts
            		

                    Configure ESLint
            		

                    Command Line Interface Reference
            		

                    Rules Reference
            		

                    Formatters Reference
            		

                    Integrations
            		

                    Rule Deprecation
            		

                    Migrating
            		
                
            
    


                This guide is intended for those who wish to use ESLint as an end-user. If you’re looking for how to extend ESLint or work with the ESLint source code, please see the Extend ESLint documentation.
Getting Started
Want to skip ahead and just start using ESLint? This section gives a high-level overview of installation, setup, and configuration options.
Core Concepts
Understand the main components of ESLint and how to use them in your project.
Configure ESLint
Once you’ve got ESLint running, you’ll probably want to adjust the configuration to better suit your project. This section explains all the different ways you can configure ESLint.
Command Line Interface Reference
There are a lot of command line flags for ESLint and this section explains what they do.
Rules Reference
ESLint has a lot of rules that you can configure to fine-tune it to your project. This section is an exhaustive list of every rule and link to each rule’s documentation.
Formatters Reference
Control the appearance of the linting results with formatters. View all built-in formatters on this page.
Integrations
Wondering if ESLint will work with your favorite editor or build system? This page has a list of integrations (submitted by their authors).
Rule Deprecation
The ESLint team is committed to making upgrading as easy and painless as possible. This section outlines the guidelines the team has set in place for the deprecation of rules in future releases.
Migrating
If you were using a prior version of ESLint, you can get help with the transition by reading:

migrating-to-1.0.0
migrating-to-2.0.0
migrating-to-3.0.0
migrating-to-4.0.0
migrating-to-5.0.0
migrating-to-6.0.0
migrating-to-7.0.0
migrate-to-8.0.0
migrate-to-9.x


            

            
                Edit this page\n\n\n\nGetting Started with ESLint
                

                Table of Contents
    
        
                
                    
                    Prerequisites
            		

                    Quick start
            		

                    Configuration
            		

                    Global Install
            		

                    Manual Set Up
            		

                    Next Steps
            		
                
            
    


                ESLint is a tool for identifying and reporting on patterns found in ECMAScript/JavaScript code, with the goal of making code more consistent and avoiding bugs.
ESLint is completely pluggable. Every single rule is a plugin and you can add more at runtime. You can also add community plugins, configurations, and parsers to extend the functionality of ESLint.
Prerequisites
To use ESLint, you must have Node.js (^18.18.0, ^20.9.0, or >=21.1.0) installed and built with SSL support. (If you are using an official Node.js distribution, SSL is always built in.)
Quick start
You can install and configure ESLint using this command:

   
      npm
      yarn
      pnpm
      bun
   
    
        npm


    npm init @eslint/config@latest
1
    
        Copy code to clipboard
        
    


   
      yarn


    yarn create @eslint/config
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm create @eslint/config@latest
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bun create @eslint/config@latest
1
    
        Copy code to clipboard
        
    

   

If you want to use a specific shareable config that is hosted on npm, you can use the --config option and specify the package name:

   
      npm
      yarn
      pnpm
      bun
   
    
        npm


    # use `eslint-config-standard` shared config - npm 7+
npm init @eslint/config@latest -- --config eslint-config-standard
12
    
        Copy code to clipboard
        
    


   
      yarn


    # use `eslint-config-standard` shared config - npm 7+
yarn create @eslint/config -- --config eslint-config-standard
12
    
        Copy code to clipboard
        
    

   
   
      pnpm


    # use `eslint-config-standard` shared config - npm 7+
pnpm create @eslint/config@latest -- --config eslint-config-standard
12
    
        Copy code to clipboard
        
    

   
   
      bun


    # use `eslint-config-standard` shared config - npm 7+
bun create @eslint/config@latest -- --config eslint-config-standard
12
    
        Copy code to clipboard
        
    

   

Note: npm init @eslint/config assumes you have a package.json file already. If you don’t, make sure to run npm init or yarn init beforehand.
After that, you can run ESLint on any file or directory like this:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint yourfile.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint yourfile.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint yourfile.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint yourfile.js 
1
    
        Copy code to clipboard
        
    

   

Configuration
Note: If you are coming from a version before 9.0.0 please see the migration guide.
When you run npm init @eslint/config, you’ll be asked a series of questions to determine how you’re using ESLint and what options should be included. After answering these questions, you’ll have an eslint.config.js (or eslint.config.mjs) file created in your directory.
For example, one of the questions is “Where does your code run?” If you select “Browser” then your configuration file will contain the definitions for global variables found in web browsers. Here’s an example:


    import { defineConfig } from "eslint/config";
import globals from "globals";
import js from "@eslint/js";

export default defineConfig([
	{ files: ["**/*.js"], languageOptions: { globals: globals.browser } },
	{ files: ["**/*.js"], plugins: { js }, extends: ["js/recommended"] },
]);
12345678
    
        Copy code to clipboard
        
    

The "js/recommended" configuration ensures all of the rules marked as recommended on the rules page will be turned on. Alternatively, you can use configurations that others have created by searching for “eslint-config” on npmjs.com. ESLint will not lint your code unless you extend from a shared configuration or explicitly turn rules on in your configuration.
You can configure rules individually by defining a new object with a rules key, as in this example:


    import { defineConfig } from "eslint/config";
import js from "@eslint/js";

export default defineConfig([
	{ files: ["**/*.js"], plugins: { js }, extends: ["js/recommended"] },

	{
		rules: {
			"no-unused-vars": "warn",
			"no-undef": "warn",
		},
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    

The names "no-unused-vars" and "no-undef" are the names of rules in ESLint. The first value is the error level of the rule and can be one of these values:

“off” or 0 - turn the rule off
“warn” or 1 - turn the rule on as a warning (doesn’t affect exit code)
“error” or 2 - turn the rule on as an error (exit code will be 1)

The three error levels allow you fine-grained control over how ESLint applies rules (for more configuration options and details, see the configuration docs).
Global Install
It is also possible to install ESLint globally, rather than locally, using npm install eslint --global. However, this is not recommended, and any plugins or shareable configs that you use must still be installed locally if you install ESLint globally.
Manual Set Up
You can also manually set up ESLint in your project.

                    
                    
                        Important
                        If you are using pnpm, be sure to create a .npmrc file with at least the following settings:


    auto-install-peers=true
node-linker=hoisted
12
    
        Copy code to clipboard
        
    

This ensures that pnpm installs dependencies in a way that is more compatible with npm and is less likely to produce errors.

                    
                Before you begin, you must already have a package.json file. If you don’t, make sure to run npm init or yarn init to create the file beforehand.

Install the ESLint packages in your project:


   
      npm
      yarn
      pnpm
      bun
   
    
        npm


    npm install --save-dev eslint @eslint/js
1
    
        Copy code to clipboard
        
    


   
      yarn


    yarn add --dev eslint @eslint/js
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm add --save-dev eslint @eslint/js
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bun add --dev eslint @eslint/js
1
    
        Copy code to clipboard
        
    

   



Add an eslint.config.js file:


    # Create JavaScript configuration file
touch eslint.config.js
12
    
        Copy code to clipboard
        
    



Add configuration to the eslint.config.js file. Refer to the Configure ESLint documentation to learn how to add rules, custom configurations, plugins, and more.


    import { defineConfig } from "eslint/config";
import js from "@eslint/js";

export default defineConfig([
	{
		files: ["**/*.js"],
		plugins: {
			js,
		},
		extends: ["js/recommended"],
		rules: {
			"no-unused-vars": "warn",
			"no-undef": "warn",
		},
	},
]);
12345678910111213141516
    
        Copy code to clipboard
        
    



Lint code using the ESLint CLI:



   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint project-dir/ file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint project-dir/ file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint project-dir/ file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint project-dir/ file.js 
1
    
        Copy code to clipboard
        
    

   

For more information on the available CLI options, refer to Command Line Interface.

Next Steps

Learn about advanced configuration of ESLint.
Get familiar with the command line options.
Explore ESLint integrations into other tools like editors, build systems, and more.
Can’t find just the right rule? Make your own custom rule.
Make ESLint even better by contributing.


            

            
                Edit this page\n\nGetting Started with ESLint
                

                Table of Contents
    
        
                
                    
                    Prerequisites
            		

                    Quick start
            		

                    Configuration
            		

                    Global Install
            		

                    Manual Set Up
            		

                    Next Steps
            		
                
            
    


                ESLint is a tool for identifying and reporting on patterns found in ECMAScript/JavaScript code, with the goal of making code more consistent and avoiding bugs.
ESLint is completely pluggable. Every single rule is a plugin and you can add more at runtime. You can also add community plugins, configurations, and parsers to extend the functionality of ESLint.
Prerequisites
To use ESLint, you must have Node.js (^18.18.0, ^20.9.0, or >=21.1.0) installed and built with SSL support. (If you are using an official Node.js distribution, SSL is always built in.)
Quick start
You can install and configure ESLint using this command:

   
      npm
      yarn
      pnpm
      bun
   
    
        npm


    npm init @eslint/config@latest
1
    
        Copy code to clipboard
        
    


   
      yarn


    yarn create @eslint/config
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm create @eslint/config@latest
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bun create @eslint/config@latest
1
    
        Copy code to clipboard
        
    

   

If you want to use a specific shareable config that is hosted on npm, you can use the --config option and specify the package name:

   
      npm
      yarn
      pnpm
      bun
   
    
        npm


    # use `eslint-config-standard` shared config - npm 7+
npm init @eslint/config@latest -- --config eslint-config-standard
12
    
        Copy code to clipboard
        
    


   
      yarn


    # use `eslint-config-standard` shared config - npm 7+
yarn create @eslint/config -- --config eslint-config-standard
12
    
        Copy code to clipboard
        
    

   
   
      pnpm


    # use `eslint-config-standard` shared config - npm 7+
pnpm create @eslint/config@latest -- --config eslint-config-standard
12
    
        Copy code to clipboard
        
    

   
   
      bun


    # use `eslint-config-standard` shared config - npm 7+
bun create @eslint/config@latest -- --config eslint-config-standard
12
    
        Copy code to clipboard
        
    

   

Note: npm init @eslint/config assumes you have a package.json file already. If you don’t, make sure to run npm init or yarn init beforehand.
After that, you can run ESLint on any file or directory like this:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint yourfile.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint yourfile.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint yourfile.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint yourfile.js 
1
    
        Copy code to clipboard
        
    

   

Configuration
Note: If you are coming from a version before 9.0.0 please see the migration guide.
When you run npm init @eslint/config, you’ll be asked a series of questions to determine how you’re using ESLint and what options should be included. After answering these questions, you’ll have an eslint.config.js (or eslint.config.mjs) file created in your directory.
For example, one of the questions is “Where does your code run?” If you select “Browser” then your configuration file will contain the definitions for global variables found in web browsers. Here’s an example:


    import { defineConfig } from "eslint/config";
import globals from "globals";
import js from "@eslint/js";

export default defineConfig([
	{ files: ["**/*.js"], languageOptions: { globals: globals.browser } },
	{ files: ["**/*.js"], plugins: { js }, extends: ["js/recommended"] },
]);
12345678
    
        Copy code to clipboard
        
    

The "js/recommended" configuration ensures all of the rules marked as recommended on the rules page will be turned on. Alternatively, you can use configurations that others have created by searching for “eslint-config” on npmjs.com. ESLint will not lint your code unless you extend from a shared configuration or explicitly turn rules on in your configuration.
You can configure rules individually by defining a new object with a rules key, as in this example:


    import { defineConfig } from "eslint/config";
import js from "@eslint/js";

export default defineConfig([
	{ files: ["**/*.js"], plugins: { js }, extends: ["js/recommended"] },

	{
		rules: {
			"no-unused-vars": "warn",
			"no-undef": "warn",
		},
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    

The names "no-unused-vars" and "no-undef" are the names of rules in ESLint. The first value is the error level of the rule and can be one of these values:

“off” or 0 - turn the rule off
“warn” or 1 - turn the rule on as a warning (doesn’t affect exit code)
“error” or 2 - turn the rule on as an error (exit code will be 1)

The three error levels allow you fine-grained control over how ESLint applies rules (for more configuration options and details, see the configuration docs).
Global Install
It is also possible to install ESLint globally, rather than locally, using npm install eslint --global. However, this is not recommended, and any plugins or shareable configs that you use must still be installed locally if you install ESLint globally.
Manual Set Up
You can also manually set up ESLint in your project.

                    
                    
                        Important
                        If you are using pnpm, be sure to create a .npmrc file with at least the following settings:


    auto-install-peers=true
node-linker=hoisted
12
    
        Copy code to clipboard
        
    

This ensures that pnpm installs dependencies in a way that is more compatible with npm and is less likely to produce errors.

                    
                Before you begin, you must already have a package.json file. If you don’t, make sure to run npm init or yarn init to create the file beforehand.

Install the ESLint packages in your project:


   
      npm
      yarn
      pnpm
      bun
   
    
        npm


    npm install --save-dev eslint @eslint/js
1
    
        Copy code to clipboard
        
    


   
      yarn


    yarn add --dev eslint @eslint/js
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm add --save-dev eslint @eslint/js
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bun add --dev eslint @eslint/js
1
    
        Copy code to clipboard
        
    

   



Add an eslint.config.js file:


    # Create JavaScript configuration file
touch eslint.config.js
12
    
        Copy code to clipboard
        
    



Add configuration to the eslint.config.js file. Refer to the Configure ESLint documentation to learn how to add rules, custom configurations, plugins, and more.


    import { defineConfig } from "eslint/config";
import js from "@eslint/js";

export default defineConfig([
	{
		files: ["**/*.js"],
		plugins: {
			js,
		},
		extends: ["js/recommended"],
		rules: {
			"no-unused-vars": "warn",
			"no-undef": "warn",
		},
	},
]);
12345678910111213141516
    
        Copy code to clipboard
        
    



Lint code using the ESLint CLI:



   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint project-dir/ file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint project-dir/ file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint project-dir/ file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint project-dir/ file.js 
1
    
        Copy code to clipboard
        
    

   

For more information on the available CLI options, refer to Command Line Interface.

Next Steps

Learn about advanced configuration of ESLint.
Get familiar with the command line options.
Explore ESLint integrations into other tools like editors, build systems, and more.
Can’t find just the right rule? Make your own custom rule.
Make ESLint even better by contributing.


            

            
                Edit this page\n\n\n\nCore Concepts
                

                Table of Contents
    
        
                
                    
                    What is ESLint?
            		

                    Rules
            
                
                    
                    Rule Fixes
            		

                    Rule Suggestions
            		
                
            		

                    Configuration Files
            		

                    Shareable Configurations
            		

                    Plugins
            		

                    Parsers
            		

                    Custom Processors
            		

                    Formatters
            		

                    Integrations
            		

                    CLI & Node.js API
            		
                
            
    


                This page contains a high-level overview of some of the core concepts of ESLint.
What is ESLint?
ESLint is a configurable JavaScript linter. It helps you find and fix problems in your JavaScript code. Problems can be anything from potential runtime bugs, to not following best practices, to styling issues.
Rules
Rules are the core building block of ESLint. A rule validates if your code meets a certain expectation, and what to do if it does not meet that expectation. Rules can also contain additional configuration options specific to that rule.
For example, the semi rule lets you specify whether or not JavaScript statements should end with a semicolon (;). You can set the rule to either always require semicolons or require that a statement never ends with a semicolon.
ESLint contains hundreds of built-in rules that you can use. You can also create custom rules or use rules that others have created with plugins.
For more information, refer to Rules.
Rule Fixes
Rules may optionally provide fixes for violations that they find. Fixes safely correct the violation without changing application logic.
Fixes may be applied automatically with the --fix command line option and via editor extensions.
Rules that may provide fixes are marked with 🔧 in Rules.
Rule Suggestions
Rules may optionally provide suggestions in addition to or instead of providing fixes. Suggestions differ from fixes in two ways:

Suggestions may change application logic and so cannot be automatically applied.
Suggestions cannot be applied through the ESLint CLI and are only available through editor integrations.

Rules that may provide suggestions are marked with 💡 in Rules.
Configuration Files
An ESLint configuration file is a place where you put the configuration for ESLint in your project. You can include built-in rules, how you want them enforced, plugins with custom rules, shareable configurations, which files you want rules to apply to, and more.
For more information, refer to Configuration Files.
Shareable Configurations
Shareable configurations are ESLint configurations that are shared via npm.
Often shareable configurations are used to enforce style guides using ESLint’s built-in rules. For example the sharable configuration eslint-config-airbnb-base implements the popular Airbnb JavaScript style guide.
For more information, refer to Using a shareable configuration package.
Plugins
An ESLint plugin is an npm module that can contain a set of ESLint rules, configurations, processors, and languages. Often plugins include custom rules. Plugins can be used to enforce a style guide and support JavaScript extensions (like TypeScript), libraries (like React), and frameworks (Angular).
A popular use case for plugins is to enforce best practices for a framework. For example, @angular-eslint/eslint-plugin contains best practices for using the Angular framework.
For more information, refer to Configure Plugins.
Parsers
An ESLint parser converts code into an abstract syntax tree that ESLint can evaluate. By default, ESLint uses the built-in Espree parser, which is compatible with standard JavaScript runtimes and versions.
Custom parsers let ESLint parse non-standard JavaScript syntax. Often custom parsers are included as part of shareable configurations or plugins, so you don’t have to use them directly.
For example, @typescript-eslint/parser is a custom parser included in the typescript-eslint project that lets ESLint parse TypeScript code.
Custom Processors
An ESLint processor extracts JavaScript code from other kinds of files, then lets ESLint lint the JavaScript code. Alternatively, you can use a processor to manipulate JavaScript code before parsing it with ESLint.
For example, @eslint/markdown contains a custom processor that lets you lint JavaScript code inside of Markdown code blocks.
Formatters
An ESLint formatter controls the appearance of the linting results in the CLI.
For more information, refer to Formatters.
Integrations
One of the things that makes ESLint such a useful tool is the ecosystem of integrations that surrounds it. For example, many code editors have ESLint extensions that show you the ESLint results of your code in the file as you work so that you don’t need to use the ESLint CLI to see linting results.
For more information, refer to Integrations.
CLI & Node.js API
The ESLint CLI is a command line interface that lets you execute linting from the terminal. The CLI has a variety of options that you can pass to its commands.
The ESLint Node.js API lets you use ESLint programmatically from Node.js code. The API is useful when developing plugins, integrations, and other tools related to ESLint.
Unless you are extending ESLint in some way, you should use the CLI.
For more information, refer to Command Line Interface and Node.js API.

            

            
                Edit this page\n\nCore Concepts
                

                Table of Contents
    
        
                
                    
                    What is ESLint?
            		

                    Rules
            
                
                    
                    Rule Fixes
            		

                    Rule Suggestions
            		
                
            		

                    Configuration Files
            		

                    Shareable Configurations
            		

                    Plugins
            		

                    Parsers
            		

                    Custom Processors
            		

                    Formatters
            		

                    Integrations
            		

                    CLI & Node.js API
            		
                
            
    


                This page contains a high-level overview of some of the core concepts of ESLint.
What is ESLint?
ESLint is a configurable JavaScript linter. It helps you find and fix problems in your JavaScript code. Problems can be anything from potential runtime bugs, to not following best practices, to styling issues.
Rules
Rules are the core building block of ESLint. A rule validates if your code meets a certain expectation, and what to do if it does not meet that expectation. Rules can also contain additional configuration options specific to that rule.
For example, the semi rule lets you specify whether or not JavaScript statements should end with a semicolon (;). You can set the rule to either always require semicolons or require that a statement never ends with a semicolon.
ESLint contains hundreds of built-in rules that you can use. You can also create custom rules or use rules that others have created with plugins.
For more information, refer to Rules.
Rule Fixes
Rules may optionally provide fixes for violations that they find. Fixes safely correct the violation without changing application logic.
Fixes may be applied automatically with the --fix command line option and via editor extensions.
Rules that may provide fixes are marked with 🔧 in Rules.
Rule Suggestions
Rules may optionally provide suggestions in addition to or instead of providing fixes. Suggestions differ from fixes in two ways:

Suggestions may change application logic and so cannot be automatically applied.
Suggestions cannot be applied through the ESLint CLI and are only available through editor integrations.

Rules that may provide suggestions are marked with 💡 in Rules.
Configuration Files
An ESLint configuration file is a place where you put the configuration for ESLint in your project. You can include built-in rules, how you want them enforced, plugins with custom rules, shareable configurations, which files you want rules to apply to, and more.
For more information, refer to Configuration Files.
Shareable Configurations
Shareable configurations are ESLint configurations that are shared via npm.
Often shareable configurations are used to enforce style guides using ESLint’s built-in rules. For example the sharable configuration eslint-config-airbnb-base implements the popular Airbnb JavaScript style guide.
For more information, refer to Using a shareable configuration package.
Plugins
An ESLint plugin is an npm module that can contain a set of ESLint rules, configurations, processors, and languages. Often plugins include custom rules. Plugins can be used to enforce a style guide and support JavaScript extensions (like TypeScript), libraries (like React), and frameworks (Angular).
A popular use case for plugins is to enforce best practices for a framework. For example, @angular-eslint/eslint-plugin contains best practices for using the Angular framework.
For more information, refer to Configure Plugins.
Parsers
An ESLint parser converts code into an abstract syntax tree that ESLint can evaluate. By default, ESLint uses the built-in Espree parser, which is compatible with standard JavaScript runtimes and versions.
Custom parsers let ESLint parse non-standard JavaScript syntax. Often custom parsers are included as part of shareable configurations or plugins, so you don’t have to use them directly.
For example, @typescript-eslint/parser is a custom parser included in the typescript-eslint project that lets ESLint parse TypeScript code.
Custom Processors
An ESLint processor extracts JavaScript code from other kinds of files, then lets ESLint lint the JavaScript code. Alternatively, you can use a processor to manipulate JavaScript code before parsing it with ESLint.
For example, @eslint/markdown contains a custom processor that lets you lint JavaScript code inside of Markdown code blocks.
Formatters
An ESLint formatter controls the appearance of the linting results in the CLI.
For more information, refer to Formatters.
Integrations
One of the things that makes ESLint such a useful tool is the ecosystem of integrations that surrounds it. For example, many code editors have ESLint extensions that show you the ESLint results of your code in the file as you work so that you don’t need to use the ESLint CLI to see linting results.
For more information, refer to Integrations.
CLI & Node.js API
The ESLint CLI is a command line interface that lets you execute linting from the terminal. The CLI has a variety of options that you can pass to its commands.
The ESLint Node.js API lets you use ESLint programmatically from Node.js code. The API is useful when developing plugins, integrations, and other tools related to ESLint.
Unless you are extending ESLint in some way, you should use the CLI.
For more information, refer to Command Line Interface and Node.js API.

            

            
                Edit this page\n\n\n\nGlossary
                

                Table of Contents
    
        
                
                    
                    A
            
                
                    
                    Abstract Syntax Tree (AST)
            		
                
            		

                    C
            
                
                    
                    Config File (Configuration File)
            		

                    Config Array
            		

                    Config Object
            		
                
            		

                    E
            
                
                    
                    ESQuery
            		

                    ESTree
            		
                
            		

                    F
            
                
                    
                    Fix
            		

                    Flat Config
            		

                    Formatter (Linting)
            		

                    Formatter (Tool)
            		

                    Formatting (Rule)
            		
                
            		

                    G
            
                
                    
                    Global Declaration
            		

                    Global Variable
            		
                
            		

                    I
            
                
                    
                    Inline Config (Configuration Comment)
            		
                
            		

                    L
            
                
                    
                    Legacy Config
            		

                    Linter
            		

                    Logical Rule
            		
                
            		

                    N
            
                
                    
                    Node
            		
                
            		

                    O
            
                
                    
                    Override
            		
                
            		

                    P
            
                
                    
                    Parser
            		

                    Plugin
            		

                    Processor
            		
                
            		

                    R
            
                
                    
                    Report
            		

                    Rule
            		
                
            		

                    S
            
                
                    
                    Selector
            		

                    Severity
            		

                    Shareable Config (Configuration)
            		

                    Static Analysis
            		

                    Stylistic (Rule)
            		

                    Suggestion
            		
                
            		

                    T
            
                
                    
                    Type Checker
            		
                
            		

                    V
            
                
                    
                    Violation
            		
                
            		
                
            
    


                This page serves as a reference for common terms associated with ESLint.
A
Abstract Syntax Tree (AST)
A structured representation of code syntax.
Each section of source code in an AST is referred to as a node.
Each node may have any number of properties, including properties that store child nodes.
The AST format used by ESLint is the ESTree format.
ESLint rules are given an AST and may produce violations on parts of the AST when they detect a violation.
C
Config File (Configuration File)
A file containing preferences for how ESLint should parse files and run rules.
ESLint config files are named like eslint.config.(c|m)js.
Each config file exports a config array containing config objects.
For example, this eslint.config.js file enables the prefer-const rule at the error severity:


    export default [
	{
		rules: {
			"prefer-const": "error",
		},
	},
];
1234567
    
        Copy code to clipboard
        
    

See Configuration Files for more details.
Config Array
An array of config objects within a config file.
Each config file exports an array of config objects.
The objects in the array are evaluated in order: later objects may override settings specified in earlier objects.
See Configuration Files for more details.
Config Object
A config file entry specifying all of the information ESLint needs to execute on a set of files.
Each configuration object may include properties describing which files to run on, how to handle different file types, which plugins to include, and how to run rules.
See Configuration Files > Configuration Objects for more details.
E
ESQuery
The library used by ESLint to parse selector syntax for querying nodes in an AST.
ESQuery interprets CSS syntax for AST node properties.
Examples of ESQuery selectors include:

BinaryExpression: selects all nodes of type BinaryExpression
BinaryExpression[operator='+']: selects all BinaryExpression nodes whose operator is +
BinaryExpression > Literal[value=1]: selects all Literal nodes with value 1 whose direct parent is a BinaryExpression

See github.com/estools/esquery for more information on the ESQuery format.
ESTree
The format used by ESLint for how to represent JavaScript syntax as an AST.
For example, the ESTree representation of the code 1 + 2; would be an object roughly like:


    {
	"type": "ExpressionStatement",
	"expression": {
		"type": "BinaryExpression",
		"left": {
			"type": "Literal",
			"value": 1,
			"raw": "1"
		},
		"operator": "+",
		"right": {
			"type": "Literal",
			"value": 2,
			"raw": "2"
		}
	}
}
1234567891011121314151617
    
        Copy code to clipboard
        
    

Static analysis tools such as ESLint typically operate by converting syntax into an AST in the ESTree format.
See github.com/estree/estree for more information on the ESTree specification.
F
Fix
An optional augmentation to a rule violation that describes how to automatically correct the violation.
Fixes are generally “safe” to apply automatically: they shouldn’t cause code behavior changes.
ESLint attempts to apply as many fixes as possible in a report when run with the --fix flag, though there is no guarantee that all fixes will be applied.
Fixes may also be applied by common editor extensions.
Rule violations may also include file changes that are unsafe and not automatically applied in the form of suggestions.
Flat Config
The current configuration file format for ESLint.
Flat config files are named in the format eslint.config.(c|m)?js.
“Flat” config files are named as such because all nesting must be done in one configuration file.
In contrast, the “Legacy” config format allowed nesting configuration files in sub-directories within a project.
You can read more about the motivations behind flat configurations in ESLint’s new config system, Part 2: Introduction to flat config.
Formatter (Linting)
A package that presents the report generated by ESLint.
ESLint ships with several built-in reporters, including stylish (default), json, and html.
For more information, see Formatters.
Formatter (Tool)
A static analysis tool that quickly reformats code without changing its logic or names.
Formatters generally only modify the “trivia” of code, such as semicolons, spacing, newlines, and whitespace in general.
Trivia changes generally don’t modify the AST of code.
Common formatters in the ecosystem include Prettier and dprint.
Note that although ESLint is a linter rather than a formatter, ESLint rules can also apply formatting changes to source code.
See Formatting (Rule) for more information on formatting rules.
Formatting (Rule)
A rule that solely targets formatting concerns, such as semicolons and whitespace.
These rules don’t change application logic and are a subset of Stylistic rules.
ESLint no longer recommends formatting rules and previously deprecated its built-in formatting rules.
ESLint recommends instead using a dedicated formatter such as Prettier or dprint.
Alternately, the ESLint Stylistic project provides formatting-related lint rules.
For more information, see Deprecation of formatting rules.
G
Global Declaration
A description to ESLint of a JavaScript global variable that should exist at runtime.
Global declarations inform lint rules that check for proper uses of global variables.
For example, the no-undef rule will create a violation for references to global variables not defined in the configured list of globals.
Config files have globals defined as JavaScript objects.
For information about configuring globals, see Configure Language Options > Specifying Globals.
Global Variable
A runtime variable that exists in the global scope, meaning all modules and scripts have access to it.
Global variables in JavaScript are declared on the globalThis object (generally aliased as global in Node.js and window in browsers).
You can let ESLint know which global variables your code uses with global declarations.
I
Inline Config (Configuration Comment)
A source code comment that configures a rule to a different severity and/or set of options.
Inline configs use similar syntax as config files to specify any number of rules by name, their new severity, and optionally new options for the rules.
For example, the following inline config comment simultaneously disables the eqeqeq rule and sets the curly rule to "error":


    /* eslint eqeqeq: "off", curly: "error" */
1
    
        Copy code to clipboard
        
    

For documentation on inline config comments, see Rules > Using configuration comments.
L
Legacy Config
The previous configuration file format for ESLint, now superseded by “Flat” config.
Legacy ESLint configurations are named in the format .eslintrc.* and allowed to be nested across files within sub-directories in a project.
You can read more about the lifetime of legacy configurations in ESLint’s new config system, Part 1: Background.
Linter
A static analysis tool that can report the results from running a set of rules on source code.
Each rule may report any number of violations in the source code.
ESLint is a commonly used linter for JavaScript and other web technologies.
Note that a linter is separate from formatters and type checkers.
Logical Rule
A rule that inspects how code operates to find problems.
Many logical rules look for likely crashes (e.g. no-undef), unintended behavior (e.g. no-sparse-arrays), and unused code (e.g no-unused-vars),
You can see the full list of logical rules that ship with ESLint under Rules > Possible Problems
N
Node
A section of code within an AST.
Each node represents a type of syntax found in source code.
For example, the 1 + 2 in the AST for 1 + 2; is a BinaryExpression.
See #esquery for the library ESLint uses to parse selectors that allow rules to search for nodes.
O
Override
When a config object or inline config sets a new severity and/or rule options that supersede previously set severity and/or options.
The following config file overrides no-unused-expressions from "error" to "off" in *.test.js files:


    export default [
	{
		rules: {
			"no-unused-expressions": "error",
		},
	},
	{
		files: ["*.test.js"],
		rules: {
			"no-unused-expressions": "off",
		},
	},
];
12345678910111213
    
        Copy code to clipboard
        
    

The following inline config sets no-unused-expressions to "error":


    /* eslint no-unused-expressions: "error" */
1
    
        Copy code to clipboard
        
    

For more information on overrides in legacy configs, see Configuration Files (Deprecated) > How do overrides work?.
P
Parser
An object containing a method that reads in a string and converts it to a standardized format.
ESLint uses parsers to convert source code strings into an AST shape.
By default, ESLint uses the Espree parser, which generates an AST compatible with standard JavaScript runtimes and versions.
Custom parsers let ESLint parse non-standard JavaScript syntax.
Often custom parsers are included as part of shareable configurations or plugins, so you don’t have to use them directly.
For example, @typescript-eslint/parser is a custom parser included in the typescript-eslint project that lets ESLint parse TypeScript code.
For more information on using parsers with ESLint, see Configure a Parser.
Plugin
A package that can contain a set of configurations, processors, and/or rules.
A popular use case for plugins is to enforce best practices for a framework.
For example, @angular-eslint/eslint-plugin contains best practices for using the Angular framework.
For more information, refer to Configure Plugins.
Processor
A part of a plugin that extracts JavaScript code from other kinds of files, then lets ESLint lint the JavaScript code.
For example, @eslint/markdown includes a processor that converts the text of ``` code blocks in Markdown files into code that can be linted.
For more information on configuring processor, see Plugins > Specify a Processor.
R
Report
A collection of violations from a single ESLint run.
When ESLint runs on source files, it will pass an AST for each source file to each configured rule.
The collection of violations from each of the rules will be packaged together and passed to a formatter to be presented to the user.
Rule
Code that checks an AST for expected patterns. When a rule’s expectation is not met, it creates a violation.
ESLint provides a large collection of rules that check for common JavaScript code issues.
Many more rules may be loaded in by plugins.
For an overview of rules provided, see Core Concepts > Rules.
S
Selector
Syntax describing how to search for nodes within an AST.
ESLint rules use ESQuery selectors to find nodes that should be checked.
Severity
What level of reporting a rule is configured to run, if at all.
ESLint supports three levels of severity:

"off" (0): Do not run the rule.
"warn" (1): Run the rule, but don’t exit with a non-zero status code based on its violations (excluding the --max-warnings flag)
"error" (2): Run the rule, and exit with a non-zero status code if it produces any violations

For documentation on configuring rules, see Configure Rules.
Shareable Config (Configuration)
A module that provides a predefined config file configurations.
Shareable configs can configure all the same information from config files, including plugins and rules.
Shareable configs are often provided alongside plugins.
Many plugins provide configs with names like “recommended” that enable their suggested starting set of rules.
For example, eslint-plugin-solid provides a shareable recommended config:


    import js from "@eslint/js";
import solid from "eslint-plugin-solid/configs/recommended";

export default [js.configs.recommended, solid];
1234
    
        Copy code to clipboard
        
    

For information on shareable configs, see Share Configurations.
Static Analysis
The process of analyzing source code without building or running it.
Linters such as ESLint, formatters, and type checkers are examples of static analysis tools.
Static analysis is different from dynamic analysis, which is the process of evaluating source code after it is built and executed.
Unit, integration, and end-to-end tests are common examples of dynamic analysis.
Stylistic (Rule)
A rule that enforces a preference rather than a logical issue.
Stylistic areas include Formatting rules, naming conventions, and consistent choices between equivalent syntaxes.
ESLint’s built-in stylistic rules are feature frozen: except for supporting new ECMAScript versions, they won’t receive new features.
For more information, see Changes to our rules policies and Deprecation of formatting rules.
Suggestion
An optional augmentation to a rule violation that describes how one may manually adjust the code to address the violation.
Suggestions are not generally safe to apply automatically because they cause code behavior changes.
ESLint does not apply suggestions directly but does provide suggestion to integrations that may choose to apply suggestions (such as an editor extension).
Rule violations may also include file changes that are safe and may be automatically applied in the form of fixes.
T
Type Checker
A static analysis tool that builds a full understanding of a project’s code constructs and data shapes.
Type checkers are generally slower and more comprehensive than linters.
Whereas linters traditionally operate only on a single file’s or snippet’s AST at a time, type checkers understand cross-file dependencies and types.
TypeScript is the most common type checker for JavaScript.
The typescript-eslint project provides integrations that allow using type checker in lint rules.
V
Violation
An indication from a rule that an area of code doesn’t meet the expectation of the rule.
Rule violations indicate a range in source code and error message explaining the violation.
Violations may also optionally include a fix and/or suggestions that indicate how to improve the violating code.

            

            
                Edit this page\n\nGlossary
                

                Table of Contents
    
        
                
                    
                    A
            
                
                    
                    Abstract Syntax Tree (AST)
            		
                
            		

                    C
            
                
                    
                    Config File (Configuration File)
            		

                    Config Array
            		

                    Config Object
            		
                
            		

                    E
            
                
                    
                    ESQuery
            		

                    ESTree
            		
                
            		

                    F
            
                
                    
                    Fix
            		

                    Flat Config
            		

                    Formatter (Linting)
            		

                    Formatter (Tool)
            		

                    Formatting (Rule)
            		
                
            		

                    G
            
                
                    
                    Global Declaration
            		

                    Global Variable
            		
                
            		

                    I
            
                
                    
                    Inline Config (Configuration Comment)
            		
                
            		

                    L
            
                
                    
                    Legacy Config
            		

                    Linter
            		

                    Logical Rule
            		
                
            		

                    N
            
                
                    
                    Node
            		
                
            		

                    O
            
                
                    
                    Override
            		
                
            		

                    P
            
                
                    
                    Parser
            		

                    Plugin
            		

                    Processor
            		
                
            		

                    R
            
                
                    
                    Report
            		

                    Rule
            		
                
            		

                    S
            
                
                    
                    Selector
            		

                    Severity
            		

                    Shareable Config (Configuration)
            		

                    Static Analysis
            		

                    Stylistic (Rule)
            		

                    Suggestion
            		
                
            		

                    T
            
                
                    
                    Type Checker
            		
                
            		

                    V
            
                
                    
                    Violation
            		
                
            		
                
            
    


                This page serves as a reference for common terms associated with ESLint.
A
Abstract Syntax Tree (AST)
A structured representation of code syntax.
Each section of source code in an AST is referred to as a node.
Each node may have any number of properties, including properties that store child nodes.
The AST format used by ESLint is the ESTree format.
ESLint rules are given an AST and may produce violations on parts of the AST when they detect a violation.
C
Config File (Configuration File)
A file containing preferences for how ESLint should parse files and run rules.
ESLint config files are named like eslint.config.(c|m)js.
Each config file exports a config array containing config objects.
For example, this eslint.config.js file enables the prefer-const rule at the error severity:


    export default [
	{
		rules: {
			"prefer-const": "error",
		},
	},
];
1234567
    
        Copy code to clipboard
        
    

See Configuration Files for more details.
Config Array
An array of config objects within a config file.
Each config file exports an array of config objects.
The objects in the array are evaluated in order: later objects may override settings specified in earlier objects.
See Configuration Files for more details.
Config Object
A config file entry specifying all of the information ESLint needs to execute on a set of files.
Each configuration object may include properties describing which files to run on, how to handle different file types, which plugins to include, and how to run rules.
See Configuration Files > Configuration Objects for more details.
E
ESQuery
The library used by ESLint to parse selector syntax for querying nodes in an AST.
ESQuery interprets CSS syntax for AST node properties.
Examples of ESQuery selectors include:

BinaryExpression: selects all nodes of type BinaryExpression
BinaryExpression[operator='+']: selects all BinaryExpression nodes whose operator is +
BinaryExpression > Literal[value=1]: selects all Literal nodes with value 1 whose direct parent is a BinaryExpression

See github.com/estools/esquery for more information on the ESQuery format.
ESTree
The format used by ESLint for how to represent JavaScript syntax as an AST.
For example, the ESTree representation of the code 1 + 2; would be an object roughly like:


    {
	"type": "ExpressionStatement",
	"expression": {
		"type": "BinaryExpression",
		"left": {
			"type": "Literal",
			"value": 1,
			"raw": "1"
		},
		"operator": "+",
		"right": {
			"type": "Literal",
			"value": 2,
			"raw": "2"
		}
	}
}
1234567891011121314151617
    
        Copy code to clipboard
        
    

Static analysis tools such as ESLint typically operate by converting syntax into an AST in the ESTree format.
See github.com/estree/estree for more information on the ESTree specification.
F
Fix
An optional augmentation to a rule violation that describes how to automatically correct the violation.
Fixes are generally “safe” to apply automatically: they shouldn’t cause code behavior changes.
ESLint attempts to apply as many fixes as possible in a report when run with the --fix flag, though there is no guarantee that all fixes will be applied.
Fixes may also be applied by common editor extensions.
Rule violations may also include file changes that are unsafe and not automatically applied in the form of suggestions.
Flat Config
The current configuration file format for ESLint.
Flat config files are named in the format eslint.config.(c|m)?js.
“Flat” config files are named as such because all nesting must be done in one configuration file.
In contrast, the “Legacy” config format allowed nesting configuration files in sub-directories within a project.
You can read more about the motivations behind flat configurations in ESLint’s new config system, Part 2: Introduction to flat config.
Formatter (Linting)
A package that presents the report generated by ESLint.
ESLint ships with several built-in reporters, including stylish (default), json, and html.
For more information, see Formatters.
Formatter (Tool)
A static analysis tool that quickly reformats code without changing its logic or names.
Formatters generally only modify the “trivia” of code, such as semicolons, spacing, newlines, and whitespace in general.
Trivia changes generally don’t modify the AST of code.
Common formatters in the ecosystem include Prettier and dprint.
Note that although ESLint is a linter rather than a formatter, ESLint rules can also apply formatting changes to source code.
See Formatting (Rule) for more information on formatting rules.
Formatting (Rule)
A rule that solely targets formatting concerns, such as semicolons and whitespace.
These rules don’t change application logic and are a subset of Stylistic rules.
ESLint no longer recommends formatting rules and previously deprecated its built-in formatting rules.
ESLint recommends instead using a dedicated formatter such as Prettier or dprint.
Alternately, the ESLint Stylistic project provides formatting-related lint rules.
For more information, see Deprecation of formatting rules.
G
Global Declaration
A description to ESLint of a JavaScript global variable that should exist at runtime.
Global declarations inform lint rules that check for proper uses of global variables.
For example, the no-undef rule will create a violation for references to global variables not defined in the configured list of globals.
Config files have globals defined as JavaScript objects.
For information about configuring globals, see Configure Language Options > Specifying Globals.
Global Variable
A runtime variable that exists in the global scope, meaning all modules and scripts have access to it.
Global variables in JavaScript are declared on the globalThis object (generally aliased as global in Node.js and window in browsers).
You can let ESLint know which global variables your code uses with global declarations.
I
Inline Config (Configuration Comment)
A source code comment that configures a rule to a different severity and/or set of options.
Inline configs use similar syntax as config files to specify any number of rules by name, their new severity, and optionally new options for the rules.
For example, the following inline config comment simultaneously disables the eqeqeq rule and sets the curly rule to "error":


    /* eslint eqeqeq: "off", curly: "error" */
1
    
        Copy code to clipboard
        
    

For documentation on inline config comments, see Rules > Using configuration comments.
L
Legacy Config
The previous configuration file format for ESLint, now superseded by “Flat” config.
Legacy ESLint configurations are named in the format .eslintrc.* and allowed to be nested across files within sub-directories in a project.
You can read more about the lifetime of legacy configurations in ESLint’s new config system, Part 1: Background.
Linter
A static analysis tool that can report the results from running a set of rules on source code.
Each rule may report any number of violations in the source code.
ESLint is a commonly used linter for JavaScript and other web technologies.
Note that a linter is separate from formatters and type checkers.
Logical Rule
A rule that inspects how code operates to find problems.
Many logical rules look for likely crashes (e.g. no-undef), unintended behavior (e.g. no-sparse-arrays), and unused code (e.g no-unused-vars),
You can see the full list of logical rules that ship with ESLint under Rules > Possible Problems
N
Node
A section of code within an AST.
Each node represents a type of syntax found in source code.
For example, the 1 + 2 in the AST for 1 + 2; is a BinaryExpression.
See #esquery for the library ESLint uses to parse selectors that allow rules to search for nodes.
O
Override
When a config object or inline config sets a new severity and/or rule options that supersede previously set severity and/or options.
The following config file overrides no-unused-expressions from "error" to "off" in *.test.js files:


    export default [
	{
		rules: {
			"no-unused-expressions": "error",
		},
	},
	{
		files: ["*.test.js"],
		rules: {
			"no-unused-expressions": "off",
		},
	},
];
12345678910111213
    
        Copy code to clipboard
        
    

The following inline config sets no-unused-expressions to "error":


    /* eslint no-unused-expressions: "error" */
1
    
        Copy code to clipboard
        
    

For more information on overrides in legacy configs, see Configuration Files (Deprecated) > How do overrides work?.
P
Parser
An object containing a method that reads in a string and converts it to a standardized format.
ESLint uses parsers to convert source code strings into an AST shape.
By default, ESLint uses the Espree parser, which generates an AST compatible with standard JavaScript runtimes and versions.
Custom parsers let ESLint parse non-standard JavaScript syntax.
Often custom parsers are included as part of shareable configurations or plugins, so you don’t have to use them directly.
For example, @typescript-eslint/parser is a custom parser included in the typescript-eslint project that lets ESLint parse TypeScript code.
For more information on using parsers with ESLint, see Configure a Parser.
Plugin
A package that can contain a set of configurations, processors, and/or rules.
A popular use case for plugins is to enforce best practices for a framework.
For example, @angular-eslint/eslint-plugin contains best practices for using the Angular framework.
For more information, refer to Configure Plugins.
Processor
A part of a plugin that extracts JavaScript code from other kinds of files, then lets ESLint lint the JavaScript code.
For example, @eslint/markdown includes a processor that converts the text of ``` code blocks in Markdown files into code that can be linted.
For more information on configuring processor, see Plugins > Specify a Processor.
R
Report
A collection of violations from a single ESLint run.
When ESLint runs on source files, it will pass an AST for each source file to each configured rule.
The collection of violations from each of the rules will be packaged together and passed to a formatter to be presented to the user.
Rule
Code that checks an AST for expected patterns. When a rule’s expectation is not met, it creates a violation.
ESLint provides a large collection of rules that check for common JavaScript code issues.
Many more rules may be loaded in by plugins.
For an overview of rules provided, see Core Concepts > Rules.
S
Selector
Syntax describing how to search for nodes within an AST.
ESLint rules use ESQuery selectors to find nodes that should be checked.
Severity
What level of reporting a rule is configured to run, if at all.
ESLint supports three levels of severity:

"off" (0): Do not run the rule.
"warn" (1): Run the rule, but don’t exit with a non-zero status code based on its violations (excluding the --max-warnings flag)
"error" (2): Run the rule, and exit with a non-zero status code if it produces any violations

For documentation on configuring rules, see Configure Rules.
Shareable Config (Configuration)
A module that provides a predefined config file configurations.
Shareable configs can configure all the same information from config files, including plugins and rules.
Shareable configs are often provided alongside plugins.
Many plugins provide configs with names like “recommended” that enable their suggested starting set of rules.
For example, eslint-plugin-solid provides a shareable recommended config:


    import js from "@eslint/js";
import solid from "eslint-plugin-solid/configs/recommended";

export default [js.configs.recommended, solid];
1234
    
        Copy code to clipboard
        
    

For information on shareable configs, see Share Configurations.
Static Analysis
The process of analyzing source code without building or running it.
Linters such as ESLint, formatters, and type checkers are examples of static analysis tools.
Static analysis is different from dynamic analysis, which is the process of evaluating source code after it is built and executed.
Unit, integration, and end-to-end tests are common examples of dynamic analysis.
Stylistic (Rule)
A rule that enforces a preference rather than a logical issue.
Stylistic areas include Formatting rules, naming conventions, and consistent choices between equivalent syntaxes.
ESLint’s built-in stylistic rules are feature frozen: except for supporting new ECMAScript versions, they won’t receive new features.
For more information, see Changes to our rules policies and Deprecation of formatting rules.
Suggestion
An optional augmentation to a rule violation that describes how one may manually adjust the code to address the violation.
Suggestions are not generally safe to apply automatically because they cause code behavior changes.
ESLint does not apply suggestions directly but does provide suggestion to integrations that may choose to apply suggestions (such as an editor extension).
Rule violations may also include file changes that are safe and may be automatically applied in the form of fixes.
T
Type Checker
A static analysis tool that builds a full understanding of a project’s code constructs and data shapes.
Type checkers are generally slower and more comprehensive than linters.
Whereas linters traditionally operate only on a single file’s or snippet’s AST at a time, type checkers understand cross-file dependencies and types.
TypeScript is the most common type checker for JavaScript.
The typescript-eslint project provides integrations that allow using type checker in lint rules.
V
Violation
An indication from a rule that an area of code doesn’t meet the expectation of the rule.
Rule violations indicate a range in source code and error message explaining the violation.
Violations may also optionally include a fix and/or suggestions that indicate how to improve the violating code.

            

            
                Edit this page\n\n\n\nConfigure ESLint
                

                Table of Contents
    
        
                
                    
                    Table of Contents
            		
                
            
    


                ESLint is designed to be flexible and configurable for your use case. You can turn off every rule and run only with basic syntax validation or mix and match the bundled rules and your custom rules to fit the needs of your project. There are two primary ways to configure ESLint:

Configuration Comments - use JavaScript comments to embed configuration information directly into a file.
Configuration Files - use a JavaScript file to specify configuration information for an entire directory and all of its subdirectories. This can be in the form of an eslint.config.js file which ESLint will look for and read automatically, or you can specify a configuration file on the command line.

Here are some of the options that you can configure in ESLint:

Globals - the additional global variables your script accesses during execution.
Rules - which rules are enabled and at what error level.
Plugins - which third-party plugins define additional rules, languages, configs, etc. for ESLint to use.

All of these options give you fine-grained control over how ESLint treats your code.
Table of Contents
Configuration Files

Configuration File Format
Configuration Objects
Configuring Shared Settings
Configuration File Resolution

Configure Language Options

Specifying JavaScript Options
Specifying Globals

Configure Rules

Configuring Rules
Disabling Rules

Configure Plugins

Configure Plugins
Specify a Processor

Configure a Parser

Configure a Custom Parser

Ignore Files

Ignoring Files
Ignoring Directories
Unignoring Files and Directories
Ignored File Warnings


            

            
                Edit this page\n\nConfigure ESLint
                

                Table of Contents
    
        
                
                    
                    Table of Contents
            		
                
            
    


                ESLint is designed to be flexible and configurable for your use case. You can turn off every rule and run only with basic syntax validation or mix and match the bundled rules and your custom rules to fit the needs of your project. There are two primary ways to configure ESLint:

Configuration Comments - use JavaScript comments to embed configuration information directly into a file.
Configuration Files - use a JavaScript file to specify configuration information for an entire directory and all of its subdirectories. This can be in the form of an eslint.config.js file which ESLint will look for and read automatically, or you can specify a configuration file on the command line.

Here are some of the options that you can configure in ESLint:

Globals - the additional global variables your script accesses during execution.
Rules - which rules are enabled and at what error level.
Plugins - which third-party plugins define additional rules, languages, configs, etc. for ESLint to use.

All of these options give you fine-grained control over how ESLint treats your code.
Table of Contents
Configuration Files

Configuration File Format
Configuration Objects
Configuring Shared Settings
Configuration File Resolution

Configure Language Options

Specifying JavaScript Options
Specifying Globals

Configure Rules

Configuring Rules
Disabling Rules

Configure Plugins

Configure Plugins
Specify a Processor

Configure a Parser

Configure a Custom Parser

Ignore Files

Ignoring Files
Ignoring Directories
Unignoring Files and Directories
Ignored File Warnings


            

            
                Edit this page\n\n\n\nConfiguration Files
                

                Table of Contents
    
        
                
                    
                    Configuration File
            		

                    Configuration Objects
            
                
                    
                    Specifying files and ignores
            
                
                    
                    Excluding files with ignores
            		

                    Specifying files with arbitrary extensions
            		

                    Specifying files without extension
            		

                    Globally ignoring files with ignores
            		

                    Cascading Configuration Objects
            		
                
            		

                    Configuring Linter Options
            
                
                    
                    Disabling Inline Configuration
            		

                    Reporting Unused Disable Directives
            		

                    Reporting Unused Inline Configs
            		
                
            		

                    Configuring Rules
            		

                    Configuring Shared Settings
            		

                    Extending Configurations
            
                
                    
                    Using Configurations from Plugins
            		

                    Using Predefined Configurations
            		

                    Using a Shareable Configuration Package
            		
                
            		

                    Configuration Naming Conventions
            		
                
            		

                    Configuration File Resolution
            
                
                    
                    Experimental Configuration File Resolution
            		
                
            		

                    TypeScript Configuration Files
            
                
                    
                    Native TypeScript Support
            		

                    Configuration File Precedence
            		
                
            		
                
            
    


                
                    
                    
                        Tip
                        This page explains how to use flat config files. For the deprecated eslintrc format, see the deprecated documentation.

                    
                You can put your ESLint project configuration in a configuration file. You can include built-in rules, how you want them enforced, plugins with custom rules, shareable configurations, which files you want rules to apply to, and more.
Configuration File
The ESLint configuration file may be named any of the following:

eslint.config.js
eslint.config.mjs
eslint.config.cjs
eslint.config.ts (requires additional setup)
eslint.config.mts (requires additional setup)
eslint.config.cts (requires additional setup)

It should be placed in the root directory of your project and export an array of configuration objects. Here’s an example:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		rules: {
			semi: "error",
			"prefer-const": "error",
		},
	},
]);
1234567891011
    
        Copy code to clipboard
        
    

In this example, the defineConfig() helper is used to define a configuration array with just one configuration object. The configuration object enables two rules: semi and prefer-const. These rules are applied to all of the files ESLint processes using this config file.
If your project does not specify "type":"module" in its package.json file, then eslint.config.js must be in CommonJS format, such as:


    // eslint.config.js
const { defineConfig } = require("eslint/config");

module.exports = defineConfig([
	{
		rules: {
			semi: "error",
			"prefer-const": "error",
		},
	},
]);
1234567891011
    
        Copy code to clipboard
        
    

Configuration Objects
Each configuration object contains all of the information ESLint needs to execute on a set of files. Each configuration object is made up of these properties:

name - A name for the configuration object. This is used in error messages and config inspector to help identify which configuration object is being used. (Naming Convention)
files - An array of glob patterns indicating the files that the configuration object should apply to. If not specified, the configuration object applies to all files matched by any other configuration object.
ignores - An array of glob patterns indicating the files that the configuration object should not apply to. If not specified, the configuration object applies to all files matched by files. If ignores is used without any other keys in the configuration object, then the patterns act as global ignores and it gets applied to every configuration object.
extends - An array of strings, configuration objects, or configuration arrays that contain additional configuration to apply.
languageOptions - An object containing settings related to how JavaScript is configured for linting.

ecmaVersion - The version of ECMAScript to support. May be any year (i.e., 2022) or version (i.e., 5). Set to "latest" for the most recent supported version. (default: "latest")
sourceType - The type of JavaScript source code. Possible values are "script" for traditional script files, "module" for ECMAScript modules (ESM), and "commonjs" for CommonJS files. (default: "module" for .js and .mjs files; "commonjs" for .cjs files)
globals - An object specifying additional objects that should be added to the global scope during linting.
parser - An object containing a parse() method or a parseForESLint() method. (default: espree)
parserOptions - An object specifying additional options that are passed directly to the parse() or parseForESLint() method on the parser. The available options are parser-dependent.


linterOptions - An object containing settings related to the linting process.

noInlineConfig - A Boolean value indicating if inline configuration is allowed.
reportUnusedDisableDirectives - A severity string indicating if and how unused disable and enable directives should be tracked and reported. For legacy compatibility, true is equivalent to "warn" and false is equivalent to "off". (default: "warn").
reportUnusedInlineConfigs - A severity string indicating if and how unused inline configs should be tracked and reported. (default: "off")


processor - Either an object containing preprocess() and postprocess() methods or a string indicating the name of a processor inside of a plugin (i.e., "pluginName/processorName").
plugins - An object containing a name-value mapping of plugin names to plugin objects. When files is specified, these plugins are only available to the matching files.
rules - An object containing the configured rules. When files or ignores are specified, these rule configurations are only available to the matching files.
settings - An object containing name-value pairs of information that should be available to all rules.

Specifying files and ignores

                    
                    
                        Tip
                        Patterns specified in files and ignores use minimatch syntax and are evaluated relative to the location of the eslint.config.js file. If using an alternate config file via the --config command line option, then all patterns are evaluated relative to the current working directory.

                    
                You can use a combination of files and ignores to determine which files the configuration object should apply to and which not. By default, ESLint lints files that match the patterns **/*.js, **/*.cjs, and **/*.mjs. Those files are always matched unless you explicitly exclude them using global ignores.
Because config objects that don’t specify files or ignores apply to all files that have been matched by any other configuration object, they will apply to all JavaScript files. For example:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		rules: {
			semi: "error",
		},
	},
]);
12345678910
    
        Copy code to clipboard
        
    

With this configuration, the semi rule is enabled for all files that match the default files in ESLint. So if you pass example.js to ESLint, the semi rule is applied. If you pass a non-JavaScript file, like example.txt, the semi rule is not applied because there are no other configuration objects that match that filename. (ESLint outputs an error message letting you know that the file was ignored due to missing configuration.)
Excluding files with ignores
You can limit which files a configuration object applies to by specifying a combination of files and ignores patterns. For example, you may want certain rules to apply only to files in your src directory:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["src/**/*.js"],
		rules: {
			semi: "error",
		},
	},
]);
1234567891011
    
        Copy code to clipboard
        
    

Here, only the JavaScript files in the src directory have the semi rule applied. If you run ESLint on files in another directory, this configuration object is skipped. By adding ignores, you can also remove some of the files in src from this configuration object:


    import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["src/**/*.js"],
		ignores: ["**/*.config.js"],
		rules: {
			semi: "error",
		},
	},
]);
1234567891011
    
        Copy code to clipboard
        
    

This configuration object matches all JavaScript files in the src directory except those that end with .config.js. You can also use negation patterns in ignores to exclude files from the ignore patterns, such as:


    import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["src/**/*.js"],
		ignores: ["**/*.config.js", "!**/eslint.config.js"],
		rules: {
			semi: "error",
		},
	},
]);
1234567891011
    
        Copy code to clipboard
        
    

Here, the configuration object excludes files ending with .config.js except for eslint.config.js. That file still has semi applied.
Non-global ignores patterns can only match file names. A pattern like "dir-to-exclude/" will not ignore anything. To ignore everything in a particular directory, a pattern like "dir-to-exclude/**" should be used instead.
If ignores is used without files and there are other keys (such as rules), then the configuration object applies to all linted files except the ones excluded by ignores, for example:


    import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		ignores: ["**/*.config.js"],
		rules: {
			semi: "error",
		},
	},
]);
12345678910
    
        Copy code to clipboard
        
    

This configuration object applies to all JavaScript files except those ending with .config.js. Effectively, this is like having files set to **/*. In general, it’s a good idea to always include files if you are specifying ignores.
Note that when files is not specified, negated ignores patterns do not cause any matching files to be linted automatically.
ESLint only lints files that are matched either by default or by a files pattern that is not * and does not end with /* or /**.

                    
                    
                        Tip
                        Use the config inspector (--inspect-config in the CLI) to test which config objects apply to a specific file.

                    
                Specifying files with arbitrary extensions
To lint files with extensions other than the default .js, .cjs and .mjs, include them in files with a pattern in the format of "**/*.extension". Any pattern will work except if it is * or if it ends with /* or /**.
For example, to lint TypeScript files with .ts, .cts and .mts extensions, you would specify a configuration object like this:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/*.ts", "**/*.cts", "**.*.mts"],
	},
	// ...other config
]);
123456789
    
        Copy code to clipboard
        
    

Specifying files without extension
Files without an extension can be matched with the pattern !(*.*). For example:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/!(*.*)"],
	},
	// ...other config
]);
123456789
    
        Copy code to clipboard
        
    

The above config lints files without extension besides the default .js, .cjs and .mjs extensions in all directories.

                    
                    
                        Tip
                        Filenames starting with a dot, such as .gitignore, are considered to have only an extension without a base name. In the case of .gitignore, the extension is gitignore, so the file matches the pattern "**/.gitignore" but not "**/*.gitignore".

                    
                Globally ignoring files with ignores
Depending on how the ignores property is used, it can behave as non-global ignores or as global ignores.

When ignores is used without any other keys (besides name) in the configuration object, then the patterns act as global ignores. This means they apply to every configuration object (not only to the configuration object in which it is defined). Global ignores allows you not to have to copy and keep the ignores property synchronized in more than one configuration object.
If ignores is used with other properties in the same configuration object, then the patterns act as non-global ignores. This way ignores applies only to the configuration object in which it is defined.

Global and non-global ignores have some usage differences:

patterns in non-global ignores only match the files (dir/filename.js) or files within directories (dir/**)
patterns in global ignores can match directories (dir/) in addition to the patterns that non-global ignores supports.

For all uses of ignores:

The patterns you define are added after the default ESLint patterns, which are ["**/node_modules/", ".git/"].
The patterns always match files and directories that begin with a dot, such as .foo.js or .fixtures, unless those files are explicitly ignored. The only dot directory ignored by default is .git.



    // eslint.config.js
import { defineConfig } from "eslint/config";

// Example of global ignores
export default defineConfig([
    {
      ignores: [".config/", "dist/", "tsconfig.json"] // acts as global ignores, due to the absence of other properties
    },
    { ... }, // ... other configuration object, inherit global ignores
    { ... }, // ... other configuration object inherit global ignores
]);

// Example of non-global ignores
export default defineConfig([
    {
      ignores: [".config/**", "dir1/script1.js"],
      rules: { ... } // the presence of this property dictates non-global ignores
    },
    {
      ignores: ["other-dir/**", "dist/script2.js"],
      rules: { ... } // the presence of this property dictates non-global ignores
    },
]);
1234567891011121314151617181920212223
    
        Copy code to clipboard
        
    

To avoid confusion, use the globalIgnores() helper function to clearly indicate which ignores are meant to be global. Here’s the previous example rewritten to use globalIgnores():


    // eslint.config.js
import { defineConfig, globalIgnores } from "eslint/config";

// Example of global ignores
export default defineConfig([
    globalIgnores([".config/", "dist/", "tsconfig.json"]),
    { ... }, // ... other configuration object, inherit global ignores
    { ... }, // ... other configuration object inherit global ignores
]);

// Example of non-global ignores
export default defineConfig([
    {
      ignores: [".config/**", "dir1/script1.js"],
      rules: { ... } // the presence of this property dictates non-global ignores
    },
    {
      ignores: ["other-dir/**", "dist/script2.js"],
      rules: { ... } // the presence of this property dictates non-global ignores
    },
]);
123456789101112131415161718192021
    
        Copy code to clipboard
        
    

For more information and examples on configuring rules regarding ignores, see Ignore Files.
Cascading Configuration Objects
When more than one configuration object matches a given filename, the configuration objects are merged with later objects overriding previous objects when there is a conflict. For example:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/*.js"],
		languageOptions: {
			globals: {
				MY_CUSTOM_GLOBAL: "readonly",
			},
		},
	},
	{
		files: ["tests/**/*.js"],
		languageOptions: {
			globals: {
				it: "readonly",
				describe: "readonly",
			},
		},
	},
]);
12345678910111213141516171819202122
    
        Copy code to clipboard
        
    

Using this configuration, all JavaScript files define a custom global object defined called MY_CUSTOM_GLOBAL while those JavaScript files in the tests directory have it and describe defined as global objects in addition to MY_CUSTOM_GLOBAL. For any JavaScript file in the tests directory, both configuration objects are applied, so languageOptions.globals are merged to create a final result.
Configuring Linter Options
Options specific to the linting process can be configured using the linterOptions object. These effect how linting proceeds and does not affect how the source code of the file is interpreted.
Disabling Inline Configuration
Inline configuration is implemented using an /*eslint*/ comment, such as /*eslint semi: error*/. You can disallow inline configuration by setting noInlineConfig to true. When enabled, all inline configuration is ignored. Here’s an example:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/*.js"],
		linterOptions: {
			noInlineConfig: true,
		},
	},
]);
1234567891011
    
        Copy code to clipboard
        
    

Reporting Unused Disable Directives
Disable and enable directives such as /*eslint-disable*/, /*eslint-enable*/ and /*eslint-disable-next-line*/ are used to disable ESLint rules around certain portions of code. As code changes, it’s possible for these directives to no longer be needed because the code has changed in such a way that the rule is no longer triggered. You can enable reporting of these unused disable directives by setting the reportUnusedDisableDirectives option to a severity string, as in this example:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/*.js"],
		linterOptions: {
			reportUnusedDisableDirectives: "error",
		},
	},
]);
1234567891011
    
        Copy code to clipboard
        
    

This setting defaults to "warn".
You can override this setting using the --report-unused-disable-directives or the --report-unused-disable-directives-severity command line options.
For legacy compatibility, true is equivalent to "warn" and false is equivalent to "off".
Reporting Unused Inline Configs
Inline config comments such as /* eslint rule-name: "error" */ are used to change ESLint rule severity and/or options around certain portions of code.
As a project’s ESLint configuration file changes, it’s possible for these directives to no longer be different from what was already set.
You can enable reporting of these unused inline config comments by setting the reportUnusedInlineConfigs option to a severity string, as in this example:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/*.js"],
		linterOptions: {
			reportUnusedInlineConfigs: "error",
		},
	},
]);
1234567891011
    
        Copy code to clipboard
        
    

You can override this setting using the --report-unused-inline-configs command line option.
Configuring Rules
You can configure any number of rules in a configuration object by add a rules property containing an object with your rule configurations. The names in this object are the names of the rules and the values are the configurations for each of those rules. Here’s an example:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		rules: {
			semi: "error",
		},
	},
]);
12345678910
    
        Copy code to clipboard
        
    

This configuration object specifies that the semi rule should be enabled with a severity of "error". You can also provide options to a rule by specifying an array where the first item is the severity and each item after that is an option for the rule. For example, you can switch the semi rule to disallow semicolons by passing "never" as an option:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		rules: {
			semi: ["error", "never"],
		},
	},
]);
12345678910
    
        Copy code to clipboard
        
    

Each rule specifies its own options and can be any valid JSON data type. Please check the documentation for the rule you want to configure for more information about its available options.
For more information on configuring rules, see Configure Rules.
Configuring Shared Settings
ESLint supports adding shared settings into configuration files. When you add a settings object to a configuration object, it is supplied to every rule. By convention, plugins namespace the settings they are interested in to avoid collisions with others. Plugins can use settings to specify the information that should be shared across all of their rules. This may be useful if you are adding custom rules and want them to have access to the same information. Here’s an example:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		settings: {
			sharedData: "Hello",
		},
		plugins: {
			customPlugin: {
				rules: {
					"my-rule": {
						meta: {
							// custom rule's meta information
						},
						create(context) {
							const sharedData = context.settings.sharedData;
							return {
								// code
							};
						},
					},
				},
			},
		},
		rules: {
			"customPlugin/my-rule": "error",
		},
	},
]);
123456789101112131415161718192021222324252627282930
    
        Copy code to clipboard
        
    

Extending Configurations
A configuration object uses extends to inherit all the traits of another configuration object or array (including rules, plugins, and language options) and can then modify all the options. The extends key is an array of values indicating which configurations to extend from. The elements of the extends array can be one of three values:

a string that specifies the name of a configuration in a plugin
a configuration object
a configuration array

Using Configurations from Plugins
ESLint plugins can export predefined configurations. These configurations are referenced using a string and follow the pattern pluginName/configName. The plugin must be specified in the plugins key first. Here’s an example:


    // eslint.config.js
import examplePlugin from "eslint-plugin-example";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/*.js"],
		plugins: {
			example: examplePlugin,
		},
		extends: ["example/recommended"],
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    

In this example, the configuration named recommended from eslint-plugin-example is loaded. The plugin configurations can also be referenced by name inside of the configuration array.
You can also insert plugin configurations directly into the extends array. For example:


    // eslint.config.js
import pluginExample from "eslint-plugin-example";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/*.js"],
		plugins: {
			example: pluginExample,
		},
		extends: [pluginExample.configs.recommended],
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    

In this case, the configuration named recommended from eslint-plugin-example is accessed directly through the plugin object’s configs property.

                    
                    
                        Important
                        It’s recommended to always use a files key when you use the extends key to ensure that your configuration applies to the correct files. By omitting the files key, the extended configuration may end up applied to all files.

                    
                Using Predefined Configurations
ESLint has two predefined configurations for JavaScript:

js/recommended - enables the rules that ESLint recommends everyone use to avoid potential errors.
js/all - enables all of the rules shipped with ESLint. This configuration is not recommended for production use because it changes with every minor and major version of ESLint. Use at your own risk.

To include these predefined configurations, install the @eslint/js package and then make any modifications to other properties in subsequent configuration objects:


    // eslint.config.js
import js from "@eslint/js";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/*.js"],
		plugins: {
			js,
		},
		extends: ["js/recommended"],
		rules: {
			"no-unused-vars": "warn",
		},
	},
]);
12345678910111213141516
    
        Copy code to clipboard
        
    

Here, the js/recommended predefined configuration is applied first and then another configuration object adds the desired configuration for no-unused-vars.
For more information on how to combine predefined configs with your preferences, please see Combine Configs.
Using a Shareable Configuration Package
A sharable configuration is an npm package that exports a configuration object or array. This package should be installed as a dependency in your project and then referenced from inside of your eslint.config.js file. For example, to use a shareable configuration named eslint-config-example, your configuration file would look like this:


    // eslint.config.js
import exampleConfig from "eslint-config-example";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/*.js"],
		extends: [exampleConfig],
		rules: {
			"no-unused-vars": "warn",
		},
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    

In this example, exampleConfig can be either an object or an array, and either way it can be inserted directly into the extends array.
For more information on how to combine shareable configs with your preferences, please see Combine Configs.
Configuration Naming Conventions
The name property is optional, but it is recommended to provide a name for each configuration object, especially when you are creating shared configurations. The name is used in error messages and the config inspector to help identify which configuration object is being used.
The name should be descriptive of the configuration object’s purpose and scoped with the configuration name or plugin name using / as a separator. ESLint does not enforce the names to be unique at runtime, but it is recommended that unique names be set to avoid confusion.
For example, if you are creating a configuration object for a plugin named eslint-plugin-example, you might add name to the configuration objects with the example/ prefix:


    export default {
	configs: {
		recommended: {
			name: "example/recommended",
			rules: {
				"no-unused-vars": "warn",
			},
		},
		strict: {
			name: "example/strict",
			rules: {
				"no-unused-vars": "error",
			},
		},
	},
};
12345678910111213141516
    
        Copy code to clipboard
        
    

When exposing arrays of configuration objects, the name may have extra scoping levels to help identify the configuration object. For example:


    export default {
	configs: {
		strict: [
			{
				name: "example/strict/language-setup",
				languageOptions: {
					ecmaVersion: 2024,
				},
			},
			{
				name: "example/strict/sub-config",
				file: ["src/**/*.js"],
				rules: {
					"no-unused-vars": "error",
				},
			},
		],
	},
};
12345678910111213141516171819
    
        Copy code to clipboard
        
    

Configuration File Resolution
When ESLint is run on the command line, it first checks the current working directory for eslint.config.js. If that file is found, then the search stops, otherwise it checks for eslint.config.mjs. If that file is found, then the search stops, otherwise it checks for eslint.config.cjs. If none of the files are found, it checks the parent directory for each file. This search continues until either a config file is found or the root directory is reached.
You can prevent this search for eslint.config.js by using the -c or --config option on the command line to specify an alternate configuration file, such as:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --config some-other-file.js **/*.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --config some-other-file.js **/*.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --config some-other-file.js **/*.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --config some-other-file.js **/*.js 
1
    
        Copy code to clipboard
        
    

   

In this case, ESLint does not search for eslint.config.js and instead uses some-other-file.js.
Experimental Configuration File Resolution

                    
                    
                        Warning
                        This feature is experimental and its details may change before being finalized. This behavior will be the new lookup behavior starting in v10.0.0, but you can try it today using a feature flag.

                    
                You can use the unstable_config_lookup_from_file flag to change the way ESLint searches for configuration files. Instead of searching from the current working directory, ESLint will search for a configuration file by first starting in the directory of the file being linted and then searching up its ancestor directories until it finds a eslint.config.js file (or any other extension of configuration file). This behavior is better for monorepos, where each subdirectory may have its own configuration file.
To use this feature on the command line, use the --flag flag:


    npx eslint --flag unstable_config_lookup_from_file .
1
    
        Copy code to clipboard
        
    

For more information about using feature flags, see Feature Flags.
TypeScript Configuration Files
For Deno and Bun, TypeScript configuration files are natively supported; for Node.js, you must install the optional dev dependency jiti in version 2.0.0 or later in your project (this dependency is not automatically installed by ESLint):

   
      npm
      yarn
      pnpm
      bun
   
    
        npm


    npm install --save-dev jiti
1
    
        Copy code to clipboard
        
    


   
      yarn


    yarn add --dev jiti
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm add --save-dev jiti
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bun add --dev jiti
1
    
        Copy code to clipboard
        
    

   

You can then create a configuration file with a .ts, .mts, or .cts extension, and export an array of configuration objects.

                    
                    
                        Important
                        ESLint does not perform type checking on your configuration file and does not apply any settings from tsconfig.json.

                    
                Native TypeScript Support
If you’re using Node.js >= 22.10.0, you can load TypeScript configuration files natively without requiring jiti. This is possible thanks to the --experimental-strip-types flag.
Since this feature is still experimental, you must also enable the unstable_native_nodejs_ts_config flag.


    npx --node-options='--experimental-strip-types' eslint --flag unstable_native_nodejs_ts_config
1
    
        Copy code to clipboard
        
    

Configuration File Precedence
If you have multiple ESLint configuration files, ESLint prioritizes JavaScript files over TypeScript files. The order of precedence is as follows:

eslint.config.js
eslint.config.mjs
eslint.config.cjs
eslint.config.ts
eslint.config.mts
eslint.config.cts

To override this behavior, use the --config or -c command line option to specify a different configuration file:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --config eslint.config.ts 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --config eslint.config.ts 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --config eslint.config.ts 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --config eslint.config.ts 
1
    
        Copy code to clipboard
        
    

   


            

            
                Edit this page\n\nConfiguration Files
                

                Table of Contents
    
        
                
                    
                    Configuration File
            		

                    Configuration Objects
            
                
                    
                    Specifying files and ignores
            
                
                    
                    Excluding files with ignores
            		

                    Specifying files with arbitrary extensions
            		

                    Specifying files without extension
            		

                    Globally ignoring files with ignores
            		

                    Cascading Configuration Objects
            		
                
            		

                    Configuring Linter Options
            
                
                    
                    Disabling Inline Configuration
            		

                    Reporting Unused Disable Directives
            		

                    Reporting Unused Inline Configs
            		
                
            		

                    Configuring Rules
            		

                    Configuring Shared Settings
            		

                    Extending Configurations
            
                
                    
                    Using Configurations from Plugins
            		

                    Using Predefined Configurations
            		

                    Using a Shareable Configuration Package
            		
                
            		

                    Configuration Naming Conventions
            		
                
            		

                    Configuration File Resolution
            
                
                    
                    Experimental Configuration File Resolution
            		
                
            		

                    TypeScript Configuration Files
            
                
                    
                    Native TypeScript Support
            		

                    Configuration File Precedence
            		
                
            		
                
            
    


                
                    
                    
                        Tip
                        This page explains how to use flat config files. For the deprecated eslintrc format, see the deprecated documentation.

                    
                You can put your ESLint project configuration in a configuration file. You can include built-in rules, how you want them enforced, plugins with custom rules, shareable configurations, which files you want rules to apply to, and more.
Configuration File
The ESLint configuration file may be named any of the following:

eslint.config.js
eslint.config.mjs
eslint.config.cjs
eslint.config.ts (requires additional setup)
eslint.config.mts (requires additional setup)
eslint.config.cts (requires additional setup)

It should be placed in the root directory of your project and export an array of configuration objects. Here’s an example:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		rules: {
			semi: "error",
			"prefer-const": "error",
		},
	},
]);
1234567891011
    
        Copy code to clipboard
        
    

In this example, the defineConfig() helper is used to define a configuration array with just one configuration object. The configuration object enables two rules: semi and prefer-const. These rules are applied to all of the files ESLint processes using this config file.
If your project does not specify "type":"module" in its package.json file, then eslint.config.js must be in CommonJS format, such as:


    // eslint.config.js
const { defineConfig } = require("eslint/config");

module.exports = defineConfig([
	{
		rules: {
			semi: "error",
			"prefer-const": "error",
		},
	},
]);
1234567891011
    
        Copy code to clipboard
        
    

Configuration Objects
Each configuration object contains all of the information ESLint needs to execute on a set of files. Each configuration object is made up of these properties:

name - A name for the configuration object. This is used in error messages and config inspector to help identify which configuration object is being used. (Naming Convention)
files - An array of glob patterns indicating the files that the configuration object should apply to. If not specified, the configuration object applies to all files matched by any other configuration object.
ignores - An array of glob patterns indicating the files that the configuration object should not apply to. If not specified, the configuration object applies to all files matched by files. If ignores is used without any other keys in the configuration object, then the patterns act as global ignores and it gets applied to every configuration object.
extends - An array of strings, configuration objects, or configuration arrays that contain additional configuration to apply.
languageOptions - An object containing settings related to how JavaScript is configured for linting.

ecmaVersion - The version of ECMAScript to support. May be any year (i.e., 2022) or version (i.e., 5). Set to "latest" for the most recent supported version. (default: "latest")
sourceType - The type of JavaScript source code. Possible values are "script" for traditional script files, "module" for ECMAScript modules (ESM), and "commonjs" for CommonJS files. (default: "module" for .js and .mjs files; "commonjs" for .cjs files)
globals - An object specifying additional objects that should be added to the global scope during linting.
parser - An object containing a parse() method or a parseForESLint() method. (default: espree)
parserOptions - An object specifying additional options that are passed directly to the parse() or parseForESLint() method on the parser. The available options are parser-dependent.


linterOptions - An object containing settings related to the linting process.

noInlineConfig - A Boolean value indicating if inline configuration is allowed.
reportUnusedDisableDirectives - A severity string indicating if and how unused disable and enable directives should be tracked and reported. For legacy compatibility, true is equivalent to "warn" and false is equivalent to "off". (default: "warn").
reportUnusedInlineConfigs - A severity string indicating if and how unused inline configs should be tracked and reported. (default: "off")


processor - Either an object containing preprocess() and postprocess() methods or a string indicating the name of a processor inside of a plugin (i.e., "pluginName/processorName").
plugins - An object containing a name-value mapping of plugin names to plugin objects. When files is specified, these plugins are only available to the matching files.
rules - An object containing the configured rules. When files or ignores are specified, these rule configurations are only available to the matching files.
settings - An object containing name-value pairs of information that should be available to all rules.

Specifying files and ignores

                    
                    
                        Tip
                        Patterns specified in files and ignores use minimatch syntax and are evaluated relative to the location of the eslint.config.js file. If using an alternate config file via the --config command line option, then all patterns are evaluated relative to the current working directory.

                    
                You can use a combination of files and ignores to determine which files the configuration object should apply to and which not. By default, ESLint lints files that match the patterns **/*.js, **/*.cjs, and **/*.mjs. Those files are always matched unless you explicitly exclude them using global ignores.
Because config objects that don’t specify files or ignores apply to all files that have been matched by any other configuration object, they will apply to all JavaScript files. For example:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		rules: {
			semi: "error",
		},
	},
]);
12345678910
    
        Copy code to clipboard
        
    

With this configuration, the semi rule is enabled for all files that match the default files in ESLint. So if you pass example.js to ESLint, the semi rule is applied. If you pass a non-JavaScript file, like example.txt, the semi rule is not applied because there are no other configuration objects that match that filename. (ESLint outputs an error message letting you know that the file was ignored due to missing configuration.)
Excluding files with ignores
You can limit which files a configuration object applies to by specifying a combination of files and ignores patterns. For example, you may want certain rules to apply only to files in your src directory:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["src/**/*.js"],
		rules: {
			semi: "error",
		},
	},
]);
1234567891011
    
        Copy code to clipboard
        
    

Here, only the JavaScript files in the src directory have the semi rule applied. If you run ESLint on files in another directory, this configuration object is skipped. By adding ignores, you can also remove some of the files in src from this configuration object:


    import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["src/**/*.js"],
		ignores: ["**/*.config.js"],
		rules: {
			semi: "error",
		},
	},
]);
1234567891011
    
        Copy code to clipboard
        
    

This configuration object matches all JavaScript files in the src directory except those that end with .config.js. You can also use negation patterns in ignores to exclude files from the ignore patterns, such as:


    import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["src/**/*.js"],
		ignores: ["**/*.config.js", "!**/eslint.config.js"],
		rules: {
			semi: "error",
		},
	},
]);
1234567891011
    
        Copy code to clipboard
        
    

Here, the configuration object excludes files ending with .config.js except for eslint.config.js. That file still has semi applied.
Non-global ignores patterns can only match file names. A pattern like "dir-to-exclude/" will not ignore anything. To ignore everything in a particular directory, a pattern like "dir-to-exclude/**" should be used instead.
If ignores is used without files and there are other keys (such as rules), then the configuration object applies to all linted files except the ones excluded by ignores, for example:


    import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		ignores: ["**/*.config.js"],
		rules: {
			semi: "error",
		},
	},
]);
12345678910
    
        Copy code to clipboard
        
    

This configuration object applies to all JavaScript files except those ending with .config.js. Effectively, this is like having files set to **/*. In general, it’s a good idea to always include files if you are specifying ignores.
Note that when files is not specified, negated ignores patterns do not cause any matching files to be linted automatically.
ESLint only lints files that are matched either by default or by a files pattern that is not * and does not end with /* or /**.

                    
                    
                        Tip
                        Use the config inspector (--inspect-config in the CLI) to test which config objects apply to a specific file.

                    
                Specifying files with arbitrary extensions
To lint files with extensions other than the default .js, .cjs and .mjs, include them in files with a pattern in the format of "**/*.extension". Any pattern will work except if it is * or if it ends with /* or /**.
For example, to lint TypeScript files with .ts, .cts and .mts extensions, you would specify a configuration object like this:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/*.ts", "**/*.cts", "**.*.mts"],
	},
	// ...other config
]);
123456789
    
        Copy code to clipboard
        
    

Specifying files without extension
Files without an extension can be matched with the pattern !(*.*). For example:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/!(*.*)"],
	},
	// ...other config
]);
123456789
    
        Copy code to clipboard
        
    

The above config lints files without extension besides the default .js, .cjs and .mjs extensions in all directories.

                    
                    
                        Tip
                        Filenames starting with a dot, such as .gitignore, are considered to have only an extension without a base name. In the case of .gitignore, the extension is gitignore, so the file matches the pattern "**/.gitignore" but not "**/*.gitignore".

                    
                Globally ignoring files with ignores
Depending on how the ignores property is used, it can behave as non-global ignores or as global ignores.

When ignores is used without any other keys (besides name) in the configuration object, then the patterns act as global ignores. This means they apply to every configuration object (not only to the configuration object in which it is defined). Global ignores allows you not to have to copy and keep the ignores property synchronized in more than one configuration object.
If ignores is used with other properties in the same configuration object, then the patterns act as non-global ignores. This way ignores applies only to the configuration object in which it is defined.

Global and non-global ignores have some usage differences:

patterns in non-global ignores only match the files (dir/filename.js) or files within directories (dir/**)
patterns in global ignores can match directories (dir/) in addition to the patterns that non-global ignores supports.

For all uses of ignores:

The patterns you define are added after the default ESLint patterns, which are ["**/node_modules/", ".git/"].
The patterns always match files and directories that begin with a dot, such as .foo.js or .fixtures, unless those files are explicitly ignored. The only dot directory ignored by default is .git.



    // eslint.config.js
import { defineConfig } from "eslint/config";

// Example of global ignores
export default defineConfig([
    {
      ignores: [".config/", "dist/", "tsconfig.json"] // acts as global ignores, due to the absence of other properties
    },
    { ... }, // ... other configuration object, inherit global ignores
    { ... }, // ... other configuration object inherit global ignores
]);

// Example of non-global ignores
export default defineConfig([
    {
      ignores: [".config/**", "dir1/script1.js"],
      rules: { ... } // the presence of this property dictates non-global ignores
    },
    {
      ignores: ["other-dir/**", "dist/script2.js"],
      rules: { ... } // the presence of this property dictates non-global ignores
    },
]);
1234567891011121314151617181920212223
    
        Copy code to clipboard
        
    

To avoid confusion, use the globalIgnores() helper function to clearly indicate which ignores are meant to be global. Here’s the previous example rewritten to use globalIgnores():


    // eslint.config.js
import { defineConfig, globalIgnores } from "eslint/config";

// Example of global ignores
export default defineConfig([
    globalIgnores([".config/", "dist/", "tsconfig.json"]),
    { ... }, // ... other configuration object, inherit global ignores
    { ... }, // ... other configuration object inherit global ignores
]);

// Example of non-global ignores
export default defineConfig([
    {
      ignores: [".config/**", "dir1/script1.js"],
      rules: { ... } // the presence of this property dictates non-global ignores
    },
    {
      ignores: ["other-dir/**", "dist/script2.js"],
      rules: { ... } // the presence of this property dictates non-global ignores
    },
]);
123456789101112131415161718192021
    
        Copy code to clipboard
        
    

For more information and examples on configuring rules regarding ignores, see Ignore Files.
Cascading Configuration Objects
When more than one configuration object matches a given filename, the configuration objects are merged with later objects overriding previous objects when there is a conflict. For example:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/*.js"],
		languageOptions: {
			globals: {
				MY_CUSTOM_GLOBAL: "readonly",
			},
		},
	},
	{
		files: ["tests/**/*.js"],
		languageOptions: {
			globals: {
				it: "readonly",
				describe: "readonly",
			},
		},
	},
]);
12345678910111213141516171819202122
    
        Copy code to clipboard
        
    

Using this configuration, all JavaScript files define a custom global object defined called MY_CUSTOM_GLOBAL while those JavaScript files in the tests directory have it and describe defined as global objects in addition to MY_CUSTOM_GLOBAL. For any JavaScript file in the tests directory, both configuration objects are applied, so languageOptions.globals are merged to create a final result.
Configuring Linter Options
Options specific to the linting process can be configured using the linterOptions object. These effect how linting proceeds and does not affect how the source code of the file is interpreted.
Disabling Inline Configuration
Inline configuration is implemented using an /*eslint*/ comment, such as /*eslint semi: error*/. You can disallow inline configuration by setting noInlineConfig to true. When enabled, all inline configuration is ignored. Here’s an example:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/*.js"],
		linterOptions: {
			noInlineConfig: true,
		},
	},
]);
1234567891011
    
        Copy code to clipboard
        
    

Reporting Unused Disable Directives
Disable and enable directives such as /*eslint-disable*/, /*eslint-enable*/ and /*eslint-disable-next-line*/ are used to disable ESLint rules around certain portions of code. As code changes, it’s possible for these directives to no longer be needed because the code has changed in such a way that the rule is no longer triggered. You can enable reporting of these unused disable directives by setting the reportUnusedDisableDirectives option to a severity string, as in this example:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/*.js"],
		linterOptions: {
			reportUnusedDisableDirectives: "error",
		},
	},
]);
1234567891011
    
        Copy code to clipboard
        
    

This setting defaults to "warn".
You can override this setting using the --report-unused-disable-directives or the --report-unused-disable-directives-severity command line options.
For legacy compatibility, true is equivalent to "warn" and false is equivalent to "off".
Reporting Unused Inline Configs
Inline config comments such as /* eslint rule-name: "error" */ are used to change ESLint rule severity and/or options around certain portions of code.
As a project’s ESLint configuration file changes, it’s possible for these directives to no longer be different from what was already set.
You can enable reporting of these unused inline config comments by setting the reportUnusedInlineConfigs option to a severity string, as in this example:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/*.js"],
		linterOptions: {
			reportUnusedInlineConfigs: "error",
		},
	},
]);
1234567891011
    
        Copy code to clipboard
        
    

You can override this setting using the --report-unused-inline-configs command line option.
Configuring Rules
You can configure any number of rules in a configuration object by add a rules property containing an object with your rule configurations. The names in this object are the names of the rules and the values are the configurations for each of those rules. Here’s an example:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		rules: {
			semi: "error",
		},
	},
]);
12345678910
    
        Copy code to clipboard
        
    

This configuration object specifies that the semi rule should be enabled with a severity of "error". You can also provide options to a rule by specifying an array where the first item is the severity and each item after that is an option for the rule. For example, you can switch the semi rule to disallow semicolons by passing "never" as an option:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		rules: {
			semi: ["error", "never"],
		},
	},
]);
12345678910
    
        Copy code to clipboard
        
    

Each rule specifies its own options and can be any valid JSON data type. Please check the documentation for the rule you want to configure for more information about its available options.
For more information on configuring rules, see Configure Rules.
Configuring Shared Settings
ESLint supports adding shared settings into configuration files. When you add a settings object to a configuration object, it is supplied to every rule. By convention, plugins namespace the settings they are interested in to avoid collisions with others. Plugins can use settings to specify the information that should be shared across all of their rules. This may be useful if you are adding custom rules and want them to have access to the same information. Here’s an example:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		settings: {
			sharedData: "Hello",
		},
		plugins: {
			customPlugin: {
				rules: {
					"my-rule": {
						meta: {
							// custom rule's meta information
						},
						create(context) {
							const sharedData = context.settings.sharedData;
							return {
								// code
							};
						},
					},
				},
			},
		},
		rules: {
			"customPlugin/my-rule": "error",
		},
	},
]);
123456789101112131415161718192021222324252627282930
    
        Copy code to clipboard
        
    

Extending Configurations
A configuration object uses extends to inherit all the traits of another configuration object or array (including rules, plugins, and language options) and can then modify all the options. The extends key is an array of values indicating which configurations to extend from. The elements of the extends array can be one of three values:

a string that specifies the name of a configuration in a plugin
a configuration object
a configuration array

Using Configurations from Plugins
ESLint plugins can export predefined configurations. These configurations are referenced using a string and follow the pattern pluginName/configName. The plugin must be specified in the plugins key first. Here’s an example:


    // eslint.config.js
import examplePlugin from "eslint-plugin-example";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/*.js"],
		plugins: {
			example: examplePlugin,
		},
		extends: ["example/recommended"],
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    

In this example, the configuration named recommended from eslint-plugin-example is loaded. The plugin configurations can also be referenced by name inside of the configuration array.
You can also insert plugin configurations directly into the extends array. For example:


    // eslint.config.js
import pluginExample from "eslint-plugin-example";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/*.js"],
		plugins: {
			example: pluginExample,
		},
		extends: [pluginExample.configs.recommended],
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    

In this case, the configuration named recommended from eslint-plugin-example is accessed directly through the plugin object’s configs property.

                    
                    
                        Important
                        It’s recommended to always use a files key when you use the extends key to ensure that your configuration applies to the correct files. By omitting the files key, the extended configuration may end up applied to all files.

                    
                Using Predefined Configurations
ESLint has two predefined configurations for JavaScript:

js/recommended - enables the rules that ESLint recommends everyone use to avoid potential errors.
js/all - enables all of the rules shipped with ESLint. This configuration is not recommended for production use because it changes with every minor and major version of ESLint. Use at your own risk.

To include these predefined configurations, install the @eslint/js package and then make any modifications to other properties in subsequent configuration objects:


    // eslint.config.js
import js from "@eslint/js";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/*.js"],
		plugins: {
			js,
		},
		extends: ["js/recommended"],
		rules: {
			"no-unused-vars": "warn",
		},
	},
]);
12345678910111213141516
    
        Copy code to clipboard
        
    

Here, the js/recommended predefined configuration is applied first and then another configuration object adds the desired configuration for no-unused-vars.
For more information on how to combine predefined configs with your preferences, please see Combine Configs.
Using a Shareable Configuration Package
A sharable configuration is an npm package that exports a configuration object or array. This package should be installed as a dependency in your project and then referenced from inside of your eslint.config.js file. For example, to use a shareable configuration named eslint-config-example, your configuration file would look like this:


    // eslint.config.js
import exampleConfig from "eslint-config-example";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/*.js"],
		extends: [exampleConfig],
		rules: {
			"no-unused-vars": "warn",
		},
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    

In this example, exampleConfig can be either an object or an array, and either way it can be inserted directly into the extends array.
For more information on how to combine shareable configs with your preferences, please see Combine Configs.
Configuration Naming Conventions
The name property is optional, but it is recommended to provide a name for each configuration object, especially when you are creating shared configurations. The name is used in error messages and the config inspector to help identify which configuration object is being used.
The name should be descriptive of the configuration object’s purpose and scoped with the configuration name or plugin name using / as a separator. ESLint does not enforce the names to be unique at runtime, but it is recommended that unique names be set to avoid confusion.
For example, if you are creating a configuration object for a plugin named eslint-plugin-example, you might add name to the configuration objects with the example/ prefix:


    export default {
	configs: {
		recommended: {
			name: "example/recommended",
			rules: {
				"no-unused-vars": "warn",
			},
		},
		strict: {
			name: "example/strict",
			rules: {
				"no-unused-vars": "error",
			},
		},
	},
};
12345678910111213141516
    
        Copy code to clipboard
        
    

When exposing arrays of configuration objects, the name may have extra scoping levels to help identify the configuration object. For example:


    export default {
	configs: {
		strict: [
			{
				name: "example/strict/language-setup",
				languageOptions: {
					ecmaVersion: 2024,
				},
			},
			{
				name: "example/strict/sub-config",
				file: ["src/**/*.js"],
				rules: {
					"no-unused-vars": "error",
				},
			},
		],
	},
};
12345678910111213141516171819
    
        Copy code to clipboard
        
    

Configuration File Resolution
When ESLint is run on the command line, it first checks the current working directory for eslint.config.js. If that file is found, then the search stops, otherwise it checks for eslint.config.mjs. If that file is found, then the search stops, otherwise it checks for eslint.config.cjs. If none of the files are found, it checks the parent directory for each file. This search continues until either a config file is found or the root directory is reached.
You can prevent this search for eslint.config.js by using the -c or --config option on the command line to specify an alternate configuration file, such as:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --config some-other-file.js **/*.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --config some-other-file.js **/*.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --config some-other-file.js **/*.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --config some-other-file.js **/*.js 
1
    
        Copy code to clipboard
        
    

   

In this case, ESLint does not search for eslint.config.js and instead uses some-other-file.js.
Experimental Configuration File Resolution

                    
                    
                        Warning
                        This feature is experimental and its details may change before being finalized. This behavior will be the new lookup behavior starting in v10.0.0, but you can try it today using a feature flag.

                    
                You can use the unstable_config_lookup_from_file flag to change the way ESLint searches for configuration files. Instead of searching from the current working directory, ESLint will search for a configuration file by first starting in the directory of the file being linted and then searching up its ancestor directories until it finds a eslint.config.js file (or any other extension of configuration file). This behavior is better for monorepos, where each subdirectory may have its own configuration file.
To use this feature on the command line, use the --flag flag:


    npx eslint --flag unstable_config_lookup_from_file .
1
    
        Copy code to clipboard
        
    

For more information about using feature flags, see Feature Flags.
TypeScript Configuration Files
For Deno and Bun, TypeScript configuration files are natively supported; for Node.js, you must install the optional dev dependency jiti in version 2.0.0 or later in your project (this dependency is not automatically installed by ESLint):

   
      npm
      yarn
      pnpm
      bun
   
    
        npm


    npm install --save-dev jiti
1
    
        Copy code to clipboard
        
    


   
      yarn


    yarn add --dev jiti
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm add --save-dev jiti
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bun add --dev jiti
1
    
        Copy code to clipboard
        
    

   

You can then create a configuration file with a .ts, .mts, or .cts extension, and export an array of configuration objects.

                    
                    
                        Important
                        ESLint does not perform type checking on your configuration file and does not apply any settings from tsconfig.json.

                    
                Native TypeScript Support
If you’re using Node.js >= 22.10.0, you can load TypeScript configuration files natively without requiring jiti. This is possible thanks to the --experimental-strip-types flag.
Since this feature is still experimental, you must also enable the unstable_native_nodejs_ts_config flag.


    npx --node-options='--experimental-strip-types' eslint --flag unstable_native_nodejs_ts_config
1
    
        Copy code to clipboard
        
    

Configuration File Precedence
If you have multiple ESLint configuration files, ESLint prioritizes JavaScript files over TypeScript files. The order of precedence is as follows:

eslint.config.js
eslint.config.mjs
eslint.config.cjs
eslint.config.ts
eslint.config.mts
eslint.config.cts

To override this behavior, use the --config or -c command line option to specify a different configuration file:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --config eslint.config.ts 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --config eslint.config.ts 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --config eslint.config.ts 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --config eslint.config.ts 
1
    
        Copy code to clipboard
        
    

   


            

            
                Edit this page\n\n\n\nConfigure Language Options
                

                Table of Contents
    
        
                
                    
                    Specifying JavaScript Options
            		

                    Specifying Parser Options
            		

                    Specifying Globals
            
                
                    
                    Using configuration comments
            		

                    Using configuration files
            		

                    Predefined global variables
            		
                
            		
                
            
    


                
                    
                    
                        Tip
                        This page explains how to configure language options using the flat config format. For the deprecated eslintrc format, see the deprecated documentation.

                    
                The JavaScript ecosystem has a variety of runtimes, versions, extensions, and frameworks. Each of these can have different supported syntax and global variables. ESLint lets you configure language options specific to the JavaScript used in your project, like custom global variables. You can also use plugins to extend ESLint to support your project’s language options.
Specifying JavaScript Options
ESLint allows you to specify the JavaScript language options you want to support. By default, ESLint expects the most recent stage 4 ECMAScript syntax and ECMAScript modules (ESM) mode. You can override these settings by using the languageOptions key and specifying one or more of these properties:

ecmaVersion (default: "latest") - Indicates the ECMAScript version of the code being linted, determining both the syntax and the available global variables. Set to 3 or 5 for ECMAScript 3 and 5, respectively. Otherwise, you can use any year between 2015 to present. In most cases, we recommend using the default of "latest" to ensure you’re always using the most recent ECMAScript version.
sourceType (default: "module") - Indicates the mode of the JavaScript file being used. Possible values are:

module - ESM module (invalid when ecmaVersion is 3 or 5). Your code has a module scope and is run in strict mode.
commonjs - CommonJS module (useful if your code uses require()). Your code has a top-level function scope and runs in non-strict mode.
script - non-module. Your code has a shared global scope and runs in non-strict mode.



Here’s an example configuration file you might use when linting ECMAScript 5 code:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		languageOptions: {
			ecmaVersion: 5,
			sourceType: "script",
		},
	},
]);
1234567891011
    
        Copy code to clipboard
        
    

Specifying Parser Options
If you are using the built-in ESLint parser, you can additionally change how ESLint interprets your code by specifying the languageOptions.parserOptions key. All options are false by default:

allowReserved - allow the use of reserved words as identifiers (if ecmaVersion is 3).
ecmaFeatures - an object indicating which additional language features you’d like to use:

globalReturn - allow return statements in the global scope.
impliedStrict - enable global strict mode (if ecmaVersion is 5 or greater).
jsx - enable JSX.



Here’s an example configuration file that enables JSX parsing in the default parser:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		languageOptions: {
			parserOptions: {
				ecmaFeatures: {
					jsx: true,
				},
			},
		},
	},
]);
1234567891011121314
    
        Copy code to clipboard
        
    


                    
                    
                        Important
                        Please note that supporting JSX syntax is not the same as supporting React. React applies specific semantics to JSX syntax that ESLint doesn’t recognize. We recommend using eslint-plugin-react if you are using React.

                    
                Specifying Globals
Some of ESLint’s core rules rely on knowledge of the global variables available to your code at runtime. Since these can vary greatly between different environments as well as be modified at runtime, ESLint makes no assumptions about what global variables exist in your execution environment. If you would like to use rules that require knowledge of what global variables are available, you can define global variables in your configuration file or by using configuration comments in your source code.
Using configuration comments
To specify globals using a comment inside of your JavaScript file, use the following format:


    /* global var1, var2 */
1
    
        Copy code to clipboard
        
    

This defines two global variables, var1 and var2. If you want to optionally specify that these global variables can be written to (rather than only being read), then you can set each with a "writable" flag:


    /* global var1:writable, var2:writable */
1
    
        Copy code to clipboard
        
    

Using configuration files
To configure global variables inside of a configuration file, set the languageOptions.globals configuration property to an object containing keys named for each of the global variables you want to use. For each global variable key, set the corresponding value equal to "writable" to allow the variable to be overwritten or "readonly" to disallow overwriting. For example:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		languageOptions: {
			globals: {
				var1: "writable",
				var2: "readonly",
			},
		},
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    

This configuration allows var1 to be overwritten in your code, but disallow it for var2.
Globals can be disabled by setting their value to "off". For example, in an environment where most globals are available but Promise is unavailable, you might use this config:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		languageOptions: {
			globals: {
				Promise: "off",
			},
		},
	},
]);
123456789101112
    
        Copy code to clipboard
        
    


                    
                    
                        Tip
                        For historical reasons, the boolean value false and the string value "readable" are equivalent to "readonly". Similarly, the boolean value true and the string value "writeable" are equivalent to "writable". However, the use of these older values is deprecated.

                    
                Predefined global variables
Apart from the ECMAScript standard built-in globals, which are automatically enabled based on the configured languageOptions.ecmaVersion, ESLint doesn’t provide predefined sets of global variables. You can use the globals package to additionally enable all globals for a specific environment. For example, here is how you can add console, amongst other browser globals, into your configuration.


    // eslint.config.js
import globals from "globals";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		languageOptions: {
			globals: {
				...globals.browser,
			},
		},
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    

You can include multiple different collections of globals in the same way. The following example includes globals both for web browsers and for Jest:


    // eslint.config.js
import globals from "globals";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		languageOptions: {
			globals: {
				...globals.browser,
				...globals.jest,
			},
		},
	},
]);
1234567891011121314
    
        Copy code to clipboard
        
    


            

            
                Edit this page\n\nConfigure Language Options
                

                Table of Contents
    
        
                
                    
                    Specifying JavaScript Options
            		

                    Specifying Parser Options
            		

                    Specifying Globals
            
                
                    
                    Using configuration comments
            		

                    Using configuration files
            		

                    Predefined global variables
            		
                
            		
                
            
    


                
                    
                    
                        Tip
                        This page explains how to configure language options using the flat config format. For the deprecated eslintrc format, see the deprecated documentation.

                    
                The JavaScript ecosystem has a variety of runtimes, versions, extensions, and frameworks. Each of these can have different supported syntax and global variables. ESLint lets you configure language options specific to the JavaScript used in your project, like custom global variables. You can also use plugins to extend ESLint to support your project’s language options.
Specifying JavaScript Options
ESLint allows you to specify the JavaScript language options you want to support. By default, ESLint expects the most recent stage 4 ECMAScript syntax and ECMAScript modules (ESM) mode. You can override these settings by using the languageOptions key and specifying one or more of these properties:

ecmaVersion (default: "latest") - Indicates the ECMAScript version of the code being linted, determining both the syntax and the available global variables. Set to 3 or 5 for ECMAScript 3 and 5, respectively. Otherwise, you can use any year between 2015 to present. In most cases, we recommend using the default of "latest" to ensure you’re always using the most recent ECMAScript version.
sourceType (default: "module") - Indicates the mode of the JavaScript file being used. Possible values are:

module - ESM module (invalid when ecmaVersion is 3 or 5). Your code has a module scope and is run in strict mode.
commonjs - CommonJS module (useful if your code uses require()). Your code has a top-level function scope and runs in non-strict mode.
script - non-module. Your code has a shared global scope and runs in non-strict mode.



Here’s an example configuration file you might use when linting ECMAScript 5 code:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		languageOptions: {
			ecmaVersion: 5,
			sourceType: "script",
		},
	},
]);
1234567891011
    
        Copy code to clipboard
        
    

Specifying Parser Options
If you are using the built-in ESLint parser, you can additionally change how ESLint interprets your code by specifying the languageOptions.parserOptions key. All options are false by default:

allowReserved - allow the use of reserved words as identifiers (if ecmaVersion is 3).
ecmaFeatures - an object indicating which additional language features you’d like to use:

globalReturn - allow return statements in the global scope.
impliedStrict - enable global strict mode (if ecmaVersion is 5 or greater).
jsx - enable JSX.



Here’s an example configuration file that enables JSX parsing in the default parser:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		languageOptions: {
			parserOptions: {
				ecmaFeatures: {
					jsx: true,
				},
			},
		},
	},
]);
1234567891011121314
    
        Copy code to clipboard
        
    


                    
                    
                        Important
                        Please note that supporting JSX syntax is not the same as supporting React. React applies specific semantics to JSX syntax that ESLint doesn’t recognize. We recommend using eslint-plugin-react if you are using React.

                    
                Specifying Globals
Some of ESLint’s core rules rely on knowledge of the global variables available to your code at runtime. Since these can vary greatly between different environments as well as be modified at runtime, ESLint makes no assumptions about what global variables exist in your execution environment. If you would like to use rules that require knowledge of what global variables are available, you can define global variables in your configuration file or by using configuration comments in your source code.
Using configuration comments
To specify globals using a comment inside of your JavaScript file, use the following format:


    /* global var1, var2 */
1
    
        Copy code to clipboard
        
    

This defines two global variables, var1 and var2. If you want to optionally specify that these global variables can be written to (rather than only being read), then you can set each with a "writable" flag:


    /* global var1:writable, var2:writable */
1
    
        Copy code to clipboard
        
    

Using configuration files
To configure global variables inside of a configuration file, set the languageOptions.globals configuration property to an object containing keys named for each of the global variables you want to use. For each global variable key, set the corresponding value equal to "writable" to allow the variable to be overwritten or "readonly" to disallow overwriting. For example:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		languageOptions: {
			globals: {
				var1: "writable",
				var2: "readonly",
			},
		},
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    

This configuration allows var1 to be overwritten in your code, but disallow it for var2.
Globals can be disabled by setting their value to "off". For example, in an environment where most globals are available but Promise is unavailable, you might use this config:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		languageOptions: {
			globals: {
				Promise: "off",
			},
		},
	},
]);
123456789101112
    
        Copy code to clipboard
        
    


                    
                    
                        Tip
                        For historical reasons, the boolean value false and the string value "readable" are equivalent to "readonly". Similarly, the boolean value true and the string value "writeable" are equivalent to "writable". However, the use of these older values is deprecated.

                    
                Predefined global variables
Apart from the ECMAScript standard built-in globals, which are automatically enabled based on the configured languageOptions.ecmaVersion, ESLint doesn’t provide predefined sets of global variables. You can use the globals package to additionally enable all globals for a specific environment. For example, here is how you can add console, amongst other browser globals, into your configuration.


    // eslint.config.js
import globals from "globals";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		languageOptions: {
			globals: {
				...globals.browser,
			},
		},
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    

You can include multiple different collections of globals in the same way. The following example includes globals both for web browsers and for Jest:


    // eslint.config.js
import globals from "globals";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		languageOptions: {
			globals: {
				...globals.browser,
				...globals.jest,
			},
		},
	},
]);
1234567891011121314
    
        Copy code to clipboard
        
    


            

            
                Edit this page\n\n\n\nConfigure Rules
                

                Table of Contents
    
        
                
                    
                    Rule Severities
            
                
                    
                    Using configuration comments
            
                
                    
                    Configuration Comment Descriptions
            		

                    Report unused eslint inline config comments
            		
                
            		

                    Using Configuration Files
            		
                
            		

                    Rules from Plugins
            		

                    Disabling Rules
            
                
                    
                    Using configuration comments
            
                
                    
                    Comment descriptions
            		
                
            		

                    Using configuration files
            		

                    Disabling Inline Comments
            
                
                    
                    Report unused eslint-disable comments
            		
                
            		
                
            		
                
            
    


                
                    
                    
                        Tip
                        This page explains how to configure rules using the flat config format. For the deprecated eslintrc format, see the deprecated documentation.

                    
                Rules are the core building block of ESLint. A rule validates if your code meets a certain expectation, and what to do if it does not meet that expectation. Rules can also contain additional configuration options specific to that rule.
ESLint comes with a large number of built-in rules and you can add more rules through plugins. You can modify which rules your project uses with either configuration comments or configuration files.
Rule Severities
To change a rule’s severity, set the rule ID equal to one of these values:

"off" or 0 - turn the rule off.
"warn" or 1 - turn the rule on as a warning (doesn’t affect exit code).
"error" or 2 - turn the rule on as an error (exit code is 1 when triggered).

Rules are typically set to "error" to enforce compliance with the rule during continuous integration testing, pre-commit checks, and pull request merging because doing so causes ESLint to exit with a non-zero exit code.
If you don’t want to enforce compliance with a rule but would still like ESLint to report the rule’s violations, set the severity to "warn". This is typically used when introducing a new rule that will eventually be set to "error", when a rule is flagging something other than a potential buildtime or runtime error (such as an unused variable), or when a rule cannot determine with certainty that a problem has been found (when a rule might have false positives and need manual review).
Using configuration comments
To configure rules inside of a file using configuration comments, use a comment in the following format:


    /* eslint eqeqeq: "off", curly: "error" */
1
    
        Copy code to clipboard
        
    

In this example, eqeqeq is turned off and curly is turned on as an error. You can also use the numeric equivalent for the rule severity:


    /* eslint eqeqeq: 0, curly: 2 */
1
    
        Copy code to clipboard
        
    

This example is the same as the last example, only it uses the numeric codes instead of the string values. The eqeqeq rule is off and the curly rule is set to be an error.
If a rule has additional options, you can specify them using array literal syntax, such as:


    /* eslint quotes: ["error", "double"], curly: 2 */
1
    
        Copy code to clipboard
        
    

This comment specifies the “double” option for the quotes rule. The first item in the array is always the rule severity (number or string).
Configuration Comment Descriptions
Configuration comments can include descriptions to explain why the comment is necessary. The description must occur after the configuration and is separated from the configuration by two or more consecutive - characters. For example:


    /* eslint eqeqeq: "off", curly: "error" -- Here's a description about why this configuration is necessary. */
1
    
        Copy code to clipboard
        
    



    /* eslint eqeqeq: "off", curly: "error"
    --------
    Here's a description about why this configuration is necessary. */
123
    
        Copy code to clipboard
        
    



    /* eslint eqeqeq: "off", curly: "error"
 * --------
 * This will not work due to the line above starting with a '*' character.
 */
1234
    
        Copy code to clipboard
        
    

Report unused eslint inline config comments
To report unused eslint inline config comments (those that don’t change anything from what was already configured), use the reportUnusedInlineConfigs setting. For example:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		linterOptions: {
			reportUnusedInlineConfigs: "error",
		},
	},
]);
12345678910
    
        Copy code to clipboard
        
    

This setting defaults to "off".
This setting is similar to the --report-unused-inline-configs CLI option.
Using Configuration Files
To configure rules inside of a configuration file, use the rules key along with an error level and any options you want to use. For example:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		rules: {
			eqeqeq: "off",
			"no-unused-vars": "error",
			"prefer-const": ["error", { ignoreReadBeforeAssign: true }],
		},
	},
]);
123456789101112
    
        Copy code to clipboard
        
    

When more than one configuration object specifies the same rule, the rule configuration is merged with the later object taking precedence over any previous objects. For example:


    import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		rules: {
			semi: ["error", "never"],
		},
	},
	{
		rules: {
			semi: ["warn", "always"],
		},
	},
]);
1234567891011121314
    
        Copy code to clipboard
        
    

Using this configuration, the final rule configuration for semi is ["warn", "always"] because it appears last in the array. The array indicates that the configuration is for the severity and any options. You can change just the severity by defining only a string or number, as in this example:


    import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		rules: {
			semi: ["error", "never"],
		},
	},
	{
		rules: {
			semi: "warn",
		},
	},
]);
1234567891011121314
    
        Copy code to clipboard
        
    

Here, the second configuration object only overrides the severity, so the final configuration for semi is ["warn", "never"].

                    
                    
                        Important
                        Rules configured via configuration comments have the highest priority and are applied after all configuration files settings.

                    
                Rules from Plugins
To configure a rule that is defined within a plugin, prefix the rule ID with the plugin namespace and /.
In a configuration file, for example:


    // eslint.config.js
import example from "eslint-plugin-example";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		plugins: {
			example,
		},
		rules: {
			"example/rule1": "warn",
		},
	},
]);
1234567891011121314
    
        Copy code to clipboard
        
    

In this configuration file, the rule example/rule1 comes from the plugin named eslint-plugin-example.
You can also use this format with configuration comments, such as:


    /* eslint "example/rule1": "error" */
1
    
        Copy code to clipboard
        
    


                    
                    
                        Important
                        In order to use plugin rules in configuration comments, your configuration file must load the plugin and specify it in the plugins object of your config. Configuration comments can not load plugins on their own.

                    
                Disabling Rules
Using configuration comments

Use with Caution. Disabling ESLint rules inline should be restricted and used only in situations with a clear and
valid reason for doing so. Disabling rules inline should not be the default solution to resolve linting errors.
Document the Reason. Provide a comment explaining the reason for disabling a particular rule after the -- section of the comment. This
documentation should clarify why the rule is being disabled and why it is necessary in that specific situation.
Temporary Solutions. If a disable comment is added as a temporary measure to address a pressing issue, create a follow-up task to address the underlying problem adequately. This ensures that the
disable comment is revisited and resolved at a later stage.
Code Reviews and Pair Programming. Encourage team members to review each other’s code regularly. Code reviews can help
identify the reasons behind disable comments and ensure that they are used appropriately.
Configurations. Whenever possible, prefer using ESLint configuration files over disable comments. Configuration
files allow for consistent and project-wide rule handling.

To disable rule warnings in a part of a file, use block comments in the following format:


    /* eslint-disable */

alert("foo");

/* eslint-enable */
12345
    
        Copy code to clipboard
        
    

You can also disable or enable warnings for specific rules:


    /* eslint-disable no-alert, no-console */

alert("foo");
console.log("bar");

/* eslint-enable no-alert, no-console */
123456
    
        Copy code to clipboard
        
    


                    
                    
                        Warning
                        /* eslint-enable */ without any specific rules listed causes all disabled rules to be re-enabled.

                    
                To disable rule warnings in an entire file, put a /* eslint-disable */ block comment at the top of the file:


    /* eslint-disable */

alert("foo");
123
    
        Copy code to clipboard
        
    

You can also disable or enable specific rules for an entire file:


    /* eslint-disable no-alert */

alert("foo");
123
    
        Copy code to clipboard
        
    

To ensure that a rule is never applied (regardless of any future enable/disable lines):


    /* eslint no-alert: "off" */

alert("foo");
123
    
        Copy code to clipboard
        
    

To disable all rules on a specific line, use a line or block comment in one of the following formats:


    alert("foo"); // eslint-disable-line

// eslint-disable-next-line
alert("foo");

/* eslint-disable-next-line */
alert("foo");

alert("foo"); /* eslint-disable-line */
123456789
    
        Copy code to clipboard
        
    

To disable a specific rule on a specific line:


    alert("foo"); // eslint-disable-line no-alert

// eslint-disable-next-line no-alert
alert("foo");

alert("foo"); /* eslint-disable-line no-alert */

/* eslint-disable-next-line no-alert */
alert("foo");
123456789
    
        Copy code to clipboard
        
    

To disable multiple rules on a specific line:


    alert("foo"); // eslint-disable-line no-alert, quotes, semi

// eslint-disable-next-line no-alert, quotes, semi
alert("foo");

alert("foo"); /* eslint-disable-line no-alert, quotes, semi */

/* eslint-disable-next-line no-alert, quotes, semi */
alert("foo");

/* eslint-disable-next-line
  no-alert,
  quotes,
  semi
*/
alert("foo");
12345678910111213141516
    
        Copy code to clipboard
        
    

All of the above methods also work for plugin rules. For example, to disable eslint-plugin-example’s rule-name rule, combine the plugin’s name (example) and the rule’s name (rule-name) into example/rule-name:


    foo(); // eslint-disable-line example/rule-name
foo(); /* eslint-disable-line example/rule-name */
12
    
        Copy code to clipboard
        
    


                    
                    
                        Tip
                        Comments that disable warnings for a portion of a file tell ESLint not to report rule violations for the disabled code. ESLint still parses the entire file, however, so disabled code still needs to be syntactically valid JavaScript.

                    
                Comment descriptions
Configuration comments can include descriptions to explain why disabling or re-enabling the rule is necessary. The description must come after the configuration and needs to be separated from the configuration by two or more consecutive - characters. For example:


    // eslint-disable-next-line no-console -- Here's a description about why this configuration is necessary.
console.log("hello");

/* eslint-disable-next-line no-console --
 * Here's a very long description about why this configuration is necessary
 * along with some additional information
 **/
console.log("hello");
12345678
    
        Copy code to clipboard
        
    

Using configuration files
To disable rules inside of a configuration file for a group of files, use a subsequent config object with a files key. For example:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		rules: {
			"no-unused-expressions": "error",
		},
	},
	{
		files: ["*-test.js", "*.spec.js"],
		rules: {
			"no-unused-expressions": "off",
		},
	},
]);
12345678910111213141516
    
        Copy code to clipboard
        
    

Disabling Inline Comments
To disable all inline config comments, use the noInlineConfig setting in your configuration file. For example:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		linterOptions: {
			noInlineConfig: true,
		},
		rules: {
			"no-unused-expressions": "error",
		},
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    

You can also use the --no-inline-config CLI option to disable rule comments, in addition to other in-line configuration.
Report unused eslint-disable comments
To report unused eslint-disable comments (those that disable rules which would not report on the disabled line), use the reportUnusedDisableDirectives setting. For example:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		linterOptions: {
			reportUnusedDisableDirectives: "error",
		},
	},
]);
12345678910
    
        Copy code to clipboard
        
    

This setting defaults to "warn".
This setting is similar to --report-unused-disable-directives and --report-unused-disable-directives-severity CLI options.

            

            
                Edit this page\n\nConfigure Rules
                

                Table of Contents
    
        
                
                    
                    Rule Severities
            
                
                    
                    Using configuration comments
            
                
                    
                    Configuration Comment Descriptions
            		

                    Report unused eslint inline config comments
            		
                
            		

                    Using Configuration Files
            		
                
            		

                    Rules from Plugins
            		

                    Disabling Rules
            
                
                    
                    Using configuration comments
            
                
                    
                    Comment descriptions
            		
                
            		

                    Using configuration files
            		

                    Disabling Inline Comments
            
                
                    
                    Report unused eslint-disable comments
            		
                
            		
                
            		
                
            
    


                
                    
                    
                        Tip
                        This page explains how to configure rules using the flat config format. For the deprecated eslintrc format, see the deprecated documentation.

                    
                Rules are the core building block of ESLint. A rule validates if your code meets a certain expectation, and what to do if it does not meet that expectation. Rules can also contain additional configuration options specific to that rule.
ESLint comes with a large number of built-in rules and you can add more rules through plugins. You can modify which rules your project uses with either configuration comments or configuration files.
Rule Severities
To change a rule’s severity, set the rule ID equal to one of these values:

"off" or 0 - turn the rule off.
"warn" or 1 - turn the rule on as a warning (doesn’t affect exit code).
"error" or 2 - turn the rule on as an error (exit code is 1 when triggered).

Rules are typically set to "error" to enforce compliance with the rule during continuous integration testing, pre-commit checks, and pull request merging because doing so causes ESLint to exit with a non-zero exit code.
If you don’t want to enforce compliance with a rule but would still like ESLint to report the rule’s violations, set the severity to "warn". This is typically used when introducing a new rule that will eventually be set to "error", when a rule is flagging something other than a potential buildtime or runtime error (such as an unused variable), or when a rule cannot determine with certainty that a problem has been found (when a rule might have false positives and need manual review).
Using configuration comments
To configure rules inside of a file using configuration comments, use a comment in the following format:


    /* eslint eqeqeq: "off", curly: "error" */
1
    
        Copy code to clipboard
        
    

In this example, eqeqeq is turned off and curly is turned on as an error. You can also use the numeric equivalent for the rule severity:


    /* eslint eqeqeq: 0, curly: 2 */
1
    
        Copy code to clipboard
        
    

This example is the same as the last example, only it uses the numeric codes instead of the string values. The eqeqeq rule is off and the curly rule is set to be an error.
If a rule has additional options, you can specify them using array literal syntax, such as:


    /* eslint quotes: ["error", "double"], curly: 2 */
1
    
        Copy code to clipboard
        
    

This comment specifies the “double” option for the quotes rule. The first item in the array is always the rule severity (number or string).
Configuration Comment Descriptions
Configuration comments can include descriptions to explain why the comment is necessary. The description must occur after the configuration and is separated from the configuration by two or more consecutive - characters. For example:


    /* eslint eqeqeq: "off", curly: "error" -- Here's a description about why this configuration is necessary. */
1
    
        Copy code to clipboard
        
    



    /* eslint eqeqeq: "off", curly: "error"
    --------
    Here's a description about why this configuration is necessary. */
123
    
        Copy code to clipboard
        
    



    /* eslint eqeqeq: "off", curly: "error"
 * --------
 * This will not work due to the line above starting with a '*' character.
 */
1234
    
        Copy code to clipboard
        
    

Report unused eslint inline config comments
To report unused eslint inline config comments (those that don’t change anything from what was already configured), use the reportUnusedInlineConfigs setting. For example:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		linterOptions: {
			reportUnusedInlineConfigs: "error",
		},
	},
]);
12345678910
    
        Copy code to clipboard
        
    

This setting defaults to "off".
This setting is similar to the --report-unused-inline-configs CLI option.
Using Configuration Files
To configure rules inside of a configuration file, use the rules key along with an error level and any options you want to use. For example:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		rules: {
			eqeqeq: "off",
			"no-unused-vars": "error",
			"prefer-const": ["error", { ignoreReadBeforeAssign: true }],
		},
	},
]);
123456789101112
    
        Copy code to clipboard
        
    

When more than one configuration object specifies the same rule, the rule configuration is merged with the later object taking precedence over any previous objects. For example:


    import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		rules: {
			semi: ["error", "never"],
		},
	},
	{
		rules: {
			semi: ["warn", "always"],
		},
	},
]);
1234567891011121314
    
        Copy code to clipboard
        
    

Using this configuration, the final rule configuration for semi is ["warn", "always"] because it appears last in the array. The array indicates that the configuration is for the severity and any options. You can change just the severity by defining only a string or number, as in this example:


    import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		rules: {
			semi: ["error", "never"],
		},
	},
	{
		rules: {
			semi: "warn",
		},
	},
]);
1234567891011121314
    
        Copy code to clipboard
        
    

Here, the second configuration object only overrides the severity, so the final configuration for semi is ["warn", "never"].

                    
                    
                        Important
                        Rules configured via configuration comments have the highest priority and are applied after all configuration files settings.

                    
                Rules from Plugins
To configure a rule that is defined within a plugin, prefix the rule ID with the plugin namespace and /.
In a configuration file, for example:


    // eslint.config.js
import example from "eslint-plugin-example";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		plugins: {
			example,
		},
		rules: {
			"example/rule1": "warn",
		},
	},
]);
1234567891011121314
    
        Copy code to clipboard
        
    

In this configuration file, the rule example/rule1 comes from the plugin named eslint-plugin-example.
You can also use this format with configuration comments, such as:


    /* eslint "example/rule1": "error" */
1
    
        Copy code to clipboard
        
    


                    
                    
                        Important
                        In order to use plugin rules in configuration comments, your configuration file must load the plugin and specify it in the plugins object of your config. Configuration comments can not load plugins on their own.

                    
                Disabling Rules
Using configuration comments

Use with Caution. Disabling ESLint rules inline should be restricted and used only in situations with a clear and
valid reason for doing so. Disabling rules inline should not be the default solution to resolve linting errors.
Document the Reason. Provide a comment explaining the reason for disabling a particular rule after the -- section of the comment. This
documentation should clarify why the rule is being disabled and why it is necessary in that specific situation.
Temporary Solutions. If a disable comment is added as a temporary measure to address a pressing issue, create a follow-up task to address the underlying problem adequately. This ensures that the
disable comment is revisited and resolved at a later stage.
Code Reviews and Pair Programming. Encourage team members to review each other’s code regularly. Code reviews can help
identify the reasons behind disable comments and ensure that they are used appropriately.
Configurations. Whenever possible, prefer using ESLint configuration files over disable comments. Configuration
files allow for consistent and project-wide rule handling.

To disable rule warnings in a part of a file, use block comments in the following format:


    /* eslint-disable */

alert("foo");

/* eslint-enable */
12345
    
        Copy code to clipboard
        
    

You can also disable or enable warnings for specific rules:


    /* eslint-disable no-alert, no-console */

alert("foo");
console.log("bar");

/* eslint-enable no-alert, no-console */
123456
    
        Copy code to clipboard
        
    


                    
                    
                        Warning
                        /* eslint-enable */ without any specific rules listed causes all disabled rules to be re-enabled.

                    
                To disable rule warnings in an entire file, put a /* eslint-disable */ block comment at the top of the file:


    /* eslint-disable */

alert("foo");
123
    
        Copy code to clipboard
        
    

You can also disable or enable specific rules for an entire file:


    /* eslint-disable no-alert */

alert("foo");
123
    
        Copy code to clipboard
        
    

To ensure that a rule is never applied (regardless of any future enable/disable lines):


    /* eslint no-alert: "off" */

alert("foo");
123
    
        Copy code to clipboard
        
    

To disable all rules on a specific line, use a line or block comment in one of the following formats:


    alert("foo"); // eslint-disable-line

// eslint-disable-next-line
alert("foo");

/* eslint-disable-next-line */
alert("foo");

alert("foo"); /* eslint-disable-line */
123456789
    
        Copy code to clipboard
        
    

To disable a specific rule on a specific line:


    alert("foo"); // eslint-disable-line no-alert

// eslint-disable-next-line no-alert
alert("foo");

alert("foo"); /* eslint-disable-line no-alert */

/* eslint-disable-next-line no-alert */
alert("foo");
123456789
    
        Copy code to clipboard
        
    

To disable multiple rules on a specific line:


    alert("foo"); // eslint-disable-line no-alert, quotes, semi

// eslint-disable-next-line no-alert, quotes, semi
alert("foo");

alert("foo"); /* eslint-disable-line no-alert, quotes, semi */

/* eslint-disable-next-line no-alert, quotes, semi */
alert("foo");

/* eslint-disable-next-line
  no-alert,
  quotes,
  semi
*/
alert("foo");
12345678910111213141516
    
        Copy code to clipboard
        
    

All of the above methods also work for plugin rules. For example, to disable eslint-plugin-example’s rule-name rule, combine the plugin’s name (example) and the rule’s name (rule-name) into example/rule-name:


    foo(); // eslint-disable-line example/rule-name
foo(); /* eslint-disable-line example/rule-name */
12
    
        Copy code to clipboard
        
    


                    
                    
                        Tip
                        Comments that disable warnings for a portion of a file tell ESLint not to report rule violations for the disabled code. ESLint still parses the entire file, however, so disabled code still needs to be syntactically valid JavaScript.

                    
                Comment descriptions
Configuration comments can include descriptions to explain why disabling or re-enabling the rule is necessary. The description must come after the configuration and needs to be separated from the configuration by two or more consecutive - characters. For example:


    // eslint-disable-next-line no-console -- Here's a description about why this configuration is necessary.
console.log("hello");

/* eslint-disable-next-line no-console --
 * Here's a very long description about why this configuration is necessary
 * along with some additional information
 **/
console.log("hello");
12345678
    
        Copy code to clipboard
        
    

Using configuration files
To disable rules inside of a configuration file for a group of files, use a subsequent config object with a files key. For example:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		rules: {
			"no-unused-expressions": "error",
		},
	},
	{
		files: ["*-test.js", "*.spec.js"],
		rules: {
			"no-unused-expressions": "off",
		},
	},
]);
12345678910111213141516
    
        Copy code to clipboard
        
    

Disabling Inline Comments
To disable all inline config comments, use the noInlineConfig setting in your configuration file. For example:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		linterOptions: {
			noInlineConfig: true,
		},
		rules: {
			"no-unused-expressions": "error",
		},
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    

You can also use the --no-inline-config CLI option to disable rule comments, in addition to other in-line configuration.
Report unused eslint-disable comments
To report unused eslint-disable comments (those that disable rules which would not report on the disabled line), use the reportUnusedDisableDirectives setting. For example:


    // eslint.config.js
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		linterOptions: {
			reportUnusedDisableDirectives: "error",
		},
	},
]);
12345678910
    
        Copy code to clipboard
        
    

This setting defaults to "warn".
This setting is similar to --report-unused-disable-directives and --report-unused-disable-directives-severity CLI options.

            

            
                Edit this page\n\n\n\nConfigure Plugins
                

                Table of Contents
    
        
                
                    
                    Configure Plugins
            
                
                    
                    Configure a Local Plugin
            		

                    Configure a Virtual Plugin
            		
                
            		

                    Use Plugin Rules
            		

                    Specify a Processor
            		

                    Specify a Language
            		

                    Common Problems
            		
                
            
    


                
                    
                    
                        Tip
                        This page explains how to configure plugins using the flat config format. For the deprecated eslintrc format, see the deprecated documentation.

                    
                You can extend ESLint with plugins in a variety of different ways. Plugins can include:

Custom rules to validate if your code meets a certain expectation, and what to do if it does not meet that expectation.
Custom configurations. Please refer to the plugin’s documentation for details on how to use these configurations.
Custom processors to extract JavaScript code from other kinds of files or preprocess code before linting.

Configure Plugins
ESLint supports the use of third-party plugins. Plugins are simply objects that conform to a specific interface that ESLint recognizes.
To configure plugins inside of a configuration file, use the plugins key, which contains an object with properties representing plugin namespaces and values equal to the plugin object.


    // eslint.config.js
import example from "eslint-plugin-example";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		plugins: {
			example,
		},
		rules: {
			"example/rule1": "warn",
		},
	},
]);
1234567891011121314
    
        Copy code to clipboard
        
    


                    
                    
                        Tip
                        When creating a namespace for a plugin, the convention is to use the npm package name without the eslint-plugin- prefix. In the preceding example, eslint-plugin-example is assigned a namespace of example.

                    
                Configure a Local Plugin
Plugins don’t need to be published to npm for use with ESLint. You can also load plugins directly from a file, as in this example:


    // eslint.config.js
import local from "./my-local-plugin.js";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		plugins: {
			local,
		},
		rules: {
			"local/rule1": "warn",
		},
	},
]);
1234567891011121314
    
        Copy code to clipboard
        
    

Here, the namespace local is used, but you can also use any name you’d like instead.
Configure a Virtual Plugin
Plugin definitions can be created virtually directly in your config. For example, suppose you have a rule contained in a file called my-rule.js that you’d like to enable in your config. You can define a virtual plugin to do so, as in this example:


    // eslint.config.js
import myRule from "./rules/my-rule.js";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		plugins: {
			local: {
				rules: {
					"my-rule": myRule,
				},
			},
		},
		rules: {
			"local/my-rule": "warn",
		},
	},
]);
123456789101112131415161718
    
        Copy code to clipboard
        
    

Here, the namespace local is used to define a virtual plugin. The rule myRule is then assigned a name of my-rule inside of the virtual plugin’s rules object. (See Create Plugins for the complete format of a plugin.) You can then reference the rule as local/my-rule to configure it.
Use Plugin Rules
You can use specific rules included in a plugin. To do this, specify the plugin
in a configuration object using the plugins key. The value for the plugin key
is an object where the name of the plugin is the property name and the value is the plugin object itself. Here’s an example:


    // eslint.config.js
import jsdoc from "eslint-plugin-jsdoc";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/*.js"],
		plugins: {
			jsdoc: jsdoc,
		},
		rules: {
			"jsdoc/require-description": "error",
			"jsdoc/check-values": "error",
		},
	},
]);
12345678910111213141516
    
        Copy code to clipboard
        
    

In this configuration, the JSDoc plugin is defined to have the name jsdoc. The prefix jsdoc/ in each rule name indicates that the rule is coming from the plugin with that name rather than from ESLint itself.
Because the name of the plugin and the plugin object are both jsdoc, you can also shorten the configuration to this:


    import jsdoc from "eslint-plugin-jsdoc";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/*.js"],
		plugins: {
			jsdoc,
		},
		rules: {
			"jsdoc/require-description": "error",
			"jsdoc/check-values": "error",
		},
	},
]);
123456789101112131415
    
        Copy code to clipboard
        
    

While this is the most common convention, you don’t need to use the same name that the plugin prescribes. You can specify any prefix that you’d like, such as:


    import jsdoc from "eslint-plugin-jsdoc";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/*.js"],
		plugins: {
			jsd: jsdoc,
		},
		rules: {
			"jsd/require-description": "error",
			"jsd/check-values": "error",
		},
	},
]);
123456789101112131415
    
        Copy code to clipboard
        
    

This configuration object uses jsd as the prefix plugin instead of jsdoc.
Specify a Processor
Plugins may provide processors. Processors can extract JavaScript code from other kinds of files, then let ESLint lint the JavaScript code. Alternatively, processors can convert JavaScript code during preprocessing.
To specify processors in a configuration file, use the processor key and assign the name of processor in the format namespace/processor-name. For example, the following uses the processor from @eslint/markdown for *.md files.


    // eslint.config.js
import markdown from "@eslint/markdown";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/*.md"],
		plugins: {
			markdown,
		},
		processor: "markdown/markdown",
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    

Processors may make named code blocks such as 0.js and 1.js. ESLint handles such a named code block as a child file of the original file. You can specify additional configurations for named code blocks with additional config objects. For example, the following disables the strict rule for the named code blocks which end with .js in markdown files.


    // eslint.config.js
import markdown from "@eslint/markdown";
import { defineConfig } from "eslint/config";

export default defineConfig([
	// applies to all JavaScript files
	{
		rules: {
			strict: "error",
		},
	},

	// applies to Markdown files
	{
		files: ["**/*.md"],
		plugins: {
			markdown,
		},
		processor: "markdown/markdown",
	},

	// applies only to JavaScript blocks inside of Markdown files
	{
		files: ["**/*.md/*.js"],
		rules: {
			strict: "off",
		},
	},
]);
1234567891011121314151617181920212223242526272829
    
        Copy code to clipboard
        
    

ESLint only lints named code blocks when they are JavaScript files or if they match a files entry in a config object. Be sure to add a config object with a matching files entry if you want to lint non-JavaScript named code blocks. Also note that global ignores apply to named code blocks as well.


    // eslint.config.js
import markdown from "@eslint/markdown";
import { defineConfig } from "eslint/config";

export default defineConfig([
	// applies to Markdown files
	{
		files: ["**/*.md"],
		plugins: {
			markdown,
		},
		processor: "markdown/markdown",
	},

	// applies to all .jsx files, including jsx blocks inside of Markdown files
	{
		files: ["**/*.jsx"],
		languageOptions: {
			parserOptions: {
				ecmaFeatures: {
					jsx: true,
				},
			},
		},
	},

	// ignore jsx blocks inside of test.md files
	{
		ignores: ["**/test.md/*.jsx"],
	},
]);
12345678910111213141516171819202122232425262728293031
    
        Copy code to clipboard
        
    

Specify a Language
Plugins may provide languages. Languages allow ESLint to lint programming languages besides JavaScript. To specify a language in a configuration file, use the language key and assign the name of language in the format namespace/language-name. For example, the following uses the json/jsonc language from @eslint/json for *.json files.


    // eslint.config.js
import json from "@eslint/json";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/*.json"],
		plugins: {
			json,
		},
		language: "json/jsonc",
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    


                    
                    
                        Tip
                        When you specify a language in a config object, languageOptions becomes specific to that language. Each language defines its own languageOptions, so check the documentation of the plugin to determine which options are available.

                    
                Common Problems

Plugin rules using the ESLint < v9.0.0 API
Plugin configurations have not been upgraded to flat config


            

            
                Edit this page\n\nConfigure Plugins
                

                Table of Contents
    
        
                
                    
                    Configure Plugins
            
                
                    
                    Configure a Local Plugin
            		

                    Configure a Virtual Plugin
            		
                
            		

                    Use Plugin Rules
            		

                    Specify a Processor
            		

                    Specify a Language
            		

                    Common Problems
            		
                
            
    


                
                    
                    
                        Tip
                        This page explains how to configure plugins using the flat config format. For the deprecated eslintrc format, see the deprecated documentation.

                    
                You can extend ESLint with plugins in a variety of different ways. Plugins can include:

Custom rules to validate if your code meets a certain expectation, and what to do if it does not meet that expectation.
Custom configurations. Please refer to the plugin’s documentation for details on how to use these configurations.
Custom processors to extract JavaScript code from other kinds of files or preprocess code before linting.

Configure Plugins
ESLint supports the use of third-party plugins. Plugins are simply objects that conform to a specific interface that ESLint recognizes.
To configure plugins inside of a configuration file, use the plugins key, which contains an object with properties representing plugin namespaces and values equal to the plugin object.


    // eslint.config.js
import example from "eslint-plugin-example";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		plugins: {
			example,
		},
		rules: {
			"example/rule1": "warn",
		},
	},
]);
1234567891011121314
    
        Copy code to clipboard
        
    


                    
                    
                        Tip
                        When creating a namespace for a plugin, the convention is to use the npm package name without the eslint-plugin- prefix. In the preceding example, eslint-plugin-example is assigned a namespace of example.

                    
                Configure a Local Plugin
Plugins don’t need to be published to npm for use with ESLint. You can also load plugins directly from a file, as in this example:


    // eslint.config.js
import local from "./my-local-plugin.js";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		plugins: {
			local,
		},
		rules: {
			"local/rule1": "warn",
		},
	},
]);
1234567891011121314
    
        Copy code to clipboard
        
    

Here, the namespace local is used, but you can also use any name you’d like instead.
Configure a Virtual Plugin
Plugin definitions can be created virtually directly in your config. For example, suppose you have a rule contained in a file called my-rule.js that you’d like to enable in your config. You can define a virtual plugin to do so, as in this example:


    // eslint.config.js
import myRule from "./rules/my-rule.js";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		plugins: {
			local: {
				rules: {
					"my-rule": myRule,
				},
			},
		},
		rules: {
			"local/my-rule": "warn",
		},
	},
]);
123456789101112131415161718
    
        Copy code to clipboard
        
    

Here, the namespace local is used to define a virtual plugin. The rule myRule is then assigned a name of my-rule inside of the virtual plugin’s rules object. (See Create Plugins for the complete format of a plugin.) You can then reference the rule as local/my-rule to configure it.
Use Plugin Rules
You can use specific rules included in a plugin. To do this, specify the plugin
in a configuration object using the plugins key. The value for the plugin key
is an object where the name of the plugin is the property name and the value is the plugin object itself. Here’s an example:


    // eslint.config.js
import jsdoc from "eslint-plugin-jsdoc";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/*.js"],
		plugins: {
			jsdoc: jsdoc,
		},
		rules: {
			"jsdoc/require-description": "error",
			"jsdoc/check-values": "error",
		},
	},
]);
12345678910111213141516
    
        Copy code to clipboard
        
    

In this configuration, the JSDoc plugin is defined to have the name jsdoc. The prefix jsdoc/ in each rule name indicates that the rule is coming from the plugin with that name rather than from ESLint itself.
Because the name of the plugin and the plugin object are both jsdoc, you can also shorten the configuration to this:


    import jsdoc from "eslint-plugin-jsdoc";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/*.js"],
		plugins: {
			jsdoc,
		},
		rules: {
			"jsdoc/require-description": "error",
			"jsdoc/check-values": "error",
		},
	},
]);
123456789101112131415
    
        Copy code to clipboard
        
    

While this is the most common convention, you don’t need to use the same name that the plugin prescribes. You can specify any prefix that you’d like, such as:


    import jsdoc from "eslint-plugin-jsdoc";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/*.js"],
		plugins: {
			jsd: jsdoc,
		},
		rules: {
			"jsd/require-description": "error",
			"jsd/check-values": "error",
		},
	},
]);
123456789101112131415
    
        Copy code to clipboard
        
    

This configuration object uses jsd as the prefix plugin instead of jsdoc.
Specify a Processor
Plugins may provide processors. Processors can extract JavaScript code from other kinds of files, then let ESLint lint the JavaScript code. Alternatively, processors can convert JavaScript code during preprocessing.
To specify processors in a configuration file, use the processor key and assign the name of processor in the format namespace/processor-name. For example, the following uses the processor from @eslint/markdown for *.md files.


    // eslint.config.js
import markdown from "@eslint/markdown";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/*.md"],
		plugins: {
			markdown,
		},
		processor: "markdown/markdown",
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    

Processors may make named code blocks such as 0.js and 1.js. ESLint handles such a named code block as a child file of the original file. You can specify additional configurations for named code blocks with additional config objects. For example, the following disables the strict rule for the named code blocks which end with .js in markdown files.


    // eslint.config.js
import markdown from "@eslint/markdown";
import { defineConfig } from "eslint/config";

export default defineConfig([
	// applies to all JavaScript files
	{
		rules: {
			strict: "error",
		},
	},

	// applies to Markdown files
	{
		files: ["**/*.md"],
		plugins: {
			markdown,
		},
		processor: "markdown/markdown",
	},

	// applies only to JavaScript blocks inside of Markdown files
	{
		files: ["**/*.md/*.js"],
		rules: {
			strict: "off",
		},
	},
]);
1234567891011121314151617181920212223242526272829
    
        Copy code to clipboard
        
    

ESLint only lints named code blocks when they are JavaScript files or if they match a files entry in a config object. Be sure to add a config object with a matching files entry if you want to lint non-JavaScript named code blocks. Also note that global ignores apply to named code blocks as well.


    // eslint.config.js
import markdown from "@eslint/markdown";
import { defineConfig } from "eslint/config";

export default defineConfig([
	// applies to Markdown files
	{
		files: ["**/*.md"],
		plugins: {
			markdown,
		},
		processor: "markdown/markdown",
	},

	// applies to all .jsx files, including jsx blocks inside of Markdown files
	{
		files: ["**/*.jsx"],
		languageOptions: {
			parserOptions: {
				ecmaFeatures: {
					jsx: true,
				},
			},
		},
	},

	// ignore jsx blocks inside of test.md files
	{
		ignores: ["**/test.md/*.jsx"],
	},
]);
12345678910111213141516171819202122232425262728293031
    
        Copy code to clipboard
        
    

Specify a Language
Plugins may provide languages. Languages allow ESLint to lint programming languages besides JavaScript. To specify a language in a configuration file, use the language key and assign the name of language in the format namespace/language-name. For example, the following uses the json/jsonc language from @eslint/json for *.json files.


    // eslint.config.js
import json from "@eslint/json";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/*.json"],
		plugins: {
			json,
		},
		language: "json/jsonc",
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    


                    
                    
                        Tip
                        When you specify a language in a config object, languageOptions becomes specific to that language. Each language defines its own languageOptions, so check the documentation of the plugin to determine which options are available.

                    
                Common Problems

Plugin rules using the ESLint < v9.0.0 API
Plugin configurations have not been upgraded to flat config


            

            
                Edit this page\n\n\n\nConfigure a Parser
                

                Table of Contents
    
        
                
                    
                    Configure a Custom Parser
            		

                    Configure Parser Options
            		
                
            
    


                
                    
                    
                        Tip
                        This page explains how to configure parsers using the flat config format. For the deprecated eslintrc format, see the deprecated documentation.

                    
                You can use custom parsers to convert JavaScript code into an abstract syntax tree for ESLint to evaluate. You might want to add a custom parser if your code isn’t compatible with ESLint’s default parser, Espree.
Configure a Custom Parser
In many cases, you can use the default parser that ESLint ships with for parsing your JavaScript code. You can optionally override the default parser by using the parser property. The parser property must be an object that conforms to the parser interface. For example, you can use the @babel/eslint-parser package to allow ESLint to parse experimental syntax:


    // eslint.config.js
import babelParser from "@babel/eslint-parser";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/*.js", "**/*.mjs"],
		languageOptions: {
			parser: babelParser,
		},
	},
]);
123456789101112
    
        Copy code to clipboard
        
    

This configuration ensures that the Babel parser, rather than the default Espree parser, is used to parse all files ending with .js and .mjs.
The following third-party parsers are known to be compatible with ESLint:

Esprima
@babel/eslint-parser - A wrapper around the Babel parser that makes it compatible with ESLint.
@typescript-eslint/parser - A parser that converts TypeScript into an ESTree-compatible form so it can be used in ESLint.


                    
                    
                        Warning
                        There are no guarantees that an external parser works correctly with ESLint. ESLint does not fix bugs related to incompatibilities that affect only third-party parsers.

                    
                Configure Parser Options
Parsers may accept options to alter the way they behave. The languageOptions.parserOptions is used to pass options directly to parsers. These options are always parser-specific, so you’ll need to check the documentation of the parser you’re using for available options. Here’s an example of setting parser options for the Babel ESLint parser:


    // eslint.config.js
import babelParser from "@babel/eslint-parser";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		languageOptions: {
			parser: babelParser,
			parserOptions: {
				requireConfigFile: false,
				babelOptions: {
					babelrc: false,
					configFile: false,
					presets: ["@babel/preset-env"],
				},
			},
		},
	},
]);
12345678910111213141516171819
    
        Copy code to clipboard
        
    


                    
                    
                        Tip
                        In addition to the options specified in languageOptions.parserOptions, ESLint also passes ecmaVersion and sourceType to all parsers. This allows custom parsers to understand the context in which ESLint is evaluating JavaScript code.

                    
                
            

            
                Edit this page\n\nConfigure a Parser
                

                Table of Contents
    
        
                
                    
                    Configure a Custom Parser
            		

                    Configure Parser Options
            		
                
            
    


                
                    
                    
                        Tip
                        This page explains how to configure parsers using the flat config format. For the deprecated eslintrc format, see the deprecated documentation.

                    
                You can use custom parsers to convert JavaScript code into an abstract syntax tree for ESLint to evaluate. You might want to add a custom parser if your code isn’t compatible with ESLint’s default parser, Espree.
Configure a Custom Parser
In many cases, you can use the default parser that ESLint ships with for parsing your JavaScript code. You can optionally override the default parser by using the parser property. The parser property must be an object that conforms to the parser interface. For example, you can use the @babel/eslint-parser package to allow ESLint to parse experimental syntax:


    // eslint.config.js
import babelParser from "@babel/eslint-parser";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/*.js", "**/*.mjs"],
		languageOptions: {
			parser: babelParser,
		},
	},
]);
123456789101112
    
        Copy code to clipboard
        
    

This configuration ensures that the Babel parser, rather than the default Espree parser, is used to parse all files ending with .js and .mjs.
The following third-party parsers are known to be compatible with ESLint:

Esprima
@babel/eslint-parser - A wrapper around the Babel parser that makes it compatible with ESLint.
@typescript-eslint/parser - A parser that converts TypeScript into an ESTree-compatible form so it can be used in ESLint.


                    
                    
                        Warning
                        There are no guarantees that an external parser works correctly with ESLint. ESLint does not fix bugs related to incompatibilities that affect only third-party parsers.

                    
                Configure Parser Options
Parsers may accept options to alter the way they behave. The languageOptions.parserOptions is used to pass options directly to parsers. These options are always parser-specific, so you’ll need to check the documentation of the parser you’re using for available options. Here’s an example of setting parser options for the Babel ESLint parser:


    // eslint.config.js
import babelParser from "@babel/eslint-parser";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		languageOptions: {
			parser: babelParser,
			parserOptions: {
				requireConfigFile: false,
				babelOptions: {
					babelrc: false,
					configFile: false,
					presets: ["@babel/preset-env"],
				},
			},
		},
	},
]);
12345678910111213141516171819
    
        Copy code to clipboard
        
    


                    
                    
                        Tip
                        In addition to the options specified in languageOptions.parserOptions, ESLint also passes ecmaVersion and sourceType to all parsers. This allows custom parsers to understand the context in which ESLint is evaluating JavaScript code.

                    
                
            

            
                Edit this page\n\n\n\nCombine Configs
                

                Table of Contents
    
        
                
                    
                    Apply a Config Object
            
                
                    
                    Apply a Configuration to a Subset of Files
            		
                
            		

                    Apply a Config Array
            
                
                    
                    Apply a Config Array to a Subset of Files
            		
                
            		
                
            
    


                In many cases, you won’t write an ESLint config file from scratch, but rather, you’ll use a combination of predefined and shareable configs along with your own overrides to create the config for your project. This page explains some of the patterns you can use to combine configs in your configuration file.
Apply a Config Object
If you are importing an object from another module, in most cases, you can just insert the object directly into your config file’s exported array. For example, you can use the recommended rule configurations for JavaScript by importing the recommended config and using it in your array:


    // eslint.config.js
import js from "@eslint/js";
import { defineConfig } from "eslint/config";

export default defineConfig([
	js.configs.recommended,
	{
		rules: {
			"no-unused-vars": "warn",
		},
	},
]);
123456789101112
    
        Copy code to clipboard
        
    

Here, the js.configs.recommended predefined configuration is applied first and then another configuration object adds the desired configuration for no-unused-vars.
Apply a Configuration to a Subset of Files
You can apply a config object to just a subset of files by creating a new object with a files key and using the extends key to merge in the rest of the properties from the config object. For example:


    // eslint.config.js
import js from "@eslint/js";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/src/safe/*.js"],
		plugins: {
			js,
		},
		extends: ["js/recommended"],
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    

Here, the js/recommended config object is applied only to files that match the pattern "**/src/safe/*.js".
Apply a Config Array
If you are importing an array from another module, insert the array directly into your exported array. Here’s an example:


    // eslint.config.js
import exampleConfigs from "eslint-config-example";
import { defineConfig } from "eslint/config";

export default defineConfig([
	// insert array directly
	exampleConfigs,

	// your modifications
	{
		rules: {
			"no-unused-vars": "warn",
		},
	},
]);
123456789101112131415
    
        Copy code to clipboard
        
    

Here, the exampleConfigs shareable configuration is applied first and then another configuration object adds the desired configuration for no-unused-vars. This is equivalent to inserting the individual elements of exampleConfigs in order, such as:


    // eslint.config.js
import exampleConfigs from "eslint-config-example";
import { defineConfig } from "eslint/config";

export default defineConfig([
	// insert individual elements instead of an array
	exampleConfigs[0],
	exampleConfigs[1],
	exampleConfigs[2],

	// your modifications
	{
		rules: {
			"no-unused-vars": "warn",
		},
	},
]);
1234567891011121314151617
    
        Copy code to clipboard
        
    

Apply a Config Array to a Subset of Files
You can apply a config array to just a subset of files by using the extends key. For example:


    // eslint.config.js
import exampleConfigs from "eslint-config-example";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/src/safe/*.js"],
		extends: [exampleConfigs],
		rules: {
			"no-unused-vars": "warn",
		},
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    

Here, each config object in exampleConfigs is applied only to files that match the pattern "**/src/safe/*.js".

            

            
                Edit this page\n\nCombine Configs
                

                Table of Contents
    
        
                
                    
                    Apply a Config Object
            
                
                    
                    Apply a Configuration to a Subset of Files
            		
                
            		

                    Apply a Config Array
            
                
                    
                    Apply a Config Array to a Subset of Files
            		
                
            		
                
            
    


                In many cases, you won’t write an ESLint config file from scratch, but rather, you’ll use a combination of predefined and shareable configs along with your own overrides to create the config for your project. This page explains some of the patterns you can use to combine configs in your configuration file.
Apply a Config Object
If you are importing an object from another module, in most cases, you can just insert the object directly into your config file’s exported array. For example, you can use the recommended rule configurations for JavaScript by importing the recommended config and using it in your array:


    // eslint.config.js
import js from "@eslint/js";
import { defineConfig } from "eslint/config";

export default defineConfig([
	js.configs.recommended,
	{
		rules: {
			"no-unused-vars": "warn",
		},
	},
]);
123456789101112
    
        Copy code to clipboard
        
    

Here, the js.configs.recommended predefined configuration is applied first and then another configuration object adds the desired configuration for no-unused-vars.
Apply a Configuration to a Subset of Files
You can apply a config object to just a subset of files by creating a new object with a files key and using the extends key to merge in the rest of the properties from the config object. For example:


    // eslint.config.js
import js from "@eslint/js";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/src/safe/*.js"],
		plugins: {
			js,
		},
		extends: ["js/recommended"],
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    

Here, the js/recommended config object is applied only to files that match the pattern "**/src/safe/*.js".
Apply a Config Array
If you are importing an array from another module, insert the array directly into your exported array. Here’s an example:


    // eslint.config.js
import exampleConfigs from "eslint-config-example";
import { defineConfig } from "eslint/config";

export default defineConfig([
	// insert array directly
	exampleConfigs,

	// your modifications
	{
		rules: {
			"no-unused-vars": "warn",
		},
	},
]);
123456789101112131415
    
        Copy code to clipboard
        
    

Here, the exampleConfigs shareable configuration is applied first and then another configuration object adds the desired configuration for no-unused-vars. This is equivalent to inserting the individual elements of exampleConfigs in order, such as:


    // eslint.config.js
import exampleConfigs from "eslint-config-example";
import { defineConfig } from "eslint/config";

export default defineConfig([
	// insert individual elements instead of an array
	exampleConfigs[0],
	exampleConfigs[1],
	exampleConfigs[2],

	// your modifications
	{
		rules: {
			"no-unused-vars": "warn",
		},
	},
]);
1234567891011121314151617
    
        Copy code to clipboard
        
    

Apply a Config Array to a Subset of Files
You can apply a config array to just a subset of files by using the extends key. For example:


    // eslint.config.js
import exampleConfigs from "eslint-config-example";
import { defineConfig } from "eslint/config";

export default defineConfig([
	{
		files: ["**/src/safe/*.js"],
		extends: [exampleConfigs],
		rules: {
			"no-unused-vars": "warn",
		},
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    

Here, each config object in exampleConfigs is applied only to files that match the pattern "**/src/safe/*.js".

            

            
                Edit this page\n\n\n\nIgnore Files
                

                Table of Contents
    
        
                
                    
                    Ignoring Files
            		

                    Ignoring Directories
            		

                    Unignoring Files and Directories
            		

                    Glob Pattern Resolution
            		

                    Name the Global Ignores Config
            		

                    Ignored File Warnings
            		

                    Including .gitignore Files
            		
                
            
    


                
                    
                    
                        Tip
                        This page explains how to ignore files using the flat config format. For the deprecated eslintrc format, see the deprecated documentation.

                    
                
                    
                    
                        Tip
                        This page explains how to use the globalIgnores() function to completely ignore files and directories. For more information on non-global ignores, see Specifying files and ignores. For more information on the differences between global and non-global ignores, see Globally ignoring files with ignores.

                    
                You can configure ESLint to ignore certain files and directories while linting by specifying one or more glob patterns in the following ways:

Inside of your eslint.config.js file.
On the command line using --ignore-pattern.

Ignoring Files
In your eslint.config.js file, if an ignores key is used without any other keys in the configuration object, then the patterns act as global ignores. Here’s an example:


    // eslint.config.js
import { defineConfig, globalIgnores } from "eslint/config";

export default defineConfig([globalIgnores([".config/*"])]);
1234
    
        Copy code to clipboard
        
    

This configuration specifies that all of the files in the .config directory should be ignored. This pattern is added after the default patterns, which are ["**/node_modules/", ".git/"].
You can also ignore files on the command line using --ignore-pattern, such as:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint . --ignore-pattern '.config/*' 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint . --ignore-pattern '.config/*' 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint . --ignore-pattern '.config/*' 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint . --ignore-pattern '.config/*' 
1
    
        Copy code to clipboard
        
    

   

Ignoring Directories
Ignoring directories works the same way as ignoring files, by placing a pattern in the ignores key of a configuration object with no other keys. For example, the following ignores the .config directory as a whole (meaning file search will not traverse into it at all):


    // eslint.config.js
import { defineConfig, globalIgnores } from "eslint/config";

export default defineConfig([globalIgnores([".config/"])]);
1234
    
        Copy code to clipboard
        
    

Unlike .gitignore, an ignore pattern like .config will only ignore the .config directory in the same directory as the configuration file. If you want to recursively ignore all directories named .config, you need to use **/.config/, as in this example:


    // eslint.config.js
import { defineConfig, globalIgnores } from "eslint/config";

export default defineConfig([globalIgnores(["**/.config/"])]);
1234
    
        Copy code to clipboard
        
    

Unignoring Files and Directories
You can also unignore files and directories that are ignored by previous patterns, including the default patterns. For example, this config unignores node_modules/mylibrary:


    // eslint.config.js
import { defineConfig, globalIgnores } from "eslint/config";

export default defineConfig([
	globalIgnores([
		"!node_modules/", // unignore `node_modules/` directory
		"node_modules/*", // ignore its content
		"!node_modules/mylibrary/", // unignore `node_modules/mylibrary` directory
	]),
]);
12345678910
    
        Copy code to clipboard
        
    

If you’d like to ignore a directory except for specific files or subdirectories, then the ignore pattern directory/**/* must be used instead of directory/**. The pattern directory/** ignores the entire directory and its contents, so traversal will skip over the directory completely and you cannot unignore anything inside.
For example, build/** ignores directory build and its contents, whereas build/**/* ignores only its contents. If you’d like to ignore everything in the build directory except for build/test.js, you’d need to create a config like this:


    // eslint.config.js
import { defineConfig, globalIgnores } from "eslint/config";

export default defineConfig([
	globalIgnores([
		"build/**/*", // ignore all contents in and under `build/` directory but not the `build/` directory itself
		"!build/test.js", // unignore `!build/test.js`
	]),
]);
123456789
    
        Copy code to clipboard
        
    

If you’d like to ignore a directory except for specific files at any level under the directory, you should also ensure that subdirectories are not ignored. Note that while patterns that end with / only match directories, patterns that don’t end with / match both files and directories so it isn’t possible to write a single pattern that only ignores files, but you can achieve this with two patterns: one to ignore all contents and another to unignore subdirectories.
For example, this config ignores all files in and under build directory except for files named test.js at any level:


    // eslint.config.js
import { defineConfig, globalIgnores } from "eslint/config";

export default defineConfig([
	globalIgnores([
		"build/**/*", // ignore all contents in and under `build/` directory but not the `build/` directory itself
		"!build/**/*/", // unignore all subdirectories
		"!build/**/test.js", // unignore `test.js` files
	]),
]);
12345678910
    
        Copy code to clipboard
        
    


                    
                    
                        Important
                        Note that only global ignores patterns can match directories.
ignores patterns that are specific to a configuration will only match file names.

                    
                You can also unignore files on the command line using --ignore-pattern, such as:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint . --ignore-pattern '!node_modules/' 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint . --ignore-pattern '!node_modules/' 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint . --ignore-pattern '!node_modules/' 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint . --ignore-pattern '!node_modules/' 
1
    
        Copy code to clipboard
        
    

   

Glob Pattern Resolution
How glob patterns are evaluated depends on where they are located and how they are used:

When using ignores in an eslint.config.js file, glob patterns are evaluated relative to the eslint.config.js file.
When using ignores in an alternate configuration file specified using the --config command line option, glob patterns are evaluated relative to the current working directory.
When using --ignore-pattern, glob patterns are evaluated relative to the current working directory.

Name the Global Ignores Config
By default, globalIgnores() will assign a name to the config that represents your ignores. You can override this name by providing a second argument to globalIgnores(), which is the name you’d like to use instead of the default:


    // eslint.config.js
import { defineConfig, globalIgnores } from "eslint/config";

export default defineConfig([
	globalIgnores(["build/**/*"], "Ignore build directory"),
]);
123456
    
        Copy code to clipboard
        
    

The "Ignore Build Directory" string in this example is the name of the config created for the global ignores. This is useful for debugging purposes.
Ignored File Warnings
When you pass directories to the ESLint CLI, files and directories are silently ignored. If you pass a specific file to ESLint, then ESLint creates a warning that the file was skipped. For example, suppose you have an eslint.config.js file that looks like this:


    // eslint.config.js
import { defineConfig, globalIgnores } from "eslint/config";

export default defineConfig([globalIgnores(["foo.js"])]);
1234
    
        Copy code to clipboard
        
    

And then you run:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint foo.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint foo.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint foo.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint foo.js 
1
    
        Copy code to clipboard
        
    

   

You’ll see this warning:


    foo.js
  0:0  warning  File ignored because of a matching ignore pattern. Use "--no-ignore" to disable file ignore settings or use "--no-warn-ignored" to suppress this warning.

✖ 1 problem (0 errors, 1 warning)
1234
    
        Copy code to clipboard
        
    

This message occurs because ESLint is unsure if you wanted to actually lint the file or not. As the message indicates, you can use --no-ignore to omit using the ignore rules.
Including .gitignore Files
If you want to include patterns from a .gitignore file or any other file with gitignore-style patterns, you can use includeIgnoreFile utility from the @eslint/compat package.


    // eslint.config.js
import { defineConfig } from "eslint/config";
import { includeIgnoreFile } from "@eslint/compat";
import { fileURLToPath } from "node:url";

const gitignorePath = fileURLToPath(new URL(".gitignore", import.meta.url));

export default defineConfig([
	includeIgnoreFile(gitignorePath),
	{
		// your overrides
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    

This automatically loads the specified file and translates gitignore-style patterns into ignores glob patterns.

            

            
                Edit this page\n\nIgnore Files
                

                Table of Contents
    
        
                
                    
                    Ignoring Files
            		

                    Ignoring Directories
            		

                    Unignoring Files and Directories
            		

                    Glob Pattern Resolution
            		

                    Name the Global Ignores Config
            		

                    Ignored File Warnings
            		

                    Including .gitignore Files
            		
                
            
    


                
                    
                    
                        Tip
                        This page explains how to ignore files using the flat config format. For the deprecated eslintrc format, see the deprecated documentation.

                    
                
                    
                    
                        Tip
                        This page explains how to use the globalIgnores() function to completely ignore files and directories. For more information on non-global ignores, see Specifying files and ignores. For more information on the differences between global and non-global ignores, see Globally ignoring files with ignores.

                    
                You can configure ESLint to ignore certain files and directories while linting by specifying one or more glob patterns in the following ways:

Inside of your eslint.config.js file.
On the command line using --ignore-pattern.

Ignoring Files
In your eslint.config.js file, if an ignores key is used without any other keys in the configuration object, then the patterns act as global ignores. Here’s an example:


    // eslint.config.js
import { defineConfig, globalIgnores } from "eslint/config";

export default defineConfig([globalIgnores([".config/*"])]);
1234
    
        Copy code to clipboard
        
    

This configuration specifies that all of the files in the .config directory should be ignored. This pattern is added after the default patterns, which are ["**/node_modules/", ".git/"].
You can also ignore files on the command line using --ignore-pattern, such as:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint . --ignore-pattern '.config/*' 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint . --ignore-pattern '.config/*' 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint . --ignore-pattern '.config/*' 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint . --ignore-pattern '.config/*' 
1
    
        Copy code to clipboard
        
    

   

Ignoring Directories
Ignoring directories works the same way as ignoring files, by placing a pattern in the ignores key of a configuration object with no other keys. For example, the following ignores the .config directory as a whole (meaning file search will not traverse into it at all):


    // eslint.config.js
import { defineConfig, globalIgnores } from "eslint/config";

export default defineConfig([globalIgnores([".config/"])]);
1234
    
        Copy code to clipboard
        
    

Unlike .gitignore, an ignore pattern like .config will only ignore the .config directory in the same directory as the configuration file. If you want to recursively ignore all directories named .config, you need to use **/.config/, as in this example:


    // eslint.config.js
import { defineConfig, globalIgnores } from "eslint/config";

export default defineConfig([globalIgnores(["**/.config/"])]);
1234
    
        Copy code to clipboard
        
    

Unignoring Files and Directories
You can also unignore files and directories that are ignored by previous patterns, including the default patterns. For example, this config unignores node_modules/mylibrary:


    // eslint.config.js
import { defineConfig, globalIgnores } from "eslint/config";

export default defineConfig([
	globalIgnores([
		"!node_modules/", // unignore `node_modules/` directory
		"node_modules/*", // ignore its content
		"!node_modules/mylibrary/", // unignore `node_modules/mylibrary` directory
	]),
]);
12345678910
    
        Copy code to clipboard
        
    

If you’d like to ignore a directory except for specific files or subdirectories, then the ignore pattern directory/**/* must be used instead of directory/**. The pattern directory/** ignores the entire directory and its contents, so traversal will skip over the directory completely and you cannot unignore anything inside.
For example, build/** ignores directory build and its contents, whereas build/**/* ignores only its contents. If you’d like to ignore everything in the build directory except for build/test.js, you’d need to create a config like this:


    // eslint.config.js
import { defineConfig, globalIgnores } from "eslint/config";

export default defineConfig([
	globalIgnores([
		"build/**/*", // ignore all contents in and under `build/` directory but not the `build/` directory itself
		"!build/test.js", // unignore `!build/test.js`
	]),
]);
123456789
    
        Copy code to clipboard
        
    

If you’d like to ignore a directory except for specific files at any level under the directory, you should also ensure that subdirectories are not ignored. Note that while patterns that end with / only match directories, patterns that don’t end with / match both files and directories so it isn’t possible to write a single pattern that only ignores files, but you can achieve this with two patterns: one to ignore all contents and another to unignore subdirectories.
For example, this config ignores all files in and under build directory except for files named test.js at any level:


    // eslint.config.js
import { defineConfig, globalIgnores } from "eslint/config";

export default defineConfig([
	globalIgnores([
		"build/**/*", // ignore all contents in and under `build/` directory but not the `build/` directory itself
		"!build/**/*/", // unignore all subdirectories
		"!build/**/test.js", // unignore `test.js` files
	]),
]);
12345678910
    
        Copy code to clipboard
        
    


                    
                    
                        Important
                        Note that only global ignores patterns can match directories.
ignores patterns that are specific to a configuration will only match file names.

                    
                You can also unignore files on the command line using --ignore-pattern, such as:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint . --ignore-pattern '!node_modules/' 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint . --ignore-pattern '!node_modules/' 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint . --ignore-pattern '!node_modules/' 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint . --ignore-pattern '!node_modules/' 
1
    
        Copy code to clipboard
        
    

   

Glob Pattern Resolution
How glob patterns are evaluated depends on where they are located and how they are used:

When using ignores in an eslint.config.js file, glob patterns are evaluated relative to the eslint.config.js file.
When using ignores in an alternate configuration file specified using the --config command line option, glob patterns are evaluated relative to the current working directory.
When using --ignore-pattern, glob patterns are evaluated relative to the current working directory.

Name the Global Ignores Config
By default, globalIgnores() will assign a name to the config that represents your ignores. You can override this name by providing a second argument to globalIgnores(), which is the name you’d like to use instead of the default:


    // eslint.config.js
import { defineConfig, globalIgnores } from "eslint/config";

export default defineConfig([
	globalIgnores(["build/**/*"], "Ignore build directory"),
]);
123456
    
        Copy code to clipboard
        
    

The "Ignore Build Directory" string in this example is the name of the config created for the global ignores. This is useful for debugging purposes.
Ignored File Warnings
When you pass directories to the ESLint CLI, files and directories are silently ignored. If you pass a specific file to ESLint, then ESLint creates a warning that the file was skipped. For example, suppose you have an eslint.config.js file that looks like this:


    // eslint.config.js
import { defineConfig, globalIgnores } from "eslint/config";

export default defineConfig([globalIgnores(["foo.js"])]);
1234
    
        Copy code to clipboard
        
    

And then you run:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint foo.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint foo.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint foo.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint foo.js 
1
    
        Copy code to clipboard
        
    

   

You’ll see this warning:


    foo.js
  0:0  warning  File ignored because of a matching ignore pattern. Use "--no-ignore" to disable file ignore settings or use "--no-warn-ignored" to suppress this warning.

✖ 1 problem (0 errors, 1 warning)
1234
    
        Copy code to clipboard
        
    

This message occurs because ESLint is unsure if you wanted to actually lint the file or not. As the message indicates, you can use --no-ignore to omit using the ignore rules.
Including .gitignore Files
If you want to include patterns from a .gitignore file or any other file with gitignore-style patterns, you can use includeIgnoreFile utility from the @eslint/compat package.


    // eslint.config.js
import { defineConfig } from "eslint/config";
import { includeIgnoreFile } from "@eslint/compat";
import { fileURLToPath } from "node:url";

const gitignorePath = fileURLToPath(new URL(".gitignore", import.meta.url));

export default defineConfig([
	includeIgnoreFile(gitignorePath),
	{
		// your overrides
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    

This automatically loads the specified file and translates gitignore-style patterns into ignores glob patterns.

            

            
                Edit this page\n\n\n\nDebug Your Configuration
                

                Table of Contents
    
        
                
                    
                    Run the CLI in Debug Mode
            		

                    Print a File’s Calculated Configuration
            		

                    Use the Config Inspector
            		
                
            
    


                ESLint creates a configuration for each file that is linted based on your configuration file and command line options. The larger the configuration file, the more difficult it can be to determine why a file isn’t linted as expected. To aid in debugging your configuration, ESLint provides several tools.
Run the CLI in Debug Mode
Use When: You aren’t sure if the correct configuration file is being read. This may happen if you have multiple configuration files in the same project.
What To Do: Run ESLint with the --debug command line flag and pass the file to check, like this:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --debug file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --debug file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --debug file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --debug file.js 
1
    
        Copy code to clipboard
        
    

   

This outputs all of ESLint’s debugging information onto the console. You should copy this output to a file and then search for eslint.config.js to see which file is loaded. Here’s some example output:


    eslint:eslint Using file patterns: bin/eslint.js +0ms
eslint:eslint Searching for eslint.config.js +0ms
eslint:eslint Loading config from C:\Users\nzakas\projects\eslint\eslint\eslint.config.js +5ms
eslint:eslint Config file URL is file:///C:/Users/nzakas/projects/eslint/eslint/eslint.config.js +0ms
1234
    
        Copy code to clipboard
        
    

Print a File’s Calculated Configuration
Use When: You aren’t sure why linting isn’t producing the expected results, either because it seems like your rule configuration isn’t being honored or the wrong language options are being used.
What To Do: Run ESLint with the --print-config command line flag and pass the file to check, like this:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --print-config file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --print-config file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --print-config file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --print-config file.js 
1
    
        Copy code to clipboard
        
    

   

This outputs a JSON representation of the file’s calculated config, such as:


    {
	"linterOptions": {
		"reportUnusedDisableDirectives": 1
	},
	"language": "@/js",
	"languageOptions": {
		"sourceType": "module",
		"ecmaVersion": "latest"
	},
	"plugins": ["@"],
	"rules": {
		"prefer-const": 2
	}
}
1234567891011121314
    
        Copy code to clipboard
        
    


                    
                    
                        Tip
                        You won’t see any entries for files, ignores, or name, because those are only used in calculating the final configuration and so do not appear in the result. You will see any default configuration applied by ESLint itself.

                    
                Use the Config Inspector
Use When: You aren’t sure if certain configuration objects in your configuration file match a given filename.
What To Do: Run ESLint with the --inspect-config command line flag and pass the file to check, like this:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --inspect-config 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --inspect-config 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --inspect-config 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --inspect-config 
1
    
        Copy code to clipboard
        
    

   

This initiates the config inspector by installing and starting @eslint/config-inspector. You can then type in the filename in question to see which configuration objects will apply.

The config inspector also shows you when rules are deprecated, how many available rules you’re using, and more.

            

            
                Edit this page\n\nDebug Your Configuration
                

                Table of Contents
    
        
                
                    
                    Run the CLI in Debug Mode
            		

                    Print a File’s Calculated Configuration
            		

                    Use the Config Inspector
            		
                
            
    


                ESLint creates a configuration for each file that is linted based on your configuration file and command line options. The larger the configuration file, the more difficult it can be to determine why a file isn’t linted as expected. To aid in debugging your configuration, ESLint provides several tools.
Run the CLI in Debug Mode
Use When: You aren’t sure if the correct configuration file is being read. This may happen if you have multiple configuration files in the same project.
What To Do: Run ESLint with the --debug command line flag and pass the file to check, like this:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --debug file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --debug file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --debug file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --debug file.js 
1
    
        Copy code to clipboard
        
    

   

This outputs all of ESLint’s debugging information onto the console. You should copy this output to a file and then search for eslint.config.js to see which file is loaded. Here’s some example output:


    eslint:eslint Using file patterns: bin/eslint.js +0ms
eslint:eslint Searching for eslint.config.js +0ms
eslint:eslint Loading config from C:\Users\nzakas\projects\eslint\eslint\eslint.config.js +5ms
eslint:eslint Config file URL is file:///C:/Users/nzakas/projects/eslint/eslint/eslint.config.js +0ms
1234
    
        Copy code to clipboard
        
    

Print a File’s Calculated Configuration
Use When: You aren’t sure why linting isn’t producing the expected results, either because it seems like your rule configuration isn’t being honored or the wrong language options are being used.
What To Do: Run ESLint with the --print-config command line flag and pass the file to check, like this:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --print-config file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --print-config file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --print-config file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --print-config file.js 
1
    
        Copy code to clipboard
        
    

   

This outputs a JSON representation of the file’s calculated config, such as:


    {
	"linterOptions": {
		"reportUnusedDisableDirectives": 1
	},
	"language": "@/js",
	"languageOptions": {
		"sourceType": "module",
		"ecmaVersion": "latest"
	},
	"plugins": ["@"],
	"rules": {
		"prefer-const": 2
	}
}
1234567891011121314
    
        Copy code to clipboard
        
    


                    
                    
                        Tip
                        You won’t see any entries for files, ignores, or name, because those are only used in calculating the final configuration and so do not appear in the result. You will see any default configuration applied by ESLint itself.

                    
                Use the Config Inspector
Use When: You aren’t sure if certain configuration objects in your configuration file match a given filename.
What To Do: Run ESLint with the --inspect-config command line flag and pass the file to check, like this:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --inspect-config 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --inspect-config 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --inspect-config 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --inspect-config 
1
    
        Copy code to clipboard
        
    

   

This initiates the config inspector by installing and starting @eslint/config-inspector. You can then type in the filename in question to see which configuration objects will apply.

The config inspector also shows you when rules are deprecated, how many available rules you’re using, and more.

            

            
                Edit this page\n\n\n\nConfiguration Migration Guide
                

                Table of Contents
    
        
                
                    
                    Migrate Your Config File
            		

                    Start Using Flat Config Files
            		

                    Things That Haven’t Changed between Configuration File Formats
            		

                    Key Differences between Configuration Formats
            
                
                    
                    Importing Plugins and Custom Parsers
            		

                    Custom Parsers
            		

                    Processors
            		

                    Glob-Based Configs
            
                
                    
                    eslintrc Examples
            		
                
            		

                    Configuring Language Options
            		

                    eslint-env Configuration Comments
            		

                    Predefined and Shareable Configs
            
                
                    
                    Using eslintrc Configs in Flat Config
            		
                
            		

                    Ignoring Files
            		

                    Linter Options
            		

                    CLI Flag Changes
            
                
                    
                    --rulesdir
            		

                    --ext
            		

                    --resolve-plugins-relative-to
            		
                
            		

                    package.json Configuration No Longer Supported
            		

                    Additional Changes
            		
                
            		

                    TypeScript Types for Flat Config Files
            		

                    Visual Studio Code Support
            		

                    Further Reading
            		
                
            
    


                This guide provides an overview of how you can migrate your ESLint configuration file from the eslintrc format (typically configured in .eslintrc.js or .eslintrc.json files) to the new flat config format (typically configured in an eslint.config.js file).
To learn more about the flat config format, refer to this blog post.
For reference information on these configuration formats, refer to the following documentation:

eslintrc configuration files
flat configuration files

Migrate Your Config File
To get started, use the configuration migrator on your existing configuration file (.eslintrc, .eslintrc.json, .eslintrc.yml), like this:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx  @eslint/migrate-config .eslintrc.json 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx  @eslint/migrate-config .eslintrc.json 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx  @eslint/migrate-config .eslintrc.json 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx  @eslint/migrate-config .eslintrc.json 
1
    
        Copy code to clipboard
        
    

   

This will create a starting point for your eslint.config.js file but is not guaranteed to work immediately without further modification. It will, however, do most of the conversion work mentioned in this guide automatically.

                    
                    
                        Important
                        The configuration migrator doesn’t yet work well for .eslintrc.js files. If you are using .eslintrc.js, the migration results in a config file that matches the evaluated output of your configuration and won’t include any functions, conditionals, or anything other than the raw data represented in your configuration.

                    
                Start Using Flat Config Files
The flat config file format has been the default configuration file format since ESLint v9.0.0. You can start using the flat config file format without any additional configuration.
To use flat config with ESLint v8, place a eslint.config.js file in the root of your project or set the ESLINT_USE_FLAT_CONFIG environment variable to true.
Things That Haven’t Changed between Configuration File Formats
While the configuration file format has changed from eslintrc to flat config, the following has stayed the same:

Syntax for configuring rules.
Syntax for configuring processors.
The CLI, except for the flag changes noted in CLI Flag Changes.
Global variables are configured the same way, but on a different property (see Configuring Language Options).

Key Differences between Configuration Formats
A few of the most notable differences between the eslintrc and flat config formats are the following:
Importing Plugins and Custom Parsers
Eslintrc files use string-based import system inside the plugins property to load plugins and inside the extends property to load external configurations.
Flat config files represent plugins and parsers as JavaScript objects. This means you can use CommonJS require() or ES module import statements to load plugins and custom parsers from external files.
For example, this eslintrc config file loads eslint-plugin-jsdoc and configures rules from that plugin:


    // .eslintrc.js

module.exports = {
	// ...other config
	plugins: ["jsdoc"],
	rules: {
		"jsdoc/require-description": "error",
		"jsdoc/check-values": "error",
	},
	// ...other config
};
1234567891011
    
        Copy code to clipboard
        
    

In flat config, you would do the same thing like this:


    // eslint.config.js

import jsdoc from "eslint-plugin-jsdoc";

export default [
	{
		files: ["**/*.js"],
		plugins: {
			jsdoc: jsdoc,
		},
		rules: {
			"jsdoc/require-description": "error",
			"jsdoc/check-values": "error",
		},
	},
];
12345678910111213141516
    
        Copy code to clipboard
        
    


                    
                    
                        Tip
                        If you import a plugin and get an error such as “TypeError: context.getScope is not a function”, then that means the plugin has not yet been updated to the ESLint v9.x rule API. While you should file an issue with the particular plugin, you can manually patch the plugin to work in ESLint v9.x using the compatibility utilities.

                    
                Custom Parsers
In eslintrc files, importing a custom parser is similar to importing a plugin: you use a string to specify the name of the parser.
In flat config files, import a custom parser as a module, then assign it to the languageOptions.parser property of a configuration object.
For example, this eslintrc config file uses the @babel/eslint-parser parser:


    // .eslintrc.js

module.exports = {
	// ...other config
	parser: "@babel/eslint-parser",
	// ...other config
};
1234567
    
        Copy code to clipboard
        
    

In flat config, you would do the same thing like this:


    // eslint.config.js

import babelParser from "@babel/eslint-parser";

export default [
	{
		// ...other config
		languageOptions: {
			parser: babelParser,
		},
		// ...other config
	},
];
12345678910111213
    
        Copy code to clipboard
        
    

Processors
In eslintrc files, processors had to be defined in a plugin, and then referenced by name in the configuration. Processors beginning with a dot indicated a file extension-named processor which ESLint would automatically configure for that file extension.
In flat config files, processors can still be referenced from plugins by their name, but they can now also be inserted directly into the configuration. Processors will never be automatically configured, and must be explicitly set in the configuration.
As an example with a custom plugin with processors:


    // node_modules/eslint-plugin-someplugin/index.js
module.exports = {
	processors: {
		".md": {
			preprocess() {},
			postprocess() {},
		},
		someProcessor: {
			preprocess() {},
			postprocess() {},
		},
	},
};
12345678910111213
    
        Copy code to clipboard
        
    

In eslintrc, you would configure as follows:


    // .eslintrc.js
module.exports = {
	plugins: ["someplugin"],
	processor: "someplugin/someProcessor",
};
12345
    
        Copy code to clipboard
        
    

ESLint would also automatically add the equivalent of the following:


    {
	overrides: [
		{
			files: ["**/*.md"],
			processor: "someplugin/.md",
		},
	];
}
12345678
    
        Copy code to clipboard
        
    

In flat config, the following are all valid ways to express the same:


    // eslint.config.js
import somePlugin from "eslint-plugin-someplugin";

export default [
	{
		plugins: { somePlugin },
		processor: "somePlugin/someProcessor",
	},
	{
		plugins: { somePlugin },
		// We can embed the processor object in the config directly
		processor: somePlugin.processors.someProcessor,
	},
	{
		// We don't need the plugin to be present in the config to use the processor directly
		processor: somePlugin.processors.someProcessor,
	},
];
123456789101112131415161718
    
        Copy code to clipboard
        
    

Note that because the .md processor is not automatically added by flat config, you also need to specify an extra configuration element:


    {
    files: ["**/*.md"],
    processor: somePlugin.processors[".md"]
}
1234
    
        Copy code to clipboard
        
    

Glob-Based Configs
By default, eslintrc files lint all files (except those covered by .eslintignore) in the directory in which they’re placed and its child directories. If you want to have different configurations for different file glob patterns, you can specify them in the overrides property.
By default, flat config files support different glob pattern-based configs in exported array. You can include the glob pattern in a config object’s files property. If you don’t specify a files property, the config defaults to the glob pattern "**/*.{js,mjs,cjs}". Basically, all configuration in the flat config file is like the eslintrc overrides property.
eslintrc Examples
For example, this eslintrc file applies to all files in the directory where it is placed and its child directories:


    // .eslintrc.js

module.exports = {
	// ...other config
	rules: {
		semi: ["warn", "always"],
	},
};
12345678
    
        Copy code to clipboard
        
    

This eslintrc file supports multiple configs with overrides:


    // .eslintrc.js

module.exports = {
	// ...other config
	overrides: [
		{
			files: ["src/**/*"],
			rules: {
				semi: ["warn", "always"],
			},
		},
		{
			files: ["test/**/*"],
			rules: {
				"no-console": "off",
			},
		},
	],
};
12345678910111213141516171819
    
        Copy code to clipboard
        
    

For flat config, here is a configuration with the default glob pattern:


    // eslint.config.js

import js from "@eslint/js";

export default [
	js.configs.recommended, // Recommended config applied to all files
	// Override the recommended config
	{
		rules: {
			indent: ["error", 2],
			"no-unused-vars": "warn",
		},
		// ...other configuration
	},
];
123456789101112131415
    
        Copy code to clipboard
        
    

A flat config example configuration supporting multiple configs for different glob patterns:


    // eslint.config.js

import js from "@eslint/js";

export default [
	js.configs.recommended, // Recommended config applied to all files
	// File-pattern specific overrides
	{
		files: ["src/**/*", "test/**/*"],
		rules: {
			semi: ["warn", "always"],
		},
	},
	{
		files: ["test/**/*"],
		rules: {
			"no-console": "off",
		},
	},
	// ...other configurations
];
123456789101112131415161718192021
    
        Copy code to clipboard
        
    

Configuring Language Options
In eslintrc files, you configure various language options across the env, globals and parserOptions properties. Groups of global variables for specific runtimes (e.g. document and window for browser JavaScript; process and require for Node.js) are configured with the env property.
In flat config files, the globals, and parserOptions are consolidated under the languageOptions key; the env property doesn’t exist. Groups of global variables for specific runtimes are imported from the globals npm package and included in the globals property. You can use the spread operator (...) to import multiple globals at once.
For example, here’s an eslintrc file with language options:


    // .eslintrc.js

module.exports = {
	env: {
		browser: true,
		node: true,
	},
	globals: {
		myCustomGlobal: "readonly",
	},
	parserOptions: {
		ecmaVersion: 2022,
		sourceType: "module",
	},
	// ...other config
};
12345678910111213141516
    
        Copy code to clipboard
        
    

Here’s the same configuration in flat config:


    // eslint.config.js

import globals from "globals";

export default [
	{
		languageOptions: {
			ecmaVersion: 2022,
			sourceType: "module",
			globals: {
				...globals.browser,
				...globals.node,
				myCustomGlobal: "readonly",
			},
		},
		// ...other config
	},
];
123456789101112131415161718
    
        Copy code to clipboard
        
    


                    
                    
                        Tip
                        You’ll need to install the globals package from npm for this example to work. It is not automatically installed by ESLint.

                    
                eslint-env Configuration Comments
In the eslintrc config system it was possible to use eslint-env configuration comments to define globals for a file.
These comments are no longer recognized when linting with flat config: in a future version of ESLint, eslint-env comments will be reported as errors.
For this reason, when migrating from eslintrc to flat config, eslint-env configuration comments should be removed from all files.
They can be either replaced with equivalent but more verbose global configuration comments, or dropped in favor of globals definitions in the config file.
For example, when using eslintrc, a file to be linted could look like this:


    // tests/my-file.js

/* eslint-env mocha */

describe("unit tests", () => {
	it("should pass", () => {
		// ...
	});
});
123456789
    
        Copy code to clipboard
        
    

In the above example, describe and it would be recognized as global identifiers because of the /* eslint-env mocha */ comment.
The same effect can be achieved with flat config with a global configuration comment, e.g.:


    // tests/my-file.js

/* global describe, it -- Globals defined by Mocha */

describe("unit tests", () => {
	it("should pass", () => {
		// ...
	});
});
123456789
    
        Copy code to clipboard
        
    

Another option is to remove the comment from the file being linted and define the globals in the configuration, for example:


    // eslint.config.js

import globals from "globals";

export default [
	// ...other config
	{
		files: ["tests/**"],
		languageOptions: {
			globals: {
				...globals.mocha,
			},
		},
	},
];
123456789101112131415
    
        Copy code to clipboard
        
    

Predefined and Shareable Configs
In eslintrc files, use the extends property to use predefined and shareable configs. ESLint comes with two predefined configs that you can access as strings:

"eslint:recommended": the rules recommended by ESLint.
"eslint:all": all rules shipped with ESLint.

You can also use the extends property to extend a shareable config. Shareable configs can either be paths to local config files or npm package names.
In flat config files, predefined configs are imported from separate modules into flat config files. The recommended and all rules configs are located in the @eslint/js package. You must import this package to use these configs:

   
      npm
      yarn
      pnpm
      bun
   
    
        npm


    npm install --save-dev @eslint/js
1
    
        Copy code to clipboard
        
    


   
      yarn


    yarn add --dev @eslint/js
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm add --save-dev @eslint/js
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bun add --dev @eslint/js
1
    
        Copy code to clipboard
        
    

   

You can add each of these configs to the exported array or expose specific rules from them. You must import the modules for local config files and npm package configs with flat config.
For example, here’s an eslintrc file using the built-in eslint:recommended config:


    // .eslintrc.js

module.exports = {
	// ...other config
	extends: "eslint:recommended",
	rules: {
		semi: ["warn", "always"],
	},
	// ...other config
};
12345678910
    
        Copy code to clipboard
        
    

This eslintrc file uses built-in config, local custom config, and shareable config from an npm package:


    // .eslintrc.js

module.exports = {
	// ...other config
	extends: [
		"eslint:recommended",
		"./custom-config.js",
		"eslint-config-my-config",
	],
	rules: {
		semi: ["warn", "always"],
	},
	// ...other config
};
1234567891011121314
    
        Copy code to clipboard
        
    

To use the same configs in flat config, you would do the following:


    // eslint.config.js

import js from "@eslint/js";
import customConfig from "./custom-config.js";
import myConfig from "eslint-config-my-config";

export default [
	js.configs.recommended,
	customConfig,
	myConfig,
	{
		rules: {
			semi: ["warn", "always"],
		},
		// ...other config
	},
];
1234567891011121314151617
    
        Copy code to clipboard
        
    

Note that because you are just importing JavaScript modules, you can mutate the config objects before ESLint uses them. For example, you might want to have a certain config object only apply to your test files:


    // eslint.config.js

import js from "@eslint/js";
import customTestConfig from "./custom-test-config.js";

export default [
	js.configs.recommended,
	{
		...customTestConfig,
		files: ["**/*.test.js"],
	},
];
123456789101112
    
        Copy code to clipboard
        
    

Using eslintrc Configs in Flat Config
You may find that there’s a shareable config you rely on that hasn’t yet been updated to flat config format. In that case, you can use the FlatCompat utility to translate the eslintrc format into flat config format. First, install the @eslint/eslintrc package:

   
      npm
      yarn
      pnpm
      bun
   
    
        npm


    npm install --save-dev @eslint/eslintrc
1
    
        Copy code to clipboard
        
    


   
      yarn


    yarn add --dev @eslint/eslintrc
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm add --save-dev @eslint/eslintrc
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bun add --dev @eslint/eslintrc
1
    
        Copy code to clipboard
        
    

   

Then, import FlatCompat and create a new instance to convert an existing eslintrc config. For example, if the npm package eslint-config-my-config is in eslintrc format, you can write this:


    import { FlatCompat } from "@eslint/eslintrc";
import path from "path";
import { fileURLToPath } from "url";

// mimic CommonJS variables -- not needed if using CommonJS
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const compat = new FlatCompat({
	baseDirectory: __dirname,
});

export default [
	// mimic ESLintRC-style extends
	...compat.extends("eslint-config-my-config"),
];
12345678910111213141516
    
        Copy code to clipboard
        
    

This example uses the FlatCompat#extends() method to insert the eslint-config-my-config into the flat config array.
For more information about the FlatCompat class, please see the package README.
Ignoring Files
With eslintrc, you can make ESLint ignore files by creating a separate .eslintignore file in the root of your project. The .eslintignore file uses the same glob pattern syntax as .gitignore files. Alternatively, you can use an ignorePatterns property in your eslintrc file.
To ignore files with flat config, you can use the ignores property in a config object with no other properties. The ignores property accepts an array of glob patterns. Flat config does not support loading ignore patterns from .eslintignore files, so you’ll need to migrate those patterns directly into flat config.
For example, here’s a .eslintignore example you can use with an eslintrc config:


    # .eslintignore
temp.js
config/*
# ...other ignored files
1234
    
        Copy code to clipboard
        
    

Here are the same patterns represented as ignorePatterns in a .eslintrc.js file:


    // .eslintrc.js
module.exports = {
	// ...other config
	ignorePatterns: ["temp.js", "config/*"],
};
12345
    
        Copy code to clipboard
        
    

The equivalent ignore patterns in flat config look like this:


    export default [
	// ...other config
	{
		// Note: there should be no other properties in this object
		ignores: ["**/temp.js", "config/*"],
	},
];
1234567
    
        Copy code to clipboard
        
    

In .eslintignore, temp.js ignores all files named temp.js, whereas in flat config, you need to specify this as **/temp.js. The pattern temp.js in flat config only ignores a file named temp.js in the same directory as the configuration file.

                    
                    
                        Important
                        In flat config, dotfiles (e.g. .dotfile.js) are no longer ignored by default. If you want to ignore dotfiles, add an ignore pattern of "**/.*".

                    
                Linter Options
Eslintrc files let you configure the linter itself with the noInlineConfig and reportUnusedDisableDirectives properties.
The flat config system introduces a new top-level property linterOptions that you can use to configure the linter. In the linterOptions object, you can include noInlineConfig and reportUnusedDisableDirectives.
For example, here’s an eslintrc file with linter options enabled:


    // .eslintrc.js

module.exports = {
	// ...other config
	noInlineConfig: true,
	reportUnusedDisableDirectives: true,
};
1234567
    
        Copy code to clipboard
        
    

Here’s the same options in flat config:


    // eslint.config.js

export default [
	{
		// ...other config
		linterOptions: {
			noInlineConfig: true,
			reportUnusedDisableDirectives: "warn",
		},
	},
];
1234567891011
    
        Copy code to clipboard
        
    

CLI Flag Changes
The following CLI flags are no longer supported with the flat config file format:

--rulesdir
--ext
--resolve-plugins-relative-to

The flag --no-eslintrc has been replaced with --no-config-lookup.
--rulesdir
The --rulesdir flag was used to load additional rules from a specified directory. This is no longer supported when using flat config. You can instead create a plugin containing the local rules you have directly in your config, like this:


    // eslint.config.js
import myRule from "./rules/my-rule.js";

export default [
	{
		// define the plugin
		plugins: {
			local: {
				rules: {
					"my-rule": myRule,
				},
			},
		},

		// configure the rule
		rules: {
			"local/my-rule": ["error"],
		},
	},
];
1234567891011121314151617181920
    
        Copy code to clipboard
        
    

--ext
The --ext flag was used to specify additional file extensions ESLint should search for when a directory was passed on the command line, such as npx eslint .. This is no longer supported when using flat config. Instead, specify the file patterns you’d like ESLint to search for directly in your config. For example, if you previously were using --ext .ts,.tsx, then you will need to update your config file like this:


    // eslint.config.js
export default [
	{
		files: ["**/*.ts", "**/*.tsx"],

		// any additional configuration for these file types here
	},
];
12345678
    
        Copy code to clipboard
        
    

ESLint uses the files keys from the config file to determine which files should be linted.
--resolve-plugins-relative-to
The --resolve-plugins-relative-to flag was used to indicate which directory plugin references in your configuration file should be resolved relative to. This was necessary because shareable configs could only resolve plugins that were peer dependencies or dependencies of parent packages.
With flat config, shareable configs can specify their dependencies directly, so this flag is no longer needed.
package.json Configuration No Longer Supported
With eslintrc, it was possible to use a package.json file to configure ESLint using the eslintConfig key.
With flat config, it’s no longer possible to use a package.json file to configure ESLint. You’ll need to move your configuration into a separate file.
Additional Changes
The following changes have been made from the eslintrc to the flat config file format:

The root option no longer exists. (Flat config files act as if root: true is set.)
The files option cannot be a single string anymore, it must be an array.
The sourceType option now supports the new value "commonjs" (.eslintrc supports it too, but it was never documented).

TypeScript Types for Flat Config Files
You can see the TypeScript types for the flat config file format in the lib/types source folder on GitHub. The interface for the objects in the config’s array is called Linter.Config.
You can view the type definitions in lib/types/index.d.ts.
Visual Studio Code Support
ESLint v9.x support was added in the vscode-eslint v3.0.10.
In versions of vscode-eslint prior to v3.0.10, the new configuration system is not enabled by default. To enable support for the new configuration files, edit your .vscode/settings.json file and add the following:


    {
	// required in vscode-eslint < v3.0.10 only
	"eslint.experimental.useFlatConfig": true
}
1234
    
        Copy code to clipboard
        
    

In a future version of the ESLint plugin, you will no longer need to enable this manually.
Further Reading

Overview of the flat config file format blog post
API usage of new configuration system blog post
Background to new configuration system blog post


            

            
                Edit this page\n\nConfiguration Migration Guide
                

                Table of Contents
    
        
                
                    
                    Migrate Your Config File
            		

                    Start Using Flat Config Files
            		

                    Things That Haven’t Changed between Configuration File Formats
            		

                    Key Differences between Configuration Formats
            
                
                    
                    Importing Plugins and Custom Parsers
            		

                    Custom Parsers
            		

                    Processors
            		

                    Glob-Based Configs
            
                
                    
                    eslintrc Examples
            		
                
            		

                    Configuring Language Options
            		

                    eslint-env Configuration Comments
            		

                    Predefined and Shareable Configs
            
                
                    
                    Using eslintrc Configs in Flat Config
            		
                
            		

                    Ignoring Files
            		

                    Linter Options
            		

                    CLI Flag Changes
            
                
                    
                    --rulesdir
            		

                    --ext
            		

                    --resolve-plugins-relative-to
            		
                
            		

                    package.json Configuration No Longer Supported
            		

                    Additional Changes
            		
                
            		

                    TypeScript Types for Flat Config Files
            		

                    Visual Studio Code Support
            		

                    Further Reading
            		
                
            
    


                This guide provides an overview of how you can migrate your ESLint configuration file from the eslintrc format (typically configured in .eslintrc.js or .eslintrc.json files) to the new flat config format (typically configured in an eslint.config.js file).
To learn more about the flat config format, refer to this blog post.
For reference information on these configuration formats, refer to the following documentation:

eslintrc configuration files
flat configuration files

Migrate Your Config File
To get started, use the configuration migrator on your existing configuration file (.eslintrc, .eslintrc.json, .eslintrc.yml), like this:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx  @eslint/migrate-config .eslintrc.json 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx  @eslint/migrate-config .eslintrc.json 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx  @eslint/migrate-config .eslintrc.json 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx  @eslint/migrate-config .eslintrc.json 
1
    
        Copy code to clipboard
        
    

   

This will create a starting point for your eslint.config.js file but is not guaranteed to work immediately without further modification. It will, however, do most of the conversion work mentioned in this guide automatically.

                    
                    
                        Important
                        The configuration migrator doesn’t yet work well for .eslintrc.js files. If you are using .eslintrc.js, the migration results in a config file that matches the evaluated output of your configuration and won’t include any functions, conditionals, or anything other than the raw data represented in your configuration.

                    
                Start Using Flat Config Files
The flat config file format has been the default configuration file format since ESLint v9.0.0. You can start using the flat config file format without any additional configuration.
To use flat config with ESLint v8, place a eslint.config.js file in the root of your project or set the ESLINT_USE_FLAT_CONFIG environment variable to true.
Things That Haven’t Changed between Configuration File Formats
While the configuration file format has changed from eslintrc to flat config, the following has stayed the same:

Syntax for configuring rules.
Syntax for configuring processors.
The CLI, except for the flag changes noted in CLI Flag Changes.
Global variables are configured the same way, but on a different property (see Configuring Language Options).

Key Differences between Configuration Formats
A few of the most notable differences between the eslintrc and flat config formats are the following:
Importing Plugins and Custom Parsers
Eslintrc files use string-based import system inside the plugins property to load plugins and inside the extends property to load external configurations.
Flat config files represent plugins and parsers as JavaScript objects. This means you can use CommonJS require() or ES module import statements to load plugins and custom parsers from external files.
For example, this eslintrc config file loads eslint-plugin-jsdoc and configures rules from that plugin:


    // .eslintrc.js

module.exports = {
	// ...other config
	plugins: ["jsdoc"],
	rules: {
		"jsdoc/require-description": "error",
		"jsdoc/check-values": "error",
	},
	// ...other config
};
1234567891011
    
        Copy code to clipboard
        
    

In flat config, you would do the same thing like this:


    // eslint.config.js

import jsdoc from "eslint-plugin-jsdoc";

export default [
	{
		files: ["**/*.js"],
		plugins: {
			jsdoc: jsdoc,
		},
		rules: {
			"jsdoc/require-description": "error",
			"jsdoc/check-values": "error",
		},
	},
];
12345678910111213141516
    
        Copy code to clipboard
        
    


                    
                    
                        Tip
                        If you import a plugin and get an error such as “TypeError: context.getScope is not a function”, then that means the plugin has not yet been updated to the ESLint v9.x rule API. While you should file an issue with the particular plugin, you can manually patch the plugin to work in ESLint v9.x using the compatibility utilities.

                    
                Custom Parsers
In eslintrc files, importing a custom parser is similar to importing a plugin: you use a string to specify the name of the parser.
In flat config files, import a custom parser as a module, then assign it to the languageOptions.parser property of a configuration object.
For example, this eslintrc config file uses the @babel/eslint-parser parser:


    // .eslintrc.js

module.exports = {
	// ...other config
	parser: "@babel/eslint-parser",
	// ...other config
};
1234567
    
        Copy code to clipboard
        
    

In flat config, you would do the same thing like this:


    // eslint.config.js

import babelParser from "@babel/eslint-parser";

export default [
	{
		// ...other config
		languageOptions: {
			parser: babelParser,
		},
		// ...other config
	},
];
12345678910111213
    
        Copy code to clipboard
        
    

Processors
In eslintrc files, processors had to be defined in a plugin, and then referenced by name in the configuration. Processors beginning with a dot indicated a file extension-named processor which ESLint would automatically configure for that file extension.
In flat config files, processors can still be referenced from plugins by their name, but they can now also be inserted directly into the configuration. Processors will never be automatically configured, and must be explicitly set in the configuration.
As an example with a custom plugin with processors:


    // node_modules/eslint-plugin-someplugin/index.js
module.exports = {
	processors: {
		".md": {
			preprocess() {},
			postprocess() {},
		},
		someProcessor: {
			preprocess() {},
			postprocess() {},
		},
	},
};
12345678910111213
    
        Copy code to clipboard
        
    

In eslintrc, you would configure as follows:


    // .eslintrc.js
module.exports = {
	plugins: ["someplugin"],
	processor: "someplugin/someProcessor",
};
12345
    
        Copy code to clipboard
        
    

ESLint would also automatically add the equivalent of the following:


    {
	overrides: [
		{
			files: ["**/*.md"],
			processor: "someplugin/.md",
		},
	];
}
12345678
    
        Copy code to clipboard
        
    

In flat config, the following are all valid ways to express the same:


    // eslint.config.js
import somePlugin from "eslint-plugin-someplugin";

export default [
	{
		plugins: { somePlugin },
		processor: "somePlugin/someProcessor",
	},
	{
		plugins: { somePlugin },
		// We can embed the processor object in the config directly
		processor: somePlugin.processors.someProcessor,
	},
	{
		// We don't need the plugin to be present in the config to use the processor directly
		processor: somePlugin.processors.someProcessor,
	},
];
123456789101112131415161718
    
        Copy code to clipboard
        
    

Note that because the .md processor is not automatically added by flat config, you also need to specify an extra configuration element:


    {
    files: ["**/*.md"],
    processor: somePlugin.processors[".md"]
}
1234
    
        Copy code to clipboard
        
    

Glob-Based Configs
By default, eslintrc files lint all files (except those covered by .eslintignore) in the directory in which they’re placed and its child directories. If you want to have different configurations for different file glob patterns, you can specify them in the overrides property.
By default, flat config files support different glob pattern-based configs in exported array. You can include the glob pattern in a config object’s files property. If you don’t specify a files property, the config defaults to the glob pattern "**/*.{js,mjs,cjs}". Basically, all configuration in the flat config file is like the eslintrc overrides property.
eslintrc Examples
For example, this eslintrc file applies to all files in the directory where it is placed and its child directories:


    // .eslintrc.js

module.exports = {
	// ...other config
	rules: {
		semi: ["warn", "always"],
	},
};
12345678
    
        Copy code to clipboard
        
    

This eslintrc file supports multiple configs with overrides:


    // .eslintrc.js

module.exports = {
	// ...other config
	overrides: [
		{
			files: ["src/**/*"],
			rules: {
				semi: ["warn", "always"],
			},
		},
		{
			files: ["test/**/*"],
			rules: {
				"no-console": "off",
			},
		},
	],
};
12345678910111213141516171819
    
        Copy code to clipboard
        
    

For flat config, here is a configuration with the default glob pattern:


    // eslint.config.js

import js from "@eslint/js";

export default [
	js.configs.recommended, // Recommended config applied to all files
	// Override the recommended config
	{
		rules: {
			indent: ["error", 2],
			"no-unused-vars": "warn",
		},
		// ...other configuration
	},
];
123456789101112131415
    
        Copy code to clipboard
        
    

A flat config example configuration supporting multiple configs for different glob patterns:


    // eslint.config.js

import js from "@eslint/js";

export default [
	js.configs.recommended, // Recommended config applied to all files
	// File-pattern specific overrides
	{
		files: ["src/**/*", "test/**/*"],
		rules: {
			semi: ["warn", "always"],
		},
	},
	{
		files: ["test/**/*"],
		rules: {
			"no-console": "off",
		},
	},
	// ...other configurations
];
123456789101112131415161718192021
    
        Copy code to clipboard
        
    

Configuring Language Options
In eslintrc files, you configure various language options across the env, globals and parserOptions properties. Groups of global variables for specific runtimes (e.g. document and window for browser JavaScript; process and require for Node.js) are configured with the env property.
In flat config files, the globals, and parserOptions are consolidated under the languageOptions key; the env property doesn’t exist. Groups of global variables for specific runtimes are imported from the globals npm package and included in the globals property. You can use the spread operator (...) to import multiple globals at once.
For example, here’s an eslintrc file with language options:


    // .eslintrc.js

module.exports = {
	env: {
		browser: true,
		node: true,
	},
	globals: {
		myCustomGlobal: "readonly",
	},
	parserOptions: {
		ecmaVersion: 2022,
		sourceType: "module",
	},
	// ...other config
};
12345678910111213141516
    
        Copy code to clipboard
        
    

Here’s the same configuration in flat config:


    // eslint.config.js

import globals from "globals";

export default [
	{
		languageOptions: {
			ecmaVersion: 2022,
			sourceType: "module",
			globals: {
				...globals.browser,
				...globals.node,
				myCustomGlobal: "readonly",
			},
		},
		// ...other config
	},
];
123456789101112131415161718
    
        Copy code to clipboard
        
    


                    
                    
                        Tip
                        You’ll need to install the globals package from npm for this example to work. It is not automatically installed by ESLint.

                    
                eslint-env Configuration Comments
In the eslintrc config system it was possible to use eslint-env configuration comments to define globals for a file.
These comments are no longer recognized when linting with flat config: in a future version of ESLint, eslint-env comments will be reported as errors.
For this reason, when migrating from eslintrc to flat config, eslint-env configuration comments should be removed from all files.
They can be either replaced with equivalent but more verbose global configuration comments, or dropped in favor of globals definitions in the config file.
For example, when using eslintrc, a file to be linted could look like this:


    // tests/my-file.js

/* eslint-env mocha */

describe("unit tests", () => {
	it("should pass", () => {
		// ...
	});
});
123456789
    
        Copy code to clipboard
        
    

In the above example, describe and it would be recognized as global identifiers because of the /* eslint-env mocha */ comment.
The same effect can be achieved with flat config with a global configuration comment, e.g.:


    // tests/my-file.js

/* global describe, it -- Globals defined by Mocha */

describe("unit tests", () => {
	it("should pass", () => {
		// ...
	});
});
123456789
    
        Copy code to clipboard
        
    

Another option is to remove the comment from the file being linted and define the globals in the configuration, for example:


    // eslint.config.js

import globals from "globals";

export default [
	// ...other config
	{
		files: ["tests/**"],
		languageOptions: {
			globals: {
				...globals.mocha,
			},
		},
	},
];
123456789101112131415
    
        Copy code to clipboard
        
    

Predefined and Shareable Configs
In eslintrc files, use the extends property to use predefined and shareable configs. ESLint comes with two predefined configs that you can access as strings:

"eslint:recommended": the rules recommended by ESLint.
"eslint:all": all rules shipped with ESLint.

You can also use the extends property to extend a shareable config. Shareable configs can either be paths to local config files or npm package names.
In flat config files, predefined configs are imported from separate modules into flat config files. The recommended and all rules configs are located in the @eslint/js package. You must import this package to use these configs:

   
      npm
      yarn
      pnpm
      bun
   
    
        npm


    npm install --save-dev @eslint/js
1
    
        Copy code to clipboard
        
    


   
      yarn


    yarn add --dev @eslint/js
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm add --save-dev @eslint/js
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bun add --dev @eslint/js
1
    
        Copy code to clipboard
        
    

   

You can add each of these configs to the exported array or expose specific rules from them. You must import the modules for local config files and npm package configs with flat config.
For example, here’s an eslintrc file using the built-in eslint:recommended config:


    // .eslintrc.js

module.exports = {
	// ...other config
	extends: "eslint:recommended",
	rules: {
		semi: ["warn", "always"],
	},
	// ...other config
};
12345678910
    
        Copy code to clipboard
        
    

This eslintrc file uses built-in config, local custom config, and shareable config from an npm package:


    // .eslintrc.js

module.exports = {
	// ...other config
	extends: [
		"eslint:recommended",
		"./custom-config.js",
		"eslint-config-my-config",
	],
	rules: {
		semi: ["warn", "always"],
	},
	// ...other config
};
1234567891011121314
    
        Copy code to clipboard
        
    

To use the same configs in flat config, you would do the following:


    // eslint.config.js

import js from "@eslint/js";
import customConfig from "./custom-config.js";
import myConfig from "eslint-config-my-config";

export default [
	js.configs.recommended,
	customConfig,
	myConfig,
	{
		rules: {
			semi: ["warn", "always"],
		},
		// ...other config
	},
];
1234567891011121314151617
    
        Copy code to clipboard
        
    

Note that because you are just importing JavaScript modules, you can mutate the config objects before ESLint uses them. For example, you might want to have a certain config object only apply to your test files:


    // eslint.config.js

import js from "@eslint/js";
import customTestConfig from "./custom-test-config.js";

export default [
	js.configs.recommended,
	{
		...customTestConfig,
		files: ["**/*.test.js"],
	},
];
123456789101112
    
        Copy code to clipboard
        
    

Using eslintrc Configs in Flat Config
You may find that there’s a shareable config you rely on that hasn’t yet been updated to flat config format. In that case, you can use the FlatCompat utility to translate the eslintrc format into flat config format. First, install the @eslint/eslintrc package:

   
      npm
      yarn
      pnpm
      bun
   
    
        npm


    npm install --save-dev @eslint/eslintrc
1
    
        Copy code to clipboard
        
    


   
      yarn


    yarn add --dev @eslint/eslintrc
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm add --save-dev @eslint/eslintrc
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bun add --dev @eslint/eslintrc
1
    
        Copy code to clipboard
        
    

   

Then, import FlatCompat and create a new instance to convert an existing eslintrc config. For example, if the npm package eslint-config-my-config is in eslintrc format, you can write this:


    import { FlatCompat } from "@eslint/eslintrc";
import path from "path";
import { fileURLToPath } from "url";

// mimic CommonJS variables -- not needed if using CommonJS
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const compat = new FlatCompat({
	baseDirectory: __dirname,
});

export default [
	// mimic ESLintRC-style extends
	...compat.extends("eslint-config-my-config"),
];
12345678910111213141516
    
        Copy code to clipboard
        
    

This example uses the FlatCompat#extends() method to insert the eslint-config-my-config into the flat config array.
For more information about the FlatCompat class, please see the package README.
Ignoring Files
With eslintrc, you can make ESLint ignore files by creating a separate .eslintignore file in the root of your project. The .eslintignore file uses the same glob pattern syntax as .gitignore files. Alternatively, you can use an ignorePatterns property in your eslintrc file.
To ignore files with flat config, you can use the ignores property in a config object with no other properties. The ignores property accepts an array of glob patterns. Flat config does not support loading ignore patterns from .eslintignore files, so you’ll need to migrate those patterns directly into flat config.
For example, here’s a .eslintignore example you can use with an eslintrc config:


    # .eslintignore
temp.js
config/*
# ...other ignored files
1234
    
        Copy code to clipboard
        
    

Here are the same patterns represented as ignorePatterns in a .eslintrc.js file:


    // .eslintrc.js
module.exports = {
	// ...other config
	ignorePatterns: ["temp.js", "config/*"],
};
12345
    
        Copy code to clipboard
        
    

The equivalent ignore patterns in flat config look like this:


    export default [
	// ...other config
	{
		// Note: there should be no other properties in this object
		ignores: ["**/temp.js", "config/*"],
	},
];
1234567
    
        Copy code to clipboard
        
    

In .eslintignore, temp.js ignores all files named temp.js, whereas in flat config, you need to specify this as **/temp.js. The pattern temp.js in flat config only ignores a file named temp.js in the same directory as the configuration file.

                    
                    
                        Important
                        In flat config, dotfiles (e.g. .dotfile.js) are no longer ignored by default. If you want to ignore dotfiles, add an ignore pattern of "**/.*".

                    
                Linter Options
Eslintrc files let you configure the linter itself with the noInlineConfig and reportUnusedDisableDirectives properties.
The flat config system introduces a new top-level property linterOptions that you can use to configure the linter. In the linterOptions object, you can include noInlineConfig and reportUnusedDisableDirectives.
For example, here’s an eslintrc file with linter options enabled:


    // .eslintrc.js

module.exports = {
	// ...other config
	noInlineConfig: true,
	reportUnusedDisableDirectives: true,
};
1234567
    
        Copy code to clipboard
        
    

Here’s the same options in flat config:


    // eslint.config.js

export default [
	{
		// ...other config
		linterOptions: {
			noInlineConfig: true,
			reportUnusedDisableDirectives: "warn",
		},
	},
];
1234567891011
    
        Copy code to clipboard
        
    

CLI Flag Changes
The following CLI flags are no longer supported with the flat config file format:

--rulesdir
--ext
--resolve-plugins-relative-to

The flag --no-eslintrc has been replaced with --no-config-lookup.
--rulesdir
The --rulesdir flag was used to load additional rules from a specified directory. This is no longer supported when using flat config. You can instead create a plugin containing the local rules you have directly in your config, like this:


    // eslint.config.js
import myRule from "./rules/my-rule.js";

export default [
	{
		// define the plugin
		plugins: {
			local: {
				rules: {
					"my-rule": myRule,
				},
			},
		},

		// configure the rule
		rules: {
			"local/my-rule": ["error"],
		},
	},
];
1234567891011121314151617181920
    
        Copy code to clipboard
        
    

--ext
The --ext flag was used to specify additional file extensions ESLint should search for when a directory was passed on the command line, such as npx eslint .. This is no longer supported when using flat config. Instead, specify the file patterns you’d like ESLint to search for directly in your config. For example, if you previously were using --ext .ts,.tsx, then you will need to update your config file like this:


    // eslint.config.js
export default [
	{
		files: ["**/*.ts", "**/*.tsx"],

		// any additional configuration for these file types here
	},
];
12345678
    
        Copy code to clipboard
        
    

ESLint uses the files keys from the config file to determine which files should be linted.
--resolve-plugins-relative-to
The --resolve-plugins-relative-to flag was used to indicate which directory plugin references in your configuration file should be resolved relative to. This was necessary because shareable configs could only resolve plugins that were peer dependencies or dependencies of parent packages.
With flat config, shareable configs can specify their dependencies directly, so this flag is no longer needed.
package.json Configuration No Longer Supported
With eslintrc, it was possible to use a package.json file to configure ESLint using the eslintConfig key.
With flat config, it’s no longer possible to use a package.json file to configure ESLint. You’ll need to move your configuration into a separate file.
Additional Changes
The following changes have been made from the eslintrc to the flat config file format:

The root option no longer exists. (Flat config files act as if root: true is set.)
The files option cannot be a single string anymore, it must be an array.
The sourceType option now supports the new value "commonjs" (.eslintrc supports it too, but it was never documented).

TypeScript Types for Flat Config Files
You can see the TypeScript types for the flat config file format in the lib/types source folder on GitHub. The interface for the objects in the config’s array is called Linter.Config.
You can view the type definitions in lib/types/index.d.ts.
Visual Studio Code Support
ESLint v9.x support was added in the vscode-eslint v3.0.10.
In versions of vscode-eslint prior to v3.0.10, the new configuration system is not enabled by default. To enable support for the new configuration files, edit your .vscode/settings.json file and add the following:


    {
	// required in vscode-eslint < v3.0.10 only
	"eslint.experimental.useFlatConfig": true
}
1234
    
        Copy code to clipboard
        
    

In a future version of the ESLint plugin, you will no longer need to enable this manually.
Further Reading

Overview of the flat config file format blog post
API usage of new configuration system blog post
Background to new configuration system blog post


            

            
                Edit this page\n\n\n\nCommand Line Interface Reference
                

                Table of Contents
    
        
                
                    
                    Run the CLI
            		

                    Pass Multiple Values to an Option
            		

                    Options
            
                
                    
                    Basic Configuration
            
                
                    
                    --no-eslintrc
            		

                    -c, --config
            		

                    --inspect-config
            		

                    --env
            		

                    --ext
            		

                    --global
            		

                    --parser
            		

                    --parser-options
            		

                    --resolve-plugins-relative-to
            		
                
            		

                    Specify Rules and Plugins
            
                
                    
                    --plugin
            		

                    --rule
            		

                    --rulesdir
            		
                
            		

                    Fix Problems
            
                
                    
                    --fix
            		

                    --fix-dry-run
            		

                    --fix-type
            		
                
            		

                    Ignore Files
            
                
                    
                    --ignore-path
            		

                    --no-ignore
            		

                    --ignore-pattern
            		
                
            		

                    Use stdin
            
                
                    
                    --stdin
            		

                    --stdin-filename
            		
                
            		

                    Handle Warnings
            
                
                    
                    --quiet
            		

                    --max-warnings
            		
                
            		

                    Output
            
                
                    
                    -o, --output-file
            		

                    -f, --format
            		

                    --color and --no-color
            		
                
            		

                    Inline Configuration Comments
            
                
                    
                    --no-inline-config
            		

                    --report-unused-disable-directives
            		

                    --report-unused-disable-directives-severity
            		

                    --report-unused-inline-configs
            		
                
            		

                    Caching
            
                
                    
                    --cache
            		

                    --cache-file
            		

                    --cache-location
            		

                    --cache-strategy
            		
                
            		

                    Suppressing Violations
            
                
                    
                    --suppress-all
            		

                    --suppress-rule
            		

                    --suppressions-location
            		

                    --prune-suppressions
            		
                
            		

                    Miscellaneous
            
                
                    
                    --init
            		

                    --env-info
            		

                    --no-error-on-unmatched-pattern
            		

                    --exit-on-fatal-error
            		

                    --no-warn-ignored
            		

                    --pass-on-no-patterns
            		

                    --debug
            		

                    -h, --help
            		

                    -v, --version
            		

                    --print-config
            		

                    --stats
            		

                    --flag
            		
                
            		
                
            		

                    Exit Codes
            		
                
            
    


                The ESLint Command Line Interface (CLI) lets you execute linting from the terminal. The CLI has a variety of options that you can pass to configure ESLint.
Run the CLI
ESLint requires Node.js for installation. Follow the instructions in the Getting Started Guide to install ESLint.
Most users use npx to run ESLint on the command line like this:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint [options] [file|dir|glob]* 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint [options] [file|dir|glob]* 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint [options] [file|dir|glob]* 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint [options] [file|dir|glob]* 
1
    
        Copy code to clipboard
        
    

   

Such as:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    # Run on two files
npx eslint file1.js file2.js 
12
    
        Copy code to clipboard
        
    

   
   
      yarn


    # Run on two files
yarn dlx eslint file1.js file2.js 
12
    
        Copy code to clipboard
        
    

   
   
      pnpm


    # Run on two files
pnpm dlx eslint file1.js file2.js 
12
    
        Copy code to clipboard
        
    

   
   
      bun


    # Run on two files
bunx eslint file1.js file2.js 
12
    
        Copy code to clipboard
        
    

   

or

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    # Run on multiple files
npx eslint lib/** 
12
    
        Copy code to clipboard
        
    

   
   
      yarn


    # Run on multiple files
yarn dlx eslint lib/** 
12
    
        Copy code to clipboard
        
    

   
   
      pnpm


    # Run on multiple files
pnpm dlx eslint lib/** 
12
    
        Copy code to clipboard
        
    

   
   
      bun


    # Run on multiple files
bunx eslint lib/** 
12
    
        Copy code to clipboard
        
    

   

Please note that when passing a glob as a parameter, it is expanded by your shell. The results of the expansion can vary depending on your shell, and its configuration. If you want to use node glob syntax, you have to quote your parameter (using double quotes if you need it to run in Windows), as follows:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint "lib/**" 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint "lib/**" 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint "lib/**" 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint "lib/**" 
1
    
        Copy code to clipboard
        
    

   

If you are using a flat configuration file (eslint.config.js), you can also omit the file arguments and ESLint will use .. For instance, these two lines perform the same operation:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint . 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint . 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint . 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint . 
1
    
        Copy code to clipboard
        
    

   


   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint 
1
    
        Copy code to clipboard
        
    

   

If you are not using a flat configuration file, running ESLint without file arguments results in an error.
Note: You can also use alternative package managers such as Yarn or pnpm to run ESLint. For pnpm use pnpm dlx eslint and for Yarn use yarn dlx eslint.
Pass Multiple Values to an Option
Options that accept multiple values can be specified by repeating the option or with a comma-delimited list (other than --ignore-pattern, which does not allow the second style).
Examples of options that accept multiple values:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --global describe --global it tests/ 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --global describe --global it tests/ 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --global describe --global it tests/ 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --global describe --global it tests/ 
1
    
        Copy code to clipboard
        
    

   

OR

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --global describe,it tests/ 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --global describe,it tests/ 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --global describe,it tests/ 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --global describe,it tests/ 
1
    
        Copy code to clipboard
        
    

   

Options
You can view all the CLI options by running npx eslint -h.


    eslint [options] file.js [file.js] [dir]

Basic configuration:
  --no-config-lookup              Disable look up for eslint.config.js
  -c, --config path::String       Use this configuration instead of eslint.config.js, eslint.config.mjs, or
                                  eslint.config.cjs
  --inspect-config                Open the config inspector with the current configuration
  --ext [String]                  Specify additional file extensions to lint
  --global [String]               Define global variables
  --parser String                 Specify the parser to be used
  --parser-options Object         Specify parser options

Specify Rules and Plugins:
  --plugin [String]               Specify plugins
  --rule Object                   Specify rules

Fix Problems:
  --fix                           Automatically fix problems
  --fix-dry-run                   Automatically fix problems without saving the changes to the file system
  --fix-type Array                Specify the types of fixes to apply (directive, problem, suggestion, layout)

Ignore Files:
  --no-ignore                     Disable use of ignore files and patterns
  --ignore-pattern [String]       Patterns of files to ignore

Use stdin:
  --stdin                         Lint code provided on <STDIN> - default: false
  --stdin-filename String         Specify filename to process STDIN as

Handle Warnings:
  --quiet                         Report errors only - default: false
  --max-warnings Int              Number of warnings to trigger nonzero exit code - default: -1

Output:
  -o, --output-file path::String  Specify file to write report to
  -f, --format String             Use a specific output format - default: stylish
  --color, --no-color             Force enabling/disabling of color

Inline configuration comments:
  --no-inline-config              Prevent comments from changing config or rules
  --report-unused-disable-directives  Adds reported errors for unused eslint-disable and eslint-enable directives
  --report-unused-disable-directives-severity String  Chooses severity level for reporting unused eslint-disable and
                                                      eslint-enable directives - either: off, warn, error, 0, 1, or 2
  --report-unused-inline-configs String  Adds reported errors for unused eslint inline config comments - either: off, warn, error, 0, 1, or 2

Caching:
  --cache                         Only check changed files - default: false
  --cache-file path::String       Path to the cache file. Deprecated: use --cache-location - default: .eslintcache
  --cache-location path::String   Path to the cache file or directory
  --cache-strategy String         Strategy to use for detecting changed files in the cache - either: metadata or
                                  content - default: metadata

Suppressing Violations:
  --suppress-all                  Suppress all violations - default: false
  --suppress-rule [String]        Suppress specific rules
  --suppressions-location path::String  Specify the location of the suppressions file
  --prune-suppressions            Prune unused suppressions - default: false

Miscellaneous:
  --init                          Run config initialization wizard - default: false
  --env-info                      Output execution environment information - default: false
  --no-error-on-unmatched-pattern  Prevent errors when pattern is unmatched
  --exit-on-fatal-error           Exit with exit code 2 in case of fatal error - default: false
  --no-warn-ignored               Suppress warnings when the file list includes ignored files
  --pass-on-no-patterns           Exit with exit code 0 in case no file patterns are passed
  --debug                         Output debugging information
  -h, --help                      Show help
  -v, --version                   Output the version number
  --print-config path::String     Print the configuration for the given file
  --stats                         Add statistics to the lint report - default: false
  --flag [String]                 Enable a feature flag
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071
    
        Copy code to clipboard
        
    

Basic Configuration
--no-eslintrc
eslintrc Mode Only. Disables use of configuration from .eslintrc.* and package.json files. For flat config mode, use --no-config-lookup instead.

Argument Type: No argument.

--no-eslintrc example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --no-eslintrc file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --no-eslintrc file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --no-eslintrc file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --no-eslintrc file.js 
1
    
        Copy code to clipboard
        
    

   

-c, --config
This option allows you to specify an additional configuration file for ESLint (see Configure ESLint for more).

Argument Type: String. Path to file.
Multiple Arguments: No

-c, --config example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint -c ~/my.eslint.config.js file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint -c ~/my.eslint.config.js file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint -c ~/my.eslint.config.js file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint -c ~/my.eslint.config.js file.js 
1
    
        Copy code to clipboard
        
    

   

This example uses the configuration file at ~/my.eslint.config.js, which is used instead of searching for an eslint.config.js file.
--inspect-config
Flat Config Mode Only. This option runs npx @eslint/config-inspector@latest to start the config inspector. You can use the config inspector to better understand what your configuration is doing and which files it applies to. When you use this flag, the CLI does not perform linting.

Argument Type: No argument.

--inspect-config example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --inspect-config 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --inspect-config 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --inspect-config 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --inspect-config 
1
    
        Copy code to clipboard
        
    

   

--env
eslintrc Mode Only. This option enables specific environments.

Argument Type: String. One of the available environments.
Multiple Arguments: Yes

Details about the global variables defined by each environment are available in the Specifying Environments documentation. This option only enables environments. It does not disable environments set in other configuration files. To specify multiple environments, separate them using commas, or use the option multiple times.
--env example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --env browser,node file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --env browser,node file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --env browser,node file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --env browser,node file.js 
1
    
        Copy code to clipboard
        
    

   


   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --env browser --env node file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --env browser --env node file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --env browser --env node file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --env browser --env node file.js 
1
    
        Copy code to clipboard
        
    

   

--ext
This option allows you to specify additional file extensions to lint.

Argument Type: String. File extension.
Multiple Arguments: Yes
Default Value: By default, ESLint lints files with extensions .js, .mjs, .cjs, and additional extensions specified in the configuration file.

This option is primarily intended for use in combination with the --no-config-lookup option, since in that case there is no configuration file in which the additional extensions would be specified.
--ext example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    # Include .ts files
npx eslint . --ext .ts 
12
    
        Copy code to clipboard
        
    

   
   
      yarn


    # Include .ts files
yarn dlx eslint . --ext .ts 
12
    
        Copy code to clipboard
        
    

   
   
      pnpm


    # Include .ts files
pnpm dlx eslint . --ext .ts 
12
    
        Copy code to clipboard
        
    

   
   
      bun


    # Include .ts files
bunx eslint . --ext .ts 
12
    
        Copy code to clipboard
        
    

   


   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    # Include .ts and .tsx files
npx eslint . --ext .ts --ext .tsx 
12
    
        Copy code to clipboard
        
    

   
   
      yarn


    # Include .ts and .tsx files
yarn dlx eslint . --ext .ts --ext .tsx 
12
    
        Copy code to clipboard
        
    

   
   
      pnpm


    # Include .ts and .tsx files
pnpm dlx eslint . --ext .ts --ext .tsx 
12
    
        Copy code to clipboard
        
    

   
   
      bun


    # Include .ts and .tsx files
bunx eslint . --ext .ts --ext .tsx 
12
    
        Copy code to clipboard
        
    

   


   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    # Also include .ts and .tsx files
npx eslint . --ext .ts,.tsx 
12
    
        Copy code to clipboard
        
    

   
   
      yarn


    # Also include .ts and .tsx files
yarn dlx eslint . --ext .ts,.tsx 
12
    
        Copy code to clipboard
        
    

   
   
      pnpm


    # Also include .ts and .tsx files
pnpm dlx eslint . --ext .ts,.tsx 
12
    
        Copy code to clipboard
        
    

   
   
      bun


    # Also include .ts and .tsx files
bunx eslint . --ext .ts,.tsx 
12
    
        Copy code to clipboard
        
    

   

--global
This option defines global variables so that they are not flagged as undefined by the no-undef rule.

Argument Type: String. Name of the global variable. Any specified global variables are assumed to be read-only by default, but appending :true to a variable’s name ensures that no-undef also allows writes.
Multiple Arguments: Yes

--global example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --global require,exports:true file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --global require,exports:true file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --global require,exports:true file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --global require,exports:true file.js 
1
    
        Copy code to clipboard
        
    

   


   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --global require --global exports:true 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --global require --global exports:true 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --global require --global exports:true 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --global require --global exports:true 
1
    
        Copy code to clipboard
        
    

   

--parser
This option allows you to specify a parser to be used by ESLint.

Argument Type: String. Parser to be used by ESLint.
Multiple Arguments: No
Default Value: espree

--parser example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    # Use TypeScript ESLint parser
npx eslint --parser @typescript-eslint/parser file.ts 
12
    
        Copy code to clipboard
        
    

   
   
      yarn


    # Use TypeScript ESLint parser
yarn dlx eslint --parser @typescript-eslint/parser file.ts 
12
    
        Copy code to clipboard
        
    

   
   
      pnpm


    # Use TypeScript ESLint parser
pnpm dlx eslint --parser @typescript-eslint/parser file.ts 
12
    
        Copy code to clipboard
        
    

   
   
      bun


    # Use TypeScript ESLint parser
bunx eslint --parser @typescript-eslint/parser file.ts 
12
    
        Copy code to clipboard
        
    

   

--parser-options
This option allows you to specify parser options to be used by ESLint. The available parser options are determined by the parser being used.

Argument Type: Key/value pair separated by colon (:).
Multiple Arguments: Yes

--parser-options example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    # fails with a parsing error
echo '3 ** 4' | npx eslint --stdin --parser-options ecmaVersion:6 
12
    
        Copy code to clipboard
        
    

   
   
      yarn


    # fails with a parsing error
echo '3 ** 4' | yarn dlx eslint --stdin --parser-options ecmaVersion:6 
12
    
        Copy code to clipboard
        
    

   
   
      pnpm


    # fails with a parsing error
echo '3 ** 4' | pnpm dlx eslint --stdin --parser-options ecmaVersion:6 
12
    
        Copy code to clipboard
        
    

   
   
      bun


    # fails with a parsing error
echo '3 ** 4' | bunx eslint --stdin --parser-options ecmaVersion:6 
12
    
        Copy code to clipboard
        
    

   


   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    # succeeds, yay!
echo '3 ** 4' | npx eslint --stdin --parser-options ecmaVersion:7 
12
    
        Copy code to clipboard
        
    

   
   
      yarn


    # succeeds, yay!
echo '3 ** 4' | yarn dlx eslint --stdin --parser-options ecmaVersion:7 
12
    
        Copy code to clipboard
        
    

   
   
      pnpm


    # succeeds, yay!
echo '3 ** 4' | pnpm dlx eslint --stdin --parser-options ecmaVersion:7 
12
    
        Copy code to clipboard
        
    

   
   
      bun


    # succeeds, yay!
echo '3 ** 4' | bunx eslint --stdin --parser-options ecmaVersion:7 
12
    
        Copy code to clipboard
        
    

   

--resolve-plugins-relative-to
eslintrc Mode Only. Changes the directory where plugins are resolved from.

Argument Type: String. Path to directory.
Multiple Arguments: No
Default Value: By default, plugins are resolved from the directory in which your configuration file is found.

This option should be used when plugins were installed by someone other than the end user. It should be set to the project directory of the project that has a dependency on the necessary plugins.
For example:

When using a config file that is located outside of the current project (with the --config flag), if the config uses plugins which are installed locally to itself, --resolve-plugins-relative-to should be set to the directory containing the config file.
If an integration has dependencies on ESLint and a set of plugins, and the tool invokes ESLint on behalf of the user with a preset configuration, the tool should set --resolve-plugins-relative-to to the top-level directory of the tool.

--resolve-plugins-relative-to example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --config ~/personal-eslintrc.js --resolve-plugins-relative-to /usr/local/lib/ 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --config ~/personal-eslintrc.js --resolve-plugins-relative-to /usr/local/lib/ 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --config ~/personal-eslintrc.js --resolve-plugins-relative-to /usr/local/lib/ 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --config ~/personal-eslintrc.js --resolve-plugins-relative-to /usr/local/lib/ 
1
    
        Copy code to clipboard
        
    

   

Specify Rules and Plugins
--plugin
This option specifies a plugin to load.

Argument Type: String. Plugin name. You can optionally omit the prefix eslint-plugin- from the plugin name.
Multiple Arguments: Yes

Before using the plugin, you have to install it using npm.
--plugin example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --plugin jquery file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --plugin jquery file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --plugin jquery file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --plugin jquery file.js 
1
    
        Copy code to clipboard
        
    

   


   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --plugin eslint-plugin-mocha file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --plugin eslint-plugin-mocha file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --plugin eslint-plugin-mocha file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --plugin eslint-plugin-mocha file.js 
1
    
        Copy code to clipboard
        
    

   

--rule
This option specifies the rules to be used.

Argument Type: Rules and their configuration specified with levn format.
Multiple Arguments: Yes

These rules are merged with any rules specified with configuration files. If the rule is defined in a plugin, you have to prefix the rule ID with the plugin name and a /.
To ignore rules in .eslintrc configuration files and only run rules specified in the command line, use the --rule flag in combination with the --no-eslintrc flag.
--rule example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    # Apply single rule
npx eslint --rule 'quotes: [error, double]' 
12
    
        Copy code to clipboard
        
    

   
   
      yarn


    # Apply single rule
yarn dlx eslint --rule 'quotes: [error, double]' 
12
    
        Copy code to clipboard
        
    

   
   
      pnpm


    # Apply single rule
pnpm dlx eslint --rule 'quotes: [error, double]' 
12
    
        Copy code to clipboard
        
    

   
   
      bun


    # Apply single rule
bunx eslint --rule 'quotes: [error, double]' 
12
    
        Copy code to clipboard
        
    

   


   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    # Apply multiple rules
npx eslint --rule 'guard-for-in: error' --rule 'brace-style: [error, 1tbs]' 
12
    
        Copy code to clipboard
        
    

   
   
      yarn


    # Apply multiple rules
yarn dlx eslint --rule 'guard-for-in: error' --rule 'brace-style: [error, 1tbs]' 
12
    
        Copy code to clipboard
        
    

   
   
      pnpm


    # Apply multiple rules
pnpm dlx eslint --rule 'guard-for-in: error' --rule 'brace-style: [error, 1tbs]' 
12
    
        Copy code to clipboard
        
    

   
   
      bun


    # Apply multiple rules
bunx eslint --rule 'guard-for-in: error' --rule 'brace-style: [error, 1tbs]' 
12
    
        Copy code to clipboard
        
    

   


   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    # Apply rule from jquery plugin
npx eslint --rule 'jquery/dollar-sign: error' 
12
    
        Copy code to clipboard
        
    

   
   
      yarn


    # Apply rule from jquery plugin
yarn dlx eslint --rule 'jquery/dollar-sign: error' 
12
    
        Copy code to clipboard
        
    

   
   
      pnpm


    # Apply rule from jquery plugin
pnpm dlx eslint --rule 'jquery/dollar-sign: error' 
12
    
        Copy code to clipboard
        
    

   
   
      bun


    # Apply rule from jquery plugin
bunx eslint --rule 'jquery/dollar-sign: error' 
12
    
        Copy code to clipboard
        
    

   


   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    # Only apply rule from the command line
npx eslint --rule 'quotes: [error, double]' --no-eslintrc 
12
    
        Copy code to clipboard
        
    

   
   
      yarn


    # Only apply rule from the command line
yarn dlx eslint --rule 'quotes: [error, double]' --no-eslintrc 
12
    
        Copy code to clipboard
        
    

   
   
      pnpm


    # Only apply rule from the command line
pnpm dlx eslint --rule 'quotes: [error, double]' --no-eslintrc 
12
    
        Copy code to clipboard
        
    

   
   
      bun


    # Only apply rule from the command line
bunx eslint --rule 'quotes: [error, double]' --no-eslintrc 
12
    
        Copy code to clipboard
        
    

   

--rulesdir
Deprecated: Use rules from plugins instead.
eslintrc Mode Only. This option allows you to specify another directory from which to load rules files. This allows you to dynamically load new rules at run time. This is useful when you have custom rules that aren’t suitable for being bundled with ESLint.

Argument Type: String. Path to directory. The rules in your custom rules directory must follow the same format as bundled rules to work properly.
Multiple Arguments: Yes

Note that, as with core rules and plugin rules, you still need to enable the rules in configuration or via the --rule CLI option in order to actually run those rules during linting. Specifying a rules directory with --rulesdir does not automatically enable the rules within that directory.
--rulesdir example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --rulesdir my-rules/ file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --rulesdir my-rules/ file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --rulesdir my-rules/ file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --rulesdir my-rules/ file.js 
1
    
        Copy code to clipboard
        
    

   


   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --rulesdir my-rules/ --rulesdir my-other-rules/ file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --rulesdir my-rules/ --rulesdir my-other-rules/ file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --rulesdir my-rules/ --rulesdir my-other-rules/ file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --rulesdir my-rules/ --rulesdir my-other-rules/ file.js 
1
    
        Copy code to clipboard
        
    

   

Fix Problems
--fix
This option instructs ESLint to try to fix as many issues as possible. The fixes are made to the actual files themselves and only the remaining unfixed issues are output.

Argument Type: No argument.

Not all problems are fixable using this option, and the option does not work in these situations:

This option throws an error when code is piped to ESLint.
This option has no effect on code that uses a processor, unless the processor opts into allowing autofixes.

If you want to fix code from stdin or otherwise want to get the fixes without actually writing them to the file, use the --fix-dry-run option.
--fix example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --fix file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --fix file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --fix file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --fix file.js 
1
    
        Copy code to clipboard
        
    

   

--fix-dry-run
This option has the same effect as --fix with the difference that the fixes are not saved to the file system. Because the default formatter does not output the fixed code, you’ll have to use another formatter (e.g. --format json) to get the fixes.

Argument Type: No argument.

This makes it possible to fix code from stdin when used with the --stdin flag.
This flag can be useful for integrations (e.g. editor plugins) which need to autofix text from the command line without saving it to the filesystem.
--fix-dry-run example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    getSomeText | npx eslint --stdin --fix-dry-run --format json 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    getSomeText | yarn dlx eslint --stdin --fix-dry-run --format json 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    getSomeText | pnpm dlx eslint --stdin --fix-dry-run --format json 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    getSomeText | bunx eslint --stdin --fix-dry-run --format json 
1
    
        Copy code to clipboard
        
    

   

--fix-type
This option allows you to specify the type of fixes to apply when using either --fix or --fix-dry-run.

Argument Type: String. One of the following fix types:

problem - fix potential errors in the code
suggestion - apply fixes to the code that improve it
layout - apply fixes that do not change the program structure (AST)
directive - apply fixes to inline directives such as // eslint-disable


Multiple Arguments: Yes

This option is helpful if you are using another program to format your code, but you would still like ESLint to apply other types of fixes.
--fix-type example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --fix --fix-type suggestion . 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --fix --fix-type suggestion . 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --fix --fix-type suggestion . 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --fix --fix-type suggestion . 
1
    
        Copy code to clipboard
        
    

   


   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --fix --fix-type suggestion --fix-type problem . 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --fix --fix-type suggestion --fix-type problem . 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --fix --fix-type suggestion --fix-type problem . 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --fix --fix-type suggestion --fix-type problem . 
1
    
        Copy code to clipboard
        
    

   


   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --fix --fix-type suggestion,layout . 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --fix --fix-type suggestion,layout . 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --fix --fix-type suggestion,layout . 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --fix --fix-type suggestion,layout . 
1
    
        Copy code to clipboard
        
    

   

Ignore Files
--ignore-path
eslintrc Mode Only. This option allows you to specify the file to use as your .eslintignore.

Argument Type: String. Path to file.
Multiple Arguments: No
Default Value: By default, ESLint looks for .eslintignore in the current working directory.

Note: --ignore-path is only supported when using deprecated configuration. If you want to include patterns from a .gitignore file in your eslint.config.js file, please see including .gitignore files.
--ignore-path example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --ignore-path tmp/.eslintignore file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --ignore-path tmp/.eslintignore file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --ignore-path tmp/.eslintignore file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --ignore-path tmp/.eslintignore file.js 
1
    
        Copy code to clipboard
        
    

   


   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --ignore-path .gitignore file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --ignore-path .gitignore file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --ignore-path .gitignore file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --ignore-path .gitignore file.js 
1
    
        Copy code to clipboard
        
    

   

--no-ignore
Disables excluding of files from .eslintignore files, --ignore-path flags, --ignore-pattern flags, and the ignorePatterns property in config files.

Argument Type: No argument.

--no-ignore example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --no-ignore file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --no-ignore file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --no-ignore file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --no-ignore file.js 
1
    
        Copy code to clipboard
        
    

   

--ignore-pattern
This option allows you to specify patterns of files to ignore. In eslintrc mode, these are in addition to .eslintignore.

Argument Type: String. The supported syntax is the same as for .eslintignore files, which use the same patterns as the .gitignore specification. You should quote your patterns in order to avoid shell interpretation of glob patterns.
Multiple Arguments: Yes

--ignore-pattern example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --ignore-pattern "/lib/" --ignore-pattern "/src/vendor/*" . 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --ignore-pattern "/lib/" --ignore-pattern "/src/vendor/*" . 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --ignore-pattern "/lib/" --ignore-pattern "/src/vendor/*" . 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --ignore-pattern "/lib/" --ignore-pattern "/src/vendor/*" . 
1
    
        Copy code to clipboard
        
    

   

Use stdin
--stdin
This option tells ESLint to read and lint source code from STDIN instead of from files. You can use this to pipe code to ESLint.

Argument Type: No argument.

--stdin example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    cat myFile.js | npx eslint --stdin 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    cat myFile.js | yarn dlx eslint --stdin 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    cat myFile.js | pnpm dlx eslint --stdin 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    cat myFile.js | bunx eslint --stdin 
1
    
        Copy code to clipboard
        
    

   

--stdin-filename
This option allows you to specify a filename to process STDIN as.

Argument Type: String. Path to file.
Multiple Arguments: No

This is useful when processing files from STDIN and you have rules which depend on the filename.
--stdin-filename example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    cat myFile.js | npx eslint --stdin --stdin-filename myfile.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    cat myFile.js | yarn dlx eslint --stdin --stdin-filename myfile.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    cat myFile.js | pnpm dlx eslint --stdin --stdin-filename myfile.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    cat myFile.js | bunx eslint --stdin --stdin-filename myfile.js 
1
    
        Copy code to clipboard
        
    

   

Handle Warnings
--quiet
This option allows you to disable reporting on warnings and running of rules set to warn. If you enable this option, only errors are reported by ESLint and only rules set to error will be run.

Argument Type: No argument.

--quiet example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --quiet file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --quiet file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --quiet file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --quiet file.js 
1
    
        Copy code to clipboard
        
    

   

--max-warnings
This option allows you to specify a warning threshold, which can be used to force ESLint to exit with an error status if there are too many warning-level rule violations in your project.

Argument Type: Integer. The maximum number of warnings to allow. To prevent this behavior, do not use this option or specify -1 as the argument.
Multiple Arguments: No

Normally, if ESLint runs and finds no errors (only warnings), it exits with a success exit status. However, if --max-warnings is specified and the total warning count is greater than the specified threshold, ESLint exits with an error status.

                    
                    
                        Important
                        When used alongside --quiet, this will cause rules marked as warn to still be run, but not reported.

                    
                --max-warnings example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --max-warnings 10 file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --max-warnings 10 file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --max-warnings 10 file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --max-warnings 10 file.js 
1
    
        Copy code to clipboard
        
    

   

Output
-o, --output-file
Write the output of linting results to a specified file.

Argument Type: String. Path to file.
Multiple Arguments: No

-o, --output-file example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint -o ./test/test.html 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint -o ./test/test.html 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint -o ./test/test.html 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint -o ./test/test.html 
1
    
        Copy code to clipboard
        
    

   

-f, --format
This option specifies the output format for the console.

Argument Type: String. One of the built-in formatters or a custom formatter.
Multiple Arguments: No
Default Value: stylish

If you are using a custom formatter defined in a local file, you can specify the path to the custom formatter file.
An npm-installed formatter is resolved with or without eslint-formatter- prefix.
When specified, the given format is output to the console. If you’d like to save that output into a file, you can do so on the command line like so:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    # Saves the output into the `results.json` file.
npx eslint -f json file.js > results.json 
12
    
        Copy code to clipboard
        
    

   
   
      yarn


    # Saves the output into the `results.json` file.
yarn dlx eslint -f json file.js > results.json 
12
    
        Copy code to clipboard
        
    

   
   
      pnpm


    # Saves the output into the `results.json` file.
pnpm dlx eslint -f json file.js > results.json 
12
    
        Copy code to clipboard
        
    

   
   
      bun


    # Saves the output into the `results.json` file.
bunx eslint -f json file.js > results.json 
12
    
        Copy code to clipboard
        
    

   

-f, --format example
Use the built-in json formatter:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --format json file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --format json file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --format json file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --format json file.js 
1
    
        Copy code to clipboard
        
    

   

Use a local custom formatter:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint -f ./customformat.js file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint -f ./customformat.js file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint -f ./customformat.js file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint -f ./customformat.js file.js 
1
    
        Copy code to clipboard
        
    

   

Use an npm-installed formatter:

   
      npm
      yarn
      pnpm
      bun
   
    
        npm


    npm install eslint-formatter-pretty
1
    
        Copy code to clipboard
        
    


   
      yarn


    yarn add eslint-formatter-pretty
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm add eslint-formatter-pretty
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bun add eslint-formatter-pretty
1
    
        Copy code to clipboard
        
    

   

Then run one of the following commands

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint -f pretty file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint -f pretty file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint -f pretty file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint -f pretty file.js 
1
    
        Copy code to clipboard
        
    

   

or alternatively

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint -f eslint-formatter-pretty file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint -f eslint-formatter-pretty file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint -f eslint-formatter-pretty file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint -f eslint-formatter-pretty file.js 
1
    
        Copy code to clipboard
        
    

   

--color and --no-color
These options force the enabling/disabling of colorized output.

Argument Type: No argument.

You can use these options to override the default behavior, which is to enable colorized output unless no TTY is detected, such as when piping eslint through cat or less.
--color and --no-color example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --color file.js | cat 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --color file.js | cat 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --color file.js | cat 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --color file.js | cat 
1
    
        Copy code to clipboard
        
    

   


   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --no-color file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --no-color file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --no-color file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --no-color file.js 
1
    
        Copy code to clipboard
        
    

   

Inline Configuration Comments
--no-inline-config
This option prevents inline comments like /*eslint-disable*/ or
/*global foo*/ from having any effect.

Argument Type: No argument.

This allows you to set an ESLint config without files modifying it. All inline config comments are ignored, such as:

/*eslint-disable*/
/*eslint-enable*/
/*global*/
/*eslint*/
/*eslint-env*/
// eslint-disable-line
// eslint-disable-next-line

--no-inline-config example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --no-inline-config file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --no-inline-config file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --no-inline-config file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --no-inline-config file.js 
1
    
        Copy code to clipboard
        
    

   

--report-unused-disable-directives
This option causes ESLint to report directive comments like // eslint-disable-line when no errors would have been reported on that line anyway.

Argument Type: No argument.

This can be useful to prevent future errors from unexpectedly being suppressed, by cleaning up old eslint-disable and eslint-enable comments which are no longer applicable.

                    
                    
                        Warning
                        When using this option, it is possible that new errors start being reported whenever ESLint or custom rules are upgraded.
For example, suppose a rule has a bug that causes it to report a false positive, and an eslint-disable comment is added to suppress the incorrect report. If the bug is then fixed in a patch release of ESLint, the eslint-disable comment becomes unused since ESLint is no longer generating an incorrect report. This results in a new reported error for the unused directive if the --report-unused-disable-directives option is used.

                    
                --report-unused-disable-directives example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --report-unused-disable-directives file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --report-unused-disable-directives file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --report-unused-disable-directives file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --report-unused-disable-directives file.js 
1
    
        Copy code to clipboard
        
    

   

--report-unused-disable-directives-severity
Same as --report-unused-disable-directives, but allows you to specify the severity level (error, warn, off) of the reported errors. Only one of these two options can be used at a time.

Argument Type: String. One of the following values:

off (or 0)
warn (or 1)
error (or 2)


Multiple Arguments: No
Default Value: By default, linterOptions.reportUnusedDisableDirectives configuration setting is used (which defaults to "warn").

--report-unused-disable-directives-severity example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --report-unused-disable-directives-severity warn file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --report-unused-disable-directives-severity warn file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --report-unused-disable-directives-severity warn file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --report-unused-disable-directives-severity warn file.js 
1
    
        Copy code to clipboard
        
    

   

--report-unused-inline-configs
This option causes ESLint to report inline config comments like /* eslint rule-name: "error" */ whose rule severity and any options match what’s already been configured.

Argument Type: String. One of the following values:

off (or 0)
warn (or 1)
error (or 2)


Multiple Arguments: No
Default Value: By default, linterOptions.reportUnusedInlineConfigs configuration setting is used (which defaults to "off").

This can be useful to keep files clean and devoid of misleading clutter.
Inline config comments are meant to change ESLint’s behavior in some way: if they change nothing, there is no reason to leave them in.
--report-unused-inline-configs example


    npx eslint --report-unused-inline-configs error file.js
1
    
        Copy code to clipboard
        
    

Caching
--cache
Store the info about processed files in order to only operate on the changed ones. Enabling this option can dramatically improve ESLint’s run time performance by ensuring that only changed files are linted.
The cache is stored in .eslintcache by default.

Argument Type: No argument.

If you run ESLint with --cache and then run ESLint without --cache, the .eslintcache file will be deleted. This is necessary because the results of the lint might change and make .eslintcache invalid. If you want to control when the cache file is deleted, then use --cache-location to specify an alternate location for the cache file.
Autofixed files are not placed in the cache. Subsequent linting that does not trigger an autofix will place it in the cache.
--cache example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --cache file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --cache file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --cache file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --cache file.js 
1
    
        Copy code to clipboard
        
    

   

--cache-file
Deprecated: Use --cache-location instead.
Path to the cache file. If none specified .eslintcache is used. The file is created in the directory where the eslint command is executed.
--cache-location
Specify the path to the cache location. Can be a file or a directory.

Argument Type: String. Path to file or directory. If a directory is specified, a cache file is created inside the specified folder. The name of the file is based on the hash of the current working directory, e.g.: .cache_hashOfCWD.
Multiple Arguments: No
Default Value: If no location is specified, .eslintcache is used. The file is created in the directory where the eslint command is executed.

If the directory for the cache does not exist make sure you add a trailing / on *nix systems or \ on Windows. Otherwise, the path is assumed to be a file.
--cache-location example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint "src/**/*.js" --cache --cache-location "/Users/user/.eslintcache/" 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint "src/**/*.js" --cache --cache-location "/Users/user/.eslintcache/" 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint "src/**/*.js" --cache --cache-location "/Users/user/.eslintcache/" 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint "src/**/*.js" --cache --cache-location "/Users/user/.eslintcache/" 
1
    
        Copy code to clipboard
        
    

   

--cache-strategy
Strategy for the cache to use for detecting changed files.

Argument Type: String. One of the following values:

metadata
content


Multiple Arguments: No
Default Value: metadata

The content strategy can be useful in cases where the modification time of your files changes even if their contents have not. For example, this can happen during git operations like git clone because git does not track file modification time.
--cache-strategy example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint "src/**/*.js" --cache --cache-strategy content 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint "src/**/*.js" --cache --cache-strategy content 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint "src/**/*.js" --cache --cache-strategy content 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint "src/**/*.js" --cache --cache-strategy content 
1
    
        Copy code to clipboard
        
    

   

Suppressing Violations
--suppress-all
Suppresses existing violations, so that they are not being reported in subsequent runs. It allows you to enable one or more lint rules and be notified only when new violations show up. The suppressions are stored in eslint-suppressions.json by default, unless otherwise specified by --suppressions-location. The file gets updated with the new suppressions.

Argument Type: No argument.

--suppress-all example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint "src/**/*.js" --suppress-all 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint "src/**/*.js" --suppress-all 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint "src/**/*.js" --suppress-all 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint "src/**/*.js" --suppress-all 
1
    
        Copy code to clipboard
        
    

   

--suppress-rule
Suppresses violations for specific rules, so that they are not being reported in subsequent runs. Similar to --suppress-all, the suppressions are stored in eslint-suppressions.json by default, unless otherwise specified by --suppressions-location. The file gets updated with the new suppressions.

Argument Type: String. Rule ID.
Multiple Arguments: Yes

--suppress-rule example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint "src/**/*.js" --suppress-rule no-console --suppress-rule indent 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint "src/**/*.js" --suppress-rule no-console --suppress-rule indent 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint "src/**/*.js" --suppress-rule no-console --suppress-rule indent 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint "src/**/*.js" --suppress-rule no-console --suppress-rule indent 
1
    
        Copy code to clipboard
        
    

   

--suppressions-location
Specify the path to the suppressions location. Can be a file or a directory.

Argument Type: String. Path to file. If a directory is specified, a cache file is created inside the specified folder. The name of the file is based on the hash of the current working directory, e.g.: suppressions_hashOfCWD
Multiple Arguments: No
Default Value: If no location is specified, eslint-suppressions.json is used. The file is created in the directory where the eslint command is executed.

--suppressions-location example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint "src/**/*.js" --suppressions-location ".eslint-suppressions-example.json" 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint "src/**/*.js" --suppressions-location ".eslint-suppressions-example.json" 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint "src/**/*.js" --suppressions-location ".eslint-suppressions-example.json" 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint "src/**/*.js" --suppressions-location ".eslint-suppressions-example.json" 
1
    
        Copy code to clipboard
        
    

   

--prune-suppressions
Prune unused suppressions from the suppressions file. This option is useful when you addressed one or more of the suppressed violations.

Argument Type: No argument.

--prune-suppressions example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint "src/**/*.js" --prune-suppressions 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint "src/**/*.js" --prune-suppressions 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint "src/**/*.js" --prune-suppressions 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint "src/**/*.js" --prune-suppressions 
1
    
        Copy code to clipboard
        
    

   

Miscellaneous
--init
This option runs npm init @eslint/config to start the config initialization wizard. It’s designed to help new users quickly create an .eslintrc file by answering a few questions. When you use this flag, the CLI does not perform linting.

Argument Type: No argument.

The resulting configuration file is created in the current directory.
--init example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --init 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --init 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --init 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --init 
1
    
        Copy code to clipboard
        
    

   

--env-info
This option outputs information about the execution environment, including the version of Node.js, npm, and local and global installations of ESLint.

Argument Type: No argument.

The ESLint team may ask for this information to help solve bugs. When you use this flag, the CLI does not perform linting.
--env-info example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --env-info 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --env-info 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --env-info 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --env-info 
1
    
        Copy code to clipboard
        
    

   

--no-error-on-unmatched-pattern
This option prevents errors when a quoted glob pattern or --ext is unmatched. This does not prevent errors when your shell can’t match a glob.

Argument Type: No argument.

--no-error-on-unmatched-pattern example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --no-error-on-unmatched-pattern --ext .ts "lib/*" 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --no-error-on-unmatched-pattern --ext .ts "lib/*" 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --no-error-on-unmatched-pattern --ext .ts "lib/*" 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --no-error-on-unmatched-pattern --ext .ts "lib/*" 
1
    
        Copy code to clipboard
        
    

   

--exit-on-fatal-error
This option causes ESLint to exit with exit code 2 if one or more fatal parsing errors occur. Without this option, ESLint reports fatal parsing errors as rule violations.

Argument Type: No argument.

--exit-on-fatal-error example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --exit-on-fatal-error file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --exit-on-fatal-error file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --exit-on-fatal-error file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --exit-on-fatal-error file.js 
1
    
        Copy code to clipboard
        
    

   

--no-warn-ignored
Flat Config Mode Only. This option suppresses both File ignored by default and File ignored because of a matching ignore pattern warnings when an ignored filename is passed explicitly. It is useful when paired with --max-warnings 0 as it will prevent exit code 1 due to the aforementioned warning.

Argument Type: No argument.

--no-warn-ignored example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --no-warn-ignored --max-warnings 0 ignored-file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --no-warn-ignored --max-warnings 0 ignored-file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --no-warn-ignored --max-warnings 0 ignored-file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --no-warn-ignored --max-warnings 0 ignored-file.js 
1
    
        Copy code to clipboard
        
    

   

--pass-on-no-patterns
This option allows ESLint to exit with code 0 when no file or directory patterns are passed. Without this option, ESLint assumes you want to use . as the pattern. (When running in legacy eslintrc mode, ESLint will exit with code 1.)

Argument Type: No argument.

--pass-on-no-patterns example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --pass-on-no-patterns 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --pass-on-no-patterns 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --pass-on-no-patterns 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --pass-on-no-patterns 
1
    
        Copy code to clipboard
        
    

   

--debug
This option outputs debugging information to the console. Add this flag to an ESLint command line invocation in order to get extra debugging information while the command runs.

Argument Type: No argument.

This information is useful when you’re seeing a problem and having a hard time pinpointing it. The ESLint team may ask for this debugging information to help solve bugs.
--debug example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --debug test.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --debug test.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --debug test.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --debug test.js 
1
    
        Copy code to clipboard
        
    

   

-h, --help
This option outputs the help menu, displaying all of the available options. All other options are ignored when this is present. When you use this flag, the CLI does not perform linting.

Argument Type: No argument.

-h, --help example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --help 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --help 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --help 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --help 
1
    
        Copy code to clipboard
        
    

   

-v, --version
This option outputs the current ESLint version onto the console. All other options are ignored when this is present. When you use this flag, the CLI does not perform linting.

Argument Type: No argument.

-v, --version example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --version 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --version 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --version 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --version 
1
    
        Copy code to clipboard
        
    

   

--print-config
This option outputs the configuration to be used for the file passed. When present, no linting is performed and only config-related options are valid. When you use this flag, the CLI does not perform linting.

Argument Type: String. Path to file.
Multiple Arguments: No

--print-config example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --print-config file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --print-config file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --print-config file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --print-config file.js 
1
    
        Copy code to clipboard
        
    

   

--stats
This option adds a series of detailed performance statistics (see Stats type) such as the parse-, fix- and lint-times (time per rule) to result objects that are passed to the formatter (see Stats CLI usage).

Argument Type: No argument.

This option is intended for use with custom formatters that display statistics. It can also be used with the built-in json formatter.
--stats example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --stats --format json file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --stats --format json file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --stats --format json file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --stats --format json file.js 
1
    
        Copy code to clipboard
        
    

   

--flag
This option enables one or more feature flags for ESLint.

Argument Type: String. A feature identifier.
Multiple Arguments: Yes

--flag example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --flag x_feature file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --flag x_feature file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --flag x_feature file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --flag x_feature file.js 
1
    
        Copy code to clipboard
        
    

   

Exit Codes
When linting files, ESLint exits with one of the following exit codes:

0: Linting was successful and there are no linting errors. If the --max-warnings flag is set to n, the number of linting warnings is at most n.
1: Linting was successful and there is at least one linting error, or there are more linting warnings than allowed by the --max-warnings option.
2: Linting was unsuccessful due to a configuration problem or an internal error.


            

            
                Edit this page\n\nCommand Line Interface Reference
                

                Table of Contents
    
        
                
                    
                    Run the CLI
            		

                    Pass Multiple Values to an Option
            		

                    Options
            
                
                    
                    Basic Configuration
            
                
                    
                    --no-eslintrc
            		

                    -c, --config
            		

                    --inspect-config
            		

                    --env
            		

                    --ext
            		

                    --global
            		

                    --parser
            		

                    --parser-options
            		

                    --resolve-plugins-relative-to
            		
                
            		

                    Specify Rules and Plugins
            
                
                    
                    --plugin
            		

                    --rule
            		

                    --rulesdir
            		
                
            		

                    Fix Problems
            
                
                    
                    --fix
            		

                    --fix-dry-run
            		

                    --fix-type
            		
                
            		

                    Ignore Files
            
                
                    
                    --ignore-path
            		

                    --no-ignore
            		

                    --ignore-pattern
            		
                
            		

                    Use stdin
            
                
                    
                    --stdin
            		

                    --stdin-filename
            		
                
            		

                    Handle Warnings
            
                
                    
                    --quiet
            		

                    --max-warnings
            		
                
            		

                    Output
            
                
                    
                    -o, --output-file
            		

                    -f, --format
            		

                    --color and --no-color
            		
                
            		

                    Inline Configuration Comments
            
                
                    
                    --no-inline-config
            		

                    --report-unused-disable-directives
            		

                    --report-unused-disable-directives-severity
            		

                    --report-unused-inline-configs
            		
                
            		

                    Caching
            
                
                    
                    --cache
            		

                    --cache-file
            		

                    --cache-location
            		

                    --cache-strategy
            		
                
            		

                    Suppressing Violations
            
                
                    
                    --suppress-all
            		

                    --suppress-rule
            		

                    --suppressions-location
            		

                    --prune-suppressions
            		
                
            		

                    Miscellaneous
            
                
                    
                    --init
            		

                    --env-info
            		

                    --no-error-on-unmatched-pattern
            		

                    --exit-on-fatal-error
            		

                    --no-warn-ignored
            		

                    --pass-on-no-patterns
            		

                    --debug
            		

                    -h, --help
            		

                    -v, --version
            		

                    --print-config
            		

                    --stats
            		

                    --flag
            		
                
            		
                
            		

                    Exit Codes
            		
                
            
    


                The ESLint Command Line Interface (CLI) lets you execute linting from the terminal. The CLI has a variety of options that you can pass to configure ESLint.
Run the CLI
ESLint requires Node.js for installation. Follow the instructions in the Getting Started Guide to install ESLint.
Most users use npx to run ESLint on the command line like this:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint [options] [file|dir|glob]* 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint [options] [file|dir|glob]* 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint [options] [file|dir|glob]* 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint [options] [file|dir|glob]* 
1
    
        Copy code to clipboard
        
    

   

Such as:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    # Run on two files
npx eslint file1.js file2.js 
12
    
        Copy code to clipboard
        
    

   
   
      yarn


    # Run on two files
yarn dlx eslint file1.js file2.js 
12
    
        Copy code to clipboard
        
    

   
   
      pnpm


    # Run on two files
pnpm dlx eslint file1.js file2.js 
12
    
        Copy code to clipboard
        
    

   
   
      bun


    # Run on two files
bunx eslint file1.js file2.js 
12
    
        Copy code to clipboard
        
    

   

or

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    # Run on multiple files
npx eslint lib/** 
12
    
        Copy code to clipboard
        
    

   
   
      yarn


    # Run on multiple files
yarn dlx eslint lib/** 
12
    
        Copy code to clipboard
        
    

   
   
      pnpm


    # Run on multiple files
pnpm dlx eslint lib/** 
12
    
        Copy code to clipboard
        
    

   
   
      bun


    # Run on multiple files
bunx eslint lib/** 
12
    
        Copy code to clipboard
        
    

   

Please note that when passing a glob as a parameter, it is expanded by your shell. The results of the expansion can vary depending on your shell, and its configuration. If you want to use node glob syntax, you have to quote your parameter (using double quotes if you need it to run in Windows), as follows:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint "lib/**" 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint "lib/**" 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint "lib/**" 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint "lib/**" 
1
    
        Copy code to clipboard
        
    

   

If you are using a flat configuration file (eslint.config.js), you can also omit the file arguments and ESLint will use .. For instance, these two lines perform the same operation:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint . 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint . 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint . 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint . 
1
    
        Copy code to clipboard
        
    

   


   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint 
1
    
        Copy code to clipboard
        
    

   

If you are not using a flat configuration file, running ESLint without file arguments results in an error.
Note: You can also use alternative package managers such as Yarn or pnpm to run ESLint. For pnpm use pnpm dlx eslint and for Yarn use yarn dlx eslint.
Pass Multiple Values to an Option
Options that accept multiple values can be specified by repeating the option or with a comma-delimited list (other than --ignore-pattern, which does not allow the second style).
Examples of options that accept multiple values:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --global describe --global it tests/ 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --global describe --global it tests/ 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --global describe --global it tests/ 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --global describe --global it tests/ 
1
    
        Copy code to clipboard
        
    

   

OR

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --global describe,it tests/ 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --global describe,it tests/ 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --global describe,it tests/ 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --global describe,it tests/ 
1
    
        Copy code to clipboard
        
    

   

Options
You can view all the CLI options by running npx eslint -h.


    eslint [options] file.js [file.js] [dir]

Basic configuration:
  --no-config-lookup              Disable look up for eslint.config.js
  -c, --config path::String       Use this configuration instead of eslint.config.js, eslint.config.mjs, or
                                  eslint.config.cjs
  --inspect-config                Open the config inspector with the current configuration
  --ext [String]                  Specify additional file extensions to lint
  --global [String]               Define global variables
  --parser String                 Specify the parser to be used
  --parser-options Object         Specify parser options

Specify Rules and Plugins:
  --plugin [String]               Specify plugins
  --rule Object                   Specify rules

Fix Problems:
  --fix                           Automatically fix problems
  --fix-dry-run                   Automatically fix problems without saving the changes to the file system
  --fix-type Array                Specify the types of fixes to apply (directive, problem, suggestion, layout)

Ignore Files:
  --no-ignore                     Disable use of ignore files and patterns
  --ignore-pattern [String]       Patterns of files to ignore

Use stdin:
  --stdin                         Lint code provided on <STDIN> - default: false
  --stdin-filename String         Specify filename to process STDIN as

Handle Warnings:
  --quiet                         Report errors only - default: false
  --max-warnings Int              Number of warnings to trigger nonzero exit code - default: -1

Output:
  -o, --output-file path::String  Specify file to write report to
  -f, --format String             Use a specific output format - default: stylish
  --color, --no-color             Force enabling/disabling of color

Inline configuration comments:
  --no-inline-config              Prevent comments from changing config or rules
  --report-unused-disable-directives  Adds reported errors for unused eslint-disable and eslint-enable directives
  --report-unused-disable-directives-severity String  Chooses severity level for reporting unused eslint-disable and
                                                      eslint-enable directives - either: off, warn, error, 0, 1, or 2
  --report-unused-inline-configs String  Adds reported errors for unused eslint inline config comments - either: off, warn, error, 0, 1, or 2

Caching:
  --cache                         Only check changed files - default: false
  --cache-file path::String       Path to the cache file. Deprecated: use --cache-location - default: .eslintcache
  --cache-location path::String   Path to the cache file or directory
  --cache-strategy String         Strategy to use for detecting changed files in the cache - either: metadata or
                                  content - default: metadata

Suppressing Violations:
  --suppress-all                  Suppress all violations - default: false
  --suppress-rule [String]        Suppress specific rules
  --suppressions-location path::String  Specify the location of the suppressions file
  --prune-suppressions            Prune unused suppressions - default: false

Miscellaneous:
  --init                          Run config initialization wizard - default: false
  --env-info                      Output execution environment information - default: false
  --no-error-on-unmatched-pattern  Prevent errors when pattern is unmatched
  --exit-on-fatal-error           Exit with exit code 2 in case of fatal error - default: false
  --no-warn-ignored               Suppress warnings when the file list includes ignored files
  --pass-on-no-patterns           Exit with exit code 0 in case no file patterns are passed
  --debug                         Output debugging information
  -h, --help                      Show help
  -v, --version                   Output the version number
  --print-config path::String     Print the configuration for the given file
  --stats                         Add statistics to the lint report - default: false
  --flag [String]                 Enable a feature flag
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071
    
        Copy code to clipboard
        
    

Basic Configuration
--no-eslintrc
eslintrc Mode Only. Disables use of configuration from .eslintrc.* and package.json files. For flat config mode, use --no-config-lookup instead.

Argument Type: No argument.

--no-eslintrc example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --no-eslintrc file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --no-eslintrc file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --no-eslintrc file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --no-eslintrc file.js 
1
    
        Copy code to clipboard
        
    

   

-c, --config
This option allows you to specify an additional configuration file for ESLint (see Configure ESLint for more).

Argument Type: String. Path to file.
Multiple Arguments: No

-c, --config example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint -c ~/my.eslint.config.js file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint -c ~/my.eslint.config.js file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint -c ~/my.eslint.config.js file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint -c ~/my.eslint.config.js file.js 
1
    
        Copy code to clipboard
        
    

   

This example uses the configuration file at ~/my.eslint.config.js, which is used instead of searching for an eslint.config.js file.
--inspect-config
Flat Config Mode Only. This option runs npx @eslint/config-inspector@latest to start the config inspector. You can use the config inspector to better understand what your configuration is doing and which files it applies to. When you use this flag, the CLI does not perform linting.

Argument Type: No argument.

--inspect-config example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --inspect-config 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --inspect-config 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --inspect-config 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --inspect-config 
1
    
        Copy code to clipboard
        
    

   

--env
eslintrc Mode Only. This option enables specific environments.

Argument Type: String. One of the available environments.
Multiple Arguments: Yes

Details about the global variables defined by each environment are available in the Specifying Environments documentation. This option only enables environments. It does not disable environments set in other configuration files. To specify multiple environments, separate them using commas, or use the option multiple times.
--env example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --env browser,node file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --env browser,node file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --env browser,node file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --env browser,node file.js 
1
    
        Copy code to clipboard
        
    

   


   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --env browser --env node file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --env browser --env node file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --env browser --env node file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --env browser --env node file.js 
1
    
        Copy code to clipboard
        
    

   

--ext
This option allows you to specify additional file extensions to lint.

Argument Type: String. File extension.
Multiple Arguments: Yes
Default Value: By default, ESLint lints files with extensions .js, .mjs, .cjs, and additional extensions specified in the configuration file.

This option is primarily intended for use in combination with the --no-config-lookup option, since in that case there is no configuration file in which the additional extensions would be specified.
--ext example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    # Include .ts files
npx eslint . --ext .ts 
12
    
        Copy code to clipboard
        
    

   
   
      yarn


    # Include .ts files
yarn dlx eslint . --ext .ts 
12
    
        Copy code to clipboard
        
    

   
   
      pnpm


    # Include .ts files
pnpm dlx eslint . --ext .ts 
12
    
        Copy code to clipboard
        
    

   
   
      bun


    # Include .ts files
bunx eslint . --ext .ts 
12
    
        Copy code to clipboard
        
    

   


   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    # Include .ts and .tsx files
npx eslint . --ext .ts --ext .tsx 
12
    
        Copy code to clipboard
        
    

   
   
      yarn


    # Include .ts and .tsx files
yarn dlx eslint . --ext .ts --ext .tsx 
12
    
        Copy code to clipboard
        
    

   
   
      pnpm


    # Include .ts and .tsx files
pnpm dlx eslint . --ext .ts --ext .tsx 
12
    
        Copy code to clipboard
        
    

   
   
      bun


    # Include .ts and .tsx files
bunx eslint . --ext .ts --ext .tsx 
12
    
        Copy code to clipboard
        
    

   


   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    # Also include .ts and .tsx files
npx eslint . --ext .ts,.tsx 
12
    
        Copy code to clipboard
        
    

   
   
      yarn


    # Also include .ts and .tsx files
yarn dlx eslint . --ext .ts,.tsx 
12
    
        Copy code to clipboard
        
    

   
   
      pnpm


    # Also include .ts and .tsx files
pnpm dlx eslint . --ext .ts,.tsx 
12
    
        Copy code to clipboard
        
    

   
   
      bun


    # Also include .ts and .tsx files
bunx eslint . --ext .ts,.tsx 
12
    
        Copy code to clipboard
        
    

   

--global
This option defines global variables so that they are not flagged as undefined by the no-undef rule.

Argument Type: String. Name of the global variable. Any specified global variables are assumed to be read-only by default, but appending :true to a variable’s name ensures that no-undef also allows writes.
Multiple Arguments: Yes

--global example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --global require,exports:true file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --global require,exports:true file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --global require,exports:true file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --global require,exports:true file.js 
1
    
        Copy code to clipboard
        
    

   


   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --global require --global exports:true 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --global require --global exports:true 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --global require --global exports:true 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --global require --global exports:true 
1
    
        Copy code to clipboard
        
    

   

--parser
This option allows you to specify a parser to be used by ESLint.

Argument Type: String. Parser to be used by ESLint.
Multiple Arguments: No
Default Value: espree

--parser example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    # Use TypeScript ESLint parser
npx eslint --parser @typescript-eslint/parser file.ts 
12
    
        Copy code to clipboard
        
    

   
   
      yarn


    # Use TypeScript ESLint parser
yarn dlx eslint --parser @typescript-eslint/parser file.ts 
12
    
        Copy code to clipboard
        
    

   
   
      pnpm


    # Use TypeScript ESLint parser
pnpm dlx eslint --parser @typescript-eslint/parser file.ts 
12
    
        Copy code to clipboard
        
    

   
   
      bun


    # Use TypeScript ESLint parser
bunx eslint --parser @typescript-eslint/parser file.ts 
12
    
        Copy code to clipboard
        
    

   

--parser-options
This option allows you to specify parser options to be used by ESLint. The available parser options are determined by the parser being used.

Argument Type: Key/value pair separated by colon (:).
Multiple Arguments: Yes

--parser-options example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    # fails with a parsing error
echo '3 ** 4' | npx eslint --stdin --parser-options ecmaVersion:6 
12
    
        Copy code to clipboard
        
    

   
   
      yarn


    # fails with a parsing error
echo '3 ** 4' | yarn dlx eslint --stdin --parser-options ecmaVersion:6 
12
    
        Copy code to clipboard
        
    

   
   
      pnpm


    # fails with a parsing error
echo '3 ** 4' | pnpm dlx eslint --stdin --parser-options ecmaVersion:6 
12
    
        Copy code to clipboard
        
    

   
   
      bun


    # fails with a parsing error
echo '3 ** 4' | bunx eslint --stdin --parser-options ecmaVersion:6 
12
    
        Copy code to clipboard
        
    

   


   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    # succeeds, yay!
echo '3 ** 4' | npx eslint --stdin --parser-options ecmaVersion:7 
12
    
        Copy code to clipboard
        
    

   
   
      yarn


    # succeeds, yay!
echo '3 ** 4' | yarn dlx eslint --stdin --parser-options ecmaVersion:7 
12
    
        Copy code to clipboard
        
    

   
   
      pnpm


    # succeeds, yay!
echo '3 ** 4' | pnpm dlx eslint --stdin --parser-options ecmaVersion:7 
12
    
        Copy code to clipboard
        
    

   
   
      bun


    # succeeds, yay!
echo '3 ** 4' | bunx eslint --stdin --parser-options ecmaVersion:7 
12
    
        Copy code to clipboard
        
    

   

--resolve-plugins-relative-to
eslintrc Mode Only. Changes the directory where plugins are resolved from.

Argument Type: String. Path to directory.
Multiple Arguments: No
Default Value: By default, plugins are resolved from the directory in which your configuration file is found.

This option should be used when plugins were installed by someone other than the end user. It should be set to the project directory of the project that has a dependency on the necessary plugins.
For example:

When using a config file that is located outside of the current project (with the --config flag), if the config uses plugins which are installed locally to itself, --resolve-plugins-relative-to should be set to the directory containing the config file.
If an integration has dependencies on ESLint and a set of plugins, and the tool invokes ESLint on behalf of the user with a preset configuration, the tool should set --resolve-plugins-relative-to to the top-level directory of the tool.

--resolve-plugins-relative-to example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --config ~/personal-eslintrc.js --resolve-plugins-relative-to /usr/local/lib/ 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --config ~/personal-eslintrc.js --resolve-plugins-relative-to /usr/local/lib/ 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --config ~/personal-eslintrc.js --resolve-plugins-relative-to /usr/local/lib/ 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --config ~/personal-eslintrc.js --resolve-plugins-relative-to /usr/local/lib/ 
1
    
        Copy code to clipboard
        
    

   

Specify Rules and Plugins
--plugin
This option specifies a plugin to load.

Argument Type: String. Plugin name. You can optionally omit the prefix eslint-plugin- from the plugin name.
Multiple Arguments: Yes

Before using the plugin, you have to install it using npm.
--plugin example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --plugin jquery file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --plugin jquery file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --plugin jquery file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --plugin jquery file.js 
1
    
        Copy code to clipboard
        
    

   


   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --plugin eslint-plugin-mocha file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --plugin eslint-plugin-mocha file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --plugin eslint-plugin-mocha file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --plugin eslint-plugin-mocha file.js 
1
    
        Copy code to clipboard
        
    

   

--rule
This option specifies the rules to be used.

Argument Type: Rules and their configuration specified with levn format.
Multiple Arguments: Yes

These rules are merged with any rules specified with configuration files. If the rule is defined in a plugin, you have to prefix the rule ID with the plugin name and a /.
To ignore rules in .eslintrc configuration files and only run rules specified in the command line, use the --rule flag in combination with the --no-eslintrc flag.
--rule example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    # Apply single rule
npx eslint --rule 'quotes: [error, double]' 
12
    
        Copy code to clipboard
        
    

   
   
      yarn


    # Apply single rule
yarn dlx eslint --rule 'quotes: [error, double]' 
12
    
        Copy code to clipboard
        
    

   
   
      pnpm


    # Apply single rule
pnpm dlx eslint --rule 'quotes: [error, double]' 
12
    
        Copy code to clipboard
        
    

   
   
      bun


    # Apply single rule
bunx eslint --rule 'quotes: [error, double]' 
12
    
        Copy code to clipboard
        
    

   


   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    # Apply multiple rules
npx eslint --rule 'guard-for-in: error' --rule 'brace-style: [error, 1tbs]' 
12
    
        Copy code to clipboard
        
    

   
   
      yarn


    # Apply multiple rules
yarn dlx eslint --rule 'guard-for-in: error' --rule 'brace-style: [error, 1tbs]' 
12
    
        Copy code to clipboard
        
    

   
   
      pnpm


    # Apply multiple rules
pnpm dlx eslint --rule 'guard-for-in: error' --rule 'brace-style: [error, 1tbs]' 
12
    
        Copy code to clipboard
        
    

   
   
      bun


    # Apply multiple rules
bunx eslint --rule 'guard-for-in: error' --rule 'brace-style: [error, 1tbs]' 
12
    
        Copy code to clipboard
        
    

   


   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    # Apply rule from jquery plugin
npx eslint --rule 'jquery/dollar-sign: error' 
12
    
        Copy code to clipboard
        
    

   
   
      yarn


    # Apply rule from jquery plugin
yarn dlx eslint --rule 'jquery/dollar-sign: error' 
12
    
        Copy code to clipboard
        
    

   
   
      pnpm


    # Apply rule from jquery plugin
pnpm dlx eslint --rule 'jquery/dollar-sign: error' 
12
    
        Copy code to clipboard
        
    

   
   
      bun


    # Apply rule from jquery plugin
bunx eslint --rule 'jquery/dollar-sign: error' 
12
    
        Copy code to clipboard
        
    

   


   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    # Only apply rule from the command line
npx eslint --rule 'quotes: [error, double]' --no-eslintrc 
12
    
        Copy code to clipboard
        
    

   
   
      yarn


    # Only apply rule from the command line
yarn dlx eslint --rule 'quotes: [error, double]' --no-eslintrc 
12
    
        Copy code to clipboard
        
    

   
   
      pnpm


    # Only apply rule from the command line
pnpm dlx eslint --rule 'quotes: [error, double]' --no-eslintrc 
12
    
        Copy code to clipboard
        
    

   
   
      bun


    # Only apply rule from the command line
bunx eslint --rule 'quotes: [error, double]' --no-eslintrc 
12
    
        Copy code to clipboard
        
    

   

--rulesdir
Deprecated: Use rules from plugins instead.
eslintrc Mode Only. This option allows you to specify another directory from which to load rules files. This allows you to dynamically load new rules at run time. This is useful when you have custom rules that aren’t suitable for being bundled with ESLint.

Argument Type: String. Path to directory. The rules in your custom rules directory must follow the same format as bundled rules to work properly.
Multiple Arguments: Yes

Note that, as with core rules and plugin rules, you still need to enable the rules in configuration or via the --rule CLI option in order to actually run those rules during linting. Specifying a rules directory with --rulesdir does not automatically enable the rules within that directory.
--rulesdir example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --rulesdir my-rules/ file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --rulesdir my-rules/ file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --rulesdir my-rules/ file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --rulesdir my-rules/ file.js 
1
    
        Copy code to clipboard
        
    

   


   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --rulesdir my-rules/ --rulesdir my-other-rules/ file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --rulesdir my-rules/ --rulesdir my-other-rules/ file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --rulesdir my-rules/ --rulesdir my-other-rules/ file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --rulesdir my-rules/ --rulesdir my-other-rules/ file.js 
1
    
        Copy code to clipboard
        
    

   

Fix Problems
--fix
This option instructs ESLint to try to fix as many issues as possible. The fixes are made to the actual files themselves and only the remaining unfixed issues are output.

Argument Type: No argument.

Not all problems are fixable using this option, and the option does not work in these situations:

This option throws an error when code is piped to ESLint.
This option has no effect on code that uses a processor, unless the processor opts into allowing autofixes.

If you want to fix code from stdin or otherwise want to get the fixes without actually writing them to the file, use the --fix-dry-run option.
--fix example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --fix file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --fix file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --fix file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --fix file.js 
1
    
        Copy code to clipboard
        
    

   

--fix-dry-run
This option has the same effect as --fix with the difference that the fixes are not saved to the file system. Because the default formatter does not output the fixed code, you’ll have to use another formatter (e.g. --format json) to get the fixes.

Argument Type: No argument.

This makes it possible to fix code from stdin when used with the --stdin flag.
This flag can be useful for integrations (e.g. editor plugins) which need to autofix text from the command line without saving it to the filesystem.
--fix-dry-run example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    getSomeText | npx eslint --stdin --fix-dry-run --format json 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    getSomeText | yarn dlx eslint --stdin --fix-dry-run --format json 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    getSomeText | pnpm dlx eslint --stdin --fix-dry-run --format json 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    getSomeText | bunx eslint --stdin --fix-dry-run --format json 
1
    
        Copy code to clipboard
        
    

   

--fix-type
This option allows you to specify the type of fixes to apply when using either --fix or --fix-dry-run.

Argument Type: String. One of the following fix types:

problem - fix potential errors in the code
suggestion - apply fixes to the code that improve it
layout - apply fixes that do not change the program structure (AST)
directive - apply fixes to inline directives such as // eslint-disable


Multiple Arguments: Yes

This option is helpful if you are using another program to format your code, but you would still like ESLint to apply other types of fixes.
--fix-type example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --fix --fix-type suggestion . 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --fix --fix-type suggestion . 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --fix --fix-type suggestion . 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --fix --fix-type suggestion . 
1
    
        Copy code to clipboard
        
    

   


   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --fix --fix-type suggestion --fix-type problem . 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --fix --fix-type suggestion --fix-type problem . 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --fix --fix-type suggestion --fix-type problem . 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --fix --fix-type suggestion --fix-type problem . 
1
    
        Copy code to clipboard
        
    

   


   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --fix --fix-type suggestion,layout . 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --fix --fix-type suggestion,layout . 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --fix --fix-type suggestion,layout . 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --fix --fix-type suggestion,layout . 
1
    
        Copy code to clipboard
        
    

   

Ignore Files
--ignore-path
eslintrc Mode Only. This option allows you to specify the file to use as your .eslintignore.

Argument Type: String. Path to file.
Multiple Arguments: No
Default Value: By default, ESLint looks for .eslintignore in the current working directory.

Note: --ignore-path is only supported when using deprecated configuration. If you want to include patterns from a .gitignore file in your eslint.config.js file, please see including .gitignore files.
--ignore-path example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --ignore-path tmp/.eslintignore file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --ignore-path tmp/.eslintignore file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --ignore-path tmp/.eslintignore file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --ignore-path tmp/.eslintignore file.js 
1
    
        Copy code to clipboard
        
    

   


   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --ignore-path .gitignore file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --ignore-path .gitignore file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --ignore-path .gitignore file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --ignore-path .gitignore file.js 
1
    
        Copy code to clipboard
        
    

   

--no-ignore
Disables excluding of files from .eslintignore files, --ignore-path flags, --ignore-pattern flags, and the ignorePatterns property in config files.

Argument Type: No argument.

--no-ignore example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --no-ignore file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --no-ignore file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --no-ignore file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --no-ignore file.js 
1
    
        Copy code to clipboard
        
    

   

--ignore-pattern
This option allows you to specify patterns of files to ignore. In eslintrc mode, these are in addition to .eslintignore.

Argument Type: String. The supported syntax is the same as for .eslintignore files, which use the same patterns as the .gitignore specification. You should quote your patterns in order to avoid shell interpretation of glob patterns.
Multiple Arguments: Yes

--ignore-pattern example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --ignore-pattern "/lib/" --ignore-pattern "/src/vendor/*" . 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --ignore-pattern "/lib/" --ignore-pattern "/src/vendor/*" . 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --ignore-pattern "/lib/" --ignore-pattern "/src/vendor/*" . 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --ignore-pattern "/lib/" --ignore-pattern "/src/vendor/*" . 
1
    
        Copy code to clipboard
        
    

   

Use stdin
--stdin
This option tells ESLint to read and lint source code from STDIN instead of from files. You can use this to pipe code to ESLint.

Argument Type: No argument.

--stdin example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    cat myFile.js | npx eslint --stdin 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    cat myFile.js | yarn dlx eslint --stdin 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    cat myFile.js | pnpm dlx eslint --stdin 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    cat myFile.js | bunx eslint --stdin 
1
    
        Copy code to clipboard
        
    

   

--stdin-filename
This option allows you to specify a filename to process STDIN as.

Argument Type: String. Path to file.
Multiple Arguments: No

This is useful when processing files from STDIN and you have rules which depend on the filename.
--stdin-filename example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    cat myFile.js | npx eslint --stdin --stdin-filename myfile.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    cat myFile.js | yarn dlx eslint --stdin --stdin-filename myfile.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    cat myFile.js | pnpm dlx eslint --stdin --stdin-filename myfile.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    cat myFile.js | bunx eslint --stdin --stdin-filename myfile.js 
1
    
        Copy code to clipboard
        
    

   

Handle Warnings
--quiet
This option allows you to disable reporting on warnings and running of rules set to warn. If you enable this option, only errors are reported by ESLint and only rules set to error will be run.

Argument Type: No argument.

--quiet example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --quiet file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --quiet file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --quiet file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --quiet file.js 
1
    
        Copy code to clipboard
        
    

   

--max-warnings
This option allows you to specify a warning threshold, which can be used to force ESLint to exit with an error status if there are too many warning-level rule violations in your project.

Argument Type: Integer. The maximum number of warnings to allow. To prevent this behavior, do not use this option or specify -1 as the argument.
Multiple Arguments: No

Normally, if ESLint runs and finds no errors (only warnings), it exits with a success exit status. However, if --max-warnings is specified and the total warning count is greater than the specified threshold, ESLint exits with an error status.

                    
                    
                        Important
                        When used alongside --quiet, this will cause rules marked as warn to still be run, but not reported.

                    
                --max-warnings example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --max-warnings 10 file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --max-warnings 10 file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --max-warnings 10 file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --max-warnings 10 file.js 
1
    
        Copy code to clipboard
        
    

   

Output
-o, --output-file
Write the output of linting results to a specified file.

Argument Type: String. Path to file.
Multiple Arguments: No

-o, --output-file example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint -o ./test/test.html 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint -o ./test/test.html 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint -o ./test/test.html 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint -o ./test/test.html 
1
    
        Copy code to clipboard
        
    

   

-f, --format
This option specifies the output format for the console.

Argument Type: String. One of the built-in formatters or a custom formatter.
Multiple Arguments: No
Default Value: stylish

If you are using a custom formatter defined in a local file, you can specify the path to the custom formatter file.
An npm-installed formatter is resolved with or without eslint-formatter- prefix.
When specified, the given format is output to the console. If you’d like to save that output into a file, you can do so on the command line like so:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    # Saves the output into the `results.json` file.
npx eslint -f json file.js > results.json 
12
    
        Copy code to clipboard
        
    

   
   
      yarn


    # Saves the output into the `results.json` file.
yarn dlx eslint -f json file.js > results.json 
12
    
        Copy code to clipboard
        
    

   
   
      pnpm


    # Saves the output into the `results.json` file.
pnpm dlx eslint -f json file.js > results.json 
12
    
        Copy code to clipboard
        
    

   
   
      bun


    # Saves the output into the `results.json` file.
bunx eslint -f json file.js > results.json 
12
    
        Copy code to clipboard
        
    

   

-f, --format example
Use the built-in json formatter:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --format json file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --format json file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --format json file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --format json file.js 
1
    
        Copy code to clipboard
        
    

   

Use a local custom formatter:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint -f ./customformat.js file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint -f ./customformat.js file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint -f ./customformat.js file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint -f ./customformat.js file.js 
1
    
        Copy code to clipboard
        
    

   

Use an npm-installed formatter:

   
      npm
      yarn
      pnpm
      bun
   
    
        npm


    npm install eslint-formatter-pretty
1
    
        Copy code to clipboard
        
    


   
      yarn


    yarn add eslint-formatter-pretty
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm add eslint-formatter-pretty
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bun add eslint-formatter-pretty
1
    
        Copy code to clipboard
        
    

   

Then run one of the following commands

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint -f pretty file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint -f pretty file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint -f pretty file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint -f pretty file.js 
1
    
        Copy code to clipboard
        
    

   

or alternatively

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint -f eslint-formatter-pretty file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint -f eslint-formatter-pretty file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint -f eslint-formatter-pretty file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint -f eslint-formatter-pretty file.js 
1
    
        Copy code to clipboard
        
    

   

--color and --no-color
These options force the enabling/disabling of colorized output.

Argument Type: No argument.

You can use these options to override the default behavior, which is to enable colorized output unless no TTY is detected, such as when piping eslint through cat or less.
--color and --no-color example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --color file.js | cat 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --color file.js | cat 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --color file.js | cat 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --color file.js | cat 
1
    
        Copy code to clipboard
        
    

   


   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --no-color file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --no-color file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --no-color file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --no-color file.js 
1
    
        Copy code to clipboard
        
    

   

Inline Configuration Comments
--no-inline-config
This option prevents inline comments like /*eslint-disable*/ or
/*global foo*/ from having any effect.

Argument Type: No argument.

This allows you to set an ESLint config without files modifying it. All inline config comments are ignored, such as:

/*eslint-disable*/
/*eslint-enable*/
/*global*/
/*eslint*/
/*eslint-env*/
// eslint-disable-line
// eslint-disable-next-line

--no-inline-config example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --no-inline-config file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --no-inline-config file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --no-inline-config file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --no-inline-config file.js 
1
    
        Copy code to clipboard
        
    

   

--report-unused-disable-directives
This option causes ESLint to report directive comments like // eslint-disable-line when no errors would have been reported on that line anyway.

Argument Type: No argument.

This can be useful to prevent future errors from unexpectedly being suppressed, by cleaning up old eslint-disable and eslint-enable comments which are no longer applicable.

                    
                    
                        Warning
                        When using this option, it is possible that new errors start being reported whenever ESLint or custom rules are upgraded.
For example, suppose a rule has a bug that causes it to report a false positive, and an eslint-disable comment is added to suppress the incorrect report. If the bug is then fixed in a patch release of ESLint, the eslint-disable comment becomes unused since ESLint is no longer generating an incorrect report. This results in a new reported error for the unused directive if the --report-unused-disable-directives option is used.

                    
                --report-unused-disable-directives example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --report-unused-disable-directives file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --report-unused-disable-directives file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --report-unused-disable-directives file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --report-unused-disable-directives file.js 
1
    
        Copy code to clipboard
        
    

   

--report-unused-disable-directives-severity
Same as --report-unused-disable-directives, but allows you to specify the severity level (error, warn, off) of the reported errors. Only one of these two options can be used at a time.

Argument Type: String. One of the following values:

off (or 0)
warn (or 1)
error (or 2)


Multiple Arguments: No
Default Value: By default, linterOptions.reportUnusedDisableDirectives configuration setting is used (which defaults to "warn").

--report-unused-disable-directives-severity example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --report-unused-disable-directives-severity warn file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --report-unused-disable-directives-severity warn file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --report-unused-disable-directives-severity warn file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --report-unused-disable-directives-severity warn file.js 
1
    
        Copy code to clipboard
        
    

   

--report-unused-inline-configs
This option causes ESLint to report inline config comments like /* eslint rule-name: "error" */ whose rule severity and any options match what’s already been configured.

Argument Type: String. One of the following values:

off (or 0)
warn (or 1)
error (or 2)


Multiple Arguments: No
Default Value: By default, linterOptions.reportUnusedInlineConfigs configuration setting is used (which defaults to "off").

This can be useful to keep files clean and devoid of misleading clutter.
Inline config comments are meant to change ESLint’s behavior in some way: if they change nothing, there is no reason to leave them in.
--report-unused-inline-configs example


    npx eslint --report-unused-inline-configs error file.js
1
    
        Copy code to clipboard
        
    

Caching
--cache
Store the info about processed files in order to only operate on the changed ones. Enabling this option can dramatically improve ESLint’s run time performance by ensuring that only changed files are linted.
The cache is stored in .eslintcache by default.

Argument Type: No argument.

If you run ESLint with --cache and then run ESLint without --cache, the .eslintcache file will be deleted. This is necessary because the results of the lint might change and make .eslintcache invalid. If you want to control when the cache file is deleted, then use --cache-location to specify an alternate location for the cache file.
Autofixed files are not placed in the cache. Subsequent linting that does not trigger an autofix will place it in the cache.
--cache example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --cache file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --cache file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --cache file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --cache file.js 
1
    
        Copy code to clipboard
        
    

   

--cache-file
Deprecated: Use --cache-location instead.
Path to the cache file. If none specified .eslintcache is used. The file is created in the directory where the eslint command is executed.
--cache-location
Specify the path to the cache location. Can be a file or a directory.

Argument Type: String. Path to file or directory. If a directory is specified, a cache file is created inside the specified folder. The name of the file is based on the hash of the current working directory, e.g.: .cache_hashOfCWD.
Multiple Arguments: No
Default Value: If no location is specified, .eslintcache is used. The file is created in the directory where the eslint command is executed.

If the directory for the cache does not exist make sure you add a trailing / on *nix systems or \ on Windows. Otherwise, the path is assumed to be a file.
--cache-location example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint "src/**/*.js" --cache --cache-location "/Users/user/.eslintcache/" 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint "src/**/*.js" --cache --cache-location "/Users/user/.eslintcache/" 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint "src/**/*.js" --cache --cache-location "/Users/user/.eslintcache/" 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint "src/**/*.js" --cache --cache-location "/Users/user/.eslintcache/" 
1
    
        Copy code to clipboard
        
    

   

--cache-strategy
Strategy for the cache to use for detecting changed files.

Argument Type: String. One of the following values:

metadata
content


Multiple Arguments: No
Default Value: metadata

The content strategy can be useful in cases where the modification time of your files changes even if their contents have not. For example, this can happen during git operations like git clone because git does not track file modification time.
--cache-strategy example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint "src/**/*.js" --cache --cache-strategy content 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint "src/**/*.js" --cache --cache-strategy content 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint "src/**/*.js" --cache --cache-strategy content 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint "src/**/*.js" --cache --cache-strategy content 
1
    
        Copy code to clipboard
        
    

   

Suppressing Violations
--suppress-all
Suppresses existing violations, so that they are not being reported in subsequent runs. It allows you to enable one or more lint rules and be notified only when new violations show up. The suppressions are stored in eslint-suppressions.json by default, unless otherwise specified by --suppressions-location. The file gets updated with the new suppressions.

Argument Type: No argument.

--suppress-all example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint "src/**/*.js" --suppress-all 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint "src/**/*.js" --suppress-all 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint "src/**/*.js" --suppress-all 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint "src/**/*.js" --suppress-all 
1
    
        Copy code to clipboard
        
    

   

--suppress-rule
Suppresses violations for specific rules, so that they are not being reported in subsequent runs. Similar to --suppress-all, the suppressions are stored in eslint-suppressions.json by default, unless otherwise specified by --suppressions-location. The file gets updated with the new suppressions.

Argument Type: String. Rule ID.
Multiple Arguments: Yes

--suppress-rule example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint "src/**/*.js" --suppress-rule no-console --suppress-rule indent 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint "src/**/*.js" --suppress-rule no-console --suppress-rule indent 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint "src/**/*.js" --suppress-rule no-console --suppress-rule indent 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint "src/**/*.js" --suppress-rule no-console --suppress-rule indent 
1
    
        Copy code to clipboard
        
    

   

--suppressions-location
Specify the path to the suppressions location. Can be a file or a directory.

Argument Type: String. Path to file. If a directory is specified, a cache file is created inside the specified folder. The name of the file is based on the hash of the current working directory, e.g.: suppressions_hashOfCWD
Multiple Arguments: No
Default Value: If no location is specified, eslint-suppressions.json is used. The file is created in the directory where the eslint command is executed.

--suppressions-location example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint "src/**/*.js" --suppressions-location ".eslint-suppressions-example.json" 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint "src/**/*.js" --suppressions-location ".eslint-suppressions-example.json" 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint "src/**/*.js" --suppressions-location ".eslint-suppressions-example.json" 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint "src/**/*.js" --suppressions-location ".eslint-suppressions-example.json" 
1
    
        Copy code to clipboard
        
    

   

--prune-suppressions
Prune unused suppressions from the suppressions file. This option is useful when you addressed one or more of the suppressed violations.

Argument Type: No argument.

--prune-suppressions example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint "src/**/*.js" --prune-suppressions 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint "src/**/*.js" --prune-suppressions 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint "src/**/*.js" --prune-suppressions 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint "src/**/*.js" --prune-suppressions 
1
    
        Copy code to clipboard
        
    

   

Miscellaneous
--init
This option runs npm init @eslint/config to start the config initialization wizard. It’s designed to help new users quickly create an .eslintrc file by answering a few questions. When you use this flag, the CLI does not perform linting.

Argument Type: No argument.

The resulting configuration file is created in the current directory.
--init example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --init 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --init 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --init 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --init 
1
    
        Copy code to clipboard
        
    

   

--env-info
This option outputs information about the execution environment, including the version of Node.js, npm, and local and global installations of ESLint.

Argument Type: No argument.

The ESLint team may ask for this information to help solve bugs. When you use this flag, the CLI does not perform linting.
--env-info example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --env-info 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --env-info 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --env-info 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --env-info 
1
    
        Copy code to clipboard
        
    

   

--no-error-on-unmatched-pattern
This option prevents errors when a quoted glob pattern or --ext is unmatched. This does not prevent errors when your shell can’t match a glob.

Argument Type: No argument.

--no-error-on-unmatched-pattern example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --no-error-on-unmatched-pattern --ext .ts "lib/*" 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --no-error-on-unmatched-pattern --ext .ts "lib/*" 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --no-error-on-unmatched-pattern --ext .ts "lib/*" 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --no-error-on-unmatched-pattern --ext .ts "lib/*" 
1
    
        Copy code to clipboard
        
    

   

--exit-on-fatal-error
This option causes ESLint to exit with exit code 2 if one or more fatal parsing errors occur. Without this option, ESLint reports fatal parsing errors as rule violations.

Argument Type: No argument.

--exit-on-fatal-error example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --exit-on-fatal-error file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --exit-on-fatal-error file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --exit-on-fatal-error file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --exit-on-fatal-error file.js 
1
    
        Copy code to clipboard
        
    

   

--no-warn-ignored
Flat Config Mode Only. This option suppresses both File ignored by default and File ignored because of a matching ignore pattern warnings when an ignored filename is passed explicitly. It is useful when paired with --max-warnings 0 as it will prevent exit code 1 due to the aforementioned warning.

Argument Type: No argument.

--no-warn-ignored example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --no-warn-ignored --max-warnings 0 ignored-file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --no-warn-ignored --max-warnings 0 ignored-file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --no-warn-ignored --max-warnings 0 ignored-file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --no-warn-ignored --max-warnings 0 ignored-file.js 
1
    
        Copy code to clipboard
        
    

   

--pass-on-no-patterns
This option allows ESLint to exit with code 0 when no file or directory patterns are passed. Without this option, ESLint assumes you want to use . as the pattern. (When running in legacy eslintrc mode, ESLint will exit with code 1.)

Argument Type: No argument.

--pass-on-no-patterns example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --pass-on-no-patterns 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --pass-on-no-patterns 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --pass-on-no-patterns 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --pass-on-no-patterns 
1
    
        Copy code to clipboard
        
    

   

--debug
This option outputs debugging information to the console. Add this flag to an ESLint command line invocation in order to get extra debugging information while the command runs.

Argument Type: No argument.

This information is useful when you’re seeing a problem and having a hard time pinpointing it. The ESLint team may ask for this debugging information to help solve bugs.
--debug example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --debug test.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --debug test.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --debug test.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --debug test.js 
1
    
        Copy code to clipboard
        
    

   

-h, --help
This option outputs the help menu, displaying all of the available options. All other options are ignored when this is present. When you use this flag, the CLI does not perform linting.

Argument Type: No argument.

-h, --help example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --help 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --help 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --help 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --help 
1
    
        Copy code to clipboard
        
    

   

-v, --version
This option outputs the current ESLint version onto the console. All other options are ignored when this is present. When you use this flag, the CLI does not perform linting.

Argument Type: No argument.

-v, --version example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --version 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --version 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --version 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --version 
1
    
        Copy code to clipboard
        
    

   

--print-config
This option outputs the configuration to be used for the file passed. When present, no linting is performed and only config-related options are valid. When you use this flag, the CLI does not perform linting.

Argument Type: String. Path to file.
Multiple Arguments: No

--print-config example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --print-config file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --print-config file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --print-config file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --print-config file.js 
1
    
        Copy code to clipboard
        
    

   

--stats
This option adds a series of detailed performance statistics (see Stats type) such as the parse-, fix- and lint-times (time per rule) to result objects that are passed to the formatter (see Stats CLI usage).

Argument Type: No argument.

This option is intended for use with custom formatters that display statistics. It can also be used with the built-in json formatter.
--stats example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --stats --format json file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --stats --format json file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --stats --format json file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --stats --format json file.js 
1
    
        Copy code to clipboard
        
    

   

--flag
This option enables one or more feature flags for ESLint.

Argument Type: String. A feature identifier.
Multiple Arguments: Yes

--flag example

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --flag x_feature file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --flag x_feature file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --flag x_feature file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --flag x_feature file.js 
1
    
        Copy code to clipboard
        
    

   

Exit Codes
When linting files, ESLint exits with one of the following exit codes:

0: Linting was successful and there are no linting errors. If the --max-warnings flag is set to n, the number of linting warnings is at most n.
1: Linting was successful and there is at least one linting error, or there are more linting warnings than allowed by the --max-warnings option.
2: Linting was unsuccessful due to a configuration problem or an internal error.


            

            
                Edit this page\n\n\n\narray-callback-return
Enforce return statements in callbacks of array methods
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



constructor-super
Require super() calls in constructors
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



for-direction
Enforce for loop update clause moving the counter in the right direction
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



getter-return
Enforce return statements in getters
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-async-promise-executor
Disallow using an async function as a Promise executor
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-await-in-loop
Disallow await inside of loops
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-class-assign
Disallow reassigning class members
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-compare-neg-zero
Disallow comparing against -0
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-cond-assign
Disallow assignment operators in conditional expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-const-assign
Disallow reassigning const variables
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-constant-binary-expression
Disallow expressions where the operation doesn’t affect the value
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-constant-condition
Disallow constant expressions in conditions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-constructor-return
Disallow returning value from constructor
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-control-regex
Disallow control characters in regular expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-debugger
Disallow the use of debugger
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-dupe-args
Disallow duplicate arguments in function definitions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-dupe-class-members
Disallow duplicate class members
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-dupe-else-if
Disallow duplicate conditions in if-else-if chains
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-dupe-keys
Disallow duplicate keys in object literals
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-duplicate-case
Disallow duplicate case labels
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-duplicate-imports
Disallow duplicate module imports
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-empty-character-class
Disallow empty character classes in regular expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-empty-pattern
Disallow empty destructuring patterns
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-ex-assign
Disallow reassigning exceptions in catch clauses
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-fallthrough
Disallow fallthrough of case statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-func-assign
Disallow reassigning function declarations
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-import-assign
Disallow assigning to imported bindings
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-inner-declarations
Disallow variable or function declarations in nested blocks
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-invalid-regexp
Disallow invalid regular expression strings in RegExp constructors
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-irregular-whitespace
Disallow irregular whitespace
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-loss-of-precision
Disallow literal numbers that lose precision
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-misleading-character-class
Disallow characters which are made with multiple code points in character class syntax
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-new-native-nonconstructor
Disallow new operators with global non-constructor functions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-obj-calls
Disallow calling global object properties as functions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-promise-executor-return
Disallow returning values from Promise executor functions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-prototype-builtins
Disallow calling some Object.prototype methods directly on objects
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-self-assign
Disallow assignments where both sides are exactly the same
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-self-compare
Disallow comparisons where both sides are exactly the same
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-setter-return
Disallow returning values from setters
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-sparse-arrays
Disallow sparse arrays
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-template-curly-in-string
Disallow template literal placeholder syntax in regular strings
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-this-before-super
Disallow this/super before calling super() in constructors
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-undef
Disallow the use of undeclared variables unless mentioned in /*global */ comments
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unexpected-multiline
Disallow confusing multiline expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unmodified-loop-condition
Disallow unmodified loop conditions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unreachable
Disallow unreachable code after return, throw, continue, and break statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unreachable-loop
Disallow loops with a body that allows only one iteration
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unsafe-finally
Disallow control flow statements in finally blocks
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unsafe-negation
Disallow negating the left operand of relational operators
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unsafe-optional-chaining
Disallow use of optional chaining in contexts where the undefined value is not allowed
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unused-private-class-members
Disallow unused private class members
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unused-vars
Disallow unused variables
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-use-before-define
Disallow the use of variables before they are defined
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-useless-assignment
Disallow variable assignments when the value is not used
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-useless-backreference
Disallow useless backreferences in regular expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



require-atomic-updates
Disallow assignments that can lead to race conditions due to usage of await or yield
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



use-isnan
Require calls to isNaN() when checking for NaN
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



valid-typeof
Enforce comparing typeof expressions against valid strings
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



accessor-pairs
Enforce getter and setter pairs in objects and classes
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



arrow-body-style
 ❄️ Frozen
Require braces around arrow function bodies
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



block-scoped-var
Enforce the use of variables within the scope they are defined
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



camelcase
 ❄️ Frozen
Enforce camelcase naming convention
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



capitalized-comments
 ❄️ Frozen
Enforce or disallow capitalization of the first letter of a comment
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



class-methods-use-this
Enforce that class methods utilize this
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



complexity
Enforce a maximum cyclomatic complexity allowed in a program
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



consistent-return
Require return statements to either always or never specify values
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



consistent-this
 ❄️ Frozen
Enforce consistent naming when capturing the current execution context
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



curly
 ❄️ Frozen
Enforce consistent brace style for all control statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



default-case
Require default cases in switch statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



default-case-last
Enforce default clauses in switch statements to be last
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



default-param-last
 ❄️ Frozen
Enforce default parameters to be last
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



dot-notation
 ❄️ Frozen
Enforce dot notation whenever possible
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



eqeqeq
Require the use of === and !==
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



func-name-matching
 ❄️ Frozen
Require function names to match the name of the variable or property to which they are assigned
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



func-names
Require or disallow named function expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



func-style
 ❄️ Frozen
Enforce the consistent use of either function declarations or expressions assigned to variables
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



grouped-accessor-pairs
Require grouped accessor pairs in object literals and classes
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



guard-for-in
Require for-in loops to include an if statement
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



id-denylist
 ❄️ Frozen
Disallow specified identifiers
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



id-length
 ❄️ Frozen
Enforce minimum and maximum identifier lengths
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



id-match
 ❄️ Frozen
Require identifiers to match a specified regular expression
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



init-declarations
 ❄️ Frozen
Require or disallow initialization in variable declarations
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



logical-assignment-operators
 ❄️ Frozen
Require or disallow logical assignment operator shorthand
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



max-classes-per-file
Enforce a maximum number of classes per file
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



max-depth
Enforce a maximum depth that blocks can be nested
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



max-lines
Enforce a maximum number of lines per file
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



max-lines-per-function
Enforce a maximum number of lines of code in a function
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



max-nested-callbacks
Enforce a maximum depth that callbacks can be nested
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



max-params
Enforce a maximum number of parameters in function definitions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



max-statements
Enforce a maximum number of statements allowed in function blocks
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



new-cap
Require constructor names to begin with a capital letter
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-alert
Disallow the use of alert, confirm, and prompt
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-array-constructor
Disallow Array constructors
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-bitwise
Disallow bitwise operators
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-caller
Disallow the use of arguments.caller or arguments.callee
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-case-declarations
Disallow lexical declarations in case clauses
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-console
Disallow the use of console
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-continue
 ❄️ Frozen
Disallow continue statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-delete-var
Disallow deleting variables
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-div-regex
 ❄️ Frozen
Disallow equal signs explicitly at the beginning of regular expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-else-return
 ❄️ Frozen
Disallow else blocks after return statements in if statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-empty
Disallow empty block statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-empty-function
Disallow empty functions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-empty-static-block
Disallow empty static blocks
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-eq-null
Disallow null comparisons without type-checking operators
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-eval
Disallow the use of eval()
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-extend-native
Disallow extending native types
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-extra-bind
Disallow unnecessary calls to .bind()
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-extra-boolean-cast
 ❄️ Frozen
Disallow unnecessary boolean casts
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-extra-label
 ❄️ Frozen
Disallow unnecessary labels
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-global-assign
Disallow assignments to native objects or read-only global variables
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-implicit-coercion
 ❄️ Frozen
Disallow shorthand type conversions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-implicit-globals
Disallow declarations in the global scope
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-implied-eval
Disallow the use of eval()-like methods
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-inline-comments
 ❄️ Frozen
Disallow inline comments after code
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-invalid-this
Disallow use of this in contexts where the value of this is undefined
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-iterator
Disallow the use of the __iterator__ property
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-label-var
 ❄️ Frozen
Disallow labels that share a name with a variable
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-labels
 ❄️ Frozen
Disallow labeled statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-lone-blocks
Disallow unnecessary nested blocks
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-lonely-if
 ❄️ Frozen
Disallow if statements as the only statement in else blocks
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-loop-func
Disallow function declarations that contain unsafe references inside loop statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-magic-numbers
 ❄️ Frozen
Disallow magic numbers
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-multi-assign
Disallow use of chained assignment expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-multi-str
 ❄️ Frozen
Disallow multiline strings
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-negated-condition
 ❄️ Frozen
Disallow negated conditions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-nested-ternary
 ❄️ Frozen
Disallow nested ternary expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-new
Disallow new operators outside of assignments or comparisons
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-new-func
Disallow new operators with the Function object
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-new-wrappers
Disallow new operators with the String, Number, and Boolean objects
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-nonoctal-decimal-escape
Disallow &#92;8 and &#92;9 escape sequences in string literals
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-object-constructor
Disallow calls to the Object constructor without an argument
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-octal
Disallow octal literals
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-octal-escape
Disallow octal escape sequences in string literals
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-param-reassign
Disallow reassigning function parameters
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-plusplus
 ❄️ Frozen
Disallow the unary operators ++ and --
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-proto
Disallow the use of the __proto__ property
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-redeclare
Disallow variable redeclaration
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-regex-spaces
Disallow multiple spaces in regular expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-restricted-exports
Disallow specified names in exports
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-restricted-globals
Disallow specified global variables
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-restricted-imports
Disallow specified modules when loaded by import
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-restricted-properties
Disallow certain properties on certain objects
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-restricted-syntax
Disallow specified syntax
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-return-assign
Disallow assignment operators in return statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-script-url
Disallow javascript: URLs
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-sequences
Disallow comma operators
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-shadow
Disallow variable declarations from shadowing variables declared in the outer scope
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-shadow-restricted-names
Disallow identifiers from shadowing restricted names
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-ternary
 ❄️ Frozen
Disallow ternary operators
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-throw-literal
Disallow throwing literals as exceptions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-undef-init
 ❄️ Frozen
Disallow initializing variables to undefined
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-undefined
 ❄️ Frozen
Disallow the use of undefined as an identifier
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-underscore-dangle
 ❄️ Frozen
Disallow dangling underscores in identifiers
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unneeded-ternary
 ❄️ Frozen
Disallow ternary operators when simpler alternatives exist
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unused-expressions
Disallow unused expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unused-labels
Disallow unused labels
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-useless-call
Disallow unnecessary calls to .call() and .apply()
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-useless-catch
Disallow unnecessary catch clauses
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-useless-computed-key
 ❄️ Frozen
Disallow unnecessary computed property keys in objects and classes
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-useless-concat
 ❄️ Frozen
Disallow unnecessary concatenation of literals or template literals
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-useless-constructor
Disallow unnecessary constructors
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-useless-escape
Disallow unnecessary escape characters
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-useless-rename
Disallow renaming import, export, and destructured assignments to the same name
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-useless-return
Disallow redundant return statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-var
Require let or const instead of var
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-void
 ❄️ Frozen
Disallow void operators
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-warning-comments
 ❄️ Frozen
Disallow specified warning terms in comments
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-with
Disallow with statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



object-shorthand
 ❄️ Frozen
Require or disallow method and property shorthand syntax for object literals
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



one-var
 ❄️ Frozen
Enforce variables to be declared either together or separately in functions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



operator-assignment
 ❄️ Frozen
Require or disallow assignment operator shorthand where possible
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-arrow-callback
 ❄️ Frozen
Require using arrow functions for callbacks
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-const
Require const declarations for variables that are never reassigned after declared
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-destructuring
 ❄️ Frozen
Require destructuring from arrays and/or objects
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-exponentiation-operator
 ❄️ Frozen
Disallow the use of Math.pow in favor of the ** operator
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-named-capture-group
Enforce using named capture group in regular expression
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-numeric-literals
 ❄️ Frozen
Disallow parseInt() and Number.parseInt() in favor of binary, octal, and hexadecimal literals
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-object-has-own
Disallow use of Object.prototype.hasOwnProperty.call() and prefer use of Object.hasOwn()
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-object-spread
 ❄️ Frozen
Disallow using Object.assign with an object literal as the first argument and prefer the use of object spread instead
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-promise-reject-errors
Require using Error objects as Promise rejection reasons
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-regex-literals
Disallow use of the RegExp constructor in favor of regular expression literals
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-rest-params
Require rest parameters instead of arguments
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-spread
 ❄️ Frozen
Require spread operators instead of .apply()
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-template
 ❄️ Frozen
Require template literals instead of string concatenation
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



radix
Enforce the consistent use of the radix argument when using parseInt()
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



require-await
Disallow async functions which have no await expression
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



require-unicode-regexp
Enforce the use of u or v flag on regular expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



require-yield
Require generator functions to contain yield
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



sort-imports
 ❄️ Frozen
Enforce sorted import declarations within modules
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



sort-keys
 ❄️ Frozen
Require object keys to be sorted
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



sort-vars
 ❄️ Frozen
Require variables within the same declaration block to be sorted
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



strict
Require or disallow strict mode directives
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



symbol-description
Require symbol descriptions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



vars-on-top
 ❄️ Frozen
Require var declarations be placed at the top of their containing scope
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



yoda
 ❄️ Frozen
Require or disallow “Yoda” conditions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



unicode-bom
Require or disallow Unicode byte order mark (BOM)
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



array-bracket-newline
deprecated
Replaced by
array-bracket-newline
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



array-bracket-spacing
deprecated
Replaced by
array-bracket-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



array-element-newline
deprecated
Replaced by
array-element-newline
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



arrow-parens
deprecated
Replaced by
arrow-parens
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



arrow-spacing
deprecated
Replaced by
arrow-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



block-spacing
deprecated
Replaced by
block-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



brace-style
deprecated
Replaced by
brace-style
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



callback-return
deprecated
Replaced by
callback-return
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



comma-dangle
deprecated
Replaced by
comma-dangle
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



comma-spacing
deprecated
Replaced by
comma-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



comma-style
deprecated
Replaced by
comma-style
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



computed-property-spacing
deprecated
Replaced by
computed-property-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



dot-location
deprecated
Replaced by
dot-location
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



eol-last
deprecated
Replaced by
eol-last
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



func-call-spacing
deprecated
Replaced by
function-call-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



function-call-argument-newline
deprecated
Replaced by
function-call-argument-newline
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



function-paren-newline
deprecated
Replaced by
function-paren-newline
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



generator-star-spacing
deprecated
Replaced by
generator-star-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



global-require
deprecated
Replaced by
global-require
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



handle-callback-err
deprecated
Replaced by
handle-callback-err
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



id-blacklist
deprecated
Replaced by
id-denylist

Categories:❌
🔧 Fix


💡 Suggestions



implicit-arrow-linebreak
deprecated
Replaced by
implicit-arrow-linebreak
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



indent
deprecated
Replaced by
indent
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



indent-legacy
deprecated
Replaced by
indent
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



jsx-quotes
deprecated
Replaced by
jsx-quotes
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



key-spacing
deprecated
Replaced by
key-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



keyword-spacing
deprecated
Replaced by
keyword-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



line-comment-position
deprecated
Replaced by
line-comment-position
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



linebreak-style
deprecated
Replaced by
linebreak-style
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



lines-around-comment
deprecated
Replaced by
lines-around-comment
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



lines-around-directive
deprecated
Replaced by
padding-line-between-statements
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



lines-between-class-members
deprecated
Replaced by
lines-between-class-members
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



max-len
deprecated
Replaced by
max-len
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



max-statements-per-line
deprecated
Replaced by
max-statements-per-line
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



multiline-comment-style
deprecated
Replaced by
multiline-comment-style
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



multiline-ternary
deprecated
Replaced by
multiline-ternary
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



new-parens
deprecated
Replaced by
new-parens
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



newline-after-var
deprecated
Replaced by
padding-line-between-statements
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



newline-before-return
deprecated
Replaced by
padding-line-between-statements
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



newline-per-chained-call
deprecated
Replaced by
newline-per-chained-call
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-buffer-constructor
deprecated
Replaced by
no-deprecated-api
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



no-catch-shadow
deprecated
Replaced by
no-shadow

Categories:❌
🔧 Fix


💡 Suggestions



no-confusing-arrow
deprecated
Replaced by
no-confusing-arrow
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-extra-parens
deprecated
Replaced by
no-extra-parens
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-extra-semi
deprecated
Replaced by
no-extra-semi
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-floating-decimal
deprecated
Replaced by
no-floating-decimal
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-mixed-operators
deprecated
Replaced by
no-mixed-operators
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-mixed-requires
deprecated
Replaced by
no-mixed-requires
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



no-mixed-spaces-and-tabs
deprecated
Replaced by
no-mixed-spaces-and-tabs
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-multi-spaces
deprecated
Replaced by
no-multi-spaces
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-multiple-empty-lines
deprecated
Replaced by
no-multiple-empty-lines
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-native-reassign
deprecated
Replaced by
no-global-assign

Categories:❌
🔧 Fix


💡 Suggestions



no-negated-in-lhs
deprecated
Replaced by
no-unsafe-negation

Categories:❌
🔧 Fix


💡 Suggestions



no-new-object
deprecated
Replaced by
no-object-constructor

Categories:❌
🔧 Fix


💡 Suggestions



no-new-require
deprecated
Replaced by
no-new-require
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



no-new-symbol
deprecated
Replaced by
no-new-native-nonconstructor

Categories:❌
🔧 Fix


💡 Suggestions



no-path-concat
deprecated
Replaced by
no-path-concat
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



no-process-env
deprecated
Replaced by
no-process-env
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



no-process-exit
deprecated
Replaced by
no-process-exit
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



no-restricted-modules
deprecated
Replaced by
no-restricted-require
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



no-return-await
deprecated

Categories:❌
🔧 Fix


💡 Suggestions



no-spaced-func
deprecated
Replaced by
function-call-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-sync
deprecated
Replaced by
no-sync
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



no-tabs
deprecated
Replaced by
no-tabs
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-trailing-spaces
deprecated
Replaced by
no-trailing-spaces
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-whitespace-before-property
deprecated
Replaced by
no-whitespace-before-property
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



nonblock-statement-body-position
deprecated
Replaced by
nonblock-statement-body-position
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



object-curly-newline
deprecated
Replaced by
object-curly-newline
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



object-curly-spacing
deprecated
Replaced by
object-curly-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



object-property-newline
deprecated
Replaced by
object-property-newline
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



one-var-declaration-per-line
deprecated
Replaced by
one-var-declaration-per-line
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



operator-linebreak
deprecated
Replaced by
operator-linebreak
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



padded-blocks
deprecated
Replaced by
padded-blocks
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



padding-line-between-statements
deprecated
Replaced by
padding-line-between-statements
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



prefer-reflect
deprecated

Categories:❌
🔧 Fix


💡 Suggestions



quote-props
deprecated
Replaced by
quote-props
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



quotes
deprecated
Replaced by
quotes
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



rest-spread-spacing
deprecated
Replaced by
rest-spread-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



semi
deprecated
Replaced by
semi
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



semi-spacing
deprecated
Replaced by
semi-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



semi-style
deprecated
Replaced by
semi-style
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



space-before-blocks
deprecated
Replaced by
space-before-blocks
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



space-before-function-paren
deprecated
Replaced by
space-before-function-paren
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



space-in-parens
deprecated
Replaced by
space-in-parens
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



space-infix-ops
deprecated
Replaced by
space-infix-ops
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



space-unary-ops
deprecated
Replaced by
space-unary-ops
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



spaced-comment
deprecated
Replaced by
spaced-comment
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



switch-colon-spacing
deprecated
Replaced by
switch-colon-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



template-curly-spacing
deprecated
Replaced by
template-curly-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



template-tag-spacing
deprecated
Replaced by
template-tag-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



wrap-iife
deprecated
Replaced by
wrap-iife
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



wrap-regex
deprecated
Replaced by
wrap-regex
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



yield-star-spacing
deprecated
Replaced by
yield-star-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



generator-star
removed
Replaced by
generator-star-spacing


global-strict
removed
Replaced by
strict


no-arrow-condition
removed
Replaced by
no-confusing-arrow
or 
no-constant-condition


no-comma-dangle
removed
Replaced by
comma-dangle


no-empty-class
removed
Replaced by
no-empty-character-class


no-empty-label
removed
Replaced by
no-labels


no-extra-strict
removed
Replaced by
strict


no-reserved-keys
removed
Replaced by
quote-props


no-space-before-semi
removed
Replaced by
semi-spacing


no-wrap-func
removed
Replaced by
no-extra-parens


space-after-function-name
removed
Replaced by
space-before-function-paren


space-after-keywords
removed
Replaced by
keyword-spacing


space-before-function-parentheses
removed
Replaced by
space-before-function-paren


space-before-keywords
removed
Replaced by
keyword-spacing


space-in-brackets
removed
Replaced by
object-curly-spacing
or 
array-bracket-spacing


space-return-throw-case
removed
Replaced by
keyword-spacing


space-unary-word-ops
removed
Replaced by
space-unary-ops


spaced-line-comment
removed
Replaced by
spaced-comment


valid-jsdoc
removed


require-jsdoc
removed\n\nRules Reference
                

                Table of Contents
    
        
                
                    
                    Possible Problems
            		

                    Suggestions
            		

                    Layout & Formatting
            		

                    Deprecated
            		

                    Removed
            		
                
            
    


                Rules in ESLint are grouped by type to help you understand their purpose. Each rule has emojis denoting:

        ✅ Recommended
        
            Using the recommended config from @eslint/js in a configuration file
            enables this rule
        
    
        🔧 Fixable
        
            Some problems reported by this rule are automatically fixable by the --fix command line option
        
    
        💡 hasSuggestions
        
            Some problems reported by this rule are manually fixable by editor suggestions
        
    
        ❄️ Frozen
        
            This rule is currently frozen and is not accepting feature requests.
        
     Possible Problems 
These rules relate to possible logic errors in code:

array-callback-return
Enforce return statements in callbacks of array methods
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



constructor-super
Require super() calls in constructors
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



for-direction
Enforce for loop update clause moving the counter in the right direction
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



getter-return
Enforce return statements in getters
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-async-promise-executor
Disallow using an async function as a Promise executor
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-await-in-loop
Disallow await inside of loops
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-class-assign
Disallow reassigning class members
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-compare-neg-zero
Disallow comparing against -0
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-cond-assign
Disallow assignment operators in conditional expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-const-assign
Disallow reassigning const variables
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-constant-binary-expression
Disallow expressions where the operation doesn’t affect the value
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-constant-condition
Disallow constant expressions in conditions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-constructor-return
Disallow returning value from constructor
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-control-regex
Disallow control characters in regular expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-debugger
Disallow the use of debugger
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-dupe-args
Disallow duplicate arguments in function definitions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-dupe-class-members
Disallow duplicate class members
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-dupe-else-if
Disallow duplicate conditions in if-else-if chains
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-dupe-keys
Disallow duplicate keys in object literals
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-duplicate-case
Disallow duplicate case labels
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-duplicate-imports
Disallow duplicate module imports
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-empty-character-class
Disallow empty character classes in regular expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-empty-pattern
Disallow empty destructuring patterns
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-ex-assign
Disallow reassigning exceptions in catch clauses
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-fallthrough
Disallow fallthrough of case statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-func-assign
Disallow reassigning function declarations
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-import-assign
Disallow assigning to imported bindings
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-inner-declarations
Disallow variable or function declarations in nested blocks
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-invalid-regexp
Disallow invalid regular expression strings in RegExp constructors
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-irregular-whitespace
Disallow irregular whitespace
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-loss-of-precision
Disallow literal numbers that lose precision
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-misleading-character-class
Disallow characters which are made with multiple code points in character class syntax
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-new-native-nonconstructor
Disallow new operators with global non-constructor functions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-obj-calls
Disallow calling global object properties as functions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-promise-executor-return
Disallow returning values from Promise executor functions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-prototype-builtins
Disallow calling some Object.prototype methods directly on objects
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-self-assign
Disallow assignments where both sides are exactly the same
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-self-compare
Disallow comparisons where both sides are exactly the same
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-setter-return
Disallow returning values from setters
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-sparse-arrays
Disallow sparse arrays
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-template-curly-in-string
Disallow template literal placeholder syntax in regular strings
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-this-before-super
Disallow this/super before calling super() in constructors
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-undef
Disallow the use of undeclared variables unless mentioned in /*global */ comments
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unexpected-multiline
Disallow confusing multiline expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unmodified-loop-condition
Disallow unmodified loop conditions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unreachable
Disallow unreachable code after return, throw, continue, and break statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unreachable-loop
Disallow loops with a body that allows only one iteration
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unsafe-finally
Disallow control flow statements in finally blocks
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unsafe-negation
Disallow negating the left operand of relational operators
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unsafe-optional-chaining
Disallow use of optional chaining in contexts where the undefined value is not allowed
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unused-private-class-members
Disallow unused private class members
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unused-vars
Disallow unused variables
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-use-before-define
Disallow the use of variables before they are defined
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-useless-assignment
Disallow variable assignments when the value is not used
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-useless-backreference
Disallow useless backreferences in regular expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



require-atomic-updates
Disallow assignments that can lead to race conditions due to usage of await or yield
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



use-isnan
Require calls to isNaN() when checking for NaN
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



valid-typeof
Enforce comparing typeof expressions against valid strings
Categories:
✅ Extends

🔧 Fix


💡 Suggestions

 Suggestions 
These rules suggest alternate ways of doing things:

accessor-pairs
Enforce getter and setter pairs in objects and classes
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



arrow-body-style
 ❄️ Frozen
Require braces around arrow function bodies
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



block-scoped-var
Enforce the use of variables within the scope they are defined
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



camelcase
 ❄️ Frozen
Enforce camelcase naming convention
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



capitalized-comments
 ❄️ Frozen
Enforce or disallow capitalization of the first letter of a comment
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



class-methods-use-this
Enforce that class methods utilize this
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



complexity
Enforce a maximum cyclomatic complexity allowed in a program
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



consistent-return
Require return statements to either always or never specify values
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



consistent-this
 ❄️ Frozen
Enforce consistent naming when capturing the current execution context
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



curly
 ❄️ Frozen
Enforce consistent brace style for all control statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



default-case
Require default cases in switch statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



default-case-last
Enforce default clauses in switch statements to be last
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



default-param-last
 ❄️ Frozen
Enforce default parameters to be last
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



dot-notation
 ❄️ Frozen
Enforce dot notation whenever possible
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



eqeqeq
Require the use of === and !==
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



func-name-matching
 ❄️ Frozen
Require function names to match the name of the variable or property to which they are assigned
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



func-names
Require or disallow named function expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



func-style
 ❄️ Frozen
Enforce the consistent use of either function declarations or expressions assigned to variables
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



grouped-accessor-pairs
Require grouped accessor pairs in object literals and classes
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



guard-for-in
Require for-in loops to include an if statement
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



id-denylist
 ❄️ Frozen
Disallow specified identifiers
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



id-length
 ❄️ Frozen
Enforce minimum and maximum identifier lengths
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



id-match
 ❄️ Frozen
Require identifiers to match a specified regular expression
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



init-declarations
 ❄️ Frozen
Require or disallow initialization in variable declarations
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



logical-assignment-operators
 ❄️ Frozen
Require or disallow logical assignment operator shorthand
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



max-classes-per-file
Enforce a maximum number of classes per file
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



max-depth
Enforce a maximum depth that blocks can be nested
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



max-lines
Enforce a maximum number of lines per file
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



max-lines-per-function
Enforce a maximum number of lines of code in a function
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



max-nested-callbacks
Enforce a maximum depth that callbacks can be nested
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



max-params
Enforce a maximum number of parameters in function definitions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



max-statements
Enforce a maximum number of statements allowed in function blocks
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



new-cap
Require constructor names to begin with a capital letter
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-alert
Disallow the use of alert, confirm, and prompt
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-array-constructor
Disallow Array constructors
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-bitwise
Disallow bitwise operators
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-caller
Disallow the use of arguments.caller or arguments.callee
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-case-declarations
Disallow lexical declarations in case clauses
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-console
Disallow the use of console
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-continue
 ❄️ Frozen
Disallow continue statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-delete-var
Disallow deleting variables
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-div-regex
 ❄️ Frozen
Disallow equal signs explicitly at the beginning of regular expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-else-return
 ❄️ Frozen
Disallow else blocks after return statements in if statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-empty
Disallow empty block statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-empty-function
Disallow empty functions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-empty-static-block
Disallow empty static blocks
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-eq-null
Disallow null comparisons without type-checking operators
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-eval
Disallow the use of eval()
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-extend-native
Disallow extending native types
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-extra-bind
Disallow unnecessary calls to .bind()
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-extra-boolean-cast
 ❄️ Frozen
Disallow unnecessary boolean casts
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-extra-label
 ❄️ Frozen
Disallow unnecessary labels
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-global-assign
Disallow assignments to native objects or read-only global variables
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-implicit-coercion
 ❄️ Frozen
Disallow shorthand type conversions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-implicit-globals
Disallow declarations in the global scope
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-implied-eval
Disallow the use of eval()-like methods
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-inline-comments
 ❄️ Frozen
Disallow inline comments after code
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-invalid-this
Disallow use of this in contexts where the value of this is undefined
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-iterator
Disallow the use of the __iterator__ property
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-label-var
 ❄️ Frozen
Disallow labels that share a name with a variable
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-labels
 ❄️ Frozen
Disallow labeled statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-lone-blocks
Disallow unnecessary nested blocks
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-lonely-if
 ❄️ Frozen
Disallow if statements as the only statement in else blocks
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-loop-func
Disallow function declarations that contain unsafe references inside loop statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-magic-numbers
 ❄️ Frozen
Disallow magic numbers
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-multi-assign
Disallow use of chained assignment expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-multi-str
 ❄️ Frozen
Disallow multiline strings
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-negated-condition
 ❄️ Frozen
Disallow negated conditions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-nested-ternary
 ❄️ Frozen
Disallow nested ternary expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-new
Disallow new operators outside of assignments or comparisons
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-new-func
Disallow new operators with the Function object
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-new-wrappers
Disallow new operators with the String, Number, and Boolean objects
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-nonoctal-decimal-escape
Disallow &#92;8 and &#92;9 escape sequences in string literals
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-object-constructor
Disallow calls to the Object constructor without an argument
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-octal
Disallow octal literals
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-octal-escape
Disallow octal escape sequences in string literals
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-param-reassign
Disallow reassigning function parameters
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-plusplus
 ❄️ Frozen
Disallow the unary operators ++ and --
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-proto
Disallow the use of the __proto__ property
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-redeclare
Disallow variable redeclaration
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-regex-spaces
Disallow multiple spaces in regular expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-restricted-exports
Disallow specified names in exports
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-restricted-globals
Disallow specified global variables
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-restricted-imports
Disallow specified modules when loaded by import
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-restricted-properties
Disallow certain properties on certain objects
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-restricted-syntax
Disallow specified syntax
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-return-assign
Disallow assignment operators in return statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-script-url
Disallow javascript: URLs
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-sequences
Disallow comma operators
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-shadow
Disallow variable declarations from shadowing variables declared in the outer scope
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-shadow-restricted-names
Disallow identifiers from shadowing restricted names
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-ternary
 ❄️ Frozen
Disallow ternary operators
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-throw-literal
Disallow throwing literals as exceptions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-undef-init
 ❄️ Frozen
Disallow initializing variables to undefined
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-undefined
 ❄️ Frozen
Disallow the use of undefined as an identifier
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-underscore-dangle
 ❄️ Frozen
Disallow dangling underscores in identifiers
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unneeded-ternary
 ❄️ Frozen
Disallow ternary operators when simpler alternatives exist
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unused-expressions
Disallow unused expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unused-labels
Disallow unused labels
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-useless-call
Disallow unnecessary calls to .call() and .apply()
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-useless-catch
Disallow unnecessary catch clauses
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-useless-computed-key
 ❄️ Frozen
Disallow unnecessary computed property keys in objects and classes
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-useless-concat
 ❄️ Frozen
Disallow unnecessary concatenation of literals or template literals
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-useless-constructor
Disallow unnecessary constructors
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-useless-escape
Disallow unnecessary escape characters
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-useless-rename
Disallow renaming import, export, and destructured assignments to the same name
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-useless-return
Disallow redundant return statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-var
Require let or const instead of var
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-void
 ❄️ Frozen
Disallow void operators
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-warning-comments
 ❄️ Frozen
Disallow specified warning terms in comments
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-with
Disallow with statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



object-shorthand
 ❄️ Frozen
Require or disallow method and property shorthand syntax for object literals
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



one-var
 ❄️ Frozen
Enforce variables to be declared either together or separately in functions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



operator-assignment
 ❄️ Frozen
Require or disallow assignment operator shorthand where possible
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-arrow-callback
 ❄️ Frozen
Require using arrow functions for callbacks
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-const
Require const declarations for variables that are never reassigned after declared
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-destructuring
 ❄️ Frozen
Require destructuring from arrays and/or objects
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-exponentiation-operator
 ❄️ Frozen
Disallow the use of Math.pow in favor of the ** operator
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-named-capture-group
Enforce using named capture group in regular expression
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-numeric-literals
 ❄️ Frozen
Disallow parseInt() and Number.parseInt() in favor of binary, octal, and hexadecimal literals
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-object-has-own
Disallow use of Object.prototype.hasOwnProperty.call() and prefer use of Object.hasOwn()
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-object-spread
 ❄️ Frozen
Disallow using Object.assign with an object literal as the first argument and prefer the use of object spread instead
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-promise-reject-errors
Require using Error objects as Promise rejection reasons
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-regex-literals
Disallow use of the RegExp constructor in favor of regular expression literals
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-rest-params
Require rest parameters instead of arguments
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-spread
 ❄️ Frozen
Require spread operators instead of .apply()
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-template
 ❄️ Frozen
Require template literals instead of string concatenation
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



radix
Enforce the consistent use of the radix argument when using parseInt()
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



require-await
Disallow async functions which have no await expression
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



require-unicode-regexp
Enforce the use of u or v flag on regular expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



require-yield
Require generator functions to contain yield
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



sort-imports
 ❄️ Frozen
Enforce sorted import declarations within modules
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



sort-keys
 ❄️ Frozen
Require object keys to be sorted
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



sort-vars
 ❄️ Frozen
Require variables within the same declaration block to be sorted
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



strict
Require or disallow strict mode directives
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



symbol-description
Require symbol descriptions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



vars-on-top
 ❄️ Frozen
Require var declarations be placed at the top of their containing scope
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



yoda
 ❄️ Frozen
Require or disallow “Yoda” conditions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions

 Layout & Formatting 
These rules care about how the code looks rather than how it executes:

unicode-bom
Require or disallow Unicode byte order mark (BOM)
Categories:
✅ Extends

🔧 Fix


💡 Suggestions

Deprecated
These rules have been deprecated in accordance with the deprecation policy, and replaced by newer rules:

array-bracket-newline
deprecated
Replaced by
array-bracket-newline
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



array-bracket-spacing
deprecated
Replaced by
array-bracket-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



array-element-newline
deprecated
Replaced by
array-element-newline
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



arrow-parens
deprecated
Replaced by
arrow-parens
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



arrow-spacing
deprecated
Replaced by
arrow-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



block-spacing
deprecated
Replaced by
block-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



brace-style
deprecated
Replaced by
brace-style
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



callback-return
deprecated
Replaced by
callback-return
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



comma-dangle
deprecated
Replaced by
comma-dangle
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



comma-spacing
deprecated
Replaced by
comma-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



comma-style
deprecated
Replaced by
comma-style
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



computed-property-spacing
deprecated
Replaced by
computed-property-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



dot-location
deprecated
Replaced by
dot-location
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



eol-last
deprecated
Replaced by
eol-last
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



func-call-spacing
deprecated
Replaced by
function-call-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



function-call-argument-newline
deprecated
Replaced by
function-call-argument-newline
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



function-paren-newline
deprecated
Replaced by
function-paren-newline
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



generator-star-spacing
deprecated
Replaced by
generator-star-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



global-require
deprecated
Replaced by
global-require
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



handle-callback-err
deprecated
Replaced by
handle-callback-err
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



id-blacklist
deprecated
Replaced by
id-denylist

Categories:❌
🔧 Fix


💡 Suggestions



implicit-arrow-linebreak
deprecated
Replaced by
implicit-arrow-linebreak
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



indent
deprecated
Replaced by
indent
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



indent-legacy
deprecated
Replaced by
indent
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



jsx-quotes
deprecated
Replaced by
jsx-quotes
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



key-spacing
deprecated
Replaced by
key-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



keyword-spacing
deprecated
Replaced by
keyword-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



line-comment-position
deprecated
Replaced by
line-comment-position
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



linebreak-style
deprecated
Replaced by
linebreak-style
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



lines-around-comment
deprecated
Replaced by
lines-around-comment
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



lines-around-directive
deprecated
Replaced by
padding-line-between-statements
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



lines-between-class-members
deprecated
Replaced by
lines-between-class-members
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



max-len
deprecated
Replaced by
max-len
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



max-statements-per-line
deprecated
Replaced by
max-statements-per-line
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



multiline-comment-style
deprecated
Replaced by
multiline-comment-style
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



multiline-ternary
deprecated
Replaced by
multiline-ternary
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



new-parens
deprecated
Replaced by
new-parens
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



newline-after-var
deprecated
Replaced by
padding-line-between-statements
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



newline-before-return
deprecated
Replaced by
padding-line-between-statements
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



newline-per-chained-call
deprecated
Replaced by
newline-per-chained-call
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-buffer-constructor
deprecated
Replaced by
no-deprecated-api
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



no-catch-shadow
deprecated
Replaced by
no-shadow

Categories:❌
🔧 Fix


💡 Suggestions



no-confusing-arrow
deprecated
Replaced by
no-confusing-arrow
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-extra-parens
deprecated
Replaced by
no-extra-parens
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-extra-semi
deprecated
Replaced by
no-extra-semi
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-floating-decimal
deprecated
Replaced by
no-floating-decimal
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-mixed-operators
deprecated
Replaced by
no-mixed-operators
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-mixed-requires
deprecated
Replaced by
no-mixed-requires
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



no-mixed-spaces-and-tabs
deprecated
Replaced by
no-mixed-spaces-and-tabs
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-multi-spaces
deprecated
Replaced by
no-multi-spaces
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-multiple-empty-lines
deprecated
Replaced by
no-multiple-empty-lines
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-native-reassign
deprecated
Replaced by
no-global-assign

Categories:❌
🔧 Fix


💡 Suggestions



no-negated-in-lhs
deprecated
Replaced by
no-unsafe-negation

Categories:❌
🔧 Fix


💡 Suggestions



no-new-object
deprecated
Replaced by
no-object-constructor

Categories:❌
🔧 Fix


💡 Suggestions



no-new-require
deprecated
Replaced by
no-new-require
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



no-new-symbol
deprecated
Replaced by
no-new-native-nonconstructor

Categories:❌
🔧 Fix


💡 Suggestions



no-path-concat
deprecated
Replaced by
no-path-concat
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



no-process-env
deprecated
Replaced by
no-process-env
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



no-process-exit
deprecated
Replaced by
no-process-exit
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



no-restricted-modules
deprecated
Replaced by
no-restricted-require
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



no-return-await
deprecated

Categories:❌
🔧 Fix


💡 Suggestions



no-spaced-func
deprecated
Replaced by
function-call-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-sync
deprecated
Replaced by
no-sync
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



no-tabs
deprecated
Replaced by
no-tabs
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-trailing-spaces
deprecated
Replaced by
no-trailing-spaces
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-whitespace-before-property
deprecated
Replaced by
no-whitespace-before-property
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



nonblock-statement-body-position
deprecated
Replaced by
nonblock-statement-body-position
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



object-curly-newline
deprecated
Replaced by
object-curly-newline
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



object-curly-spacing
deprecated
Replaced by
object-curly-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



object-property-newline
deprecated
Replaced by
object-property-newline
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



one-var-declaration-per-line
deprecated
Replaced by
one-var-declaration-per-line
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



operator-linebreak
deprecated
Replaced by
operator-linebreak
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



padded-blocks
deprecated
Replaced by
padded-blocks
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



padding-line-between-statements
deprecated
Replaced by
padding-line-between-statements
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



prefer-reflect
deprecated

Categories:❌
🔧 Fix


💡 Suggestions



quote-props
deprecated
Replaced by
quote-props
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



quotes
deprecated
Replaced by
quotes
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



rest-spread-spacing
deprecated
Replaced by
rest-spread-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



semi
deprecated
Replaced by
semi
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



semi-spacing
deprecated
Replaced by
semi-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



semi-style
deprecated
Replaced by
semi-style
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



space-before-blocks
deprecated
Replaced by
space-before-blocks
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



space-before-function-paren
deprecated
Replaced by
space-before-function-paren
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



space-in-parens
deprecated
Replaced by
space-in-parens
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



space-infix-ops
deprecated
Replaced by
space-infix-ops
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



space-unary-ops
deprecated
Replaced by
space-unary-ops
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



spaced-comment
deprecated
Replaced by
spaced-comment
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



switch-colon-spacing
deprecated
Replaced by
switch-colon-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



template-curly-spacing
deprecated
Replaced by
template-curly-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



template-tag-spacing
deprecated
Replaced by
template-tag-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



wrap-iife
deprecated
Replaced by
wrap-iife
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



wrap-regex
deprecated
Replaced by
wrap-regex
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



yield-star-spacing
deprecated
Replaced by
yield-star-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions

Removed
These rules from older versions of ESLint (before the deprecation policy existed) have been replaced by newer rules:

generator-star
removed
Replaced by
generator-star-spacing


global-strict
removed
Replaced by
strict


no-arrow-condition
removed
Replaced by
no-confusing-arrow
or 
no-constant-condition


no-comma-dangle
removed
Replaced by
comma-dangle


no-empty-class
removed
Replaced by
no-empty-character-class


no-empty-label
removed
Replaced by
no-labels


no-extra-strict
removed
Replaced by
strict


no-reserved-keys
removed
Replaced by
quote-props


no-space-before-semi
removed
Replaced by
semi-spacing


no-wrap-func
removed
Replaced by
no-extra-parens


space-after-function-name
removed
Replaced by
space-before-function-paren


space-after-keywords
removed
Replaced by
keyword-spacing


space-before-function-parentheses
removed
Replaced by
space-before-function-paren


space-before-keywords
removed
Replaced by
keyword-spacing


space-in-brackets
removed
Replaced by
object-curly-spacing
or 
array-bracket-spacing


space-return-throw-case
removed
Replaced by
keyword-spacing


space-unary-word-ops
removed
Replaced by
space-unary-ops


spaced-line-comment
removed
Replaced by
spaced-comment


valid-jsdoc
removed


require-jsdoc
removed


            

            
                Edit this page\n\nRules Reference
                

                Table of Contents
    
        
                
                    
                    Possible Problems
            		

                    Suggestions
            		

                    Layout & Formatting
            		

                    Deprecated
            		

                    Removed
            		
                
            
    


                Rules in ESLint are grouped by type to help you understand their purpose. Each rule has emojis denoting:

        ✅ Recommended
        
            Using the recommended config from @eslint/js in a configuration file
            enables this rule
        
    
        🔧 Fixable
        
            Some problems reported by this rule are automatically fixable by the --fix command line option
        
    
        💡 hasSuggestions
        
            Some problems reported by this rule are manually fixable by editor suggestions
        
    
        ❄️ Frozen
        
            This rule is currently frozen and is not accepting feature requests.
        
     Possible Problems 
These rules relate to possible logic errors in code:

array-callback-return
Enforce return statements in callbacks of array methods
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



constructor-super
Require super() calls in constructors
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



for-direction
Enforce for loop update clause moving the counter in the right direction
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



getter-return
Enforce return statements in getters
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-async-promise-executor
Disallow using an async function as a Promise executor
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-await-in-loop
Disallow await inside of loops
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-class-assign
Disallow reassigning class members
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-compare-neg-zero
Disallow comparing against -0
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-cond-assign
Disallow assignment operators in conditional expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-const-assign
Disallow reassigning const variables
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-constant-binary-expression
Disallow expressions where the operation doesn’t affect the value
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-constant-condition
Disallow constant expressions in conditions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-constructor-return
Disallow returning value from constructor
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-control-regex
Disallow control characters in regular expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-debugger
Disallow the use of debugger
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-dupe-args
Disallow duplicate arguments in function definitions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-dupe-class-members
Disallow duplicate class members
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-dupe-else-if
Disallow duplicate conditions in if-else-if chains
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-dupe-keys
Disallow duplicate keys in object literals
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-duplicate-case
Disallow duplicate case labels
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-duplicate-imports
Disallow duplicate module imports
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-empty-character-class
Disallow empty character classes in regular expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-empty-pattern
Disallow empty destructuring patterns
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-ex-assign
Disallow reassigning exceptions in catch clauses
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-fallthrough
Disallow fallthrough of case statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-func-assign
Disallow reassigning function declarations
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-import-assign
Disallow assigning to imported bindings
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-inner-declarations
Disallow variable or function declarations in nested blocks
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-invalid-regexp
Disallow invalid regular expression strings in RegExp constructors
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-irregular-whitespace
Disallow irregular whitespace
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-loss-of-precision
Disallow literal numbers that lose precision
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-misleading-character-class
Disallow characters which are made with multiple code points in character class syntax
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-new-native-nonconstructor
Disallow new operators with global non-constructor functions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-obj-calls
Disallow calling global object properties as functions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-promise-executor-return
Disallow returning values from Promise executor functions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-prototype-builtins
Disallow calling some Object.prototype methods directly on objects
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-self-assign
Disallow assignments where both sides are exactly the same
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-self-compare
Disallow comparisons where both sides are exactly the same
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-setter-return
Disallow returning values from setters
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-sparse-arrays
Disallow sparse arrays
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-template-curly-in-string
Disallow template literal placeholder syntax in regular strings
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-this-before-super
Disallow this/super before calling super() in constructors
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-undef
Disallow the use of undeclared variables unless mentioned in /*global */ comments
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unexpected-multiline
Disallow confusing multiline expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unmodified-loop-condition
Disallow unmodified loop conditions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unreachable
Disallow unreachable code after return, throw, continue, and break statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unreachable-loop
Disallow loops with a body that allows only one iteration
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unsafe-finally
Disallow control flow statements in finally blocks
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unsafe-negation
Disallow negating the left operand of relational operators
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unsafe-optional-chaining
Disallow use of optional chaining in contexts where the undefined value is not allowed
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unused-private-class-members
Disallow unused private class members
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unused-vars
Disallow unused variables
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-use-before-define
Disallow the use of variables before they are defined
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-useless-assignment
Disallow variable assignments when the value is not used
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-useless-backreference
Disallow useless backreferences in regular expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



require-atomic-updates
Disallow assignments that can lead to race conditions due to usage of await or yield
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



use-isnan
Require calls to isNaN() when checking for NaN
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



valid-typeof
Enforce comparing typeof expressions against valid strings
Categories:
✅ Extends

🔧 Fix


💡 Suggestions

 Suggestions 
These rules suggest alternate ways of doing things:

accessor-pairs
Enforce getter and setter pairs in objects and classes
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



arrow-body-style
 ❄️ Frozen
Require braces around arrow function bodies
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



block-scoped-var
Enforce the use of variables within the scope they are defined
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



camelcase
 ❄️ Frozen
Enforce camelcase naming convention
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



capitalized-comments
 ❄️ Frozen
Enforce or disallow capitalization of the first letter of a comment
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



class-methods-use-this
Enforce that class methods utilize this
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



complexity
Enforce a maximum cyclomatic complexity allowed in a program
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



consistent-return
Require return statements to either always or never specify values
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



consistent-this
 ❄️ Frozen
Enforce consistent naming when capturing the current execution context
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



curly
 ❄️ Frozen
Enforce consistent brace style for all control statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



default-case
Require default cases in switch statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



default-case-last
Enforce default clauses in switch statements to be last
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



default-param-last
 ❄️ Frozen
Enforce default parameters to be last
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



dot-notation
 ❄️ Frozen
Enforce dot notation whenever possible
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



eqeqeq
Require the use of === and !==
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



func-name-matching
 ❄️ Frozen
Require function names to match the name of the variable or property to which they are assigned
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



func-names
Require or disallow named function expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



func-style
 ❄️ Frozen
Enforce the consistent use of either function declarations or expressions assigned to variables
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



grouped-accessor-pairs
Require grouped accessor pairs in object literals and classes
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



guard-for-in
Require for-in loops to include an if statement
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



id-denylist
 ❄️ Frozen
Disallow specified identifiers
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



id-length
 ❄️ Frozen
Enforce minimum and maximum identifier lengths
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



id-match
 ❄️ Frozen
Require identifiers to match a specified regular expression
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



init-declarations
 ❄️ Frozen
Require or disallow initialization in variable declarations
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



logical-assignment-operators
 ❄️ Frozen
Require or disallow logical assignment operator shorthand
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



max-classes-per-file
Enforce a maximum number of classes per file
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



max-depth
Enforce a maximum depth that blocks can be nested
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



max-lines
Enforce a maximum number of lines per file
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



max-lines-per-function
Enforce a maximum number of lines of code in a function
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



max-nested-callbacks
Enforce a maximum depth that callbacks can be nested
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



max-params
Enforce a maximum number of parameters in function definitions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



max-statements
Enforce a maximum number of statements allowed in function blocks
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



new-cap
Require constructor names to begin with a capital letter
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-alert
Disallow the use of alert, confirm, and prompt
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-array-constructor
Disallow Array constructors
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-bitwise
Disallow bitwise operators
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-caller
Disallow the use of arguments.caller or arguments.callee
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-case-declarations
Disallow lexical declarations in case clauses
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-console
Disallow the use of console
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-continue
 ❄️ Frozen
Disallow continue statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-delete-var
Disallow deleting variables
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-div-regex
 ❄️ Frozen
Disallow equal signs explicitly at the beginning of regular expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-else-return
 ❄️ Frozen
Disallow else blocks after return statements in if statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-empty
Disallow empty block statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-empty-function
Disallow empty functions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-empty-static-block
Disallow empty static blocks
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-eq-null
Disallow null comparisons without type-checking operators
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-eval
Disallow the use of eval()
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-extend-native
Disallow extending native types
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-extra-bind
Disallow unnecessary calls to .bind()
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-extra-boolean-cast
 ❄️ Frozen
Disallow unnecessary boolean casts
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-extra-label
 ❄️ Frozen
Disallow unnecessary labels
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-global-assign
Disallow assignments to native objects or read-only global variables
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-implicit-coercion
 ❄️ Frozen
Disallow shorthand type conversions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-implicit-globals
Disallow declarations in the global scope
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-implied-eval
Disallow the use of eval()-like methods
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-inline-comments
 ❄️ Frozen
Disallow inline comments after code
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-invalid-this
Disallow use of this in contexts where the value of this is undefined
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-iterator
Disallow the use of the __iterator__ property
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-label-var
 ❄️ Frozen
Disallow labels that share a name with a variable
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-labels
 ❄️ Frozen
Disallow labeled statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-lone-blocks
Disallow unnecessary nested blocks
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-lonely-if
 ❄️ Frozen
Disallow if statements as the only statement in else blocks
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-loop-func
Disallow function declarations that contain unsafe references inside loop statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-magic-numbers
 ❄️ Frozen
Disallow magic numbers
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-multi-assign
Disallow use of chained assignment expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-multi-str
 ❄️ Frozen
Disallow multiline strings
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-negated-condition
 ❄️ Frozen
Disallow negated conditions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-nested-ternary
 ❄️ Frozen
Disallow nested ternary expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-new
Disallow new operators outside of assignments or comparisons
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-new-func
Disallow new operators with the Function object
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-new-wrappers
Disallow new operators with the String, Number, and Boolean objects
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-nonoctal-decimal-escape
Disallow &#92;8 and &#92;9 escape sequences in string literals
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-object-constructor
Disallow calls to the Object constructor without an argument
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-octal
Disallow octal literals
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-octal-escape
Disallow octal escape sequences in string literals
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-param-reassign
Disallow reassigning function parameters
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-plusplus
 ❄️ Frozen
Disallow the unary operators ++ and --
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-proto
Disallow the use of the __proto__ property
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-redeclare
Disallow variable redeclaration
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-regex-spaces
Disallow multiple spaces in regular expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-restricted-exports
Disallow specified names in exports
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-restricted-globals
Disallow specified global variables
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-restricted-imports
Disallow specified modules when loaded by import
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-restricted-properties
Disallow certain properties on certain objects
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-restricted-syntax
Disallow specified syntax
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-return-assign
Disallow assignment operators in return statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-script-url
Disallow javascript: URLs
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-sequences
Disallow comma operators
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-shadow
Disallow variable declarations from shadowing variables declared in the outer scope
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-shadow-restricted-names
Disallow identifiers from shadowing restricted names
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-ternary
 ❄️ Frozen
Disallow ternary operators
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-throw-literal
Disallow throwing literals as exceptions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-undef-init
 ❄️ Frozen
Disallow initializing variables to undefined
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-undefined
 ❄️ Frozen
Disallow the use of undefined as an identifier
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-underscore-dangle
 ❄️ Frozen
Disallow dangling underscores in identifiers
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unneeded-ternary
 ❄️ Frozen
Disallow ternary operators when simpler alternatives exist
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unused-expressions
Disallow unused expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-unused-labels
Disallow unused labels
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-useless-call
Disallow unnecessary calls to .call() and .apply()
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-useless-catch
Disallow unnecessary catch clauses
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-useless-computed-key
 ❄️ Frozen
Disallow unnecessary computed property keys in objects and classes
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-useless-concat
 ❄️ Frozen
Disallow unnecessary concatenation of literals or template literals
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-useless-constructor
Disallow unnecessary constructors
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-useless-escape
Disallow unnecessary escape characters
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-useless-rename
Disallow renaming import, export, and destructured assignments to the same name
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-useless-return
Disallow redundant return statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-var
Require let or const instead of var
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-void
 ❄️ Frozen
Disallow void operators
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-warning-comments
 ❄️ Frozen
Disallow specified warning terms in comments
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



no-with
Disallow with statements
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



object-shorthand
 ❄️ Frozen
Require or disallow method and property shorthand syntax for object literals
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



one-var
 ❄️ Frozen
Enforce variables to be declared either together or separately in functions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



operator-assignment
 ❄️ Frozen
Require or disallow assignment operator shorthand where possible
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-arrow-callback
 ❄️ Frozen
Require using arrow functions for callbacks
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-const
Require const declarations for variables that are never reassigned after declared
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-destructuring
 ❄️ Frozen
Require destructuring from arrays and/or objects
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-exponentiation-operator
 ❄️ Frozen
Disallow the use of Math.pow in favor of the ** operator
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-named-capture-group
Enforce using named capture group in regular expression
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-numeric-literals
 ❄️ Frozen
Disallow parseInt() and Number.parseInt() in favor of binary, octal, and hexadecimal literals
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-object-has-own
Disallow use of Object.prototype.hasOwnProperty.call() and prefer use of Object.hasOwn()
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-object-spread
 ❄️ Frozen
Disallow using Object.assign with an object literal as the first argument and prefer the use of object spread instead
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-promise-reject-errors
Require using Error objects as Promise rejection reasons
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-regex-literals
Disallow use of the RegExp constructor in favor of regular expression literals
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-rest-params
Require rest parameters instead of arguments
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-spread
 ❄️ Frozen
Require spread operators instead of .apply()
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



prefer-template
 ❄️ Frozen
Require template literals instead of string concatenation
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



radix
Enforce the consistent use of the radix argument when using parseInt()
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



require-await
Disallow async functions which have no await expression
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



require-unicode-regexp
Enforce the use of u or v flag on regular expressions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



require-yield
Require generator functions to contain yield
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



sort-imports
 ❄️ Frozen
Enforce sorted import declarations within modules
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



sort-keys
 ❄️ Frozen
Require object keys to be sorted
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



sort-vars
 ❄️ Frozen
Require variables within the same declaration block to be sorted
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



strict
Require or disallow strict mode directives
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



symbol-description
Require symbol descriptions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



vars-on-top
 ❄️ Frozen
Require var declarations be placed at the top of their containing scope
Categories:
✅ Extends

🔧 Fix


💡 Suggestions



yoda
 ❄️ Frozen
Require or disallow “Yoda” conditions
Categories:
✅ Extends

🔧 Fix


💡 Suggestions

 Layout & Formatting 
These rules care about how the code looks rather than how it executes:

unicode-bom
Require or disallow Unicode byte order mark (BOM)
Categories:
✅ Extends

🔧 Fix


💡 Suggestions

Deprecated
These rules have been deprecated in accordance with the deprecation policy, and replaced by newer rules:

array-bracket-newline
deprecated
Replaced by
array-bracket-newline
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



array-bracket-spacing
deprecated
Replaced by
array-bracket-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



array-element-newline
deprecated
Replaced by
array-element-newline
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



arrow-parens
deprecated
Replaced by
arrow-parens
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



arrow-spacing
deprecated
Replaced by
arrow-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



block-spacing
deprecated
Replaced by
block-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



brace-style
deprecated
Replaced by
brace-style
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



callback-return
deprecated
Replaced by
callback-return
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



comma-dangle
deprecated
Replaced by
comma-dangle
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



comma-spacing
deprecated
Replaced by
comma-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



comma-style
deprecated
Replaced by
comma-style
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



computed-property-spacing
deprecated
Replaced by
computed-property-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



dot-location
deprecated
Replaced by
dot-location
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



eol-last
deprecated
Replaced by
eol-last
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



func-call-spacing
deprecated
Replaced by
function-call-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



function-call-argument-newline
deprecated
Replaced by
function-call-argument-newline
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



function-paren-newline
deprecated
Replaced by
function-paren-newline
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



generator-star-spacing
deprecated
Replaced by
generator-star-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



global-require
deprecated
Replaced by
global-require
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



handle-callback-err
deprecated
Replaced by
handle-callback-err
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



id-blacklist
deprecated
Replaced by
id-denylist

Categories:❌
🔧 Fix


💡 Suggestions



implicit-arrow-linebreak
deprecated
Replaced by
implicit-arrow-linebreak
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



indent
deprecated
Replaced by
indent
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



indent-legacy
deprecated
Replaced by
indent
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



jsx-quotes
deprecated
Replaced by
jsx-quotes
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



key-spacing
deprecated
Replaced by
key-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



keyword-spacing
deprecated
Replaced by
keyword-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



line-comment-position
deprecated
Replaced by
line-comment-position
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



linebreak-style
deprecated
Replaced by
linebreak-style
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



lines-around-comment
deprecated
Replaced by
lines-around-comment
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



lines-around-directive
deprecated
Replaced by
padding-line-between-statements
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



lines-between-class-members
deprecated
Replaced by
lines-between-class-members
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



max-len
deprecated
Replaced by
max-len
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



max-statements-per-line
deprecated
Replaced by
max-statements-per-line
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



multiline-comment-style
deprecated
Replaced by
multiline-comment-style
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



multiline-ternary
deprecated
Replaced by
multiline-ternary
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



new-parens
deprecated
Replaced by
new-parens
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



newline-after-var
deprecated
Replaced by
padding-line-between-statements
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



newline-before-return
deprecated
Replaced by
padding-line-between-statements
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



newline-per-chained-call
deprecated
Replaced by
newline-per-chained-call
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-buffer-constructor
deprecated
Replaced by
no-deprecated-api
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



no-catch-shadow
deprecated
Replaced by
no-shadow

Categories:❌
🔧 Fix


💡 Suggestions



no-confusing-arrow
deprecated
Replaced by
no-confusing-arrow
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-extra-parens
deprecated
Replaced by
no-extra-parens
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-extra-semi
deprecated
Replaced by
no-extra-semi
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-floating-decimal
deprecated
Replaced by
no-floating-decimal
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-mixed-operators
deprecated
Replaced by
no-mixed-operators
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-mixed-requires
deprecated
Replaced by
no-mixed-requires
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



no-mixed-spaces-and-tabs
deprecated
Replaced by
no-mixed-spaces-and-tabs
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-multi-spaces
deprecated
Replaced by
no-multi-spaces
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-multiple-empty-lines
deprecated
Replaced by
no-multiple-empty-lines
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-native-reassign
deprecated
Replaced by
no-global-assign

Categories:❌
🔧 Fix


💡 Suggestions



no-negated-in-lhs
deprecated
Replaced by
no-unsafe-negation

Categories:❌
🔧 Fix


💡 Suggestions



no-new-object
deprecated
Replaced by
no-object-constructor

Categories:❌
🔧 Fix


💡 Suggestions



no-new-require
deprecated
Replaced by
no-new-require
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



no-new-symbol
deprecated
Replaced by
no-new-native-nonconstructor

Categories:❌
🔧 Fix


💡 Suggestions



no-path-concat
deprecated
Replaced by
no-path-concat
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



no-process-env
deprecated
Replaced by
no-process-env
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



no-process-exit
deprecated
Replaced by
no-process-exit
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



no-restricted-modules
deprecated
Replaced by
no-restricted-require
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



no-return-await
deprecated

Categories:❌
🔧 Fix


💡 Suggestions



no-spaced-func
deprecated
Replaced by
function-call-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-sync
deprecated
Replaced by
no-sync
 in eslint-plugin-n 
Categories:❌
🔧 Fix


💡 Suggestions



no-tabs
deprecated
Replaced by
no-tabs
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-trailing-spaces
deprecated
Replaced by
no-trailing-spaces
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



no-whitespace-before-property
deprecated
Replaced by
no-whitespace-before-property
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



nonblock-statement-body-position
deprecated
Replaced by
nonblock-statement-body-position
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



object-curly-newline
deprecated
Replaced by
object-curly-newline
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



object-curly-spacing
deprecated
Replaced by
object-curly-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



object-property-newline
deprecated
Replaced by
object-property-newline
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



one-var-declaration-per-line
deprecated
Replaced by
one-var-declaration-per-line
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



operator-linebreak
deprecated
Replaced by
operator-linebreak
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



padded-blocks
deprecated
Replaced by
padded-blocks
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



padding-line-between-statements
deprecated
Replaced by
padding-line-between-statements
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



prefer-reflect
deprecated

Categories:❌
🔧 Fix


💡 Suggestions



quote-props
deprecated
Replaced by
quote-props
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



quotes
deprecated
Replaced by
quotes
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



rest-spread-spacing
deprecated
Replaced by
rest-spread-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



semi
deprecated
Replaced by
semi
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



semi-spacing
deprecated
Replaced by
semi-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



semi-style
deprecated
Replaced by
semi-style
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



space-before-blocks
deprecated
Replaced by
space-before-blocks
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



space-before-function-paren
deprecated
Replaced by
space-before-function-paren
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



space-in-parens
deprecated
Replaced by
space-in-parens
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



space-infix-ops
deprecated
Replaced by
space-infix-ops
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



space-unary-ops
deprecated
Replaced by
space-unary-ops
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



spaced-comment
deprecated
Replaced by
spaced-comment
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



switch-colon-spacing
deprecated
Replaced by
switch-colon-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



template-curly-spacing
deprecated
Replaced by
template-curly-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



template-tag-spacing
deprecated
Replaced by
template-tag-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



wrap-iife
deprecated
Replaced by
wrap-iife
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



wrap-regex
deprecated
Replaced by
wrap-regex
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions



yield-star-spacing
deprecated
Replaced by
yield-star-spacing
 in @stylistic/eslint-plugin-js 
Categories:❌
🔧 Fix


💡 Suggestions

Removed
These rules from older versions of ESLint (before the deprecation policy existed) have been replaced by newer rules:

generator-star
removed
Replaced by
generator-star-spacing


global-strict
removed
Replaced by
strict


no-arrow-condition
removed
Replaced by
no-confusing-arrow
or 
no-constant-condition


no-comma-dangle
removed
Replaced by
comma-dangle


no-empty-class
removed
Replaced by
no-empty-character-class


no-empty-label
removed
Replaced by
no-labels


no-extra-strict
removed
Replaced by
strict


no-reserved-keys
removed
Replaced by
quote-props


no-space-before-semi
removed
Replaced by
semi-spacing


no-wrap-func
removed
Replaced by
no-extra-parens


space-after-function-name
removed
Replaced by
space-before-function-paren


space-after-keywords
removed
Replaced by
keyword-spacing


space-before-function-parentheses
removed
Replaced by
space-before-function-paren


space-before-keywords
removed
Replaced by
keyword-spacing


space-in-brackets
removed
Replaced by
object-curly-spacing
or 
array-bracket-spacing


space-return-throw-case
removed
Replaced by
keyword-spacing


space-unary-word-ops
removed
Replaced by
space-unary-ops


spaced-line-comment
removed
Replaced by
spaced-comment


valid-jsdoc
removed


require-jsdoc
removed


            

            
                Edit this page\n\n\n\nFeature Flags
                

                Table of Contents
    
        
                
                    
                    Flag Prefixes
            		

                    Active Flags
            		

                    Inactive Flags
            		

                    How to Use Feature Flags
            
                
                    
                    Enable Feature Flags with the CLI
            		

                    Enable Feature Flags with the API
            		

                    Enable Feature Flags in VS Code
            		
                
            		
                
            
    


                ESLint ships experimental and future breaking changes behind feature flags to let users opt-in to behavior they want. Flags are used in these situations:

When a feature is experimental and not ready to be enabled for everyone.
When a feature is a breaking change that will be formally merged in the next major release, but users may opt-in to that behavior prior to the next major release.

Flag Prefixes
The prefix of a flag indicates its status:

unstable_ indicates that the feature is experimental and the implementation may change before the feature is stabilized. This is a “use at your own risk” feature.
v##_ indicates that the feature is stabilized and will be available in the next major release. For example, v10_some_feature indicates that this is a breaking change that will be formally released in ESLint v10.0.0. These flags are removed each major release, and further use of them throws an error.

A feature may move from unstable to being enabled by default without a major release if it is a non-breaking change.
The following policies apply to unstable_ flags.

When the feature is stabilized

If enabling the feature by default would be a breaking change, a new v##_ flag is added as active, and the unstable_ flag becomes inactive. Further use of the unstable_ flag automatically enables the v##_ flag but emits a warning.
Otherwise, the feature is enabled by default, and the unstable_ flag becomes inactive. Further use of the unstable_ flag emits a warning.


If the feature is abandoned, the unstable_ flag becomes inactive. Further use of it throws an error.
All inactive unstable_ flags are removed each major release, and further use of them throws an error.

Active Flags
The following flags are currently available for use in ESLint.

    
        
            Flag
            Description
        
    
    unstable_config_lookup_from_fileLook up `eslint.config.js` from the file being linted.unstable_native_nodejs_ts_configUse native Node.js to load TypeScript configuration.

Inactive Flags
The following flags were once used but are no longer active.

    
        
            Flag
            Description
            Inactivity Reason
        
    
    unstable_ts_configEnable TypeScript configuration files.This feature is now enabled by default.

How to Use Feature Flags
Because feature flags are strictly opt-in, you need to manually enable the flags that you want.
Enable Feature Flags with the CLI
On the command line, you can specify feature flags using the --flag option. You can specify as many flags as you’d like:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --flag flag_one --flag flag_two file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --flag flag_one --flag flag_two file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --flag flag_one --flag flag_two file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --flag flag_one --flag flag_two file.js 
1
    
        Copy code to clipboard
        
    

   

Enable Feature Flags with the API
When using the API, you can pass a flags array to both the ESLint and Linter classes:


    const { ESLint, Linter } = require("eslint");

const eslint = new ESLint({
	flags: ["flag_one", "flag_two"],
});

const linter = new Linter({
	flags: ["flag_one", "flag_two"],
});
123456789
    
        Copy code to clipboard
        
    

Enable Feature Flags in VS Code
To enable flags in the VS Code ESLint Extension for the editor, specify the flags you’d like in the eslint.options setting in your settings.json file:


    {
	"eslint.options": { "flags": ["flag_one", "flag_two"] }
}
123
    
        Copy code to clipboard
        
    

To enable flags in the VS Code ESLint Extension for a lint task, specify the eslint.lintTask.options settings:


    {
	"eslint.lintTask.options": "--flag flag_one --flag flag_two ."
}
123
    
        Copy code to clipboard
        
    


            

            
                Edit this page\n\nFeature Flags
                

                Table of Contents
    
        
                
                    
                    Flag Prefixes
            		

                    Active Flags
            		

                    Inactive Flags
            		

                    How to Use Feature Flags
            
                
                    
                    Enable Feature Flags with the CLI
            		

                    Enable Feature Flags with the API
            		

                    Enable Feature Flags in VS Code
            		
                
            		
                
            
    


                ESLint ships experimental and future breaking changes behind feature flags to let users opt-in to behavior they want. Flags are used in these situations:

When a feature is experimental and not ready to be enabled for everyone.
When a feature is a breaking change that will be formally merged in the next major release, but users may opt-in to that behavior prior to the next major release.

Flag Prefixes
The prefix of a flag indicates its status:

unstable_ indicates that the feature is experimental and the implementation may change before the feature is stabilized. This is a “use at your own risk” feature.
v##_ indicates that the feature is stabilized and will be available in the next major release. For example, v10_some_feature indicates that this is a breaking change that will be formally released in ESLint v10.0.0. These flags are removed each major release, and further use of them throws an error.

A feature may move from unstable to being enabled by default without a major release if it is a non-breaking change.
The following policies apply to unstable_ flags.

When the feature is stabilized

If enabling the feature by default would be a breaking change, a new v##_ flag is added as active, and the unstable_ flag becomes inactive. Further use of the unstable_ flag automatically enables the v##_ flag but emits a warning.
Otherwise, the feature is enabled by default, and the unstable_ flag becomes inactive. Further use of the unstable_ flag emits a warning.


If the feature is abandoned, the unstable_ flag becomes inactive. Further use of it throws an error.
All inactive unstable_ flags are removed each major release, and further use of them throws an error.

Active Flags
The following flags are currently available for use in ESLint.

    
        
            Flag
            Description
        
    
    unstable_config_lookup_from_fileLook up `eslint.config.js` from the file being linted.unstable_native_nodejs_ts_configUse native Node.js to load TypeScript configuration.

Inactive Flags
The following flags were once used but are no longer active.

    
        
            Flag
            Description
            Inactivity Reason
        
    
    unstable_ts_configEnable TypeScript configuration files.This feature is now enabled by default.

How to Use Feature Flags
Because feature flags are strictly opt-in, you need to manually enable the flags that you want.
Enable Feature Flags with the CLI
On the command line, you can specify feature flags using the --flag option. You can specify as many flags as you’d like:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint --flag flag_one --flag flag_two file.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint --flag flag_one --flag flag_two file.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint --flag flag_one --flag flag_two file.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint --flag flag_one --flag flag_two file.js 
1
    
        Copy code to clipboard
        
    

   

Enable Feature Flags with the API
When using the API, you can pass a flags array to both the ESLint and Linter classes:


    const { ESLint, Linter } = require("eslint");

const eslint = new ESLint({
	flags: ["flag_one", "flag_two"],
});

const linter = new Linter({
	flags: ["flag_one", "flag_two"],
});
123456789
    
        Copy code to clipboard
        
    

Enable Feature Flags in VS Code
To enable flags in the VS Code ESLint Extension for the editor, specify the flags you’d like in the eslint.options setting in your settings.json file:


    {
	"eslint.options": { "flags": ["flag_one", "flag_two"] }
}
123
    
        Copy code to clipboard
        
    

To enable flags in the VS Code ESLint Extension for a lint task, specify the eslint.lintTask.options settings:


    {
	"eslint.lintTask.options": "--flag flag_one --flag flag_two ."
}
123
    
        Copy code to clipboard
        
    


            

            
                Edit this page\n\n\n\nFormatters Reference
                

                Table of Contents
    
        
                
                    
                    Example Source
            		

                    Built-In Formatter Options
            
                
                    
                    html
            		

                    json-with-metadata
            		

                    json
            		

                    stylish
            		
                
            		
                
            
    


                ESLint comes with several built-in formatters to control the appearance of the linting results, and supports third-party formatters as well.
You can specify a formatter using the --format or -f flag in the CLI. For example, --format json uses the json formatter.
The built-in formatter options are:

html
json-with-metadata
json
stylish

Example Source
Examples of each formatter were created from linting fullOfProblems.js using the .eslintrc.json configuration shown below.
fullOfProblems.js:


    function addOne(i) {
    if (i != NaN) {
        return i ++
    } else {
      return
    }
};
1234567
    
        Copy code to clipboard
        
    

.eslintrc.json:


    {
    "extends": "eslint:recommended",
    "rules": {
        "consistent-return": 2,
        "indent"           : [1, 4],
        "no-else-return"   : 1,
        "semi"             : [1, "always"],
        "space-unary-ops"  : 2
    }
}
12345678910
    
        Copy code to clipboard
        
    

Tests the formatters with the CLI:


    npx eslint --format <Add formatter here> fullOfProblems.js
1
    
        Copy code to clipboard
        
    

Built-In Formatter Options
html
Outputs results to HTML. The html formatter is useful for visual presentation in the browser.
Example output:

json-with-metadata
Outputs JSON-serialized results. The json-with-metadata provides the same linting results as the json formatter with additional metadata about the rules applied. The linting results are included in the results property and the rules metadata is included in the metadata property.
Alternatively, you can use the ESLint Node.js API to programmatically use ESLint.
Example output (formatted for easier reading):


    {
    "results": [
        {
            "filePath": "/var/lib/jenkins/workspace/eslint Release/eslint/fullOfProblems.js",
            "messages": [
                {
                    "ruleId": "no-unused-vars",
                    "severity": 2,
                    "message": "'addOne' is defined but never used.",
                    "line": 1,
                    "column": 10,
                    "nodeType": "Identifier",
                    "messageId": "unusedVar",
                    "endLine": 1,
                    "endColumn": 16,
                    "suggestions": [
                        {
                            "messageId": "removeVar",
                            "data": {
                                "varName": "addOne"
                            },
                            "fix": {
                                "range": [
                                    0,
                                    94
                                ],
                                "text": ""
                            },
                            "desc": "Remove unused variable 'addOne'."
                        }
                    ]
                },
                {
                    "ruleId": "use-isnan",
                    "severity": 2,
                    "message": "Use the isNaN function to compare with NaN.",
                    "line": 2,
                    "column": 9,
                    "nodeType": "BinaryExpression",
                    "messageId": "comparisonWithNaN",
                    "endLine": 2,
                    "endColumn": 17,
                    "suggestions": [
                        {
                            "messageId": "replaceWithIsNaN",
                            "fix": {
                                "range": [
                                    29,
                                    37
                                ],
                                "text": "!Number.isNaN(i)"
                            },
                            "desc": "Replace with Number.isNaN."
                        },
                        {
                            "messageId": "replaceWithCastingAndIsNaN",
                            "fix": {
                                "range": [
                                    29,
                                    37
                                ],
                                "text": "!Number.isNaN(Number(i))"
                            },
                            "desc": "Replace with Number.isNaN and cast to a Number."
                        }
                    ]
                },
                {
                    "ruleId": "space-unary-ops",
                    "severity": 2,
                    "message": "Unexpected space before unary operator '++'.",
                    "line": 3,
                    "column": 16,
                    "nodeType": "UpdateExpression",
                    "messageId": "unexpectedBefore",
                    "endLine": 3,
                    "endColumn": 20,
                    "fix": {
                        "range": [
                            57,
                            58
                        ],
                        "text": ""
                    }
                },
                {
                    "ruleId": "semi",
                    "severity": 1,
                    "message": "Missing semicolon.",
                    "line": 3,
                    "column": 20,
                    "nodeType": "ReturnStatement",
                    "messageId": "missingSemi",
                    "endLine": 4,
                    "endColumn": 1,
                    "fix": {
                        "range": [
                            60,
                            60
                        ],
                        "text": ";"
                    }
                },
                {
                    "ruleId": "no-else-return",
                    "severity": 1,
                    "message": "Unnecessary 'else' after 'return'.",
                    "line": 4,
                    "column": 12,
                    "nodeType": "BlockStatement",
                    "messageId": "unexpected",
                    "endLine": 6,
                    "endColumn": 6,
                    "fix": {
                        "range": [
                            0,
                            94
                        ],
                        "text": "function addOne(i) {\n    if (i != NaN) {\n        return i ++\n    } \n      return\n    \n}"
                    }
                },
                {
                    "ruleId": "indent",
                    "severity": 1,
                    "message": "Expected indentation of 8 spaces but found 6.",
                    "line": 5,
                    "column": 1,
                    "nodeType": "Keyword",
                    "messageId": "wrongIndentation",
                    "endLine": 5,
                    "endColumn": 7,
                    "fix": {
                        "range": [
                            74,
                            80
                        ],
                        "text": "        "
                    }
                },
                {
                    "ruleId": "consistent-return",
                    "severity": 2,
                    "message": "Function 'addOne' expected a return value.",
                    "line": 5,
                    "column": 7,
                    "nodeType": "ReturnStatement",
                    "messageId": "missingReturnValue",
                    "endLine": 5,
                    "endColumn": 13
                },
                {
                    "ruleId": "semi",
                    "severity": 1,
                    "message": "Missing semicolon.",
                    "line": 5,
                    "column": 13,
                    "nodeType": "ReturnStatement",
                    "messageId": "missingSemi",
                    "endLine": 6,
                    "endColumn": 1,
                    "fix": {
                        "range": [
                            86,
                            86
                        ],
                        "text": ";"
                    }
                }
            ],
            "suppressedMessages": [],
            "errorCount": 4,
            "fatalErrorCount": 0,
            "warningCount": 4,
            "fixableErrorCount": 1,
            "fixableWarningCount": 4,
            "source": "function addOne(i) {\n    if (i != NaN) {\n        return i ++\n    } else {\n      return\n    }\n};"
        }
    ],
    "metadata": {
        "rulesMeta": {
            "no-else-return": {
                "type": "suggestion",
                "defaultOptions": [
                    {
                        "allowElseIf": true
                    }
                ],
                "docs": {
                    "description": "Disallow `else` blocks after `return` statements in `if` statements",
                    "recommended": false,
                    "frozen": true,
                    "url": "https://eslint.org/docs/latest/rules/no-else-return"
                },
                "schema": [
                    {
                        "type": "object",
                        "properties": {
                            "allowElseIf": {
                                "type": "boolean"
                            }
                        },
                        "additionalProperties": false
                    }
                ],
                "fixable": "code",
                "messages": {
                    "unexpected": "Unnecessary 'else' after 'return'."
                }
            },
            "indent": {
                "deprecated": {
                    "message": "Formatting rules are being moved out of ESLint core.",
                    "url": "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
                    "deprecatedSince": "8.53.0",
                    "availableUntil": "10.0.0",
                    "replacedBy": [
                        {
                            "message": "ESLint Stylistic now maintains deprecated stylistic core rules.",
                            "url": "https://eslint.style/guide/migration",
                            "plugin": {
                                "name": "@stylistic/eslint-plugin-js",
                                "url": "https://eslint.style/packages/js"
                            },
                            "rule": {
                                "name": "indent",
                                "url": "https://eslint.style/rules/js/indent"
                            }
                        }
                    ]
                },
                "type": "layout",
                "docs": {
                    "description": "Enforce consistent indentation",
                    "recommended": false,
                    "url": "https://eslint.org/docs/latest/rules/indent"
                },
                "fixable": "whitespace",
                "schema": [
                    {
                        "oneOf": [
                            {
                                "enum": [
                                    "tab"
                                ]
                            },
                            {
                                "type": "integer",
                                "minimum": 0
                            }
                        ]
                    },
                    {
                        "type": "object",
                        "properties": {
                            "SwitchCase": {
                                "type": "integer",
                                "minimum": 0,
                                "default": 0
                            },
                            "VariableDeclarator": {
                                "oneOf": [
                                    {
                                        "oneOf": [
                                            {
                                                "type": "integer",
                                                "minimum": 0
                                            },
                                            {
                                                "enum": [
                                                    "first",
                                                    "off"
                                                ]
                                            }
                                        ]
                                    },
                                    {
                                        "type": "object",
                                        "properties": {
                                            "var": {
                                                "oneOf": [
                                                    {
                                                        "type": "integer",
                                                        "minimum": 0
                                                    },
                                                    {
                                                        "enum": [
                                                            "first",
                                                            "off"
                                                        ]
                                                    }
                                                ]
                                            },
                                            "let": {
                                                "oneOf": [
                                                    {
                                                        "type": "integer",
                                                        "minimum": 0
                                                    },
                                                    {
                                                        "enum": [
                                                            "first",
                                                            "off"
                                                        ]
                                                    }
                                                ]
                                            },
                                            "const": {
                                                "oneOf": [
                                                    {
                                                        "type": "integer",
                                                        "minimum": 0
                                                    },
                                                    {
                                                        "enum": [
                                                            "first",
                                                            "off"
                                                        ]
                                                    }
                                                ]
                                            }
                                        },
                                        "additionalProperties": false
                                    }
                                ]
                            },
                            "outerIIFEBody": {
                                "oneOf": [
                                    {
                                        "type": "integer",
                                        "minimum": 0
                                    },
                                    {
                                        "enum": [
                                            "off"
                                        ]
                                    }
                                ]
                            },
                            "MemberExpression": {
                                "oneOf": [
                                    {
                                        "type": "integer",
                                        "minimum": 0
                                    },
                                    {
                                        "enum": [
                                            "off"
                                        ]
                                    }
                                ]
                            },
                            "FunctionDeclaration": {
                                "type": "object",
                                "properties": {
                                    "parameters": {
                                        "oneOf": [
                                            {
                                                "type": "integer",
                                                "minimum": 0
                                            },
                                            {
                                                "enum": [
                                                    "first",
                                                    "off"
                                                ]
                                            }
                                        ]
                                    },
                                    "body": {
                                        "type": "integer",
                                        "minimum": 0
                                    }
                                },
                                "additionalProperties": false
                            },
                            "FunctionExpression": {
                                "type": "object",
                                "properties": {
                                    "parameters": {
                                        "oneOf": [
                                            {
                                                "type": "integer",
                                                "minimum": 0
                                            },
                                            {
                                                "enum": [
                                                    "first",
                                                    "off"
                                                ]
                                            }
                                        ]
                                    },
                                    "body": {
                                        "type": "integer",
                                        "minimum": 0
                                    }
                                },
                                "additionalProperties": false
                            },
                            "StaticBlock": {
                                "type": "object",
                                "properties": {
                                    "body": {
                                        "type": "integer",
                                        "minimum": 0
                                    }
                                },
                                "additionalProperties": false
                            },
                            "CallExpression": {
                                "type": "object",
                                "properties": {
                                    "arguments": {
                                        "oneOf": [
                                            {
                                                "type": "integer",
                                                "minimum": 0
                                            },
                                            {
                                                "enum": [
                                                    "first",
                                                    "off"
                                                ]
                                            }
                                        ]
                                    }
                                },
                                "additionalProperties": false
                            },
                            "ArrayExpression": {
                                "oneOf": [
                                    {
                                        "type": "integer",
                                        "minimum": 0
                                    },
                                    {
                                        "enum": [
                                            "first",
                                            "off"
                                        ]
                                    }
                                ]
                            },
                            "ObjectExpression": {
                                "oneOf": [
                                    {
                                        "type": "integer",
                                        "minimum": 0
                                    },
                                    {
                                        "enum": [
                                            "first",
                                            "off"
                                        ]
                                    }
                                ]
                            },
                            "ImportDeclaration": {
                                "oneOf": [
                                    {
                                        "type": "integer",
                                        "minimum": 0
                                    },
                                    {
                                        "enum": [
                                            "first",
                                            "off"
                                        ]
                                    }
                                ]
                            },
                            "flatTernaryExpressions": {
                                "type": "boolean",
                                "default": false
                            },
                            "offsetTernaryExpressions": {
                                "type": "boolean",
                                "default": false
                            },
                            "ignoredNodes": {
                                "type": "array",
                                "items": {
                                    "type": "string",
                                    "not": {
                                        "pattern": ":exit$"
                                    }
                                }
                            },
                            "ignoreComments": {
                                "type": "boolean",
                                "default": false
                            }
                        },
                        "additionalProperties": false
                    }
                ],
                "messages": {
                    "wrongIndentation": "Expected indentation of  but found ."
                }
            },
            "space-unary-ops": {
                "deprecated": {
                    "message": "Formatting rules are being moved out of ESLint core.",
                    "url": "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
                    "deprecatedSince": "8.53.0",
                    "availableUntil": "10.0.0",
                    "replacedBy": [
                        {
                            "message": "ESLint Stylistic now maintains deprecated stylistic core rules.",
                            "url": "https://eslint.style/guide/migration",
                            "plugin": {
                                "name": "@stylistic/eslint-plugin-js",
                                "url": "https://eslint.style/packages/js"
                            },
                            "rule": {
                                "name": "space-unary-ops",
                                "url": "https://eslint.style/rules/js/space-unary-ops"
                            }
                        }
                    ]
                },
                "type": "layout",
                "docs": {
                    "description": "Enforce consistent spacing before or after unary operators",
                    "recommended": false,
                    "url": "https://eslint.org/docs/latest/rules/space-unary-ops"
                },
                "fixable": "whitespace",
                "schema": [
                    {
                        "type": "object",
                        "properties": {
                            "words": {
                                "type": "boolean",
                                "default": true
                            },
                            "nonwords": {
                                "type": "boolean",
                                "default": false
                            },
                            "overrides": {
                                "type": "object",
                                "additionalProperties": {
                                    "type": "boolean"
                                }
                            }
                        },
                        "additionalProperties": false
                    }
                ],
                "messages": {
                    "unexpectedBefore": "Unexpected space before unary operator ''.",
                    "unexpectedAfter": "Unexpected space after unary operator ''.",
                    "unexpectedAfterWord": "Unexpected space after unary word operator ''.",
                    "wordOperator": "Unary word operator '' must be followed by whitespace.",
                    "operator": "Unary operator '' must be followed by whitespace.",
                    "beforeUnaryExpressions": "Space is required before unary expressions ''."
                }
            },
            "semi": {
                "deprecated": {
                    "message": "Formatting rules are being moved out of ESLint core.",
                    "url": "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
                    "deprecatedSince": "8.53.0",
                    "availableUntil": "10.0.0",
                    "replacedBy": [
                        {
                            "message": "ESLint Stylistic now maintains deprecated stylistic core rules.",
                            "url": "https://eslint.style/guide/migration",
                            "plugin": {
                                "name": "@stylistic/eslint-plugin-js",
                                "url": "https://eslint.style/packages/js"
                            },
                            "rule": {
                                "name": "semi",
                                "url": "https://eslint.style/rules/js/semi"
                            }
                        }
                    ]
                },
                "type": "layout",
                "docs": {
                    "description": "Require or disallow semicolons instead of ASI",
                    "recommended": false,
                    "url": "https://eslint.org/docs/latest/rules/semi"
                },
                "fixable": "code",
                "schema": {
                    "anyOf": [
                        {
                            "type": "array",
                            "items": [
                                {
                                    "enum": [
                                        "never"
                                    ]
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "beforeStatementContinuationChars": {
                                            "enum": [
                                                "always",
                                                "any",
                                                "never"
                                            ]
                                        }
                                    },
                                    "additionalProperties": false
                                }
                            ],
                            "minItems": 0,
                            "maxItems": 2
                        },
                        {
                            "type": "array",
                            "items": [
                                {
                                    "enum": [
                                        "always"
                                    ]
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "omitLastInOneLineBlock": {
                                            "type": "boolean"
                                        },
                                        "omitLastInOneLineClassBody": {
                                            "type": "boolean"
                                        }
                                    },
                                    "additionalProperties": false
                                }
                            ],
                            "minItems": 0,
                            "maxItems": 2
                        }
                    ]
                },
                "messages": {
                    "missingSemi": "Missing semicolon.",
                    "extraSemi": "Extra semicolon."
                }
            },
            "consistent-return": {
                "type": "suggestion",
                "docs": {
                    "description": "Require `return` statements to either always or never specify values",
                    "recommended": false,
                    "url": "https://eslint.org/docs/latest/rules/consistent-return"
                },
                "schema": [
                    {
                        "type": "object",
                        "properties": {
                            "treatUndefinedAsUnspecified": {
                                "type": "boolean"
                            }
                        },
                        "additionalProperties": false
                    }
                ],
                "defaultOptions": [
                    {
                        "treatUndefinedAsUnspecified": false
                    }
                ],
                "messages": {
                    "missingReturn": "Expected to return a value at the end of .",
                    "missingReturnValue": " expected a return value.",
                    "unexpectedReturnValue": " expected no return value."
                }
            }
        }
    }
}
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677
    
        Copy code to clipboard
        
    

json
Outputs JSON-serialized results. The json formatter is useful when you want to programmatically work with the CLI's linting results.
Alternatively, you can use the ESLint Node.js API to programmatically use ESLint.
Example output (formatted for easier reading):


    [
    {
        "filePath": "/var/lib/jenkins/workspace/eslint Release/eslint/fullOfProblems.js",
        "messages": [
            {
                "ruleId": "no-unused-vars",
                "severity": 2,
                "message": "'addOne' is defined but never used.",
                "line": 1,
                "column": 10,
                "nodeType": "Identifier",
                "messageId": "unusedVar",
                "endLine": 1,
                "endColumn": 16,
                "suggestions": [
                    {
                        "messageId": "removeVar",
                        "data": {
                            "varName": "addOne"
                        },
                        "fix": {
                            "range": [
                                0,
                                94
                            ],
                            "text": ""
                        },
                        "desc": "Remove unused variable 'addOne'."
                    }
                ]
            },
            {
                "ruleId": "use-isnan",
                "severity": 2,
                "message": "Use the isNaN function to compare with NaN.",
                "line": 2,
                "column": 9,
                "nodeType": "BinaryExpression",
                "messageId": "comparisonWithNaN",
                "endLine": 2,
                "endColumn": 17,
                "suggestions": [
                    {
                        "messageId": "replaceWithIsNaN",
                        "fix": {
                            "range": [
                                29,
                                37
                            ],
                            "text": "!Number.isNaN(i)"
                        },
                        "desc": "Replace with Number.isNaN."
                    },
                    {
                        "messageId": "replaceWithCastingAndIsNaN",
                        "fix": {
                            "range": [
                                29,
                                37
                            ],
                            "text": "!Number.isNaN(Number(i))"
                        },
                        "desc": "Replace with Number.isNaN and cast to a Number."
                    }
                ]
            },
            {
                "ruleId": "space-unary-ops",
                "severity": 2,
                "message": "Unexpected space before unary operator '++'.",
                "line": 3,
                "column": 16,
                "nodeType": "UpdateExpression",
                "messageId": "unexpectedBefore",
                "endLine": 3,
                "endColumn": 20,
                "fix": {
                    "range": [
                        57,
                        58
                    ],
                    "text": ""
                }
            },
            {
                "ruleId": "semi",
                "severity": 1,
                "message": "Missing semicolon.",
                "line": 3,
                "column": 20,
                "nodeType": "ReturnStatement",
                "messageId": "missingSemi",
                "endLine": 4,
                "endColumn": 1,
                "fix": {
                    "range": [
                        60,
                        60
                    ],
                    "text": ";"
                }
            },
            {
                "ruleId": "no-else-return",
                "severity": 1,
                "message": "Unnecessary 'else' after 'return'.",
                "line": 4,
                "column": 12,
                "nodeType": "BlockStatement",
                "messageId": "unexpected",
                "endLine": 6,
                "endColumn": 6,
                "fix": {
                    "range": [
                        0,
                        94
                    ],
                    "text": "function addOne(i) {\n    if (i != NaN) {\n        return i ++\n    } \n      return\n    \n}"
                }
            },
            {
                "ruleId": "indent",
                "severity": 1,
                "message": "Expected indentation of 8 spaces but found 6.",
                "line": 5,
                "column": 1,
                "nodeType": "Keyword",
                "messageId": "wrongIndentation",
                "endLine": 5,
                "endColumn": 7,
                "fix": {
                    "range": [
                        74,
                        80
                    ],
                    "text": "        "
                }
            },
            {
                "ruleId": "consistent-return",
                "severity": 2,
                "message": "Function 'addOne' expected a return value.",
                "line": 5,
                "column": 7,
                "nodeType": "ReturnStatement",
                "messageId": "missingReturnValue",
                "endLine": 5,
                "endColumn": 13
            },
            {
                "ruleId": "semi",
                "severity": 1,
                "message": "Missing semicolon.",
                "line": 5,
                "column": 13,
                "nodeType": "ReturnStatement",
                "messageId": "missingSemi",
                "endLine": 6,
                "endColumn": 1,
                "fix": {
                    "range": [
                        86,
                        86
                    ],
                    "text": ";"
                }
            }
        ],
        "suppressedMessages": [],
        "errorCount": 4,
        "fatalErrorCount": 0,
        "warningCount": 4,
        "fixableErrorCount": 1,
        "fixableWarningCount": 4,
        "source": "function addOne(i) {\n    if (i != NaN) {\n        return i ++\n    } else {\n      return\n    }\n};"
    }
]
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177
    
        Copy code to clipboard
        
    

stylish
Human-readable output format. This is the default formatter.
Example output:


    
/var/lib/jenkins/workspace/eslint Release/eslint/fullOfProblems.js
  1:10  error    'addOne' is defined but never used            no-unused-vars
  2:9   error    Use the isNaN function to compare with NaN    use-isnan
  3:16  error    Unexpected space before unary operator '++'   space-unary-ops
  3:20  warning  Missing semicolon                             semi
  4:12  warning  Unnecessary 'else' after 'return'             no-else-return
  5:1   warning  Expected indentation of 8 spaces but found 6  indent
  5:7   error    Function 'addOne' expected a return value     consistent-return
  5:13  warning  Missing semicolon                             semi

✖ 8 problems (4 errors, 4 warnings)
  1 error and 4 warnings potentially fixable with the `--fix` option.

1234567891011121314
    
        Copy code to clipboard
        
    


            

            
                Edit this page\n\nFormatters Reference
                

                Table of Contents
    
        
                
                    
                    Example Source
            		

                    Built-In Formatter Options
            
                
                    
                    html
            		

                    json-with-metadata
            		

                    json
            		

                    stylish
            		
                
            		
                
            
    


                ESLint comes with several built-in formatters to control the appearance of the linting results, and supports third-party formatters as well.
You can specify a formatter using the --format or -f flag in the CLI. For example, --format json uses the json formatter.
The built-in formatter options are:

html
json-with-metadata
json
stylish

Example Source
Examples of each formatter were created from linting fullOfProblems.js using the .eslintrc.json configuration shown below.
fullOfProblems.js:


    function addOne(i) {
    if (i != NaN) {
        return i ++
    } else {
      return
    }
};
1234567
    
        Copy code to clipboard
        
    

.eslintrc.json:


    {
    "extends": "eslint:recommended",
    "rules": {
        "consistent-return": 2,
        "indent"           : [1, 4],
        "no-else-return"   : 1,
        "semi"             : [1, "always"],
        "space-unary-ops"  : 2
    }
}
12345678910
    
        Copy code to clipboard
        
    

Tests the formatters with the CLI:


    npx eslint --format <Add formatter here> fullOfProblems.js
1
    
        Copy code to clipboard
        
    

Built-In Formatter Options
html
Outputs results to HTML. The html formatter is useful for visual presentation in the browser.
Example output:

json-with-metadata
Outputs JSON-serialized results. The json-with-metadata provides the same linting results as the json formatter with additional metadata about the rules applied. The linting results are included in the results property and the rules metadata is included in the metadata property.
Alternatively, you can use the ESLint Node.js API to programmatically use ESLint.
Example output (formatted for easier reading):


    {
    "results": [
        {
            "filePath": "/var/lib/jenkins/workspace/eslint Release/eslint/fullOfProblems.js",
            "messages": [
                {
                    "ruleId": "no-unused-vars",
                    "severity": 2,
                    "message": "'addOne' is defined but never used.",
                    "line": 1,
                    "column": 10,
                    "nodeType": "Identifier",
                    "messageId": "unusedVar",
                    "endLine": 1,
                    "endColumn": 16,
                    "suggestions": [
                        {
                            "messageId": "removeVar",
                            "data": {
                                "varName": "addOne"
                            },
                            "fix": {
                                "range": [
                                    0,
                                    94
                                ],
                                "text": ""
                            },
                            "desc": "Remove unused variable 'addOne'."
                        }
                    ]
                },
                {
                    "ruleId": "use-isnan",
                    "severity": 2,
                    "message": "Use the isNaN function to compare with NaN.",
                    "line": 2,
                    "column": 9,
                    "nodeType": "BinaryExpression",
                    "messageId": "comparisonWithNaN",
                    "endLine": 2,
                    "endColumn": 17,
                    "suggestions": [
                        {
                            "messageId": "replaceWithIsNaN",
                            "fix": {
                                "range": [
                                    29,
                                    37
                                ],
                                "text": "!Number.isNaN(i)"
                            },
                            "desc": "Replace with Number.isNaN."
                        },
                        {
                            "messageId": "replaceWithCastingAndIsNaN",
                            "fix": {
                                "range": [
                                    29,
                                    37
                                ],
                                "text": "!Number.isNaN(Number(i))"
                            },
                            "desc": "Replace with Number.isNaN and cast to a Number."
                        }
                    ]
                },
                {
                    "ruleId": "space-unary-ops",
                    "severity": 2,
                    "message": "Unexpected space before unary operator '++'.",
                    "line": 3,
                    "column": 16,
                    "nodeType": "UpdateExpression",
                    "messageId": "unexpectedBefore",
                    "endLine": 3,
                    "endColumn": 20,
                    "fix": {
                        "range": [
                            57,
                            58
                        ],
                        "text": ""
                    }
                },
                {
                    "ruleId": "semi",
                    "severity": 1,
                    "message": "Missing semicolon.",
                    "line": 3,
                    "column": 20,
                    "nodeType": "ReturnStatement",
                    "messageId": "missingSemi",
                    "endLine": 4,
                    "endColumn": 1,
                    "fix": {
                        "range": [
                            60,
                            60
                        ],
                        "text": ";"
                    }
                },
                {
                    "ruleId": "no-else-return",
                    "severity": 1,
                    "message": "Unnecessary 'else' after 'return'.",
                    "line": 4,
                    "column": 12,
                    "nodeType": "BlockStatement",
                    "messageId": "unexpected",
                    "endLine": 6,
                    "endColumn": 6,
                    "fix": {
                        "range": [
                            0,
                            94
                        ],
                        "text": "function addOne(i) {\n    if (i != NaN) {\n        return i ++\n    } \n      return\n    \n}"
                    }
                },
                {
                    "ruleId": "indent",
                    "severity": 1,
                    "message": "Expected indentation of 8 spaces but found 6.",
                    "line": 5,
                    "column": 1,
                    "nodeType": "Keyword",
                    "messageId": "wrongIndentation",
                    "endLine": 5,
                    "endColumn": 7,
                    "fix": {
                        "range": [
                            74,
                            80
                        ],
                        "text": "        "
                    }
                },
                {
                    "ruleId": "consistent-return",
                    "severity": 2,
                    "message": "Function 'addOne' expected a return value.",
                    "line": 5,
                    "column": 7,
                    "nodeType": "ReturnStatement",
                    "messageId": "missingReturnValue",
                    "endLine": 5,
                    "endColumn": 13
                },
                {
                    "ruleId": "semi",
                    "severity": 1,
                    "message": "Missing semicolon.",
                    "line": 5,
                    "column": 13,
                    "nodeType": "ReturnStatement",
                    "messageId": "missingSemi",
                    "endLine": 6,
                    "endColumn": 1,
                    "fix": {
                        "range": [
                            86,
                            86
                        ],
                        "text": ";"
                    }
                }
            ],
            "suppressedMessages": [],
            "errorCount": 4,
            "fatalErrorCount": 0,
            "warningCount": 4,
            "fixableErrorCount": 1,
            "fixableWarningCount": 4,
            "source": "function addOne(i) {\n    if (i != NaN) {\n        return i ++\n    } else {\n      return\n    }\n};"
        }
    ],
    "metadata": {
        "rulesMeta": {
            "no-else-return": {
                "type": "suggestion",
                "defaultOptions": [
                    {
                        "allowElseIf": true
                    }
                ],
                "docs": {
                    "description": "Disallow `else` blocks after `return` statements in `if` statements",
                    "recommended": false,
                    "frozen": true,
                    "url": "https://eslint.org/docs/latest/rules/no-else-return"
                },
                "schema": [
                    {
                        "type": "object",
                        "properties": {
                            "allowElseIf": {
                                "type": "boolean"
                            }
                        },
                        "additionalProperties": false
                    }
                ],
                "fixable": "code",
                "messages": {
                    "unexpected": "Unnecessary 'else' after 'return'."
                }
            },
            "indent": {
                "deprecated": {
                    "message": "Formatting rules are being moved out of ESLint core.",
                    "url": "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
                    "deprecatedSince": "8.53.0",
                    "availableUntil": "10.0.0",
                    "replacedBy": [
                        {
                            "message": "ESLint Stylistic now maintains deprecated stylistic core rules.",
                            "url": "https://eslint.style/guide/migration",
                            "plugin": {
                                "name": "@stylistic/eslint-plugin-js",
                                "url": "https://eslint.style/packages/js"
                            },
                            "rule": {
                                "name": "indent",
                                "url": "https://eslint.style/rules/js/indent"
                            }
                        }
                    ]
                },
                "type": "layout",
                "docs": {
                    "description": "Enforce consistent indentation",
                    "recommended": false,
                    "url": "https://eslint.org/docs/latest/rules/indent"
                },
                "fixable": "whitespace",
                "schema": [
                    {
                        "oneOf": [
                            {
                                "enum": [
                                    "tab"
                                ]
                            },
                            {
                                "type": "integer",
                                "minimum": 0
                            }
                        ]
                    },
                    {
                        "type": "object",
                        "properties": {
                            "SwitchCase": {
                                "type": "integer",
                                "minimum": 0,
                                "default": 0
                            },
                            "VariableDeclarator": {
                                "oneOf": [
                                    {
                                        "oneOf": [
                                            {
                                                "type": "integer",
                                                "minimum": 0
                                            },
                                            {
                                                "enum": [
                                                    "first",
                                                    "off"
                                                ]
                                            }
                                        ]
                                    },
                                    {
                                        "type": "object",
                                        "properties": {
                                            "var": {
                                                "oneOf": [
                                                    {
                                                        "type": "integer",
                                                        "minimum": 0
                                                    },
                                                    {
                                                        "enum": [
                                                            "first",
                                                            "off"
                                                        ]
                                                    }
                                                ]
                                            },
                                            "let": {
                                                "oneOf": [
                                                    {
                                                        "type": "integer",
                                                        "minimum": 0
                                                    },
                                                    {
                                                        "enum": [
                                                            "first",
                                                            "off"
                                                        ]
                                                    }
                                                ]
                                            },
                                            "const": {
                                                "oneOf": [
                                                    {
                                                        "type": "integer",
                                                        "minimum": 0
                                                    },
                                                    {
                                                        "enum": [
                                                            "first",
                                                            "off"
                                                        ]
                                                    }
                                                ]
                                            }
                                        },
                                        "additionalProperties": false
                                    }
                                ]
                            },
                            "outerIIFEBody": {
                                "oneOf": [
                                    {
                                        "type": "integer",
                                        "minimum": 0
                                    },
                                    {
                                        "enum": [
                                            "off"
                                        ]
                                    }
                                ]
                            },
                            "MemberExpression": {
                                "oneOf": [
                                    {
                                        "type": "integer",
                                        "minimum": 0
                                    },
                                    {
                                        "enum": [
                                            "off"
                                        ]
                                    }
                                ]
                            },
                            "FunctionDeclaration": {
                                "type": "object",
                                "properties": {
                                    "parameters": {
                                        "oneOf": [
                                            {
                                                "type": "integer",
                                                "minimum": 0
                                            },
                                            {
                                                "enum": [
                                                    "first",
                                                    "off"
                                                ]
                                            }
                                        ]
                                    },
                                    "body": {
                                        "type": "integer",
                                        "minimum": 0
                                    }
                                },
                                "additionalProperties": false
                            },
                            "FunctionExpression": {
                                "type": "object",
                                "properties": {
                                    "parameters": {
                                        "oneOf": [
                                            {
                                                "type": "integer",
                                                "minimum": 0
                                            },
                                            {
                                                "enum": [
                                                    "first",
                                                    "off"
                                                ]
                                            }
                                        ]
                                    },
                                    "body": {
                                        "type": "integer",
                                        "minimum": 0
                                    }
                                },
                                "additionalProperties": false
                            },
                            "StaticBlock": {
                                "type": "object",
                                "properties": {
                                    "body": {
                                        "type": "integer",
                                        "minimum": 0
                                    }
                                },
                                "additionalProperties": false
                            },
                            "CallExpression": {
                                "type": "object",
                                "properties": {
                                    "arguments": {
                                        "oneOf": [
                                            {
                                                "type": "integer",
                                                "minimum": 0
                                            },
                                            {
                                                "enum": [
                                                    "first",
                                                    "off"
                                                ]
                                            }
                                        ]
                                    }
                                },
                                "additionalProperties": false
                            },
                            "ArrayExpression": {
                                "oneOf": [
                                    {
                                        "type": "integer",
                                        "minimum": 0
                                    },
                                    {
                                        "enum": [
                                            "first",
                                            "off"
                                        ]
                                    }
                                ]
                            },
                            "ObjectExpression": {
                                "oneOf": [
                                    {
                                        "type": "integer",
                                        "minimum": 0
                                    },
                                    {
                                        "enum": [
                                            "first",
                                            "off"
                                        ]
                                    }
                                ]
                            },
                            "ImportDeclaration": {
                                "oneOf": [
                                    {
                                        "type": "integer",
                                        "minimum": 0
                                    },
                                    {
                                        "enum": [
                                            "first",
                                            "off"
                                        ]
                                    }
                                ]
                            },
                            "flatTernaryExpressions": {
                                "type": "boolean",
                                "default": false
                            },
                            "offsetTernaryExpressions": {
                                "type": "boolean",
                                "default": false
                            },
                            "ignoredNodes": {
                                "type": "array",
                                "items": {
                                    "type": "string",
                                    "not": {
                                        "pattern": ":exit$"
                                    }
                                }
                            },
                            "ignoreComments": {
                                "type": "boolean",
                                "default": false
                            }
                        },
                        "additionalProperties": false
                    }
                ],
                "messages": {
                    "wrongIndentation": "Expected indentation of  but found ."
                }
            },
            "space-unary-ops": {
                "deprecated": {
                    "message": "Formatting rules are being moved out of ESLint core.",
                    "url": "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
                    "deprecatedSince": "8.53.0",
                    "availableUntil": "10.0.0",
                    "replacedBy": [
                        {
                            "message": "ESLint Stylistic now maintains deprecated stylistic core rules.",
                            "url": "https://eslint.style/guide/migration",
                            "plugin": {
                                "name": "@stylistic/eslint-plugin-js",
                                "url": "https://eslint.style/packages/js"
                            },
                            "rule": {
                                "name": "space-unary-ops",
                                "url": "https://eslint.style/rules/js/space-unary-ops"
                            }
                        }
                    ]
                },
                "type": "layout",
                "docs": {
                    "description": "Enforce consistent spacing before or after unary operators",
                    "recommended": false,
                    "url": "https://eslint.org/docs/latest/rules/space-unary-ops"
                },
                "fixable": "whitespace",
                "schema": [
                    {
                        "type": "object",
                        "properties": {
                            "words": {
                                "type": "boolean",
                                "default": true
                            },
                            "nonwords": {
                                "type": "boolean",
                                "default": false
                            },
                            "overrides": {
                                "type": "object",
                                "additionalProperties": {
                                    "type": "boolean"
                                }
                            }
                        },
                        "additionalProperties": false
                    }
                ],
                "messages": {
                    "unexpectedBefore": "Unexpected space before unary operator ''.",
                    "unexpectedAfter": "Unexpected space after unary operator ''.",
                    "unexpectedAfterWord": "Unexpected space after unary word operator ''.",
                    "wordOperator": "Unary word operator '' must be followed by whitespace.",
                    "operator": "Unary operator '' must be followed by whitespace.",
                    "beforeUnaryExpressions": "Space is required before unary expressions ''."
                }
            },
            "semi": {
                "deprecated": {
                    "message": "Formatting rules are being moved out of ESLint core.",
                    "url": "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
                    "deprecatedSince": "8.53.0",
                    "availableUntil": "10.0.0",
                    "replacedBy": [
                        {
                            "message": "ESLint Stylistic now maintains deprecated stylistic core rules.",
                            "url": "https://eslint.style/guide/migration",
                            "plugin": {
                                "name": "@stylistic/eslint-plugin-js",
                                "url": "https://eslint.style/packages/js"
                            },
                            "rule": {
                                "name": "semi",
                                "url": "https://eslint.style/rules/js/semi"
                            }
                        }
                    ]
                },
                "type": "layout",
                "docs": {
                    "description": "Require or disallow semicolons instead of ASI",
                    "recommended": false,
                    "url": "https://eslint.org/docs/latest/rules/semi"
                },
                "fixable": "code",
                "schema": {
                    "anyOf": [
                        {
                            "type": "array",
                            "items": [
                                {
                                    "enum": [
                                        "never"
                                    ]
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "beforeStatementContinuationChars": {
                                            "enum": [
                                                "always",
                                                "any",
                                                "never"
                                            ]
                                        }
                                    },
                                    "additionalProperties": false
                                }
                            ],
                            "minItems": 0,
                            "maxItems": 2
                        },
                        {
                            "type": "array",
                            "items": [
                                {
                                    "enum": [
                                        "always"
                                    ]
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "omitLastInOneLineBlock": {
                                            "type": "boolean"
                                        },
                                        "omitLastInOneLineClassBody": {
                                            "type": "boolean"
                                        }
                                    },
                                    "additionalProperties": false
                                }
                            ],
                            "minItems": 0,
                            "maxItems": 2
                        }
                    ]
                },
                "messages": {
                    "missingSemi": "Missing semicolon.",
                    "extraSemi": "Extra semicolon."
                }
            },
            "consistent-return": {
                "type": "suggestion",
                "docs": {
                    "description": "Require `return` statements to either always or never specify values",
                    "recommended": false,
                    "url": "https://eslint.org/docs/latest/rules/consistent-return"
                },
                "schema": [
                    {
                        "type": "object",
                        "properties": {
                            "treatUndefinedAsUnspecified": {
                                "type": "boolean"
                            }
                        },
                        "additionalProperties": false
                    }
                ],
                "defaultOptions": [
                    {
                        "treatUndefinedAsUnspecified": false
                    }
                ],
                "messages": {
                    "missingReturn": "Expected to return a value at the end of .",
                    "missingReturnValue": " expected a return value.",
                    "unexpectedReturnValue": " expected no return value."
                }
            }
        }
    }
}
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677
    
        Copy code to clipboard
        
    

json
Outputs JSON-serialized results. The json formatter is useful when you want to programmatically work with the CLI's linting results.
Alternatively, you can use the ESLint Node.js API to programmatically use ESLint.
Example output (formatted for easier reading):


    [
    {
        "filePath": "/var/lib/jenkins/workspace/eslint Release/eslint/fullOfProblems.js",
        "messages": [
            {
                "ruleId": "no-unused-vars",
                "severity": 2,
                "message": "'addOne' is defined but never used.",
                "line": 1,
                "column": 10,
                "nodeType": "Identifier",
                "messageId": "unusedVar",
                "endLine": 1,
                "endColumn": 16,
                "suggestions": [
                    {
                        "messageId": "removeVar",
                        "data": {
                            "varName": "addOne"
                        },
                        "fix": {
                            "range": [
                                0,
                                94
                            ],
                            "text": ""
                        },
                        "desc": "Remove unused variable 'addOne'."
                    }
                ]
            },
            {
                "ruleId": "use-isnan",
                "severity": 2,
                "message": "Use the isNaN function to compare with NaN.",
                "line": 2,
                "column": 9,
                "nodeType": "BinaryExpression",
                "messageId": "comparisonWithNaN",
                "endLine": 2,
                "endColumn": 17,
                "suggestions": [
                    {
                        "messageId": "replaceWithIsNaN",
                        "fix": {
                            "range": [
                                29,
                                37
                            ],
                            "text": "!Number.isNaN(i)"
                        },
                        "desc": "Replace with Number.isNaN."
                    },
                    {
                        "messageId": "replaceWithCastingAndIsNaN",
                        "fix": {
                            "range": [
                                29,
                                37
                            ],
                            "text": "!Number.isNaN(Number(i))"
                        },
                        "desc": "Replace with Number.isNaN and cast to a Number."
                    }
                ]
            },
            {
                "ruleId": "space-unary-ops",
                "severity": 2,
                "message": "Unexpected space before unary operator '++'.",
                "line": 3,
                "column": 16,
                "nodeType": "UpdateExpression",
                "messageId": "unexpectedBefore",
                "endLine": 3,
                "endColumn": 20,
                "fix": {
                    "range": [
                        57,
                        58
                    ],
                    "text": ""
                }
            },
            {
                "ruleId": "semi",
                "severity": 1,
                "message": "Missing semicolon.",
                "line": 3,
                "column": 20,
                "nodeType": "ReturnStatement",
                "messageId": "missingSemi",
                "endLine": 4,
                "endColumn": 1,
                "fix": {
                    "range": [
                        60,
                        60
                    ],
                    "text": ";"
                }
            },
            {
                "ruleId": "no-else-return",
                "severity": 1,
                "message": "Unnecessary 'else' after 'return'.",
                "line": 4,
                "column": 12,
                "nodeType": "BlockStatement",
                "messageId": "unexpected",
                "endLine": 6,
                "endColumn": 6,
                "fix": {
                    "range": [
                        0,
                        94
                    ],
                    "text": "function addOne(i) {\n    if (i != NaN) {\n        return i ++\n    } \n      return\n    \n}"
                }
            },
            {
                "ruleId": "indent",
                "severity": 1,
                "message": "Expected indentation of 8 spaces but found 6.",
                "line": 5,
                "column": 1,
                "nodeType": "Keyword",
                "messageId": "wrongIndentation",
                "endLine": 5,
                "endColumn": 7,
                "fix": {
                    "range": [
                        74,
                        80
                    ],
                    "text": "        "
                }
            },
            {
                "ruleId": "consistent-return",
                "severity": 2,
                "message": "Function 'addOne' expected a return value.",
                "line": 5,
                "column": 7,
                "nodeType": "ReturnStatement",
                "messageId": "missingReturnValue",
                "endLine": 5,
                "endColumn": 13
            },
            {
                "ruleId": "semi",
                "severity": 1,
                "message": "Missing semicolon.",
                "line": 5,
                "column": 13,
                "nodeType": "ReturnStatement",
                "messageId": "missingSemi",
                "endLine": 6,
                "endColumn": 1,
                "fix": {
                    "range": [
                        86,
                        86
                    ],
                    "text": ";"
                }
            }
        ],
        "suppressedMessages": [],
        "errorCount": 4,
        "fatalErrorCount": 0,
        "warningCount": 4,
        "fixableErrorCount": 1,
        "fixableWarningCount": 4,
        "source": "function addOne(i) {\n    if (i != NaN) {\n        return i ++\n    } else {\n      return\n    }\n};"
    }
]
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177
    
        Copy code to clipboard
        
    

stylish
Human-readable output format. This is the default formatter.
Example output:


    
/var/lib/jenkins/workspace/eslint Release/eslint/fullOfProblems.js
  1:10  error    'addOne' is defined but never used            no-unused-vars
  2:9   error    Use the isNaN function to compare with NaN    use-isnan
  3:16  error    Unexpected space before unary operator '++'   space-unary-ops
  3:20  warning  Missing semicolon                             semi
  4:12  warning  Unnecessary 'else' after 'return'             no-else-return
  5:1   warning  Expected indentation of 8 spaces but found 6  indent
  5:7   error    Function 'addOne' expected a return value     consistent-return
  5:13  warning  Missing semicolon                             semi

✖ 8 problems (4 errors, 4 warnings)
  1 error and 4 warnings potentially fixable with the `--fix` option.

1234567891011121314
    
        Copy code to clipboard
        
    


            

            
                Edit this page\n\n\n\nBulk Suppressions
                

                Table of Contents
    
        
                
                    
                    Suppressions File
            		

                    Resolving Suppressions
            		
                
            
    


                Enabling a new lint rule as "error" can be challenging when the codebase has many violations and the rule isn’t auto-fixable. Unless the rule is enabled during the early stages of the project, it becomes harder and harder to enable it as the codebase grows. Existing violations must be resolved before enabling the rule, but while doing that other violations may occur.
To address this, ESLint provides a way to suppress existing violations for one or more rules. While the rule will be enforced for new code, the existing violations will not be reported. This way, you can address the existing violations at your own pace.

                    
                    
                        Important
                        Only rules configured as "error" are suppressed. If a rule is enabled as "warn", ESLint will not suppress the violations.

                    
                After you enable a rule as "error" in your configuration file, you can suppress all the existing violations at once by using the --suppress-all flag. It is recommended to execute the command with the --fix flag so that you don’t suppress violations that can be auto-fixed.


    eslint --fix --suppress-all
1
    
        Copy code to clipboard
        
    

This command will suppress all the existing violations of all the rules that are enabled as "error". Running the eslint command again will not report these violations.
If you would like to suppress violations of a specific rule, you can use the --suppress-rule flag.


    eslint --fix --suppress-rule no-unused-expressions
1
    
        Copy code to clipboard
        
    

You can also suppress violations of multiple rules by providing multiple rule names.


    eslint --fix --suppress-rule no-unused-expressions --suppress-rule no-unsafe-assignment
1
    
        Copy code to clipboard
        
    

Suppressions File
When you suppress violations, ESLint creates a eslint-suppressions.json file in the root of the project. This file contains the list of rules that have been suppressed. You should commit this file to the repository so that the suppressions are shared with all the developers.
If necessary, you can change the location of the suppressions file by using the --suppressions-location argument. Note that the argument must be provided not only when suppressing violations but also when running ESLint. This is necessary so that ESLint picks up the correct suppressions file.


    eslint --suppressions-location .github/.eslint-suppressions
1
    
        Copy code to clipboard
        
    

Resolving Suppressions
You can address any of the reported violations by making the necessary changes to the code as usual. If you run ESLint again you will notice that a warning is reported about unused suppressions. This is because the violations have been resolved but the suppressions are still in place.


    > eslint
There are suppressions left that do not occur anymore. Consider re-running the command with `--prune-suppressions`.
12
    
        Copy code to clipboard
        
    

To remove the suppressions that are no longer needed, you can use the --prune-suppressions flag.


    eslint --prune-suppressions
1
    
        Copy code to clipboard
        
    

For more information on the available CLI options, refer to Command Line Interface.

            

            
                Edit this page\n\nBulk Suppressions
                

                Table of Contents
    
        
                
                    
                    Suppressions File
            		

                    Resolving Suppressions
            		
                
            
    


                Enabling a new lint rule as "error" can be challenging when the codebase has many violations and the rule isn’t auto-fixable. Unless the rule is enabled during the early stages of the project, it becomes harder and harder to enable it as the codebase grows. Existing violations must be resolved before enabling the rule, but while doing that other violations may occur.
To address this, ESLint provides a way to suppress existing violations for one or more rules. While the rule will be enforced for new code, the existing violations will not be reported. This way, you can address the existing violations at your own pace.

                    
                    
                        Important
                        Only rules configured as "error" are suppressed. If a rule is enabled as "warn", ESLint will not suppress the violations.

                    
                After you enable a rule as "error" in your configuration file, you can suppress all the existing violations at once by using the --suppress-all flag. It is recommended to execute the command with the --fix flag so that you don’t suppress violations that can be auto-fixed.


    eslint --fix --suppress-all
1
    
        Copy code to clipboard
        
    

This command will suppress all the existing violations of all the rules that are enabled as "error". Running the eslint command again will not report these violations.
If you would like to suppress violations of a specific rule, you can use the --suppress-rule flag.


    eslint --fix --suppress-rule no-unused-expressions
1
    
        Copy code to clipboard
        
    

You can also suppress violations of multiple rules by providing multiple rule names.


    eslint --fix --suppress-rule no-unused-expressions --suppress-rule no-unsafe-assignment
1
    
        Copy code to clipboard
        
    

Suppressions File
When you suppress violations, ESLint creates a eslint-suppressions.json file in the root of the project. This file contains the list of rules that have been suppressed. You should commit this file to the repository so that the suppressions are shared with all the developers.
If necessary, you can change the location of the suppressions file by using the --suppressions-location argument. Note that the argument must be provided not only when suppressing violations but also when running ESLint. This is necessary so that ESLint picks up the correct suppressions file.


    eslint --suppressions-location .github/.eslint-suppressions
1
    
        Copy code to clipboard
        
    

Resolving Suppressions
You can address any of the reported violations by making the necessary changes to the code as usual. If you run ESLint again you will notice that a warning is reported about unused suppressions. This is because the violations have been resolved but the suppressions are still in place.


    > eslint
There are suppressions left that do not occur anymore. Consider re-running the command with `--prune-suppressions`.
12
    
        Copy code to clipboard
        
    

To remove the suppressions that are no longer needed, you can use the --prune-suppressions flag.


    eslint --prune-suppressions
1
    
        Copy code to clipboard
        
    

For more information on the available CLI options, refer to Command Line Interface.

            

            
                Edit this page\n\n\n\nIntegrations
                

                Table of Contents
    
        
                
                    
                    Editors
            		

                    Build tools
            		

                    Command Line Tools
            		

                    Source Control
            		

                    Other Integration Lists
            		
                
            
    


                This page contains community projects that have integrated ESLint. The projects on this page are not maintained by the ESLint team.
If you would like to recommend an integration to be added to this page, submit a pull request.
Editors

Sublime Text 3:

SublimeLinter-eslint
Build Next


Vim:

ALE
Syntastic


Emacs: Flycheck supports ESLint with the javascript-eslint checker.
Eclipse Orion: ESLint is the default linter
Eclipse IDE: Tern ESLint linter
TextMate 2:

eslint.tmbundle
javascript-eslint.tmbundle


IntelliJ IDEA, WebStorm, PhpStorm, PyCharm, RubyMine, and other JetBrains IDEs: How to use ESLint
Visual Studio: Linting JavaScript in VS
Visual Studio Code: ESLint Extension
Brackets: Included and Brackets ESLint

Build tools

Grunt: grunt-eslint
Webpack: eslint-webpack-plugin
Rollup: @rollup/plugin-eslint

Command Line Tools

ESLint Watch
Code Climate CLI
ESLint Nibble

Source Control

Git Precommit Hook
Git pre-commit hook that only lints staged changes
overcommit Git hook manager
Mega-Linter: Linters aggregator for CI, embedding eslint

Other Integration Lists
You can find a curated list of other popular integrations for ESLint in the awesome-eslint GitHub repository.

            

            
                Edit this page\n\nIntegrations
                

                Table of Contents
    
        
                
                    
                    Editors
            		

                    Build tools
            		

                    Command Line Tools
            		

                    Source Control
            		

                    Other Integration Lists
            		
                
            
    


                This page contains community projects that have integrated ESLint. The projects on this page are not maintained by the ESLint team.
If you would like to recommend an integration to be added to this page, submit a pull request.
Editors

Sublime Text 3:

SublimeLinter-eslint
Build Next


Vim:

ALE
Syntastic


Emacs: Flycheck supports ESLint with the javascript-eslint checker.
Eclipse Orion: ESLint is the default linter
Eclipse IDE: Tern ESLint linter
TextMate 2:

eslint.tmbundle
javascript-eslint.tmbundle


IntelliJ IDEA, WebStorm, PhpStorm, PyCharm, RubyMine, and other JetBrains IDEs: How to use ESLint
Visual Studio: Linting JavaScript in VS
Visual Studio Code: ESLint Extension
Brackets: Included and Brackets ESLint

Build tools

Grunt: grunt-eslint
Webpack: eslint-webpack-plugin
Rollup: @rollup/plugin-eslint

Command Line Tools

ESLint Watch
Code Climate CLI
ESLint Nibble

Source Control

Git Precommit Hook
Git pre-commit hook that only lints staged changes
overcommit Git hook manager
Mega-Linter: Linters aggregator for CI, embedding eslint

Other Integration Lists
You can find a curated list of other popular integrations for ESLint in the awesome-eslint GitHub repository.

            

            
                Edit this page\n\n\n\nMigrate to v9.x
                

                Table of Contents
    
        
                
                    
                    Table of Contents
            
                
                    
                    Breaking changes for users
            		

                    Breaking changes for plugin developers
            		

                    Breaking changes for integration developers
            		
                
            		

                    Node.js < v18.18, v19 are no longer supported
            		

                    New default config format (eslint.config.js)
            		

                    Removed multiple formatters
            		

                    Removed require-jsdoc and valid-jsdoc rules
            		

                    eslint:recommended has been updated
            		

                    --quiet no longer runs rules set to "warn"
            		

                    --output-file now writes a file to disk even with an empty output
            		

                    Change in behavior when no patterns are passed to CLI
            		

                    /* eslint */ comments with only severity now retain options from the config file
            		

                    Multiple /* eslint */ comments for the same rule are now disallowed
            		

                    Stricter /* exported */ parsing
            		

                    no-constructor-return and no-sequences rule schemas are stricter
            		

                    New checks in no-implicit-coercion by default
            		

                    Case-sensitive flags in no-invalid-regexp
            		

                    varsIgnorePattern option of no-unused-vars no longer applies to catch arguments
            		

                    no-restricted-imports now accepts multiple config entries with the same name
            		

                    "eslint:recommended" and "eslint:all" no longer accepted in flat config
            		

                    no-inner-declarations has a new default behavior with a new option
            		

                    no-unused-vars now defaults caughtErrors to "all"
            		

                    no-useless-computed-key flags unnecessary computed member names in classes by default
            		

                    camelcase allow option only accepts an array of strings
            		

                    Removed multiple context methods
            		

                    Removed sourceCode.getComments()
            		

                    Removed CodePath#currentSegments
            		

                    Code paths are now precalculated
            		

                    Function-style rules are no longer supported
            		

                    meta.schema is required for rules with options
            		

                    FlatRuleTester is now RuleTester
            		

                    Stricter RuleTester checks
            		

                    FlatESLint is now ESLint
            		

                    Linter now expects flat config format
            		
                
            
    


                ESLint v9.0.0 is a major release of ESLint, and as such, has several breaking changes that you need to be aware of. This guide is intended to walk you through the breaking changes.
The lists below are ordered roughly by the number of users each change is expected to affect, where the first items are expected to affect the most users.
Table of Contents
Breaking changes for users

Node.js < v18.18, v19 are no longer supported
New default config format (eslint.config.js)
Removed multiple formatters
Removed require-jsdoc and valid-jsdoc rules
eslint:recommended has been updated
--quiet no longer runs rules set to "warn"
--output-file now writes a file to disk even with an empty output
Change in behavior when no patterns are passed to CLI
/* eslint */ comments with only severity now retain options from the config file
Multiple /* eslint */ comments for the same rule are now disallowed
Stricter /* exported */ parsing
no-constructor-return and no-sequences rule schemas are stricter
New checks in no-implicit-coercion by default
Case-sensitive flags in no-invalid-regexp
varsIgnorePattern option of no-unused-vars no longer applies to catch arguments
no-restricted-imports now accepts multiple config entries with the same name
"eslint:recommended" and "eslint:all" strings no longer accepted in flat config
no-inner-declarations has a new default behavior with a new option
no-unused-vars now defaults caughtErrors to "all"
no-useless-computed-key flags unnecessary computed member names in classes by default
camelcase allow option only accepts an array of strings

Breaking changes for plugin developers

Node.js < v18.18, v19 are no longer supported
Removed multiple context methods
Removed sourceCode.getComments()
Removed CodePath#currentSegments
Code paths are now precalculated
Function-style rules are no longer supported
meta.schema is required for rules with options
FlatRuleTester is now RuleTester
Stricter RuleTester checks

Breaking changes for integration developers

Node.js < v18.18, v19 are no longer supported
FlatESLint is now ESLint
Linter now expects flat config format


 Node.js < v18.18, v19 are no longer supported
ESLint is officially dropping support for these versions of Node.js starting with ESLint v9.0.0. ESLint now supports the following versions of Node.js:

Node.js v18.18.0 and above
Node.js v20.9.0 and above
Node.js v21 and above

To address: Make sure you upgrade to at least Node.js v18.18.0 when using ESLint v9.0.0. One important thing to double check is the Node.js version supported by your editor when using ESLint via editor integrations. If you are unable to upgrade, we recommend continuing to use ESLint v8.56.0 until you are able to upgrade Node.js.
Related issue(s): #17595
 New default config format (eslint.config.js)
As announced in our blog post, in ESLint v9.0.0, eslint.config.js is the new default configuration format. The previous format, eslintrc, is now deprecated and will not automatically be searched for.
To address: Update your configuration to the new format following the Configuration Migration Guide. In case you still need to use the deprecated eslintrc config format, set environment variable ESLINT_USE_FLAT_CONFIG to false.
Related Issues(s): #13481
 Removed multiple formatters
ESLint v9.0.0 has removed the following formatters from the core:



Removed Formatter
Replacement npm Package




checkstyle
eslint-formatter-checkstyle


compact
eslint-formatter-compact


jslint-xml
eslint-formatter-jslint-xml


junit
eslint-formatter-junit


tap
eslint-formatter-tap


unix
eslint-formatter-unix


visualstudio
eslint-formatter-visualstudio



To address: If you are using any of these formatters via the -f command line flag, you’ll need to install the respective package for the formatter.
Related issue(s): #17524
 Removed require-jsdoc and valid-jsdoc rules
The require-jsdoc and valid-jsdoc rules have been removed in ESLint v9.0.0. These rules were initially deprecated in 2018.
To address: Use the replacement rules in eslint-plugin-jsdoc.
Related issue(s): #15820
 eslint:recommended has been updated
Four new rules have been enabled in eslint:recommended:

no-constant-binary-expression
no-empty-static-block
no-new-native-nonconstructor
no-unused-private-class-members

Additionally, the following rules have been removed from eslint:recommended:

no-extra-semi
no-inner-declarations
no-mixed-spaces-and-tabs
no-new-symbol

To address: Fix errors or disable these rules.
Related issue(s): #15576, #17446, #17596
 --quiet no longer runs rules set to "warn"
Prior to ESLint v9.0.0, the --quiet CLI flag would run all rules set to either "error" or "warn" and then hide the results from rules set to "warn". In ESLint v9.0.0, --quiet will prevent rules from being executed when set to "warn". This can result in a performance improvement for configurations containing many rules set to "warn".
If --max-warnings is used then --quiet will not suppress the execution of rules set to "warn" but the output of those rules will be suppressed.
To address: In most cases, this change is transparent. If, however, you are running a rule set to "warn" that makes changes to the data available to other rules (for example, if the rule uses sourceCode.markVariableAsUsed()), then this can result in a behavior change. In such a case, you’ll need to either set the rule to "error" or stop using --quiet.
Related issue(s): #16450
 --output-file now writes a file to disk even with an empty output
Prior to ESLint v9.0.0, the --output-file flag would skip writing a file to disk if the output was empty. However, in ESLint v9.0.0, --output-file now consistently writes a file to disk, even when the output is empty. This update ensures a more consistent and reliable behavior for --output-file.
To address: Review your usage of the --output-file flag, especially if your processes depend on the file’s presence or absence based on output content. If necessary, update your scripts or configurations to accommodate this change.
Related Issues(s): #17660
 Change in behavior when no patterns are passed to CLI
Prior to ESLint v9.0.0, running the ESLint CLI without any file or directory patterns would result in no files being linted and would exit with code 0. This was confusing because it wasn’t clear that nothing had actually happened. In ESLint v9.0.0, this behavior has been updated:

Flat config. If you are using flat config, you can run npx eslint or eslint (if globally installed) and ESLint will assume you want to lint the current directory. Effectively, passing no patterns is equivalent to passing ..
eslintrc. If you are using the deprecated eslintrc config, you’ll now receive an error when running the CLI without any patterns.

To address: In most cases, no change is necessary, and you may find some locations where you thought ESLint was running but it wasn’t. If you’d like to keep the v8.x behavior, where passing no patterns results in ESLint exiting with code 0, add the --pass-on-no-patterns flag to the CLI call.
Related issue(s): #14308
 /* eslint */ comments with only severity now retain options from the config file
Prior to ESLint v9.0.0, configuration comments such as /* eslint curly: "warn" */ or /* eslint curly: ["warn"] */ would completely override any configuration specified for the rule in the config file, and thus enforce the default options of the rule.
In ESLint v9.0.0, the behavior of configuration comments is aligned with how rule configurations in config files are merged, meaning that a configuration comment with only severity now retains options specified in the config file and just overrides the severity.
For example, if you have the following config file:


    // eslint.config.js

export default [
	{
		rules: {
			curly: ["error", "multi"],
		},
	},
];
123456789
    
        Copy code to clipboard
        
    

and the following configuration comment:


    // my-file.js

/* eslint curly: "warn" */
123
    
        Copy code to clipboard
        
    

the resulting configuration for the curly rule when linting my-file.js will be curly: ["warn", "multi"].
Note that this change only affects cases where the same rule is configured in the config file with options and using a configuration comment without options. In all other cases (e.g. the rule is only configured using a configuration comment), the behavior remains the same as prior to ESLint v9.0.0.
To address: We expect that in most cases no change is necessary, as rules configured using configuration comments are typically not already configured in the config file. However, if you need a configuration comment to completely override configuration from the config file and enforce the default options, you’ll need to specify at least one option:


    // my-file.js

/* eslint curly: ["warn", "all"] */
123
    
        Copy code to clipboard
        
    

Related issue(s): #17381
 Multiple /* eslint */ comments for the same rule are now disallowed
Prior to ESLint v9.0.0, if the file being linted contained multiple /* eslint */ configuration comments for the same rule, the last one would be applied, while the others would be silently ignored. For example:


    /* eslint semi: ["error", "always"] */
/* eslint semi: ["error", "never"] */

foo(); // valid, because the configuration is "never"
1234
    
        Copy code to clipboard
        
    

In ESLint v9.0.0, the first one is applied, while the others are reported as lint errors:


    /* eslint semi: ["error", "always"] */
/* eslint semi: ["error", "never"] */ // error: Rule "semi" is already configured by another configuration comment in the preceding code. This configuration is ignored.

foo(); // error: Missing semicolon
1234
    
        Copy code to clipboard
        
    

To address: Remove duplicate /* eslint */ comments.
Related issue(s): #18132
 Stricter /* exported */ parsing
Prior to ESLint v9.0.0, the /* exported */ directive incorrectly allowed the following syntax:


    /* exported foo: true, bar: false */

// and

/* exported foo bar */
12345
    
        Copy code to clipboard
        
    

The true and false in this example had no effect on ESLint’s behavior, and in fact, was a parsing bug.
In ESLint v9.0.0, any /* exported */ variables followed by a colon and value will be ignored as invalid.
To address: Update any /* exported */ directives to eliminate the colons and subsequent values, and ensure there are commas between variable names such as:


    /* exported foo, bar */
1
    
        Copy code to clipboard
        
    

Related issue(s): #17622
 no-constructor-return and no-sequences rule schemas are stricter
In previous versions of ESLint, no-constructor-return and no-sequences rules were mistakenly accepting invalid options.
This has been fixed in ESLint v9.0.0:

The no-constructor-return rule does not accept any options.
The no-sequences rule can take one option, an object with a property "allowInParentheses" (boolean).



    {
	"rules": {
		"no-constructor-return": ["error"],
		"no-sequences": ["error", { "allowInParentheses": false }]
	}
}
123456
    
        Copy code to clipboard
        
    

To address: If ESLint reports invalid configuration for any of these rules, update your configuration.
Related issue(s): #16879
 New checks in no-implicit-coercion by default
In ESLint v9.0.0, the no-implicit-coercion rule additionally reports the following cases by default:


    -(-foo);
foo - 0;
12
    
        Copy code to clipboard
        
    

To address: If you want to retain the previous behavior of this rule, set "allow": ["-", "- -"].


    {
	"rules": {
		"no-implicit-coercion": [2, { "allow": ["-", "- -"] }]
	}
}
12345
    
        Copy code to clipboard
        
    

Related issue(s): #17832
 Case-sensitive flags in no-invalid-regexp
In ESLint v9.0.0, the option allowConstructorFlags is now case-sensitive.
To address: Update your configuration if needed.
Related issue(s): #16574
 varsIgnorePattern option of no-unused-vars no longer applies to catch arguments
In previous versions of ESLint, the varsIgnorePattern option of no-unused-vars incorrectly ignored errors specified in a catch clause. In ESLint v9.0.0, varsIgnorePattern no longer applies to errors in catch clauses. For example:


    /*eslint no-unused-vars: ["error", { "caughtErrors": "all", "varsIgnorePattern": "^err" }]*/

try {
	//...
} catch (err) {
	// 'err' will be reported.
	console.error("errors");
}
12345678
    
        Copy code to clipboard
        
    

To address: If you want to specify ignore patterns for catch clause variable names, use the caughtErrorsIgnorePattern option in addition to varsIgnorePattern.
Related issue(s): #17540
 no-restricted-imports now accepts multiple config entries with the same name
In previous versions of ESLint, if multiple entries in the paths array of your configuration for the no-restricted-imports rule had the same name property, only the last one would apply, while the previous ones would be ignored.
As of ESLint v9.0.0, all entries apply, allowing for specifying different messages for different imported names. For example, you can now configure the rule like this:


    {
    rules: {
        "no-restricted-imports": ["error", {
            paths: [
                {
                    name: "react-native",
                    importNames: ["Text"],
                    message: "import 'Text' from 'ui/_components' instead"
                },
                {
                    name: "react-native",
                    importNames: ["View"],
                    message: "import 'View' from 'ui/_components' instead"
                }
            ]
        }]
    }
}
123456789101112131415161718
    
        Copy code to clipboard
        
    

and both import { Text } from "react-native" and import { View } from "react-native" will be reported, with different messages.
In previous versions of ESLint, with this configuration only import { View } from "react-native" would be reported.
To address: If your configuration for this rule has multiple entries with the same name, you may need to remove unintentional ones.
Related issue(s): #15261
 "eslint:recommended" and "eslint:all" no longer accepted in flat config
In ESLint v8.x, eslint.config.js could refer to "eslint:recommended" and "eslint:all" configurations by inserting a string into the config array, as in this example:


    // eslint.config.js
export default ["eslint:recommended", "eslint:all"];
12
    
        Copy code to clipboard
        
    

In ESLint v9.0.0, this format is no longer supported and will result in an error.
To address: Use the @eslint/js package instead:


    // eslint.config.js
import js from "@eslint/js";

export default [js.configs.recommended, js.configs.all];
1234
    
        Copy code to clipboard
        
    

Related issue(s): #17488
 no-inner-declarations has a new default behavior with a new option
ESLint v9.0.0 introduces a new option in no-inner-declarations rule called blockScopeFunctions which by default allows block-level functions in strict mode when languageOptions.ecmaVersion is set to 2015 or above.


    /*eslint no-inner-declarations: "error"*/
"use strict";

if (test) {
	function foo() {} // no error
}
123456
    
        Copy code to clipboard
        
    

To address: If you want to report the block-level functions in every condition regardless of strict or non-strict mode, set the blockScopeFunctions option to "disallow".
Related issue(s): #15576
 no-unused-vars now defaults caughtErrors to "all"
ESLint v9.0.0 changes the default value for the no-unused-vars rule’s caughtErrors option.
Previously it defaulted to "none" to never check whether caught errors were used.
It now defaults to "all" to check caught errors for being used.


    /*eslint no-unused-vars: "error"*/
try {
} catch (error) {
	// 'error' is defined but never used
}
12345
    
        Copy code to clipboard
        
    

To address: If you want to allow unused caught errors, such as when writing code that will be directly run in an environment that does not support ES2019 optional catch bindings, set the caughtErrors option to "none".
Otherwise, delete the unused caught errors.


    /*eslint no-unused-vars: "error"*/
try {
} catch {
	// no error
}
12345
    
        Copy code to clipboard
        
    

Related issue(s): #17974
 no-useless-computed-key flags unnecessary computed member names in classes by default
In ESLint v9.0.0, the default value of the enforceForClassMembers option of the no-useless-computed-key rule was changed from false to true.
The effect of this change is that unnecessary computed member names in classes will be flagged by default.


    /*eslint no-useless-computed-key: "error"*/

class SomeClass {
	["someMethod"]() {} // ok in ESLint v8, error in ESLint v9.
}
12345
    
        Copy code to clipboard
        
    

To address: Fix the problems reported by the rule or revert to the previous behavior by setting the enforceForClassMembers option to false.
Related issue(s): #18042
 camelcase allow option only accepts an array of strings
Previously the camelcase rule didn’t enforce the allow option to be an array of strings. In ESLint v9.0.0, the allow option now only accepts an array of strings.
To address: If ESLint reports invalid configuration for this rule, update your configuration.
Related issue(s): #18232
 Removed multiple context methods
ESLint v9.0.0 removes multiple deprecated methods from the context object and moves them onto the SourceCode object:



Removed on context
Replacement(s) on SourceCode




context.getSource()
sourceCode.getText()


context.getSourceLines()
sourceCode.getLines()


context.getAllComments()
sourceCode.getAllComments()


context.getNodeByRangeIndex()
sourceCode.getNodeByRangeIndex()


context.getComments()
sourceCode.getCommentsBefore(), sourceCode.getCommentsAfter(), sourceCode.getCommentsInside()


context.getCommentsBefore()
sourceCode.getCommentsBefore()


context.getCommentsAfter()
sourceCode.getCommentsAfter()


context.getCommentsInside()
sourceCode.getCommentsInside()


context.getJSDocComment()
sourceCode.getJSDocComment()


context.getFirstToken()
sourceCode.getFirstToken()


context.getFirstTokens()
sourceCode.getFirstTokens()


context.getLastToken()
sourceCode.getLastToken()


context.getLastTokens()
sourceCode.getLastTokens()


context.getTokenAfter()
sourceCode.getTokenAfter()


context.getTokenBefore()
sourceCode.getTokenBefore()


context.getTokenByRangeStart()
sourceCode.getTokenByRangeStart()


context.getTokens()
sourceCode.getTokens()


context.getTokensAfter()
sourceCode.getTokensAfter()


context.getTokensBefore()
sourceCode.getTokensBefore()


context.getTokensBetween()
sourceCode.getTokensBetween()


context.parserServices
sourceCode.parserServices


context.getDeclaredVariables()
sourceCode.getDeclaredVariables()



In addition to the methods in the above table, there are several other methods that are also moved but required different method signatures:



Removed on context
Replacement(s) on SourceCode




context.getAncestors()
sourceCode.getAncestors(node)


context.getScope()
sourceCode.getScope(node)


context.markVariableAsUsed(name)
sourceCode.markVariableAsUsed(name, node)



To address: Use the automated upgrade tool as recommended in the blog post.
Related Issues(s): #16999, #13481
 Removed sourceCode.getComments()
ESLint v9.0.0 removes the deprecated sourceCode.getComments() method.
To address: Replace with sourceCode.getCommentsBefore(), sourceCode.getCommentsAfter(), or sourceCode.getCommentsInside().
Related Issues(s): #14744
 Removed CodePath#currentSegments
ESLint v9.0.0 removes the deprecated CodePath#currentSegments property.
To address: Update your code following the recommendations in the blog post.
Related Issues(s): #17457
 Code paths are now precalculated
Prior to ESLint v9.0.0, code paths were calculated during the same AST traversal used by rules, meaning that the information passed to methods like onCodePathStart and onCodePathSegmentStart was incomplete. Specifically, array properties like CodePath#childCodePaths and CodePathSegment#nextSegments began empty and then were filled with the appropriate information as the traversal completed, meaning that those arrays could have different elements depending on when you checked their values.
ESLint v9.0.0 now precalculates code path information before the traversal used by rules. As a result, the code path information is now complete regardless of where it is accessed inside of a rule.
To address: If you are accessing any array properties on CodePath or CodePathSegment, you’ll need to update your code. Specifically:

If you are checking the length of any array properties, ensure you are using relative comparison operators like <, >, <=, and >= instead of equals.
If you are accessing the nextSegments, prevSegments, allNextSegments, or allPrevSegments properties on a CodePathSegment, or CodePath#childCodePaths, verify that your code will still work as expected. To be backwards compatible, consider moving the logic that checks these properties into onCodePathEnd.

Related Issues(s): #16999
 Function-style rules are no longer supported
ESLint v9.0.0 drops support for function-style rules. Function-style rules are rules created by exporting a function rather than an object with a create() method. This rule format was deprecated in 2016.
To address: Update your rules to the most recent rule format. For rules written in CommonJS, you can also use eslint-transforms.
The eslint-plugin/prefer-object-rule rule can help enforce the usage of object-style rules and autofix any remaining function-style rules.
Related Issues(s): #14709
 meta.schema is required for rules with options
As of ESLint v9.0.0, an error will be thrown if any options are passed to a rule that doesn’t specify meta.schema property.
To address:

If your rule expects options, set meta.schema property to a JSON Schema format description of the rule’s options. This schema will be used by ESLint to validate configured options and prevent invalid or unexpected inputs to your rule.
If your rule doesn’t expect any options, there is no action required. This change ensures that end users will not mistakenly configure options for rules that don’t expect options.
(not recommended) you can also set meta.schema to false to disable this validation, but it is highly recommended to provide a schema if the rule expects options and omit the schema (or set []) if the rule doesn’t expect options so that ESLint can ensure that your users’ configurations are valid.

The eslint-plugin/require-meta-schema rule can help enforce that rules have schemas when required.
Related Issues(s): #14709
 FlatRuleTester is now RuleTester
As announced in our blog post, the temporary FlatRuleTester class has been renamed to RuleTester, while the RuleTester class from v8.x has been removed. Additionally, the FlatRuleTester export from eslint/use-at-your-own-risk has been removed.
To address: Update your rule tests to use the new RuleTester. To do so, here are some of the common changes you’ll need to make:


Be aware of new defaults for ecmaVersion and sourceType. By default, RuleTester uses the flat config default of ecmaVersion: "latest" and sourceType: "module". This may cause some tests to break if they were expecting the old default of ecmaVersion: 5 and sourceType: "script". If you’d like to use the old default, you’ll need to manually specify that in your RuleTester like this:


    // use eslintrc defaults
const ruleTester = new RuleTester({
	languageOptions: {
		ecmaVersion: 5,
		sourceType: "script",
	},
});
1234567
    
        Copy code to clipboard
        
    



Change parserOptions to languageOptions. If you’re setting ecmaVersion or sourceType on your tests, move those from parserOptions to languageOptions, like this:


    ruleTester.run("my-rule", myRule, {
	valid: [
		{
			code: "foo",
			parserOptions: {
				ecmaVersion: 6,
			},
		},
	],
});

// becomes

ruleTester.run("my-rule", myRule, {
	valid: [
		{
			code: "foo",
			languageOptions: {
				ecmaVersion: 6,
			},
		},
	],
});
1234567891011121314151617181920212223
    
        Copy code to clipboard
        
    



Translate other config keys. Keys such as env and parser that used to run on the eslintrc config system must be translated into the flat config system. Please refer to the Configuration Migration Guide for details on translating other keys you may be using.


Related Issues(s): #13481
 Stricter RuleTester checks
In order to aid in the development of high-quality custom rules that are free from common bugs, ESLint v9.0.0 implements several changes to RuleTester:

Test case output must be different from code. In ESLint v8.x, if output is the same as code, it asserts that there was no autofix. When looking at a test case, it’s not always immediately clear whether output differs from code, especially if the strings are longer or multiline, making it difficult for developers to determine whether or not the test case expects an autofix. In ESLint v9.0.0, to avoid this ambiguity, RuleTester now throws an error if the test output has the same value as the test code. Therefore, specifying output now necessarily means that the test case expects an autofix and asserts its result. If the test case doesn’t expect an autofix, omit the output property or set it to null. This asserts that there was no autofix.
Test error objects must specify message or messageId. To improve the quality of test coverage, RuleTester now throws an error if neither message nor messageId is specified on test error objects.
Test error object must specify suggestions if the actual error provides suggestions. In ESLint v8.x, if the suggestions property was omitted from test error objects, RuleTester wasn’t performing any checks related to suggestions, so it was easy to forget to assert if a test case produces suggestions. In ESLint v9.0.0, omitting the suggestions property asserts that the actual error does not provide suggestions, while you need to specify the suggestions property if the actual error does provide suggestions. We highly recommend that you test suggestions in detail by specifying an array of test suggestion objects, but you can also specify suggestions: <number> to assert just the number of suggestions.
Test suggestion objects must specify output. To improve the quality of test coverage, RuleTester now throws an error if output property is not specified on test suggestion objects.
Test suggestion objects must specify desc or messageId. To improve the quality of test coverage, RuleTester now throws an error if neither desc nor messageId property is specified on test suggestion objects. It’s also not allowed to specify both. If you want to assert the suggestion description text in addition to the messageId, then also add the data property.
Suggestion messages must be unique. Because suggestions are typically displayed in an editor as a dropdown list, it’s important that no two suggestions for the same lint problem have the same message. Otherwise, it’s impossible to know what any given suggestion will do. This additional check runs automatically.
Suggestions must change the code. Suggestions are expected to fix the reported problem by changing the code. RuleTester now throws an error if the suggestion test output is the same as the test code.
Suggestions must generate valid syntax. In order for rule suggestions to be helpful, they need to be valid syntax. RuleTester now parses the output of suggestions using the same language options as the code value and throws an error if parsing fails.
Test cases must be unique. Identical test cases can cause confusion and be hard to detect manually in a long test file. Duplicates are now automatically detected and can be safely removed.
filename and only must be of the expected type. RuleTester now checks the type of filename and only properties of test objects. If specified, filename must be a string value. If specified, only must be a boolean value.
Messages cannot have unsubstituted placeholders. The RuleTester now also checks if there are {{ placeholder }}  still in the message as their values were not passed via data in the respective context.report() call.

To address: Run your rule tests using RuleTester and fix any errors that occur. The changes you’ll need to make to satisfy RuleTester are compatible with ESLint v8.x.
Related Issues(s): #15104, #15735, #16908, #18016
 FlatESLint is now ESLint
As announced in our blog post, the temporary FlatESLint class has been renamed to ESLint, while the ESLint class from v8.x has been renamed to LegacyESLint.
To address: If you are currently using the ESLint class, verify that your tests pass using the new ESLint class. Not all of the old options are supported, so you may need to update the arguments passed to the constructor. See the Node.js API Reference for details.
If you still need the v8.x ESLint functionality, use the LegacyESLint class like this:


    const { LegacyESLint } = require("eslint/use-at-your-own-risk");
1
    
        Copy code to clipboard
        
    

Related Issues(s): #13481
 Linter now expects flat config format
In ESLint v9.0.0, the config argument passed to Linter#verify() and Linter#verifyAndFix() methods should be in the flat config format.
Additionally, methods Linter#defineRule(), Linter#defineRules(), Linter#defineParser(), and Linter#getRules() are no longer available.
To address: If you are using the Linter class, verify that your tests pass.
If you’re passing configuration objects that are incompatible with the flat config format, you’ll need to update the code.


    // eslintrc config format
linter.verify(code, {
	parserOptions: {
		ecmaVersion: 6,
	},
});

// flat config format
linter.verify(code, {
	languageOptions: {
		ecmaVersion: 6,
	},
});
12345678910111213
    
        Copy code to clipboard
        
    

Please refer to the Configuration Migration Guide for details on translating other keys you may be using.
Rules and parsers can be defined directly in the configuration.


    // eslintrc mode
linter.defineRule("my-rule1", myRule1);
linter.defineRules({
	"my-rule2": myRule2,
	"my-rule3": myRule3,
});
linter.defineParser("my-parser", myParser);
linter.verify(code, {
	rules: {
		"my-rule1": "error",
		"my-rule2": "error",
		"my-rule3": "error",
	},
	parser: "my-parser",
});

// flat config mode
linter.verify(code, {
	plugins: {
		"my-plugin-foo": {
			rules: {
				"my-rule1": myRule1,
			},
		},
		"my-plugin-bar": {
			rules: {
				"my-rule2": myRule2,
				"my-rule3": myRule3,
			},
		},
	},
	rules: {
		"my-plugin-foo/my-rule1": "error",
		"my-plugin-bar/my-rule2": "error",
		"my-plugin-bar/my-rule3": "error",
	},
	languageOptions: {
		parser: myParser,
	},
});
12345678910111213141516171819202122232425262728293031323334353637383940
    
        Copy code to clipboard
        
    

If you still need the v8.x Linter functionality, pass configType: "eslintrc" to the constructor like this:


    const linter = new Linter({ configType: "eslintrc" });

linter.verify(code, {
	parserOptions: {
		ecmaVersion: 6,
	},
});

linter.getRules();
123456789
    
        Copy code to clipboard
        
    

Related Issues(s): #13481

            

            
                Edit this page\n\nMigrate to v9.x
                

                Table of Contents
    
        
                
                    
                    Table of Contents
            
                
                    
                    Breaking changes for users
            		

                    Breaking changes for plugin developers
            		

                    Breaking changes for integration developers
            		
                
            		

                    Node.js < v18.18, v19 are no longer supported
            		

                    New default config format (eslint.config.js)
            		

                    Removed multiple formatters
            		

                    Removed require-jsdoc and valid-jsdoc rules
            		

                    eslint:recommended has been updated
            		

                    --quiet no longer runs rules set to "warn"
            		

                    --output-file now writes a file to disk even with an empty output
            		

                    Change in behavior when no patterns are passed to CLI
            		

                    /* eslint */ comments with only severity now retain options from the config file
            		

                    Multiple /* eslint */ comments for the same rule are now disallowed
            		

                    Stricter /* exported */ parsing
            		

                    no-constructor-return and no-sequences rule schemas are stricter
            		

                    New checks in no-implicit-coercion by default
            		

                    Case-sensitive flags in no-invalid-regexp
            		

                    varsIgnorePattern option of no-unused-vars no longer applies to catch arguments
            		

                    no-restricted-imports now accepts multiple config entries with the same name
            		

                    "eslint:recommended" and "eslint:all" no longer accepted in flat config
            		

                    no-inner-declarations has a new default behavior with a new option
            		

                    no-unused-vars now defaults caughtErrors to "all"
            		

                    no-useless-computed-key flags unnecessary computed member names in classes by default
            		

                    camelcase allow option only accepts an array of strings
            		

                    Removed multiple context methods
            		

                    Removed sourceCode.getComments()
            		

                    Removed CodePath#currentSegments
            		

                    Code paths are now precalculated
            		

                    Function-style rules are no longer supported
            		

                    meta.schema is required for rules with options
            		

                    FlatRuleTester is now RuleTester
            		

                    Stricter RuleTester checks
            		

                    FlatESLint is now ESLint
            		

                    Linter now expects flat config format
            		
                
            
    


                ESLint v9.0.0 is a major release of ESLint, and as such, has several breaking changes that you need to be aware of. This guide is intended to walk you through the breaking changes.
The lists below are ordered roughly by the number of users each change is expected to affect, where the first items are expected to affect the most users.
Table of Contents
Breaking changes for users

Node.js < v18.18, v19 are no longer supported
New default config format (eslint.config.js)
Removed multiple formatters
Removed require-jsdoc and valid-jsdoc rules
eslint:recommended has been updated
--quiet no longer runs rules set to "warn"
--output-file now writes a file to disk even with an empty output
Change in behavior when no patterns are passed to CLI
/* eslint */ comments with only severity now retain options from the config file
Multiple /* eslint */ comments for the same rule are now disallowed
Stricter /* exported */ parsing
no-constructor-return and no-sequences rule schemas are stricter
New checks in no-implicit-coercion by default
Case-sensitive flags in no-invalid-regexp
varsIgnorePattern option of no-unused-vars no longer applies to catch arguments
no-restricted-imports now accepts multiple config entries with the same name
"eslint:recommended" and "eslint:all" strings no longer accepted in flat config
no-inner-declarations has a new default behavior with a new option
no-unused-vars now defaults caughtErrors to "all"
no-useless-computed-key flags unnecessary computed member names in classes by default
camelcase allow option only accepts an array of strings

Breaking changes for plugin developers

Node.js < v18.18, v19 are no longer supported
Removed multiple context methods
Removed sourceCode.getComments()
Removed CodePath#currentSegments
Code paths are now precalculated
Function-style rules are no longer supported
meta.schema is required for rules with options
FlatRuleTester is now RuleTester
Stricter RuleTester checks

Breaking changes for integration developers

Node.js < v18.18, v19 are no longer supported
FlatESLint is now ESLint
Linter now expects flat config format


 Node.js < v18.18, v19 are no longer supported
ESLint is officially dropping support for these versions of Node.js starting with ESLint v9.0.0. ESLint now supports the following versions of Node.js:

Node.js v18.18.0 and above
Node.js v20.9.0 and above
Node.js v21 and above

To address: Make sure you upgrade to at least Node.js v18.18.0 when using ESLint v9.0.0. One important thing to double check is the Node.js version supported by your editor when using ESLint via editor integrations. If you are unable to upgrade, we recommend continuing to use ESLint v8.56.0 until you are able to upgrade Node.js.
Related issue(s): #17595
 New default config format (eslint.config.js)
As announced in our blog post, in ESLint v9.0.0, eslint.config.js is the new default configuration format. The previous format, eslintrc, is now deprecated and will not automatically be searched for.
To address: Update your configuration to the new format following the Configuration Migration Guide. In case you still need to use the deprecated eslintrc config format, set environment variable ESLINT_USE_FLAT_CONFIG to false.
Related Issues(s): #13481
 Removed multiple formatters
ESLint v9.0.0 has removed the following formatters from the core:



Removed Formatter
Replacement npm Package




checkstyle
eslint-formatter-checkstyle


compact
eslint-formatter-compact


jslint-xml
eslint-formatter-jslint-xml


junit
eslint-formatter-junit


tap
eslint-formatter-tap


unix
eslint-formatter-unix


visualstudio
eslint-formatter-visualstudio



To address: If you are using any of these formatters via the -f command line flag, you’ll need to install the respective package for the formatter.
Related issue(s): #17524
 Removed require-jsdoc and valid-jsdoc rules
The require-jsdoc and valid-jsdoc rules have been removed in ESLint v9.0.0. These rules were initially deprecated in 2018.
To address: Use the replacement rules in eslint-plugin-jsdoc.
Related issue(s): #15820
 eslint:recommended has been updated
Four new rules have been enabled in eslint:recommended:

no-constant-binary-expression
no-empty-static-block
no-new-native-nonconstructor
no-unused-private-class-members

Additionally, the following rules have been removed from eslint:recommended:

no-extra-semi
no-inner-declarations
no-mixed-spaces-and-tabs
no-new-symbol

To address: Fix errors or disable these rules.
Related issue(s): #15576, #17446, #17596
 --quiet no longer runs rules set to "warn"
Prior to ESLint v9.0.0, the --quiet CLI flag would run all rules set to either "error" or "warn" and then hide the results from rules set to "warn". In ESLint v9.0.0, --quiet will prevent rules from being executed when set to "warn". This can result in a performance improvement for configurations containing many rules set to "warn".
If --max-warnings is used then --quiet will not suppress the execution of rules set to "warn" but the output of those rules will be suppressed.
To address: In most cases, this change is transparent. If, however, you are running a rule set to "warn" that makes changes to the data available to other rules (for example, if the rule uses sourceCode.markVariableAsUsed()), then this can result in a behavior change. In such a case, you’ll need to either set the rule to "error" or stop using --quiet.
Related issue(s): #16450
 --output-file now writes a file to disk even with an empty output
Prior to ESLint v9.0.0, the --output-file flag would skip writing a file to disk if the output was empty. However, in ESLint v9.0.0, --output-file now consistently writes a file to disk, even when the output is empty. This update ensures a more consistent and reliable behavior for --output-file.
To address: Review your usage of the --output-file flag, especially if your processes depend on the file’s presence or absence based on output content. If necessary, update your scripts or configurations to accommodate this change.
Related Issues(s): #17660
 Change in behavior when no patterns are passed to CLI
Prior to ESLint v9.0.0, running the ESLint CLI without any file or directory patterns would result in no files being linted and would exit with code 0. This was confusing because it wasn’t clear that nothing had actually happened. In ESLint v9.0.0, this behavior has been updated:

Flat config. If you are using flat config, you can run npx eslint or eslint (if globally installed) and ESLint will assume you want to lint the current directory. Effectively, passing no patterns is equivalent to passing ..
eslintrc. If you are using the deprecated eslintrc config, you’ll now receive an error when running the CLI without any patterns.

To address: In most cases, no change is necessary, and you may find some locations where you thought ESLint was running but it wasn’t. If you’d like to keep the v8.x behavior, where passing no patterns results in ESLint exiting with code 0, add the --pass-on-no-patterns flag to the CLI call.
Related issue(s): #14308
 /* eslint */ comments with only severity now retain options from the config file
Prior to ESLint v9.0.0, configuration comments such as /* eslint curly: "warn" */ or /* eslint curly: ["warn"] */ would completely override any configuration specified for the rule in the config file, and thus enforce the default options of the rule.
In ESLint v9.0.0, the behavior of configuration comments is aligned with how rule configurations in config files are merged, meaning that a configuration comment with only severity now retains options specified in the config file and just overrides the severity.
For example, if you have the following config file:


    // eslint.config.js

export default [
	{
		rules: {
			curly: ["error", "multi"],
		},
	},
];
123456789
    
        Copy code to clipboard
        
    

and the following configuration comment:


    // my-file.js

/* eslint curly: "warn" */
123
    
        Copy code to clipboard
        
    

the resulting configuration for the curly rule when linting my-file.js will be curly: ["warn", "multi"].
Note that this change only affects cases where the same rule is configured in the config file with options and using a configuration comment without options. In all other cases (e.g. the rule is only configured using a configuration comment), the behavior remains the same as prior to ESLint v9.0.0.
To address: We expect that in most cases no change is necessary, as rules configured using configuration comments are typically not already configured in the config file. However, if you need a configuration comment to completely override configuration from the config file and enforce the default options, you’ll need to specify at least one option:


    // my-file.js

/* eslint curly: ["warn", "all"] */
123
    
        Copy code to clipboard
        
    

Related issue(s): #17381
 Multiple /* eslint */ comments for the same rule are now disallowed
Prior to ESLint v9.0.0, if the file being linted contained multiple /* eslint */ configuration comments for the same rule, the last one would be applied, while the others would be silently ignored. For example:


    /* eslint semi: ["error", "always"] */
/* eslint semi: ["error", "never"] */

foo(); // valid, because the configuration is "never"
1234
    
        Copy code to clipboard
        
    

In ESLint v9.0.0, the first one is applied, while the others are reported as lint errors:


    /* eslint semi: ["error", "always"] */
/* eslint semi: ["error", "never"] */ // error: Rule "semi" is already configured by another configuration comment in the preceding code. This configuration is ignored.

foo(); // error: Missing semicolon
1234
    
        Copy code to clipboard
        
    

To address: Remove duplicate /* eslint */ comments.
Related issue(s): #18132
 Stricter /* exported */ parsing
Prior to ESLint v9.0.0, the /* exported */ directive incorrectly allowed the following syntax:


    /* exported foo: true, bar: false */

// and

/* exported foo bar */
12345
    
        Copy code to clipboard
        
    

The true and false in this example had no effect on ESLint’s behavior, and in fact, was a parsing bug.
In ESLint v9.0.0, any /* exported */ variables followed by a colon and value will be ignored as invalid.
To address: Update any /* exported */ directives to eliminate the colons and subsequent values, and ensure there are commas between variable names such as:


    /* exported foo, bar */
1
    
        Copy code to clipboard
        
    

Related issue(s): #17622
 no-constructor-return and no-sequences rule schemas are stricter
In previous versions of ESLint, no-constructor-return and no-sequences rules were mistakenly accepting invalid options.
This has been fixed in ESLint v9.0.0:

The no-constructor-return rule does not accept any options.
The no-sequences rule can take one option, an object with a property "allowInParentheses" (boolean).



    {
	"rules": {
		"no-constructor-return": ["error"],
		"no-sequences": ["error", { "allowInParentheses": false }]
	}
}
123456
    
        Copy code to clipboard
        
    

To address: If ESLint reports invalid configuration for any of these rules, update your configuration.
Related issue(s): #16879
 New checks in no-implicit-coercion by default
In ESLint v9.0.0, the no-implicit-coercion rule additionally reports the following cases by default:


    -(-foo);
foo - 0;
12
    
        Copy code to clipboard
        
    

To address: If you want to retain the previous behavior of this rule, set "allow": ["-", "- -"].


    {
	"rules": {
		"no-implicit-coercion": [2, { "allow": ["-", "- -"] }]
	}
}
12345
    
        Copy code to clipboard
        
    

Related issue(s): #17832
 Case-sensitive flags in no-invalid-regexp
In ESLint v9.0.0, the option allowConstructorFlags is now case-sensitive.
To address: Update your configuration if needed.
Related issue(s): #16574
 varsIgnorePattern option of no-unused-vars no longer applies to catch arguments
In previous versions of ESLint, the varsIgnorePattern option of no-unused-vars incorrectly ignored errors specified in a catch clause. In ESLint v9.0.0, varsIgnorePattern no longer applies to errors in catch clauses. For example:


    /*eslint no-unused-vars: ["error", { "caughtErrors": "all", "varsIgnorePattern": "^err" }]*/

try {
	//...
} catch (err) {
	// 'err' will be reported.
	console.error("errors");
}
12345678
    
        Copy code to clipboard
        
    

To address: If you want to specify ignore patterns for catch clause variable names, use the caughtErrorsIgnorePattern option in addition to varsIgnorePattern.
Related issue(s): #17540
 no-restricted-imports now accepts multiple config entries with the same name
In previous versions of ESLint, if multiple entries in the paths array of your configuration for the no-restricted-imports rule had the same name property, only the last one would apply, while the previous ones would be ignored.
As of ESLint v9.0.0, all entries apply, allowing for specifying different messages for different imported names. For example, you can now configure the rule like this:


    {
    rules: {
        "no-restricted-imports": ["error", {
            paths: [
                {
                    name: "react-native",
                    importNames: ["Text"],
                    message: "import 'Text' from 'ui/_components' instead"
                },
                {
                    name: "react-native",
                    importNames: ["View"],
                    message: "import 'View' from 'ui/_components' instead"
                }
            ]
        }]
    }
}
123456789101112131415161718
    
        Copy code to clipboard
        
    

and both import { Text } from "react-native" and import { View } from "react-native" will be reported, with different messages.
In previous versions of ESLint, with this configuration only import { View } from "react-native" would be reported.
To address: If your configuration for this rule has multiple entries with the same name, you may need to remove unintentional ones.
Related issue(s): #15261
 "eslint:recommended" and "eslint:all" no longer accepted in flat config
In ESLint v8.x, eslint.config.js could refer to "eslint:recommended" and "eslint:all" configurations by inserting a string into the config array, as in this example:


    // eslint.config.js
export default ["eslint:recommended", "eslint:all"];
12
    
        Copy code to clipboard
        
    

In ESLint v9.0.0, this format is no longer supported and will result in an error.
To address: Use the @eslint/js package instead:


    // eslint.config.js
import js from "@eslint/js";

export default [js.configs.recommended, js.configs.all];
1234
    
        Copy code to clipboard
        
    

Related issue(s): #17488
 no-inner-declarations has a new default behavior with a new option
ESLint v9.0.0 introduces a new option in no-inner-declarations rule called blockScopeFunctions which by default allows block-level functions in strict mode when languageOptions.ecmaVersion is set to 2015 or above.


    /*eslint no-inner-declarations: "error"*/
"use strict";

if (test) {
	function foo() {} // no error
}
123456
    
        Copy code to clipboard
        
    

To address: If you want to report the block-level functions in every condition regardless of strict or non-strict mode, set the blockScopeFunctions option to "disallow".
Related issue(s): #15576
 no-unused-vars now defaults caughtErrors to "all"
ESLint v9.0.0 changes the default value for the no-unused-vars rule’s caughtErrors option.
Previously it defaulted to "none" to never check whether caught errors were used.
It now defaults to "all" to check caught errors for being used.


    /*eslint no-unused-vars: "error"*/
try {
} catch (error) {
	// 'error' is defined but never used
}
12345
    
        Copy code to clipboard
        
    

To address: If you want to allow unused caught errors, such as when writing code that will be directly run in an environment that does not support ES2019 optional catch bindings, set the caughtErrors option to "none".
Otherwise, delete the unused caught errors.


    /*eslint no-unused-vars: "error"*/
try {
} catch {
	// no error
}
12345
    
        Copy code to clipboard
        
    

Related issue(s): #17974
 no-useless-computed-key flags unnecessary computed member names in classes by default
In ESLint v9.0.0, the default value of the enforceForClassMembers option of the no-useless-computed-key rule was changed from false to true.
The effect of this change is that unnecessary computed member names in classes will be flagged by default.


    /*eslint no-useless-computed-key: "error"*/

class SomeClass {
	["someMethod"]() {} // ok in ESLint v8, error in ESLint v9.
}
12345
    
        Copy code to clipboard
        
    

To address: Fix the problems reported by the rule or revert to the previous behavior by setting the enforceForClassMembers option to false.
Related issue(s): #18042
 camelcase allow option only accepts an array of strings
Previously the camelcase rule didn’t enforce the allow option to be an array of strings. In ESLint v9.0.0, the allow option now only accepts an array of strings.
To address: If ESLint reports invalid configuration for this rule, update your configuration.
Related issue(s): #18232
 Removed multiple context methods
ESLint v9.0.0 removes multiple deprecated methods from the context object and moves them onto the SourceCode object:



Removed on context
Replacement(s) on SourceCode




context.getSource()
sourceCode.getText()


context.getSourceLines()
sourceCode.getLines()


context.getAllComments()
sourceCode.getAllComments()


context.getNodeByRangeIndex()
sourceCode.getNodeByRangeIndex()


context.getComments()
sourceCode.getCommentsBefore(), sourceCode.getCommentsAfter(), sourceCode.getCommentsInside()


context.getCommentsBefore()
sourceCode.getCommentsBefore()


context.getCommentsAfter()
sourceCode.getCommentsAfter()


context.getCommentsInside()
sourceCode.getCommentsInside()


context.getJSDocComment()
sourceCode.getJSDocComment()


context.getFirstToken()
sourceCode.getFirstToken()


context.getFirstTokens()
sourceCode.getFirstTokens()


context.getLastToken()
sourceCode.getLastToken()


context.getLastTokens()
sourceCode.getLastTokens()


context.getTokenAfter()
sourceCode.getTokenAfter()


context.getTokenBefore()
sourceCode.getTokenBefore()


context.getTokenByRangeStart()
sourceCode.getTokenByRangeStart()


context.getTokens()
sourceCode.getTokens()


context.getTokensAfter()
sourceCode.getTokensAfter()


context.getTokensBefore()
sourceCode.getTokensBefore()


context.getTokensBetween()
sourceCode.getTokensBetween()


context.parserServices
sourceCode.parserServices


context.getDeclaredVariables()
sourceCode.getDeclaredVariables()



In addition to the methods in the above table, there are several other methods that are also moved but required different method signatures:



Removed on context
Replacement(s) on SourceCode




context.getAncestors()
sourceCode.getAncestors(node)


context.getScope()
sourceCode.getScope(node)


context.markVariableAsUsed(name)
sourceCode.markVariableAsUsed(name, node)



To address: Use the automated upgrade tool as recommended in the blog post.
Related Issues(s): #16999, #13481
 Removed sourceCode.getComments()
ESLint v9.0.0 removes the deprecated sourceCode.getComments() method.
To address: Replace with sourceCode.getCommentsBefore(), sourceCode.getCommentsAfter(), or sourceCode.getCommentsInside().
Related Issues(s): #14744
 Removed CodePath#currentSegments
ESLint v9.0.0 removes the deprecated CodePath#currentSegments property.
To address: Update your code following the recommendations in the blog post.
Related Issues(s): #17457
 Code paths are now precalculated
Prior to ESLint v9.0.0, code paths were calculated during the same AST traversal used by rules, meaning that the information passed to methods like onCodePathStart and onCodePathSegmentStart was incomplete. Specifically, array properties like CodePath#childCodePaths and CodePathSegment#nextSegments began empty and then were filled with the appropriate information as the traversal completed, meaning that those arrays could have different elements depending on when you checked their values.
ESLint v9.0.0 now precalculates code path information before the traversal used by rules. As a result, the code path information is now complete regardless of where it is accessed inside of a rule.
To address: If you are accessing any array properties on CodePath or CodePathSegment, you’ll need to update your code. Specifically:

If you are checking the length of any array properties, ensure you are using relative comparison operators like <, >, <=, and >= instead of equals.
If you are accessing the nextSegments, prevSegments, allNextSegments, or allPrevSegments properties on a CodePathSegment, or CodePath#childCodePaths, verify that your code will still work as expected. To be backwards compatible, consider moving the logic that checks these properties into onCodePathEnd.

Related Issues(s): #16999
 Function-style rules are no longer supported
ESLint v9.0.0 drops support for function-style rules. Function-style rules are rules created by exporting a function rather than an object with a create() method. This rule format was deprecated in 2016.
To address: Update your rules to the most recent rule format. For rules written in CommonJS, you can also use eslint-transforms.
The eslint-plugin/prefer-object-rule rule can help enforce the usage of object-style rules and autofix any remaining function-style rules.
Related Issues(s): #14709
 meta.schema is required for rules with options
As of ESLint v9.0.0, an error will be thrown if any options are passed to a rule that doesn’t specify meta.schema property.
To address:

If your rule expects options, set meta.schema property to a JSON Schema format description of the rule’s options. This schema will be used by ESLint to validate configured options and prevent invalid or unexpected inputs to your rule.
If your rule doesn’t expect any options, there is no action required. This change ensures that end users will not mistakenly configure options for rules that don’t expect options.
(not recommended) you can also set meta.schema to false to disable this validation, but it is highly recommended to provide a schema if the rule expects options and omit the schema (or set []) if the rule doesn’t expect options so that ESLint can ensure that your users’ configurations are valid.

The eslint-plugin/require-meta-schema rule can help enforce that rules have schemas when required.
Related Issues(s): #14709
 FlatRuleTester is now RuleTester
As announced in our blog post, the temporary FlatRuleTester class has been renamed to RuleTester, while the RuleTester class from v8.x has been removed. Additionally, the FlatRuleTester export from eslint/use-at-your-own-risk has been removed.
To address: Update your rule tests to use the new RuleTester. To do so, here are some of the common changes you’ll need to make:


Be aware of new defaults for ecmaVersion and sourceType. By default, RuleTester uses the flat config default of ecmaVersion: "latest" and sourceType: "module". This may cause some tests to break if they were expecting the old default of ecmaVersion: 5 and sourceType: "script". If you’d like to use the old default, you’ll need to manually specify that in your RuleTester like this:


    // use eslintrc defaults
const ruleTester = new RuleTester({
	languageOptions: {
		ecmaVersion: 5,
		sourceType: "script",
	},
});
1234567
    
        Copy code to clipboard
        
    



Change parserOptions to languageOptions. If you’re setting ecmaVersion or sourceType on your tests, move those from parserOptions to languageOptions, like this:


    ruleTester.run("my-rule", myRule, {
	valid: [
		{
			code: "foo",
			parserOptions: {
				ecmaVersion: 6,
			},
		},
	],
});

// becomes

ruleTester.run("my-rule", myRule, {
	valid: [
		{
			code: "foo",
			languageOptions: {
				ecmaVersion: 6,
			},
		},
	],
});
1234567891011121314151617181920212223
    
        Copy code to clipboard
        
    



Translate other config keys. Keys such as env and parser that used to run on the eslintrc config system must be translated into the flat config system. Please refer to the Configuration Migration Guide for details on translating other keys you may be using.


Related Issues(s): #13481
 Stricter RuleTester checks
In order to aid in the development of high-quality custom rules that are free from common bugs, ESLint v9.0.0 implements several changes to RuleTester:

Test case output must be different from code. In ESLint v8.x, if output is the same as code, it asserts that there was no autofix. When looking at a test case, it’s not always immediately clear whether output differs from code, especially if the strings are longer or multiline, making it difficult for developers to determine whether or not the test case expects an autofix. In ESLint v9.0.0, to avoid this ambiguity, RuleTester now throws an error if the test output has the same value as the test code. Therefore, specifying output now necessarily means that the test case expects an autofix and asserts its result. If the test case doesn’t expect an autofix, omit the output property or set it to null. This asserts that there was no autofix.
Test error objects must specify message or messageId. To improve the quality of test coverage, RuleTester now throws an error if neither message nor messageId is specified on test error objects.
Test error object must specify suggestions if the actual error provides suggestions. In ESLint v8.x, if the suggestions property was omitted from test error objects, RuleTester wasn’t performing any checks related to suggestions, so it was easy to forget to assert if a test case produces suggestions. In ESLint v9.0.0, omitting the suggestions property asserts that the actual error does not provide suggestions, while you need to specify the suggestions property if the actual error does provide suggestions. We highly recommend that you test suggestions in detail by specifying an array of test suggestion objects, but you can also specify suggestions: <number> to assert just the number of suggestions.
Test suggestion objects must specify output. To improve the quality of test coverage, RuleTester now throws an error if output property is not specified on test suggestion objects.
Test suggestion objects must specify desc or messageId. To improve the quality of test coverage, RuleTester now throws an error if neither desc nor messageId property is specified on test suggestion objects. It’s also not allowed to specify both. If you want to assert the suggestion description text in addition to the messageId, then also add the data property.
Suggestion messages must be unique. Because suggestions are typically displayed in an editor as a dropdown list, it’s important that no two suggestions for the same lint problem have the same message. Otherwise, it’s impossible to know what any given suggestion will do. This additional check runs automatically.
Suggestions must change the code. Suggestions are expected to fix the reported problem by changing the code. RuleTester now throws an error if the suggestion test output is the same as the test code.
Suggestions must generate valid syntax. In order for rule suggestions to be helpful, they need to be valid syntax. RuleTester now parses the output of suggestions using the same language options as the code value and throws an error if parsing fails.
Test cases must be unique. Identical test cases can cause confusion and be hard to detect manually in a long test file. Duplicates are now automatically detected and can be safely removed.
filename and only must be of the expected type. RuleTester now checks the type of filename and only properties of test objects. If specified, filename must be a string value. If specified, only must be a boolean value.
Messages cannot have unsubstituted placeholders. The RuleTester now also checks if there are {{ placeholder }}  still in the message as their values were not passed via data in the respective context.report() call.

To address: Run your rule tests using RuleTester and fix any errors that occur. The changes you’ll need to make to satisfy RuleTester are compatible with ESLint v8.x.
Related Issues(s): #15104, #15735, #16908, #18016
 FlatESLint is now ESLint
As announced in our blog post, the temporary FlatESLint class has been renamed to ESLint, while the ESLint class from v8.x has been renamed to LegacyESLint.
To address: If you are currently using the ESLint class, verify that your tests pass using the new ESLint class. Not all of the old options are supported, so you may need to update the arguments passed to the constructor. See the Node.js API Reference for details.
If you still need the v8.x ESLint functionality, use the LegacyESLint class like this:


    const { LegacyESLint } = require("eslint/use-at-your-own-risk");
1
    
        Copy code to clipboard
        
    

Related Issues(s): #13481
 Linter now expects flat config format
In ESLint v9.0.0, the config argument passed to Linter#verify() and Linter#verifyAndFix() methods should be in the flat config format.
Additionally, methods Linter#defineRule(), Linter#defineRules(), Linter#defineParser(), and Linter#getRules() are no longer available.
To address: If you are using the Linter class, verify that your tests pass.
If you’re passing configuration objects that are incompatible with the flat config format, you’ll need to update the code.


    // eslintrc config format
linter.verify(code, {
	parserOptions: {
		ecmaVersion: 6,
	},
});

// flat config format
linter.verify(code, {
	languageOptions: {
		ecmaVersion: 6,
	},
});
12345678910111213
    
        Copy code to clipboard
        
    

Please refer to the Configuration Migration Guide for details on translating other keys you may be using.
Rules and parsers can be defined directly in the configuration.


    // eslintrc mode
linter.defineRule("my-rule1", myRule1);
linter.defineRules({
	"my-rule2": myRule2,
	"my-rule3": myRule3,
});
linter.defineParser("my-parser", myParser);
linter.verify(code, {
	rules: {
		"my-rule1": "error",
		"my-rule2": "error",
		"my-rule3": "error",
	},
	parser: "my-parser",
});

// flat config mode
linter.verify(code, {
	plugins: {
		"my-plugin-foo": {
			rules: {
				"my-rule1": myRule1,
			},
		},
		"my-plugin-bar": {
			rules: {
				"my-rule2": myRule2,
				"my-rule3": myRule3,
			},
		},
	},
	rules: {
		"my-plugin-foo/my-rule1": "error",
		"my-plugin-bar/my-rule2": "error",
		"my-plugin-bar/my-rule3": "error",
	},
	languageOptions: {
		parser: myParser,
	},
});
12345678910111213141516171819202122232425262728293031323334353637383940
    
        Copy code to clipboard
        
    

If you still need the v8.x Linter functionality, pass configType: "eslintrc" to the constructor like this:


    const linter = new Linter({ configType: "eslintrc" });

linter.verify(code, {
	parserOptions: {
		ecmaVersion: 6,
	},
});

linter.getRules();
123456789
    
        Copy code to clipboard
        
    

Related Issues(s): #13481

            

            
                Edit this page\n\n\n\nVersion Support
            
                The ESLint team provides ongoing support for the current version and six months of limited support for the previous version.

            
            
        
        
            






        
    


    
        Major ESLint release lines move through a status of Current, to Maintenance, to End of Life (EOL). A release line is considered Current when prerelease work begins. At that point, the previous release line moves to Maintenance status and stays there until six months after the general availability of the Current release line. After that, the release line moves to EOL.
Release Statuses
ESLint major release lines are designated by the level of support they receive from the ESLint team. The release statuses are:

Current - Receives active maintenance and development from the ESLint team.
Maintenance - Receives critical bug fixes, including security issues, and compatibility fixes to ensure interoperability between major release lines. There is no backporting of other fixes or features from the current release line.
End of Life (EOL) - When a release line falls out of maintenance mode it receives no further updates from the ESLint team.

Current Release Lines



Release Line
Status
First Release
Last Release
EOL Start
Commercial Support




v9.x
Current
2024-04-05
TBD
TBD
Tidelift


v8.0.0-v8.57.1
EOL
2021-10-09
2024-09-16
2024-10-05
HeroDevs


v7.0.0-v7.32.0
EOL
2020-05-08
2021-07-30
2022-04-09
HeroDevs


v6.0.0-v6.8.0
EOL
2019-06-21
2019-12-20
2020-11-08
HeroDevs


v5.0.0-v5.16.0
EOL
2018-06-22
2019-03-29
2019-12-21
HeroDevs


v4.0.0-v4.19.1
EOL
2017-06-11
2018-03-21
2018-12-22
HeroDevs


v3.0.0-v3.19.0
EOL
2016-07-01
2017-03-31
2017-12-11
HeroDevs


v2.0.0-v2.13.1
EOL
2016-02-12
2016-06-20
2017-01-01
HeroDevs


v1.0.0-v1.10.3
EOL
2015-07-31
2015-12-01
2016-08-12
HeroDevs



Commercial Support
ESLint offers commercial support through our partners, Tidelift and HeroDevs.
For Current and Maintenance release lines, commercial support is provided by Tidelift. Tidelift validates that ESLint is up-to-date with the latest security best practices and can be a first point of contact for any problems that may arise. Learn more
For EOL release lines, commercial support is provided by HeroDevs. HeroDevs provides drop-in replacements for older versions of ESLint that are kept up-to-date for security and compliance issues. Learn more\n\nVersion Support
            
                The ESLint team provides ongoing support for the current version and six months of limited support for the previous version.

            
            
        
        
            






        
    


    
        Major ESLint release lines move through a status of Current, to Maintenance, to End of Life (EOL). A release line is considered Current when prerelease work begins. At that point, the previous release line moves to Maintenance status and stays there until six months after the general availability of the Current release line. After that, the release line moves to EOL.
Release Statuses
ESLint major release lines are designated by the level of support they receive from the ESLint team. The release statuses are:

Current - Receives active maintenance and development from the ESLint team.
Maintenance - Receives critical bug fixes, including security issues, and compatibility fixes to ensure interoperability between major release lines. There is no backporting of other fixes or features from the current release line.
End of Life (EOL) - When a release line falls out of maintenance mode it receives no further updates from the ESLint team.

Current Release Lines



Release Line
Status
First Release
Last Release
EOL Start
Commercial Support




v9.x
Current
2024-04-05
TBD
TBD
Tidelift


v8.0.0-v8.57.1
EOL
2021-10-09
2024-09-16
2024-10-05
HeroDevs


v7.0.0-v7.32.0
EOL
2020-05-08
2021-07-30
2022-04-09
HeroDevs


v6.0.0-v6.8.0
EOL
2019-06-21
2019-12-20
2020-11-08
HeroDevs


v5.0.0-v5.16.0
EOL
2018-06-22
2019-03-29
2019-12-21
HeroDevs


v4.0.0-v4.19.1
EOL
2017-06-11
2018-03-21
2018-12-22
HeroDevs


v3.0.0-v3.19.0
EOL
2016-07-01
2017-03-31
2017-12-11
HeroDevs


v2.0.0-v2.13.1
EOL
2016-02-12
2016-06-20
2017-01-01
HeroDevs


v1.0.0-v1.10.3
EOL
2015-07-31
2015-12-01
2016-08-12
HeroDevs



Commercial Support
ESLint offers commercial support through our partners, Tidelift and HeroDevs.
For Current and Maintenance release lines, commercial support is provided by Tidelift. Tidelift validates that ESLint is up-to-date with the latest security best practices and can be a first point of contact for any problems that may arise. Learn more
For EOL release lines, commercial support is provided by HeroDevs. HeroDevs provides drop-in replacements for older versions of ESLint that are kept up-to-date for security and compliance issues. Learn more\n\n\n\nTroubleshooting
                

                Table of Contents
    
        
                
                    
                    Configuration
            		

                    Legacy (eslintrc) Configuration
            		
                
            
    


                This page serves as a reference for common issues working with ESLint.
Configuration

Circular fixes detected …
TypeError: context.getScope is not a function

Legacy (eslintrc) Configuration

ESLint couldn't determine the plugin … uniquely
ESLint couldn't find the config … to extend from
ESLint couldn't find the plugin …

Issues oftentimes can be resolved by updating the to latest versions of the eslint package and any related packages, such as for ESLint shareable configs and plugins.
If you still can’t figure out the problem, please stop by https://eslint.org/chat/help to chat with the team.

            

            
                Edit this page\n\nTroubleshooting
                

                Table of Contents
    
        
                
                    
                    Configuration
            		

                    Legacy (eslintrc) Configuration
            		
                
            
    


                This page serves as a reference for common issues working with ESLint.
Configuration

Circular fixes detected …
TypeError: context.getScope is not a function

Legacy (eslintrc) Configuration

ESLint couldn't determine the plugin … uniquely
ESLint couldn't find the config … to extend from
ESLint couldn't find the plugin …

Issues oftentimes can be resolved by updating the to latest versions of the eslint package and any related packages, such as for ESLint shareable configs and plugins.
If you still can’t figure out the problem, please stop by https://eslint.org/chat/help to chat with the team.

            

            
                Edit this page\n\n\n\nCircular fixes detected …
                

                Table of Contents
    
        
                
                    
                    Symptoms
            		

                    Cause
            		

                    Resolution
            		

                    Resources
            		
                
            
    


                Symptoms
When running ESLint with the --fix option, you may see the following warning:


    ESLintCircularFixesWarning: Circular fixes detected while fixing path/to/file. It is likely that you have conflicting rules in your configuration.
1
    
        Copy code to clipboard
        
    

Cause
You have conflicting fixable rules in your configuration. ESLint autofixes code in multiple passes, meaning it’s possible that a fix in one pass is undone in a subsequent pass. For example, in the first pass a rule removes a trailing comma and in the following pass a different rule adds a trailing comma in the same place, effectively changing the code back to the previous version. ESLint emits a warning when it detects cycles like this.
Resolution
Common resolutions for this issue include:

Remove or reconfigure one of the conflicting rules in your configuration file.

How to find the conflicting rules:

Open the file specified in the warning in an editor that supports applying individual fixes (for example, VS Code).
In the list of lint problems, find a fixable rule. That is one of the conflicting rules.
Apply the fix (“Fix this (rule-name) problem” action in VS Code).
Check what new lint problem has appeared in the list. That is the other conflicting rule.

Resources
For more information, see:

Configure Rules for documentation on how to configure rules


            

            
                Edit this page\n\nCircular fixes detected …
                

                Table of Contents
    
        
                
                    
                    Symptoms
            		

                    Cause
            		

                    Resolution
            		

                    Resources
            		
                
            
    


                Symptoms
When running ESLint with the --fix option, you may see the following warning:


    ESLintCircularFixesWarning: Circular fixes detected while fixing path/to/file. It is likely that you have conflicting rules in your configuration.
1
    
        Copy code to clipboard
        
    

Cause
You have conflicting fixable rules in your configuration. ESLint autofixes code in multiple passes, meaning it’s possible that a fix in one pass is undone in a subsequent pass. For example, in the first pass a rule removes a trailing comma and in the following pass a different rule adds a trailing comma in the same place, effectively changing the code back to the previous version. ESLint emits a warning when it detects cycles like this.
Resolution
Common resolutions for this issue include:

Remove or reconfigure one of the conflicting rules in your configuration file.

How to find the conflicting rules:

Open the file specified in the warning in an editor that supports applying individual fixes (for example, VS Code).
In the list of lint problems, find a fixable rule. That is one of the conflicting rules.
Apply the fix (“Fix this (rule-name) problem” action in VS Code).
Check what new lint problem has appeared in the list. That is the other conflicting rule.

Resources
For more information, see:

Configure Rules for documentation on how to configure rules


            

            
                Edit this page\n\n\n\nESLint couldn't determine the plugin … uniquely
                

                Table of Contents
    
        
                
                    
                    Symptoms
            		

                    Cause
            		

                    Resolution
            		

                    Resources
            		
                
            
    


                Symptoms
When using the legacy ESLint config system, you may see this error running ESLint after installing dependencies:


    ESLint couldn't determine the plugin "${pluginId}" uniquely.

- ${filePath} (loaded in "${importerName}")
- ${filePath} (loaded in "${importerName}")
...

Please remove the "plugins" setting from either config or remove either plugin installation.
1234567
    
        Copy code to clipboard
        
    

Cause
ESLint configuration files allow loading in plugins that may include other plugins.
A plugin package might be specified as a dependency of both your package and one or more ESLint plugins.
Legacy ESLint configuration files may use extends to include other configurations.
Those configurations may depend on plugins to provide certain functionality in the configuration.
For example, if your config depends on eslint-plugin-a@2 and eslint-plugin-b@3, and you extend eslint-config-b that depends on eslint-plugin-a@1, then the eslint-plugin-a package might have two different versions on disk:

node_modules/eslint-plugin-a
node_modules/eslint-plugin-b/node_modules/eslint-plugin-a

If the legacy ESLint configuration system sees that both plugins exists in multiple places with different versions, it won’t know which one to use.
Note that this issue is only present in the legacy eslintrc configurations.
The new “flat” config system has you import the dependencies yourself, removing the need for ESLint to attempt to determine their version uniquely.
Resolution
Common resolutions for this issue include:

Upgrading all versions of all packages to their latest version.
Running npm dedupe or the equivalent package manager command to deduplicate packages, if their version ranges are compatible.
Using overrides or the equivalent package manager package.json field, to force a specific version of a plugin package.

Note that this may cause bugs in linting if the plugin package had breaking changes between versions.



Resources
For more information, see:

Configure Plugins for documentation on how to extend from plugins
Create Plugins for documentation on how to define plugins


            

            
                Edit this page\n\nESLint couldn't determine the plugin … uniquely
                

                Table of Contents
    
        
                
                    
                    Symptoms
            		

                    Cause
            		

                    Resolution
            		

                    Resources
            		
                
            
    


                Symptoms
When using the legacy ESLint config system, you may see this error running ESLint after installing dependencies:


    ESLint couldn't determine the plugin "${pluginId}" uniquely.

- ${filePath} (loaded in "${importerName}")
- ${filePath} (loaded in "${importerName}")
...

Please remove the "plugins" setting from either config or remove either plugin installation.
1234567
    
        Copy code to clipboard
        
    

Cause
ESLint configuration files allow loading in plugins that may include other plugins.
A plugin package might be specified as a dependency of both your package and one or more ESLint plugins.
Legacy ESLint configuration files may use extends to include other configurations.
Those configurations may depend on plugins to provide certain functionality in the configuration.
For example, if your config depends on eslint-plugin-a@2 and eslint-plugin-b@3, and you extend eslint-config-b that depends on eslint-plugin-a@1, then the eslint-plugin-a package might have two different versions on disk:

node_modules/eslint-plugin-a
node_modules/eslint-plugin-b/node_modules/eslint-plugin-a

If the legacy ESLint configuration system sees that both plugins exists in multiple places with different versions, it won’t know which one to use.
Note that this issue is only present in the legacy eslintrc configurations.
The new “flat” config system has you import the dependencies yourself, removing the need for ESLint to attempt to determine their version uniquely.
Resolution
Common resolutions for this issue include:

Upgrading all versions of all packages to their latest version.
Running npm dedupe or the equivalent package manager command to deduplicate packages, if their version ranges are compatible.
Using overrides or the equivalent package manager package.json field, to force a specific version of a plugin package.

Note that this may cause bugs in linting if the plugin package had breaking changes between versions.



Resources
For more information, see:

Configure Plugins for documentation on how to extend from plugins
Create Plugins for documentation on how to define plugins


            

            
                Edit this page\n\n\n\nESLint couldn't find the config … to extend from
                

                Table of Contents
    
        
                
                    
                    Symptoms
            		

                    Cause
            
                
                    
                    Config Name Variations
            		
                
            		

                    Resolution
            		

                    Resources
            		
                
            
    


                Symptoms
When using the legacy ESLint config system, you may see this error running ESLint after installing dependencies:


    ESLint couldn't find the config "${configName}" to extend from. Please check that the name of the config is correct.

The config "${configName}" was referenced from the config file in "${importerName}".
123
    
        Copy code to clipboard
        
    

Cause
ESLint configuration files specify shareable configs by their package name in the extends array.
That package name is passed to the Node.js require(), which looks up the package under local node_modules/ directories.
For example, the following ESLint config will first try to load a module located at node_modules/eslint-config-yours:


    module.exports = {
	extends: ["eslint-config-yours"],
};
123
    
        Copy code to clipboard
        
    

The error is output when you attempt to extend from a configuration and the package for that configuration is not found in any searched node_modules/.
Common reasons for this occurring include:

Not running npm install or the equivalent package manager command
Mistyping the case-sensitive name of the package and/or configuration

Config Name Variations
Note that ESLint supports several config name formats:

The eslint-config- config name prefix may be omitted for brevity, e.g. extends: ["yours"]

@ npm scoped packages put the eslint-config- prefix after the org scope, e.g. extends: ["@org/yours"] to load from @org/eslint-config-yours


A plugin: prefix indicates a config is loaded from a shared plugin, e.g. extends: [plugin:yours/recommended] to load from eslint-plugin-yours

Resolution
Common resolutions for this issue include:

Upgrading all versions of all packages to their latest version.
Adding the config as a devDependency in your package.json.
Running npm install or the equivalent package manager command.
Checking that the name in your config file matches the name of the config package.

Resources
For more information, see:

Legacy ESLint configuration files for documentation on the legacy ESLint configuration format

Legacy ESLint configuration files > Using a shareable configuration package for documentation on using shareable configurations


Share Configurations for documentation on how to define standalone shared configs
Create Plugins > Configs in Plugins for documentation on how to define shared configs in plugins


            

            
                Edit this page\n\nESLint couldn't find the config … to extend from
                

                Table of Contents
    
        
                
                    
                    Symptoms
            		

                    Cause
            
                
                    
                    Config Name Variations
            		
                
            		

                    Resolution
            		

                    Resources
            		
                
            
    


                Symptoms
When using the legacy ESLint config system, you may see this error running ESLint after installing dependencies:


    ESLint couldn't find the config "${configName}" to extend from. Please check that the name of the config is correct.

The config "${configName}" was referenced from the config file in "${importerName}".
123
    
        Copy code to clipboard
        
    

Cause
ESLint configuration files specify shareable configs by their package name in the extends array.
That package name is passed to the Node.js require(), which looks up the package under local node_modules/ directories.
For example, the following ESLint config will first try to load a module located at node_modules/eslint-config-yours:


    module.exports = {
	extends: ["eslint-config-yours"],
};
123
    
        Copy code to clipboard
        
    

The error is output when you attempt to extend from a configuration and the package for that configuration is not found in any searched node_modules/.
Common reasons for this occurring include:

Not running npm install or the equivalent package manager command
Mistyping the case-sensitive name of the package and/or configuration

Config Name Variations
Note that ESLint supports several config name formats:

The eslint-config- config name prefix may be omitted for brevity, e.g. extends: ["yours"]

@ npm scoped packages put the eslint-config- prefix after the org scope, e.g. extends: ["@org/yours"] to load from @org/eslint-config-yours


A plugin: prefix indicates a config is loaded from a shared plugin, e.g. extends: [plugin:yours/recommended] to load from eslint-plugin-yours

Resolution
Common resolutions for this issue include:

Upgrading all versions of all packages to their latest version.
Adding the config as a devDependency in your package.json.
Running npm install or the equivalent package manager command.
Checking that the name in your config file matches the name of the config package.

Resources
For more information, see:

Legacy ESLint configuration files for documentation on the legacy ESLint configuration format

Legacy ESLint configuration files > Using a shareable configuration package for documentation on using shareable configurations


Share Configurations for documentation on how to define standalone shared configs
Create Plugins > Configs in Plugins for documentation on how to define shared configs in plugins


            

            
                Edit this page\n\n\n\nESLint couldn't find the plugin …
                

                Table of Contents
    
        
                
                    
                    Symptoms
            		

                    Cause
            
                
                    
                    Plugin Name Variations
            		
                
            		

                    Resolution
            		

                    Resources
            		
                
            
    


                Symptoms
When using the legacy ESLint config system, you may see this error running ESLint after installing dependencies:


    ESLint couldn't find the plugin "${pluginName}".

(The package "${pluginName}" was not found when loaded as a Node module from the directory "${resolvePluginsRelativeTo}".)

It's likely that the plugin isn't installed correctly. Try reinstalling by running the following:

    npm install ${pluginName}@latest --save-dev

The plugin "${pluginName}" was referenced from the config file in "${importerName}".
123456789
    
        Copy code to clipboard
        
    

Cause
Legacy ESLint configuration files specify shareable configs by their package name.
That package name is passed to the Node.js require(), which looks up the package under local node_modules/ directories.
For example, the following ESLint config will first try to load a module located at node_modules/eslint-plugin-yours:


    module.exports = {
	extends: ["plugin:eslint-plugin-yours/config-name"],
};
123
    
        Copy code to clipboard
        
    

If the package is not found in any searched node_modules/, ESLint will print the aforementioned error.
Common reasons for this occurring include:

Not running npm install or the equivalent package manager command
Mistyping the case-sensitive name of the plugin

Plugin Name Variations
Note that the eslint-plugin- plugin name prefix may be omitted for brevity, e.g. extends: ["yours"].
@ npm scoped packages put the eslint-plugin- prefix after the org scope, e.g. extends: ["@org/yours"] to load from @org/eslint-plugin-yours.
Resolution
Common resolutions for this issue include:

Upgrading all versions of all packages to their latest version.
Adding the plugin as a devDependency in your package.json.
Running npm install or the equivalent package manager command.
Checking that the name in your config file matches the name of the plugin package.

Resources
For more information, see:

Legacy ESLint configuration files for documentation on the legacy ESLint configuration format
Configure Plugins for documentation on how to extend from plugins
Create Plugins for documentation on how to define plugins


            

            
                Edit this page\n\nESLint couldn't find the plugin …
                

                Table of Contents
    
        
                
                    
                    Symptoms
            		

                    Cause
            
                
                    
                    Plugin Name Variations
            		
                
            		

                    Resolution
            		

                    Resources
            		
                
            
    


                Symptoms
When using the legacy ESLint config system, you may see this error running ESLint after installing dependencies:


    ESLint couldn't find the plugin "${pluginName}".

(The package "${pluginName}" was not found when loaded as a Node module from the directory "${resolvePluginsRelativeTo}".)

It's likely that the plugin isn't installed correctly. Try reinstalling by running the following:

    npm install ${pluginName}@latest --save-dev

The plugin "${pluginName}" was referenced from the config file in "${importerName}".
123456789
    
        Copy code to clipboard
        
    

Cause
Legacy ESLint configuration files specify shareable configs by their package name.
That package name is passed to the Node.js require(), which looks up the package under local node_modules/ directories.
For example, the following ESLint config will first try to load a module located at node_modules/eslint-plugin-yours:


    module.exports = {
	extends: ["plugin:eslint-plugin-yours/config-name"],
};
123
    
        Copy code to clipboard
        
    

If the package is not found in any searched node_modules/, ESLint will print the aforementioned error.
Common reasons for this occurring include:

Not running npm install or the equivalent package manager command
Mistyping the case-sensitive name of the plugin

Plugin Name Variations
Note that the eslint-plugin- plugin name prefix may be omitted for brevity, e.g. extends: ["yours"].
@ npm scoped packages put the eslint-plugin- prefix after the org scope, e.g. extends: ["@org/yours"] to load from @org/eslint-plugin-yours.
Resolution
Common resolutions for this issue include:

Upgrading all versions of all packages to their latest version.
Adding the plugin as a devDependency in your package.json.
Running npm install or the equivalent package manager command.
Checking that the name in your config file matches the name of the plugin package.

Resources
For more information, see:

Legacy ESLint configuration files for documentation on the legacy ESLint configuration format
Configure Plugins for documentation on how to extend from plugins
Create Plugins for documentation on how to define plugins


            

            
                Edit this page\n\n\n\nTypeError: context.getScope is not a function
                

                Table of Contents
    
        
                
                    
                    Symptoms
            		

                    Cause
            		

                    Resolution
            		

                    Resources
            		
                
            
    


                Symptoms
When using ESLint v9.0.0 or later with a plugin, you may see one of the following errors:


    TypeError: context.getScope is not a function
TypeError: context.getAncestors is not a function
TypeError: context.markVariableAsUsed is not a function
TypeError: context.getDeclaredVariables is not a function
1234
    
        Copy code to clipboard
        
    

Cause
ESLint v9.0.0 introduces changes to the rules API that plugin rules use, which included moving some methods from the context object to the sourceCode object. If you’re seeing one of these errors, that means the plugin has not yet been updated to use the new rules API.
Resolution
Common resolutions for this issue include:

Upgrade the plugin to the latest version.
Use the compatibility utilities to patch the plugin in your config file.


                    
                    
                        Important
                        If you are already using the latest version of the plugin and you need to use the compatibility utilities to make the plugin work with ESLint v9.0.0 and later, make sure to open an issue on the plugin’s repository to ask the maintainer to make the necessary API changes.

                    
                Resources
For more information, see:

Configure Plugins for documentation on how to configure plugins
Create Plugins for documentation on how to define plugins


            

            
                Edit this page\n\nTypeError: context.getScope is not a function
                

                Table of Contents
    
        
                
                    
                    Symptoms
            		

                    Cause
            		

                    Resolution
            		

                    Resources
            		
                
            
    


                Symptoms
When using ESLint v9.0.0 or later with a plugin, you may see one of the following errors:


    TypeError: context.getScope is not a function
TypeError: context.getAncestors is not a function
TypeError: context.markVariableAsUsed is not a function
TypeError: context.getDeclaredVariables is not a function
1234
    
        Copy code to clipboard
        
    

Cause
ESLint v9.0.0 introduces changes to the rules API that plugin rules use, which included moving some methods from the context object to the sourceCode object. If you’re seeing one of these errors, that means the plugin has not yet been updated to use the new rules API.
Resolution
Common resolutions for this issue include:

Upgrade the plugin to the latest version.
Use the compatibility utilities to patch the plugin in your config file.


                    
                    
                        Important
                        If you are already using the latest version of the plugin and you need to use the compatibility utilities to make the plugin work with ESLint v9.0.0 and later, make sure to open an issue on the plugin’s repository to ask the maintainer to make the necessary API changes.

                    
                Resources
For more information, see:

Configure Plugins for documentation on how to configure plugins
Create Plugins for documentation on how to define plugins


            

            
                Edit this page\n\n\n\nExtend ESLint
                

                Table of Contents
    
        
                
                    
                    Ways to Extend ESLint
            		

                    Create Plugins
            		

                    Custom Rule Tutorial
            		

                    Custom Rules
            		

                    Custom Formatters
            		

                    Custom Parsers
            		

                    Custom Processors
            		

                    Share Configurations
            		
                
            
    


                This guide is intended for those who wish to extend the functionality of ESLint.
In order to extend ESLint, it’s recommended that:

You know JavaScript, since ESLint is written in JavaScript.
You have some familiarity with Node.js, since ESLint runs on it.
You’re comfortable with command-line programs.

If that sounds like you, then continue reading to get started.
Ways to Extend ESLint
This page summarizes the various ways that you can extend ESLint and how these extensions all fit together.
Create Plugins
You’ve developed custom rules for ESLint and you want to share them with the community. You can publish an ESLint plugin on npm.
Custom Rule Tutorial
A tutorial that walks you through creating a custom rule for ESLint.
Custom Rules
This section explains how to create custom rules to use with ESLint.
Custom Formatters
This section explains how you can create a custom formatter to control what ESLint outputs.
Custom Parsers
If you don’t want to use the default parser of ESLint, this section explains how to create custom parsers.
Custom Processors
This section explains how you can use a custom processor to have ESLint process files other than JavaScript.
Share Configurations
This section explains how you can bundle and share ESLint configuration in a JavaScript package.

            

            
                Edit this page\n\nExtend ESLint
                

                Table of Contents
    
        
                
                    
                    Ways to Extend ESLint
            		

                    Create Plugins
            		

                    Custom Rule Tutorial
            		

                    Custom Rules
            		

                    Custom Formatters
            		

                    Custom Parsers
            		

                    Custom Processors
            		

                    Share Configurations
            		
                
            
    


                This guide is intended for those who wish to extend the functionality of ESLint.
In order to extend ESLint, it’s recommended that:

You know JavaScript, since ESLint is written in JavaScript.
You have some familiarity with Node.js, since ESLint runs on it.
You’re comfortable with command-line programs.

If that sounds like you, then continue reading to get started.
Ways to Extend ESLint
This page summarizes the various ways that you can extend ESLint and how these extensions all fit together.
Create Plugins
You’ve developed custom rules for ESLint and you want to share them with the community. You can publish an ESLint plugin on npm.
Custom Rule Tutorial
A tutorial that walks you through creating a custom rule for ESLint.
Custom Rules
This section explains how to create custom rules to use with ESLint.
Custom Formatters
This section explains how you can create a custom formatter to control what ESLint outputs.
Custom Parsers
If you don’t want to use the default parser of ESLint, this section explains how to create custom parsers.
Custom Processors
This section explains how you can use a custom processor to have ESLint process files other than JavaScript.
Share Configurations
This section explains how you can bundle and share ESLint configuration in a JavaScript package.

            

            
                Edit this page\n\n\n\nWays to Extend ESLint
                

                Table of Contents
    
        
                
                    
                    Plugins
            		

                    Shareable Configs
            		

                    Custom Formatters
            		

                    Custom Parsers
            		
                
            
    


                ESLint is highly pluggable and configurable. There are a variety of ways that you can extend ESLint’s functionality.
This page explains the ways to extend ESLint, and how these extensions all fit together.
Plugins
Plugins let you add your own ESLint custom rules and custom processors to a project. You can publish a plugin as an npm module.
Plugins are useful because your project may require some ESLint configuration that isn’t included in the core eslint package. For example, if you’re using a frontend JavaScript library like React or framework like Vue, these tools have some features that require custom rules outside the scope of the ESLint core rules.
Often a plugin is paired with a configuration for ESLint that applies a set of features from the plugin to a project. You can include configurations in a plugin as well.
For example, eslint-plugin-react is an ESLint plugin that includes rules specifically for React projects. The rules include things like enforcing consistent usage of React component lifecycle methods and requiring the use of key props when rendering dynamic lists.
To learn more about creating the extensions you can include in a plugin, refer to the following documentation:

Custom Rules
Custom Processors
Configs in Plugins

To learn more about bundling these extensions into a plugin, refer to Plugins.
Shareable Configs
ESLint shareable configs are pre-defined configurations for ESLint that you can use in your projects. They bundle rules and other configuration together in an npm package. Anything that you can put in a configuration file can be put in a shareable config.
You can either publish a shareable config independently or as part of a plugin.
For example, a popular shareable config is eslint-config-airbnb, which contains a variety of rules in addition to some parser options. This is a set of rules for ESLint that is designed to match the style guide used by the Airbnb JavaScript style guide. By using the eslint-config-airbnb shareable config, you can automatically enforce the Airbnb style guide in your project without having to manually configure each rule.
To learn more about creating a shareable config, refer to Share Configuration.
Custom Formatters
Custom formatters take ESLint linting results and output the results in a format that you define. Custom formatters let you display linting results in a format that best fits your needs, whether that’s in a specific file format, a certain display style, or a format optimized for a particular tool. You only need to create a custom formatter if the built-in formatters don’t serve your use case.
For example, the custom formatter eslint-formatter-gitlab can be used to display ESLint results in GitLab code quality reports.
To learn more about creating a custom formatter, refer to Custom Formatters.
Custom Parsers
ESLint custom parsers are a way to extend ESLint to support the linting of new language features or custom syntax in your code. A parser is responsible for taking your code and transforming it into an abstract syntax tree (AST) that ESLint can then analyze and lint.
ESLint ships with a built-in JavaScript parser (Espree), but custom parsers allow you to lint other languages or to extend the linting capabilities of the built-in parser.
For example, the custom parser @typescript-eslint/parser extends ESLint to lint TypeScript code.
Custom parsers can be also included in a plugin.
To learn more about creating a custom parser, refer to Custom Parsers.

            

            
                Edit this page\n\nWays to Extend ESLint
                

                Table of Contents
    
        
                
                    
                    Plugins
            		

                    Shareable Configs
            		

                    Custom Formatters
            		

                    Custom Parsers
            		
                
            
    


                ESLint is highly pluggable and configurable. There are a variety of ways that you can extend ESLint’s functionality.
This page explains the ways to extend ESLint, and how these extensions all fit together.
Plugins
Plugins let you add your own ESLint custom rules and custom processors to a project. You can publish a plugin as an npm module.
Plugins are useful because your project may require some ESLint configuration that isn’t included in the core eslint package. For example, if you’re using a frontend JavaScript library like React or framework like Vue, these tools have some features that require custom rules outside the scope of the ESLint core rules.
Often a plugin is paired with a configuration for ESLint that applies a set of features from the plugin to a project. You can include configurations in a plugin as well.
For example, eslint-plugin-react is an ESLint plugin that includes rules specifically for React projects. The rules include things like enforcing consistent usage of React component lifecycle methods and requiring the use of key props when rendering dynamic lists.
To learn more about creating the extensions you can include in a plugin, refer to the following documentation:

Custom Rules
Custom Processors
Configs in Plugins

To learn more about bundling these extensions into a plugin, refer to Plugins.
Shareable Configs
ESLint shareable configs are pre-defined configurations for ESLint that you can use in your projects. They bundle rules and other configuration together in an npm package. Anything that you can put in a configuration file can be put in a shareable config.
You can either publish a shareable config independently or as part of a plugin.
For example, a popular shareable config is eslint-config-airbnb, which contains a variety of rules in addition to some parser options. This is a set of rules for ESLint that is designed to match the style guide used by the Airbnb JavaScript style guide. By using the eslint-config-airbnb shareable config, you can automatically enforce the Airbnb style guide in your project without having to manually configure each rule.
To learn more about creating a shareable config, refer to Share Configuration.
Custom Formatters
Custom formatters take ESLint linting results and output the results in a format that you define. Custom formatters let you display linting results in a format that best fits your needs, whether that’s in a specific file format, a certain display style, or a format optimized for a particular tool. You only need to create a custom formatter if the built-in formatters don’t serve your use case.
For example, the custom formatter eslint-formatter-gitlab can be used to display ESLint results in GitLab code quality reports.
To learn more about creating a custom formatter, refer to Custom Formatters.
Custom Parsers
ESLint custom parsers are a way to extend ESLint to support the linting of new language features or custom syntax in your code. A parser is responsible for taking your code and transforming it into an abstract syntax tree (AST) that ESLint can then analyze and lint.
ESLint ships with a built-in JavaScript parser (Espree), but custom parsers allow you to lint other languages or to extend the linting capabilities of the built-in parser.
For example, the custom parser @typescript-eslint/parser extends ESLint to lint TypeScript code.
Custom parsers can be also included in a plugin.
To learn more about creating a custom parser, refer to Custom Parsers.

            

            
                Edit this page\n\n\n\nCreate Plugins
                

                Table of Contents
    
        
                
                    
                    Creating a plugin
            
                
                    
                    Meta Data in Plugins
            		

                    Rules in Plugins
            		

                    Processors in Plugins
            		

                    Configs in Plugins
            
                
                    
                    Backwards Compatibility for Legacy Configs
            		
                
            		
                
            		

                    Testing a Plugin
            		

                    Linting a Plugin
            		

                    Share Plugins
            		
                
            
    


                ESLint plugins extend ESLint with additional functionality. In most cases, you’ll extend ESLint by creating plugins that encapsulate the additional functionality you want to share across multiple projects.
Creating a plugin
A plugin is a JavaScript object that exposes certain properties to ESLint:

meta - information about the plugin.
configs - an object containing named configurations.
rules - an object containing the definitions of custom rules.
processors - an object containing named processors.

To get started, create a JavaScript file and export an object containing the properties you’d like ESLint to use. To make your plugin as easy to maintain as possible, we recommend that you format your plugin entrypoint file to look like this:


    const plugin = {
	meta: {},
	configs: {},
	rules: {},
	processors: {},
};

// for ESM
export default plugin;

// OR for CommonJS
module.exports = plugin;
123456789101112
    
        Copy code to clipboard
        
    

If you plan to distribute your plugin as an npm package, make sure that the module that exports the plugin object is the default export of your package. This will enable ESLint to import the plugin when it is specified in the command line in the --plugin option.
Meta Data in Plugins
For easier debugging and more effective caching of plugins, it’s recommended to provide a name and version in a meta object at the root of your plugin, like this:


    const plugin = {
	// preferred location of name and version
	meta: {
		name: "eslint-plugin-example",
		version: "1.2.3",
	},
	rules: {
		// add rules here
	},
};

// for ESM
export default plugin;

// OR for CommonJS
module.exports = plugin;
12345678910111213141516
    
        Copy code to clipboard
        
    

The meta.name property should match the npm package name for your plugin and the meta.version property should match the npm package version for your plugin. The easiest way to accomplish this is by reading this information from your package.json, as in this example:


    import fs from "fs";

const pkg = JSON.parse(
	fs.readFileSync(new URL("./package.json", import.meta.url), "utf8"),
);

const plugin = {
	// preferred location of name and version
	meta: {
		name: pkg.name,
		version: pkg.version,
	},
	rules: {
		// add rules here
	},
};

export default plugin;
123456789101112131415161718
    
        Copy code to clipboard
        
    


                    
                    
                        Tip
                        While there are no restrictions on plugin names, it helps others to find your plugin on npm when you follow these naming conventions:

Unscoped: If your npm package name won’t be scoped (doesn’t begin with @), then the plugin name should begin with eslint-plugin-, such as eslint-plugin-example.
Scoped: If your npm package name will be scoped, then the plugin name should be in the format of @<scope>/eslint-plugin-<plugin-name> such as @jquery/eslint-plugin-jquery or even @<scope>/eslint-plugin such as @jquery/eslint-plugin.
:::

As an alternative, you can also expose name and version properties at the root of your plugin, such as:


    const plugin = {
	// alternate location of name and version
	name: "eslint-plugin-example",
	version: "1.2.3",
	rules: {
		// add rules here
	},
};

// for ESM
export default plugin;

// OR for CommonJS
module.exports = plugin;
1234567891011121314
    
        Copy code to clipboard
        
    


                    
                    
                        Important
                        While the meta object is the preferred way to provide the plugin name and version, this format is also acceptable and is provided for backward compatibility.

                    
                
                    
                Rules in Plugins
Plugins can expose custom rules for use in ESLint. To do so, the plugin must export a rules object containing a key-value mapping of rule ID to rule. The rule ID does not have to follow any naming convention except that it should not contain a / character (so it can just be dollar-sign but not foo/dollar-sign, for instance). To learn more about creating custom rules in plugins, refer to Custom Rules.


    const plugin = {
	meta: {
		name: "eslint-plugin-example",
		version: "1.2.3",
	},
	rules: {
		"dollar-sign": {
			create(context) {
				// rule implementation ...
			},
		},
	},
};

// for ESM
export default plugin;

// OR for CommonJS
module.exports = plugin;
12345678910111213141516171819
    
        Copy code to clipboard
        
    

In order to use a rule from a plugin in a configuration file, import the plugin and include it in the plugins key, specifying a namespace. Then, use that namespace to reference the rule in the rules configuration, like this:


    // eslint.config.js
import { defineConfig } from "eslint/config";
import example from "eslint-plugin-example";

export default defineConfig([
	{
		plugins: {
			example,
		},
		rules: {
			"example/dollar-sign": "error",
		},
	},
]);
1234567891011121314
    
        Copy code to clipboard
        
    


                    
                    
                        Warning
                        Namespaces that don’t begin with @ may not contain a /; namespaces that begin with @ may contain a /. For example, eslint/plugin is not a valid namespace but @eslint/plugin is valid. This restriction is for backwards compatibility with eslintrc plugin naming restrictions.

                    
                Processors in Plugins
Plugins can expose processors for use in configuration file by providing a processors object. Similar to rules, each key in the processors object is the name of a processor and each value is the processor object itself. Here’s an example:


    const plugin = {
	meta: {
		name: "eslint-plugin-example",
		version: "1.2.3",
	},
	processors: {
		"processor-name": {
			preprocess(text, filename) {
				/* ... */
			},
			postprocess(messages, filename) {
				/* ... */
			},
		},
	},
};

// for ESM
export default plugin;

// OR for CommonJS
module.exports = plugin;
12345678910111213141516171819202122
    
        Copy code to clipboard
        
    

In order to use a processor from a plugin in a configuration file, import the plugin and include it in the plugins key, specifying a namespace. Then, use that namespace to reference the processor in the processor configuration, like this:


    // eslint.config.js
import { defineConfig } from "eslint/config";
import example from "eslint-plugin-example";

export default defineConfig([
	{
		files: ["**/*.txt"],
		plugins: {
			example,
		},
		processor: "example/processor-name",
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    

Configs in Plugins
You can bundle configurations inside a plugin by specifying them under the configs key. This can be useful when you want to bundle a set of custom rules with a configuration that enables the recommended options. Multiple configurations are supported per plugin.
You can include individual rules from a plugin in a config that’s also included in the plugin. In the config, you must specify your plugin name in the plugins object as well as any rules you want to enable that are part of the plugin. Any plugin rules must be prefixed with the plugin namespace. Here’s an example:


    const plugin = {
	meta: {
		name: "eslint-plugin-example",
		version: "1.2.3",
	},
	configs: {},
	rules: {
		"dollar-sign": {
			create(context) {
				// rule implementation ...
			},
		},
	},
};

// assign configs here so we can reference `plugin`
Object.assign(plugin.configs, {
	recommended: [
		{
			plugins: {
				example: plugin,
			},
			rules: {
				"example/dollar-sign": "error",
			},
			languageOptions: {
				globals: {
					myGlobal: "readonly",
				},
				parserOptions: {
					ecmaFeatures: {
						jsx: true,
					},
				},
			},
		},
	],
});

// for ESM
export default plugin;

// OR for CommonJS
module.exports = plugin;
1234567891011121314151617181920212223242526272829303132333435363738394041424344
    
        Copy code to clipboard
        
    

This plugin exports a recommended config that is an array with one config object. When there is just one config object, you can also export just the object without an enclosing array.
In order to use a config from a plugin in a configuration file, import the plugin and use the extends key to reference the name of the config, like this:


    // eslint.config.js
import { defineConfig } from "eslint/config";
import example from "eslint-plugin-example";

export default defineConfig([
	{
		files: ["**/*.js"], // any patterns you want to apply the config to
		plugins: {
			example,
		},
		extends: ["example/recommended"],
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    


                    
                    
                        Important
                        Plugins cannot force a specific configuration to be used. Users must manually include a plugin’s configurations in their configuration file.

                    
                Backwards Compatibility for Legacy Configs
If your plugin needs to export configs that work both with the current (flat config) system and the old (eslintrc) system, you can export both config types from the configs key. When exporting legacy configs, we recommend prefixing the name with "legacy-" (for example, "legacy-recommended") to make it clear how the config should be used.
If you’re working on a plugin that has existed prior to ESLint v9.0.0, then you may already have legacy configs with names such as "recommended". If you don’t want to update the config name, you can also create an additional entry in the configs object prefixed with "flat/" (for example, "flat/recommended"). Here’s an example:


    const plugin = {
	meta: {
		name: "eslint-plugin-example",
		version: "1.2.3",
	},
	configs: {},
	rules: {
		"dollar-sign": {
			create(context) {
				// rule implementation ...
			},
		},
	},
};

// assign configs here so we can reference `plugin`
Object.assign(plugin.configs, {
	// flat config format
	"flat/recommended": [
		{
			plugins: {
				example: plugin,
			},
			rules: {
				"example/dollar-sign": "error",
			},
			languageOptions: {
				globals: {
					myGlobal: "readonly",
				},
				parserOptions: {
					ecmaFeatures: {
						jsx: true,
					},
				},
			},
		},
	],

	// eslintrc format
	recommended: {
		plugins: ["example"],
		rules: {
			"example/dollar-sign": "error",
		},
		globals: {
			myGlobal: "readonly",
		},
		parserOptions: {
			ecmaFeatures: {
				jsx: true,
			},
		},
	},
});

// for ESM
export default plugin;

// OR for CommonJS
module.exports = plugin;
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061
    
        Copy code to clipboard
        
    

With this approach, both configuration systems recognize "recommended". The old config system uses the recommended key while the current config system uses the flat/recommended key. The defineConfig() helper first looks at the recommended key, and if that is not in the correct format, it looks for the flat/recommended key. This allows you an upgrade path if you’d later like to rename flat/recommended to recommended when you no longer need to support the old config system.
Testing a Plugin
ESLint provides the RuleTester utility to make it easy to test the rules of your plugin.
Linting a Plugin
ESLint plugins should be linted too! It’s suggested to lint your plugin with the recommended configurations of:

eslint
eslint-plugin-eslint-plugin
eslint-plugin-n

Share Plugins
In order to make your plugin available publicly, you have to publish it on npm. When doing so, please be sure to:


List ESLint as a peer dependency. Because plugins are intended for use with ESLint, it’s important to add the eslint package as a peer dependency. To do so, manually edit your package.json file to include a peerDependencies block, like this:


    {
	"peerDependencies": {
		"eslint": ">=9.0.0"
	}
}
12345
    
        Copy code to clipboard
        
    



Specify keywords. ESLint plugins should specify eslint, eslintplugin and eslint-plugin as keywords in your package.json file.



            

            
                Edit this page\n\nCreate Plugins
                

                Table of Contents
    
        
                
                    
                    Creating a plugin
            
                
                    
                    Meta Data in Plugins
            		

                    Rules in Plugins
            		

                    Processors in Plugins
            		

                    Configs in Plugins
            
                
                    
                    Backwards Compatibility for Legacy Configs
            		
                
            		
                
            		

                    Testing a Plugin
            		

                    Linting a Plugin
            		

                    Share Plugins
            		
                
            
    


                ESLint plugins extend ESLint with additional functionality. In most cases, you’ll extend ESLint by creating plugins that encapsulate the additional functionality you want to share across multiple projects.
Creating a plugin
A plugin is a JavaScript object that exposes certain properties to ESLint:

meta - information about the plugin.
configs - an object containing named configurations.
rules - an object containing the definitions of custom rules.
processors - an object containing named processors.

To get started, create a JavaScript file and export an object containing the properties you’d like ESLint to use. To make your plugin as easy to maintain as possible, we recommend that you format your plugin entrypoint file to look like this:


    const plugin = {
	meta: {},
	configs: {},
	rules: {},
	processors: {},
};

// for ESM
export default plugin;

// OR for CommonJS
module.exports = plugin;
123456789101112
    
        Copy code to clipboard
        
    

If you plan to distribute your plugin as an npm package, make sure that the module that exports the plugin object is the default export of your package. This will enable ESLint to import the plugin when it is specified in the command line in the --plugin option.
Meta Data in Plugins
For easier debugging and more effective caching of plugins, it’s recommended to provide a name and version in a meta object at the root of your plugin, like this:


    const plugin = {
	// preferred location of name and version
	meta: {
		name: "eslint-plugin-example",
		version: "1.2.3",
	},
	rules: {
		// add rules here
	},
};

// for ESM
export default plugin;

// OR for CommonJS
module.exports = plugin;
12345678910111213141516
    
        Copy code to clipboard
        
    

The meta.name property should match the npm package name for your plugin and the meta.version property should match the npm package version for your plugin. The easiest way to accomplish this is by reading this information from your package.json, as in this example:


    import fs from "fs";

const pkg = JSON.parse(
	fs.readFileSync(new URL("./package.json", import.meta.url), "utf8"),
);

const plugin = {
	// preferred location of name and version
	meta: {
		name: pkg.name,
		version: pkg.version,
	},
	rules: {
		// add rules here
	},
};

export default plugin;
123456789101112131415161718
    
        Copy code to clipboard
        
    


                    
                    
                        Tip
                        While there are no restrictions on plugin names, it helps others to find your plugin on npm when you follow these naming conventions:

Unscoped: If your npm package name won’t be scoped (doesn’t begin with @), then the plugin name should begin with eslint-plugin-, such as eslint-plugin-example.
Scoped: If your npm package name will be scoped, then the plugin name should be in the format of @<scope>/eslint-plugin-<plugin-name> such as @jquery/eslint-plugin-jquery or even @<scope>/eslint-plugin such as @jquery/eslint-plugin.
:::

As an alternative, you can also expose name and version properties at the root of your plugin, such as:


    const plugin = {
	// alternate location of name and version
	name: "eslint-plugin-example",
	version: "1.2.3",
	rules: {
		// add rules here
	},
};

// for ESM
export default plugin;

// OR for CommonJS
module.exports = plugin;
1234567891011121314
    
        Copy code to clipboard
        
    


                    
                    
                        Important
                        While the meta object is the preferred way to provide the plugin name and version, this format is also acceptable and is provided for backward compatibility.

                    
                
                    
                Rules in Plugins
Plugins can expose custom rules for use in ESLint. To do so, the plugin must export a rules object containing a key-value mapping of rule ID to rule. The rule ID does not have to follow any naming convention except that it should not contain a / character (so it can just be dollar-sign but not foo/dollar-sign, for instance). To learn more about creating custom rules in plugins, refer to Custom Rules.


    const plugin = {
	meta: {
		name: "eslint-plugin-example",
		version: "1.2.3",
	},
	rules: {
		"dollar-sign": {
			create(context) {
				// rule implementation ...
			},
		},
	},
};

// for ESM
export default plugin;

// OR for CommonJS
module.exports = plugin;
12345678910111213141516171819
    
        Copy code to clipboard
        
    

In order to use a rule from a plugin in a configuration file, import the plugin and include it in the plugins key, specifying a namespace. Then, use that namespace to reference the rule in the rules configuration, like this:


    // eslint.config.js
import { defineConfig } from "eslint/config";
import example from "eslint-plugin-example";

export default defineConfig([
	{
		plugins: {
			example,
		},
		rules: {
			"example/dollar-sign": "error",
		},
	},
]);
1234567891011121314
    
        Copy code to clipboard
        
    


                    
                    
                        Warning
                        Namespaces that don’t begin with @ may not contain a /; namespaces that begin with @ may contain a /. For example, eslint/plugin is not a valid namespace but @eslint/plugin is valid. This restriction is for backwards compatibility with eslintrc plugin naming restrictions.

                    
                Processors in Plugins
Plugins can expose processors for use in configuration file by providing a processors object. Similar to rules, each key in the processors object is the name of a processor and each value is the processor object itself. Here’s an example:


    const plugin = {
	meta: {
		name: "eslint-plugin-example",
		version: "1.2.3",
	},
	processors: {
		"processor-name": {
			preprocess(text, filename) {
				/* ... */
			},
			postprocess(messages, filename) {
				/* ... */
			},
		},
	},
};

// for ESM
export default plugin;

// OR for CommonJS
module.exports = plugin;
12345678910111213141516171819202122
    
        Copy code to clipboard
        
    

In order to use a processor from a plugin in a configuration file, import the plugin and include it in the plugins key, specifying a namespace. Then, use that namespace to reference the processor in the processor configuration, like this:


    // eslint.config.js
import { defineConfig } from "eslint/config";
import example from "eslint-plugin-example";

export default defineConfig([
	{
		files: ["**/*.txt"],
		plugins: {
			example,
		},
		processor: "example/processor-name",
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    

Configs in Plugins
You can bundle configurations inside a plugin by specifying them under the configs key. This can be useful when you want to bundle a set of custom rules with a configuration that enables the recommended options. Multiple configurations are supported per plugin.
You can include individual rules from a plugin in a config that’s also included in the plugin. In the config, you must specify your plugin name in the plugins object as well as any rules you want to enable that are part of the plugin. Any plugin rules must be prefixed with the plugin namespace. Here’s an example:


    const plugin = {
	meta: {
		name: "eslint-plugin-example",
		version: "1.2.3",
	},
	configs: {},
	rules: {
		"dollar-sign": {
			create(context) {
				// rule implementation ...
			},
		},
	},
};

// assign configs here so we can reference `plugin`
Object.assign(plugin.configs, {
	recommended: [
		{
			plugins: {
				example: plugin,
			},
			rules: {
				"example/dollar-sign": "error",
			},
			languageOptions: {
				globals: {
					myGlobal: "readonly",
				},
				parserOptions: {
					ecmaFeatures: {
						jsx: true,
					},
				},
			},
		},
	],
});

// for ESM
export default plugin;

// OR for CommonJS
module.exports = plugin;
1234567891011121314151617181920212223242526272829303132333435363738394041424344
    
        Copy code to clipboard
        
    

This plugin exports a recommended config that is an array with one config object. When there is just one config object, you can also export just the object without an enclosing array.
In order to use a config from a plugin in a configuration file, import the plugin and use the extends key to reference the name of the config, like this:


    // eslint.config.js
import { defineConfig } from "eslint/config";
import example from "eslint-plugin-example";

export default defineConfig([
	{
		files: ["**/*.js"], // any patterns you want to apply the config to
		plugins: {
			example,
		},
		extends: ["example/recommended"],
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    


                    
                    
                        Important
                        Plugins cannot force a specific configuration to be used. Users must manually include a plugin’s configurations in their configuration file.

                    
                Backwards Compatibility for Legacy Configs
If your plugin needs to export configs that work both with the current (flat config) system and the old (eslintrc) system, you can export both config types from the configs key. When exporting legacy configs, we recommend prefixing the name with "legacy-" (for example, "legacy-recommended") to make it clear how the config should be used.
If you’re working on a plugin that has existed prior to ESLint v9.0.0, then you may already have legacy configs with names such as "recommended". If you don’t want to update the config name, you can also create an additional entry in the configs object prefixed with "flat/" (for example, "flat/recommended"). Here’s an example:


    const plugin = {
	meta: {
		name: "eslint-plugin-example",
		version: "1.2.3",
	},
	configs: {},
	rules: {
		"dollar-sign": {
			create(context) {
				// rule implementation ...
			},
		},
	},
};

// assign configs here so we can reference `plugin`
Object.assign(plugin.configs, {
	// flat config format
	"flat/recommended": [
		{
			plugins: {
				example: plugin,
			},
			rules: {
				"example/dollar-sign": "error",
			},
			languageOptions: {
				globals: {
					myGlobal: "readonly",
				},
				parserOptions: {
					ecmaFeatures: {
						jsx: true,
					},
				},
			},
		},
	],

	// eslintrc format
	recommended: {
		plugins: ["example"],
		rules: {
			"example/dollar-sign": "error",
		},
		globals: {
			myGlobal: "readonly",
		},
		parserOptions: {
			ecmaFeatures: {
				jsx: true,
			},
		},
	},
});

// for ESM
export default plugin;

// OR for CommonJS
module.exports = plugin;
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061
    
        Copy code to clipboard
        
    

With this approach, both configuration systems recognize "recommended". The old config system uses the recommended key while the current config system uses the flat/recommended key. The defineConfig() helper first looks at the recommended key, and if that is not in the correct format, it looks for the flat/recommended key. This allows you an upgrade path if you’d later like to rename flat/recommended to recommended when you no longer need to support the old config system.
Testing a Plugin
ESLint provides the RuleTester utility to make it easy to test the rules of your plugin.
Linting a Plugin
ESLint plugins should be linted too! It’s suggested to lint your plugin with the recommended configurations of:

eslint
eslint-plugin-eslint-plugin
eslint-plugin-n

Share Plugins
In order to make your plugin available publicly, you have to publish it on npm. When doing so, please be sure to:


List ESLint as a peer dependency. Because plugins are intended for use with ESLint, it’s important to add the eslint package as a peer dependency. To do so, manually edit your package.json file to include a peerDependencies block, like this:


    {
	"peerDependencies": {
		"eslint": ">=9.0.0"
	}
}
12345
    
        Copy code to clipboard
        
    



Specify keywords. ESLint plugins should specify eslint, eslintplugin and eslint-plugin as keywords in your package.json file.



            

            
                Edit this page\n\n\n\nCustom Rule Tutorial
                

                Table of Contents
    
        
                
                    
                    Why Create a Custom Rule?
            		

                    Prerequisites
            		

                    The Custom Rule
            		

                    Step 1: Set up Your Project
            		

                    Step 2: Stub Out the Rule File
            		

                    Step 3: Add Rule Metadata
            		

                    Step 4: Add Rule Visitor Methods
            		

                    Step 5: Set up Testing
            		

                    Step 6: Write the Test
            		

                    Step 7: Bundle the Custom Rule in a Plugin
            		

                    Step 8: Use the Plugin Locally
            		

                    Step 9: Publish the Plugin
            		

                    Step 10: Use the Published Custom Rule
            		

                    Summary
            		

                    View the Tutorial Code
            		
                
            
    


                This tutorial covers how to create a custom rule for ESLint and distribute it with a plugin.
You can create custom rules to validate if your code meets a certain expectation, and determine what to do if it does not meet that expectation. Plugins package custom rules and other configuration, allowing you to easily share and reuse them in different projects.
To learn more about custom rules and plugins refer to the following documentation:

Custom Rules
Plugins

Why Create a Custom Rule?
Create a custom rule if the ESLint built-in rules and community-published custom rules do not meet your needs. You might create a custom rule to enforce a best practice for your company or project, prevent a particular bug from recurring, or ensure compliance with a style guide.
Before creating a custom rule that isn’t specific to your company or project, it’s worth searching the web to see if someone has published a plugin with a custom rule that solves your use case. It’s quite possible the rule may already exist.
Prerequisites
Before you begin, make sure you have the following installed in your development environment:

Node.js
npm

This tutorial also assumes that you have a basic understanding of ESLint and ESLint rules.
The Custom Rule
The custom rule in this tutorial requires that all const variables named foo are assigned the string literal "bar". The rule is defined in the file enforce-foo-bar.js. The rule also suggests replacing any other value assigned to const foo with "bar".
For example, say you had the following foo.js file:


    // foo.js

const foo = "baz123";
123
    
        Copy code to clipboard
        
    

Running ESLint with the rule would flag "baz123" as an incorrect value for variable foo. If ESLint is running in autofix mode, then ESLint would fix the file to contain the following:


    // foo.js

const foo = "bar";
123
    
        Copy code to clipboard
        
    

Step 1: Set up Your Project
First, create a new project for your custom rule. Create a new directory, initiate a new npm project in it, and create a new file for the custom rule:


    mkdir eslint-custom-rule-example # create directory
cd eslint-custom-rule-example # enter the directory
npm init -y # init new npm project
touch enforce-foo-bar.js # create file enforce-foo-bar.js
1234
    
        Copy code to clipboard
        
    

Step 2: Stub Out the Rule File
In the enforce-foo-bar.js file, add some scaffolding for the enforce-foo-bar custom rule. Also, add a meta object with some basic information about the rule.


    // enforce-foo-bar.js

module.exports = {
	meta: {
		// TODO: add metadata
	},
	create(context) {
		return {
			// TODO: add callback function(s)
		};
	},
};
123456789101112
    
        Copy code to clipboard
        
    

Step 3: Add Rule Metadata
Before writing the rule, add some metadata to the rule object. ESLint uses this information when running the rule.
Start by exporting an object with a meta property containing the rule’s metadata, such as the rule type, documentation, and fixability. In this case, the rule type is “problem,” the description is “Enforce that a variable named foo can only be assigned a value of ‘bar’.”, and the rule is fixable by modifying the code.


    // enforce-foo-bar.js

module.exports = {
	meta: {
		type: "problem",
		docs: {
			description:
				"Enforce that a variable named `foo` can only be assigned a value of 'bar'.",
		},
		fixable: "code",
		schema: [],
	},
	create(context) {
		return {
			// TODO: add callback function(s)
		};
	},
};
123456789101112131415161718
    
        Copy code to clipboard
        
    

To learn more about rule metadata, refer to Rule Structure.
Step 4: Add Rule Visitor Methods
Define the rule’s create function, which accepts a context object and returns an object with a property for each syntax node type you want to handle. In this case, you want to handle VariableDeclarator nodes.
You can choose any ESTree node type or selector.

                    
                    
                        Tip
                        You can view the AST for any JavaScript code using Code Explorer. This is helpful in determining the type of nodes you’d like to target.

                    
                Inside the VariableDeclarator visitor method, check if the node represents a const variable declaration, if its name is foo, and if it’s not assigned to the string "bar". You do this by evaluating the node passed to the VariableDeclaration method.
If the const foo declaration is assigned a value of "bar", then the rule does nothing. If const foo is not assigned a value of "bar", then context.report() reports an error to ESLint. The error report includes information about the error and how to fix it.


    // enforce-foo-bar.js

module.exports = {
    meta: {
        type: "problem",
        docs: {
            description: "Enforce that a variable named `foo` can only be assigned a value of 'bar'."
        },
        fixable: "code",
        schema: []
    },
    create(context) {
        return {

            // Performs action in the function on every variable declarator
            VariableDeclarator(node) {

                // Check if a `const` variable declaration
                if (node.parent.kind === "const") {

                    // Check if variable name is `foo`
                    if (node.id.type === "Identifier" && node.id.name === "foo") {

                        // Check if value of variable is "bar"
                        if (node.init && node.init.type === "Literal" && node.init.value !== "bar") {

                            /*
                             * Report error to ESLint. Error message uses
                             * a message placeholder to include the incorrect value
                             * in the error message.
                             * Also includes a `fix(fixer)` function that replaces
                             * any values assigned to `const foo` with "bar".
                             */
                            context.report({
                                node,
                                message: 'Value other than "bar" assigned to `const foo`. Unexpected value: {{ notBar }}.',
                                data: {
                                    notBar: node.init.value
                                },
                                fix(fixer) {
                                    return fixer.replaceText(node.init, '"bar"');
                                }
                            });
                        }
                    }
                }
            }
        };
    }
};

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051
    
        Copy code to clipboard
        
    

Step 5: Set up Testing
With the rule written, you can test it to make sure it’s working as expected.
ESLint provides the built-in RuleTester class to test rules. You do not need to use third-party testing libraries to test ESLint rules, but RuleTester works seamlessly with tools like Mocha and Jest.
Next, create the file for the tests, enforce-foo-bar.test.js:


    touch enforce-foo-bar.test.js
1
    
        Copy code to clipboard
        
    

You will use the eslint package in the test file. Install it as a development dependency:

   
      npm
      yarn
      pnpm
      bun
   
    
        npm


    npm install --save-dev eslint
1
    
        Copy code to clipboard
        
    


   
      yarn


    yarn add --dev eslint
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm add --save-dev eslint
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bun add --dev eslint
1
    
        Copy code to clipboard
        
    

   

And add a test script to your package.json file to run the tests:


    // package.json
{
    // ...other configuration
    "scripts": {
        "test": "node enforce-foo-bar.test.js"
    },
    // ...other configuration
}
12345678
    
        Copy code to clipboard
        
    

Step 6: Write the Test
To write the test using RuleTester, import the class and your custom rule into the enforce-foo-bar.test.js file.
The RuleTester#run() method tests the rule against valid and invalid test cases. If the rule fails to pass any of the test scenarios, this method throws an error.
RuleTester requires that at least one valid and one invalid test scenario be present.


    // enforce-foo-bar.test.js
const { RuleTester } = require("eslint");
const fooBarRule = require("./enforce-foo-bar");

const ruleTester = new RuleTester({
	// Must use at least ecmaVersion 2015 because
	// that's when `const` variables were introduced.
	languageOptions: { ecmaVersion: 2015 },
});

// Throws error if the tests in ruleTester.run() do not pass
ruleTester.run(
	"enforce-foo-bar", // rule name
	fooBarRule, // rule code
	{
		// checks
		// 'valid' checks cases that should pass
		valid: [
			{
				code: "const foo = 'bar';",
			},
		],
		// 'invalid' checks cases that should not pass
		invalid: [
			{
				code: "const foo = 'baz';",
				output: 'const foo = "bar";',
				errors: 1,
			},
		],
	},
);

console.log("All tests passed!");
12345678910111213141516171819202122232425262728293031323334
    
        Copy code to clipboard
        
    

Run the test with the following command:


    npm test
1
    
        Copy code to clipboard
        
    

If the test passes, you should see the following in your console:


    All tests passed!
1
    
        Copy code to clipboard
        
    

Step 7: Bundle the Custom Rule in a Plugin
Now that you’ve written the custom rule and validated that it works, you can include it in a plugin. Using a plugin, you can share the rule in an npm package to use in other projects.
Create the file for the plugin:


    touch eslint-plugin-example.js
1
    
        Copy code to clipboard
        
    

And now write the plugin code. Plugins are just exported JavaScript objects. To include a rule in a plugin, include it in the plugin’s rules object, which contains key-value pairs of rule names and their source code.
To learn more about creating plugins, refer to Create Plugins.


    // eslint-plugin-example.js

const fooBarRule = require("./enforce-foo-bar");
const plugin = { rules: { "enforce-foo-bar": fooBarRule } };
module.exports = plugin;
12345
    
        Copy code to clipboard
        
    

Step 8: Use the Plugin Locally
You can use a locally defined plugin to execute the custom rule in your project. To use a local plugin, specify the path to the plugin in the plugins property of your ESLint configuration file.
You might want to use a locally defined plugin in one of the following scenarios:

You want to test the plugin before publishing it to npm.
You want to use a plugin, but do not want to publish it to npm.

Before you can add the plugin to the project, create an ESLint configuration for your project using a flat configuration file, eslint.config.js:


    touch eslint.config.js
1
    
        Copy code to clipboard
        
    

Then, add the following code to eslint.config.js:


    // eslint.config.js
"use strict";

// Import the ESLint plugin locally
const eslintPluginExample = require("./eslint-plugin-example");

module.exports = [
	{
		files: ["**/*.js"],
		languageOptions: {
			sourceType: "commonjs",
			ecmaVersion: "latest",
		},
		// Using the eslint-plugin-example plugin defined locally
		plugins: { example: eslintPluginExample },
		rules: {
			"example/enforce-foo-bar": "error",
		},
	},
];
1234567891011121314151617181920
    
        Copy code to clipboard
        
    

Before you can test the rule, you must create a file to test the rule on.
Create a file example.js:


    touch example.js
1
    
        Copy code to clipboard
        
    

Add the following code to example.js:


    // example.js

function correctFooBar() {
	const foo = "bar";
}

function incorrectFoo() {
	const foo = "baz"; // Problem!
}
123456789
    
        Copy code to clipboard
        
    

Now you’re ready to test the custom rule with the locally defined plugin.
Run ESLint on example.js:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint example.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint example.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint example.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint example.js 
1
    
        Copy code to clipboard
        
    

   

This produces the following output in the terminal:


    /<path-to-directory>/eslint-custom-rule-example/example.js
  8:11  error  Value other than "bar" assigned to `const foo`. Unexpected value: baz  example/enforce-foo-bar

✖ 1 problem (1 error, 0 warnings)
  1 error and 0 warnings potentially fixable with the `--fix` option.
12345
    
        Copy code to clipboard
        
    

Step 9: Publish the Plugin
To publish a plugin containing a rule to npm, you need to configure the package.json. Add the following in the corresponding fields:

"name": A unique name for the package. No other package on npm can have the same name.
"main": The relative path to the plugin file. Following this example, the path is "eslint-plugin-example.js".
"description": A description of the package that’s viewable on npm.
"peerDependencies": Add "eslint": ">=9.0.0" as a peer dependency. Any version greater than or equal to that is necessary to use the plugin. Declaring eslint as a peer dependency requires that users add the package to the project separately from the plugin.
"keywords": Include the standard keywords ["eslint", "eslintplugin", "eslint-plugin"] to make the package easy to find. You can add any other keywords that might be relevant to your plugin as well.

A complete annotated example of what a plugin’s package.json file should look like:


    // package.json
{
  // Name npm package.
  // Add your own package name. eslint-plugin-example is taken!
  "name": "eslint-plugin-example",
  "version": "1.0.0",
  "description": "ESLint plugin for enforce-foo-bar rule.",
  "main": "eslint-plugin-example.js", // plugin entry point
  "scripts": {
    "test": "node enforce-foo-bar.test.js"
  },
  // Add eslint>=9.0.0 as a peer dependency.
  "peerDependencies": {
    "eslint": ">=9.0.0"
  },
  // Add these standard keywords to make plugin easy to find!
  "keywords": [
    "eslint",
    "eslintplugin",
    "eslint-plugin"
  ],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "eslint": "^9.0.0"
  }
}
123456789101112131415161718192021222324252627
    
        Copy code to clipboard
        
    

To publish the package, run npm publish and follow the CLI prompts.
You should see the package live on npm!
Step 10: Use the Published Custom Rule
Next, you can use the published plugin.
Run the following command in your project to download the package:

   
      npm
      yarn
      pnpm
      bun
   
    
        npm


    # Add your package name here
npm install --save-dev eslint-plugin-example
12
    
        Copy code to clipboard
        
    


   
      yarn


    # Add your package name here
yarn add --dev eslint-plugin-example
12
    
        Copy code to clipboard
        
    

   
   
      pnpm


    # Add your package name here
pnpm add --save-dev eslint-plugin-example
12
    
        Copy code to clipboard
        
    

   
   
      bun


    # Add your package name here
bun add --dev eslint-plugin-example
12
    
        Copy code to clipboard
        
    

   

Update the eslint.config.js to use the packaged version of the plugin:


    // eslint.config.js
"use strict";

// Import the plugin downloaded from npm
const eslintPluginExample = require("eslint-plugin-example");

// ... rest of configuration
1234567
    
        Copy code to clipboard
        
    

Now you’re ready to test the custom rule.
Run ESLint on the example.js file you created in step 8, now with the downloaded plugin:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint example.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint example.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint example.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint example.js 
1
    
        Copy code to clipboard
        
    

   

This produces the following output in the terminal:


    /<path-to-directory>/eslint-custom-rule-example/example.js
  8:11  error  Value other than "bar" assigned to `const foo`. Unexpected value: baz  example/enforce-foo-bar

✖ 1 problem (1 error, 0 warnings)
  1 error and 0 warnings potentially fixable with the `--fix` option.
12345
    
        Copy code to clipboard
        
    

As you can see in the above message, you can actually fix the issue with the --fix flag, correcting the variable assignment to be "bar".
Run ESLint again with the --fix flag:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint example.js --fix 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint example.js --fix 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint example.js --fix 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint example.js --fix 
1
    
        Copy code to clipboard
        
    

   

There is no error output in the terminal when you run this, but you can see the fix applied in example.js. You should see the following:


    // example.js

// ... rest of file

function incorrectFoo() {
	const foo = "bar"; // Fixed!
}
1234567
    
        Copy code to clipboard
        
    

Summary
In this tutorial, you’ve made a custom rule that requires all const variables named foo to be assigned the string "bar" and suggests replacing any other value assigned to const foo with "bar". You’ve also added the rule to a plugin, and published the plugin on npm.
Through doing this, you’ve learned the following practices which you can apply to create other custom rules and plugins:

Creating a custom ESLint rule
Testing the custom rule
Bundling the rule in a plugin
Publishing the plugin
Using the rule from the plugin

View the Tutorial Code
You can view the annotated source code for the tutorial here.

            

            
                Edit this page\n\nCustom Rule Tutorial
                

                Table of Contents
    
        
                
                    
                    Why Create a Custom Rule?
            		

                    Prerequisites
            		

                    The Custom Rule
            		

                    Step 1: Set up Your Project
            		

                    Step 2: Stub Out the Rule File
            		

                    Step 3: Add Rule Metadata
            		

                    Step 4: Add Rule Visitor Methods
            		

                    Step 5: Set up Testing
            		

                    Step 6: Write the Test
            		

                    Step 7: Bundle the Custom Rule in a Plugin
            		

                    Step 8: Use the Plugin Locally
            		

                    Step 9: Publish the Plugin
            		

                    Step 10: Use the Published Custom Rule
            		

                    Summary
            		

                    View the Tutorial Code
            		
                
            
    


                This tutorial covers how to create a custom rule for ESLint and distribute it with a plugin.
You can create custom rules to validate if your code meets a certain expectation, and determine what to do if it does not meet that expectation. Plugins package custom rules and other configuration, allowing you to easily share and reuse them in different projects.
To learn more about custom rules and plugins refer to the following documentation:

Custom Rules
Plugins

Why Create a Custom Rule?
Create a custom rule if the ESLint built-in rules and community-published custom rules do not meet your needs. You might create a custom rule to enforce a best practice for your company or project, prevent a particular bug from recurring, or ensure compliance with a style guide.
Before creating a custom rule that isn’t specific to your company or project, it’s worth searching the web to see if someone has published a plugin with a custom rule that solves your use case. It’s quite possible the rule may already exist.
Prerequisites
Before you begin, make sure you have the following installed in your development environment:

Node.js
npm

This tutorial also assumes that you have a basic understanding of ESLint and ESLint rules.
The Custom Rule
The custom rule in this tutorial requires that all const variables named foo are assigned the string literal "bar". The rule is defined in the file enforce-foo-bar.js. The rule also suggests replacing any other value assigned to const foo with "bar".
For example, say you had the following foo.js file:


    // foo.js

const foo = "baz123";
123
    
        Copy code to clipboard
        
    

Running ESLint with the rule would flag "baz123" as an incorrect value for variable foo. If ESLint is running in autofix mode, then ESLint would fix the file to contain the following:


    // foo.js

const foo = "bar";
123
    
        Copy code to clipboard
        
    

Step 1: Set up Your Project
First, create a new project for your custom rule. Create a new directory, initiate a new npm project in it, and create a new file for the custom rule:


    mkdir eslint-custom-rule-example # create directory
cd eslint-custom-rule-example # enter the directory
npm init -y # init new npm project
touch enforce-foo-bar.js # create file enforce-foo-bar.js
1234
    
        Copy code to clipboard
        
    

Step 2: Stub Out the Rule File
In the enforce-foo-bar.js file, add some scaffolding for the enforce-foo-bar custom rule. Also, add a meta object with some basic information about the rule.


    // enforce-foo-bar.js

module.exports = {
	meta: {
		// TODO: add metadata
	},
	create(context) {
		return {
			// TODO: add callback function(s)
		};
	},
};
123456789101112
    
        Copy code to clipboard
        
    

Step 3: Add Rule Metadata
Before writing the rule, add some metadata to the rule object. ESLint uses this information when running the rule.
Start by exporting an object with a meta property containing the rule’s metadata, such as the rule type, documentation, and fixability. In this case, the rule type is “problem,” the description is “Enforce that a variable named foo can only be assigned a value of ‘bar’.”, and the rule is fixable by modifying the code.


    // enforce-foo-bar.js

module.exports = {
	meta: {
		type: "problem",
		docs: {
			description:
				"Enforce that a variable named `foo` can only be assigned a value of 'bar'.",
		},
		fixable: "code",
		schema: [],
	},
	create(context) {
		return {
			// TODO: add callback function(s)
		};
	},
};
123456789101112131415161718
    
        Copy code to clipboard
        
    

To learn more about rule metadata, refer to Rule Structure.
Step 4: Add Rule Visitor Methods
Define the rule’s create function, which accepts a context object and returns an object with a property for each syntax node type you want to handle. In this case, you want to handle VariableDeclarator nodes.
You can choose any ESTree node type or selector.

                    
                    
                        Tip
                        You can view the AST for any JavaScript code using Code Explorer. This is helpful in determining the type of nodes you’d like to target.

                    
                Inside the VariableDeclarator visitor method, check if the node represents a const variable declaration, if its name is foo, and if it’s not assigned to the string "bar". You do this by evaluating the node passed to the VariableDeclaration method.
If the const foo declaration is assigned a value of "bar", then the rule does nothing. If const foo is not assigned a value of "bar", then context.report() reports an error to ESLint. The error report includes information about the error and how to fix it.


    // enforce-foo-bar.js

module.exports = {
    meta: {
        type: "problem",
        docs: {
            description: "Enforce that a variable named `foo` can only be assigned a value of 'bar'."
        },
        fixable: "code",
        schema: []
    },
    create(context) {
        return {

            // Performs action in the function on every variable declarator
            VariableDeclarator(node) {

                // Check if a `const` variable declaration
                if (node.parent.kind === "const") {

                    // Check if variable name is `foo`
                    if (node.id.type === "Identifier" && node.id.name === "foo") {

                        // Check if value of variable is "bar"
                        if (node.init && node.init.type === "Literal" && node.init.value !== "bar") {

                            /*
                             * Report error to ESLint. Error message uses
                             * a message placeholder to include the incorrect value
                             * in the error message.
                             * Also includes a `fix(fixer)` function that replaces
                             * any values assigned to `const foo` with "bar".
                             */
                            context.report({
                                node,
                                message: 'Value other than "bar" assigned to `const foo`. Unexpected value: {{ notBar }}.',
                                data: {
                                    notBar: node.init.value
                                },
                                fix(fixer) {
                                    return fixer.replaceText(node.init, '"bar"');
                                }
                            });
                        }
                    }
                }
            }
        };
    }
};

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051
    
        Copy code to clipboard
        
    

Step 5: Set up Testing
With the rule written, you can test it to make sure it’s working as expected.
ESLint provides the built-in RuleTester class to test rules. You do not need to use third-party testing libraries to test ESLint rules, but RuleTester works seamlessly with tools like Mocha and Jest.
Next, create the file for the tests, enforce-foo-bar.test.js:


    touch enforce-foo-bar.test.js
1
    
        Copy code to clipboard
        
    

You will use the eslint package in the test file. Install it as a development dependency:

   
      npm
      yarn
      pnpm
      bun
   
    
        npm


    npm install --save-dev eslint
1
    
        Copy code to clipboard
        
    


   
      yarn


    yarn add --dev eslint
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm add --save-dev eslint
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bun add --dev eslint
1
    
        Copy code to clipboard
        
    

   

And add a test script to your package.json file to run the tests:


    // package.json
{
    // ...other configuration
    "scripts": {
        "test": "node enforce-foo-bar.test.js"
    },
    // ...other configuration
}
12345678
    
        Copy code to clipboard
        
    

Step 6: Write the Test
To write the test using RuleTester, import the class and your custom rule into the enforce-foo-bar.test.js file.
The RuleTester#run() method tests the rule against valid and invalid test cases. If the rule fails to pass any of the test scenarios, this method throws an error.
RuleTester requires that at least one valid and one invalid test scenario be present.


    // enforce-foo-bar.test.js
const { RuleTester } = require("eslint");
const fooBarRule = require("./enforce-foo-bar");

const ruleTester = new RuleTester({
	// Must use at least ecmaVersion 2015 because
	// that's when `const` variables were introduced.
	languageOptions: { ecmaVersion: 2015 },
});

// Throws error if the tests in ruleTester.run() do not pass
ruleTester.run(
	"enforce-foo-bar", // rule name
	fooBarRule, // rule code
	{
		// checks
		// 'valid' checks cases that should pass
		valid: [
			{
				code: "const foo = 'bar';",
			},
		],
		// 'invalid' checks cases that should not pass
		invalid: [
			{
				code: "const foo = 'baz';",
				output: 'const foo = "bar";',
				errors: 1,
			},
		],
	},
);

console.log("All tests passed!");
12345678910111213141516171819202122232425262728293031323334
    
        Copy code to clipboard
        
    

Run the test with the following command:


    npm test
1
    
        Copy code to clipboard
        
    

If the test passes, you should see the following in your console:


    All tests passed!
1
    
        Copy code to clipboard
        
    

Step 7: Bundle the Custom Rule in a Plugin
Now that you’ve written the custom rule and validated that it works, you can include it in a plugin. Using a plugin, you can share the rule in an npm package to use in other projects.
Create the file for the plugin:


    touch eslint-plugin-example.js
1
    
        Copy code to clipboard
        
    

And now write the plugin code. Plugins are just exported JavaScript objects. To include a rule in a plugin, include it in the plugin’s rules object, which contains key-value pairs of rule names and their source code.
To learn more about creating plugins, refer to Create Plugins.


    // eslint-plugin-example.js

const fooBarRule = require("./enforce-foo-bar");
const plugin = { rules: { "enforce-foo-bar": fooBarRule } };
module.exports = plugin;
12345
    
        Copy code to clipboard
        
    

Step 8: Use the Plugin Locally
You can use a locally defined plugin to execute the custom rule in your project. To use a local plugin, specify the path to the plugin in the plugins property of your ESLint configuration file.
You might want to use a locally defined plugin in one of the following scenarios:

You want to test the plugin before publishing it to npm.
You want to use a plugin, but do not want to publish it to npm.

Before you can add the plugin to the project, create an ESLint configuration for your project using a flat configuration file, eslint.config.js:


    touch eslint.config.js
1
    
        Copy code to clipboard
        
    

Then, add the following code to eslint.config.js:


    // eslint.config.js
"use strict";

// Import the ESLint plugin locally
const eslintPluginExample = require("./eslint-plugin-example");

module.exports = [
	{
		files: ["**/*.js"],
		languageOptions: {
			sourceType: "commonjs",
			ecmaVersion: "latest",
		},
		// Using the eslint-plugin-example plugin defined locally
		plugins: { example: eslintPluginExample },
		rules: {
			"example/enforce-foo-bar": "error",
		},
	},
];
1234567891011121314151617181920
    
        Copy code to clipboard
        
    

Before you can test the rule, you must create a file to test the rule on.
Create a file example.js:


    touch example.js
1
    
        Copy code to clipboard
        
    

Add the following code to example.js:


    // example.js

function correctFooBar() {
	const foo = "bar";
}

function incorrectFoo() {
	const foo = "baz"; // Problem!
}
123456789
    
        Copy code to clipboard
        
    

Now you’re ready to test the custom rule with the locally defined plugin.
Run ESLint on example.js:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint example.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint example.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint example.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint example.js 
1
    
        Copy code to clipboard
        
    

   

This produces the following output in the terminal:


    /<path-to-directory>/eslint-custom-rule-example/example.js
  8:11  error  Value other than "bar" assigned to `const foo`. Unexpected value: baz  example/enforce-foo-bar

✖ 1 problem (1 error, 0 warnings)
  1 error and 0 warnings potentially fixable with the `--fix` option.
12345
    
        Copy code to clipboard
        
    

Step 9: Publish the Plugin
To publish a plugin containing a rule to npm, you need to configure the package.json. Add the following in the corresponding fields:

"name": A unique name for the package. No other package on npm can have the same name.
"main": The relative path to the plugin file. Following this example, the path is "eslint-plugin-example.js".
"description": A description of the package that’s viewable on npm.
"peerDependencies": Add "eslint": ">=9.0.0" as a peer dependency. Any version greater than or equal to that is necessary to use the plugin. Declaring eslint as a peer dependency requires that users add the package to the project separately from the plugin.
"keywords": Include the standard keywords ["eslint", "eslintplugin", "eslint-plugin"] to make the package easy to find. You can add any other keywords that might be relevant to your plugin as well.

A complete annotated example of what a plugin’s package.json file should look like:


    // package.json
{
  // Name npm package.
  // Add your own package name. eslint-plugin-example is taken!
  "name": "eslint-plugin-example",
  "version": "1.0.0",
  "description": "ESLint plugin for enforce-foo-bar rule.",
  "main": "eslint-plugin-example.js", // plugin entry point
  "scripts": {
    "test": "node enforce-foo-bar.test.js"
  },
  // Add eslint>=9.0.0 as a peer dependency.
  "peerDependencies": {
    "eslint": ">=9.0.0"
  },
  // Add these standard keywords to make plugin easy to find!
  "keywords": [
    "eslint",
    "eslintplugin",
    "eslint-plugin"
  ],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "eslint": "^9.0.0"
  }
}
123456789101112131415161718192021222324252627
    
        Copy code to clipboard
        
    

To publish the package, run npm publish and follow the CLI prompts.
You should see the package live on npm!
Step 10: Use the Published Custom Rule
Next, you can use the published plugin.
Run the following command in your project to download the package:

   
      npm
      yarn
      pnpm
      bun
   
    
        npm


    # Add your package name here
npm install --save-dev eslint-plugin-example
12
    
        Copy code to clipboard
        
    


   
      yarn


    # Add your package name here
yarn add --dev eslint-plugin-example
12
    
        Copy code to clipboard
        
    

   
   
      pnpm


    # Add your package name here
pnpm add --save-dev eslint-plugin-example
12
    
        Copy code to clipboard
        
    

   
   
      bun


    # Add your package name here
bun add --dev eslint-plugin-example
12
    
        Copy code to clipboard
        
    

   

Update the eslint.config.js to use the packaged version of the plugin:


    // eslint.config.js
"use strict";

// Import the plugin downloaded from npm
const eslintPluginExample = require("eslint-plugin-example");

// ... rest of configuration
1234567
    
        Copy code to clipboard
        
    

Now you’re ready to test the custom rule.
Run ESLint on the example.js file you created in step 8, now with the downloaded plugin:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint example.js 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint example.js 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint example.js 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint example.js 
1
    
        Copy code to clipboard
        
    

   

This produces the following output in the terminal:


    /<path-to-directory>/eslint-custom-rule-example/example.js
  8:11  error  Value other than "bar" assigned to `const foo`. Unexpected value: baz  example/enforce-foo-bar

✖ 1 problem (1 error, 0 warnings)
  1 error and 0 warnings potentially fixable with the `--fix` option.
12345
    
        Copy code to clipboard
        
    

As you can see in the above message, you can actually fix the issue with the --fix flag, correcting the variable assignment to be "bar".
Run ESLint again with the --fix flag:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint example.js --fix 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint example.js --fix 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint example.js --fix 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint example.js --fix 
1
    
        Copy code to clipboard
        
    

   

There is no error output in the terminal when you run this, but you can see the fix applied in example.js. You should see the following:


    // example.js

// ... rest of file

function incorrectFoo() {
	const foo = "bar"; // Fixed!
}
1234567
    
        Copy code to clipboard
        
    

Summary
In this tutorial, you’ve made a custom rule that requires all const variables named foo to be assigned the string "bar" and suggests replacing any other value assigned to const foo with "bar". You’ve also added the rule to a plugin, and published the plugin on npm.
Through doing this, you’ve learned the following practices which you can apply to create other custom rules and plugins:

Creating a custom ESLint rule
Testing the custom rule
Bundling the rule in a plugin
Publishing the plugin
Using the rule from the plugin

View the Tutorial Code
You can view the annotated source code for the tutorial here.

            

            
                Edit this page\n\n\n\nCustom Rules
                

                Table of Contents
    
        
                
                    
                    Rule Structure
            		

                    The Context Object
            
                
                    
                    Reporting Problems
            
                
                    
                    Using Message Placeholders
            		

                    messageIds
            		

                    Applying Fixes
            		

                    Conflicting Fixes
            		

                    Providing Suggestions
            		

                    Suggestion messageIds
            		

                    Placeholders in Suggestion Messages
            		
                
            		

                    Accessing Options Passed to a Rule
            		

                    Accessing the Source Code
            
                
                    
                    Accessing the Source Text
            		

                    Accessing Comments
            		
                
            		

                    Options Schemas
            		

                    Option Defaults
            		

                    Accessing Shebangs
            		

                    Accessing Variable Scopes
            
                
                    
                    Scope types
            		

                    Scope Variables
            		
                
            		

                    Marking Variables as Used
            		

                    Accessing Code Paths
            		

                    Deprecated SourceCode Methods
            		
                
            		

                    Rule Unit Tests
            		

                    Rule Naming Conventions
            		

                    Runtime Rules
            		

                    Profile Rule Performance
            		
                
            
    


                You can create custom rules to use with ESLint. You might want to create a custom rule if the core rules do not cover your use case.
Here’s the basic format of a custom rule:


    // customRule.js

module.exports = {
	meta: {
		type: "suggestion",
		docs: {
			description: "Description of the rule",
		},
		fixable: "code",
		schema: [], // no options
	},
	create: function (context) {
		return {
			// callback functions
		};
	},
};
1234567891011121314151617
    
        Copy code to clipboard
        
    


                    
                    
                        Warning
                        The core rules shipped in the eslint package are not considered part of the public API and are not designed to be extended from. Building on top of these rules is fragile and will most likely result in your rules breaking completely at some point in the future. If you’re interested in creating a rule that is similar to a core rule, you should first copy the rule file into your project and proceed from there.

                    
                Rule Structure
The source file for a rule exports an object with the following properties. Both custom rules and core rules follow this format.
meta: (object) Contains metadata for the rule:


type: (string) Indicates the type of rule, which is one of "problem", "suggestion", or "layout":

"problem": The rule is identifying code that either will cause an error or may cause a confusing behavior. Developers should consider this a high priority to resolve.
"suggestion": The rule is identifying something that could be done in a better way but no errors will occur if the code isn’t changed.
"layout": The rule cares primarily about whitespace, semicolons, commas, and parentheses, all the parts of the program that determine how the code looks rather than how it executes. These rules work on parts of the code that aren’t specified in the AST.



docs: (object) Properties often used for documentation generation and tooling. Required for core rules and optional for custom rules. Custom rules can include additional properties here as needed.

description: (string) Provides a short description of the rule. For core rules, this is used in rules index.
recommended: (boolean) For core rules, this specifies whether the rule is enabled by the recommended config from @eslint/js.
url: (string) Specifies the URL at which the full documentation can be accessed. Code editors often use this to provide a helpful link on highlighted rule violations.



fixable: (string) Either "code" or "whitespace" if the --fix option on the command line automatically fixes problems reported by the rule.
Important: the fixable property is mandatory for fixable rules. If this property isn’t specified, ESLint will throw an error whenever the rule attempts to produce a fix. Omit the fixable property if the rule is not fixable.


hasSuggestions: (boolean) Specifies whether rules can return suggestions (defaults to false if omitted).
Important: the hasSuggestions property is mandatory for rules that provide suggestions. If this property isn’t set to true, ESLint will throw an error whenever the rule attempts to produce a suggestion. Omit the hasSuggestions property if the rule does not provide suggestions.


schema: (object | array | false) Specifies the options so ESLint can prevent invalid rule configurations. Mandatory when the rule has options.


defaultOptions: (array) Specifies default options for the rule. If present, any user-provided options in their config will be merged on top of them recursively.


deprecated: (boolean | DeprecatedInfo) Indicates whether the rule has been deprecated. You may omit the deprecated property if the rule has not been deprecated.
There is a dedicated page for the DeprecatedInfo


replacedBy: (array, Deprecated Use meta.deprecated.replacedBy instead.) In the case of a deprecated rule, specify replacement rule(s).


create(): Returns an object with methods that ESLint calls to “visit” nodes while traversing the abstract syntax tree (AST as defined by ESTree) of JavaScript code:

If a key is a node type or a selector, ESLint calls that visitor function while going down the tree.
If a key is a node type or a selector plus :exit, ESLint calls that visitor function while going up the tree.
If a key is an event name, ESLint calls that handler function for code path analysis.

A rule can use the current node and its surrounding tree to report or fix problems.
Here are methods for the array-callback-return rule:


    function checkLastSegment (node) {
    // report problem for function if last code path segment is reachable
}

module.exports = {
    meta: { ... },
    create: function(context) {
        // declare the state of the rule
        return {
            ReturnStatement: function(node) {
                // at a ReturnStatement node while going down
            },
            // at a function expression node while going up:
            "FunctionExpression:exit": checkLastSegment,
            "ArrowFunctionExpression:exit": checkLastSegment,
            onCodePathStart: function (codePath, node) {
                // at the start of analyzing a code path
            },
            onCodePathEnd: function(codePath, node) {
                // at the end of analyzing a code path
            }
        };
    }
};
123456789101112131415161718192021222324
    
        Copy code to clipboard
        
    


                    
                    
                        Tip
                        You can view the complete AST for any JavaScript code using Code Explorer.

                    
                The Context Object
The context object is the only argument of the create method in a rule. For example:


    // customRule.js

module.exports = {
    meta: { ... },
    // `context` object is the argument
    create(context) {
       // ...
    }
};
123456789
    
        Copy code to clipboard
        
    

As the name implies, the context object contains information that is relevant to the context of the rule.
The context object has the following properties:

id: (string) The rule ID.
filename: (string) The filename associated with the source.
physicalFilename: (string) When linting a file, it provides the full path of the file on disk without any code block information. When linting text, it provides the value passed to —stdin-filename or <text> if not specified.
cwd: (string) The cwd option passed to the Linter. It is a path to a directory that should be considered the current working directory.
options: (array) An array of the configured options for this rule. This array does not include the rule severity (see the dedicated section).
sourceCode: (object) A SourceCode object that you can use to work with the source that was passed to ESLint (see Accessing the Source Code).
settings: (object) The shared settings from the configuration.
languageOptions: (object) more details for each property here

sourceType: ('script' | 'module' | 'commonjs') The mode for the current file.
ecmaVersion: (number) The ECMA version used to parse the current file.
parser: (object): The parser used to parse the current file.
parserOptions: (object) The parser options configured for this file.
globals: (object) The specified globals.


parserPath: (string, Removed Use context.languageOptions.parser instead.) The name of the parser from the configuration.
parserOptions: (Deprecated Use context.languageOptions.parserOptions instead.) The parser options configured for this run (more details here).

Additionally, the context object has the following methods:

getCwd(): (Deprecated: Use context.cwd instead.) Returns the cwd option passed to the Linter. It is a path to a directory that should be considered the current working directory.
getFilename(): (Deprecated: Use context.filename instead.) Returns the filename associated with the source.
getPhysicalFilename(): (Deprecated: Use context.physicalFilename instead.) When linting a file, it returns the full path of the file on disk without any code block information. When linting text, it returns the value passed to —stdin-filename or <text> if not specified.
getSourceCode(): (Deprecated: Use context.sourceCode instead.) Returns a SourceCode object that you can use to work with the source that was passed to ESLint (see Accessing the Source Code).
report(descriptor). Reports a problem in the code (see the dedicated section).

Note: Earlier versions of ESLint supported additional methods on the context object. Those methods were removed in the new format and should not be relied upon.
Reporting Problems
The main method you’ll use when writing custom rules is context.report(), which publishes a warning or error (depending on the configuration being used). This method accepts a single argument, which is an object containing the following properties:

messageId: (string) The ID of the message (see messageIds) (recommended over message).
message: (string) The problem message (alternative to messageId).
node: (optional object) The AST node related to the problem. If present and loc is not specified, then the starting location of the node is used as the location of the problem.
loc: (optional object) Specifies the location of the problem. If both loc and node are specified, then the location is used from loc instead of node.

start: An object of the start location.

line: (number) The 1-based line number at which the problem occurred.
column: (number) The 0-based column number at which the problem occurred.


end: An object of the end location.

line: (number) The 1-based line number at which the problem occurred.
column: (number) The 0-based column number at which the problem occurred.




data: (optional object) Placeholder data for message.
fix(fixer): (optional function) Applies a fix to resolve the problem.

Note that at least one of node or loc is required.
The simplest example is to use just node and message:


    context.report({
	node: node,
	message: "Unexpected identifier",
});
1234
    
        Copy code to clipboard
        
    

The node contains all the information necessary to figure out the line and column number of the offending text as well as the source text representing the node.
Using Message Placeholders
You can also use placeholders in the message and provide data:


    
context.report({
    node: node,
    message: "Unexpected identifier: {{ identifier }}",
    data: {
        identifier: node.name
    }
});

123456789
    
        Copy code to clipboard
        
    

Note that leading and trailing whitespace is optional in message parameters.
The node contains all the information necessary to figure out the line and column number of the offending text as well as the source text representing the node.
messageIds
messageIds are the recommended approach to reporting messages in context.report() calls because of the following benefits:

Rule violation messages can be stored in a central meta.messages object for convenient management.
Rule violation messages do not need to be repeated in both the rule file and rule test file.
As a result, the barrier for changing rule violation messages is lower, encouraging more frequent contributions to improve and optimize them for the greatest clarity and usefulness.

Rule file:


    
// avoid-name.js

module.exports = {
    meta: {
        messages: {
            avoidName: "Avoid using variables named '{{ name }}'"
        }
    },
    create(context) {
        return {
            Identifier(node) {
                if (node.name === "foo") {
                    context.report({
                        node,
                        messageId: "avoidName",
                        data: {
                            name: "foo",
                        }
                    });
                }
            }
        };
    }
};

1234567891011121314151617181920212223242526
    
        Copy code to clipboard
        
    

In the file to lint:


    // someFile.js

var foo = 2;
//  ^ error: Avoid using variables named 'foo'
1234
    
        Copy code to clipboard
        
    

In your tests:


    // avoid-name.test.js

var rule = require("../../../lib/rules/avoid-name");
var RuleTester = require("eslint").RuleTester;

var ruleTester = new RuleTester();
ruleTester.run("avoid-name", rule, {
	valid: ["bar", "baz"],
	invalid: [
		{
			code: "foo",
			errors: [
				{
					messageId: "avoidName",
				},
			],
		},
	],
});
12345678910111213141516171819
    
        Copy code to clipboard
        
    

Applying Fixes
If you’d like ESLint to attempt to fix the problem you’re reporting, you can do so by specifying the fix function when using context.report(). The fix function receives a single argument, a fixer object, that you can use to apply a fix. For example:


    context.report({
	node: node,
	message: "Missing semicolon",
	fix(fixer) {
		return fixer.insertTextAfter(node, ";");
	},
});
1234567
    
        Copy code to clipboard
        
    

Here, the fix() function is used to insert a semicolon after the node. Note that a fix is not immediately applied, and may not be applied at all if there are conflicts with other fixes. After applying fixes, ESLint will run all the enabled rules again on the fixed code, potentially applying more fixes. This process will repeat up to 10 times, or until no more fixable problems are found. Afterward, any remaining problems will be reported as usual.
Important: The meta.fixable property is mandatory for fixable rules. ESLint will throw an error if a rule that implements fix functions does not export the meta.fixable property.
The fixer object has the following methods:

insertTextAfter(nodeOrToken, text): Insert text after the given node or token.
insertTextAfterRange(range, text): Insert text after the given range.
insertTextBefore(nodeOrToken, text): Insert text before the given node or token.
insertTextBeforeRange(range, text): Insert text before the given range.
remove(nodeOrToken): Remove the given node or token.
removeRange(range): Remove text in the given range.
replaceText(nodeOrToken, text): Replace the text in the given node or token.
replaceTextRange(range, text): Replace the text in the given range.

A range is a two-item array containing character indices inside the source code. The first item is the start of the range (inclusive) and the second item is the end of the range (exclusive). Every node and token has a range property to identify the source code range they represent.
The above methods return a fixing object.
The fix() function can return the following values:

A fixing object.
An array which includes fixing objects.
An iterable object which enumerates fixing objects. Especially, the fix() function can be a generator.

If you make a fix() function which returns multiple fixing objects, those fixing objects must not overlap.
Best practices for fixes:


Avoid any fixes that could change the runtime behavior of code and cause it to stop working.


Make fixes as small as possible. Fixes that are unnecessarily large could conflict with other fixes, and prevent them from being applied.


Only make one fix per message. This is enforced because you must return the result of the fixer operation from fix().


Since all rules are run again after the initial round of fixes is applied, it’s not necessary for a rule to check whether the code style of a fix will cause errors to be reported by another rule.


For example, suppose a fixer would like to surround an object key with quotes, but it’s not sure whether the user would prefer single or double quotes.


    { foo: 1 }

// should get fixed to either
{ 'foo': 1 }

// or
{ "foo": 1 }
1234567
    
        Copy code to clipboard
        
    



This fixer can just select a quote type arbitrarily. If it guesses wrong, the resulting code will be automatically reported and fixed by the quotes rule.




Note: Making fixes as small as possible is a best practice, but in some cases it may be correct to extend the range of the fix in order to intentionally prevent other rules from making fixes in a surrounding range in the same pass. For instance, if replacement text declares a new variable, it can be useful to prevent other changes in the scope of the variable as they might cause name collisions.
The following example replaces node and also ensures that no other fixes will be applied in the range of node.parent in the same pass:


    context.report({
	node,
	message,
	*fix(fixer) {
		yield fixer.replaceText(node, replacementText);

		// extend range of the fix to the range of `node.parent`
		yield fixer.insertTextBefore(node.parent, "");
		yield fixer.insertTextAfter(node.parent, "");
	},
});
1234567891011
    
        Copy code to clipboard
        
    

Conflicting Fixes
Conflicting fixes are fixes that apply different changes to the same part of the source code.
There is no way to specify which of the conflicting fixes is applied.
For example, if two fixes want to modify characters 0 through 5, only one is applied.
Providing Suggestions
In some cases fixes aren’t appropriate to be automatically applied, for example, if a fix potentially changes functionality or if there are multiple valid ways to fix a rule depending on the implementation intent (see the best practices for applying fixes listed above). In these cases, there is an alternative suggest option on context.report() that allows other tools, such as editors, to expose helpers for users to manually apply a suggestion.
To provide suggestions, use the suggest key in the report argument with an array of suggestion objects. The suggestion objects represent individual suggestions that could be applied and require either a desc key string that describes what applying the suggestion would do or a messageId key (see below), and a fix key that is a function defining the suggestion result. This fix function follows the same API as regular fixes (described above in applying fixes).


    
context.report({
    node: node,
    message: "Unnecessary escape character: \\{{character}}.",
    data: { character },
    suggest: [
        {
            desc: "Remove the `\\`. This maintains the current functionality.",
            fix: function(fixer) {
                return fixer.removeRange(range);
            }
        },
        {
            desc: "Replace the `\\` with `\\\\` to include the actual backslash character.",
            fix: function(fixer) {
                return fixer.insertTextBeforeRange(range, "\\");
            }
        }
    ]
});

123456789101112131415161718192021
    
        Copy code to clipboard
        
    

Important: The meta.hasSuggestions property is mandatory for rules that provide suggestions. ESLint will throw an error if a rule attempts to produce a suggestion but does not export this property.
Note: Suggestions are applied as stand-alone changes, without triggering multipass fixes. Each suggestion should focus on a singular change in the code and should not try to conform to user-defined styles. For example, if a suggestion is adding a new statement into the codebase, it should not try to match correct indentation or conform to user preferences on the presence/absence of semicolons. All of those things can be corrected by multipass autofix when the user triggers it.
Best practices for suggestions:

Don’t try to do too much and suggest large refactors that could introduce a lot of breaking changes.
As noted above, don’t try to conform to user-defined styles.

Suggestions are intended to provide fixes. ESLint will automatically remove the whole suggestion from the linting output if the suggestion’s fix function returned null or an empty array/sequence.
Suggestion messageIds
Instead of using a desc key for suggestions a messageId can be used instead. This works the same way as messageIds for the overall error (see messageIds). Here is an example of how to use a suggestion messageId in a rule:


    
module.exports = {
    meta: {
        messages: {
            unnecessaryEscape: "Unnecessary escape character: \\{{character}}.",
            removeEscape: "Remove the `\\`. This maintains the current functionality.",
            escapeBackslash: "Replace the `\\` with `\\\\` to include the actual backslash character."
        },
        hasSuggestions: true
    },
    create: function(context) {
        // ...
        context.report({
            node: node,
            messageId: 'unnecessaryEscape',
            data: { character },
            suggest: [
                {
                    messageId: "removeEscape", // suggestion messageId
                    fix: function(fixer) {
                        return fixer.removeRange(range);
                    }
                },
                {
                    messageId: "escapeBackslash", // suggestion messageId
                    fix: function(fixer) {
                        return fixer.insertTextBeforeRange(range, "\\");
                    }
                }
            ]
        });
    }
};

12345678910111213141516171819202122232425262728293031323334
    
        Copy code to clipboard
        
    

Placeholders in Suggestion Messages
You can also use placeholders in the suggestion message. This works the same way as placeholders for the overall error (see using message placeholders).
Please note that you have to provide data on the suggestion’s object. Suggestion messages cannot use properties from the overall error’s data.


    
module.exports = {
    meta: {
        messages: {
            unnecessaryEscape: "Unnecessary escape character: \\{{character}}.",
            removeEscape: "Remove `\\` before {{character}}.",
        },
        hasSuggestions: true
    },
    create: function(context) {
        // ...
        context.report({
            node: node,
            messageId: "unnecessaryEscape",
            data: { character }, // data for the unnecessaryEscape overall message
            suggest: [
                {
                    messageId: "removeEscape",
                    data: { character }, // data for the removeEscape suggestion message
                    fix: function(fixer) {
                        return fixer.removeRange(range);
                    }
                }
            ]
        });
    }
};

12345678910111213141516171819202122232425262728
    
        Copy code to clipboard
        
    

Accessing Options Passed to a Rule
Some rules require options in order to function correctly. These options appear in configuration (.eslintrc, command line interface, or comments). For example:


    {
	"quotes": ["error", "double"]
}
123
    
        Copy code to clipboard
        
    

The quotes rule in this example has one option, "double" (the error is the error level). You can retrieve the options for a rule by using context.options, which is an array containing every configured option for the rule. In this case, context.options[0] would contain "double":


    module.exports = {
	meta: {
		schema: [
			{
				enum: ["single", "double", "backtick"],
			},
		],
	},
	create: function (context) {
		var isDouble = context.options[0] === "double";

		// ...
	},
};
1234567891011121314
    
        Copy code to clipboard
        
    

Since context.options is just an array, you can use it to determine how many options have been passed as well as retrieving the actual options themselves. Keep in mind that the error level is not part of context.options, as the error level cannot be known or modified from inside a rule.
When using options, make sure that your rule has some logical defaults in case the options are not provided.
Rules with options must specify a schema.
Accessing the Source Code
The SourceCode object is the main object for getting more information about the source code being linted. You can retrieve the SourceCode object at any time by using the context.sourceCode property:


    module.exports = {
	create: function (context) {
		var sourceCode = context.sourceCode;

		// ...
	},
};
1234567
    
        Copy code to clipboard
        
    

Deprecated: The context.getSourceCode() method is deprecated; make sure to use context.sourceCode property instead.
Once you have an instance of SourceCode, you can use the following methods on it to work with the code:

getText(node): Returns the source code for the given node. Omit node to get the whole source (see the dedicated section).
getAllComments(): Returns an array of all comments in the source (see the dedicated section).
getCommentsBefore(nodeOrToken): Returns an array of comment tokens that occur directly before the given node or token (see the dedicated section).
getCommentsAfter(nodeOrToken): Returns an array of comment tokens that occur directly after the given node or token (see the dedicated section).
getCommentsInside(node): Returns an array of all comment tokens inside a given node (see the dedicated section).
isSpaceBetween(nodeOrToken, nodeOrToken): Returns true if there is a whitespace character between the two tokens or, if given a node, the last token of the first node and the first token of the second node.
getFirstToken(node, skipOptions): Returns the first token representing the given node.
getFirstTokens(node, countOptions): Returns the first count tokens representing the given node.
getLastToken(node, skipOptions): Returns the last token representing the given node.
getLastTokens(node, countOptions): Returns the last count tokens representing the given node.
getTokenAfter(nodeOrToken, skipOptions): Returns the first token after the given node or token.
getTokensAfter(nodeOrToken, countOptions): Returns count tokens after the given node or token.
getTokenBefore(nodeOrToken, skipOptions): Returns the first token before the given node or token.
getTokensBefore(nodeOrToken, countOptions): Returns count tokens before the given node or token.
getFirstTokenBetween(nodeOrToken1, nodeOrToken2, skipOptions): Returns the first token between two nodes or tokens.
getFirstTokensBetween(nodeOrToken1, nodeOrToken2, countOptions): Returns the first count tokens between two nodes or tokens.
getLastTokenBetween(nodeOrToken1, nodeOrToken2, skipOptions): Returns the last token between two nodes or tokens.
getLastTokensBetween(nodeOrToken1, nodeOrToken2, countOptions): Returns the last count tokens between two nodes or tokens.
getTokens(node): Returns all tokens for the given node.
getTokensBetween(nodeOrToken1, nodeOrToken2): Returns all tokens between two nodes.
getTokenByRangeStart(index, rangeOptions): Returns the token whose range starts at the given index in the source.
getNodeByRangeIndex(index): Returns the deepest node in the AST containing the given source index.
getLocFromIndex(index): Returns an object with line and column properties, corresponding to the location of the given source index. line is 1-based and column is 0-based.
getIndexFromLoc(loc): Returns the index of a given location in the source code, where loc is an object with a 1-based line key and a 0-based column key.
commentsExistBetween(nodeOrToken1, nodeOrToken2): Returns true if comments exist between two nodes.
getAncestors(node): Returns an array of the ancestors of the given node, starting at the root of the AST and continuing through the direct parent of the given node. This array does not include the given node itself.
getDeclaredVariables(node): Returns a list of variables declared by the given node. This information can be used to track references to variables.

If the node is a VariableDeclaration, all variables declared in the declaration are returned.
If the node is a VariableDeclarator, all variables declared in the declarator are returned.
If the node is a FunctionDeclaration or FunctionExpression, the variable for the function name is returned, in addition to variables for the function parameters.
If the node is an ArrowFunctionExpression, variables for the parameters are returned.
If the node is a ClassDeclaration or a ClassExpression, the variable for the class name is returned.
If the node is a CatchClause, the variable for the exception is returned.
If the node is an ImportDeclaration, variables for all of its specifiers are returned.
If the node is an ImportSpecifier, ImportDefaultSpecifier, or ImportNamespaceSpecifier, the declared variable is returned.
Otherwise, if the node does not declare any variables, an empty array is returned.


getScope(node): Returns the scope of the given node. This information can be used to track references to variables.
markVariableAsUsed(name, refNode): Marks a variable with the given name in a scope indicated by the given reference node as used. This affects the no-unused-vars rule. Returns true if a variable with the given name was found and marked as used, otherwise false.

skipOptions is an object which has 3 properties; skip, includeComments, and filter. Default is {skip: 0, includeComments: false, filter: null}.

skip: (number) Positive integer, the number of skipping tokens. If filter option is given at the same time, it doesn’t count filtered tokens as skipped.
includeComments: (boolean) The flag to include comment tokens into the result.
filter(token): Function which gets a token as the first argument. If the function returns false then the result excludes the token.

countOptions is an object which has 3 properties; count, includeComments, and filter. Default is {count: 0, includeComments: false, filter: null}.

count: (number) Positive integer, the maximum number of returning tokens.
includeComments: (boolean) The flag to include comment tokens into the result.
filter(token): Function which gets a token as the first argument, if the function returns false then the result excludes the token.

rangeOptions is an object that has 1 property, includeComments. Default is {includeComments: false}.

includeComments: (boolean) The flag to include comment tokens into the result.

There are also some properties you can access:

hasBOM: (boolean) The flag to indicate whether the source code has Unicode BOM.
text: (string) The full text of the code being linted. Unicode BOM has been stripped from this text.
ast: (object) Program node of the AST for the code being linted.
scopeManager: ScopeManager object of the code.
visitorKeys: (object) Visitor keys to traverse this AST.
parserServices: (object) Contains parser-provided services for rules. The default parser does not provide any services. However, if a rule is intended to be used with a custom parser, it could use parserServices to access anything provided by that parser. (For example, a TypeScript parser could provide the ability to get the computed type of a given node.)
lines: (array) Array of lines, split according to the specification’s definition of line breaks.

You should use a SourceCode object whenever you need to get more information about the code being linted.
Accessing the Source Text
If your rule needs to get the actual JavaScript source to work with, then use the sourceCode.getText() method. This method works as follows:


    // get all source
var source = sourceCode.getText();

// get source for just this AST node
var nodeSource = sourceCode.getText(node);

// get source for AST node plus previous two characters
var nodeSourceWithPrev = sourceCode.getText(node, 2);

// get source for AST node plus following two characters
var nodeSourceWithFollowing = sourceCode.getText(node, 0, 2);
1234567891011
    
        Copy code to clipboard
        
    

In this way, you can look for patterns in the JavaScript text itself when the AST isn’t providing the appropriate data (such as the location of commas, semicolons, parentheses, etc.).
Accessing Comments
While comments are not technically part of the AST, ESLint provides the sourceCode.getAllComments(), sourceCode.getCommentsBefore(), sourceCode.getCommentsAfter(), and sourceCode.getCommentsInside() to access them.
sourceCode.getCommentsBefore(), sourceCode.getCommentsAfter(), and sourceCode.getCommentsInside() are useful for rules that need to check comments in relation to a given node or token.
Keep in mind that the results of these methods are calculated on demand.
You can also access comments through many of sourceCode’s methods using the includeComments option.
Options Schemas
Rules with options must specify a meta.schema property, which is a JSON Schema format description of a rule’s options which will be used by ESLint to validate configuration options and prevent invalid or unexpected inputs before they are passed to the rule in context.options.
If your rule has options, it is strongly recommended that you specify a schema for options validation. However, it is possible to opt-out of options validation by setting schema: false, but doing so is discouraged as it increases the chance of bugs and mistakes.
For rules that don’t specify a meta.schema property, ESLint throws errors when any options are passed. If your rule doesn’t have options, do not set schema: false, but simply omit the schema property or use schema: [], both of which prevent any options from being passed.
When validating a rule’s config, there are five steps:

If the rule config is not an array, then the value is wrapped into an array (e.g. "off" becomes ["off"]); if the rule config is an array then it is used directly.
ESLint validates the first element of the rule config array as a severity ("off", "warn", "error", 0, 1, 2)
If the severity is off or 0, then the rule is disabled and validation stops, ignoring any other elements of the rule config array.
If the rule is enabled, then any elements of the array after the severity are copied into the context.options array (e.g. a config of ["warn", "never", { someOption: 5 }] results in context.options = ["never", { someOption: 5 }])
The rule’s schema validation is run on the context.options array.

Note: this means that the rule schema cannot validate the severity. The rule schema only validates the array elements after the severity in a rule config. There is no way for a rule to know what severity it is configured at.
There are two formats for a rule’s schema:

An array of JSON Schema objects

Each element will be checked against the same position in the context.options array.
If the context.options array has fewer elements than there are schemas, then the unmatched schemas are ignored.
If the context.options array has more elements than there are schemas, then the validation fails.
There are two important consequences to using this format:

It is always valid for a user to provide no options to your rule (beyond severity).
If you specify an empty array, then it is always an error for a user to provide any options to your rule (beyond severity).




A full JSON Schema object that will validate the context.options array

The schema should assume an array of options to validate even if your rule only accepts one option.
The schema can be arbitrarily complex, so you can validate completely different sets of potential options via oneOf, anyOf etc.
The supported version of JSON Schemas is Draft-04, so some newer features such as if or $data are unavailable.

At present, it is explicitly planned to not update schema support beyond this level due to ecosystem compatibility concerns. See this comment for further context.





For example, the yoda rule accepts a primary mode argument of "always" or "never", as well as an extra options object with an optional property exceptRange:


    // Valid configuration:
// "yoda": "warn"
// "yoda": ["error"]
// "yoda": ["error", "always"]
// "yoda": ["error", "never", { "exceptRange": true }]
// Invalid configuration:
// "yoda": ["warn", "never", { "exceptRange": true }, 5]
// "yoda": ["error", { "exceptRange": true }, "never"]
module.exports = {
	meta: {
		schema: [
			{
				enum: ["always", "never"],
			},
			{
				type: "object",
				properties: {
					exceptRange: { type: "boolean" },
				},
				additionalProperties: false,
			},
		],
	},
};
123456789101112131415161718192021222324
    
        Copy code to clipboard
        
    

And here is the equivalent object-based schema:


    // Valid configuration:
// "yoda": "warn"
// "yoda": ["error"]
// "yoda": ["error", "always"]
// "yoda": ["error", "never", { "exceptRange": true }]
// Invalid configuration:
// "yoda": ["warn", "never", { "exceptRange": true }, 5]
// "yoda": ["error", { "exceptRange": true }, "never"]
module.exports = {
	meta: {
		schema: {
			type: "array",
			minItems: 0,
			maxItems: 2,
			items: [
				{
					enum: ["always", "never"],
				},
				{
					type: "object",
					properties: {
						exceptRange: { type: "boolean" },
					},
					additionalProperties: false,
				},
			],
		},
	},
};
1234567891011121314151617181920212223242526272829
    
        Copy code to clipboard
        
    

Object schemas can be more precise and restrictive in what is permitted. For example, the below schema always requires the first option to be specified (a number between 0 and 10), but the second option is optional, and can either be an object with some options explicitly set, or "off" or "strict".


    // Valid configuration:
// "someRule": ["error", 6]
// "someRule": ["error", 5, "strict"]
// "someRule": ["warn", 10, { someNonOptionalProperty: true }]
// Invalid configuration:
// "someRule": "warn"
// "someRule": ["error"]
// "someRule": ["warn", 15]
// "someRule": ["warn", 7, { }]
// "someRule": ["error", 3, "on"]
// "someRule": ["warn", 7, { someOtherProperty: 5 }]
// "someRule": ["warn", 7, { someNonOptionalProperty: false, someOtherProperty: 5 }]
module.exports = {
	meta: {
		schema: {
			type: "array",
			minItems: 1, // Can't specify only severity!
			maxItems: 2,
			items: [
				{
					type: "number",
					minimum: 0,
					maximum: 10,
				},
				{
					anyOf: [
						{
							type: "object",
							properties: {
								someNonOptionalProperty: { type: "boolean" },
							},
							required: ["someNonOptionalProperty"],
							additionalProperties: false,
						},
						{
							enum: ["off", "strict"],
						},
					],
				},
			],
		},
	},
};
12345678910111213141516171819202122232425262728293031323334353637383940414243
    
        Copy code to clipboard
        
    

Remember, rule options are always an array, so be careful not to specify a schema for a non-array type at the top level. If your schema does not specify an array at the top-level, users can never enable your rule, as their configuration will always be invalid when the rule is enabled.
Here’s an example schema that will always fail validation:


    // Possibly trying to validate ["error", { someOptionalProperty: true }]
// but when the rule is enabled, config will always fail validation because the options are an array which doesn't match "object"
module.exports = {
	meta: {
		schema: {
			type: "object",
			properties: {
				someOptionalProperty: {
					type: "boolean",
				},
			},
			additionalProperties: false,
		},
	},
};
123456789101112131415
    
        Copy code to clipboard
        
    

Note: If your rule schema uses JSON schema $ref properties, you must use the full JSON Schema object rather than the array of positional property schemas. This is because ESLint transforms the array shorthand into a single schema without updating references that makes them incorrect (they are ignored).
To learn more about JSON Schema, we recommend looking at some examples on the JSON Schema website, or reading the free Understanding JSON Schema ebook.
Option Defaults
Rules may specify a meta.defaultOptions array of default values for any options.
When the rule is enabled in a user configuration, ESLint will recursively merge any user-provided option elements on top of the default elements.
For example, given the following defaults:


    export default {
	meta: {
		defaultOptions: [
			{
				alias: "basic",
			},
		],
		schema: [
			{
				type: "object",
				properties: {
					alias: {
						type: "string",
					},
				},
				additionalProperties: false,
			},
		],
	},
	create(context) {
		const [{ alias }] = context.options;

		return {
			/* ... */
		};
	},
};
123456789101112131415161718192021222324252627
    
        Copy code to clipboard
        
    

The rule would have a runtime alias value of "basic" unless the user configuration specifies a different value, such as with ["error", { alias: "complex" }].
Each element of the options array is merged according to the following rules:

Any missing value or explicit user-provided undefined will fall back to a default option
User-provided arrays and primitive values other than undefined override a default option
User-provided objects will merge into a default option object and replace a non-object default otherwise

Option defaults will also be validated against the rule’s meta.schema.
Note: ESLint internally uses Ajv for schema validation with its useDefaults option enabled.
Both user-provided and meta.defaultOptions options will override any defaults specified in a rule’s schema.
ESLint may disable Ajv’s useDefaults in a future major version.
Accessing Shebangs
Shebangs (#!) are represented by the unique tokens of type "Shebang". They are treated as comments and can be accessed by the methods outlined in the Accessing Comments section, such as sourceCode.getAllComments().
Accessing Variable Scopes
The SourceCode#getScope(node) method returns the scope of the given node. It is a useful method for finding information about the variables in a given scope and how they are used in other scopes.

                    
                    
                        Tip
                        You can view scope information for any JavaScript code using Code Explorer.

                    
                Scope types
The following table contains a list of AST node types and the scope type that they correspond to. For more information about the scope types, refer to the Scope object documentation.



AST Node Type
Scope Type




Program
global


FunctionDeclaration
function


FunctionExpression
function


ArrowFunctionExpression
function


ClassDeclaration
class


ClassExpression
class


BlockStatement ※1
block


SwitchStatement ※1
switch


ForStatement ※2
for


ForInStatement ※2
for


ForOfStatement ※2
for


WithStatement
with


CatchClause
catch


others
※3



※1 Only if the configured parser provided the block-scope feature. The default parser provides the block-scope feature if parserOptions.ecmaVersion is not less than 6.
※2 Only if the for statement defines the iteration variable as a block-scoped variable (E.g., for (let i = 0;;) {}).
※3 The scope of the closest ancestor node which has own scope. If the closest ancestor node has multiple scopes then it chooses the innermost scope (E.g., the Program node has a global scope and a module scope if Program#sourceType is "module". The innermost scope is the module scope.).
Scope Variables
The Scope#variables property contains an array of Variable objects. These are the variables declared in current scope. You can use these Variable objects to track references to a variable throughout the entire module.
Inside of each Variable, the Variable#references property contains an array of Reference objects. The Reference array contains all the locations where the variable is referenced in the module’s source code.
Also inside of each Variable, the Variable#defs property contains an array of Definition objects. You can use the Definitions to find where the variable was defined.
Global variables have the following additional properties:

Variable#writeable (boolean | undefined) … If true, this global variable can be assigned arbitrary value. If false, this global variable is read-only.
Variable#eslintExplicitGlobal (boolean | undefined) … If true, this global variable was defined by a /* globals */ directive comment in the source code file.
Variable#eslintExplicitGlobalComments (Comment[] | undefined) … The array of /* globals */ directive comments which defined this global variable in the source code file. This property is undefined if there are no /* globals */ directive comments.
Variable#eslintImplicitGlobalSetting ("readonly" | "writable" | undefined) … The configured value in config files. This can be different from variable.writeable if there are /* globals */ directive comments.

For examples of using SourceCode#getScope() to track variables, refer to the source code for the following built-in rules:

no-shadow: Calls sourceCode.getScope() at the Program node and inspects all child scopes to make sure a variable name is not reused at a lower scope. (no-shadow documentation)
no-redeclare: Calls sourceCode.getScope() at each scope to make sure that a variable is not declared twice in the same scope. (no-redeclare documentation)

Marking Variables as Used
Certain ESLint rules, such as no-unused-vars, check to see if a variable has been used. ESLint itself only knows about the standard rules of variable access and so custom ways of accessing variables may not register as “used”.
To help with this, you can use the sourceCode.markVariableAsUsed() method. This method takes two arguments: the name of the variable to mark as used and an option reference node indicating the scope in which you are working. Here’s an example:


    module.exports = {
	create: function (context) {
		var sourceCode = context.sourceCode;

		return {
			ReturnStatement(node) {
				// look in the scope of the function for myCustomVar and mark as used
				sourceCode.markVariableAsUsed("myCustomVar", node);

				// or: look in the global scope for myCustomVar and mark as used
				sourceCode.markVariableAsUsed("myCustomVar");
			},
		};
		// ...
	},
};
12345678910111213141516
    
        Copy code to clipboard
        
    

Here, the myCustomVar variable is marked as used relative to a ReturnStatement node, which means ESLint will start searching from the scope closest to that node. If you omit the second argument, then the top-level scope is used. (For ESM files, the top-level scope is the module scope; for CommonJS files, the top-level scope is the first function scope.)
Accessing Code Paths
ESLint analyzes code paths while traversing AST. You can access code path objects with seven events related to code paths. For more information, refer to Code Path Analysis.
Deprecated SourceCode Methods
Please note that the following SourceCode methods have been deprecated and will be removed in a future version of ESLint:

getTokenOrCommentBefore(): Replaced by SourceCode#getTokenBefore() with the { includeComments: true } option.
getTokenOrCommentAfter(): Replaced by SourceCode#getTokenAfter() with the { includeComments: true } option.
isSpaceBetweenTokens(): Replaced by SourceCode#isSpaceBetween()
getJSDocComment()

Rule Unit Tests
ESLint provides the RuleTester utility to make it easy to write tests for rules.
Rule Naming Conventions
While you can give a custom rule any name you’d like, the core rules have naming conventions. It could be clearer to apply these same naming conventions to your custom rule. To learn more, refer to the Core Rule Naming Conventions documentation.
Runtime Rules
The thing that makes ESLint different from other linters is the ability to define custom rules at runtime. This is perfect for rules that are specific to your project or company and wouldn’t make sense for ESLint to ship with or be included in a plugin. Just write your rules and include them at runtime.
Runtime rules are written in the same format as all other rules. Create your rule as you would any other and then follow these steps:

Place all of your runtime rules in the same directory (e.g., eslint_rules).
Create a configuration file and specify your rule ID error level under the rules key. Your rule will not run unless it has a value of "warn" or "error" in the configuration file.
Run the command line interface using the --rulesdir option to specify the location of your runtime rules.

Profile Rule Performance
ESLint has a built-in method to track the performance of individual rules. Setting the TIMING environment variable will trigger the display, upon linting completion, of the ten longest-running rules, along with their individual running time (rule creation + rule execution) and relative performance impact as a percentage of total rule processing time (rule creation + rule execution).


    $ TIMING=1 eslint lib
Rule                    | Time (ms) | Relative
:-----------------------|----------:|--------:
no-multi-spaces         |    52.472 |     6.1%
camelcase               |    48.684 |     5.7%
no-irregular-whitespace |    43.847 |     5.1%
valid-jsdoc             |    40.346 |     4.7%
handle-callback-err     |    39.153 |     4.6%
space-infix-ops         |    35.444 |     4.1%
no-undefined            |    25.693 |     3.0%
no-shadow               |    22.759 |     2.7%
no-empty-class          |    21.976 |     2.6%
semi                    |    19.359 |     2.3%
12345678910111213
    
        Copy code to clipboard
        
    

To test one rule explicitly, combine the --no-eslintrc, and --rule options:


    $ TIMING=1 eslint --no-eslintrc --rule "quotes: [2, 'double']" lib
Rule   | Time (ms) | Relative
:------|----------:|--------:
quotes |    18.066 |   100.0%
1234
    
        Copy code to clipboard
        
    

To see a longer list of results (more than 10), set the environment variable to another value such as TIMING=50 or TIMING=all.
For more granular timing information (per file per rule), use the stats option instead.

            

            
                Edit this page\n\nCustom Rules
                

                Table of Contents
    
        
                
                    
                    Rule Structure
            		

                    The Context Object
            
                
                    
                    Reporting Problems
            
                
                    
                    Using Message Placeholders
            		

                    messageIds
            		

                    Applying Fixes
            		

                    Conflicting Fixes
            		

                    Providing Suggestions
            		

                    Suggestion messageIds
            		

                    Placeholders in Suggestion Messages
            		
                
            		

                    Accessing Options Passed to a Rule
            		

                    Accessing the Source Code
            
                
                    
                    Accessing the Source Text
            		

                    Accessing Comments
            		
                
            		

                    Options Schemas
            		

                    Option Defaults
            		

                    Accessing Shebangs
            		

                    Accessing Variable Scopes
            
                
                    
                    Scope types
            		

                    Scope Variables
            		
                
            		

                    Marking Variables as Used
            		

                    Accessing Code Paths
            		

                    Deprecated SourceCode Methods
            		
                
            		

                    Rule Unit Tests
            		

                    Rule Naming Conventions
            		

                    Runtime Rules
            		

                    Profile Rule Performance
            		
                
            
    


                You can create custom rules to use with ESLint. You might want to create a custom rule if the core rules do not cover your use case.
Here’s the basic format of a custom rule:


    // customRule.js

module.exports = {
	meta: {
		type: "suggestion",
		docs: {
			description: "Description of the rule",
		},
		fixable: "code",
		schema: [], // no options
	},
	create: function (context) {
		return {
			// callback functions
		};
	},
};
1234567891011121314151617
    
        Copy code to clipboard
        
    


                    
                    
                        Warning
                        The core rules shipped in the eslint package are not considered part of the public API and are not designed to be extended from. Building on top of these rules is fragile and will most likely result in your rules breaking completely at some point in the future. If you’re interested in creating a rule that is similar to a core rule, you should first copy the rule file into your project and proceed from there.

                    
                Rule Structure
The source file for a rule exports an object with the following properties. Both custom rules and core rules follow this format.
meta: (object) Contains metadata for the rule:


type: (string) Indicates the type of rule, which is one of "problem", "suggestion", or "layout":

"problem": The rule is identifying code that either will cause an error or may cause a confusing behavior. Developers should consider this a high priority to resolve.
"suggestion": The rule is identifying something that could be done in a better way but no errors will occur if the code isn’t changed.
"layout": The rule cares primarily about whitespace, semicolons, commas, and parentheses, all the parts of the program that determine how the code looks rather than how it executes. These rules work on parts of the code that aren’t specified in the AST.



docs: (object) Properties often used for documentation generation and tooling. Required for core rules and optional for custom rules. Custom rules can include additional properties here as needed.

description: (string) Provides a short description of the rule. For core rules, this is used in rules index.
recommended: (boolean) For core rules, this specifies whether the rule is enabled by the recommended config from @eslint/js.
url: (string) Specifies the URL at which the full documentation can be accessed. Code editors often use this to provide a helpful link on highlighted rule violations.



fixable: (string) Either "code" or "whitespace" if the --fix option on the command line automatically fixes problems reported by the rule.
Important: the fixable property is mandatory for fixable rules. If this property isn’t specified, ESLint will throw an error whenever the rule attempts to produce a fix. Omit the fixable property if the rule is not fixable.


hasSuggestions: (boolean) Specifies whether rules can return suggestions (defaults to false if omitted).
Important: the hasSuggestions property is mandatory for rules that provide suggestions. If this property isn’t set to true, ESLint will throw an error whenever the rule attempts to produce a suggestion. Omit the hasSuggestions property if the rule does not provide suggestions.


schema: (object | array | false) Specifies the options so ESLint can prevent invalid rule configurations. Mandatory when the rule has options.


defaultOptions: (array) Specifies default options for the rule. If present, any user-provided options in their config will be merged on top of them recursively.


deprecated: (boolean | DeprecatedInfo) Indicates whether the rule has been deprecated. You may omit the deprecated property if the rule has not been deprecated.
There is a dedicated page for the DeprecatedInfo


replacedBy: (array, Deprecated Use meta.deprecated.replacedBy instead.) In the case of a deprecated rule, specify replacement rule(s).


create(): Returns an object with methods that ESLint calls to “visit” nodes while traversing the abstract syntax tree (AST as defined by ESTree) of JavaScript code:

If a key is a node type or a selector, ESLint calls that visitor function while going down the tree.
If a key is a node type or a selector plus :exit, ESLint calls that visitor function while going up the tree.
If a key is an event name, ESLint calls that handler function for code path analysis.

A rule can use the current node and its surrounding tree to report or fix problems.
Here are methods for the array-callback-return rule:


    function checkLastSegment (node) {
    // report problem for function if last code path segment is reachable
}

module.exports = {
    meta: { ... },
    create: function(context) {
        // declare the state of the rule
        return {
            ReturnStatement: function(node) {
                // at a ReturnStatement node while going down
            },
            // at a function expression node while going up:
            "FunctionExpression:exit": checkLastSegment,
            "ArrowFunctionExpression:exit": checkLastSegment,
            onCodePathStart: function (codePath, node) {
                // at the start of analyzing a code path
            },
            onCodePathEnd: function(codePath, node) {
                // at the end of analyzing a code path
            }
        };
    }
};
123456789101112131415161718192021222324
    
        Copy code to clipboard
        
    


                    
                    
                        Tip
                        You can view the complete AST for any JavaScript code using Code Explorer.

                    
                The Context Object
The context object is the only argument of the create method in a rule. For example:


    // customRule.js

module.exports = {
    meta: { ... },
    // `context` object is the argument
    create(context) {
       // ...
    }
};
123456789
    
        Copy code to clipboard
        
    

As the name implies, the context object contains information that is relevant to the context of the rule.
The context object has the following properties:

id: (string) The rule ID.
filename: (string) The filename associated with the source.
physicalFilename: (string) When linting a file, it provides the full path of the file on disk without any code block information. When linting text, it provides the value passed to —stdin-filename or <text> if not specified.
cwd: (string) The cwd option passed to the Linter. It is a path to a directory that should be considered the current working directory.
options: (array) An array of the configured options for this rule. This array does not include the rule severity (see the dedicated section).
sourceCode: (object) A SourceCode object that you can use to work with the source that was passed to ESLint (see Accessing the Source Code).
settings: (object) The shared settings from the configuration.
languageOptions: (object) more details for each property here

sourceType: ('script' | 'module' | 'commonjs') The mode for the current file.
ecmaVersion: (number) The ECMA version used to parse the current file.
parser: (object): The parser used to parse the current file.
parserOptions: (object) The parser options configured for this file.
globals: (object) The specified globals.


parserPath: (string, Removed Use context.languageOptions.parser instead.) The name of the parser from the configuration.
parserOptions: (Deprecated Use context.languageOptions.parserOptions instead.) The parser options configured for this run (more details here).

Additionally, the context object has the following methods:

getCwd(): (Deprecated: Use context.cwd instead.) Returns the cwd option passed to the Linter. It is a path to a directory that should be considered the current working directory.
getFilename(): (Deprecated: Use context.filename instead.) Returns the filename associated with the source.
getPhysicalFilename(): (Deprecated: Use context.physicalFilename instead.) When linting a file, it returns the full path of the file on disk without any code block information. When linting text, it returns the value passed to —stdin-filename or <text> if not specified.
getSourceCode(): (Deprecated: Use context.sourceCode instead.) Returns a SourceCode object that you can use to work with the source that was passed to ESLint (see Accessing the Source Code).
report(descriptor). Reports a problem in the code (see the dedicated section).

Note: Earlier versions of ESLint supported additional methods on the context object. Those methods were removed in the new format and should not be relied upon.
Reporting Problems
The main method you’ll use when writing custom rules is context.report(), which publishes a warning or error (depending on the configuration being used). This method accepts a single argument, which is an object containing the following properties:

messageId: (string) The ID of the message (see messageIds) (recommended over message).
message: (string) The problem message (alternative to messageId).
node: (optional object) The AST node related to the problem. If present and loc is not specified, then the starting location of the node is used as the location of the problem.
loc: (optional object) Specifies the location of the problem. If both loc and node are specified, then the location is used from loc instead of node.

start: An object of the start location.

line: (number) The 1-based line number at which the problem occurred.
column: (number) The 0-based column number at which the problem occurred.


end: An object of the end location.

line: (number) The 1-based line number at which the problem occurred.
column: (number) The 0-based column number at which the problem occurred.




data: (optional object) Placeholder data for message.
fix(fixer): (optional function) Applies a fix to resolve the problem.

Note that at least one of node or loc is required.
The simplest example is to use just node and message:


    context.report({
	node: node,
	message: "Unexpected identifier",
});
1234
    
        Copy code to clipboard
        
    

The node contains all the information necessary to figure out the line and column number of the offending text as well as the source text representing the node.
Using Message Placeholders
You can also use placeholders in the message and provide data:


    
context.report({
    node: node,
    message: "Unexpected identifier: {{ identifier }}",
    data: {
        identifier: node.name
    }
});

123456789
    
        Copy code to clipboard
        
    

Note that leading and trailing whitespace is optional in message parameters.
The node contains all the information necessary to figure out the line and column number of the offending text as well as the source text representing the node.
messageIds
messageIds are the recommended approach to reporting messages in context.report() calls because of the following benefits:

Rule violation messages can be stored in a central meta.messages object for convenient management.
Rule violation messages do not need to be repeated in both the rule file and rule test file.
As a result, the barrier for changing rule violation messages is lower, encouraging more frequent contributions to improve and optimize them for the greatest clarity and usefulness.

Rule file:


    
// avoid-name.js

module.exports = {
    meta: {
        messages: {
            avoidName: "Avoid using variables named '{{ name }}'"
        }
    },
    create(context) {
        return {
            Identifier(node) {
                if (node.name === "foo") {
                    context.report({
                        node,
                        messageId: "avoidName",
                        data: {
                            name: "foo",
                        }
                    });
                }
            }
        };
    }
};

1234567891011121314151617181920212223242526
    
        Copy code to clipboard
        
    

In the file to lint:


    // someFile.js

var foo = 2;
//  ^ error: Avoid using variables named 'foo'
1234
    
        Copy code to clipboard
        
    

In your tests:


    // avoid-name.test.js

var rule = require("../../../lib/rules/avoid-name");
var RuleTester = require("eslint").RuleTester;

var ruleTester = new RuleTester();
ruleTester.run("avoid-name", rule, {
	valid: ["bar", "baz"],
	invalid: [
		{
			code: "foo",
			errors: [
				{
					messageId: "avoidName",
				},
			],
		},
	],
});
12345678910111213141516171819
    
        Copy code to clipboard
        
    

Applying Fixes
If you’d like ESLint to attempt to fix the problem you’re reporting, you can do so by specifying the fix function when using context.report(). The fix function receives a single argument, a fixer object, that you can use to apply a fix. For example:


    context.report({
	node: node,
	message: "Missing semicolon",
	fix(fixer) {
		return fixer.insertTextAfter(node, ";");
	},
});
1234567
    
        Copy code to clipboard
        
    

Here, the fix() function is used to insert a semicolon after the node. Note that a fix is not immediately applied, and may not be applied at all if there are conflicts with other fixes. After applying fixes, ESLint will run all the enabled rules again on the fixed code, potentially applying more fixes. This process will repeat up to 10 times, or until no more fixable problems are found. Afterward, any remaining problems will be reported as usual.
Important: The meta.fixable property is mandatory for fixable rules. ESLint will throw an error if a rule that implements fix functions does not export the meta.fixable property.
The fixer object has the following methods:

insertTextAfter(nodeOrToken, text): Insert text after the given node or token.
insertTextAfterRange(range, text): Insert text after the given range.
insertTextBefore(nodeOrToken, text): Insert text before the given node or token.
insertTextBeforeRange(range, text): Insert text before the given range.
remove(nodeOrToken): Remove the given node or token.
removeRange(range): Remove text in the given range.
replaceText(nodeOrToken, text): Replace the text in the given node or token.
replaceTextRange(range, text): Replace the text in the given range.

A range is a two-item array containing character indices inside the source code. The first item is the start of the range (inclusive) and the second item is the end of the range (exclusive). Every node and token has a range property to identify the source code range they represent.
The above methods return a fixing object.
The fix() function can return the following values:

A fixing object.
An array which includes fixing objects.
An iterable object which enumerates fixing objects. Especially, the fix() function can be a generator.

If you make a fix() function which returns multiple fixing objects, those fixing objects must not overlap.
Best practices for fixes:


Avoid any fixes that could change the runtime behavior of code and cause it to stop working.


Make fixes as small as possible. Fixes that are unnecessarily large could conflict with other fixes, and prevent them from being applied.


Only make one fix per message. This is enforced because you must return the result of the fixer operation from fix().


Since all rules are run again after the initial round of fixes is applied, it’s not necessary for a rule to check whether the code style of a fix will cause errors to be reported by another rule.


For example, suppose a fixer would like to surround an object key with quotes, but it’s not sure whether the user would prefer single or double quotes.


    { foo: 1 }

// should get fixed to either
{ 'foo': 1 }

// or
{ "foo": 1 }
1234567
    
        Copy code to clipboard
        
    



This fixer can just select a quote type arbitrarily. If it guesses wrong, the resulting code will be automatically reported and fixed by the quotes rule.




Note: Making fixes as small as possible is a best practice, but in some cases it may be correct to extend the range of the fix in order to intentionally prevent other rules from making fixes in a surrounding range in the same pass. For instance, if replacement text declares a new variable, it can be useful to prevent other changes in the scope of the variable as they might cause name collisions.
The following example replaces node and also ensures that no other fixes will be applied in the range of node.parent in the same pass:


    context.report({
	node,
	message,
	*fix(fixer) {
		yield fixer.replaceText(node, replacementText);

		// extend range of the fix to the range of `node.parent`
		yield fixer.insertTextBefore(node.parent, "");
		yield fixer.insertTextAfter(node.parent, "");
	},
});
1234567891011
    
        Copy code to clipboard
        
    

Conflicting Fixes
Conflicting fixes are fixes that apply different changes to the same part of the source code.
There is no way to specify which of the conflicting fixes is applied.
For example, if two fixes want to modify characters 0 through 5, only one is applied.
Providing Suggestions
In some cases fixes aren’t appropriate to be automatically applied, for example, if a fix potentially changes functionality or if there are multiple valid ways to fix a rule depending on the implementation intent (see the best practices for applying fixes listed above). In these cases, there is an alternative suggest option on context.report() that allows other tools, such as editors, to expose helpers for users to manually apply a suggestion.
To provide suggestions, use the suggest key in the report argument with an array of suggestion objects. The suggestion objects represent individual suggestions that could be applied and require either a desc key string that describes what applying the suggestion would do or a messageId key (see below), and a fix key that is a function defining the suggestion result. This fix function follows the same API as regular fixes (described above in applying fixes).


    
context.report({
    node: node,
    message: "Unnecessary escape character: \\{{character}}.",
    data: { character },
    suggest: [
        {
            desc: "Remove the `\\`. This maintains the current functionality.",
            fix: function(fixer) {
                return fixer.removeRange(range);
            }
        },
        {
            desc: "Replace the `\\` with `\\\\` to include the actual backslash character.",
            fix: function(fixer) {
                return fixer.insertTextBeforeRange(range, "\\");
            }
        }
    ]
});

123456789101112131415161718192021
    
        Copy code to clipboard
        
    

Important: The meta.hasSuggestions property is mandatory for rules that provide suggestions. ESLint will throw an error if a rule attempts to produce a suggestion but does not export this property.
Note: Suggestions are applied as stand-alone changes, without triggering multipass fixes. Each suggestion should focus on a singular change in the code and should not try to conform to user-defined styles. For example, if a suggestion is adding a new statement into the codebase, it should not try to match correct indentation or conform to user preferences on the presence/absence of semicolons. All of those things can be corrected by multipass autofix when the user triggers it.
Best practices for suggestions:

Don’t try to do too much and suggest large refactors that could introduce a lot of breaking changes.
As noted above, don’t try to conform to user-defined styles.

Suggestions are intended to provide fixes. ESLint will automatically remove the whole suggestion from the linting output if the suggestion’s fix function returned null or an empty array/sequence.
Suggestion messageIds
Instead of using a desc key for suggestions a messageId can be used instead. This works the same way as messageIds for the overall error (see messageIds). Here is an example of how to use a suggestion messageId in a rule:


    
module.exports = {
    meta: {
        messages: {
            unnecessaryEscape: "Unnecessary escape character: \\{{character}}.",
            removeEscape: "Remove the `\\`. This maintains the current functionality.",
            escapeBackslash: "Replace the `\\` with `\\\\` to include the actual backslash character."
        },
        hasSuggestions: true
    },
    create: function(context) {
        // ...
        context.report({
            node: node,
            messageId: 'unnecessaryEscape',
            data: { character },
            suggest: [
                {
                    messageId: "removeEscape", // suggestion messageId
                    fix: function(fixer) {
                        return fixer.removeRange(range);
                    }
                },
                {
                    messageId: "escapeBackslash", // suggestion messageId
                    fix: function(fixer) {
                        return fixer.insertTextBeforeRange(range, "\\");
                    }
                }
            ]
        });
    }
};

12345678910111213141516171819202122232425262728293031323334
    
        Copy code to clipboard
        
    

Placeholders in Suggestion Messages
You can also use placeholders in the suggestion message. This works the same way as placeholders for the overall error (see using message placeholders).
Please note that you have to provide data on the suggestion’s object. Suggestion messages cannot use properties from the overall error’s data.


    
module.exports = {
    meta: {
        messages: {
            unnecessaryEscape: "Unnecessary escape character: \\{{character}}.",
            removeEscape: "Remove `\\` before {{character}}.",
        },
        hasSuggestions: true
    },
    create: function(context) {
        // ...
        context.report({
            node: node,
            messageId: "unnecessaryEscape",
            data: { character }, // data for the unnecessaryEscape overall message
            suggest: [
                {
                    messageId: "removeEscape",
                    data: { character }, // data for the removeEscape suggestion message
                    fix: function(fixer) {
                        return fixer.removeRange(range);
                    }
                }
            ]
        });
    }
};

12345678910111213141516171819202122232425262728
    
        Copy code to clipboard
        
    

Accessing Options Passed to a Rule
Some rules require options in order to function correctly. These options appear in configuration (.eslintrc, command line interface, or comments). For example:


    {
	"quotes": ["error", "double"]
}
123
    
        Copy code to clipboard
        
    

The quotes rule in this example has one option, "double" (the error is the error level). You can retrieve the options for a rule by using context.options, which is an array containing every configured option for the rule. In this case, context.options[0] would contain "double":


    module.exports = {
	meta: {
		schema: [
			{
				enum: ["single", "double", "backtick"],
			},
		],
	},
	create: function (context) {
		var isDouble = context.options[0] === "double";

		// ...
	},
};
1234567891011121314
    
        Copy code to clipboard
        
    

Since context.options is just an array, you can use it to determine how many options have been passed as well as retrieving the actual options themselves. Keep in mind that the error level is not part of context.options, as the error level cannot be known or modified from inside a rule.
When using options, make sure that your rule has some logical defaults in case the options are not provided.
Rules with options must specify a schema.
Accessing the Source Code
The SourceCode object is the main object for getting more information about the source code being linted. You can retrieve the SourceCode object at any time by using the context.sourceCode property:


    module.exports = {
	create: function (context) {
		var sourceCode = context.sourceCode;

		// ...
	},
};
1234567
    
        Copy code to clipboard
        
    

Deprecated: The context.getSourceCode() method is deprecated; make sure to use context.sourceCode property instead.
Once you have an instance of SourceCode, you can use the following methods on it to work with the code:

getText(node): Returns the source code for the given node. Omit node to get the whole source (see the dedicated section).
getAllComments(): Returns an array of all comments in the source (see the dedicated section).
getCommentsBefore(nodeOrToken): Returns an array of comment tokens that occur directly before the given node or token (see the dedicated section).
getCommentsAfter(nodeOrToken): Returns an array of comment tokens that occur directly after the given node or token (see the dedicated section).
getCommentsInside(node): Returns an array of all comment tokens inside a given node (see the dedicated section).
isSpaceBetween(nodeOrToken, nodeOrToken): Returns true if there is a whitespace character between the two tokens or, if given a node, the last token of the first node and the first token of the second node.
getFirstToken(node, skipOptions): Returns the first token representing the given node.
getFirstTokens(node, countOptions): Returns the first count tokens representing the given node.
getLastToken(node, skipOptions): Returns the last token representing the given node.
getLastTokens(node, countOptions): Returns the last count tokens representing the given node.
getTokenAfter(nodeOrToken, skipOptions): Returns the first token after the given node or token.
getTokensAfter(nodeOrToken, countOptions): Returns count tokens after the given node or token.
getTokenBefore(nodeOrToken, skipOptions): Returns the first token before the given node or token.
getTokensBefore(nodeOrToken, countOptions): Returns count tokens before the given node or token.
getFirstTokenBetween(nodeOrToken1, nodeOrToken2, skipOptions): Returns the first token between two nodes or tokens.
getFirstTokensBetween(nodeOrToken1, nodeOrToken2, countOptions): Returns the first count tokens between two nodes or tokens.
getLastTokenBetween(nodeOrToken1, nodeOrToken2, skipOptions): Returns the last token between two nodes or tokens.
getLastTokensBetween(nodeOrToken1, nodeOrToken2, countOptions): Returns the last count tokens between two nodes or tokens.
getTokens(node): Returns all tokens for the given node.
getTokensBetween(nodeOrToken1, nodeOrToken2): Returns all tokens between two nodes.
getTokenByRangeStart(index, rangeOptions): Returns the token whose range starts at the given index in the source.
getNodeByRangeIndex(index): Returns the deepest node in the AST containing the given source index.
getLocFromIndex(index): Returns an object with line and column properties, corresponding to the location of the given source index. line is 1-based and column is 0-based.
getIndexFromLoc(loc): Returns the index of a given location in the source code, where loc is an object with a 1-based line key and a 0-based column key.
commentsExistBetween(nodeOrToken1, nodeOrToken2): Returns true if comments exist between two nodes.
getAncestors(node): Returns an array of the ancestors of the given node, starting at the root of the AST and continuing through the direct parent of the given node. This array does not include the given node itself.
getDeclaredVariables(node): Returns a list of variables declared by the given node. This information can be used to track references to variables.

If the node is a VariableDeclaration, all variables declared in the declaration are returned.
If the node is a VariableDeclarator, all variables declared in the declarator are returned.
If the node is a FunctionDeclaration or FunctionExpression, the variable for the function name is returned, in addition to variables for the function parameters.
If the node is an ArrowFunctionExpression, variables for the parameters are returned.
If the node is a ClassDeclaration or a ClassExpression, the variable for the class name is returned.
If the node is a CatchClause, the variable for the exception is returned.
If the node is an ImportDeclaration, variables for all of its specifiers are returned.
If the node is an ImportSpecifier, ImportDefaultSpecifier, or ImportNamespaceSpecifier, the declared variable is returned.
Otherwise, if the node does not declare any variables, an empty array is returned.


getScope(node): Returns the scope of the given node. This information can be used to track references to variables.
markVariableAsUsed(name, refNode): Marks a variable with the given name in a scope indicated by the given reference node as used. This affects the no-unused-vars rule. Returns true if a variable with the given name was found and marked as used, otherwise false.

skipOptions is an object which has 3 properties; skip, includeComments, and filter. Default is {skip: 0, includeComments: false, filter: null}.

skip: (number) Positive integer, the number of skipping tokens. If filter option is given at the same time, it doesn’t count filtered tokens as skipped.
includeComments: (boolean) The flag to include comment tokens into the result.
filter(token): Function which gets a token as the first argument. If the function returns false then the result excludes the token.

countOptions is an object which has 3 properties; count, includeComments, and filter. Default is {count: 0, includeComments: false, filter: null}.

count: (number) Positive integer, the maximum number of returning tokens.
includeComments: (boolean) The flag to include comment tokens into the result.
filter(token): Function which gets a token as the first argument, if the function returns false then the result excludes the token.

rangeOptions is an object that has 1 property, includeComments. Default is {includeComments: false}.

includeComments: (boolean) The flag to include comment tokens into the result.

There are also some properties you can access:

hasBOM: (boolean) The flag to indicate whether the source code has Unicode BOM.
text: (string) The full text of the code being linted. Unicode BOM has been stripped from this text.
ast: (object) Program node of the AST for the code being linted.
scopeManager: ScopeManager object of the code.
visitorKeys: (object) Visitor keys to traverse this AST.
parserServices: (object) Contains parser-provided services for rules. The default parser does not provide any services. However, if a rule is intended to be used with a custom parser, it could use parserServices to access anything provided by that parser. (For example, a TypeScript parser could provide the ability to get the computed type of a given node.)
lines: (array) Array of lines, split according to the specification’s definition of line breaks.

You should use a SourceCode object whenever you need to get more information about the code being linted.
Accessing the Source Text
If your rule needs to get the actual JavaScript source to work with, then use the sourceCode.getText() method. This method works as follows:


    // get all source
var source = sourceCode.getText();

// get source for just this AST node
var nodeSource = sourceCode.getText(node);

// get source for AST node plus previous two characters
var nodeSourceWithPrev = sourceCode.getText(node, 2);

// get source for AST node plus following two characters
var nodeSourceWithFollowing = sourceCode.getText(node, 0, 2);
1234567891011
    
        Copy code to clipboard
        
    

In this way, you can look for patterns in the JavaScript text itself when the AST isn’t providing the appropriate data (such as the location of commas, semicolons, parentheses, etc.).
Accessing Comments
While comments are not technically part of the AST, ESLint provides the sourceCode.getAllComments(), sourceCode.getCommentsBefore(), sourceCode.getCommentsAfter(), and sourceCode.getCommentsInside() to access them.
sourceCode.getCommentsBefore(), sourceCode.getCommentsAfter(), and sourceCode.getCommentsInside() are useful for rules that need to check comments in relation to a given node or token.
Keep in mind that the results of these methods are calculated on demand.
You can also access comments through many of sourceCode’s methods using the includeComments option.
Options Schemas
Rules with options must specify a meta.schema property, which is a JSON Schema format description of a rule’s options which will be used by ESLint to validate configuration options and prevent invalid or unexpected inputs before they are passed to the rule in context.options.
If your rule has options, it is strongly recommended that you specify a schema for options validation. However, it is possible to opt-out of options validation by setting schema: false, but doing so is discouraged as it increases the chance of bugs and mistakes.
For rules that don’t specify a meta.schema property, ESLint throws errors when any options are passed. If your rule doesn’t have options, do not set schema: false, but simply omit the schema property or use schema: [], both of which prevent any options from being passed.
When validating a rule’s config, there are five steps:

If the rule config is not an array, then the value is wrapped into an array (e.g. "off" becomes ["off"]); if the rule config is an array then it is used directly.
ESLint validates the first element of the rule config array as a severity ("off", "warn", "error", 0, 1, 2)
If the severity is off or 0, then the rule is disabled and validation stops, ignoring any other elements of the rule config array.
If the rule is enabled, then any elements of the array after the severity are copied into the context.options array (e.g. a config of ["warn", "never", { someOption: 5 }] results in context.options = ["never", { someOption: 5 }])
The rule’s schema validation is run on the context.options array.

Note: this means that the rule schema cannot validate the severity. The rule schema only validates the array elements after the severity in a rule config. There is no way for a rule to know what severity it is configured at.
There are two formats for a rule’s schema:

An array of JSON Schema objects

Each element will be checked against the same position in the context.options array.
If the context.options array has fewer elements than there are schemas, then the unmatched schemas are ignored.
If the context.options array has more elements than there are schemas, then the validation fails.
There are two important consequences to using this format:

It is always valid for a user to provide no options to your rule (beyond severity).
If you specify an empty array, then it is always an error for a user to provide any options to your rule (beyond severity).




A full JSON Schema object that will validate the context.options array

The schema should assume an array of options to validate even if your rule only accepts one option.
The schema can be arbitrarily complex, so you can validate completely different sets of potential options via oneOf, anyOf etc.
The supported version of JSON Schemas is Draft-04, so some newer features such as if or $data are unavailable.

At present, it is explicitly planned to not update schema support beyond this level due to ecosystem compatibility concerns. See this comment for further context.





For example, the yoda rule accepts a primary mode argument of "always" or "never", as well as an extra options object with an optional property exceptRange:


    // Valid configuration:
// "yoda": "warn"
// "yoda": ["error"]
// "yoda": ["error", "always"]
// "yoda": ["error", "never", { "exceptRange": true }]
// Invalid configuration:
// "yoda": ["warn", "never", { "exceptRange": true }, 5]
// "yoda": ["error", { "exceptRange": true }, "never"]
module.exports = {
	meta: {
		schema: [
			{
				enum: ["always", "never"],
			},
			{
				type: "object",
				properties: {
					exceptRange: { type: "boolean" },
				},
				additionalProperties: false,
			},
		],
	},
};
123456789101112131415161718192021222324
    
        Copy code to clipboard
        
    

And here is the equivalent object-based schema:


    // Valid configuration:
// "yoda": "warn"
// "yoda": ["error"]
// "yoda": ["error", "always"]
// "yoda": ["error", "never", { "exceptRange": true }]
// Invalid configuration:
// "yoda": ["warn", "never", { "exceptRange": true }, 5]
// "yoda": ["error", { "exceptRange": true }, "never"]
module.exports = {
	meta: {
		schema: {
			type: "array",
			minItems: 0,
			maxItems: 2,
			items: [
				{
					enum: ["always", "never"],
				},
				{
					type: "object",
					properties: {
						exceptRange: { type: "boolean" },
					},
					additionalProperties: false,
				},
			],
		},
	},
};
1234567891011121314151617181920212223242526272829
    
        Copy code to clipboard
        
    

Object schemas can be more precise and restrictive in what is permitted. For example, the below schema always requires the first option to be specified (a number between 0 and 10), but the second option is optional, and can either be an object with some options explicitly set, or "off" or "strict".


    // Valid configuration:
// "someRule": ["error", 6]
// "someRule": ["error", 5, "strict"]
// "someRule": ["warn", 10, { someNonOptionalProperty: true }]
// Invalid configuration:
// "someRule": "warn"
// "someRule": ["error"]
// "someRule": ["warn", 15]
// "someRule": ["warn", 7, { }]
// "someRule": ["error", 3, "on"]
// "someRule": ["warn", 7, { someOtherProperty: 5 }]
// "someRule": ["warn", 7, { someNonOptionalProperty: false, someOtherProperty: 5 }]
module.exports = {
	meta: {
		schema: {
			type: "array",
			minItems: 1, // Can't specify only severity!
			maxItems: 2,
			items: [
				{
					type: "number",
					minimum: 0,
					maximum: 10,
				},
				{
					anyOf: [
						{
							type: "object",
							properties: {
								someNonOptionalProperty: { type: "boolean" },
							},
							required: ["someNonOptionalProperty"],
							additionalProperties: false,
						},
						{
							enum: ["off", "strict"],
						},
					],
				},
			],
		},
	},
};
12345678910111213141516171819202122232425262728293031323334353637383940414243
    
        Copy code to clipboard
        
    

Remember, rule options are always an array, so be careful not to specify a schema for a non-array type at the top level. If your schema does not specify an array at the top-level, users can never enable your rule, as their configuration will always be invalid when the rule is enabled.
Here’s an example schema that will always fail validation:


    // Possibly trying to validate ["error", { someOptionalProperty: true }]
// but when the rule is enabled, config will always fail validation because the options are an array which doesn't match "object"
module.exports = {
	meta: {
		schema: {
			type: "object",
			properties: {
				someOptionalProperty: {
					type: "boolean",
				},
			},
			additionalProperties: false,
		},
	},
};
123456789101112131415
    
        Copy code to clipboard
        
    

Note: If your rule schema uses JSON schema $ref properties, you must use the full JSON Schema object rather than the array of positional property schemas. This is because ESLint transforms the array shorthand into a single schema without updating references that makes them incorrect (they are ignored).
To learn more about JSON Schema, we recommend looking at some examples on the JSON Schema website, or reading the free Understanding JSON Schema ebook.
Option Defaults
Rules may specify a meta.defaultOptions array of default values for any options.
When the rule is enabled in a user configuration, ESLint will recursively merge any user-provided option elements on top of the default elements.
For example, given the following defaults:


    export default {
	meta: {
		defaultOptions: [
			{
				alias: "basic",
			},
		],
		schema: [
			{
				type: "object",
				properties: {
					alias: {
						type: "string",
					},
				},
				additionalProperties: false,
			},
		],
	},
	create(context) {
		const [{ alias }] = context.options;

		return {
			/* ... */
		};
	},
};
123456789101112131415161718192021222324252627
    
        Copy code to clipboard
        
    

The rule would have a runtime alias value of "basic" unless the user configuration specifies a different value, such as with ["error", { alias: "complex" }].
Each element of the options array is merged according to the following rules:

Any missing value or explicit user-provided undefined will fall back to a default option
User-provided arrays and primitive values other than undefined override a default option
User-provided objects will merge into a default option object and replace a non-object default otherwise

Option defaults will also be validated against the rule’s meta.schema.
Note: ESLint internally uses Ajv for schema validation with its useDefaults option enabled.
Both user-provided and meta.defaultOptions options will override any defaults specified in a rule’s schema.
ESLint may disable Ajv’s useDefaults in a future major version.
Accessing Shebangs
Shebangs (#!) are represented by the unique tokens of type "Shebang". They are treated as comments and can be accessed by the methods outlined in the Accessing Comments section, such as sourceCode.getAllComments().
Accessing Variable Scopes
The SourceCode#getScope(node) method returns the scope of the given node. It is a useful method for finding information about the variables in a given scope and how they are used in other scopes.

                    
                    
                        Tip
                        You can view scope information for any JavaScript code using Code Explorer.

                    
                Scope types
The following table contains a list of AST node types and the scope type that they correspond to. For more information about the scope types, refer to the Scope object documentation.



AST Node Type
Scope Type




Program
global


FunctionDeclaration
function


FunctionExpression
function


ArrowFunctionExpression
function


ClassDeclaration
class


ClassExpression
class


BlockStatement ※1
block


SwitchStatement ※1
switch


ForStatement ※2
for


ForInStatement ※2
for


ForOfStatement ※2
for


WithStatement
with


CatchClause
catch


others
※3



※1 Only if the configured parser provided the block-scope feature. The default parser provides the block-scope feature if parserOptions.ecmaVersion is not less than 6.
※2 Only if the for statement defines the iteration variable as a block-scoped variable (E.g., for (let i = 0;;) {}).
※3 The scope of the closest ancestor node which has own scope. If the closest ancestor node has multiple scopes then it chooses the innermost scope (E.g., the Program node has a global scope and a module scope if Program#sourceType is "module". The innermost scope is the module scope.).
Scope Variables
The Scope#variables property contains an array of Variable objects. These are the variables declared in current scope. You can use these Variable objects to track references to a variable throughout the entire module.
Inside of each Variable, the Variable#references property contains an array of Reference objects. The Reference array contains all the locations where the variable is referenced in the module’s source code.
Also inside of each Variable, the Variable#defs property contains an array of Definition objects. You can use the Definitions to find where the variable was defined.
Global variables have the following additional properties:

Variable#writeable (boolean | undefined) … If true, this global variable can be assigned arbitrary value. If false, this global variable is read-only.
Variable#eslintExplicitGlobal (boolean | undefined) … If true, this global variable was defined by a /* globals */ directive comment in the source code file.
Variable#eslintExplicitGlobalComments (Comment[] | undefined) … The array of /* globals */ directive comments which defined this global variable in the source code file. This property is undefined if there are no /* globals */ directive comments.
Variable#eslintImplicitGlobalSetting ("readonly" | "writable" | undefined) … The configured value in config files. This can be different from variable.writeable if there are /* globals */ directive comments.

For examples of using SourceCode#getScope() to track variables, refer to the source code for the following built-in rules:

no-shadow: Calls sourceCode.getScope() at the Program node and inspects all child scopes to make sure a variable name is not reused at a lower scope. (no-shadow documentation)
no-redeclare: Calls sourceCode.getScope() at each scope to make sure that a variable is not declared twice in the same scope. (no-redeclare documentation)

Marking Variables as Used
Certain ESLint rules, such as no-unused-vars, check to see if a variable has been used. ESLint itself only knows about the standard rules of variable access and so custom ways of accessing variables may not register as “used”.
To help with this, you can use the sourceCode.markVariableAsUsed() method. This method takes two arguments: the name of the variable to mark as used and an option reference node indicating the scope in which you are working. Here’s an example:


    module.exports = {
	create: function (context) {
		var sourceCode = context.sourceCode;

		return {
			ReturnStatement(node) {
				// look in the scope of the function for myCustomVar and mark as used
				sourceCode.markVariableAsUsed("myCustomVar", node);

				// or: look in the global scope for myCustomVar and mark as used
				sourceCode.markVariableAsUsed("myCustomVar");
			},
		};
		// ...
	},
};
12345678910111213141516
    
        Copy code to clipboard
        
    

Here, the myCustomVar variable is marked as used relative to a ReturnStatement node, which means ESLint will start searching from the scope closest to that node. If you omit the second argument, then the top-level scope is used. (For ESM files, the top-level scope is the module scope; for CommonJS files, the top-level scope is the first function scope.)
Accessing Code Paths
ESLint analyzes code paths while traversing AST. You can access code path objects with seven events related to code paths. For more information, refer to Code Path Analysis.
Deprecated SourceCode Methods
Please note that the following SourceCode methods have been deprecated and will be removed in a future version of ESLint:

getTokenOrCommentBefore(): Replaced by SourceCode#getTokenBefore() with the { includeComments: true } option.
getTokenOrCommentAfter(): Replaced by SourceCode#getTokenAfter() with the { includeComments: true } option.
isSpaceBetweenTokens(): Replaced by SourceCode#isSpaceBetween()
getJSDocComment()

Rule Unit Tests
ESLint provides the RuleTester utility to make it easy to write tests for rules.
Rule Naming Conventions
While you can give a custom rule any name you’d like, the core rules have naming conventions. It could be clearer to apply these same naming conventions to your custom rule. To learn more, refer to the Core Rule Naming Conventions documentation.
Runtime Rules
The thing that makes ESLint different from other linters is the ability to define custom rules at runtime. This is perfect for rules that are specific to your project or company and wouldn’t make sense for ESLint to ship with or be included in a plugin. Just write your rules and include them at runtime.
Runtime rules are written in the same format as all other rules. Create your rule as you would any other and then follow these steps:

Place all of your runtime rules in the same directory (e.g., eslint_rules).
Create a configuration file and specify your rule ID error level under the rules key. Your rule will not run unless it has a value of "warn" or "error" in the configuration file.
Run the command line interface using the --rulesdir option to specify the location of your runtime rules.

Profile Rule Performance
ESLint has a built-in method to track the performance of individual rules. Setting the TIMING environment variable will trigger the display, upon linting completion, of the ten longest-running rules, along with their individual running time (rule creation + rule execution) and relative performance impact as a percentage of total rule processing time (rule creation + rule execution).


    $ TIMING=1 eslint lib
Rule                    | Time (ms) | Relative
:-----------------------|----------:|--------:
no-multi-spaces         |    52.472 |     6.1%
camelcase               |    48.684 |     5.7%
no-irregular-whitespace |    43.847 |     5.1%
valid-jsdoc             |    40.346 |     4.7%
handle-callback-err     |    39.153 |     4.6%
space-infix-ops         |    35.444 |     4.1%
no-undefined            |    25.693 |     3.0%
no-shadow               |    22.759 |     2.7%
no-empty-class          |    21.976 |     2.6%
semi                    |    19.359 |     2.3%
12345678910111213
    
        Copy code to clipboard
        
    

To test one rule explicitly, combine the --no-eslintrc, and --rule options:


    $ TIMING=1 eslint --no-eslintrc --rule "quotes: [2, 'double']" lib
Rule   | Time (ms) | Relative
:------|----------:|--------:
quotes |    18.066 |   100.0%
1234
    
        Copy code to clipboard
        
    

To see a longer list of results (more than 10), set the environment variable to another value such as TIMING=50 or TIMING=all.
For more granular timing information (per file per rule), use the stats option instead.

            

            
                Edit this page\n\n\n\nCustom Processors
                

                Table of Contents
    
        
                
                    
                    Custom Processor Specification
            
                
                    
                    How meta Objects are Used
            
                
                    
                    Plugin meta Object
            		

                    Processor meta Object
            		

                    Why Both Meta Objects are Needed
            		
                
            		
                
            		

                    Specifying Processor in Config Files
            		
                
            
    


                You can also create custom processors that tell ESLint how to process files other than standard JavaScript. For example, you could write a custom processor to extract and process JavaScript from Markdown files (@eslint/markdown includes a custom processor for this).

                    
                    
                        Tip
                        This page explains how to create a custom processor for use with the flat config format. For the deprecated eslintrc format, see the deprecated documentation.

                    
                Custom Processor Specification
In order to create a custom processor, the object exported from your module has to conform to the following interface:


    const plugin = {
	meta: {
		name: "eslint-plugin-example",
		version: "1.2.3",
	},
	processors: {
		"processor-name": {
			meta: {
				name: "eslint-processor-name",
				version: "1.2.3",
			},
			// takes text of the file and filename
			preprocess(text, filename) {
				// here, you can strip out any non-JS content
				// and split into multiple strings to lint

				return [
					// return an array of code blocks to lint
					{ text: code1, filename: "0.js" },
					{ text: code2, filename: "1.js" },
				];
			},

			// takes a Message[][] and filename
			postprocess(messages, filename) {
				// `messages` argument contains two-dimensional array of Message objects
				// where each top-level array item contains array of lint messages related
				// to the text that was returned in array from preprocess() method

				// you need to return a one-dimensional array of the messages you want to keep
				return [].concat(...messages);
			},

			supportsAutofix: true, // (optional, defaults to false)
		},
	},
};

// for ESM
export default plugin;

// OR for CommonJS
module.exports = plugin;
12345678910111213141516171819202122232425262728293031323334353637383940414243
    
        Copy code to clipboard
        
    

The preprocess method takes the file contents and filename as arguments, and returns an array of code blocks to lint. The code blocks will be linted separately but still be registered to the filename.
A code block has two properties text and filename. The text property is the content of the block and the filename property is the name of the block. The name of the block can be anything, but should include the file extension, which tells ESLint how to process the current block. ESLint checks matching files entries in the project’s config to determine if the code blocks should be linted.
It’s up to the plugin to decide if it needs to return just one part of the non-JavaScript file or multiple pieces. For example in the case of processing .html files, you might want to return just one item in the array by combining all scripts. However, for .md files, you can return multiple items because each JavaScript block might be independent.
The postprocess method takes a two-dimensional array of arrays of lint messages and the filename. Each item in the input array corresponds to the part that was returned from the preprocess method. The postprocess method must adjust the locations of all errors to correspond to locations in the original, unprocessed code, and aggregate them into a single flat array and return it.
Reported problems have the following location information in each lint message:


    type LintMessage = {
	/// The 1-based line number where the message occurs.
	line?: number;

	/// The 1-based column number where the message occurs.
	column?: number;

	/// The 1-based line number of the end location.
	endLine?: number;

	/// The 1-based column number of the end location.
	endColumn?: number;

	/// If `true`, this is a fatal error.
	fatal?: boolean;

	/// Information for an autofix.
	fix: Fix;

	/// The error message.
	message: string;

	/// The ID of the rule which generated the message, or `null` if not applicable.
	ruleId: string | null;

	/// The severity of the message.
	severity: 0 | 1 | 2;

	/// Information for suggestions.
	suggestions?: Suggestion[];
};

type Fix = {
	range: [number, number];
	text: string;
};

type Suggestion = {
	desc?: string;
	messageId?: string;
	fix: Fix;
};
123456789101112131415161718192021222324252627282930313233343536373839404142
    
        Copy code to clipboard
        
    

By default, ESLint does not perform autofixes when a custom processor is used, even when the --fix flag is enabled on the command line. To allow ESLint to autofix code when using your processor, you should take the following additional steps:


Update the postprocess method to additionally transform the fix property of reported problems. All autofixable problems have a fix property, which is an object with the following schema:


    {
    range: [number, number],
    text: string
}
1234
    
        Copy code to clipboard
        
    

The range property contains two indexes in the code, referring to the start and end location of a contiguous section of text that will be replaced. The text property refers to the text that will replace the given range.
In the initial list of problems, the fix property will refer to a fix in the processed JavaScript. The postprocess method should transform the object to refer to a fix in the original, unprocessed file.


Add a supportsAutofix: true property to the processor.


You can have both rules and custom processors in a single plugin. You can also have multiple processors in one plugin. To support multiple extensions, add each one to the processors element and point them to the same object.
How meta Objects are Used
The meta object helps ESLint cache configurations that use a processor and to provide more friendly debug messages.
Plugin meta Object
The plugin meta object provides information about the plugin itself. When a processor is specified using the string format plugin-name/processor-name, ESLint automatically uses the plugin meta to generate a name for the processor. This is the most common case for processors.
Example:


    // eslint.config.js
import { defineConfig } from "eslint/config";
import example from "eslint-plugin-example";

export default defineConfig([
	{
		files: ["**/*.txt"], // apply processor to text files
		plugins: {
			example,
		},
		processor: "example/processor-name",
	},
	// ... other configs
]);
1234567891011121314
    
        Copy code to clipboard
        
    

In this example, the processor name is "example/processor-name", and that’s the value that will be used for serializing configurations.
Processor meta Object
Each processor can also specify its own meta object. This information is used when the processor object is passed directly to processor in a configuration. In that case, ESLint doesn’t know which plugin the processor belongs to. The meta.name property should match the processor name and the meta.version property should match the npm package version for your processors. The easiest way to accomplish this is by reading this information from your package.json.
Example:


    // eslint.config.js
import { defineConfig } from "eslint/config";
import example from "eslint-plugin-example";

export default defineConfig([
	{
		files: ["**/*.txt"],
		processor: example.processors["processor-name"],
	},
	// ... other configs
]);
1234567891011
    
        Copy code to clipboard
        
    

In this example, specifying example.processors["processor-name"] directly uses the processor’s own meta object, which must be defined to ensure proper handling when the processor is not referenced through the plugin name.
Why Both Meta Objects are Needed
It is recommended that both the plugin and each processor provide their respective meta objects. This ensures that features relying on meta objects, such as --print-config and --cache, work correctly regardless of how the processor is specified in the configuration.
Specifying Processor in Config Files
In order to use a processor from a plugin in a configuration file, import the plugin and include it in the plugins key, specifying a namespace. Then, use that namespace to reference the processor in the processor configuration, like this:


    // eslint.config.js
import { defineConfig } from "eslint/config";
import example from "eslint-plugin-example";

export default defineConfig([
	{
		files: ["**/*.txt"],
		plugins: {
			example,
		},
		processor: "example/processor-name",
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    

See Specify a Processor in the Plugin Configuration documentation for more details.

            

            
                Edit this page\n\nCustom Processors
                

                Table of Contents
    
        
                
                    
                    Custom Processor Specification
            
                
                    
                    How meta Objects are Used
            
                
                    
                    Plugin meta Object
            		

                    Processor meta Object
            		

                    Why Both Meta Objects are Needed
            		
                
            		
                
            		

                    Specifying Processor in Config Files
            		
                
            
    


                You can also create custom processors that tell ESLint how to process files other than standard JavaScript. For example, you could write a custom processor to extract and process JavaScript from Markdown files (@eslint/markdown includes a custom processor for this).

                    
                    
                        Tip
                        This page explains how to create a custom processor for use with the flat config format. For the deprecated eslintrc format, see the deprecated documentation.

                    
                Custom Processor Specification
In order to create a custom processor, the object exported from your module has to conform to the following interface:


    const plugin = {
	meta: {
		name: "eslint-plugin-example",
		version: "1.2.3",
	},
	processors: {
		"processor-name": {
			meta: {
				name: "eslint-processor-name",
				version: "1.2.3",
			},
			// takes text of the file and filename
			preprocess(text, filename) {
				// here, you can strip out any non-JS content
				// and split into multiple strings to lint

				return [
					// return an array of code blocks to lint
					{ text: code1, filename: "0.js" },
					{ text: code2, filename: "1.js" },
				];
			},

			// takes a Message[][] and filename
			postprocess(messages, filename) {
				// `messages` argument contains two-dimensional array of Message objects
				// where each top-level array item contains array of lint messages related
				// to the text that was returned in array from preprocess() method

				// you need to return a one-dimensional array of the messages you want to keep
				return [].concat(...messages);
			},

			supportsAutofix: true, // (optional, defaults to false)
		},
	},
};

// for ESM
export default plugin;

// OR for CommonJS
module.exports = plugin;
12345678910111213141516171819202122232425262728293031323334353637383940414243
    
        Copy code to clipboard
        
    

The preprocess method takes the file contents and filename as arguments, and returns an array of code blocks to lint. The code blocks will be linted separately but still be registered to the filename.
A code block has two properties text and filename. The text property is the content of the block and the filename property is the name of the block. The name of the block can be anything, but should include the file extension, which tells ESLint how to process the current block. ESLint checks matching files entries in the project’s config to determine if the code blocks should be linted.
It’s up to the plugin to decide if it needs to return just one part of the non-JavaScript file or multiple pieces. For example in the case of processing .html files, you might want to return just one item in the array by combining all scripts. However, for .md files, you can return multiple items because each JavaScript block might be independent.
The postprocess method takes a two-dimensional array of arrays of lint messages and the filename. Each item in the input array corresponds to the part that was returned from the preprocess method. The postprocess method must adjust the locations of all errors to correspond to locations in the original, unprocessed code, and aggregate them into a single flat array and return it.
Reported problems have the following location information in each lint message:


    type LintMessage = {
	/// The 1-based line number where the message occurs.
	line?: number;

	/// The 1-based column number where the message occurs.
	column?: number;

	/// The 1-based line number of the end location.
	endLine?: number;

	/// The 1-based column number of the end location.
	endColumn?: number;

	/// If `true`, this is a fatal error.
	fatal?: boolean;

	/// Information for an autofix.
	fix: Fix;

	/// The error message.
	message: string;

	/// The ID of the rule which generated the message, or `null` if not applicable.
	ruleId: string | null;

	/// The severity of the message.
	severity: 0 | 1 | 2;

	/// Information for suggestions.
	suggestions?: Suggestion[];
};

type Fix = {
	range: [number, number];
	text: string;
};

type Suggestion = {
	desc?: string;
	messageId?: string;
	fix: Fix;
};
123456789101112131415161718192021222324252627282930313233343536373839404142
    
        Copy code to clipboard
        
    

By default, ESLint does not perform autofixes when a custom processor is used, even when the --fix flag is enabled on the command line. To allow ESLint to autofix code when using your processor, you should take the following additional steps:


Update the postprocess method to additionally transform the fix property of reported problems. All autofixable problems have a fix property, which is an object with the following schema:


    {
    range: [number, number],
    text: string
}
1234
    
        Copy code to clipboard
        
    

The range property contains two indexes in the code, referring to the start and end location of a contiguous section of text that will be replaced. The text property refers to the text that will replace the given range.
In the initial list of problems, the fix property will refer to a fix in the processed JavaScript. The postprocess method should transform the object to refer to a fix in the original, unprocessed file.


Add a supportsAutofix: true property to the processor.


You can have both rules and custom processors in a single plugin. You can also have multiple processors in one plugin. To support multiple extensions, add each one to the processors element and point them to the same object.
How meta Objects are Used
The meta object helps ESLint cache configurations that use a processor and to provide more friendly debug messages.
Plugin meta Object
The plugin meta object provides information about the plugin itself. When a processor is specified using the string format plugin-name/processor-name, ESLint automatically uses the plugin meta to generate a name for the processor. This is the most common case for processors.
Example:


    // eslint.config.js
import { defineConfig } from "eslint/config";
import example from "eslint-plugin-example";

export default defineConfig([
	{
		files: ["**/*.txt"], // apply processor to text files
		plugins: {
			example,
		},
		processor: "example/processor-name",
	},
	// ... other configs
]);
1234567891011121314
    
        Copy code to clipboard
        
    

In this example, the processor name is "example/processor-name", and that’s the value that will be used for serializing configurations.
Processor meta Object
Each processor can also specify its own meta object. This information is used when the processor object is passed directly to processor in a configuration. In that case, ESLint doesn’t know which plugin the processor belongs to. The meta.name property should match the processor name and the meta.version property should match the npm package version for your processors. The easiest way to accomplish this is by reading this information from your package.json.
Example:


    // eslint.config.js
import { defineConfig } from "eslint/config";
import example from "eslint-plugin-example";

export default defineConfig([
	{
		files: ["**/*.txt"],
		processor: example.processors["processor-name"],
	},
	// ... other configs
]);
1234567891011
    
        Copy code to clipboard
        
    

In this example, specifying example.processors["processor-name"] directly uses the processor’s own meta object, which must be defined to ensure proper handling when the processor is not referenced through the plugin name.
Why Both Meta Objects are Needed
It is recommended that both the plugin and each processor provide their respective meta objects. This ensures that features relying on meta objects, such as --print-config and --cache, work correctly regardless of how the processor is specified in the configuration.
Specifying Processor in Config Files
In order to use a processor from a plugin in a configuration file, import the plugin and include it in the plugins key, specifying a namespace. Then, use that namespace to reference the processor in the processor configuration, like this:


    // eslint.config.js
import { defineConfig } from "eslint/config";
import example from "eslint-plugin-example";

export default defineConfig([
	{
		files: ["**/*.txt"],
		plugins: {
			example,
		},
		processor: "example/processor-name",
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    

See Specify a Processor in the Plugin Configuration documentation for more details.

            

            
                Edit this page\n\n\n\nLanguages
                

                Table of Contents
    
        
                
                    
                    Language Requirements
            
                
                    
                    Parser Requirements for Languages
            		

                    The SourceCode Object
            		

                    The Language Object
            		
                
            		

                    Publish a Language in a Plugin
            		
                
            
    


                Starting with ESLint v9.7.0, you can extend ESLint with additional languages through plugins. While ESLint began as a linter strictly for JavaScript, the ESLint core is generic and can be used to lint any programming language. Each language is defined as an object that contains all of the parsing, evaluating, and traversal functionality required to lint a file. These languages are then distributed in plugins for use in user configurations.
Language Requirements
In order to create a language, you need:

A parser. The parser is the piece that converts plain text into a data structure. There is no specific format that ESLint requires the data structure to be in, so you can use any already-existing parser, or write your own.
A SourceCode object. The way ESLint works with an AST is through a SourceCode object. There are some required methods on each SourceCode, and you can also add more methods or properties that you’d like to expose to rules.
A Language object. The Language object contains information about the language itself along with methods for parsing and creating the SourceCode object.

Parser Requirements for Languages
To get started, make sure you have a parser that can be called from JavaScript. The parser must return a data structure representing the code that was parsed. Most parsers return an abstract syntax tree (AST) to represent the code, but they can also return a concrete syntax tree (CST). Whether an AST or CST is returned doesn’t matter to ESLint, it only matters that there is a data structure to traverse.
While there is no specific structure an AST or CST must follow, it’s easier to integrate with ESLint when each node in the tree contains the following information:


Type - A property on each node representing the node type is required. For example, in JavaScript, the type property contains this information for each node. ESLint rules use node types to define the visitor methods, so it’s important that each node can be identified by a string. The name of the property doesn’t matter (discussed further below) so long as one exists. This property is typically named type or kind by most parsers.


Location - A property on each node representing the location of the node in the original source code is required. The location must contain:

The line on which the node starts
The column on which the node starts
The line on which the node ends
The column on which the node ends

As with the node type, the property name doesn’t matter. Two common property names are loc (as in ESTree) and position (as in Unist). This information is used by ESLint to report errors and rule violations.


Range - A property on each node representing the location of the node’s source inside the source code is required. The range indicates the index at which the first character is found and the index after the last character, such that calling code.slice(start, end) returns the text that the node represents. Once again, no specific property name is required, and this information may even be merged with location information. ESTree uses the range property while Unist includes this information on position along with the location information. This information is used by ESLint to apply autofixes.


The SourceCode Object
ESLint holds information about source code in a SourceCode object. This object is the API used both by ESLint internally and by rules written to work on the code (via context.sourceCode). The SourceCode object must implement the TextSourceCode interface as defined in the @eslint/core package.
A basic SourceCode object must implement the following:

ast - a property containing the AST or CST for the source code.
text - the text of the source code.
getLoc(nodeOrToken) - a method that returns the location of a given node or token. This must match the loc structure that ESTree uses.
getRange(nodeOrToken) - a method that returns the range of a given node or token. This must return an array where the first item is the start index and the second is the end index.
traverse() - a method that returns an iterable for traversing the AST or CST. The iterator must return objects that implement either VisitTraversalStep or CallTraversalStep from @eslint/core.

The following optional members allow you to customize how ESLint interacts with the object:

visitorKeys - visitor keys that are specific to just this SourceCode object. Typically not necessary as Language#visitorKeys is used most of the time.
applyLanguageOptions(languageOptions) - if you have specific language options that need to be applied after parsing, you can do so in this method.
getDisableDirectives() - returns any disable directives in the code. ESLint uses this to apply disable directives and track unused directives.
getInlineConfigNodes() - returns any inline config nodes. ESLint uses this to report errors when noInlineConfig is enabled.
applyInlineConfig() - returns inline configuration elements to ESLint. ESLint uses this to alter the configuration of the file being linted.
finalize() - this method is called just before linting begins and is your last chance to modify SourceCode. If you’ve defined applyLanguageOptions() or applyInlineConfig(), then you may have additional changes to apply before the SourceCode object is ready.

Additionally, the following members are common on SourceCode objects and are recommended to implement:

lines - the individual lines of the source code as an array of strings.
getParent(node) - returns the parent of the given node or undefined if the node is the root.
getAncestors(node) - returns an array of the ancestry of the node with the first item as the root of the tree and each subsequent item as the descendants of the root that lead to node.
getText(node, beforeCount, afterCount) - returns the string that represents the given node, and optionally, a specified number of characters before and after the node’s range.

See JSONSourceCode as an example of a basic SourceCode class.

                    
                    
                        Tip
                        The @eslint/plugin-kit package contains multiple classes that aim to make creating a SourceCode object easier. The TextSourceCodeBase class, in particular, implements the TextSourceCode interface and provides some basic functionality typically found in SourceCode objects.

                    
                The Language Object
The Language object contains all of the information about the programming language as well as methods for interacting with code written in that language. ESLint uses this object to determine how to deal with a particular file. The Language object must implement the Language interface as defined in the @eslint/core package.
A basic Language object must implement the following:

fileType - should be "text" (in the future, we will also support "binary")
lineStart - either 0 or 1 to indicate how the AST represents the first line in the file. ESLint uses this to correctly display error locations.
columnStart - either 0 or 1 to indicate how the AST represents the first column in each line. ESLint uses this to correctly display error locations.
nodeTypeKey - the name of the property that indicates the node type (usually "type" or "kind").
validateLanguageOptions(languageOptions) - validates language options for the language. This method is expected to throw a validation error when an expected language option doesn’t have the correct type or value. Unexpected language options should be silently ignored and no error should be thrown. This method is required even if the language doesn’t specify any options.
parse(file, context) - parses the given file into an AST or CST, and can also include additional values meant for use in rules. Called internally by ESLint.
createSourceCode(file, parseResult, context) - creates a SourceCode object. Call internally by ESLint after parse(), and the second argument is the exact return value from parse().

The following optional members allow you to customize how ESLint interacts with the object:

visitorKeys - visitor keys that are specific to the AST or CST. This is used to optimize traversal of the AST or CST inside of ESLint. While not required, it is strongly recommended, especially for AST or CST formats that deviate significantly from ESTree format.
defaultLanguageOptions - default languageOptions when the language is used. User-specified languageOptions are merged with this object when calculating the config for the file being linted.
matchesSelectorClass(className, node, ancestry) - allows you to specify selector classes, such as :expression, that match more than one node. This method is called whenever an esquery selector contains a : followed by an identifier.
normalizeLanguageOptions(languageOptions) - takes a validated language options object and normalizes its values. This is helpful for backwards compatibility when language options properties change.

See JSONLanguage as an example of a basic Language class.
Publish a Language in a Plugin
Languages are published in plugins similar to processors and rules. Define the languages key in your plugin as an object whose names are the language names and the values are the language objects. Here’s an example:


    import { myLanguage } from "../languages/my.js";

const plugin = {
	// preferred location of name and version
	meta: {
		name: "eslint-plugin-example",
		version: "1.2.3",
	},
	languages: {
		my: myLanguage,
	},
	rules: {
		// add rules here
	},
};

// for ESM
export default plugin;

// OR for CommonJS
module.exports = plugin;
123456789101112131415161718192021
    
        Copy code to clipboard
        
    

In order to use a language from a plugin in a configuration file, import the plugin and include it in the plugins key, specifying a namespace. Then, use that namespace to reference the language in the language configuration, like this:


    // eslint.config.js
import { defineConfig } from "eslint/config";
import example from "eslint-plugin-example";

export default defineConfig([
	{
		files: ["**/*.my"],
		plugins: {
			example,
		},
		language: "example/my",
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    

See Specify a Language in the Plugin Configuration documentation for more details.

            

            
                Edit this page\n\nLanguages
                

                Table of Contents
    
        
                
                    
                    Language Requirements
            
                
                    
                    Parser Requirements for Languages
            		

                    The SourceCode Object
            		

                    The Language Object
            		
                
            		

                    Publish a Language in a Plugin
            		
                
            
    


                Starting with ESLint v9.7.0, you can extend ESLint with additional languages through plugins. While ESLint began as a linter strictly for JavaScript, the ESLint core is generic and can be used to lint any programming language. Each language is defined as an object that contains all of the parsing, evaluating, and traversal functionality required to lint a file. These languages are then distributed in plugins for use in user configurations.
Language Requirements
In order to create a language, you need:

A parser. The parser is the piece that converts plain text into a data structure. There is no specific format that ESLint requires the data structure to be in, so you can use any already-existing parser, or write your own.
A SourceCode object. The way ESLint works with an AST is through a SourceCode object. There are some required methods on each SourceCode, and you can also add more methods or properties that you’d like to expose to rules.
A Language object. The Language object contains information about the language itself along with methods for parsing and creating the SourceCode object.

Parser Requirements for Languages
To get started, make sure you have a parser that can be called from JavaScript. The parser must return a data structure representing the code that was parsed. Most parsers return an abstract syntax tree (AST) to represent the code, but they can also return a concrete syntax tree (CST). Whether an AST or CST is returned doesn’t matter to ESLint, it only matters that there is a data structure to traverse.
While there is no specific structure an AST or CST must follow, it’s easier to integrate with ESLint when each node in the tree contains the following information:


Type - A property on each node representing the node type is required. For example, in JavaScript, the type property contains this information for each node. ESLint rules use node types to define the visitor methods, so it’s important that each node can be identified by a string. The name of the property doesn’t matter (discussed further below) so long as one exists. This property is typically named type or kind by most parsers.


Location - A property on each node representing the location of the node in the original source code is required. The location must contain:

The line on which the node starts
The column on which the node starts
The line on which the node ends
The column on which the node ends

As with the node type, the property name doesn’t matter. Two common property names are loc (as in ESTree) and position (as in Unist). This information is used by ESLint to report errors and rule violations.


Range - A property on each node representing the location of the node’s source inside the source code is required. The range indicates the index at which the first character is found and the index after the last character, such that calling code.slice(start, end) returns the text that the node represents. Once again, no specific property name is required, and this information may even be merged with location information. ESTree uses the range property while Unist includes this information on position along with the location information. This information is used by ESLint to apply autofixes.


The SourceCode Object
ESLint holds information about source code in a SourceCode object. This object is the API used both by ESLint internally and by rules written to work on the code (via context.sourceCode). The SourceCode object must implement the TextSourceCode interface as defined in the @eslint/core package.
A basic SourceCode object must implement the following:

ast - a property containing the AST or CST for the source code.
text - the text of the source code.
getLoc(nodeOrToken) - a method that returns the location of a given node or token. This must match the loc structure that ESTree uses.
getRange(nodeOrToken) - a method that returns the range of a given node or token. This must return an array where the first item is the start index and the second is the end index.
traverse() - a method that returns an iterable for traversing the AST or CST. The iterator must return objects that implement either VisitTraversalStep or CallTraversalStep from @eslint/core.

The following optional members allow you to customize how ESLint interacts with the object:

visitorKeys - visitor keys that are specific to just this SourceCode object. Typically not necessary as Language#visitorKeys is used most of the time.
applyLanguageOptions(languageOptions) - if you have specific language options that need to be applied after parsing, you can do so in this method.
getDisableDirectives() - returns any disable directives in the code. ESLint uses this to apply disable directives and track unused directives.
getInlineConfigNodes() - returns any inline config nodes. ESLint uses this to report errors when noInlineConfig is enabled.
applyInlineConfig() - returns inline configuration elements to ESLint. ESLint uses this to alter the configuration of the file being linted.
finalize() - this method is called just before linting begins and is your last chance to modify SourceCode. If you’ve defined applyLanguageOptions() or applyInlineConfig(), then you may have additional changes to apply before the SourceCode object is ready.

Additionally, the following members are common on SourceCode objects and are recommended to implement:

lines - the individual lines of the source code as an array of strings.
getParent(node) - returns the parent of the given node or undefined if the node is the root.
getAncestors(node) - returns an array of the ancestry of the node with the first item as the root of the tree and each subsequent item as the descendants of the root that lead to node.
getText(node, beforeCount, afterCount) - returns the string that represents the given node, and optionally, a specified number of characters before and after the node’s range.

See JSONSourceCode as an example of a basic SourceCode class.

                    
                    
                        Tip
                        The @eslint/plugin-kit package contains multiple classes that aim to make creating a SourceCode object easier. The TextSourceCodeBase class, in particular, implements the TextSourceCode interface and provides some basic functionality typically found in SourceCode objects.

                    
                The Language Object
The Language object contains all of the information about the programming language as well as methods for interacting with code written in that language. ESLint uses this object to determine how to deal with a particular file. The Language object must implement the Language interface as defined in the @eslint/core package.
A basic Language object must implement the following:

fileType - should be "text" (in the future, we will also support "binary")
lineStart - either 0 or 1 to indicate how the AST represents the first line in the file. ESLint uses this to correctly display error locations.
columnStart - either 0 or 1 to indicate how the AST represents the first column in each line. ESLint uses this to correctly display error locations.
nodeTypeKey - the name of the property that indicates the node type (usually "type" or "kind").
validateLanguageOptions(languageOptions) - validates language options for the language. This method is expected to throw a validation error when an expected language option doesn’t have the correct type or value. Unexpected language options should be silently ignored and no error should be thrown. This method is required even if the language doesn’t specify any options.
parse(file, context) - parses the given file into an AST or CST, and can also include additional values meant for use in rules. Called internally by ESLint.
createSourceCode(file, parseResult, context) - creates a SourceCode object. Call internally by ESLint after parse(), and the second argument is the exact return value from parse().

The following optional members allow you to customize how ESLint interacts with the object:

visitorKeys - visitor keys that are specific to the AST or CST. This is used to optimize traversal of the AST or CST inside of ESLint. While not required, it is strongly recommended, especially for AST or CST formats that deviate significantly from ESTree format.
defaultLanguageOptions - default languageOptions when the language is used. User-specified languageOptions are merged with this object when calculating the config for the file being linted.
matchesSelectorClass(className, node, ancestry) - allows you to specify selector classes, such as :expression, that match more than one node. This method is called whenever an esquery selector contains a : followed by an identifier.
normalizeLanguageOptions(languageOptions) - takes a validated language options object and normalizes its values. This is helpful for backwards compatibility when language options properties change.

See JSONLanguage as an example of a basic Language class.
Publish a Language in a Plugin
Languages are published in plugins similar to processors and rules. Define the languages key in your plugin as an object whose names are the language names and the values are the language objects. Here’s an example:


    import { myLanguage } from "../languages/my.js";

const plugin = {
	// preferred location of name and version
	meta: {
		name: "eslint-plugin-example",
		version: "1.2.3",
	},
	languages: {
		my: myLanguage,
	},
	rules: {
		// add rules here
	},
};

// for ESM
export default plugin;

// OR for CommonJS
module.exports = plugin;
123456789101112131415161718192021
    
        Copy code to clipboard
        
    

In order to use a language from a plugin in a configuration file, import the plugin and include it in the plugins key, specifying a namespace. Then, use that namespace to reference the language in the language configuration, like this:


    // eslint.config.js
import { defineConfig } from "eslint/config";
import example from "eslint-plugin-example";

export default defineConfig([
	{
		files: ["**/*.my"],
		plugins: {
			example,
		},
		language: "example/my",
	},
]);
12345678910111213
    
        Copy code to clipboard
        
    

See Specify a Language in the Plugin Configuration documentation for more details.

            

            
                Edit this page\n\n\n\nPlugin Migration to Flat Config
                

                Table of Contents
    
        
                
                    
                    Recommended Plugin Structure
            		

                    Adding Plugin Meta Information
            		

                    Migrating Rules for Flat Config
            		

                    Migrating Processors for Flat Config
            		

                    Migrating Configs for Flat Config
            		

                    Migrating Environments for Flat Config
            		

                    Backwards Compatibility
            		

                    Further Reading
            		
                
            
    


                Beginning in ESLint v9.0.0, the default configuration system will be the new flat config system. In order for your plugins to work with flat config files, you’ll need to make some changes to your existing plugins.
Recommended Plugin Structure
To make it easier to work with your plugin in the flat config system, it’s recommended that you switch your existing plugin entrypoint to look like this:


    const plugin = {
	meta: {},
	configs: {},
	rules: {},
	processors: {},
};

// for ESM
export default plugin;

// OR for CommonJS
module.exports = plugin;
123456789101112
    
        Copy code to clipboard
        
    

This structure allows the most flexibility when making other changes discussed on this page.
Adding Plugin Meta Information
With the old eslintrc configuration system, ESLint could pull information about the plugin from the package name, but with flat config, ESLint no longer has access to the name of the plugin package. To replace that missing information, you should add a meta key that contains at least a name key, and ideally, a version key, such as:


    const plugin = {
	meta: {
		name: "eslint-plugin-example",
		version: "1.0.0",
	},
	configs: {},
	rules: {},
	processors: {},
};

// for ESM
export default plugin;

// OR for CommonJS
module.exports = plugin;
123456789101112131415
    
        Copy code to clipboard
        
    

If your plugin is published as an npm package, the name and version should be the same as in your package.json file; otherwise, you can assign any value you’d like.
Without this meta information, your plugin will not be usable with the --cache and --print-config command line options.
Migrating Rules for Flat Config
No changes are necessary for the rules key in your plugin. Everything works the same as with the old eslintrc configuration system.
Migrating Processors for Flat Config
Each processor should specify a meta object. For more information, see the full documentation.
No other changes are necessary for the processors key in your plugin as long as you aren’t using file extension-named processors. If you have any file extension-named processors, you must update the name to a valid identifier (numbers and letters). File extension-named processors were automatically applied in the old configuration system but are not automatically applied when using flat config. Here is an example of a file extension-named processor:


    const plugin = {
	configs: {},
	rules: {},
	processors: {
		// no longer supported
		".md": {
			preprocess() {},
			postprocess() {},
		},
	},
};

// for ESM
export default plugin;

// OR for CommonJS
module.exports = plugin;
1234567891011121314151617
    
        Copy code to clipboard
        
    

The name ".md" is no longer valid for a processor, so it must be replaced with a valid identifier such as markdown:


    const plugin = {
	configs: {},
	rules: {},
	processors: {
		// works in both old and new config systems
		markdown: {
			preprocess() {},
			postprocess() {},
		},
	},
};

// for ESM
export default plugin;

// OR for CommonJS
module.exports = plugin;
1234567891011121314151617
    
        Copy code to clipboard
        
    

In order to use this renamed processor, you’ll also need to manually specify it inside of a config, such as:


    import { defineConfig } from "eslint/config";
import example from "eslint-plugin-example";

export default defineConfig([
	{
		files: ["**/*.md"],
		plugins: {
			example,
		},
		processor: "example/markdown",
	},
]);
123456789101112
    
        Copy code to clipboard
        
    

You should update your plugin’s documentation to advise your users if you have renamed a file extension-named processor.
Migrating Configs for Flat Config
If your plugin is exporting configs that refer back to your plugin, then you’ll need to update your configs to flat config format. As part of the migration, you’ll need to reference your plugin directly in the plugins key. For example, here is an exported config in the old configuration system format for a plugin named eslint-plugin-example:


    // plugin name: eslint-plugin-example
module.exports = {
    configs: {

        // the config referenced by example/recommended
        recommended: {
            plugins: ["example"],
            rules: {
                "example/rule1": "error",
                "example/rule2": "error"
            }
        }
    },
    rules: {
        rule1: {},
        rule2: {};
    }
};
123456789101112131415161718
    
        Copy code to clipboard
        
    

To migrate to flat config format, you’ll need to move the configs to after the definition of the plugin variable in the recommended plugin structure, like this:


    const plugin = {
	configs: {},
	rules: {},
	processors: {},
};

// assign configs here so we can reference `plugin`
Object.assign(plugin.configs, {
	recommended: {
		plugins: {
			example: plugin,
		},
		rules: {
			"example/rule1": "error",
			"example/rule2": "error",
		},
	},
});

// for ESM
export default plugin;

// OR for CommonJS
module.exports = plugin;
123456789101112131415161718192021222324
    
        Copy code to clipboard
        
    

Your users can then use this exported config like this:


    import { defineConfig } from "eslint/config";
import example from "eslint-plugin-example";

export default defineConfig([
	// use recommended config and provide your own overrides
	{
		files: ["**/*.js"],
		plugins: {
			example,
		},
		extends: ["example/recommended"],
		rules: {
			"example/rule1": "warn",
		},
	},
]);
12345678910111213141516
    
        Copy code to clipboard
        
    

If your config extends other configs, you can export an array:


    const baseConfig = require("./base-config");

module.exports = {
	configs: {
		extendedConfig: [
			baseConfig,
			{
				rules: {
					"example/rule1": "error",
					"example/rule2": "error",
				},
			},
		],
	},
};
123456789101112131415
    
        Copy code to clipboard
        
    

You should update your documentation so your plugin users know how to reference the exported configs.
For more information, see the full documentation.
Migrating Environments for Flat Config
Environments are no longer supported in flat config, and so we recommend transitioning your environments into exported configs. For example, suppose you export a mocha environment like this:


    // plugin name: eslint-plugin-example
module.exports = {
    environments: {
        mocha: {
            globals: {
                it: true,
                xit: true,
                describe: true,
                xdescribe: true
            }
        }
    },
    rules: {
        rule1: {},
        rule2: {};
    }
};
1234567891011121314151617
    
        Copy code to clipboard
        
    

To migrate this environment into a config, you need to add a new key in the plugin.configs object that has a flat config object containing the same information, like this:


    const plugin = {
	configs: {},
	rules: {},
	processors: {},
};

// assign configs here so we can reference `plugin`
Object.assign(plugin.configs, {
	mocha: {
		languageOptions: {
			globals: {
				it: "writeable",
				xit: "writeable",
				describe: "writeable",
				xdescribe: "writeable",
			},
		},
	},
});

// for ESM
export default plugin;

// OR for CommonJS
module.exports = plugin;
12345678910111213141516171819202122232425
    
        Copy code to clipboard
        
    

Your users can then use this exported config like this:


    import { defineConfig } from "eslint/config";
import example from "eslint-plugin-example";

export default defineConfig([
	{
		files: ["**/tests/*.js"],
		plugins: {
			example,
		},

		// use the mocha globals
		extends: ["example/mocha"],

		// and provide your own overrides
		languageOptions: {
			globals: {
				it: "readonly",
			},
		},
	},
]);
123456789101112131415161718192021
    
        Copy code to clipboard
        
    

You should update your documentation so your plugin users know how to reference the exported configs.
Backwards Compatibility
If your plugin needs to work with both the old and new configuration systems, then you’ll need to:

Export a CommonJS entrypoint. The old configuration system cannot load plugins that are published only in ESM format. If your source code is in ESM, then you’ll need to use a bundler that can generate a CommonJS version and use the exports key in your package.json file to ensure the CommonJS version can be found by Node.js.
Keep the environments key. If your plugin exports custom environments, you should keep those as they are and also export the equivalent flat configs as described above. The environments key is ignored when ESLint is running in flat config mode.
Export both eslintrc and flat configs. The configs key is only validated when a config is used, so you can provide both formats of configs in the configs key. We recommend that you append older format configs with -legacy to make it clear that these configs will not be supported in the future. For example, if your primary config is called recommended and is in flat config format, then you can also have a config named recommended-legacy that is the eslintrc config format.

Further Reading

Overview of the flat config file format blog post
API usage of new configuration system blog post
Background to new configuration system blog post


            

            
                Edit this page\n\nPlugin Migration to Flat Config
                

                Table of Contents
    
        
                
                    
                    Recommended Plugin Structure
            		

                    Adding Plugin Meta Information
            		

                    Migrating Rules for Flat Config
            		

                    Migrating Processors for Flat Config
            		

                    Migrating Configs for Flat Config
            		

                    Migrating Environments for Flat Config
            		

                    Backwards Compatibility
            		

                    Further Reading
            		
                
            
    


                Beginning in ESLint v9.0.0, the default configuration system will be the new flat config system. In order for your plugins to work with flat config files, you’ll need to make some changes to your existing plugins.
Recommended Plugin Structure
To make it easier to work with your plugin in the flat config system, it’s recommended that you switch your existing plugin entrypoint to look like this:


    const plugin = {
	meta: {},
	configs: {},
	rules: {},
	processors: {},
};

// for ESM
export default plugin;

// OR for CommonJS
module.exports = plugin;
123456789101112
    
        Copy code to clipboard
        
    

This structure allows the most flexibility when making other changes discussed on this page.
Adding Plugin Meta Information
With the old eslintrc configuration system, ESLint could pull information about the plugin from the package name, but with flat config, ESLint no longer has access to the name of the plugin package. To replace that missing information, you should add a meta key that contains at least a name key, and ideally, a version key, such as:


    const plugin = {
	meta: {
		name: "eslint-plugin-example",
		version: "1.0.0",
	},
	configs: {},
	rules: {},
	processors: {},
};

// for ESM
export default plugin;

// OR for CommonJS
module.exports = plugin;
123456789101112131415
    
        Copy code to clipboard
        
    

If your plugin is published as an npm package, the name and version should be the same as in your package.json file; otherwise, you can assign any value you’d like.
Without this meta information, your plugin will not be usable with the --cache and --print-config command line options.
Migrating Rules for Flat Config
No changes are necessary for the rules key in your plugin. Everything works the same as with the old eslintrc configuration system.
Migrating Processors for Flat Config
Each processor should specify a meta object. For more information, see the full documentation.
No other changes are necessary for the processors key in your plugin as long as you aren’t using file extension-named processors. If you have any file extension-named processors, you must update the name to a valid identifier (numbers and letters). File extension-named processors were automatically applied in the old configuration system but are not automatically applied when using flat config. Here is an example of a file extension-named processor:


    const plugin = {
	configs: {},
	rules: {},
	processors: {
		// no longer supported
		".md": {
			preprocess() {},
			postprocess() {},
		},
	},
};

// for ESM
export default plugin;

// OR for CommonJS
module.exports = plugin;
1234567891011121314151617
    
        Copy code to clipboard
        
    

The name ".md" is no longer valid for a processor, so it must be replaced with a valid identifier such as markdown:


    const plugin = {
	configs: {},
	rules: {},
	processors: {
		// works in both old and new config systems
		markdown: {
			preprocess() {},
			postprocess() {},
		},
	},
};

// for ESM
export default plugin;

// OR for CommonJS
module.exports = plugin;
1234567891011121314151617
    
        Copy code to clipboard
        
    

In order to use this renamed processor, you’ll also need to manually specify it inside of a config, such as:


    import { defineConfig } from "eslint/config";
import example from "eslint-plugin-example";

export default defineConfig([
	{
		files: ["**/*.md"],
		plugins: {
			example,
		},
		processor: "example/markdown",
	},
]);
123456789101112
    
        Copy code to clipboard
        
    

You should update your plugin’s documentation to advise your users if you have renamed a file extension-named processor.
Migrating Configs for Flat Config
If your plugin is exporting configs that refer back to your plugin, then you’ll need to update your configs to flat config format. As part of the migration, you’ll need to reference your plugin directly in the plugins key. For example, here is an exported config in the old configuration system format for a plugin named eslint-plugin-example:


    // plugin name: eslint-plugin-example
module.exports = {
    configs: {

        // the config referenced by example/recommended
        recommended: {
            plugins: ["example"],
            rules: {
                "example/rule1": "error",
                "example/rule2": "error"
            }
        }
    },
    rules: {
        rule1: {},
        rule2: {};
    }
};
123456789101112131415161718
    
        Copy code to clipboard
        
    

To migrate to flat config format, you’ll need to move the configs to after the definition of the plugin variable in the recommended plugin structure, like this:


    const plugin = {
	configs: {},
	rules: {},
	processors: {},
};

// assign configs here so we can reference `plugin`
Object.assign(plugin.configs, {
	recommended: {
		plugins: {
			example: plugin,
		},
		rules: {
			"example/rule1": "error",
			"example/rule2": "error",
		},
	},
});

// for ESM
export default plugin;

// OR for CommonJS
module.exports = plugin;
123456789101112131415161718192021222324
    
        Copy code to clipboard
        
    

Your users can then use this exported config like this:


    import { defineConfig } from "eslint/config";
import example from "eslint-plugin-example";

export default defineConfig([
	// use recommended config and provide your own overrides
	{
		files: ["**/*.js"],
		plugins: {
			example,
		},
		extends: ["example/recommended"],
		rules: {
			"example/rule1": "warn",
		},
	},
]);
12345678910111213141516
    
        Copy code to clipboard
        
    

If your config extends other configs, you can export an array:


    const baseConfig = require("./base-config");

module.exports = {
	configs: {
		extendedConfig: [
			baseConfig,
			{
				rules: {
					"example/rule1": "error",
					"example/rule2": "error",
				},
			},
		],
	},
};
123456789101112131415
    
        Copy code to clipboard
        
    

You should update your documentation so your plugin users know how to reference the exported configs.
For more information, see the full documentation.
Migrating Environments for Flat Config
Environments are no longer supported in flat config, and so we recommend transitioning your environments into exported configs. For example, suppose you export a mocha environment like this:


    // plugin name: eslint-plugin-example
module.exports = {
    environments: {
        mocha: {
            globals: {
                it: true,
                xit: true,
                describe: true,
                xdescribe: true
            }
        }
    },
    rules: {
        rule1: {},
        rule2: {};
    }
};
1234567891011121314151617
    
        Copy code to clipboard
        
    

To migrate this environment into a config, you need to add a new key in the plugin.configs object that has a flat config object containing the same information, like this:


    const plugin = {
	configs: {},
	rules: {},
	processors: {},
};

// assign configs here so we can reference `plugin`
Object.assign(plugin.configs, {
	mocha: {
		languageOptions: {
			globals: {
				it: "writeable",
				xit: "writeable",
				describe: "writeable",
				xdescribe: "writeable",
			},
		},
	},
});

// for ESM
export default plugin;

// OR for CommonJS
module.exports = plugin;
12345678910111213141516171819202122232425
    
        Copy code to clipboard
        
    

Your users can then use this exported config like this:


    import { defineConfig } from "eslint/config";
import example from "eslint-plugin-example";

export default defineConfig([
	{
		files: ["**/tests/*.js"],
		plugins: {
			example,
		},

		// use the mocha globals
		extends: ["example/mocha"],

		// and provide your own overrides
		languageOptions: {
			globals: {
				it: "readonly",
			},
		},
	},
]);
123456789101112131415161718192021
    
        Copy code to clipboard
        
    

You should update your documentation so your plugin users know how to reference the exported configs.
Backwards Compatibility
If your plugin needs to work with both the old and new configuration systems, then you’ll need to:

Export a CommonJS entrypoint. The old configuration system cannot load plugins that are published only in ESM format. If your source code is in ESM, then you’ll need to use a bundler that can generate a CommonJS version and use the exports key in your package.json file to ensure the CommonJS version can be found by Node.js.
Keep the environments key. If your plugin exports custom environments, you should keep those as they are and also export the equivalent flat configs as described above. The environments key is ignored when ESLint is running in flat config mode.
Export both eslintrc and flat configs. The configs key is only validated when a config is used, so you can provide both formats of configs in the configs key. We recommend that you append older format configs with -legacy to make it clear that these configs will not be supported in the future. For example, if your primary config is called recommended and is in flat config format, then you can also have a config named recommended-legacy that is the eslintrc config format.

Further Reading

Overview of the flat config file format blog post
API usage of new configuration system blog post
Background to new configuration system blog post


            

            
                Edit this page\n\n\n\nShare Configurations
                

                Table of Contents
    
        
                
                    
                    Creating a Shareable Config
            		

                    Publishing a Shareable Config
            		

                    Using a Shareable Config
            
                
                    
                    Overriding Settings from Shareable Configs
            		
                
            		

                    Sharing Multiple Configs
            		

                    Further Reading
            		
                
            
    


                To share your ESLint configuration, create a shareable config. You can publish your shareable config on npm so that others can download and use it in their ESLint projects.
This page explains how to create and publish a shareable config.

                    
                    
                        Tip
                        This page explains how to create a shareable config using the flat config format. For the deprecated eslintrc format, see the deprecated documentation.

                    
                Creating a Shareable Config
Shareable configs are simply npm packages that export a configuration object or array. To start, create a Node.js module like you normally would.
While you can name the package in any way that you’d like, we recommend using one of the following conventions to make your package easier to identify:

Begin with eslint-config-, such as eslint-config-myconfig.
For an npm scoped module, name or prefix the module with @scope/eslint-config, such as @scope/eslint-config or @scope/eslint-config-myconfig.

In your module, export the shareable config from the module’s main entry point file. The default main entry point is index.js. For example:


    // index.js
export default [
	{
		languageOptions: {
			globals: {
				MyGlobal: true,
			},
		},

		rules: {
			semi: [2, "always"],
		},
	},
];
1234567891011121314
    
        Copy code to clipboard
        
    

Because the index.js file is just JavaScript, you can read these settings from a file or generate them dynamically.

                    
                    
                        Tip
                        Most of the time, you’ll want to export an array of config objects from your shareable config. However, you can also export a single config object. Make sure your documentation clearly shows an example of how to use your shareable config inside of an eslint.config.js file to avoid user confusion.

                    
                Publishing a Shareable Config
Once your shareable config is ready, you can publish it to npm to share it with others. We recommend using the eslint and eslintconfig keywords in the package.json file so others can easily find your module.
You should declare your dependency on ESLint in the package.json using the peerDependencies field. The recommended way to declare a dependency for future-proof compatibility is with the “>=” range syntax, using the lowest required ESLint version. For example:


    {
	"peerDependencies": {
		"eslint": ">= 9"
	}
}
12345
    
        Copy code to clipboard
        
    

If your shareable config depends on a plugin or a custom parser, you should specify these packages as dependencies in your package.json.
Using a Shareable Config
To use a shareable config, import the package inside of an eslint.config.js file and add it into the exported array using extends, like this:


    // eslint.config.js
import { defineConfig } from "eslint/config";
import myconfig from "eslint-config-myconfig";

export default defineConfig([
	{
		files: ["**/*.js"],
		extends: [myconfig],
	},
]);
12345678910
    
        Copy code to clipboard
        
    


                    
                    
                        Warning
                        It’s not possible to use shareable configs with the ESLint CLI --config flag.

                    
                Overriding Settings from Shareable Configs
You can override settings from the shareable config by adding them directly into your eslint.config.js file after importing the shareable config. For example:


    // eslint.config.js
import { defineConfig } from "eslint/config";
import myconfig from "eslint-config-myconfig";

export default defineConfig([
	{
		files: ["**/*.js"],
		extends: [myconfig],

		// anything from here will override myconfig
		rules: {
			"no-unused-vars": "warn",
		},
	},
]);
123456789101112131415
    
        Copy code to clipboard
        
    

Sharing Multiple Configs
Because shareable configs are just npm packages, you can export as many configs as you’d like from the same package. In addition to specifying a default config using the main entry in your package.json, you can specify additional shareable configs by adding a new file to your npm package and then referencing it from your eslint.config.js file.
As an example, you can create a file called my-special-config.js in the root of your npm package and export a config, such as:


    // my-special-config.js
export default {
	rules: {
		quotes: [2, "double"],
	},
};
123456
    
        Copy code to clipboard
        
    

Then, assuming you’re using the package name eslint-config-myconfig, you can access the additional config via:


    // eslint.config.js
import { defineConfig } from "eslint/config";
import myconfig from "eslint-config-myconfig";
import mySpecialConfig from "eslint-config-myconfig/my-special-config.js";

export default defineConfig([
	{
		files: ["**/*.js"],
		extends: [myconfig, mySpecialConfig],

		// anything from here will override myconfig
		rules: {
			"no-unused-vars": "warn",
		},
	},
]);
12345678910111213141516
    
        Copy code to clipboard
        
    


                    
                    
                        Important
                        We strongly recommend always including a default export for your package to avoid confusion.

                    
                Further Reading

npm Developer Guide


            

            
                Edit this page\n\nShare Configurations
                

                Table of Contents
    
        
                
                    
                    Creating a Shareable Config
            		

                    Publishing a Shareable Config
            		

                    Using a Shareable Config
            
                
                    
                    Overriding Settings from Shareable Configs
            		
                
            		

                    Sharing Multiple Configs
            		

                    Further Reading
            		
                
            
    


                To share your ESLint configuration, create a shareable config. You can publish your shareable config on npm so that others can download and use it in their ESLint projects.
This page explains how to create and publish a shareable config.

                    
                    
                        Tip
                        This page explains how to create a shareable config using the flat config format. For the deprecated eslintrc format, see the deprecated documentation.

                    
                Creating a Shareable Config
Shareable configs are simply npm packages that export a configuration object or array. To start, create a Node.js module like you normally would.
While you can name the package in any way that you’d like, we recommend using one of the following conventions to make your package easier to identify:

Begin with eslint-config-, such as eslint-config-myconfig.
For an npm scoped module, name or prefix the module with @scope/eslint-config, such as @scope/eslint-config or @scope/eslint-config-myconfig.

In your module, export the shareable config from the module’s main entry point file. The default main entry point is index.js. For example:


    // index.js
export default [
	{
		languageOptions: {
			globals: {
				MyGlobal: true,
			},
		},

		rules: {
			semi: [2, "always"],
		},
	},
];
1234567891011121314
    
        Copy code to clipboard
        
    

Because the index.js file is just JavaScript, you can read these settings from a file or generate them dynamically.

                    
                    
                        Tip
                        Most of the time, you’ll want to export an array of config objects from your shareable config. However, you can also export a single config object. Make sure your documentation clearly shows an example of how to use your shareable config inside of an eslint.config.js file to avoid user confusion.

                    
                Publishing a Shareable Config
Once your shareable config is ready, you can publish it to npm to share it with others. We recommend using the eslint and eslintconfig keywords in the package.json file so others can easily find your module.
You should declare your dependency on ESLint in the package.json using the peerDependencies field. The recommended way to declare a dependency for future-proof compatibility is with the “>=” range syntax, using the lowest required ESLint version. For example:


    {
	"peerDependencies": {
		"eslint": ">= 9"
	}
}
12345
    
        Copy code to clipboard
        
    

If your shareable config depends on a plugin or a custom parser, you should specify these packages as dependencies in your package.json.
Using a Shareable Config
To use a shareable config, import the package inside of an eslint.config.js file and add it into the exported array using extends, like this:


    // eslint.config.js
import { defineConfig } from "eslint/config";
import myconfig from "eslint-config-myconfig";

export default defineConfig([
	{
		files: ["**/*.js"],
		extends: [myconfig],
	},
]);
12345678910
    
        Copy code to clipboard
        
    


                    
                    
                        Warning
                        It’s not possible to use shareable configs with the ESLint CLI --config flag.

                    
                Overriding Settings from Shareable Configs
You can override settings from the shareable config by adding them directly into your eslint.config.js file after importing the shareable config. For example:


    // eslint.config.js
import { defineConfig } from "eslint/config";
import myconfig from "eslint-config-myconfig";

export default defineConfig([
	{
		files: ["**/*.js"],
		extends: [myconfig],

		// anything from here will override myconfig
		rules: {
			"no-unused-vars": "warn",
		},
	},
]);
123456789101112131415
    
        Copy code to clipboard
        
    

Sharing Multiple Configs
Because shareable configs are just npm packages, you can export as many configs as you’d like from the same package. In addition to specifying a default config using the main entry in your package.json, you can specify additional shareable configs by adding a new file to your npm package and then referencing it from your eslint.config.js file.
As an example, you can create a file called my-special-config.js in the root of your npm package and export a config, such as:


    // my-special-config.js
export default {
	rules: {
		quotes: [2, "double"],
	},
};
123456
    
        Copy code to clipboard
        
    

Then, assuming you’re using the package name eslint-config-myconfig, you can access the additional config via:


    // eslint.config.js
import { defineConfig } from "eslint/config";
import myconfig from "eslint-config-myconfig";
import mySpecialConfig from "eslint-config-myconfig/my-special-config.js";

export default defineConfig([
	{
		files: ["**/*.js"],
		extends: [myconfig, mySpecialConfig],

		// anything from here will override myconfig
		rules: {
			"no-unused-vars": "warn",
		},
	},
]);
12345678910111213141516
    
        Copy code to clipboard
        
    


                    
                    
                        Important
                        We strongly recommend always including a default export for your package to avoid confusion.

                    
                Further Reading

npm Developer Guide


            

            
                Edit this page\n\n\n\nCustom Formatters
                

                Table of Contents
    
        
                
                    
                    Creating a Custom Formatter
            
                
                    
                    The results Argument
            
                
                    
                    The result Object
            		
                
            		

                    The context Argument
            		

                    Passing Arguments to Formatters
            
                
                    
                    Using Environment Variables
            		

                    Complex Argument Passing
            		
                
            		

                    Formatting for Terminals
            		
                
            		

                    Packaging a Custom Formatter
            		

                    Examples
            
                
                    
                    Summary Formatter
            		

                    Detailed Formatter
            		
                
            		
                
            
    


                Custom formatters let you display linting results in a format that best fits your needs, whether that’s in a specific file format, a certain display style, or a format optimized for a particular tool.
ESLint also has built-in formatters that you can use.
You can include custom formatters in your project directly or create an npm package to distribute them separately.
Creating a Custom Formatter
Each formatter is a function that receives a results object and a context as arguments and returns a string. For example, the following is how the built-in JSON formatter is implemented:


    //my-awesome-formatter.js
module.exports = function (results, context) {
	return JSON.stringify(results, null, 2);
};
1234
    
        Copy code to clipboard
        
    

A formatter can also be an async function (from ESLint v8.4.0), the following shows a simple example:


    //my-awesome-formatter.js
module.exports = async function (results) {
	const formatted = await asyncTask();
	return formatted;
};
12345
    
        Copy code to clipboard
        
    

To run ESLint with this formatter, you can use the -f (or --format) command line flag. You must begin the path to a locally defined custom formatter with a period (.), such as ./my-awesome-formatter.js or ../formatters/my-awesome-formatter.js.


    eslint -f ./my-awesome-formatter.js src/
1
    
        Copy code to clipboard
        
    

The remainder of this section contains reference information on how to work with custom formatter functions.
The results Argument
The results object passed into a formatter is an array of result objects containing the linting results for individual files. Here’s an example output:


    [
	{
		filePath: "/path/to/a/file.js",
		messages: [
			{
				ruleId: "curly",
				severity: 2,
				message: "Expected { after 'if' condition.",
				line: 2,
				column: 1,
				nodeType: "IfStatement",
			},
			{
				ruleId: "no-process-exit",
				severity: 2,
				message: "Don't use process.exit(); throw an error instead.",
				line: 3,
				column: 1,
				nodeType: "CallExpression",
			},
		],
		errorCount: 2,
		warningCount: 0,
		fixableErrorCount: 0,
		fixableWarningCount: 0,
		source: "var err = doStuff();\nif (err) console.log('failed tests: ' + err);\nprocess.exit(1);\n",
	},
	{
		filePath: "/path/to/Gruntfile.js",
		messages: [],
		errorCount: 0,
		warningCount: 0,
		fixableErrorCount: 0,
		fixableWarningCount: 0,
	},
];
123456789101112131415161718192021222324252627282930313233343536
    
        Copy code to clipboard
        
    

The result Object

Each object in the results array is a result object. Each result object contains the path of the file that was linted and information about linting issues that were encountered. Here are the properties available on each result object:

filePath: The absolute path to the file that was linted.
messages: An array of message objects. See below for more info about messages.
errorCount: The number of errors for the given file.
warningCount: The number of warnings for the given file.
stats: The optional stats object that only exists when the stats option is used.
source: The source code for the given file. This property is omitted if this file has no errors/warnings or if the output property is present.
output: The source code for the given file with as many fixes applied as possible. This property is omitted if no fix is available.

The message Object
Each message object contains information about the ESLint rule that was triggered by some source code. The properties available on each message object are:

ruleId: the ID of the rule that produced the error or warning. If the error or warning was not produced by a rule (for example, if it’s a parsing error), this is null.
severity: the severity of the failure, 1 for warnings and 2 for errors.
message: the human readable description of the error.
line: the line where the issue is located.
column: the column where the issue is located.
nodeType: (Deprecated: This property will be removed in a future version of ESLint.) the type of the node in the AST or null if the issue isn’t related to a particular AST node.

The context Argument
The formatter function receives a context object as its second argument. The object has the following properties:

cwd: The current working directory. This value comes from the cwd constructor option of the ESLint class.
maxWarningsExceeded (optional): If --max-warnings was set and the number of warnings exceeded the limit, this property’s value is an object containing two properties:

maxWarnings: the value of the --max-warnings option
foundWarnings: the number of lint warnings


rulesMeta: The meta property values of rules. See the Custom Rules page for more information about rules.

For example, here’s what the object would look like if the rule no-extra-semi had been run:


    {
    cwd: "/path/to/cwd",
    maxWarningsExceeded: {
        maxWarnings: 5,
        foundWarnings: 6
    },
    rulesMeta: {
        "no-extra-semi": {
            type: "suggestion",
            docs: {
                description: "disallow unnecessary semicolons",
                recommended: true,
                url: "https://eslint.org/docs/rules/no-extra-semi"
            },
            fixable: "code",
            schema: [],
            messages: {
                unexpected: "Unnecessary semicolon."
            }
        }
    },
}
12345678910111213141516171819202122
    
        Copy code to clipboard
        
    

Note: if a linting is executed by the deprecated CLIEngine class, the context argument may be a different value because it is up to the API users. Please check whether the context argument is an expected value or not if you want to support legacy environments.
Passing Arguments to Formatters
While formatter functions do not receive arguments in addition to the results object and the context, it is possible to pass additional data into custom formatters using the methods described below.
Using Environment Variables
Custom formatters have access to environment variables and so can change their behavior based on environment variable data.
Here’s an example that uses a FORMATTER_SKIP_WARNINGS environment variable to determine whether to show warnings in the results:


    module.exports = function (results) {
	var skipWarnings = process.env.FORMATTER_SKIP_WARNINGS === "true";

	var results = results || [];
	var summary = results.reduce(
		function (seq, current) {
			current.messages.forEach(function (msg) {
				var logMessage = {
					filePath: current.filePath,
					ruleId: msg.ruleId,
					message: msg.message,
					line: msg.line,
					column: msg.column,
				};

				if (msg.severity === 1) {
					logMessage.type = "warning";
					seq.warnings.push(logMessage);
				}
				if (msg.severity === 2) {
					logMessage.type = "error";
					seq.errors.push(logMessage);
				}
			});
			return seq;
		},
		{
			errors: [],
			warnings: [],
		},
	);

	if (summary.errors.length > 0 || summary.warnings.length > 0) {
		var warnings = !skipWarnings ? summary.warnings : []; // skip the warnings in that case

		var lines = summary.errors
			.concat(warnings)
			.map(function (msg) {
				return (
					"\n" +
					msg.type +
					" " +
					msg.ruleId +
					"\n  " +
					msg.filePath +
					":" +
					msg.line +
					":" +
					msg.column
				);
			})
			.join("\n");

		return lines + "\n";
	}
};
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556
    
        Copy code to clipboard
        
    

You would run ESLint with this custom formatter and an environment variable set like this:


    FORMATTER_SKIP_WARNINGS=true eslint -f ./my-awesome-formatter.js src/
1
    
        Copy code to clipboard
        
    

The output would be:


    error space-infix-ops
  src/configs/bundler.js:6:8

error semi
  src/configs/bundler.js:6:10
12345
    
        Copy code to clipboard
        
    

Complex Argument Passing
If you find the custom formatter pattern doesn’t provide enough options for the way you’d like to format ESLint results, the best option is to use ESLint’s built-in JSON formatter and pipe the output to a second program. For example:


    eslint -f json src/ | your-program-that-reads-JSON --option
1
    
        Copy code to clipboard
        
    

In this example, the your-program-that-reads-json program can accept the raw JSON of ESLint results and process it before outputting its own format of the results. You can pass as many command line arguments to that program as are necessary to customize the output.
Formatting for Terminals
Modern terminals like iTerm2 or Guake expect a specific results format to automatically open filenames when they are clicked. Most terminals support this format for that purpose:


    file:line:column
1
    
        Copy code to clipboard
        
    

Packaging a Custom Formatter
Custom formatters can be distributed through npm packages. To do so, create an npm package with a name in the format eslint-formatter-*, where * is the name of your formatter (such as eslint-formatter-awesome). Projects should then install the package and use the custom formatter with the -f (or --format) flag like this:


    eslint -f awesome src/
1
    
        Copy code to clipboard
        
    

Because ESLint knows to look for packages beginning with eslint-formatter- when the specified formatter doesn’t begin with a period, you do not need to type eslint-formatter- when using a packaged custom formatter.
Tips for the package.json of a custom formatter:

The main entry point must be the JavaScript file implementing your custom formatter.
Add these keywords to help users find your formatter:

"eslint"
"eslint-formatter"
"eslintformatter"



See all custom formatters on npm.
Examples
Summary Formatter
A formatter that only reports on the total count of errors and warnings will look like this:


    module.exports = function (results, context) {
	// accumulate the errors and warnings
	var summary = results.reduce(
		function (seq, current) {
			seq.errors += current.errorCount;
			seq.warnings += current.warningCount;
			return seq;
		},
		{ errors: 0, warnings: 0 },
	);

	if (summary.errors > 0 || summary.warnings > 0) {
		return (
			"Errors: " +
			summary.errors +
			", Warnings: " +
			summary.warnings +
			"\n"
		);
	}

	return "";
};
1234567891011121314151617181920212223
    
        Copy code to clipboard
        
    

Run eslint with the above summary formatter:


    eslint -f ./my-awesome-formatter.js src/
1
    
        Copy code to clipboard
        
    

Will produce the following output:


    Errors: 2, Warnings: 4
1
    
        Copy code to clipboard
        
    

Detailed Formatter
A more complex report could look like this:


    module.exports = function (results, context) {
	var results = results || [];

	var summary = results.reduce(
		function (seq, current) {
			current.messages.forEach(function (msg) {
				var logMessage = {
					filePath: current.filePath,
					ruleId: msg.ruleId,
					ruleUrl: context.rulesMeta[msg.ruleId].docs.url,
					message: msg.message,
					line: msg.line,
					column: msg.column,
				};

				if (msg.severity === 1) {
					logMessage.type = "warning";
					seq.warnings.push(logMessage);
				}
				if (msg.severity === 2) {
					logMessage.type = "error";
					seq.errors.push(logMessage);
				}
			});
			return seq;
		},
		{
			errors: [],
			warnings: [],
		},
	);

	if (summary.errors.length > 0 || summary.warnings.length > 0) {
		var lines = summary.errors
			.concat(summary.warnings)
			.map(function (msg) {
				return (
					"\n" +
					msg.type +
					" " +
					msg.ruleId +
					(msg.ruleUrl ? " (" + msg.ruleUrl + ")" : "") +
					"\n  " +
					msg.filePath +
					":" +
					msg.line +
					":" +
					msg.column
				);
			})
			.join("\n");

		return lines + "\n";
	}
};
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455
    
        Copy code to clipboard
        
    

When you run ESLint with this custom formatter:


    eslint -f ./my-awesome-formatter.js src/
1
    
        Copy code to clipboard
        
    

The output is:


    error space-infix-ops (https://eslint.org/docs/rules/space-infix-ops)
  src/configs/bundler.js:6:8
error semi (https://eslint.org/docs/rules/semi)
  src/configs/bundler.js:6:10
warning no-unused-vars (https://eslint.org/docs/rules/no-unused-vars)
  src/configs/bundler.js:5:6
warning no-unused-vars (https://eslint.org/docs/rules/no-unused-vars)
  src/configs/bundler.js:6:6
warning no-shadow (https://eslint.org/docs/rules/no-shadow)
  src/configs/bundler.js:65:32
warning no-unused-vars (https://eslint.org/docs/rules/no-unused-vars)
  src/configs/clean.js:3:6
123456789101112
    
        Copy code to clipboard
        
    


            

            
                Edit this page\n\nCustom Formatters
                

                Table of Contents
    
        
                
                    
                    Creating a Custom Formatter
            
                
                    
                    The results Argument
            
                
                    
                    The result Object
            		
                
            		

                    The context Argument
            		

                    Passing Arguments to Formatters
            
                
                    
                    Using Environment Variables
            		

                    Complex Argument Passing
            		
                
            		

                    Formatting for Terminals
            		
                
            		

                    Packaging a Custom Formatter
            		

                    Examples
            
                
                    
                    Summary Formatter
            		

                    Detailed Formatter
            		
                
            		
                
            
    


                Custom formatters let you display linting results in a format that best fits your needs, whether that’s in a specific file format, a certain display style, or a format optimized for a particular tool.
ESLint also has built-in formatters that you can use.
You can include custom formatters in your project directly or create an npm package to distribute them separately.
Creating a Custom Formatter
Each formatter is a function that receives a results object and a context as arguments and returns a string. For example, the following is how the built-in JSON formatter is implemented:


    //my-awesome-formatter.js
module.exports = function (results, context) {
	return JSON.stringify(results, null, 2);
};
1234
    
        Copy code to clipboard
        
    

A formatter can also be an async function (from ESLint v8.4.0), the following shows a simple example:


    //my-awesome-formatter.js
module.exports = async function (results) {
	const formatted = await asyncTask();
	return formatted;
};
12345
    
        Copy code to clipboard
        
    

To run ESLint with this formatter, you can use the -f (or --format) command line flag. You must begin the path to a locally defined custom formatter with a period (.), such as ./my-awesome-formatter.js or ../formatters/my-awesome-formatter.js.


    eslint -f ./my-awesome-formatter.js src/
1
    
        Copy code to clipboard
        
    

The remainder of this section contains reference information on how to work with custom formatter functions.
The results Argument
The results object passed into a formatter is an array of result objects containing the linting results for individual files. Here’s an example output:


    [
	{
		filePath: "/path/to/a/file.js",
		messages: [
			{
				ruleId: "curly",
				severity: 2,
				message: "Expected { after 'if' condition.",
				line: 2,
				column: 1,
				nodeType: "IfStatement",
			},
			{
				ruleId: "no-process-exit",
				severity: 2,
				message: "Don't use process.exit(); throw an error instead.",
				line: 3,
				column: 1,
				nodeType: "CallExpression",
			},
		],
		errorCount: 2,
		warningCount: 0,
		fixableErrorCount: 0,
		fixableWarningCount: 0,
		source: "var err = doStuff();\nif (err) console.log('failed tests: ' + err);\nprocess.exit(1);\n",
	},
	{
		filePath: "/path/to/Gruntfile.js",
		messages: [],
		errorCount: 0,
		warningCount: 0,
		fixableErrorCount: 0,
		fixableWarningCount: 0,
	},
];
123456789101112131415161718192021222324252627282930313233343536
    
        Copy code to clipboard
        
    

The result Object

Each object in the results array is a result object. Each result object contains the path of the file that was linted and information about linting issues that were encountered. Here are the properties available on each result object:

filePath: The absolute path to the file that was linted.
messages: An array of message objects. See below for more info about messages.
errorCount: The number of errors for the given file.
warningCount: The number of warnings for the given file.
stats: The optional stats object that only exists when the stats option is used.
source: The source code for the given file. This property is omitted if this file has no errors/warnings or if the output property is present.
output: The source code for the given file with as many fixes applied as possible. This property is omitted if no fix is available.

The message Object
Each message object contains information about the ESLint rule that was triggered by some source code. The properties available on each message object are:

ruleId: the ID of the rule that produced the error or warning. If the error or warning was not produced by a rule (for example, if it’s a parsing error), this is null.
severity: the severity of the failure, 1 for warnings and 2 for errors.
message: the human readable description of the error.
line: the line where the issue is located.
column: the column where the issue is located.
nodeType: (Deprecated: This property will be removed in a future version of ESLint.) the type of the node in the AST or null if the issue isn’t related to a particular AST node.

The context Argument
The formatter function receives a context object as its second argument. The object has the following properties:

cwd: The current working directory. This value comes from the cwd constructor option of the ESLint class.
maxWarningsExceeded (optional): If --max-warnings was set and the number of warnings exceeded the limit, this property’s value is an object containing two properties:

maxWarnings: the value of the --max-warnings option
foundWarnings: the number of lint warnings


rulesMeta: The meta property values of rules. See the Custom Rules page for more information about rules.

For example, here’s what the object would look like if the rule no-extra-semi had been run:


    {
    cwd: "/path/to/cwd",
    maxWarningsExceeded: {
        maxWarnings: 5,
        foundWarnings: 6
    },
    rulesMeta: {
        "no-extra-semi": {
            type: "suggestion",
            docs: {
                description: "disallow unnecessary semicolons",
                recommended: true,
                url: "https://eslint.org/docs/rules/no-extra-semi"
            },
            fixable: "code",
            schema: [],
            messages: {
                unexpected: "Unnecessary semicolon."
            }
        }
    },
}
12345678910111213141516171819202122
    
        Copy code to clipboard
        
    

Note: if a linting is executed by the deprecated CLIEngine class, the context argument may be a different value because it is up to the API users. Please check whether the context argument is an expected value or not if you want to support legacy environments.
Passing Arguments to Formatters
While formatter functions do not receive arguments in addition to the results object and the context, it is possible to pass additional data into custom formatters using the methods described below.
Using Environment Variables
Custom formatters have access to environment variables and so can change their behavior based on environment variable data.
Here’s an example that uses a FORMATTER_SKIP_WARNINGS environment variable to determine whether to show warnings in the results:


    module.exports = function (results) {
	var skipWarnings = process.env.FORMATTER_SKIP_WARNINGS === "true";

	var results = results || [];
	var summary = results.reduce(
		function (seq, current) {
			current.messages.forEach(function (msg) {
				var logMessage = {
					filePath: current.filePath,
					ruleId: msg.ruleId,
					message: msg.message,
					line: msg.line,
					column: msg.column,
				};

				if (msg.severity === 1) {
					logMessage.type = "warning";
					seq.warnings.push(logMessage);
				}
				if (msg.severity === 2) {
					logMessage.type = "error";
					seq.errors.push(logMessage);
				}
			});
			return seq;
		},
		{
			errors: [],
			warnings: [],
		},
	);

	if (summary.errors.length > 0 || summary.warnings.length > 0) {
		var warnings = !skipWarnings ? summary.warnings : []; // skip the warnings in that case

		var lines = summary.errors
			.concat(warnings)
			.map(function (msg) {
				return (
					"\n" +
					msg.type +
					" " +
					msg.ruleId +
					"\n  " +
					msg.filePath +
					":" +
					msg.line +
					":" +
					msg.column
				);
			})
			.join("\n");

		return lines + "\n";
	}
};
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556
    
        Copy code to clipboard
        
    

You would run ESLint with this custom formatter and an environment variable set like this:


    FORMATTER_SKIP_WARNINGS=true eslint -f ./my-awesome-formatter.js src/
1
    
        Copy code to clipboard
        
    

The output would be:


    error space-infix-ops
  src/configs/bundler.js:6:8

error semi
  src/configs/bundler.js:6:10
12345
    
        Copy code to clipboard
        
    

Complex Argument Passing
If you find the custom formatter pattern doesn’t provide enough options for the way you’d like to format ESLint results, the best option is to use ESLint’s built-in JSON formatter and pipe the output to a second program. For example:


    eslint -f json src/ | your-program-that-reads-JSON --option
1
    
        Copy code to clipboard
        
    

In this example, the your-program-that-reads-json program can accept the raw JSON of ESLint results and process it before outputting its own format of the results. You can pass as many command line arguments to that program as are necessary to customize the output.
Formatting for Terminals
Modern terminals like iTerm2 or Guake expect a specific results format to automatically open filenames when they are clicked. Most terminals support this format for that purpose:


    file:line:column
1
    
        Copy code to clipboard
        
    

Packaging a Custom Formatter
Custom formatters can be distributed through npm packages. To do so, create an npm package with a name in the format eslint-formatter-*, where * is the name of your formatter (such as eslint-formatter-awesome). Projects should then install the package and use the custom formatter with the -f (or --format) flag like this:


    eslint -f awesome src/
1
    
        Copy code to clipboard
        
    

Because ESLint knows to look for packages beginning with eslint-formatter- when the specified formatter doesn’t begin with a period, you do not need to type eslint-formatter- when using a packaged custom formatter.
Tips for the package.json of a custom formatter:

The main entry point must be the JavaScript file implementing your custom formatter.
Add these keywords to help users find your formatter:

"eslint"
"eslint-formatter"
"eslintformatter"



See all custom formatters on npm.
Examples
Summary Formatter
A formatter that only reports on the total count of errors and warnings will look like this:


    module.exports = function (results, context) {
	// accumulate the errors and warnings
	var summary = results.reduce(
		function (seq, current) {
			seq.errors += current.errorCount;
			seq.warnings += current.warningCount;
			return seq;
		},
		{ errors: 0, warnings: 0 },
	);

	if (summary.errors > 0 || summary.warnings > 0) {
		return (
			"Errors: " +
			summary.errors +
			", Warnings: " +
			summary.warnings +
			"\n"
		);
	}

	return "";
};
1234567891011121314151617181920212223
    
        Copy code to clipboard
        
    

Run eslint with the above summary formatter:


    eslint -f ./my-awesome-formatter.js src/
1
    
        Copy code to clipboard
        
    

Will produce the following output:


    Errors: 2, Warnings: 4
1
    
        Copy code to clipboard
        
    

Detailed Formatter
A more complex report could look like this:


    module.exports = function (results, context) {
	var results = results || [];

	var summary = results.reduce(
		function (seq, current) {
			current.messages.forEach(function (msg) {
				var logMessage = {
					filePath: current.filePath,
					ruleId: msg.ruleId,
					ruleUrl: context.rulesMeta[msg.ruleId].docs.url,
					message: msg.message,
					line: msg.line,
					column: msg.column,
				};

				if (msg.severity === 1) {
					logMessage.type = "warning";
					seq.warnings.push(logMessage);
				}
				if (msg.severity === 2) {
					logMessage.type = "error";
					seq.errors.push(logMessage);
				}
			});
			return seq;
		},
		{
			errors: [],
			warnings: [],
		},
	);

	if (summary.errors.length > 0 || summary.warnings.length > 0) {
		var lines = summary.errors
			.concat(summary.warnings)
			.map(function (msg) {
				return (
					"\n" +
					msg.type +
					" " +
					msg.ruleId +
					(msg.ruleUrl ? " (" + msg.ruleUrl + ")" : "") +
					"\n  " +
					msg.filePath +
					":" +
					msg.line +
					":" +
					msg.column
				);
			})
			.join("\n");

		return lines + "\n";
	}
};
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455
    
        Copy code to clipboard
        
    

When you run ESLint with this custom formatter:


    eslint -f ./my-awesome-formatter.js src/
1
    
        Copy code to clipboard
        
    

The output is:


    error space-infix-ops (https://eslint.org/docs/rules/space-infix-ops)
  src/configs/bundler.js:6:8
error semi (https://eslint.org/docs/rules/semi)
  src/configs/bundler.js:6:10
warning no-unused-vars (https://eslint.org/docs/rules/no-unused-vars)
  src/configs/bundler.js:5:6
warning no-unused-vars (https://eslint.org/docs/rules/no-unused-vars)
  src/configs/bundler.js:6:6
warning no-shadow (https://eslint.org/docs/rules/no-shadow)
  src/configs/bundler.js:65:32
warning no-unused-vars (https://eslint.org/docs/rules/no-unused-vars)
  src/configs/clean.js:3:6
123456789101112
    
        Copy code to clipboard
        
    


            

            
                Edit this page\n\n\n\nCustom Parsers
                

                Table of Contents
    
        
                
                    
                    Creating a Custom Parser
            
                
                    
                    Methods in Custom Parsers
            		

                    parse Return Object
            		

                    parseForESLint Return Object
            		

                    Meta Data in Custom Parsers
            		
                
            		

                    AST Specification
            
                
                    
                    All Nodes
            		

                    The Program Node
            		

                    The Literal Node
            		
                
            		

                    Packaging a Custom Parser
            		

                    Example
            		
                
            
    


                ESLint custom parsers let you extend ESLint to support linting new non-standard JavaScript language features or custom syntax in your code. A parser is responsible for taking your code and transforming it into an abstract syntax tree (AST) that ESLint can then analyze and lint.
Creating a Custom Parser
Methods in Custom Parsers
A custom parser is a JavaScript object with either a parse() or parseForESLint() method. The parse method only returns the AST, whereas parseForESLint() also returns additional values that let the parser customize the behavior of ESLint even more.
Both methods should be instance (own) properties and take in the source code as the first argument, and an optional configuration object as the second argument, which is provided as parserOptions in a configuration file.


    // customParser.js

const espree = require("espree");

// Logs the duration it takes to parse each file.
function parse(code, options) {
	const label = `Parsing file "${options.filePath}"`;
	console.time(label);
	const ast = espree.parse(code, options);
	console.timeEnd(label);
	return ast; // Only the AST is returned.
}

module.exports = { parse };
1234567891011121314
    
        Copy code to clipboard
        
    

parse Return Object
The parse method should simply return the AST object.
parseForESLint Return Object
The parseForESLint method should return an object that contains the required property ast and optional properties services, scopeManager, and visitorKeys.

ast should contain the AST object.
services can contain any parser-dependent services (such as type checkers for nodes). The value of the services property is available to rules as context.sourceCode.parserServices. Default is an empty object.
scopeManager can be a ScopeManager object. Custom parsers can use customized scope analysis for experimental/enhancement syntaxes. The default is the ScopeManager object which is created by eslint-scope.

Support for scopeManager was added in ESLint v4.14.0. ESLint versions that support scopeManager will provide an eslintScopeManager: true property in parserOptions, which can be used for feature detection.


visitorKeys can be an object to customize AST traversal. The keys of the object are the type of AST nodes. Each value is an array of the property names which should be traversed. The default is KEYS of eslint-visitor-keys.

Support for visitorKeys was added in ESLint v4.14.0. ESLint versions that support visitorKeys will provide an eslintVisitorKeys: true property in parserOptions, which can be used for feature detection.



Meta Data in Custom Parsers
For easier debugging and more effective caching of custom parsers, it’s recommended to provide a name and version in a meta object at the root of your custom parsers, like this:


    // preferred location of name and version
module.exports = {
	meta: {
		name: "eslint-parser-custom",
		version: "1.2.3",
	},
};
1234567
    
        Copy code to clipboard
        
    

The meta.name property should match the npm package name for your custom parser and the meta.version property should match the npm package version for your custom parser. The easiest way to accomplish this is by reading this information from your package.json.
AST Specification
The AST that custom parsers should create is based on ESTree. The AST requires some additional properties about detail information of the source code.
All Nodes
All nodes must have range property.

range (number[]) is an array of two numbers. Both numbers are a 0-based index which is the position in the array of source code characters. The first is the start position of the node, the second is the end position of the node. code.slice(node.range[0], node.range[1]) must be the text of the node. This range does not include spaces/parentheses which are around the node.
loc (SourceLocation) must not be null. The loc property is defined as nullable by ESTree, but ESLint requires this property. The SourceLocation#source property can be undefined. ESLint does not use the SourceLocation#source property.

The parent property of all nodes must be rewritable. Before any rules have access to the AST, ESLint sets each node’s parent property to its parent node while traversing.
The Program Node
The Program node must have tokens and comments properties. Both properties are an array of the below Token interface.


    interface Token {
	type: string;
	loc: SourceLocation;
	// See the "All Nodes" section for details of the `range` property.
	range: [number, number];
	value: string;
}
1234567
    
        Copy code to clipboard
        
    


tokens (Token[]) is the array of tokens which affect the behavior of programs. Arbitrary spaces can exist between tokens, so rules check the Token#range to detect spaces between tokens. This must be sorted by Token#range[0].
comments (Token[]) is the array of comment tokens. This must be sorted by Token#range[0].

The range indexes of all tokens and comments must not overlap with the range of other tokens and comments.
The Literal Node
The Literal node must have raw property.

raw (string) is the source code of this literal. This is the same as code.slice(node.range[0], node.range[1]).

Packaging a Custom Parser
To publish your custom parser to npm, perform the following:

Create a custom parser following the Creating a Custom Parser section above.
Create an npm package for the custom parser.
In your package.json file, set the main field as the file that exports your custom parser.
Publish the npm package.

For more information on publishing an npm package, refer to the npm documentation.
Once you’ve published the npm package, you can use it by adding the package to your project. For example:

   
      npm
      yarn
      pnpm
      bun
   
    
        npm


    npm install --save-dev eslint-parser-myparser
1
    
        Copy code to clipboard
        
    


   
      yarn


    yarn add --dev eslint-parser-myparser
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm add --save-dev eslint-parser-myparser
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bun add --dev eslint-parser-myparser
1
    
        Copy code to clipboard
        
    

   

Then add the custom parser to your ESLint configuration file with the languageOptions.parser property. For example:


    // eslint.config.js

const myparser = require("eslint-parser-myparser");

module.exports = [
	{
		languageOptions: {
			parser: myparser,
		},
		// ... rest of configuration
	},
];
123456789101112
    
        Copy code to clipboard
        
    

When using legacy configuration, specify the parser property as a string:


    // .eslintrc.js

module.exports = {
	parser: "eslint-parser-myparser",
	// ... rest of configuration
};
123456
    
        Copy code to clipboard
        
    

To learn more about using ESLint parsers in your project, refer to Configure a Parser.
Example
For a complex example of a custom parser, refer to the @typescript-eslint/parser source code.
A simple custom parser that provides a context.sourceCode.parserServices.foo() method to rules.


    // awesome-custom-parser.js
var espree = require("espree");
function parseForESLint(code, options) {
	return {
		ast: espree.parse(code, options),
		services: {
			foo: function () {
				console.log("foo");
			},
		},
		scopeManager: null,
		visitorKeys: null,
	};
}

module.exports = { parseForESLint };
12345678910111213141516
    
        Copy code to clipboard
        
    

Include the custom parser in an ESLint configuration file:


    // eslint.config.js
module.exports = [
	{
		languageOptions: {
			parser: require("./path/to/awesome-custom-parser"),
		},
	},
];
12345678
    
        Copy code to clipboard
        
    

Or if using legacy configuration:


    // .eslintrc.json
{
    "parser": "./path/to/awesome-custom-parser.js"
}
1234
    
        Copy code to clipboard
        
    


            

            
                Edit this page\n\nCustom Parsers
                

                Table of Contents
    
        
                
                    
                    Creating a Custom Parser
            
                
                    
                    Methods in Custom Parsers
            		

                    parse Return Object
            		

                    parseForESLint Return Object
            		

                    Meta Data in Custom Parsers
            		
                
            		

                    AST Specification
            
                
                    
                    All Nodes
            		

                    The Program Node
            		

                    The Literal Node
            		
                
            		

                    Packaging a Custom Parser
            		

                    Example
            		
                
            
    


                ESLint custom parsers let you extend ESLint to support linting new non-standard JavaScript language features or custom syntax in your code. A parser is responsible for taking your code and transforming it into an abstract syntax tree (AST) that ESLint can then analyze and lint.
Creating a Custom Parser
Methods in Custom Parsers
A custom parser is a JavaScript object with either a parse() or parseForESLint() method. The parse method only returns the AST, whereas parseForESLint() also returns additional values that let the parser customize the behavior of ESLint even more.
Both methods should be instance (own) properties and take in the source code as the first argument, and an optional configuration object as the second argument, which is provided as parserOptions in a configuration file.


    // customParser.js

const espree = require("espree");

// Logs the duration it takes to parse each file.
function parse(code, options) {
	const label = `Parsing file "${options.filePath}"`;
	console.time(label);
	const ast = espree.parse(code, options);
	console.timeEnd(label);
	return ast; // Only the AST is returned.
}

module.exports = { parse };
1234567891011121314
    
        Copy code to clipboard
        
    

parse Return Object
The parse method should simply return the AST object.
parseForESLint Return Object
The parseForESLint method should return an object that contains the required property ast and optional properties services, scopeManager, and visitorKeys.

ast should contain the AST object.
services can contain any parser-dependent services (such as type checkers for nodes). The value of the services property is available to rules as context.sourceCode.parserServices. Default is an empty object.
scopeManager can be a ScopeManager object. Custom parsers can use customized scope analysis for experimental/enhancement syntaxes. The default is the ScopeManager object which is created by eslint-scope.

Support for scopeManager was added in ESLint v4.14.0. ESLint versions that support scopeManager will provide an eslintScopeManager: true property in parserOptions, which can be used for feature detection.


visitorKeys can be an object to customize AST traversal. The keys of the object are the type of AST nodes. Each value is an array of the property names which should be traversed. The default is KEYS of eslint-visitor-keys.

Support for visitorKeys was added in ESLint v4.14.0. ESLint versions that support visitorKeys will provide an eslintVisitorKeys: true property in parserOptions, which can be used for feature detection.



Meta Data in Custom Parsers
For easier debugging and more effective caching of custom parsers, it’s recommended to provide a name and version in a meta object at the root of your custom parsers, like this:


    // preferred location of name and version
module.exports = {
	meta: {
		name: "eslint-parser-custom",
		version: "1.2.3",
	},
};
1234567
    
        Copy code to clipboard
        
    

The meta.name property should match the npm package name for your custom parser and the meta.version property should match the npm package version for your custom parser. The easiest way to accomplish this is by reading this information from your package.json.
AST Specification
The AST that custom parsers should create is based on ESTree. The AST requires some additional properties about detail information of the source code.
All Nodes
All nodes must have range property.

range (number[]) is an array of two numbers. Both numbers are a 0-based index which is the position in the array of source code characters. The first is the start position of the node, the second is the end position of the node. code.slice(node.range[0], node.range[1]) must be the text of the node. This range does not include spaces/parentheses which are around the node.
loc (SourceLocation) must not be null. The loc property is defined as nullable by ESTree, but ESLint requires this property. The SourceLocation#source property can be undefined. ESLint does not use the SourceLocation#source property.

The parent property of all nodes must be rewritable. Before any rules have access to the AST, ESLint sets each node’s parent property to its parent node while traversing.
The Program Node
The Program node must have tokens and comments properties. Both properties are an array of the below Token interface.


    interface Token {
	type: string;
	loc: SourceLocation;
	// See the "All Nodes" section for details of the `range` property.
	range: [number, number];
	value: string;
}
1234567
    
        Copy code to clipboard
        
    


tokens (Token[]) is the array of tokens which affect the behavior of programs. Arbitrary spaces can exist between tokens, so rules check the Token#range to detect spaces between tokens. This must be sorted by Token#range[0].
comments (Token[]) is the array of comment tokens. This must be sorted by Token#range[0].

The range indexes of all tokens and comments must not overlap with the range of other tokens and comments.
The Literal Node
The Literal node must have raw property.

raw (string) is the source code of this literal. This is the same as code.slice(node.range[0], node.range[1]).

Packaging a Custom Parser
To publish your custom parser to npm, perform the following:

Create a custom parser following the Creating a Custom Parser section above.
Create an npm package for the custom parser.
In your package.json file, set the main field as the file that exports your custom parser.
Publish the npm package.

For more information on publishing an npm package, refer to the npm documentation.
Once you’ve published the npm package, you can use it by adding the package to your project. For example:

   
      npm
      yarn
      pnpm
      bun
   
    
        npm


    npm install --save-dev eslint-parser-myparser
1
    
        Copy code to clipboard
        
    


   
      yarn


    yarn add --dev eslint-parser-myparser
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm add --save-dev eslint-parser-myparser
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bun add --dev eslint-parser-myparser
1
    
        Copy code to clipboard
        
    

   

Then add the custom parser to your ESLint configuration file with the languageOptions.parser property. For example:


    // eslint.config.js

const myparser = require("eslint-parser-myparser");

module.exports = [
	{
		languageOptions: {
			parser: myparser,
		},
		// ... rest of configuration
	},
];
123456789101112
    
        Copy code to clipboard
        
    

When using legacy configuration, specify the parser property as a string:


    // .eslintrc.js

module.exports = {
	parser: "eslint-parser-myparser",
	// ... rest of configuration
};
123456
    
        Copy code to clipboard
        
    

To learn more about using ESLint parsers in your project, refer to Configure a Parser.
Example
For a complex example of a custom parser, refer to the @typescript-eslint/parser source code.
A simple custom parser that provides a context.sourceCode.parserServices.foo() method to rules.


    // awesome-custom-parser.js
var espree = require("espree");
function parseForESLint(code, options) {
	return {
		ast: espree.parse(code, options),
		services: {
			foo: function () {
				console.log("foo");
			},
		},
		scopeManager: null,
		visitorKeys: null,
	};
}

module.exports = { parseForESLint };
12345678910111213141516
    
        Copy code to clipboard
        
    

Include the custom parser in an ESLint configuration file:


    // eslint.config.js
module.exports = [
	{
		languageOptions: {
			parser: require("./path/to/awesome-custom-parser"),
		},
	},
];
12345678
    
        Copy code to clipboard
        
    

Or if using legacy configuration:


    // .eslintrc.json
{
    "parser": "./path/to/awesome-custom-parser.js"
}
1234
    
        Copy code to clipboard
        
    


            

            
                Edit this page\n\n\n\nStats Data
                

                Table of Contents
    
        
                
                    
                    Enable stats collection
            		

                    ◆ Stats type
            
                
                    
                    CLI usage
            		

                    API Usage
            		
                
            		
                
            
    


                While an analysis of the overall rule performance for an ESLint run can be carried out by setting the TIMING environment variable, it can sometimes be useful to acquire more granular timing data (lint time per file per rule) or collect other measures of interest. In particular, when developing new custom plugins and evaluating/benchmarking new languages or rule sets. For these use cases, you can optionally collect runtime statistics from ESLint.
Enable stats collection
To enable collection of statistics, you can either:

Use the --stats CLI option. This will pass the stats data into the formatter used to output results from ESLint. (Note: not all formatters output stats data.)
Set stats: true as an option on the ESLint constructor.

Enabling stats data adds a new stats key to each LintResult object containing data such as parse times, fix times, lint times per rule.
As such, it is not available via stdout but made easily ingestible via a formatter using the CLI or via the Node.js API to cater to your specific needs.
◆ Stats type
The Stats value is the timing information of each lint run. The stats property of the LintResult type contains it. It has the following properties:

fixPasses (number)
The number of times ESLint has applied at least one fix after linting.
times ({ passes: TimePass[] })
The times spent on (parsing, fixing, linting) a file, where the linting refers to the timing information for each rule.

TimePass ({ parse: ParseTime, rules?: Record<string, RuleTime>, fix: FixTime, total: number })
An object containing the times spent on (parsing, fixing, linting)

ParseTime ({ total: number })
The total time that is spent when parsing a file.
RuleTime ({ total: number })
The total time that is spent on a rule.
FixTime ({ total: number })
The total time that is spent on applying fixes to the code.





CLI usage
Let’s consider the following example:


    /*eslint no-regex-spaces: "error", wrap-regex: "error"*/

function a() {
	return / foo/.test("bar");
}
12345
    
        Copy code to clipboard
        
    

Run ESLint with --stats and output to JSON via the built-in json formatter:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint file-to-fix.js --fix --stats -f json 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint file-to-fix.js --fix --stats -f json 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint file-to-fix.js --fix --stats -f json 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint file-to-fix.js --fix --stats -f json 
1
    
        Copy code to clipboard
        
    

   

This yields the following stats entry as part of the formatted lint results object:


    {
	"times": {
		"passes": [
			{
				"parse": {
					"total": 3.975959
				},
				"rules": {
					"no-regex-spaces": {
						"total": 0.160792
					},
					"wrap-regex": {
						"total": 0.422626
					}
				},
				"fix": {
					"total": 0.080208
				},
				"total": 12.765959
			},
			{
				"parse": {
					"total": 0.623542
				},
				"rules": {
					"no-regex-spaces": {
						"total": 0.043084
					},
					"wrap-regex": {
						"total": 0.007959
					}
				},
				"fix": {
					"total": 0
				},
				"total": 1.148875
			}
		]
	},
	"fixPasses": 1
}
1234567891011121314151617181920212223242526272829303132333435363738394041
    
        Copy code to clipboard
        
    

Note, that for the simple example above, the sum of all rule times should be directly comparable to the first column of the TIMING output. Running the same command with TIMING=all, you can verify this:


    $ TIMING=all npx eslint file-to-fix.js --fix --stats -f json
...
Rule            | Time (ms) | Relative
:---------------|----------:|--------:
wrap-regex      |     0.431 |    67.9%
no-regex-spaces |     0.204 |    32.1%
123456
    
        Copy code to clipboard
        
    

API Usage
You can achieve the same thing using the Node.js API by passingstats: true as an option to the ESLint constructor. For example:


    const { ESLint } = require("eslint");

(async function main() {
	// 1. Create an instance.
	const eslint = new ESLint({ stats: true, fix: true });

	// 2. Lint files.
	const results = await eslint.lintFiles(["file-to-fix.js"]);

	// 3. Format the results.
	const formatter = await eslint.loadFormatter("json");
	const resultText = formatter.format(results);

	// 4. Output it.
	console.log(resultText);
})().catch(error => {
	process.exitCode = 1;
	console.error(error);
});
12345678910111213141516171819
    
        Copy code to clipboard
        
    


            

            
                Edit this page\n\nStats Data
                

                Table of Contents
    
        
                
                    
                    Enable stats collection
            		

                    ◆ Stats type
            
                
                    
                    CLI usage
            		

                    API Usage
            		
                
            		
                
            
    


                While an analysis of the overall rule performance for an ESLint run can be carried out by setting the TIMING environment variable, it can sometimes be useful to acquire more granular timing data (lint time per file per rule) or collect other measures of interest. In particular, when developing new custom plugins and evaluating/benchmarking new languages or rule sets. For these use cases, you can optionally collect runtime statistics from ESLint.
Enable stats collection
To enable collection of statistics, you can either:

Use the --stats CLI option. This will pass the stats data into the formatter used to output results from ESLint. (Note: not all formatters output stats data.)
Set stats: true as an option on the ESLint constructor.

Enabling stats data adds a new stats key to each LintResult object containing data such as parse times, fix times, lint times per rule.
As such, it is not available via stdout but made easily ingestible via a formatter using the CLI or via the Node.js API to cater to your specific needs.
◆ Stats type
The Stats value is the timing information of each lint run. The stats property of the LintResult type contains it. It has the following properties:

fixPasses (number)
The number of times ESLint has applied at least one fix after linting.
times ({ passes: TimePass[] })
The times spent on (parsing, fixing, linting) a file, where the linting refers to the timing information for each rule.

TimePass ({ parse: ParseTime, rules?: Record<string, RuleTime>, fix: FixTime, total: number })
An object containing the times spent on (parsing, fixing, linting)

ParseTime ({ total: number })
The total time that is spent when parsing a file.
RuleTime ({ total: number })
The total time that is spent on a rule.
FixTime ({ total: number })
The total time that is spent on applying fixes to the code.





CLI usage
Let’s consider the following example:


    /*eslint no-regex-spaces: "error", wrap-regex: "error"*/

function a() {
	return / foo/.test("bar");
}
12345
    
        Copy code to clipboard
        
    

Run ESLint with --stats and output to JSON via the built-in json formatter:

   
      npm
      yarn
      pnpm
      bun
   
   
      npm


    npx eslint file-to-fix.js --fix --stats -f json 
1
    
        Copy code to clipboard
        
    

   
   
      yarn


    yarn dlx eslint file-to-fix.js --fix --stats -f json 
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm dlx eslint file-to-fix.js --fix --stats -f json 
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bunx eslint file-to-fix.js --fix --stats -f json 
1
    
        Copy code to clipboard
        
    

   

This yields the following stats entry as part of the formatted lint results object:


    {
	"times": {
		"passes": [
			{
				"parse": {
					"total": 3.975959
				},
				"rules": {
					"no-regex-spaces": {
						"total": 0.160792
					},
					"wrap-regex": {
						"total": 0.422626
					}
				},
				"fix": {
					"total": 0.080208
				},
				"total": 12.765959
			},
			{
				"parse": {
					"total": 0.623542
				},
				"rules": {
					"no-regex-spaces": {
						"total": 0.043084
					},
					"wrap-regex": {
						"total": 0.007959
					}
				},
				"fix": {
					"total": 0
				},
				"total": 1.148875
			}
		]
	},
	"fixPasses": 1
}
1234567891011121314151617181920212223242526272829303132333435363738394041
    
        Copy code to clipboard
        
    

Note, that for the simple example above, the sum of all rule times should be directly comparable to the first column of the TIMING output. Running the same command with TIMING=all, you can verify this:


    $ TIMING=all npx eslint file-to-fix.js --fix --stats -f json
...
Rule            | Time (ms) | Relative
:---------------|----------:|--------:
wrap-regex      |     0.431 |    67.9%
no-regex-spaces |     0.204 |    32.1%
123456
    
        Copy code to clipboard
        
    

API Usage
You can achieve the same thing using the Node.js API by passingstats: true as an option to the ESLint constructor. For example:


    const { ESLint } = require("eslint");

(async function main() {
	// 1. Create an instance.
	const eslint = new ESLint({ stats: true, fix: true });

	// 2. Lint files.
	const results = await eslint.lintFiles(["file-to-fix.js"]);

	// 3. Format the results.
	const formatter = await eslint.loadFormatter("json");
	const resultText = formatter.format(results);

	// 4. Output it.
	console.log(resultText);
})().catch(error => {
	process.exitCode = 1;
	console.error(error);
});
12345678910111213141516171819
    
        Copy code to clipboard
        
    


            

            
                Edit this page\n\n\n\nIntegrate ESLint
                

                Table of Contents
    
        
                
                    
                    Integrate with the Node.js API Tutorial
            		

                    Node.js API Reference
            		
                
            
    


                This guide is intended for those who wish to integrate the functionality of ESLint into other applications by using the ESLint API.
In order to integrate ESLint, it’s recommended that:

You know JavaScript since ESLint is written in JavaScript.
You have some familiarity with Node.js since ESLint runs on it.

If that sounds like you, then continue reading to get started.
Integrate with the Node.js API Tutorial
This tutorial walks you through the process of creating a basic integration with ESLint using the Node.js API.
Node.js API Reference
If you’re interested in writing a tool that uses ESLint, then you can use the Node.js API to get programmatic access to functionality.

            

            
                Edit this page\n\nIntegrate ESLint
                

                Table of Contents
    
        
                
                    
                    Integrate with the Node.js API Tutorial
            		

                    Node.js API Reference
            		
                
            
    


                This guide is intended for those who wish to integrate the functionality of ESLint into other applications by using the ESLint API.
In order to integrate ESLint, it’s recommended that:

You know JavaScript since ESLint is written in JavaScript.
You have some familiarity with Node.js since ESLint runs on it.

If that sounds like you, then continue reading to get started.
Integrate with the Node.js API Tutorial
This tutorial walks you through the process of creating a basic integration with ESLint using the Node.js API.
Node.js API Reference
If you’re interested in writing a tool that uses ESLint, then you can use the Node.js API to get programmatic access to functionality.

            

            
                Edit this page\n\n\n\nIntegrate with the Node.js API Tutorial
                

                Table of Contents
    
        
                
                    
                    Why Create an Integration?
            		

                    What You’ll Build
            		

                    Requirements
            		

                    Step 1: Setup
            		

                    Step 2: Import and Configure the ESLint Instance
            		

                    Step 3: Lint and Fix Files
            		

                    Step 4: Output Results
            		

                    Step 5: Put It All Together
            		

                    Conclusion
            		

                    View the Tutorial Code
            		
                
            
    


                This guide walks you through integrating the ESLint class to lint files and
retrieve results, which can be useful for creating integrations with other
projects.
Why Create an Integration?
You might want to create an ESLint integration if you’re creating developer
tooling, such as the following:


Code editors and IDEs: Integrating ESLint with code editors and IDEs can
provide real-time feedback on code quality and automatically highlight
potential issues as you type. Many editors already have ESLint plugins
available, but you may need to create a custom integration if the existing
plugins do not meet your specific requirements.


Custom linter tools: If you’re building a custom linter tool that combines
multiple linters or adds specific functionality, you may want to integrate
ESLint into your tool to provide JavaScript linting capabilities.


Code review tools: Integrating ESLint with code review tools can help
automate the process of identifying potential issues in the codebase.


Learning platforms: If you are developing a learning platform or coding
tutorial, integrating ESLint can provide real-time feedback to users as they
learn JavaScript, helping them improve their coding skills and learn best
practices.


Developer tool integration: If you’re creating or extending a developer
tool, such as a bundler or testing framework, you may want to integrate ESLint
to provide linting capabilities. You can integrate ESLint directly into the
tool or as a plugin.


What You’ll Build
In this guide, you’ll create a simple Node.js project that uses the ESLint
class to lint files and retrieve results.
Requirements
This tutorial assumes you are familiar with JavaScript and Node.js.
To follow this tutorial, you’ll need to have the following:

Node.js (^18.18.0, ^20.9.0, or >=21.1.0)
npm
A text editor

Step 1: Setup
First, create a new project directory:


    mkdir eslint-integration
cd eslint-integration
12
    
        Copy code to clipboard
        
    

Initialize the project with a package.json file:

   
      npm
      yarn
      pnpm
      bun
   
    
        npm


    npm init -y
1
    
        Copy code to clipboard
        
    


   
      yarn


    yarn init -y
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm init -y
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bun init -y
1
    
        Copy code to clipboard
        
    

   

Install the eslint package as a dependency (not as a dev dependency):

   
      npm
      yarn
      pnpm
      bun
   
    
        npm


    npm install eslint
1
    
        Copy code to clipboard
        
    


   
      yarn


    yarn add eslint
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm add eslint
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bun add eslint
1
    
        Copy code to clipboard
        
    

   

Create a new file called example-eslint-integration.js in the project root:


    touch example-eslint-integration.js
1
    
        Copy code to clipboard
        
    

Step 2: Import and Configure the ESLint Instance
Import the ESLint class from the eslint package and create a new instance.
You can customize the ESLint configuration by passing an options object to the
ESLint constructor:


    // example-eslint-integration.js

const { ESLint } = require("eslint");

// Create an instance of ESLint with the configuration passed to the function
function createESLintInstance(overrideConfig) {
	return new ESLint({
		overrideConfigFile: true,
		overrideConfig,
		fix: true,
	});
}
123456789101112
    
        Copy code to clipboard
        
    

Step 3: Lint and Fix Files
To lint a file, use the lintFiles method of the ESLint instance. The
filePaths argument passed to ESLint#lintFiles() can be a string or an array
of strings, representing the file path(s) you want to lint. The file paths can
be globs or filenames.
The static method ESLint.outputFixes() takes the linting results from the call
to ESLint#lintFiles(), and then writes the fixed code back to the source
files.


    // example-eslint-integration.js

// ... previous step's code to instantiate the ESLint instance

// Lint the specified files and return the results
async function lintAndFix(eslint, filePaths) {
	const results = await eslint.lintFiles(filePaths);

	// Apply automatic fixes and output fixed code
	await ESLint.outputFixes(results);

	return results;
}
12345678910111213
    
        Copy code to clipboard
        
    

Step 4: Output Results
Define a function to output the linting results to the console. This should be
specific to your integration’s needs. For example, you could report the linting
results to a user interface.
In this example, we’ll simply log the results to the console:


    // example-eslint-integration.js

// ... previous step's code to instantiate the ESLint instance
// and get linting results.

// Log results to console if there are any problems
function outputLintingResults(results) {
	// Identify the number of problems found
	const problems = results.reduce(
		(acc, result) => acc + result.errorCount + result.warningCount,
		0,
	);

	if (problems > 0) {
		console.log("Linting errors found!");
		console.log(results);
	} else {
		console.log("No linting errors found.");
	}
	return results;
}
123456789101112131415161718192021
    
        Copy code to clipboard
        
    

Step 5: Put It All Together
Put the above functions together in a new function called lintFiles. This
function will be the main entry point for your integration:


    // example-eslint-integration.js

// Put previous functions all together
async function lintFiles(filePaths) {
	// The ESLint configuration. Alternatively, you could load the configuration
	// from a .eslintrc file or just use the default config.
	const overrideConfig = {
		languageOptions: {
			ecmaVersion: 2018,
			sourceType: "commonjs",
		},
		rules: {
			"no-console": "error",
			"no-unused-vars": "warn",
		},
	};

	const eslint = createESLintInstance(overrideConfig);
	const results = await lintAndFix(eslint, filePaths);
	return outputLintingResults(results);
}

// Export integration
module.exports = { lintFiles };
123456789101112131415161718192021222324
    
        Copy code to clipboard
        
    

Here’s the complete code example for example-eslint-integration.js:


    const { ESLint } = require("eslint");

// Create an instance of ESLint with the configuration passed to the function
function createESLintInstance(overrideConfig) {
	return new ESLint({
		overrideConfigFile: true,
		overrideConfig,
		fix: true,
	});
}

// Lint the specified files and return the results
async function lintAndFix(eslint, filePaths) {
	const results = await eslint.lintFiles(filePaths);

	// Apply automatic fixes and output fixed code
	await ESLint.outputFixes(results);

	return results;
}

// Log results to console if there are any problems
function outputLintingResults(results) {
	// Identify the number of problems found
	const problems = results.reduce(
		(acc, result) => acc + result.errorCount + result.warningCount,
		0,
	);

	if (problems > 0) {
		console.log("Linting errors found!");
		console.log(results);
	} else {
		console.log("No linting errors found.");
	}
	return results;
}

// Put previous functions all together
async function lintFiles(filePaths) {
	// The ESLint configuration. Alternatively, you could load the configuration
	// from an eslint.config.js file or just use the default config.
	const overrideConfig = {
		languageOptions: {
			ecmaVersion: 2018,
			sourceType: "commonjs",
		},
		rules: {
			"no-console": "error",
			"no-unused-vars": "warn",
		},
	};

	const eslint = createESLintInstance(overrideConfig);
	const results = await lintAndFix(eslint, filePaths);
	return outputLintingResults(results);
}

// Export integration
module.exports = { lintFiles };
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960
    
        Copy code to clipboard
        
    

Conclusion
In this tutorial, we have covered the essentials of using the ESLint class to
lint files and retrieve results in your projects. This knowledge can be applied
to create custom integrations, such as code editor plugins, to provide real-time
feedback on code quality.
View the Tutorial Code
You can view the annotated source code for the tutorial
here.

            

            
                Edit this page\n\nIntegrate with the Node.js API Tutorial
                

                Table of Contents
    
        
                
                    
                    Why Create an Integration?
            		

                    What You’ll Build
            		

                    Requirements
            		

                    Step 1: Setup
            		

                    Step 2: Import and Configure the ESLint Instance
            		

                    Step 3: Lint and Fix Files
            		

                    Step 4: Output Results
            		

                    Step 5: Put It All Together
            		

                    Conclusion
            		

                    View the Tutorial Code
            		
                
            
    


                This guide walks you through integrating the ESLint class to lint files and
retrieve results, which can be useful for creating integrations with other
projects.
Why Create an Integration?
You might want to create an ESLint integration if you’re creating developer
tooling, such as the following:


Code editors and IDEs: Integrating ESLint with code editors and IDEs can
provide real-time feedback on code quality and automatically highlight
potential issues as you type. Many editors already have ESLint plugins
available, but you may need to create a custom integration if the existing
plugins do not meet your specific requirements.


Custom linter tools: If you’re building a custom linter tool that combines
multiple linters or adds specific functionality, you may want to integrate
ESLint into your tool to provide JavaScript linting capabilities.


Code review tools: Integrating ESLint with code review tools can help
automate the process of identifying potential issues in the codebase.


Learning platforms: If you are developing a learning platform or coding
tutorial, integrating ESLint can provide real-time feedback to users as they
learn JavaScript, helping them improve their coding skills and learn best
practices.


Developer tool integration: If you’re creating or extending a developer
tool, such as a bundler or testing framework, you may want to integrate ESLint
to provide linting capabilities. You can integrate ESLint directly into the
tool or as a plugin.


What You’ll Build
In this guide, you’ll create a simple Node.js project that uses the ESLint
class to lint files and retrieve results.
Requirements
This tutorial assumes you are familiar with JavaScript and Node.js.
To follow this tutorial, you’ll need to have the following:

Node.js (^18.18.0, ^20.9.0, or >=21.1.0)
npm
A text editor

Step 1: Setup
First, create a new project directory:


    mkdir eslint-integration
cd eslint-integration
12
    
        Copy code to clipboard
        
    

Initialize the project with a package.json file:

   
      npm
      yarn
      pnpm
      bun
   
    
        npm


    npm init -y
1
    
        Copy code to clipboard
        
    


   
      yarn


    yarn init -y
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm init -y
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bun init -y
1
    
        Copy code to clipboard
        
    

   

Install the eslint package as a dependency (not as a dev dependency):

   
      npm
      yarn
      pnpm
      bun
   
    
        npm


    npm install eslint
1
    
        Copy code to clipboard
        
    


   
      yarn


    yarn add eslint
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm add eslint
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bun add eslint
1
    
        Copy code to clipboard
        
    

   

Create a new file called example-eslint-integration.js in the project root:


    touch example-eslint-integration.js
1
    
        Copy code to clipboard
        
    

Step 2: Import and Configure the ESLint Instance
Import the ESLint class from the eslint package and create a new instance.
You can customize the ESLint configuration by passing an options object to the
ESLint constructor:


    // example-eslint-integration.js

const { ESLint } = require("eslint");

// Create an instance of ESLint with the configuration passed to the function
function createESLintInstance(overrideConfig) {
	return new ESLint({
		overrideConfigFile: true,
		overrideConfig,
		fix: true,
	});
}
123456789101112
    
        Copy code to clipboard
        
    

Step 3: Lint and Fix Files
To lint a file, use the lintFiles method of the ESLint instance. The
filePaths argument passed to ESLint#lintFiles() can be a string or an array
of strings, representing the file path(s) you want to lint. The file paths can
be globs or filenames.
The static method ESLint.outputFixes() takes the linting results from the call
to ESLint#lintFiles(), and then writes the fixed code back to the source
files.


    // example-eslint-integration.js

// ... previous step's code to instantiate the ESLint instance

// Lint the specified files and return the results
async function lintAndFix(eslint, filePaths) {
	const results = await eslint.lintFiles(filePaths);

	// Apply automatic fixes and output fixed code
	await ESLint.outputFixes(results);

	return results;
}
12345678910111213
    
        Copy code to clipboard
        
    

Step 4: Output Results
Define a function to output the linting results to the console. This should be
specific to your integration’s needs. For example, you could report the linting
results to a user interface.
In this example, we’ll simply log the results to the console:


    // example-eslint-integration.js

// ... previous step's code to instantiate the ESLint instance
// and get linting results.

// Log results to console if there are any problems
function outputLintingResults(results) {
	// Identify the number of problems found
	const problems = results.reduce(
		(acc, result) => acc + result.errorCount + result.warningCount,
		0,
	);

	if (problems > 0) {
		console.log("Linting errors found!");
		console.log(results);
	} else {
		console.log("No linting errors found.");
	}
	return results;
}
123456789101112131415161718192021
    
        Copy code to clipboard
        
    

Step 5: Put It All Together
Put the above functions together in a new function called lintFiles. This
function will be the main entry point for your integration:


    // example-eslint-integration.js

// Put previous functions all together
async function lintFiles(filePaths) {
	// The ESLint configuration. Alternatively, you could load the configuration
	// from a .eslintrc file or just use the default config.
	const overrideConfig = {
		languageOptions: {
			ecmaVersion: 2018,
			sourceType: "commonjs",
		},
		rules: {
			"no-console": "error",
			"no-unused-vars": "warn",
		},
	};

	const eslint = createESLintInstance(overrideConfig);
	const results = await lintAndFix(eslint, filePaths);
	return outputLintingResults(results);
}

// Export integration
module.exports = { lintFiles };
123456789101112131415161718192021222324
    
        Copy code to clipboard
        
    

Here’s the complete code example for example-eslint-integration.js:


    const { ESLint } = require("eslint");

// Create an instance of ESLint with the configuration passed to the function
function createESLintInstance(overrideConfig) {
	return new ESLint({
		overrideConfigFile: true,
		overrideConfig,
		fix: true,
	});
}

// Lint the specified files and return the results
async function lintAndFix(eslint, filePaths) {
	const results = await eslint.lintFiles(filePaths);

	// Apply automatic fixes and output fixed code
	await ESLint.outputFixes(results);

	return results;
}

// Log results to console if there are any problems
function outputLintingResults(results) {
	// Identify the number of problems found
	const problems = results.reduce(
		(acc, result) => acc + result.errorCount + result.warningCount,
		0,
	);

	if (problems > 0) {
		console.log("Linting errors found!");
		console.log(results);
	} else {
		console.log("No linting errors found.");
	}
	return results;
}

// Put previous functions all together
async function lintFiles(filePaths) {
	// The ESLint configuration. Alternatively, you could load the configuration
	// from an eslint.config.js file or just use the default config.
	const overrideConfig = {
		languageOptions: {
			ecmaVersion: 2018,
			sourceType: "commonjs",
		},
		rules: {
			"no-console": "error",
			"no-unused-vars": "warn",
		},
	};

	const eslint = createESLintInstance(overrideConfig);
	const results = await lintAndFix(eslint, filePaths);
	return outputLintingResults(results);
}

// Export integration
module.exports = { lintFiles };
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960
    
        Copy code to clipboard
        
    

Conclusion
In this tutorial, we have covered the essentials of using the ESLint class to
lint files and retrieve results in your projects. This knowledge can be applied
to create custom integrations, such as code editor plugins, to provide real-time
feedback on code quality.
View the Tutorial Code
You can view the annotated source code for the tutorial
here.

            

            
                Edit this page\n\n\n\nNode.js API Reference
                

                Table of Contents
    
        
                
                    
                    ESLint class
            
                
                    
                    ◆ new ESLint(options)
            
                
                    
                    Parameters
            		
                
            		

                    ◆ eslint.lintFiles(patterns)
            
                
                    
                    Parameters
            		

                    Return Value
            		
                
            		

                    ◆ eslint.lintText(code, options)
            
                
                    
                    Parameters
            		

                    Return Value
            		
                
            		

                    ◆ eslint.getRulesMetaForResults(results)
            
                
                    
                    Parameters
            		

                    Return Value
            		
                
            		

                    ◆ eslint.calculateConfigForFile(filePath)
            
                
                    
                    Parameters
            		

                    Return Value
            		
                
            		

                    ◆ eslint.isPathIgnored(filePath)
            
                
                    
                    Parameters
            		

                    Return Value
            		
                
            		

                    ◆ eslint.loadFormatter(nameOrPath)
            
                
                    
                    Parameters
            		

                    Return Value
            		
                
            		

                    ◆ eslint.hasFlag(flagName)
            
                
                    
                    Parameters
            		

                    Return Value
            		
                
            		

                    ◆ ESLint.version
            		

                    ◆ ESLint.defaultConfig
            		

                    ◆ ESLint.outputFixes(results)
            
                
                    
                    Parameters
            		

                    Return Value
            		
                
            		

                    ◆ ESLint.getErrorResults(results)
            
                
                    
                    Parameters
            		

                    Return Value
            		
                
            		

                    ◆ LintResult type
            		

                    ◆ LintMessage type
            		

                    ◆ SuppressedLintMessage type
            		

                    ◆ EditInfo type
            		

                    ◆ LoadedFormatter type
            		
                
            		

                    loadESLint()
            		

                    SourceCode
            
                
                    
                    SourceCode#splitLines()
            		
                
            		

                    Linter
            
                
                    
                    Linter#verify
            		

                    Linter#verifyAndFix()
            		

                    Linter#version/Linter.version
            		

                    Linter#getTimes()
            		

                    Linter#getFixPassCount()
            		

                    Linter#hasFlag()
            		
                
            		

                    RuleTester
            
                
                    
                    Testing Errors with messageId
            		

                    Testing Fixes
            		

                    Testing Suggestions
            		

                    Customizing RuleTester
            		
                
            		
                
            
    


                While ESLint is designed to be run on the command line, it’s possible to use ESLint programmatically through the Node.js API. The purpose of the Node.js API is to allow plugin and tool authors to use the ESLint functionality directly, without going through the command line interface.
Note: Use undocumented parts of the API at your own risk. Only those parts that are specifically mentioned in this document are approved for use and will remain stable and reliable. Anything left undocumented is unstable and may change or be removed at any point.
ESLint class
The ESLint class is the primary class to use in Node.js applications.
This class depends on the Node.js fs module and the file system, so you cannot use it in browsers. If you want to lint code on browsers, use the Linter class instead.
Here’s a simple example of using the ESLint class:


    const { ESLint } = require("eslint");

(async function main() {
	// 1. Create an instance.
	const eslint = new ESLint();

	// 2. Lint files.
	const results = await eslint.lintFiles(["lib/**/*.js"]);

	// 3. Format the results.
	const formatter = await eslint.loadFormatter("stylish");
	const resultText = formatter.format(results);

	// 4. Output it.
	console.log(resultText);
})().catch(error => {
	process.exitCode = 1;
	console.error(error);
});
12345678910111213141516171819
    
        Copy code to clipboard
        
    

Here’s an example that autofixes lint problems:


    const { ESLint } = require("eslint");

(async function main() {
	// 1. Create an instance with the `fix` option.
	const eslint = new ESLint({ fix: true });

	// 2. Lint files. This doesn't modify target files.
	const results = await eslint.lintFiles(["lib/**/*.js"]);

	// 3. Modify the files with the fixed code.
	await ESLint.outputFixes(results);

	// 4. Format the results.
	const formatter = await eslint.loadFormatter("stylish");
	const resultText = formatter.format(results);

	// 5. Output it.
	console.log(resultText);
})().catch(error => {
	process.exitCode = 1;
	console.error(error);
});
12345678910111213141516171819202122
    
        Copy code to clipboard
        
    

And here is an example of using the ESLint class with lintText API:


    const { ESLint } = require("eslint");

const testCode = `
  const name = "eslint";
  if(true) {
    console.log("constant condition warning")
  };
`;

(async function main() {
	// 1. Create an instance
	const eslint = new ESLint({
		overrideConfigFile: true,
		overrideConfig: {
			languageOptions: {
				ecmaVersion: 2018,
				sourceType: "commonjs",
			},
		},
	});

	// 2. Lint text.
	const results = await eslint.lintText(testCode);

	// 3. Format the results.
	const formatter = await eslint.loadFormatter("stylish");
	const resultText = formatter.format(results);

	// 4. Output it.
	console.log(resultText);
})().catch(error => {
	process.exitCode = 1;
	console.error(error);
});
12345678910111213141516171819202122232425262728293031323334
    
        Copy code to clipboard
        
    

◆ new ESLint(options)


    const eslint = new ESLint(options);
1
    
        Copy code to clipboard
        
    

Create a new ESLint instance.
Parameters
The ESLint constructor takes an options object. If you omit the options object then it uses default values for all options. The options object has the following properties.
File Enumeration

options.cwd (string)
Default is process.cwd(). The working directory. This must be an absolute path.
options.errorOnUnmatchedPattern (boolean)
Default is true. Unless set to false, the eslint.lintFiles() method will throw an error when no target files are found.
options.globInputPaths (boolean)
Default is true. If false is present, the eslint.lintFiles() method doesn’t interpret glob patterns.
options.ignore (boolean)
Default is true. If false is present, the eslint.lintFiles() method doesn’t respect ignorePatterns in your configuration.
options.ignorePatterns (string[] | null)
Default is null. Ignore file patterns to use in addition to config ignores. These patterns are relative to cwd.
options.passOnNoPatterns (boolean)
Default is false. When set to true, missing patterns cause the linting operation to short circuit and not report any failures.
options.warnIgnored (boolean)
Default is true. Show warnings when the file list includes ignored files.

Linting

options.allowInlineConfig (boolean)
Default is true. If false is present, ESLint suppresses directive comments in source code. If this option is false, it overrides the noInlineConfig setting in your configurations.
options.baseConfig (ConfigData | ConfigData[] | null)
Default is null. Configuration object, extended by all configurations used with this instance. You can use this option to define the default settings that will be used if your configuration files don’t configure it.
options.overrideConfig (ConfigData | ConfigData[] | null)
Default is null. Configuration object, added after any existing configuration and therefore applies after what’s contained in your configuration file (if used).
options.overrideConfigFile (null | true | string)
Default is null. By default, ESLint searches for a configuration file. When this option is set to true, ESLint does not search for a configuration file. When this option is set to a string value, ESLint does not search for a configuration file, and uses the provided value as the path to the configuration file.
options.plugins (Record<string, Plugin> | null)
Default is null. The plugin implementations that ESLint uses for the plugins setting of your configuration. This is a map-like object. Those keys are plugin IDs and each value is implementation.
options.ruleFilter (({ruleId: string, severity: number}) => boolean)
Default is () => true. A predicate function that filters rules to be run. This function is called with an object containing ruleId and severity, and returns true if the rule should be run.
options.stats (boolean)
Default is false. When set to true, additional statistics are added to the lint results (see Stats type).

Autofix

options.fix (boolean | (message: LintMessage) => boolean)
Default is false. If true is present, the eslint.lintFiles() and eslint.lintText() methods work in autofix mode. If a predicate function is present, the methods pass each lint message to the function, then use only the lint messages for which the function returned true.
options.fixTypes (("directive" | "problem" | "suggestion" | "layout")[] | null)
Default is null. The types of the rules that the eslint.lintFiles() and eslint.lintText() methods use for autofix.

Cache-related

options.cache (boolean)
Default is false. If true is present, the eslint.lintFiles() method caches lint results and uses it if each target file is not changed. Please mind that ESLint doesn’t clear the cache when you upgrade ESLint plugins. In that case, you have to remove the cache file manually. The eslint.lintText() method doesn’t use caches even if you pass the options.filePath to the method.
options.cacheLocation (string)
Default is .eslintcache. The eslint.lintFiles() method writes caches into this file.
options.cacheStrategy (string)
Default is "metadata". Strategy for the cache to use for detecting changed files. Can be either "metadata" or "content".

Other Options

options.flags (string[])
Default is []. The feature flags to enable for this instance.

◆ eslint.lintFiles(patterns)


    const results = await eslint.lintFiles(patterns);
1
    
        Copy code to clipboard
        
    

This method lints the files that match the glob patterns and then returns the results.
Parameters

patterns (string | string[])
The lint target files. This can contain any of file paths, directory paths, and glob patterns.

Return Value

(Promise<LintResult[]>)
The promise that will be fulfilled with an array of LintResult objects.

◆ eslint.lintText(code, options)


    const results = await eslint.lintText(code, options);
1
    
        Copy code to clipboard
        
    

This method lints the given source code text and then returns the results.
By default, this method uses the configuration that applies to files in the current working directory (the cwd constructor option). If you want to use a different configuration, pass options.filePath, and ESLint will load the same configuration that eslint.lintFiles() would use for a file at options.filePath.
If the options.filePath value is configured to be ignored, this method returns an empty array. If the options.warnIgnored option is set along with the options.filePath option, this method returns a LintResult object. In that case, the result may contain a warning that indicates the file was ignored.
Parameters
The second parameter options is omittable.

code (string)
The source code text to check.
options.filePath (string)
Optional. The path to the file of the source code text. If omitted, the result.filePath becomes the string "<text>".
options.warnIgnored (boolean)
Optional, defaults to options.warnIgnored passed to the constructor. If true is present and the options.filePath is a file ESLint should ignore, this method returns a lint result contains a warning message.

Return Value

(Promise<LintResult[]>)
The promise that will be fulfilled with an array of LintResult objects. This is an array (despite there being only one lint result) in order to keep the interfaces between this and the eslint.lintFiles() method similar.

◆ eslint.getRulesMetaForResults(results)


    const results = await eslint.lintFiles(patterns);
const rulesMeta = eslint.getRulesMetaForResults(results);
12
    
        Copy code to clipboard
        
    

This method returns an object containing meta information for each rule that triggered a lint error in the given results.
Parameters

results (LintResult[])
An array of LintResult objects returned from a call to ESLint#lintFiles() or ESLint#lintText().

Return Value

(Object)
An object whose property names are the rule IDs from the results and whose property values are the rule’s meta information (if available).

◆ eslint.calculateConfigForFile(filePath)


    const config = await eslint.calculateConfigForFile(filePath);
1
    
        Copy code to clipboard
        
    

This method calculates the configuration for a given file, which can be useful for debugging purposes.
Parameters

filePath (string)
The path to the file whose configuration you would like to calculate. Directory paths are forbidden because ESLint cannot handle the overrides setting.

Return Value

(Promise<Object>)
The promise that will be fulfilled with a configuration object.

◆ eslint.isPathIgnored(filePath)


    const isPathIgnored = await eslint.isPathIgnored(filePath);
1
    
        Copy code to clipboard
        
    

This method checks if a given file is ignored by your configuration.
Parameters

filePath (string)
The path to the file you want to check.

Return Value

(Promise<boolean>)
The promise that will be fulfilled with whether the file is ignored or not. If the file is ignored, then it will return true.

◆ eslint.loadFormatter(nameOrPath)


    const formatter = await eslint.loadFormatter(nameOrPath);
1
    
        Copy code to clipboard
        
    

This method loads a formatter. Formatters convert lint results to a human- or machine-readable string.
Parameters

nameOrPath (string | undefined)
The path to the file you want to check. The following values are allowed:

undefined. In this case, loads the "stylish" built-in formatter.
A name of built-in formatters.
A name of third-party formatters. For examples:

"foo" will load eslint-formatter-foo.
"@foo" will load @foo/eslint-formatter.
"@foo/bar" will load @foo/eslint-formatter-bar.


A path to the file that defines a formatter. The path must contain one or more path separators (/) in order to distinguish if it’s a path or not. For example, start with ./.



Return Value

(Promise<LoadedFormatter>)
The promise that will be fulfilled with a LoadedFormatter object.

◆ eslint.hasFlag(flagName)
This method is used to determine if a given feature flag is set, as in this example:


    if (eslint.hasFlag("x_feature")) {
	// handle flag
}
123
    
        Copy code to clipboard
        
    

Parameters

flagName (string)
The flag to check.

Return Value

(boolean)
True if the flag is enabled.

◆ ESLint.version


    const version = ESLint.version;
1
    
        Copy code to clipboard
        
    

The version string of ESLint. E.g. "7.0.0".
This is a static property.
◆ ESLint.defaultConfig


    const defaultConfig = ESLint.defaultConfig;
1
    
        Copy code to clipboard
        
    

The default configuration that ESLint uses internally. This is provided for tooling that wants to calculate configurations using the same defaults as ESLint. Keep in mind that the default configuration may change from version to version, so you shouldn’t rely on any particular keys or values to be present.
This is a static property.
◆ ESLint.outputFixes(results)


    await ESLint.outputFixes(results);
1
    
        Copy code to clipboard
        
    

This method writes code modified by ESLint’s autofix feature into its respective file. If any of the modified files don’t exist, this method does nothing.
This is a static method.
Parameters

results (LintResult[])
The LintResult objects to write.

Return Value

(Promise<void>)
The promise that will be fulfilled after all files are written.

◆ ESLint.getErrorResults(results)


    const filteredResults = ESLint.getErrorResults(results);
1
    
        Copy code to clipboard
        
    

This method copies the given results and removes warnings. The returned value contains only errors.
This is a static method.
Parameters

results (LintResult[])
The LintResult objects to filter.

Return Value

(LintResult[])
The filtered LintResult objects.

◆ LintResult type
The LintResult value is the information of the linting result of each file. The eslint.lintFiles() and eslint.lintText() methods return it. It has the following properties:

filePath (string)
The absolute path to the file of this result. This is the string "<text>" if the file path is unknown (when you didn’t pass the options.filePath option to the eslint.lintText() method).
messages (LintMessage[])
The array of LintMessage objects.
suppressedMessages (SuppressedLintMessage[])
The array of SuppressedLintMessage objects.
fixableErrorCount (number)
The number of errors that can be fixed automatically by the fix constructor option.
fixableWarningCount (number)
The number of warnings that can be fixed automatically by the fix constructor option.
errorCount (number)
The number of errors. This includes fixable errors and fatal errors.
fatalErrorCount (number)
The number of fatal errors.
warningCount (number)
The number of warnings. This includes fixable warnings.
output (string | undefined)
The modified source code text. This property is undefined if any fixable messages didn’t exist.
source (string | undefined)
The original source code text. This property is undefined if any messages didn’t exist or the output property exists.
stats (Stats | undefined)
The Stats object. This contains the lint performance statistics collected with the stats option.
usedDeprecatedRules ({ ruleId: string; replacedBy: string[]; info: DeprecatedInfo | undefined }[])
The information about the deprecated rules that were used to check this file.
The info property is set to rule.meta.deprecated if the rule uses the new deprecated property.

◆ LintMessage type
The LintMessage value is the information of each linting error. The messages property of the LintResult type contains it. It has the following properties:

ruleId (string | null)
The rule name that generates this lint message. If this message is generated by the ESLint core rather than rules, this is null.
severity (1 | 2)
The severity of this message. 1 means warning and 2 means error.
fatal (boolean | undefined)
true if this is a fatal error unrelated to a rule, like a parsing error.
message (string)
The error message.
messageId (string | undefined)
The message ID of the lint error. This property is undefined if the rule does not use message IDs.
line (number | undefined)
The 1-based line number of the begin point of this message.
column (number | undefined)
The 1-based column number of the begin point of this message.
endLine (number | undefined)
The 1-based line number of the end point of this message. This property is undefined if this message is not a range.
endColumn (number | undefined)
The 1-based column number of the end point of this message. This property is undefined if this message is not a range.
fix (EditInfo | undefined)
The EditInfo object of autofix. This property is undefined if this message is not fixable.
suggestions ({ desc: string; fix: EditInfo; messageId?: string; data?: object }[] | undefined)
The list of suggestions. Each suggestion is the pair of a description and an EditInfo object to fix code. API users such as editor integrations can choose one of them to fix the problem of this message. This property is undefined if this message doesn’t have any suggestions.

◆ SuppressedLintMessage type
The SuppressedLintMessage value is the information of each suppressed linting error. The suppressedMessages property of the LintResult type contains it. It has the following properties:

ruleId (string | null)
Same as ruleId in LintMessage type.
severity (1 | 2)
Same as severity in LintMessage type.
fatal (boolean | undefined)
Same as fatal in LintMessage type.
message (string)
Same as message in LintMessage type.
messageId (string | undefined)
Same as messageId in LintMessage type.
line (number | undefined)
Same as line in LintMessage type.
column (number | undefined)
Same as column in LintMessage type.
endLine (number | undefined)
Same as endLine in LintMessage type.
endColumn (number | undefined)
Same as endColumn in LintMessage type.
fix (EditInfo | undefined)
Same as fix in LintMessage type.
suggestions ({ desc: string; fix: EditInfo; messageId?: string; data?: object }[] | undefined)
Same as suggestions in LintMessage type.
suppressions ({ kind: string; justification: string}[])
The list of suppressions. Each suppression is the pair of a kind and a justification.

◆ EditInfo type
The EditInfo value is information to edit text. The fix and suggestions properties of LintMessage type contain it. It has following properties:

range ([number, number])
The pair of 0-based indices in source code text to remove.
text (string)
The text to add.

This edit information means replacing the range of the range property by the text property value. It’s like sourceCodeText.slice(0, edit.range[0]) + edit.text + sourceCodeText.slice(edit.range[1]). Therefore, it’s an add if the range[0] and range[1] property values are the same value, and it’s removal if the text property value is empty string.
◆ LoadedFormatter type
The LoadedFormatter value is the object to convert the LintResult objects to text. The eslint.loadFormatter() method returns it. It has the following method:

format ((results: LintResult[], resultsMeta?: ResultsMeta) => string | Promise<string>)
The method to convert the LintResult objects to text. resultsMeta is an optional parameter that is primarily intended for use by the ESLint CLI and can contain only a maxWarningsExceeded property that would be passed through the context object when this method calls the underlying formatter function. Note that ESLint automatically generates cwd and rulesMeta properties of the context object, so you typically don’t need to pass in the second argument when calling this method.


loadESLint()
The loadESLint() function is used for integrations that wish to support both the current configuration system (flat config) and the old configuration system (eslintrc). This function returns the correct ESLint class implementation based on the arguments provided:


    const { loadESLint } = require("eslint");

// loads the default ESLint that the CLI would use based on process.cwd()
const DefaultESLint = await loadESLint();

// loads the flat config version specifically
const FlatESLint = await loadESLint({ useFlatConfig: true });

// loads the legacy version specifically
const LegacyESLint = await loadESLint({ useFlatConfig: false });
12345678910
    
        Copy code to clipboard
        
    

You can then use the returned constructor to instantiate a new ESLint instance, like this:


    // loads the default ESLint that the CLI would use based on process.cwd()
const DefaultESLint = await loadESLint();
const eslint = new DefaultESLint();
123
    
        Copy code to clipboard
        
    

If you’re ever unsure which config system the returned constructor uses, check the configType property, which is either "flat" or "eslintrc":


    // loads the default ESLint that the CLI would use based on process.cwd()
const DefaultESLint = await loadESLint();

if (DefaultESLint.configType === "flat") {
	// do something specific to flat config
}
123456
    
        Copy code to clipboard
        
    

If you don’t need to support both the old and new configuration systems, then it’s recommended to just use the ESLint constructor directly.

SourceCode
The SourceCode type represents the parsed source code that ESLint executes on. It’s used internally in ESLint and is also available so that already-parsed code can be used. You can create a new instance of SourceCode by passing in the text string representing the code and an abstract syntax tree (AST) in ESTree format (including location information, range information, comments, and tokens):


    const SourceCode = require("eslint").SourceCode;

const code = new SourceCode("var foo = bar;", ast);
123
    
        Copy code to clipboard
        
    

The SourceCode constructor throws an error if the AST is missing any of the required information.
The SourceCode constructor strips Unicode BOM.
Please note the AST also should be parsed from stripped text.


    const SourceCode = require("eslint").SourceCode;

const code = new SourceCode("\uFEFFvar foo = bar;", ast);

assert(code.hasBOM === true);
assert(code.text === "var foo = bar;");
123456
    
        Copy code to clipboard
        
    

SourceCode#splitLines()
This is a static function on SourceCode that is used to split the source code text into an array of lines.


    const SourceCode = require("eslint").SourceCode;

const code = "var a = 1;\nvar b = 2;";

// split code into an array
const codeLines = SourceCode.splitLines(code);

/*
    Value of codeLines will be
    [
        "var a = 1;",
        "var b = 2;"
    ]
 */
1234567891011121314
    
        Copy code to clipboard
        
    


Linter
The Linter object does the actual evaluation of the JavaScript code. It doesn’t do any filesystem operations, it simply parses and reports on the code. In particular, the Linter object does not process configuration files. Unless you are working in the browser, you probably want to use the ESLint class instead.
The Linter is a constructor, and you can create a new instance by passing in the options you want to use. The available options are:

cwd - Path to a directory that should be considered as the current working directory. It is accessible to rules from context.cwd or by calling context.getCwd() (see The Context Object). If cwd is undefined, it will be normalized to process.cwd() if the global process object is defined (for example, in the Node.js runtime) , or undefined otherwise.

For example:


    const Linter = require("eslint").Linter;
const linter1 = new Linter({ cwd: "path/to/project" });
const linter2 = new Linter();
123
    
        Copy code to clipboard
        
    

In this example, rules run on linter1 will get path/to/project from context.cwd or when calling context.getCwd().
Those run on linter2 will get process.cwd() if the global process object is defined or undefined otherwise (e.g. on the browser https://eslint.org/demo).
Linter#verify
The most important method on Linter is verify(), which initiates linting of the given text. This method accepts three arguments:

code - the source code to lint (a string or instance of SourceCode).
config - a Configuration object or an array of configuration objects.

Note: If you want to lint text and have your configuration be read from the file system, use ESLint#lintFiles() or ESLint#lintText() instead.


options - (optional) Additional options for this run.

filename - (optional) the filename to associate with the source code.
preprocess - (optional) A function that Processors in Plugins documentation describes as the preprocess method.
postprocess - (optional) A function that Processors in Plugins documentation describes as the postprocess method.
filterCodeBlock - (optional) A function that decides which code blocks the linter should adopt. The function receives two arguments. The first argument is the virtual filename of a code block. The second argument is the text of the code block. If the function returned true then the linter adopts the code block. If the function was omitted, the linter adopts only *.js code blocks. If you provided a filterCodeBlock function, it overrides this default behavior, so the linter doesn’t adopt *.js code blocks automatically.
disableFixes - (optional) when set to true, the linter doesn’t make either the fix or suggestions property of the lint result.
allowInlineConfig - (optional) set to false to disable inline comments from changing ESLint rules.
reportUnusedDisableDirectives - (optional) when set to true, adds reported errors for unused eslint-disable and eslint-enable directives when no problems would be reported in the disabled area anyway.
ruleFilter - (optional) A function predicate that decides which rules should run. It receives an object containing ruleId and severity, and returns true if the rule should be run.



If the third argument is a string, it is interpreted as the filename.
You can call verify() like this:


    const Linter = require("eslint").Linter;
const linter = new Linter();

const messages = linter.verify(
	"var foo;",
	{
		rules: {
			semi: 2,
		},
	},
	{ filename: "foo.js" },
);

// or using SourceCode

const Linter = require("eslint").Linter,
	linter = new Linter(),
	SourceCode = require("eslint").SourceCode;

const code = new SourceCode("var foo = bar;", ast);

const messages = linter.verify(
	code,
	{
		rules: {
			semi: 2,
		},
	},
	{ filename: "foo.js" },
);
123456789101112131415161718192021222324252627282930
    
        Copy code to clipboard
        
    

The verify() method returns an array of objects containing information about the linting warnings and errors. Here’s an example:


    [
	{
		fatal: false,
		ruleId: "semi",
		severity: 2,
		line: 1,
		column: 23,
		message: "Expected a semicolon.",
		fix: {
			range: [1, 15],
			text: ";",
		},
	},
];
1234567891011121314
    
        Copy code to clipboard
        
    

The information available for each linting message is:

column - the column on which the error occurred.
fatal - usually omitted, but will be set to true if there’s a parsing error (not related to a rule).
line - the line on which the error occurred.
message - the message that should be output.
messageId - the ID of the message used to generate the message (this property is omitted if the rule does not use message IDs).
nodeType - (Deprecated: This property will be removed in a future version of ESLint.) the node or token type that was reported with the problem.
ruleId - the ID of the rule that triggered the messages (or null if fatal is true).
severity - either 1 or 2, depending on your configuration.
endColumn - the end column of the range on which the error occurred (this property is omitted if it’s not range).
endLine - the end line of the range on which the error occurred (this property is omitted if it’s not range).
fix - an object describing the fix for the problem (this property is omitted if no fix is available).
suggestions - an array of objects describing possible lint fixes for editors to programmatically enable (see details in the Working with Rules docs).

You can get the suppressed messages from the previous run by getSuppressedMessages() method. If there is not a previous run, getSuppressedMessage() will return an empty list.


    const Linter = require("eslint").Linter;
const linter = new Linter();

const messages = linter.verify(
	"var foo = bar; // eslint-disable-line -- Need to suppress",
	{
		rules: {
			semi: ["error", "never"],
		},
	},
	{ filename: "foo.js" },
);
const suppressedMessages = linter.getSuppressedMessages();

console.log(suppressedMessages[0].suppressions); // [{ "kind": "directive", "justification": "Need to suppress" }]
123456789101112131415
    
        Copy code to clipboard
        
    

You can also get an instance of the SourceCode object used inside of linter by using the getSourceCode() method:


    const Linter = require("eslint").Linter;
const linter = new Linter();

const messages = linter.verify(
	"var foo = bar;",
	{
		rules: {
			semi: 2,
		},
	},
	{ filename: "foo.js" },
);

const code = linter.getSourceCode();

console.log(code.text); // "var foo = bar;"
12345678910111213141516
    
        Copy code to clipboard
        
    

In this way, you can retrieve the text and AST used for the last run of linter.verify().
Linter#verifyAndFix()
This method is similar to verify except that it also runs autofixing logic, similar to the --fix flag on the command line. The result object will contain the autofixed code, along with any remaining linting messages for the code that were not autofixed.


    const Linter = require("eslint").Linter;
const linter = new Linter();

const messages = linter.verifyAndFix("var foo", {
	rules: {
		semi: 2,
	},
});
12345678
    
        Copy code to clipboard
        
    

Output object from this method:


    {
    fixed: true,
    output: "var foo;",
    messages: []
}
12345
    
        Copy code to clipboard
        
    

The information available is:

fixed - True, if the code was fixed.
output - Fixed code text (might be the same as input if no fixes were applied).
messages - Collection of all messages for the given code (It has the same information as explained above under verify block).

Linter#version/Linter.version
Each instance of Linter has a version property containing the semantic version number of ESLint that the Linter instance is from.


    const Linter = require("eslint").Linter;
const linter = new Linter();

linter.version; // => '9.0.0'
1234
    
        Copy code to clipboard
        
    

There is also a Linter.version property that you can read without instantiating Linter:


    const Linter = require("eslint").Linter;

Linter.version; // => '9.0.0'
123
    
        Copy code to clipboard
        
    

Linter#getTimes()
This method is used to get the times spent on (parsing, fixing, linting) a file. See times property of the Stats object.
Linter#getFixPassCount()
This method is used to get the number of autofix passes made. See fixPasses property of the Stats object.
Linter#hasFlag()
This method is used to determine if a given feature flag is set, as in this example:


    const Linter = require("eslint").Linter;
const linter = new Linter({ flags: ["x_feature"] });

console.log(linter.hasFlag("x_feature")); // true
1234
    
        Copy code to clipboard
        
    


RuleTester
eslint.RuleTester is a utility to write tests for ESLint rules. It is used internally for the bundled rules that come with ESLint, and it can also be used by plugins.
Example usage:


    "use strict";

const rule = require("../../../lib/rules/my-rule"),
	RuleTester = require("eslint").RuleTester;

const ruleTester = new RuleTester();

ruleTester.run("my-rule", rule, {
	valid: [
		{
			code: "var foo = true",
			options: [{ allowFoo: true }],
		},
	],

	invalid: [
		{
			code: "var invalidVariable = true",
			errors: [{ message: "Unexpected invalid variable." }],
		},
		{
			code: "var invalidVariable = true",
			errors: [{ message: /^Unexpected.+variable/ }],
		},
	],
});
1234567891011121314151617181920212223242526
    
        Copy code to clipboard
        
    

The RuleTester constructor accepts an optional object argument, which can be used to specify defaults for your test cases. For example, if all of your test cases use ES2015, you can set it as a default:


    const ruleTester = new RuleTester({ languageOptions: { ecmaVersion: 2015 } });
1
    
        Copy code to clipboard
        
    


                    
                    
                        Tip
                        If you don’t specify any options to the RuleTester constructor, then it uses the ESLint defaults (languageOptions: { ecmaVersion: "latest", sourceType: "module" }).

                    
                The RuleTester#run() method is used to run the tests. It should be passed the following arguments:

The name of the rule (string).
The rule object itself (see “working with rules”).
An object containing valid and invalid properties, each of which is an array containing test cases.

A test case is an object with the following properties:

name (string, optional): The name to use for the test case, to make it easier to find.
code (string, required): The source code that the rule should be run on.
options (array, optional): The options passed to the rule. The rule severity should not be included in this list.
before (function, optional): Function to execute before testing the case.
after (function, optional): Function to execute after testing the case regardless of its result.
filename (string, optional): The filename for the given case (useful for rules that make assertions about filenames).
only (boolean, optional): Run this case exclusively for debugging in supported test frameworks.

In addition to the properties above, invalid test cases can also have the following properties:


errors (number or array, required): Asserts some properties of the errors that the rule is expected to produce when run on this code. If this is a number, asserts the number of errors produced. Otherwise, this should be a list of objects, each containing information about a single reported error. The following properties can be used for an error (all are optional unless otherwise noted):

message (string/regexp): The message for the error. Must provide this or messageId.
messageId (string): The ID for the error. Must provide this or message. See testing errors with messageId for details.
data (object): Placeholder data which can be used in combination with messageId.
type (string): (Deprecated: This property will be removed in a future version of ESLint.) The type of the reported AST node.
line (number): The 1-based line number of the reported location.
column (number): The 1-based column number of the reported location.
endLine (number): The 1-based line number of the end of the reported location.
endColumn (number): The 1-based column number of the end of the reported location.
suggestions (array): An array of objects with suggestion details to check. Required if the rule produces suggestions. See Testing Suggestions for details.

If a string is provided as an error instead of an object, the string is used to assert the message of the error.


output (string, required if the rule fixes code): Asserts the output that will be produced when using this rule for a single pass of autofixing (e.g. with the --fix command line flag). If this is null or omitted, asserts that none of the reported problems suggest autofixes.


Any additional properties of a test case will be passed directly to the linter as config options. For example, a test case can have a languageOptions property to configure parser behavior:


    {
    code: "let foo;",
    languageOptions: { ecmaVersion: 2015 }
}
1234
    
        Copy code to clipboard
        
    

If a valid test case only uses the code property, it can optionally be provided as a string containing the code, rather than an object with a code key.
Testing Errors with messageId
If the rule under test uses messageIds, you can use messageId property in a test case to assert reported error’s messageId instead of its message.


    {
    code: "let foo;",
    errors: [{ messageId: "unexpected" }]
}
1234
    
        Copy code to clipboard
        
    

For messages with placeholders, a test case can also use data property to additionally assert reported error’s message.


    {
    code: "let foo;",
    errors: [{ messageId: "unexpected", data: { name: "foo" } }]
}
1234
    
        Copy code to clipboard
        
    

Please note that data in a test case does not assert data passed to context.report. Instead, it is used to form the expected message text which is then compared with the received message.
Testing Fixes
The result of applying fixes can be tested by using the output property of an invalid test case. The output property should be used only when you expect a fix to be applied to the specified code; you can safely omit output if no changes are expected to the code. Here’s an example:


    ruleTester.run("my-rule-for-no-foo", rule, {
	valid: [],
	invalid: [
		{
			code: "var foo;",
			output: "var bar;",
			errors: [
				{
					messageId: "shouldBeBar",
					line: 1,
					column: 5,
				},
			],
		},
	],
});
12345678910111213141516
    
        Copy code to clipboard
        
    

A the end of this invalid test case, RuleTester expects a fix to be applied that results in the code changing from var foo; to var bar;. If the output after applying the fix doesn’t match, then the test fails.

                    
                    
                        Important
                        ESLint makes its best attempt at applying all fixes, but there is no guarantee that all fixes will be applied. As such, you should aim for testing each type of fix in a separate RuleTester test case rather than one test case to test multiple fixes. When there is a conflict between two fixes (because they apply to the same section of code) RuleTester applies only the first fix.

                    
                Testing Suggestions
Suggestions can be tested by defining a suggestions key on an errors object. If this is a number, it asserts the number of suggestions provided for the error. Otherwise, this should be an array of objects, each containing information about a single provided suggestion. The following properties can be used:

desc (string): The suggestion desc value. Must provide this or messageId.
messageId (string): The suggestion messageId value for suggestions that use messageIds. Must provide this or desc.
data (object): Placeholder data which can be used in combination with messageId.
output (string, required): A code string representing the result of applying the suggestion fix to the input code.

Example:


    ruleTester.run("my-rule-for-no-foo", rule, {
	valid: [],
	invalid: [
		{
			code: "var foo;",
			errors: [
				{
					suggestions: [
						{
							desc: "Rename identifier 'foo' to 'bar'",
							output: "var bar;",
						},
					],
				},
			],
		},
	],
});
123456789101112131415161718
    
        Copy code to clipboard
        
    

messageId and data properties in suggestion test objects work the same way as in error test objects. See testing errors with messageId for details.


    ruleTester.run("my-rule-for-no-foo", rule, {
	valid: [],
	invalid: [
		{
			code: "var foo;",
			errors: [
				{
					suggestions: [
						{
							messageId: "renameFoo",
							data: { newName: "bar" },
							output: "var bar;",
						},
					],
				},
			],
		},
	],
});
12345678910111213141516171819
    
        Copy code to clipboard
        
    

Customizing RuleTester
RuleTester depends on two functions to run tests: describe and it. These functions can come from various places:


If RuleTester.describe and RuleTester.it have been set to function values, RuleTester will use RuleTester.describe and RuleTester.it to run tests. You can use this to customize the behavior of RuleTester to match a test framework that you’re using.
If RuleTester.itOnly has been set to a function value, RuleTester will call RuleTester.itOnly instead of RuleTester.it to run cases with only: true. If RuleTester.itOnly is not set but RuleTester.it has an only function property, RuleTester will fall back to RuleTester.it.only.


Otherwise, if describe and it are present as globals, RuleTester will use globalThis.describe and globalThis.it to run tests and globalThis.it.only to run cases with only: true. This allows RuleTester to work when using frameworks like Mocha without any additional configuration.


Otherwise, RuleTester#run will simply execute all of the tests in sequence, and will throw an error if one of them fails. This means you can simply execute a test file that calls RuleTester.run using Node.js, without needing a testing framework.


RuleTester#run calls the describe function with two arguments: a string describing the rule, and a callback function. The callback calls the it function with a string describing the test case, and a test function. The test function will return successfully if the test passes, and throw an error if the test fails. The signature for only is the same as it. RuleTester calls either it or only for every case even when some cases have only: true, and the test framework is responsible for implementing test case exclusivity. (Note that this is the standard behavior for test suites when using frameworks like Mocha; this information is only relevant if you plan to customize RuleTester.describe, RuleTester.it, or RuleTester.itOnly.)
Example of customizing RuleTester:


    "use strict";

const RuleTester = require("eslint").RuleTester,
	test = require("my-test-runner"),
	myRule = require("../../../lib/rules/my-rule");

RuleTester.describe = function (text, method) {
	RuleTester.it.title = text;
	return method.call(this);
};

RuleTester.it = function (text, method) {
	test(RuleTester.it.title + ": " + text, method);
};

// then use RuleTester as documented

const ruleTester = new RuleTester();

ruleTester.run("my-rule", myRule, {
	valid: [
		// valid test cases
	],
	invalid: [
		// invalid test cases
	],
});
123456789101112131415161718192021222324252627
    
        Copy code to clipboard
        
    


            

            
                Edit this page\n\nNode.js API Reference
                

                Table of Contents
    
        
                
                    
                    ESLint class
            
                
                    
                    ◆ new ESLint(options)
            
                
                    
                    Parameters
            		
                
            		

                    ◆ eslint.lintFiles(patterns)
            
                
                    
                    Parameters
            		

                    Return Value
            		
                
            		

                    ◆ eslint.lintText(code, options)
            
                
                    
                    Parameters
            		

                    Return Value
            		
                
            		

                    ◆ eslint.getRulesMetaForResults(results)
            
                
                    
                    Parameters
            		

                    Return Value
            		
                
            		

                    ◆ eslint.calculateConfigForFile(filePath)
            
                
                    
                    Parameters
            		

                    Return Value
            		
                
            		

                    ◆ eslint.isPathIgnored(filePath)
            
                
                    
                    Parameters
            		

                    Return Value
            		
                
            		

                    ◆ eslint.loadFormatter(nameOrPath)
            
                
                    
                    Parameters
            		

                    Return Value
            		
                
            		

                    ◆ eslint.hasFlag(flagName)
            
                
                    
                    Parameters
            		

                    Return Value
            		
                
            		

                    ◆ ESLint.version
            		

                    ◆ ESLint.defaultConfig
            		

                    ◆ ESLint.outputFixes(results)
            
                
                    
                    Parameters
            		

                    Return Value
            		
                
            		

                    ◆ ESLint.getErrorResults(results)
            
                
                    
                    Parameters
            		

                    Return Value
            		
                
            		

                    ◆ LintResult type
            		

                    ◆ LintMessage type
            		

                    ◆ SuppressedLintMessage type
            		

                    ◆ EditInfo type
            		

                    ◆ LoadedFormatter type
            		
                
            		

                    loadESLint()
            		

                    SourceCode
            
                
                    
                    SourceCode#splitLines()
            		
                
            		

                    Linter
            
                
                    
                    Linter#verify
            		

                    Linter#verifyAndFix()
            		

                    Linter#version/Linter.version
            		

                    Linter#getTimes()
            		

                    Linter#getFixPassCount()
            		

                    Linter#hasFlag()
            		
                
            		

                    RuleTester
            
                
                    
                    Testing Errors with messageId
            		

                    Testing Fixes
            		

                    Testing Suggestions
            		

                    Customizing RuleTester
            		
                
            		
                
            
    


                While ESLint is designed to be run on the command line, it’s possible to use ESLint programmatically through the Node.js API. The purpose of the Node.js API is to allow plugin and tool authors to use the ESLint functionality directly, without going through the command line interface.
Note: Use undocumented parts of the API at your own risk. Only those parts that are specifically mentioned in this document are approved for use and will remain stable and reliable. Anything left undocumented is unstable and may change or be removed at any point.
ESLint class
The ESLint class is the primary class to use in Node.js applications.
This class depends on the Node.js fs module and the file system, so you cannot use it in browsers. If you want to lint code on browsers, use the Linter class instead.
Here’s a simple example of using the ESLint class:


    const { ESLint } = require("eslint");

(async function main() {
	// 1. Create an instance.
	const eslint = new ESLint();

	// 2. Lint files.
	const results = await eslint.lintFiles(["lib/**/*.js"]);

	// 3. Format the results.
	const formatter = await eslint.loadFormatter("stylish");
	const resultText = formatter.format(results);

	// 4. Output it.
	console.log(resultText);
})().catch(error => {
	process.exitCode = 1;
	console.error(error);
});
12345678910111213141516171819
    
        Copy code to clipboard
        
    

Here’s an example that autofixes lint problems:


    const { ESLint } = require("eslint");

(async function main() {
	// 1. Create an instance with the `fix` option.
	const eslint = new ESLint({ fix: true });

	// 2. Lint files. This doesn't modify target files.
	const results = await eslint.lintFiles(["lib/**/*.js"]);

	// 3. Modify the files with the fixed code.
	await ESLint.outputFixes(results);

	// 4. Format the results.
	const formatter = await eslint.loadFormatter("stylish");
	const resultText = formatter.format(results);

	// 5. Output it.
	console.log(resultText);
})().catch(error => {
	process.exitCode = 1;
	console.error(error);
});
12345678910111213141516171819202122
    
        Copy code to clipboard
        
    

And here is an example of using the ESLint class with lintText API:


    const { ESLint } = require("eslint");

const testCode = `
  const name = "eslint";
  if(true) {
    console.log("constant condition warning")
  };
`;

(async function main() {
	// 1. Create an instance
	const eslint = new ESLint({
		overrideConfigFile: true,
		overrideConfig: {
			languageOptions: {
				ecmaVersion: 2018,
				sourceType: "commonjs",
			},
		},
	});

	// 2. Lint text.
	const results = await eslint.lintText(testCode);

	// 3. Format the results.
	const formatter = await eslint.loadFormatter("stylish");
	const resultText = formatter.format(results);

	// 4. Output it.
	console.log(resultText);
})().catch(error => {
	process.exitCode = 1;
	console.error(error);
});
12345678910111213141516171819202122232425262728293031323334
    
        Copy code to clipboard
        
    

◆ new ESLint(options)


    const eslint = new ESLint(options);
1
    
        Copy code to clipboard
        
    

Create a new ESLint instance.
Parameters
The ESLint constructor takes an options object. If you omit the options object then it uses default values for all options. The options object has the following properties.
File Enumeration

options.cwd (string)
Default is process.cwd(). The working directory. This must be an absolute path.
options.errorOnUnmatchedPattern (boolean)
Default is true. Unless set to false, the eslint.lintFiles() method will throw an error when no target files are found.
options.globInputPaths (boolean)
Default is true. If false is present, the eslint.lintFiles() method doesn’t interpret glob patterns.
options.ignore (boolean)
Default is true. If false is present, the eslint.lintFiles() method doesn’t respect ignorePatterns in your configuration.
options.ignorePatterns (string[] | null)
Default is null. Ignore file patterns to use in addition to config ignores. These patterns are relative to cwd.
options.passOnNoPatterns (boolean)
Default is false. When set to true, missing patterns cause the linting operation to short circuit and not report any failures.
options.warnIgnored (boolean)
Default is true. Show warnings when the file list includes ignored files.

Linting

options.allowInlineConfig (boolean)
Default is true. If false is present, ESLint suppresses directive comments in source code. If this option is false, it overrides the noInlineConfig setting in your configurations.
options.baseConfig (ConfigData | ConfigData[] | null)
Default is null. Configuration object, extended by all configurations used with this instance. You can use this option to define the default settings that will be used if your configuration files don’t configure it.
options.overrideConfig (ConfigData | ConfigData[] | null)
Default is null. Configuration object, added after any existing configuration and therefore applies after what’s contained in your configuration file (if used).
options.overrideConfigFile (null | true | string)
Default is null. By default, ESLint searches for a configuration file. When this option is set to true, ESLint does not search for a configuration file. When this option is set to a string value, ESLint does not search for a configuration file, and uses the provided value as the path to the configuration file.
options.plugins (Record<string, Plugin> | null)
Default is null. The plugin implementations that ESLint uses for the plugins setting of your configuration. This is a map-like object. Those keys are plugin IDs and each value is implementation.
options.ruleFilter (({ruleId: string, severity: number}) => boolean)
Default is () => true. A predicate function that filters rules to be run. This function is called with an object containing ruleId and severity, and returns true if the rule should be run.
options.stats (boolean)
Default is false. When set to true, additional statistics are added to the lint results (see Stats type).

Autofix

options.fix (boolean | (message: LintMessage) => boolean)
Default is false. If true is present, the eslint.lintFiles() and eslint.lintText() methods work in autofix mode. If a predicate function is present, the methods pass each lint message to the function, then use only the lint messages for which the function returned true.
options.fixTypes (("directive" | "problem" | "suggestion" | "layout")[] | null)
Default is null. The types of the rules that the eslint.lintFiles() and eslint.lintText() methods use for autofix.

Cache-related

options.cache (boolean)
Default is false. If true is present, the eslint.lintFiles() method caches lint results and uses it if each target file is not changed. Please mind that ESLint doesn’t clear the cache when you upgrade ESLint plugins. In that case, you have to remove the cache file manually. The eslint.lintText() method doesn’t use caches even if you pass the options.filePath to the method.
options.cacheLocation (string)
Default is .eslintcache. The eslint.lintFiles() method writes caches into this file.
options.cacheStrategy (string)
Default is "metadata". Strategy for the cache to use for detecting changed files. Can be either "metadata" or "content".

Other Options

options.flags (string[])
Default is []. The feature flags to enable for this instance.

◆ eslint.lintFiles(patterns)


    const results = await eslint.lintFiles(patterns);
1
    
        Copy code to clipboard
        
    

This method lints the files that match the glob patterns and then returns the results.
Parameters

patterns (string | string[])
The lint target files. This can contain any of file paths, directory paths, and glob patterns.

Return Value

(Promise<LintResult[]>)
The promise that will be fulfilled with an array of LintResult objects.

◆ eslint.lintText(code, options)


    const results = await eslint.lintText(code, options);
1
    
        Copy code to clipboard
        
    

This method lints the given source code text and then returns the results.
By default, this method uses the configuration that applies to files in the current working directory (the cwd constructor option). If you want to use a different configuration, pass options.filePath, and ESLint will load the same configuration that eslint.lintFiles() would use for a file at options.filePath.
If the options.filePath value is configured to be ignored, this method returns an empty array. If the options.warnIgnored option is set along with the options.filePath option, this method returns a LintResult object. In that case, the result may contain a warning that indicates the file was ignored.
Parameters
The second parameter options is omittable.

code (string)
The source code text to check.
options.filePath (string)
Optional. The path to the file of the source code text. If omitted, the result.filePath becomes the string "<text>".
options.warnIgnored (boolean)
Optional, defaults to options.warnIgnored passed to the constructor. If true is present and the options.filePath is a file ESLint should ignore, this method returns a lint result contains a warning message.

Return Value

(Promise<LintResult[]>)
The promise that will be fulfilled with an array of LintResult objects. This is an array (despite there being only one lint result) in order to keep the interfaces between this and the eslint.lintFiles() method similar.

◆ eslint.getRulesMetaForResults(results)


    const results = await eslint.lintFiles(patterns);
const rulesMeta = eslint.getRulesMetaForResults(results);
12
    
        Copy code to clipboard
        
    

This method returns an object containing meta information for each rule that triggered a lint error in the given results.
Parameters

results (LintResult[])
An array of LintResult objects returned from a call to ESLint#lintFiles() or ESLint#lintText().

Return Value

(Object)
An object whose property names are the rule IDs from the results and whose property values are the rule’s meta information (if available).

◆ eslint.calculateConfigForFile(filePath)


    const config = await eslint.calculateConfigForFile(filePath);
1
    
        Copy code to clipboard
        
    

This method calculates the configuration for a given file, which can be useful for debugging purposes.
Parameters

filePath (string)
The path to the file whose configuration you would like to calculate. Directory paths are forbidden because ESLint cannot handle the overrides setting.

Return Value

(Promise<Object>)
The promise that will be fulfilled with a configuration object.

◆ eslint.isPathIgnored(filePath)


    const isPathIgnored = await eslint.isPathIgnored(filePath);
1
    
        Copy code to clipboard
        
    

This method checks if a given file is ignored by your configuration.
Parameters

filePath (string)
The path to the file you want to check.

Return Value

(Promise<boolean>)
The promise that will be fulfilled with whether the file is ignored or not. If the file is ignored, then it will return true.

◆ eslint.loadFormatter(nameOrPath)


    const formatter = await eslint.loadFormatter(nameOrPath);
1
    
        Copy code to clipboard
        
    

This method loads a formatter. Formatters convert lint results to a human- or machine-readable string.
Parameters

nameOrPath (string | undefined)
The path to the file you want to check. The following values are allowed:

undefined. In this case, loads the "stylish" built-in formatter.
A name of built-in formatters.
A name of third-party formatters. For examples:

"foo" will load eslint-formatter-foo.
"@foo" will load @foo/eslint-formatter.
"@foo/bar" will load @foo/eslint-formatter-bar.


A path to the file that defines a formatter. The path must contain one or more path separators (/) in order to distinguish if it’s a path or not. For example, start with ./.



Return Value

(Promise<LoadedFormatter>)
The promise that will be fulfilled with a LoadedFormatter object.

◆ eslint.hasFlag(flagName)
This method is used to determine if a given feature flag is set, as in this example:


    if (eslint.hasFlag("x_feature")) {
	// handle flag
}
123
    
        Copy code to clipboard
        
    

Parameters

flagName (string)
The flag to check.

Return Value

(boolean)
True if the flag is enabled.

◆ ESLint.version


    const version = ESLint.version;
1
    
        Copy code to clipboard
        
    

The version string of ESLint. E.g. "7.0.0".
This is a static property.
◆ ESLint.defaultConfig


    const defaultConfig = ESLint.defaultConfig;
1
    
        Copy code to clipboard
        
    

The default configuration that ESLint uses internally. This is provided for tooling that wants to calculate configurations using the same defaults as ESLint. Keep in mind that the default configuration may change from version to version, so you shouldn’t rely on any particular keys or values to be present.
This is a static property.
◆ ESLint.outputFixes(results)


    await ESLint.outputFixes(results);
1
    
        Copy code to clipboard
        
    

This method writes code modified by ESLint’s autofix feature into its respective file. If any of the modified files don’t exist, this method does nothing.
This is a static method.
Parameters

results (LintResult[])
The LintResult objects to write.

Return Value

(Promise<void>)
The promise that will be fulfilled after all files are written.

◆ ESLint.getErrorResults(results)


    const filteredResults = ESLint.getErrorResults(results);
1
    
        Copy code to clipboard
        
    

This method copies the given results and removes warnings. The returned value contains only errors.
This is a static method.
Parameters

results (LintResult[])
The LintResult objects to filter.

Return Value

(LintResult[])
The filtered LintResult objects.

◆ LintResult type
The LintResult value is the information of the linting result of each file. The eslint.lintFiles() and eslint.lintText() methods return it. It has the following properties:

filePath (string)
The absolute path to the file of this result. This is the string "<text>" if the file path is unknown (when you didn’t pass the options.filePath option to the eslint.lintText() method).
messages (LintMessage[])
The array of LintMessage objects.
suppressedMessages (SuppressedLintMessage[])
The array of SuppressedLintMessage objects.
fixableErrorCount (number)
The number of errors that can be fixed automatically by the fix constructor option.
fixableWarningCount (number)
The number of warnings that can be fixed automatically by the fix constructor option.
errorCount (number)
The number of errors. This includes fixable errors and fatal errors.
fatalErrorCount (number)
The number of fatal errors.
warningCount (number)
The number of warnings. This includes fixable warnings.
output (string | undefined)
The modified source code text. This property is undefined if any fixable messages didn’t exist.
source (string | undefined)
The original source code text. This property is undefined if any messages didn’t exist or the output property exists.
stats (Stats | undefined)
The Stats object. This contains the lint performance statistics collected with the stats option.
usedDeprecatedRules ({ ruleId: string; replacedBy: string[]; info: DeprecatedInfo | undefined }[])
The information about the deprecated rules that were used to check this file.
The info property is set to rule.meta.deprecated if the rule uses the new deprecated property.

◆ LintMessage type
The LintMessage value is the information of each linting error. The messages property of the LintResult type contains it. It has the following properties:

ruleId (string | null)
The rule name that generates this lint message. If this message is generated by the ESLint core rather than rules, this is null.
severity (1 | 2)
The severity of this message. 1 means warning and 2 means error.
fatal (boolean | undefined)
true if this is a fatal error unrelated to a rule, like a parsing error.
message (string)
The error message.
messageId (string | undefined)
The message ID of the lint error. This property is undefined if the rule does not use message IDs.
line (number | undefined)
The 1-based line number of the begin point of this message.
column (number | undefined)
The 1-based column number of the begin point of this message.
endLine (number | undefined)
The 1-based line number of the end point of this message. This property is undefined if this message is not a range.
endColumn (number | undefined)
The 1-based column number of the end point of this message. This property is undefined if this message is not a range.
fix (EditInfo | undefined)
The EditInfo object of autofix. This property is undefined if this message is not fixable.
suggestions ({ desc: string; fix: EditInfo; messageId?: string; data?: object }[] | undefined)
The list of suggestions. Each suggestion is the pair of a description and an EditInfo object to fix code. API users such as editor integrations can choose one of them to fix the problem of this message. This property is undefined if this message doesn’t have any suggestions.

◆ SuppressedLintMessage type
The SuppressedLintMessage value is the information of each suppressed linting error. The suppressedMessages property of the LintResult type contains it. It has the following properties:

ruleId (string | null)
Same as ruleId in LintMessage type.
severity (1 | 2)
Same as severity in LintMessage type.
fatal (boolean | undefined)
Same as fatal in LintMessage type.
message (string)
Same as message in LintMessage type.
messageId (string | undefined)
Same as messageId in LintMessage type.
line (number | undefined)
Same as line in LintMessage type.
column (number | undefined)
Same as column in LintMessage type.
endLine (number | undefined)
Same as endLine in LintMessage type.
endColumn (number | undefined)
Same as endColumn in LintMessage type.
fix (EditInfo | undefined)
Same as fix in LintMessage type.
suggestions ({ desc: string; fix: EditInfo; messageId?: string; data?: object }[] | undefined)
Same as suggestions in LintMessage type.
suppressions ({ kind: string; justification: string}[])
The list of suppressions. Each suppression is the pair of a kind and a justification.

◆ EditInfo type
The EditInfo value is information to edit text. The fix and suggestions properties of LintMessage type contain it. It has following properties:

range ([number, number])
The pair of 0-based indices in source code text to remove.
text (string)
The text to add.

This edit information means replacing the range of the range property by the text property value. It’s like sourceCodeText.slice(0, edit.range[0]) + edit.text + sourceCodeText.slice(edit.range[1]). Therefore, it’s an add if the range[0] and range[1] property values are the same value, and it’s removal if the text property value is empty string.
◆ LoadedFormatter type
The LoadedFormatter value is the object to convert the LintResult objects to text. The eslint.loadFormatter() method returns it. It has the following method:

format ((results: LintResult[], resultsMeta?: ResultsMeta) => string | Promise<string>)
The method to convert the LintResult objects to text. resultsMeta is an optional parameter that is primarily intended for use by the ESLint CLI and can contain only a maxWarningsExceeded property that would be passed through the context object when this method calls the underlying formatter function. Note that ESLint automatically generates cwd and rulesMeta properties of the context object, so you typically don’t need to pass in the second argument when calling this method.


loadESLint()
The loadESLint() function is used for integrations that wish to support both the current configuration system (flat config) and the old configuration system (eslintrc). This function returns the correct ESLint class implementation based on the arguments provided:


    const { loadESLint } = require("eslint");

// loads the default ESLint that the CLI would use based on process.cwd()
const DefaultESLint = await loadESLint();

// loads the flat config version specifically
const FlatESLint = await loadESLint({ useFlatConfig: true });

// loads the legacy version specifically
const LegacyESLint = await loadESLint({ useFlatConfig: false });
12345678910
    
        Copy code to clipboard
        
    

You can then use the returned constructor to instantiate a new ESLint instance, like this:


    // loads the default ESLint that the CLI would use based on process.cwd()
const DefaultESLint = await loadESLint();
const eslint = new DefaultESLint();
123
    
        Copy code to clipboard
        
    

If you’re ever unsure which config system the returned constructor uses, check the configType property, which is either "flat" or "eslintrc":


    // loads the default ESLint that the CLI would use based on process.cwd()
const DefaultESLint = await loadESLint();

if (DefaultESLint.configType === "flat") {
	// do something specific to flat config
}
123456
    
        Copy code to clipboard
        
    

If you don’t need to support both the old and new configuration systems, then it’s recommended to just use the ESLint constructor directly.

SourceCode
The SourceCode type represents the parsed source code that ESLint executes on. It’s used internally in ESLint and is also available so that already-parsed code can be used. You can create a new instance of SourceCode by passing in the text string representing the code and an abstract syntax tree (AST) in ESTree format (including location information, range information, comments, and tokens):


    const SourceCode = require("eslint").SourceCode;

const code = new SourceCode("var foo = bar;", ast);
123
    
        Copy code to clipboard
        
    

The SourceCode constructor throws an error if the AST is missing any of the required information.
The SourceCode constructor strips Unicode BOM.
Please note the AST also should be parsed from stripped text.


    const SourceCode = require("eslint").SourceCode;

const code = new SourceCode("\uFEFFvar foo = bar;", ast);

assert(code.hasBOM === true);
assert(code.text === "var foo = bar;");
123456
    
        Copy code to clipboard
        
    

SourceCode#splitLines()
This is a static function on SourceCode that is used to split the source code text into an array of lines.


    const SourceCode = require("eslint").SourceCode;

const code = "var a = 1;\nvar b = 2;";

// split code into an array
const codeLines = SourceCode.splitLines(code);

/*
    Value of codeLines will be
    [
        "var a = 1;",
        "var b = 2;"
    ]
 */
1234567891011121314
    
        Copy code to clipboard
        
    


Linter
The Linter object does the actual evaluation of the JavaScript code. It doesn’t do any filesystem operations, it simply parses and reports on the code. In particular, the Linter object does not process configuration files. Unless you are working in the browser, you probably want to use the ESLint class instead.
The Linter is a constructor, and you can create a new instance by passing in the options you want to use. The available options are:

cwd - Path to a directory that should be considered as the current working directory. It is accessible to rules from context.cwd or by calling context.getCwd() (see The Context Object). If cwd is undefined, it will be normalized to process.cwd() if the global process object is defined (for example, in the Node.js runtime) , or undefined otherwise.

For example:


    const Linter = require("eslint").Linter;
const linter1 = new Linter({ cwd: "path/to/project" });
const linter2 = new Linter();
123
    
        Copy code to clipboard
        
    

In this example, rules run on linter1 will get path/to/project from context.cwd or when calling context.getCwd().
Those run on linter2 will get process.cwd() if the global process object is defined or undefined otherwise (e.g. on the browser https://eslint.org/demo).
Linter#verify
The most important method on Linter is verify(), which initiates linting of the given text. This method accepts three arguments:

code - the source code to lint (a string or instance of SourceCode).
config - a Configuration object or an array of configuration objects.

Note: If you want to lint text and have your configuration be read from the file system, use ESLint#lintFiles() or ESLint#lintText() instead.


options - (optional) Additional options for this run.

filename - (optional) the filename to associate with the source code.
preprocess - (optional) A function that Processors in Plugins documentation describes as the preprocess method.
postprocess - (optional) A function that Processors in Plugins documentation describes as the postprocess method.
filterCodeBlock - (optional) A function that decides which code blocks the linter should adopt. The function receives two arguments. The first argument is the virtual filename of a code block. The second argument is the text of the code block. If the function returned true then the linter adopts the code block. If the function was omitted, the linter adopts only *.js code blocks. If you provided a filterCodeBlock function, it overrides this default behavior, so the linter doesn’t adopt *.js code blocks automatically.
disableFixes - (optional) when set to true, the linter doesn’t make either the fix or suggestions property of the lint result.
allowInlineConfig - (optional) set to false to disable inline comments from changing ESLint rules.
reportUnusedDisableDirectives - (optional) when set to true, adds reported errors for unused eslint-disable and eslint-enable directives when no problems would be reported in the disabled area anyway.
ruleFilter - (optional) A function predicate that decides which rules should run. It receives an object containing ruleId and severity, and returns true if the rule should be run.



If the third argument is a string, it is interpreted as the filename.
You can call verify() like this:


    const Linter = require("eslint").Linter;
const linter = new Linter();

const messages = linter.verify(
	"var foo;",
	{
		rules: {
			semi: 2,
		},
	},
	{ filename: "foo.js" },
);

// or using SourceCode

const Linter = require("eslint").Linter,
	linter = new Linter(),
	SourceCode = require("eslint").SourceCode;

const code = new SourceCode("var foo = bar;", ast);

const messages = linter.verify(
	code,
	{
		rules: {
			semi: 2,
		},
	},
	{ filename: "foo.js" },
);
123456789101112131415161718192021222324252627282930
    
        Copy code to clipboard
        
    

The verify() method returns an array of objects containing information about the linting warnings and errors. Here’s an example:


    [
	{
		fatal: false,
		ruleId: "semi",
		severity: 2,
		line: 1,
		column: 23,
		message: "Expected a semicolon.",
		fix: {
			range: [1, 15],
			text: ";",
		},
	},
];
1234567891011121314
    
        Copy code to clipboard
        
    

The information available for each linting message is:

column - the column on which the error occurred.
fatal - usually omitted, but will be set to true if there’s a parsing error (not related to a rule).
line - the line on which the error occurred.
message - the message that should be output.
messageId - the ID of the message used to generate the message (this property is omitted if the rule does not use message IDs).
nodeType - (Deprecated: This property will be removed in a future version of ESLint.) the node or token type that was reported with the problem.
ruleId - the ID of the rule that triggered the messages (or null if fatal is true).
severity - either 1 or 2, depending on your configuration.
endColumn - the end column of the range on which the error occurred (this property is omitted if it’s not range).
endLine - the end line of the range on which the error occurred (this property is omitted if it’s not range).
fix - an object describing the fix for the problem (this property is omitted if no fix is available).
suggestions - an array of objects describing possible lint fixes for editors to programmatically enable (see details in the Working with Rules docs).

You can get the suppressed messages from the previous run by getSuppressedMessages() method. If there is not a previous run, getSuppressedMessage() will return an empty list.


    const Linter = require("eslint").Linter;
const linter = new Linter();

const messages = linter.verify(
	"var foo = bar; // eslint-disable-line -- Need to suppress",
	{
		rules: {
			semi: ["error", "never"],
		},
	},
	{ filename: "foo.js" },
);
const suppressedMessages = linter.getSuppressedMessages();

console.log(suppressedMessages[0].suppressions); // [{ "kind": "directive", "justification": "Need to suppress" }]
123456789101112131415
    
        Copy code to clipboard
        
    

You can also get an instance of the SourceCode object used inside of linter by using the getSourceCode() method:


    const Linter = require("eslint").Linter;
const linter = new Linter();

const messages = linter.verify(
	"var foo = bar;",
	{
		rules: {
			semi: 2,
		},
	},
	{ filename: "foo.js" },
);

const code = linter.getSourceCode();

console.log(code.text); // "var foo = bar;"
12345678910111213141516
    
        Copy code to clipboard
        
    

In this way, you can retrieve the text and AST used for the last run of linter.verify().
Linter#verifyAndFix()
This method is similar to verify except that it also runs autofixing logic, similar to the --fix flag on the command line. The result object will contain the autofixed code, along with any remaining linting messages for the code that were not autofixed.


    const Linter = require("eslint").Linter;
const linter = new Linter();

const messages = linter.verifyAndFix("var foo", {
	rules: {
		semi: 2,
	},
});
12345678
    
        Copy code to clipboard
        
    

Output object from this method:


    {
    fixed: true,
    output: "var foo;",
    messages: []
}
12345
    
        Copy code to clipboard
        
    

The information available is:

fixed - True, if the code was fixed.
output - Fixed code text (might be the same as input if no fixes were applied).
messages - Collection of all messages for the given code (It has the same information as explained above under verify block).

Linter#version/Linter.version
Each instance of Linter has a version property containing the semantic version number of ESLint that the Linter instance is from.


    const Linter = require("eslint").Linter;
const linter = new Linter();

linter.version; // => '9.0.0'
1234
    
        Copy code to clipboard
        
    

There is also a Linter.version property that you can read without instantiating Linter:


    const Linter = require("eslint").Linter;

Linter.version; // => '9.0.0'
123
    
        Copy code to clipboard
        
    

Linter#getTimes()
This method is used to get the times spent on (parsing, fixing, linting) a file. See times property of the Stats object.
Linter#getFixPassCount()
This method is used to get the number of autofix passes made. See fixPasses property of the Stats object.
Linter#hasFlag()
This method is used to determine if a given feature flag is set, as in this example:


    const Linter = require("eslint").Linter;
const linter = new Linter({ flags: ["x_feature"] });

console.log(linter.hasFlag("x_feature")); // true
1234
    
        Copy code to clipboard
        
    


RuleTester
eslint.RuleTester is a utility to write tests for ESLint rules. It is used internally for the bundled rules that come with ESLint, and it can also be used by plugins.
Example usage:


    "use strict";

const rule = require("../../../lib/rules/my-rule"),
	RuleTester = require("eslint").RuleTester;

const ruleTester = new RuleTester();

ruleTester.run("my-rule", rule, {
	valid: [
		{
			code: "var foo = true",
			options: [{ allowFoo: true }],
		},
	],

	invalid: [
		{
			code: "var invalidVariable = true",
			errors: [{ message: "Unexpected invalid variable." }],
		},
		{
			code: "var invalidVariable = true",
			errors: [{ message: /^Unexpected.+variable/ }],
		},
	],
});
1234567891011121314151617181920212223242526
    
        Copy code to clipboard
        
    

The RuleTester constructor accepts an optional object argument, which can be used to specify defaults for your test cases. For example, if all of your test cases use ES2015, you can set it as a default:


    const ruleTester = new RuleTester({ languageOptions: { ecmaVersion: 2015 } });
1
    
        Copy code to clipboard
        
    


                    
                    
                        Tip
                        If you don’t specify any options to the RuleTester constructor, then it uses the ESLint defaults (languageOptions: { ecmaVersion: "latest", sourceType: "module" }).

                    
                The RuleTester#run() method is used to run the tests. It should be passed the following arguments:

The name of the rule (string).
The rule object itself (see “working with rules”).
An object containing valid and invalid properties, each of which is an array containing test cases.

A test case is an object with the following properties:

name (string, optional): The name to use for the test case, to make it easier to find.
code (string, required): The source code that the rule should be run on.
options (array, optional): The options passed to the rule. The rule severity should not be included in this list.
before (function, optional): Function to execute before testing the case.
after (function, optional): Function to execute after testing the case regardless of its result.
filename (string, optional): The filename for the given case (useful for rules that make assertions about filenames).
only (boolean, optional): Run this case exclusively for debugging in supported test frameworks.

In addition to the properties above, invalid test cases can also have the following properties:


errors (number or array, required): Asserts some properties of the errors that the rule is expected to produce when run on this code. If this is a number, asserts the number of errors produced. Otherwise, this should be a list of objects, each containing information about a single reported error. The following properties can be used for an error (all are optional unless otherwise noted):

message (string/regexp): The message for the error. Must provide this or messageId.
messageId (string): The ID for the error. Must provide this or message. See testing errors with messageId for details.
data (object): Placeholder data which can be used in combination with messageId.
type (string): (Deprecated: This property will be removed in a future version of ESLint.) The type of the reported AST node.
line (number): The 1-based line number of the reported location.
column (number): The 1-based column number of the reported location.
endLine (number): The 1-based line number of the end of the reported location.
endColumn (number): The 1-based column number of the end of the reported location.
suggestions (array): An array of objects with suggestion details to check. Required if the rule produces suggestions. See Testing Suggestions for details.

If a string is provided as an error instead of an object, the string is used to assert the message of the error.


output (string, required if the rule fixes code): Asserts the output that will be produced when using this rule for a single pass of autofixing (e.g. with the --fix command line flag). If this is null or omitted, asserts that none of the reported problems suggest autofixes.


Any additional properties of a test case will be passed directly to the linter as config options. For example, a test case can have a languageOptions property to configure parser behavior:


    {
    code: "let foo;",
    languageOptions: { ecmaVersion: 2015 }
}
1234
    
        Copy code to clipboard
        
    

If a valid test case only uses the code property, it can optionally be provided as a string containing the code, rather than an object with a code key.
Testing Errors with messageId
If the rule under test uses messageIds, you can use messageId property in a test case to assert reported error’s messageId instead of its message.


    {
    code: "let foo;",
    errors: [{ messageId: "unexpected" }]
}
1234
    
        Copy code to clipboard
        
    

For messages with placeholders, a test case can also use data property to additionally assert reported error’s message.


    {
    code: "let foo;",
    errors: [{ messageId: "unexpected", data: { name: "foo" } }]
}
1234
    
        Copy code to clipboard
        
    

Please note that data in a test case does not assert data passed to context.report. Instead, it is used to form the expected message text which is then compared with the received message.
Testing Fixes
The result of applying fixes can be tested by using the output property of an invalid test case. The output property should be used only when you expect a fix to be applied to the specified code; you can safely omit output if no changes are expected to the code. Here’s an example:


    ruleTester.run("my-rule-for-no-foo", rule, {
	valid: [],
	invalid: [
		{
			code: "var foo;",
			output: "var bar;",
			errors: [
				{
					messageId: "shouldBeBar",
					line: 1,
					column: 5,
				},
			],
		},
	],
});
12345678910111213141516
    
        Copy code to clipboard
        
    

A the end of this invalid test case, RuleTester expects a fix to be applied that results in the code changing from var foo; to var bar;. If the output after applying the fix doesn’t match, then the test fails.

                    
                    
                        Important
                        ESLint makes its best attempt at applying all fixes, but there is no guarantee that all fixes will be applied. As such, you should aim for testing each type of fix in a separate RuleTester test case rather than one test case to test multiple fixes. When there is a conflict between two fixes (because they apply to the same section of code) RuleTester applies only the first fix.

                    
                Testing Suggestions
Suggestions can be tested by defining a suggestions key on an errors object. If this is a number, it asserts the number of suggestions provided for the error. Otherwise, this should be an array of objects, each containing information about a single provided suggestion. The following properties can be used:

desc (string): The suggestion desc value. Must provide this or messageId.
messageId (string): The suggestion messageId value for suggestions that use messageIds. Must provide this or desc.
data (object): Placeholder data which can be used in combination with messageId.
output (string, required): A code string representing the result of applying the suggestion fix to the input code.

Example:


    ruleTester.run("my-rule-for-no-foo", rule, {
	valid: [],
	invalid: [
		{
			code: "var foo;",
			errors: [
				{
					suggestions: [
						{
							desc: "Rename identifier 'foo' to 'bar'",
							output: "var bar;",
						},
					],
				},
			],
		},
	],
});
123456789101112131415161718
    
        Copy code to clipboard
        
    

messageId and data properties in suggestion test objects work the same way as in error test objects. See testing errors with messageId for details.


    ruleTester.run("my-rule-for-no-foo", rule, {
	valid: [],
	invalid: [
		{
			code: "var foo;",
			errors: [
				{
					suggestions: [
						{
							messageId: "renameFoo",
							data: { newName: "bar" },
							output: "var bar;",
						},
					],
				},
			],
		},
	],
});
12345678910111213141516171819
    
        Copy code to clipboard
        
    

Customizing RuleTester
RuleTester depends on two functions to run tests: describe and it. These functions can come from various places:


If RuleTester.describe and RuleTester.it have been set to function values, RuleTester will use RuleTester.describe and RuleTester.it to run tests. You can use this to customize the behavior of RuleTester to match a test framework that you’re using.
If RuleTester.itOnly has been set to a function value, RuleTester will call RuleTester.itOnly instead of RuleTester.it to run cases with only: true. If RuleTester.itOnly is not set but RuleTester.it has an only function property, RuleTester will fall back to RuleTester.it.only.


Otherwise, if describe and it are present as globals, RuleTester will use globalThis.describe and globalThis.it to run tests and globalThis.it.only to run cases with only: true. This allows RuleTester to work when using frameworks like Mocha without any additional configuration.


Otherwise, RuleTester#run will simply execute all of the tests in sequence, and will throw an error if one of them fails. This means you can simply execute a test file that calls RuleTester.run using Node.js, without needing a testing framework.


RuleTester#run calls the describe function with two arguments: a string describing the rule, and a callback function. The callback calls the it function with a string describing the test case, and a test function. The test function will return successfully if the test passes, and throw an error if the test fails. The signature for only is the same as it. RuleTester calls either it or only for every case even when some cases have only: true, and the test framework is responsible for implementing test case exclusivity. (Note that this is the standard behavior for test suites when using frameworks like Mocha; this information is only relevant if you plan to customize RuleTester.describe, RuleTester.it, or RuleTester.itOnly.)
Example of customizing RuleTester:


    "use strict";

const RuleTester = require("eslint").RuleTester,
	test = require("my-test-runner"),
	myRule = require("../../../lib/rules/my-rule");

RuleTester.describe = function (text, method) {
	RuleTester.it.title = text;
	return method.call(this);
};

RuleTester.it = function (text, method) {
	test(RuleTester.it.title + ": " + text, method);
};

// then use RuleTester as documented

const ruleTester = new RuleTester();

ruleTester.run("my-rule", myRule, {
	valid: [
		// valid test cases
	],
	invalid: [
		// invalid test cases
	],
});
123456789101112131415161718192021222324252627
    
        Copy code to clipboard
        
    


            

            
                Edit this page\n\n\n\nContribute to ESLint
                

                Table of Contents
    
        
                
                    
                    Read the Code of Conduct
            		

                    Report Bugs
            		

                    Propose a New Rule
            		

                    Propose a Rule Change
            		

                    Request a Change
            		

                    Architecture
            		

                    Set up a Development Environment
            		

                    Run the Tests
            		

                    Work on Issues
            		

                    Submit a Pull Request
            		

                    Contribute to Core Rules
            		

                    Governance
            		

                    Report a Security Vulnerability
            		

                    Sign the CLA
            		
                
            
    


                One of the great things about open source projects is that anyone can contribute in any number of meaningful ways. ESLint couldn’t exist without the help of the many contributors it’s had since the project began, and we want you to feel like you can contribute and make a difference as well.
This guide is intended for anyone who wants to contribute to an ESLint project. Please read it carefully as it answers a lot of the questions many newcomers have when first working with our projects.
Read the Code of Conduct
ESLint welcomes contributions from everyone and adheres to the OpenJS Foundation Code of Conduct. We kindly request that you read over our code of conduct before contributing.
Report Bugs
Think you found a problem? We’d love to hear about it. This section explains how to submit a bug, the type of information we need to properly verify it, and the overall process.
Propose a New Rule
We get a lot of proposals for new rules in ESLint. This section explains how we determine which rules are accepted and what information you should provide to help us evaluate your proposal.
Propose a Rule Change
Want to make a change to an existing rule? This section explains the process and how we evaluate such proposals.
Request a Change
If you’d like to request a change other than a bug fix or new rule, this section explains that process.
Architecture
Learn about the architecture of the ESLint project.
Set up a Development Environment
Developing for ESLint is a bit different than running it on the command line. This section shows you how to set up a development environment and get you ready to write code.
Run the Tests
There are a lot of unit tests included with ESLint to make sure that we’re keeping on top of code quality. This section explains how to run the unit tests.
Work on Issues
Have some extra time and want to contribute? This section talks about the process of working on issues.
Submit a Pull Request
We’re always looking for contributions from the community. This section explains the requirements for pull requests and the process of contributing code.
Contribute to Core Rules
This section explains how to add to the core rules of ESLint.
Governance
Describes the governance policy for ESLint, including the rights and privileges of individuals inside the project.
Report a Security Vulnerability
To report a security vulnerability in ESLint, please create an advisory on GitHub.
Sign the CLA
In order to submit code or documentation to an ESLint project, you will need to electronically sign our Contributor License Agreement. The CLA is the commonly used Apache-style template, and is you giving us permission to use your contribution. You only need to sign the CLA once for any OpenJS Foundation projects that use EasyCLA. You will be asked to sign the CLA in the first pull request you open.

            

            
                Edit this page\n\nContribute to ESLint
                

                Table of Contents
    
        
                
                    
                    Read the Code of Conduct
            		

                    Report Bugs
            		

                    Propose a New Rule
            		

                    Propose a Rule Change
            		

                    Request a Change
            		

                    Architecture
            		

                    Set up a Development Environment
            		

                    Run the Tests
            		

                    Work on Issues
            		

                    Submit a Pull Request
            		

                    Contribute to Core Rules
            		

                    Governance
            		

                    Report a Security Vulnerability
            		

                    Sign the CLA
            		
                
            
    


                One of the great things about open source projects is that anyone can contribute in any number of meaningful ways. ESLint couldn’t exist without the help of the many contributors it’s had since the project began, and we want you to feel like you can contribute and make a difference as well.
This guide is intended for anyone who wants to contribute to an ESLint project. Please read it carefully as it answers a lot of the questions many newcomers have when first working with our projects.
Read the Code of Conduct
ESLint welcomes contributions from everyone and adheres to the OpenJS Foundation Code of Conduct. We kindly request that you read over our code of conduct before contributing.
Report Bugs
Think you found a problem? We’d love to hear about it. This section explains how to submit a bug, the type of information we need to properly verify it, and the overall process.
Propose a New Rule
We get a lot of proposals for new rules in ESLint. This section explains how we determine which rules are accepted and what information you should provide to help us evaluate your proposal.
Propose a Rule Change
Want to make a change to an existing rule? This section explains the process and how we evaluate such proposals.
Request a Change
If you’d like to request a change other than a bug fix or new rule, this section explains that process.
Architecture
Learn about the architecture of the ESLint project.
Set up a Development Environment
Developing for ESLint is a bit different than running it on the command line. This section shows you how to set up a development environment and get you ready to write code.
Run the Tests
There are a lot of unit tests included with ESLint to make sure that we’re keeping on top of code quality. This section explains how to run the unit tests.
Work on Issues
Have some extra time and want to contribute? This section talks about the process of working on issues.
Submit a Pull Request
We’re always looking for contributions from the community. This section explains the requirements for pull requests and the process of contributing code.
Contribute to Core Rules
This section explains how to add to the core rules of ESLint.
Governance
Describes the governance policy for ESLint, including the rights and privileges of individuals inside the project.
Report a Security Vulnerability
To report a security vulnerability in ESLint, please create an advisory on GitHub.
Sign the CLA
In order to submit code or documentation to an ESLint project, you will need to electronically sign our Contributor License Agreement. The CLA is the commonly used Apache-style template, and is you giving us permission to use your contribution. You only need to sign the CLA once for any OpenJS Foundation projects that use EasyCLA. You will be asked to sign the CLA in the first pull request you open.

            

            
                Edit this page\n\n\n\nCode of Conduct
                

                


                ESLint welcomes contributions from everyone and adheres to the OpenJS Foundation Code of Conduct. We kindly request that you read over this code of conduct before contributing.

            

            
                Edit this page\n\nCode of Conduct
                

                


                ESLint welcomes contributions from everyone and adheres to the OpenJS Foundation Code of Conduct. We kindly request that you read over this code of conduct before contributing.

            

            
                Edit this page\n\n\n\nReport Bugs
                

                


                If you think you’ve found a bug in ESLint, please create a new issue or a pull request on GitHub.
Please include as much detail as possible to help us properly address your issue. If we need to triage issues and constantly ask people for more detail, that’s time taken away from actually fixing issues. Help us be as efficient as possible by including a lot of detail in your issues.
Note: If you just have a question that won’t necessarily result in a change to ESLint, such as asking how something works or how to contribute, please open a discussion or stop by our Discord server instead of filing an issue.

            

            
                Edit this page\n\nReport Bugs
                

                


                If you think you’ve found a bug in ESLint, please create a new issue or a pull request on GitHub.
Please include as much detail as possible to help us properly address your issue. If we need to triage issues and constantly ask people for more detail, that’s time taken away from actually fixing issues. Help us be as efficient as possible by including a lot of detail in your issues.
Note: If you just have a question that won’t necessarily result in a change to ESLint, such as asking how something works or how to contribute, please open a discussion or stop by our Discord server instead of filing an issue.

            

            
                Edit this page\n\n\n\nPropose a New Rule
                

                Table of Contents
    
        
                
                    
                    Core Rule Guidelines
            		

                    Proposing a Rule
            		

                    Accepting a Rule
            		

                    Implementation is Your Responsibility
            		

                    Alternative: Creating Your Own Rules
            		
                
            
    


                ESLint is all about rules. For most of the project’s lifetime, we’ve had over 200 rules, and that list continues to grow. However, we can’t just accept any proposed rule because all rules need to work cohesively together. As such, we have some guidelines around which rules can be part of the ESLint core and which are better off as custom rules and plugins.
Note: As of 2020, we only accept rules related to new ECMAScript features. We prefer that new rules be implemented in plugins.
Core Rule Guidelines
In general, ESLint core rules must be:

Widely applicable. The rules we distribute need to be of importance to a large number of developers. Individual preferences for uncommon patterns are not supported.
Generic. Rules cannot be so specific that users will have trouble understanding when to use them. A rule is typically too specific if describing what it does requires more than two "and"s (if a and b and c and d, then this rule warns).
Atomic. Rules must function completely on their own. Rules are expressly forbidden from knowing about the state or presence of other rules.
Unique. No two rules can produce the same warning. Overlapping rules confuse end users and there is an expectation that core ESLint rules do not overlap.
Library agnostic. Rules must be based solely on JavaScript runtime environments and not on specific libraries or frameworks. For example, core rules shouldn’t only apply if you’re using jQuery but we may have some rules that apply only if you’re using Node.js (a runtime).
No conflicts. No rule must directly conflict with another rule. For example, if we have a rule requiring semicolons, we cannot also have a rule disallowing semicolons (which is why we have one rule, semi, that does both).

Even though these are the formal criteria for inclusion, each rule is evaluated on its own basis.
Proposing a Rule
If you want to propose a new rule, please see how to create a pull request or submit an issue by filling out a new rule template.
We need all of this information in order to determine whether or not the rule is a good core rule candidate.
Accepting a Rule
In order for a rule to be accepted in the ESLint core, it must:

Fulfill all the criteria listed in the “Core Rule Guidelines” section.
Have an ESLint team member champion inclusion of the rule.
Be related to an ECMAScript feature that has reached stage 4 in the preceding 12 months.

Keep in mind that we have over 200 rules, and that is daunting both for end users and the ESLint team (who has to maintain them). As such, any new rules must be deemed of high importance to be considered for inclusion in ESLint.
Implementation is Your Responsibility
The ESLint team doesn’t implement new rules that are suggested by users because we have a limited number of people and need to focus on the overall roadmap. Once a rule is accepted, you are responsible for implementing and documenting the rule. You may, alternately, recruit another person to help you implement the rule. The ESLint team member who championed the rule is your resource to help guide you through the rest of this process.
Alternative: Creating Your Own Rules
Remember that ESLint is completely pluggable, which means you can create your own rules and distribute them using plugins. We did this on purpose because we don’t want to be the gatekeepers for all possible rules. Even if we don’t accept a rule into the core, that doesn’t mean you can’t have the exact rule that you want. See the Custom Rules and Create Plugins documentation for more information.

            

            
                Edit this page\n\nPropose a New Rule
                

                Table of Contents
    
        
                
                    
                    Core Rule Guidelines
            		

                    Proposing a Rule
            		

                    Accepting a Rule
            		

                    Implementation is Your Responsibility
            		

                    Alternative: Creating Your Own Rules
            		
                
            
    


                ESLint is all about rules. For most of the project’s lifetime, we’ve had over 200 rules, and that list continues to grow. However, we can’t just accept any proposed rule because all rules need to work cohesively together. As such, we have some guidelines around which rules can be part of the ESLint core and which are better off as custom rules and plugins.
Note: As of 2020, we only accept rules related to new ECMAScript features. We prefer that new rules be implemented in plugins.
Core Rule Guidelines
In general, ESLint core rules must be:

Widely applicable. The rules we distribute need to be of importance to a large number of developers. Individual preferences for uncommon patterns are not supported.
Generic. Rules cannot be so specific that users will have trouble understanding when to use them. A rule is typically too specific if describing what it does requires more than two "and"s (if a and b and c and d, then this rule warns).
Atomic. Rules must function completely on their own. Rules are expressly forbidden from knowing about the state or presence of other rules.
Unique. No two rules can produce the same warning. Overlapping rules confuse end users and there is an expectation that core ESLint rules do not overlap.
Library agnostic. Rules must be based solely on JavaScript runtime environments and not on specific libraries or frameworks. For example, core rules shouldn’t only apply if you’re using jQuery but we may have some rules that apply only if you’re using Node.js (a runtime).
No conflicts. No rule must directly conflict with another rule. For example, if we have a rule requiring semicolons, we cannot also have a rule disallowing semicolons (which is why we have one rule, semi, that does both).

Even though these are the formal criteria for inclusion, each rule is evaluated on its own basis.
Proposing a Rule
If you want to propose a new rule, please see how to create a pull request or submit an issue by filling out a new rule template.
We need all of this information in order to determine whether or not the rule is a good core rule candidate.
Accepting a Rule
In order for a rule to be accepted in the ESLint core, it must:

Fulfill all the criteria listed in the “Core Rule Guidelines” section.
Have an ESLint team member champion inclusion of the rule.
Be related to an ECMAScript feature that has reached stage 4 in the preceding 12 months.

Keep in mind that we have over 200 rules, and that is daunting both for end users and the ESLint team (who has to maintain them). As such, any new rules must be deemed of high importance to be considered for inclusion in ESLint.
Implementation is Your Responsibility
The ESLint team doesn’t implement new rules that are suggested by users because we have a limited number of people and need to focus on the overall roadmap. Once a rule is accepted, you are responsible for implementing and documenting the rule. You may, alternately, recruit another person to help you implement the rule. The ESLint team member who championed the rule is your resource to help guide you through the rest of this process.
Alternative: Creating Your Own Rules
Remember that ESLint is completely pluggable, which means you can create your own rules and distribute them using plugins. We did this on purpose because we don’t want to be the gatekeepers for all possible rules. Even if we don’t accept a rule into the core, that doesn’t mean you can’t have the exact rule that you want. See the Custom Rules and Create Plugins documentation for more information.

            

            
                Edit this page\n\n\n\nPropose a Rule Change
                

                Table of Contents
    
        
                
                    
                    Proposing a Rule Change
            		

                    Accepting a Rule Change
            		

                    Implementation is Your Responsibility
            		
                
            
    


                Occasionally, a core ESLint rule needs to be changed. This is not necessarily a bug, but rather, an enhancement that makes a rule more configurable. In those situations, we will consider making changes to rules.
Proposing a Rule Change
To propose a change to an existing rule, create a pull request or new issue and fill out the template.
We need all of this information in order to determine whether or not the change is a good candidate for inclusion.
Accepting a Rule Change
In order for a rule change to be accepted into ESLint, it must:

Adhere to the Core Rule Guidelines.
Have an ESLint team member champion the change.
Be important enough that rule is deemed incomplete without this change.

Implementation is Your Responsibility
The ESLint team doesn’t implement rule changes that are suggested by users because we have a limited number of people and need to focus on the overall roadmap. Once a rule change is accepted, you are responsible for implementing and documenting it. You may, alternately, recruit another person to help you. The ESLint team member who championed the rule is your resource to help guide you through the rest of this process.

            

            
                Edit this page\n\nPropose a Rule Change
                

                Table of Contents
    
        
                
                    
                    Proposing a Rule Change
            		

                    Accepting a Rule Change
            		

                    Implementation is Your Responsibility
            		
                
            
    


                Occasionally, a core ESLint rule needs to be changed. This is not necessarily a bug, but rather, an enhancement that makes a rule more configurable. In those situations, we will consider making changes to rules.
Proposing a Rule Change
To propose a change to an existing rule, create a pull request or new issue and fill out the template.
We need all of this information in order to determine whether or not the change is a good candidate for inclusion.
Accepting a Rule Change
In order for a rule change to be accepted into ESLint, it must:

Adhere to the Core Rule Guidelines.
Have an ESLint team member champion the change.
Be important enough that rule is deemed incomplete without this change.

Implementation is Your Responsibility
The ESLint team doesn’t implement rule changes that are suggested by users because we have a limited number of people and need to focus on the overall roadmap. Once a rule change is accepted, you are responsible for implementing and documenting it. You may, alternately, recruit another person to help you. The ESLint team member who championed the rule is your resource to help guide you through the rest of this process.

            

            
                Edit this page\n\n\n\nRequest a Change
                

                


                If you’d like to request a change to ESLint, please create a new issue on GitHub. Be sure to include the following information:

The version of ESLint you are using.
The problem you want to solve.
Your take on the correct solution to problem.

If you’re requesting a change to a rule, it’s helpful to include this information as well:

What you did.
What you would like to happen.
What actually happened.

Please include as much detail as possible to help us properly address your issue. If we need to triage issues and constantly ask people for more detail, that’s time taken away from actually fixing issues. Help us be as efficient as possible by including a lot of detail in your issues.
Note: If you just have a question that won’t necessarily result in a change to ESLint, such as asking how something works or how to contribute, please open a discussion or stop by our Discord server instead of filing an issue.

            

            
                Edit this page\n\nRequest a Change
                

                


                If you’d like to request a change to ESLint, please create a new issue on GitHub. Be sure to include the following information:

The version of ESLint you are using.
The problem you want to solve.
Your take on the correct solution to problem.

If you’re requesting a change to a rule, it’s helpful to include this information as well:

What you did.
What you would like to happen.
What actually happened.

Please include as much detail as possible to help us properly address your issue. If we need to triage issues and constantly ask people for more detail, that’s time taken away from actually fixing issues. Help us be as efficient as possible by including a lot of detail in your issues.
Note: If you just have a question that won’t necessarily result in a change to ESLint, such as asking how something works or how to contribute, please open a discussion or stop by our Discord server instead of filing an issue.

            

            
                Edit this page\n\n\n\nArchitecture
                

                Table of Contents
    
        
                
                    
                    The cli object
            		

                    The CLIEngine object
            		

                    The Linter object
            		

                    Rules
            		
                
            
    


                


At a high level, there are a few key parts to ESLint:

bin/eslint.js - this is the file that actually gets executed with the command line utility. It’s a dumb wrapper that does nothing more than bootstrap ESLint, passing the command line arguments to cli. This is intentionally small so as not to require heavy testing.
lib/api.js - this is the entry point of require("eslint"). This file exposes an object that contains public classes Linter, ESLint, RuleTester, and SourceCode.
lib/cli.js - this is the heart of the ESLint CLI. It takes an array of arguments and then uses eslint to execute the commands. By keeping this as a separate utility, it allows others to effectively call ESLint from within another Node.js program as if it were done on the command line. The main call is cli.execute(). This is also the part that does all the file reading, directory traversing, input, and output.
lib/cli-engine/ - this module is CLIEngine class that finds source code files and configuration files then does code verifying with the Linter class. This includes the loading logic of configuration files, parsers, plugins, and formatters.
lib/linter/ - this module is the core Linter class that does code verifying based on configuration options. This file does no file I/O and does not interact with the console at all. For other Node.js programs that have JavaScript text to verify, they would be able to use this interface directly.
lib/rule-tester/ - this module is RuleTester class that is a wrapper around Mocha so that rules can be unit tested. This class lets us write consistently formatted tests for each rule that is implemented and be confident that each of the rules work. The RuleTester interface was modeled after Mocha and works with Mocha’s global testing methods. RuleTester can also be modified to work with other testing frameworks.
lib/source-code/ - this module is SourceCode class that is used to represent the parsed source code. It takes in source code and the Program node of the AST representing the code.
lib/rules/ - this contains built-in rules that verify source code.

The cli object
The cli object is the API for the command line interface. Literally, the bin/eslint.js file simply passes arguments to the cli object and then sets process.exitCode to the returned exit code.
The main method is cli.execute(), which accepts an array of strings that represent the command line options (as if process.argv were passed without the first two arguments). If you want to run ESLint from inside of another program and have it act like the CLI, then cli is the object to use.
This object’s responsibilities include:

Interpreting command line arguments.
Reading from the file system.
Outputting to the console.
Outputting to the filesystem.
Use a formatter.
Returning the correct exit code.

This object may not:

Call process.exit() directly.
Perform any asynchronous operations.

The CLIEngine object
The CLIEngine type represents the core functionality of the CLI except that it reads nothing from the command line and doesn’t output anything by default. Instead, it accepts many (but not all) of the arguments that are passed into the CLI. It reads both configuration and source files as well as managing the environment that is passed into the Linter object.
The main method of the CLIEngine is executeOnFiles(), which accepts an array of file and directory names to run the linter on.
This object’s responsibilities include:

Managing the execution environment for Linter.
Reading from the file system.
Reading configuration information from config files (including .eslintrc and package.json).

This object may not:

Call process.exit() directly.
Perform any asynchronous operations.
Output to the console.
Use formatters.

The Linter object
The main method of the Linter object is verify() and accepts two arguments: the source text to verify and a configuration object (the baked configuration of the given configuration file plus command line options). The method first parses the given text with espree (or whatever the configured parser is) and retrieves the AST. The AST is produced with both line/column and range locations which are useful for reporting location of issues and retrieving the source text related to an AST node, respectively.
Once the AST is available, estraverse is used to traverse the AST from top to bottom. At each node, the Linter object emits an event that has the same name as the node type (i.e., “Identifier”, “WithStatement”, etc.). On the way back up the subtree, an event is emitted with the AST type name and suffixed with “:exit”, such as “Identifier:exit” - this allows rules to take action both on the way down and on the way up in the traversal. Each event is emitted with the appropriate AST node available.
This object’s responsibilities include:

Inspecting JavaScript code strings.
Creating an AST for the code.
Executing rules on the AST.
Reporting back the results of the execution.

This object may not:

Call process.exit() directly.
Perform any asynchronous operations.
Use Node.js-specific features.
Access the file system.
Call console.log() or any other similar method.

Rules
Individual rules are the most specialized part of the ESLint architecture. Rules can do very little, they are simply a set of instructions executed against an AST that is provided. They do get some context information passed in, but the primary responsibility of a rule is to inspect the AST and report warnings.
These objects’ responsibilities are:

Inspect the AST for specific patterns.
Reporting warnings when certain patterns are found.

These objects may not:

Call process.exit() directly.
Perform any asynchronous operations.
Use Node.js-specific features.
Access the file system.
Call console.log() or any other similar method.


            

            
                Edit this page\n\nArchitecture
                

                Table of Contents
    
        
                
                    
                    The cli object
            		

                    The CLIEngine object
            		

                    The Linter object
            		

                    Rules
            		
                
            
    


                


At a high level, there are a few key parts to ESLint:

bin/eslint.js - this is the file that actually gets executed with the command line utility. It’s a dumb wrapper that does nothing more than bootstrap ESLint, passing the command line arguments to cli. This is intentionally small so as not to require heavy testing.
lib/api.js - this is the entry point of require("eslint"). This file exposes an object that contains public classes Linter, ESLint, RuleTester, and SourceCode.
lib/cli.js - this is the heart of the ESLint CLI. It takes an array of arguments and then uses eslint to execute the commands. By keeping this as a separate utility, it allows others to effectively call ESLint from within another Node.js program as if it were done on the command line. The main call is cli.execute(). This is also the part that does all the file reading, directory traversing, input, and output.
lib/cli-engine/ - this module is CLIEngine class that finds source code files and configuration files then does code verifying with the Linter class. This includes the loading logic of configuration files, parsers, plugins, and formatters.
lib/linter/ - this module is the core Linter class that does code verifying based on configuration options. This file does no file I/O and does not interact with the console at all. For other Node.js programs that have JavaScript text to verify, they would be able to use this interface directly.
lib/rule-tester/ - this module is RuleTester class that is a wrapper around Mocha so that rules can be unit tested. This class lets us write consistently formatted tests for each rule that is implemented and be confident that each of the rules work. The RuleTester interface was modeled after Mocha and works with Mocha’s global testing methods. RuleTester can also be modified to work with other testing frameworks.
lib/source-code/ - this module is SourceCode class that is used to represent the parsed source code. It takes in source code and the Program node of the AST representing the code.
lib/rules/ - this contains built-in rules that verify source code.

The cli object
The cli object is the API for the command line interface. Literally, the bin/eslint.js file simply passes arguments to the cli object and then sets process.exitCode to the returned exit code.
The main method is cli.execute(), which accepts an array of strings that represent the command line options (as if process.argv were passed without the first two arguments). If you want to run ESLint from inside of another program and have it act like the CLI, then cli is the object to use.
This object’s responsibilities include:

Interpreting command line arguments.
Reading from the file system.
Outputting to the console.
Outputting to the filesystem.
Use a formatter.
Returning the correct exit code.

This object may not:

Call process.exit() directly.
Perform any asynchronous operations.

The CLIEngine object
The CLIEngine type represents the core functionality of the CLI except that it reads nothing from the command line and doesn’t output anything by default. Instead, it accepts many (but not all) of the arguments that are passed into the CLI. It reads both configuration and source files as well as managing the environment that is passed into the Linter object.
The main method of the CLIEngine is executeOnFiles(), which accepts an array of file and directory names to run the linter on.
This object’s responsibilities include:

Managing the execution environment for Linter.
Reading from the file system.
Reading configuration information from config files (including .eslintrc and package.json).

This object may not:

Call process.exit() directly.
Perform any asynchronous operations.
Output to the console.
Use formatters.

The Linter object
The main method of the Linter object is verify() and accepts two arguments: the source text to verify and a configuration object (the baked configuration of the given configuration file plus command line options). The method first parses the given text with espree (or whatever the configured parser is) and retrieves the AST. The AST is produced with both line/column and range locations which are useful for reporting location of issues and retrieving the source text related to an AST node, respectively.
Once the AST is available, estraverse is used to traverse the AST from top to bottom. At each node, the Linter object emits an event that has the same name as the node type (i.e., “Identifier”, “WithStatement”, etc.). On the way back up the subtree, an event is emitted with the AST type name and suffixed with “:exit”, such as “Identifier:exit” - this allows rules to take action both on the way down and on the way up in the traversal. Each event is emitted with the appropriate AST node available.
This object’s responsibilities include:

Inspecting JavaScript code strings.
Creating an AST for the code.
Executing rules on the AST.
Reporting back the results of the execution.

This object may not:

Call process.exit() directly.
Perform any asynchronous operations.
Use Node.js-specific features.
Access the file system.
Call console.log() or any other similar method.

Rules
Individual rules are the most specialized part of the ESLint architecture. Rules can do very little, they are simply a set of instructions executed against an AST that is provided. They do get some context information passed in, but the primary responsibility of a rule is to inspect the AST and report warnings.
These objects’ responsibilities are:

Inspect the AST for specific patterns.
Reporting warnings when certain patterns are found.

These objects may not:

Call process.exit() directly.
Perform any asynchronous operations.
Use Node.js-specific features.
Access the file system.
Call console.log() or any other similar method.


            

            
                Edit this page\n\n\n\nSet up a Development Environment
                

                Table of Contents
    
        
                
                    
                    Step 1: Install Node.js
            		

                    Step 2: Fork and Checkout Your Own ESLint Repository
            		

                    Step 3: Add the Upstream Source
            		

                    Step 4: Install the Yeoman Generator
            		

                    Step 5: Run the Tests
            		

                    Reference Information
            
                
                    
                    Directory Structure
            		

                    Workflow
            		

                    Build Scripts
            
                
                    
                    npm test
            		

                    npm run lint
            		

                    npm run webpack
            		
                
            		
                
            		
                
            
    


                ESLint has a very lightweight development environment that makes updating code fast and easy. This is a step-by-step guide to setting up a local development environment that will let you contribute back to the project.
Step 1: Install Node.js
Go to https://nodejs.org/ to download and install the latest stable version for your operating system.
Most of the installers already come with npm but if for some reason npm doesn’t work on your system, you can install it manually using the instructions on the site.
Step 2: Fork and Checkout Your Own ESLint Repository
Go to https://github.com/eslint/eslint and click the “Fork” button. Follow the GitHub documentation for forking and cloning.
Clone your fork:


    git clone https://github.com/<Your GitHub Username>/eslint
1
    
        Copy code to clipboard
        
    

Once you’ve cloned the repository, run npm install to get all the necessary dependencies:


    cd eslint
1
    
        Copy code to clipboard
        
    


   
      npm
      yarn
      pnpm
      bun
   
    
        npm


    npm install
1
    
        Copy code to clipboard
        
    


   
      yarn


    yarn add
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm add
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bun add
1
    
        Copy code to clipboard
        
    

   

You must be connected to the Internet for this step to work. You’ll see a lot of utilities being downloaded.
Note: It’s a good idea to re-run npm install whenever you pull from the main repository to ensure you have the latest development dependencies.
Step 3: Add the Upstream Source
The upstream source is the main ESLint repository where active development happens. While you won’t have push access to upstream, you will have pull access, allowing you to pull in the latest code whenever you want.
To add the upstream source for ESLint, run the following in your repository:


    git remote add upstream git@github.com:eslint/eslint.git
1
    
        Copy code to clipboard
        
    

Now, the remote upstream points to the upstream source.
Step 4: Install the Yeoman Generator
Yeoman is a scaffold generator that ESLint uses to help streamline development of new rules. If you don’t already have Yeoman installed, you can install it via npm:

   
      npm
      yarn
      pnpm
      bun
   
    
        npm


    npm install --global yo
1
    
        Copy code to clipboard
        
    


   
      yarn


    yarn global add yo
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm add --global yo
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bun add --global yo
1
    
        Copy code to clipboard
        
    

   

Then, you can install the ESLint Yeoman generator:

   
      npm
      yarn
      pnpm
      bun
   
    
        npm


    npm install --global generator-eslint
1
    
        Copy code to clipboard
        
    


   
      yarn


    yarn global add generator-eslint
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm add --global generator-eslint
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bun add --global generator-eslint
1
    
        Copy code to clipboard
        
    

   

Please see the generator documentation for instructions on how to use it.
Step 5: Run the Tests
Running the tests is the best way to ensure you have correctly set up your development environment. Make sure you’re in the eslint directory and run:


    npm test
1
    
        Copy code to clipboard
        
    

The testing takes a few minutes to complete. If any tests fail, that likely means one or more parts of the environment setup didn’t complete correctly. The upstream tests always pass.
Reference Information
Directory Structure
The ESLint directory and file structure is as follows:

bin - executable files that are available when ESLint is installed.
conf - default configuration information.
docs - documentation for the project.
lib - contains the source code.

formatters - all source files defining formatters.
rules - all source files defining rules.


tests - the main unit test folder.

lib - tests for the source code.

formatters - tests for the formatters.
rules - tests for the rules.





Workflow
Once you have your development environment installed, you can make and submit changes to the ESLint source files. Doing this successfully requires careful adherence to our pull-request submission workflow.
Build Scripts
ESLint has several build scripts that help with various parts of development.
npm test
The primary script to use is npm test, which does several things:

Lints all JavaScript (including tests) and JSON.
Runs all tests on Node.js.
Checks code coverage targets.
Generates build/eslint.js for use in a browser.
Runs a subset of tests in PhantomJS.

Be sure to run this after making changes and before sending a pull request with your changes.
Note: The full code coverage report is output into /coverage.
npm run lint
Runs just the JavaScript and JSON linting on the repository.
npm run webpack
Generates build/eslint.js, a version of ESLint for use in the browser.

            

            
                Edit this page\n\nSet up a Development Environment
                

                Table of Contents
    
        
                
                    
                    Step 1: Install Node.js
            		

                    Step 2: Fork and Checkout Your Own ESLint Repository
            		

                    Step 3: Add the Upstream Source
            		

                    Step 4: Install the Yeoman Generator
            		

                    Step 5: Run the Tests
            		

                    Reference Information
            
                
                    
                    Directory Structure
            		

                    Workflow
            		

                    Build Scripts
            
                
                    
                    npm test
            		

                    npm run lint
            		

                    npm run webpack
            		
                
            		
                
            		
                
            
    


                ESLint has a very lightweight development environment that makes updating code fast and easy. This is a step-by-step guide to setting up a local development environment that will let you contribute back to the project.
Step 1: Install Node.js
Go to https://nodejs.org/ to download and install the latest stable version for your operating system.
Most of the installers already come with npm but if for some reason npm doesn’t work on your system, you can install it manually using the instructions on the site.
Step 2: Fork and Checkout Your Own ESLint Repository
Go to https://github.com/eslint/eslint and click the “Fork” button. Follow the GitHub documentation for forking and cloning.
Clone your fork:


    git clone https://github.com/<Your GitHub Username>/eslint
1
    
        Copy code to clipboard
        
    

Once you’ve cloned the repository, run npm install to get all the necessary dependencies:


    cd eslint
1
    
        Copy code to clipboard
        
    


   
      npm
      yarn
      pnpm
      bun
   
    
        npm


    npm install
1
    
        Copy code to clipboard
        
    


   
      yarn


    yarn add
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm add
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bun add
1
    
        Copy code to clipboard
        
    

   

You must be connected to the Internet for this step to work. You’ll see a lot of utilities being downloaded.
Note: It’s a good idea to re-run npm install whenever you pull from the main repository to ensure you have the latest development dependencies.
Step 3: Add the Upstream Source
The upstream source is the main ESLint repository where active development happens. While you won’t have push access to upstream, you will have pull access, allowing you to pull in the latest code whenever you want.
To add the upstream source for ESLint, run the following in your repository:


    git remote add upstream git@github.com:eslint/eslint.git
1
    
        Copy code to clipboard
        
    

Now, the remote upstream points to the upstream source.
Step 4: Install the Yeoman Generator
Yeoman is a scaffold generator that ESLint uses to help streamline development of new rules. If you don’t already have Yeoman installed, you can install it via npm:

   
      npm
      yarn
      pnpm
      bun
   
    
        npm


    npm install --global yo
1
    
        Copy code to clipboard
        
    


   
      yarn


    yarn global add yo
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm add --global yo
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bun add --global yo
1
    
        Copy code to clipboard
        
    

   

Then, you can install the ESLint Yeoman generator:

   
      npm
      yarn
      pnpm
      bun
   
    
        npm


    npm install --global generator-eslint
1
    
        Copy code to clipboard
        
    


   
      yarn


    yarn global add generator-eslint
1
    
        Copy code to clipboard
        
    

   
   
      pnpm


    pnpm add --global generator-eslint
1
    
        Copy code to clipboard
        
    

   
   
      bun


    bun add --global generator-eslint
1
    
        Copy code to clipboard
        
    

   

Please see the generator documentation for instructions on how to use it.
Step 5: Run the Tests
Running the tests is the best way to ensure you have correctly set up your development environment. Make sure you’re in the eslint directory and run:


    npm test
1
    
        Copy code to clipboard
        
    

The testing takes a few minutes to complete. If any tests fail, that likely means one or more parts of the environment setup didn’t complete correctly. The upstream tests always pass.
Reference Information
Directory Structure
The ESLint directory and file structure is as follows:

bin - executable files that are available when ESLint is installed.
conf - default configuration information.
docs - documentation for the project.
lib - contains the source code.

formatters - all source files defining formatters.
rules - all source files defining rules.


tests - the main unit test folder.

lib - tests for the source code.

formatters - tests for the formatters.
rules - tests for the rules.





Workflow
Once you have your development environment installed, you can make and submit changes to the ESLint source files. Doing this successfully requires careful adherence to our pull-request submission workflow.
Build Scripts
ESLint has several build scripts that help with various parts of development.
npm test
The primary script to use is npm test, which does several things:

Lints all JavaScript (including tests) and JSON.
Runs all tests on Node.js.
Checks code coverage targets.
Generates build/eslint.js for use in a browser.
Runs a subset of tests in PhantomJS.

Be sure to run this after making changes and before sending a pull request with your changes.
Note: The full code coverage report is output into /coverage.
npm run lint
Runs just the JavaScript and JSON linting on the repository.
npm run webpack
Generates build/eslint.js, a version of ESLint for use in the browser.

            

            
                Edit this page\n\n\n\nRun the Tests
                

                Table of Contents
    
        
                
                    
                    Running Individual Tests
            		

                    More Control on Unit Testing
            		
                
            
    


                Most parts of ESLint have unit tests associated with them. Unit tests are written using Mocha and are required when making contributions to ESLint. You’ll find all of the unit tests in the tests directory.
When you first get the source code, you need to run npm install once initially to set ESLint for development. Once you’ve done that, you can run the tests via:


    npm test
1
    
        Copy code to clipboard
        
    

This automatically starts Mocha and runs all tests in the tests directory. You need only add yours and it will automatically be picked up when running tests.
Running Individual Tests
If you want to quickly run just one test file, you can do so by running Mocha directly and passing in the filename. For example:


    npm run test:cli tests/lib/rules/no-undef.js
1
    
        Copy code to clipboard
        
    

If you want to run just one or a subset of RuleTester test cases, add only: true to each test case or wrap the test case in RuleTester.only(...) to add it automatically:


    ruleTester.run("my-rule", myRule, {
	valid: [
		RuleTester.only("const valid = 42;"),
		// Other valid cases
	],
	invalid: [
		{
			code: "const invalid = 42;",
			only: true,
		},
		// Other invalid cases
	],
});
12345678910111213
    
        Copy code to clipboard
        
    

Running individual tests is useful when you’re working on a specific bug and iterating on the solution. You should be sure to run npm test before submitting a pull request. npm test uses Mocha’s --forbid-only option to prevent only tests from passing full test runs.
More Control on Unit Testing
npm run test:cli is an alias of the Mocha cli in ./node_modules/.bin/mocha. Options are available to be provided to help to better control the test to run.
The default timeout for tests in npm test is 10000ms. You may change the timeout by providing ESLINT_MOCHA_TIMEOUT environment variable, for example:


    ESLINT_MOCHA_TIMEOUT=20000 npm test
1
    
        Copy code to clipboard
        
    


            

            
                Edit this page\n\nRun the Tests
                

                Table of Contents
    
        
                
                    
                    Running Individual Tests
            		

                    More Control on Unit Testing
            		
                
            
    


                Most parts of ESLint have unit tests associated with them. Unit tests are written using Mocha and are required when making contributions to ESLint. You’ll find all of the unit tests in the tests directory.
When you first get the source code, you need to run npm install once initially to set ESLint for development. Once you’ve done that, you can run the tests via:


    npm test
1
    
        Copy code to clipboard
        
    

This automatically starts Mocha and runs all tests in the tests directory. You need only add yours and it will automatically be picked up when running tests.
Running Individual Tests
If you want to quickly run just one test file, you can do so by running Mocha directly and passing in the filename. For example:


    npm run test:cli tests/lib/rules/no-undef.js
1
    
        Copy code to clipboard
        
    

If you want to run just one or a subset of RuleTester test cases, add only: true to each test case or wrap the test case in RuleTester.only(...) to add it automatically:


    ruleTester.run("my-rule", myRule, {
	valid: [
		RuleTester.only("const valid = 42;"),
		// Other valid cases
	],
	invalid: [
		{
			code: "const invalid = 42;",
			only: true,
		},
		// Other invalid cases
	],
});
12345678910111213
    
        Copy code to clipboard
        
    

Running individual tests is useful when you’re working on a specific bug and iterating on the solution. You should be sure to run npm test before submitting a pull request. npm test uses Mocha’s --forbid-only option to prevent only tests from passing full test runs.
More Control on Unit Testing
npm run test:cli is an alias of the Mocha cli in ./node_modules/.bin/mocha. Options are available to be provided to help to better control the test to run.
The default timeout for tests in npm test is 10000ms. You may change the timeout by providing ESLINT_MOCHA_TIMEOUT environment variable, for example:


    ESLINT_MOCHA_TIMEOUT=20000 npm test
1
    
        Copy code to clipboard
        
    


            

            
                Edit this page\n\n\n\nPackage.json Conventions
                

                Table of Contents
    
        
                
                    
                    Names
            		

                    Order
            		

                    Main Script Names
            
                
                    
                    Build
            		

                    Fetch
            		

                    Release
            		

                    Lint
            		

                    Start
            		

                    Test
            		
                
            		

                    Modifiers
            
                
                    
                    Fix
            		

                    Target
            		

                    Options
            		

                    Watch
            		
                
            		
                
            
    


                The following applies to the “scripts” section of package.json files.
Names
npm script names MUST contain only lower case letters, : to separate parts, - to separate words, and + to separate file extensions. Each part name SHOULD be either a full English word (e.g. coverage not cov) or a well-known initialism in all lowercase (e.g. wasm).
Here is a summary of the proposal in ABNF.


    name         = life-cycle / main target? option* ":watch"?
life-cycle   = "prepare" / "preinstall" / "install" / "postinstall" / "prepublish" / "preprepare" / "prepare" / "postprepare" / "prepack" / "postpack" / "prepublishOnly"
main         = "build" / "lint" ":fix"? / "release" / "start" / "test" / "fetch"
target       = ":" word ("-" word)* / extension ("+" extension)*
option       = ":" word ("-" word)*
word         = ALPHA +
extension    = ( ALPHA / DIGIT )+
1234567
    
        Copy code to clipboard
        
    

Order
The script names MUST appear in the package.json file in alphabetical order. The other conventions outlined in this document ensure that alphabetical order will coincide with logical groupings.
Main Script Names
With the exception of npm life cycle scripts all script names MUST begin with one of the following names.
Build
Scripts that generate a set of files from source code and / or data MUST have names that begin with build.
If a package contains any build:* scripts, there MAY be a script named build. If so, SHOULD produce the same output as running each of the build scripts individually. It MUST produce a subset of the output from running those scripts.
Fetch
Scripts that generate a set of files from external data or resources MUST have names that begin with fetch.
If a package contains any fetch:* scripts, there MAY be a script named fetch. If so, it SHOULD produce the same output as running each of the fetch scripts individually. It MUST produce a subset of the output from running those scripts.
Release
Scripts that have public side effects (publishing the web site, committing to Git, etc.) MUST begin with release.
Lint
Scripts that statically analyze files (mostly, but not limited to running eslint itself) MUST have names that begin with lint.
If a package contains any lint:* scripts, there SHOULD be a script named lint and it MUST run all of the checks that would have been run if each lint:* script was called individually.
If fixing is available, a linter MUST NOT apply fixes UNLESS the script contains the :fix modifier (see below).
Start
A start script is used to start a server. As of this writing, no ESLint package has more than one start script, so there’s no need start to have any modifiers.
Test
Scripts that execute code in order to ensure the actual behavior matches expected behavior MUST have names that begin with test.
If a package contains any test:* scripts, there SHOULD be a script named test and it MUST run of all of the tests that would have been run if each test:* script was called individually.
A test script SHOULD NOT include linting.
A test script SHOULD report test coverage when possible.
Modifiers
One or more of the following modifiers MAY be appended to the standard script names above. If a target has modifiers, they MUST be in the order in which they appear below (e.g. lint:fix:js:watch not lint:watch:js:fix).
Fix
If it’s possible for a linter to fix problems that it finds, add a copy of the script with :fix appended to the end that also fixes.
Target
The name of the target of the action being run. In the case of a build script, it SHOULD identify the build artifact(s), e.g. “javascript” or “css” or “website”. In the case of a lint or test script, it SHOULD identify the item(s) being linted or tested. In the case of a start script, it SHOULD identify which server is starting.
A target MAY refer to a list of affected file extensions (such as cjs or less) delimited by a +. If there is more than one extension, the list SHOULD be alphabetized. When a file extension has variants (such as cjs for CommonJS and mjs for ESM), the common part of the extension MAY be used instead of explicitly listing out all of the variants (e.g. js instead of cjs+jsx+mjs).
The target SHOULD NOT refer to name of the name of the tool that’s performing the action (eleventy, webpack, etc.).
Options
Additional options that don’t fit under the other modifiers.
Watch
If a script watches the filesystem and responds to changes, add :watch to the script name.

            

            
                Edit this page\n\nPackage.json Conventions
                

                Table of Contents
    
        
                
                    
                    Names
            		

                    Order
            		

                    Main Script Names
            
                
                    
                    Build
            		

                    Fetch
            		

                    Release
            		

                    Lint
            		

                    Start
            		

                    Test
            		
                
            		

                    Modifiers
            
                
                    
                    Fix
            		

                    Target
            		

                    Options
            		

                    Watch
            		
                
            		
                
            
    


                The following applies to the “scripts” section of package.json files.
Names
npm script names MUST contain only lower case letters, : to separate parts, - to separate words, and + to separate file extensions. Each part name SHOULD be either a full English word (e.g. coverage not cov) or a well-known initialism in all lowercase (e.g. wasm).
Here is a summary of the proposal in ABNF.


    name         = life-cycle / main target? option* ":watch"?
life-cycle   = "prepare" / "preinstall" / "install" / "postinstall" / "prepublish" / "preprepare" / "prepare" / "postprepare" / "prepack" / "postpack" / "prepublishOnly"
main         = "build" / "lint" ":fix"? / "release" / "start" / "test" / "fetch"
target       = ":" word ("-" word)* / extension ("+" extension)*
option       = ":" word ("-" word)*
word         = ALPHA +
extension    = ( ALPHA / DIGIT )+
1234567
    
        Copy code to clipboard
        
    

Order
The script names MUST appear in the package.json file in alphabetical order. The other conventions outlined in this document ensure that alphabetical order will coincide with logical groupings.
Main Script Names
With the exception of npm life cycle scripts all script names MUST begin with one of the following names.
Build
Scripts that generate a set of files from source code and / or data MUST have names that begin with build.
If a package contains any build:* scripts, there MAY be a script named build. If so, SHOULD produce the same output as running each of the build scripts individually. It MUST produce a subset of the output from running those scripts.
Fetch
Scripts that generate a set of files from external data or resources MUST have names that begin with fetch.
If a package contains any fetch:* scripts, there MAY be a script named fetch. If so, it SHOULD produce the same output as running each of the fetch scripts individually. It MUST produce a subset of the output from running those scripts.
Release
Scripts that have public side effects (publishing the web site, committing to Git, etc.) MUST begin with release.
Lint
Scripts that statically analyze files (mostly, but not limited to running eslint itself) MUST have names that begin with lint.
If a package contains any lint:* scripts, there SHOULD be a script named lint and it MUST run all of the checks that would have been run if each lint:* script was called individually.
If fixing is available, a linter MUST NOT apply fixes UNLESS the script contains the :fix modifier (see below).
Start
A start script is used to start a server. As of this writing, no ESLint package has more than one start script, so there’s no need start to have any modifiers.
Test
Scripts that execute code in order to ensure the actual behavior matches expected behavior MUST have names that begin with test.
If a package contains any test:* scripts, there SHOULD be a script named test and it MUST run of all of the tests that would have been run if each test:* script was called individually.
A test script SHOULD NOT include linting.
A test script SHOULD report test coverage when possible.
Modifiers
One or more of the following modifiers MAY be appended to the standard script names above. If a target has modifiers, they MUST be in the order in which they appear below (e.g. lint:fix:js:watch not lint:watch:js:fix).
Fix
If it’s possible for a linter to fix problems that it finds, add a copy of the script with :fix appended to the end that also fixes.
Target
The name of the target of the action being run. In the case of a build script, it SHOULD identify the build artifact(s), e.g. “javascript” or “css” or “website”. In the case of a lint or test script, it SHOULD identify the item(s) being linted or tested. In the case of a start script, it SHOULD identify which server is starting.
A target MAY refer to a list of affected file extensions (such as cjs or less) delimited by a +. If there is more than one extension, the list SHOULD be alphabetized. When a file extension has variants (such as cjs for CommonJS and mjs for ESM), the common part of the extension MAY be used instead of explicitly listing out all of the variants (e.g. js instead of cjs+jsx+mjs).
The target SHOULD NOT refer to name of the name of the tool that’s performing the action (eleventy, webpack, etc.).
Options
Additional options that don’t fit under the other modifiers.
Watch
If a script watches the filesystem and responds to changes, add :watch to the script name.

            

            
                Edit this page\n\n\n\nWork on Issues
                

                Table of Contents
    
        
                
                    
                    Issue Labels
            		

                    Starting Work
            		
                
            
    


                Our public issues tracker lists all of the things we plan on doing as well as suggestions from the community. Before starting to work on an issue, be sure you read through the rest of this page.
Issue Labels
We use labels to indicate the status of issues. The most complete documentation on the labels is found in the Maintain ESLint documentation, but most contributors should find the information on this page sufficient. The most important questions that labels can help you, as a contributor, answer are:


Is this issue available for me to work on? If you have little or no experience contributing to ESLint, the good first issue label marks appropriate issues. Otherwise, the help wanted label is an invitation to work on the issue. If you have more experience, you can try working on other issues labeled accepted. Conversely, issues not yet ready to work on are labeled triage, evaluating, and/or needs bikeshedding, and issues that cannot currently be worked on because of something else, such as a bug in a dependency, are labeled blocked.


What is this issue about? Labels describing the nature of issues include bug, enhancement, feature, question, rule, documentation, core, build, cli, infrastructure, breaking, and chore. These are documented in Maintain ESLint.


What is the priority of this issue? Because we have a lot of issues, we prioritize certain issues above others. The following is the list of priorities, from highest to lowest:

Bugs - problems with the project are actively affecting users. We want to get these resolved as quickly as possible.
Documentation - documentation issues are a type of bug in that they actively affect current users. As such, we want to address documentation issues as quickly as possible.
Features - new functionality that will aid users in the future.
Enhancements - requested improvements for existing functionality.
Other - anything else.

Some issues have had monetary rewards attached to them. Those are labeled bounty. Bounties are assigned via BountySource.


Starting Work
If you’re going to work on an issue, please add a comment to that issue saying so and indicating when you think you will complete it. It will help us to avoid duplication of effort. Some examples of good comments are:

“I’ll take a look at this over the weekend.”
“I’m going to do this, give me two weeks.”
“Working on this” (as in, I’m working on it right now)

If an issue has already been claimed by someone, please be respectful of that person’s desire to complete the work and don’t work on it unless you verify that they are no longer interested.
If you find you can’t finish the work, then simply add a comment letting people know, for example:

“Sorry, it looks like I don’t have time to do this.”
“I thought I knew enough to fix this, but it turns out I don’t.”

No one will blame you for backing out of an issue if you are unable to complete it. We just want to keep the process moving along as efficiently as possible.

            

            
                Edit this page\n\nWork on Issues
                

                Table of Contents
    
        
                
                    
                    Issue Labels
            		

                    Starting Work
            		
                
            
    


                Our public issues tracker lists all of the things we plan on doing as well as suggestions from the community. Before starting to work on an issue, be sure you read through the rest of this page.
Issue Labels
We use labels to indicate the status of issues. The most complete documentation on the labels is found in the Maintain ESLint documentation, but most contributors should find the information on this page sufficient. The most important questions that labels can help you, as a contributor, answer are:


Is this issue available for me to work on? If you have little or no experience contributing to ESLint, the good first issue label marks appropriate issues. Otherwise, the help wanted label is an invitation to work on the issue. If you have more experience, you can try working on other issues labeled accepted. Conversely, issues not yet ready to work on are labeled triage, evaluating, and/or needs bikeshedding, and issues that cannot currently be worked on because of something else, such as a bug in a dependency, are labeled blocked.


What is this issue about? Labels describing the nature of issues include bug, enhancement, feature, question, rule, documentation, core, build, cli, infrastructure, breaking, and chore. These are documented in Maintain ESLint.


What is the priority of this issue? Because we have a lot of issues, we prioritize certain issues above others. The following is the list of priorities, from highest to lowest:

Bugs - problems with the project are actively affecting users. We want to get these resolved as quickly as possible.
Documentation - documentation issues are a type of bug in that they actively affect current users. As such, we want to address documentation issues as quickly as possible.
Features - new functionality that will aid users in the future.
Enhancements - requested improvements for existing functionality.
Other - anything else.

Some issues have had monetary rewards attached to them. Those are labeled bounty. Bounties are assigned via BountySource.


Starting Work
If you’re going to work on an issue, please add a comment to that issue saying so and indicating when you think you will complete it. It will help us to avoid duplication of effort. Some examples of good comments are:

“I’ll take a look at this over the weekend.”
“I’m going to do this, give me two weeks.”
“Working on this” (as in, I’m working on it right now)

If an issue has already been claimed by someone, please be respectful of that person’s desire to complete the work and don’t work on it unless you verify that they are no longer interested.
If you find you can’t finish the work, then simply add a comment letting people know, for example:

“Sorry, it looks like I don’t have time to do this.”
“I thought I knew enough to fix this, but it turns out I don’t.”

No one will blame you for backing out of an issue if you are unable to complete it. We just want to keep the process moving along as efficiently as possible.

            

            
                Edit this page\n\n\n\nSubmit a Pull Request
                

                Table of Contents
    
        
                
                    
                    Getting Started
            		

                    Working with Code
            
                
                    
                    Step 1: Create a new branch
            		

                    Step 2: Make your changes
            		

                    Step 3: Rebase onto upstream
            		

                    Step 4: Run the tests
            		

                    Step 5: Double check your submission
            		

                    Step 6: Push your changes
            		

                    Step 7: Send the pull request
            		
                
            		

                    Following Up
            
                
                    
                    Updating the Pull Request Title
            		

                    Updating the Code
            		

                    Rebasing
            		
                
            		
                
            
    


                If you want to contribute to an ESLint repo, please use a GitHub pull request. This is the fastest way for us to evaluate your code and to merge it into the code base. Please don’t file an issue with snippets of code. Doing so means that we need to manually merge the changes in and update any appropriate tests. That decreases the likelihood that your code is going to get included in a timely manner. Please use pull requests.
Getting Started
If you’d like to work on a pull request and you’ve never submitted code before, follow these steps:

Set up a development environment.
If you want to implement a breaking change or a change to the core, ensure there’s an issue that describes what you’re doing and the issue has been accepted. You can create a new issue or just indicate you’re working on an existing issue. Bug fixes, documentation changes, and other pull requests do not require an issue.

After that, you’re ready to start working on code.
Working with Code
The process of submitting a pull request is fairly straightforward and generally follows the same pattern each time:

Create a new branch.
Make your changes.
Rebase onto upstream.
Run the tests.
Double check your submission.
Push your changes.
Submit the pull request.

Details about each step are found below.
Step 1: Create a new branch
The first step to sending a pull request is to create a new branch in your ESLint fork. Give the branch a descriptive name that describes what it is you’re fixing, such as:


    git checkout -b issue1234
1
    
        Copy code to clipboard
        
    

You should do all of your development for the issue in this branch.
Note: Do not combine fixes for multiple issues into one branch. Use a separate branch for each issue you’re working on.
Step 2: Make your changes
Make the changes to the code and tests, following the code conventions as you go. Once you have finished, commit the changes to your branch:


    git add -A
git commit
12
    
        Copy code to clipboard
        
    

All ESLint projects follow Conventional Commits for our commit messages. (Note: we don’t support the optional scope in messages.) Here’s an example commit message:


    tag: Short description of what you did

Longer description here if necessary

Fixes #1234
12345
    
        Copy code to clipboard
        
    

The first line of the commit message (the summary) must have a specific format. This format is checked by our build tools. Although the commit message is not checked directly, it will be used to generate the title of a pull request, which will be checked when the pull request is submitted.
The tag is one of the following:

fix - for a bug fix.
feat - either for a backwards-compatible enhancement or for a rule change that adds reported problems.
fix! - for a backwards-incompatible bug fix.
feat! - for a backwards-incompatible enhancement or feature.
docs - changes to documentation only.
chore - for changes that aren’t user-facing.
build - changes to build process only.
refactor - a change that doesn’t affect APIs or user experience.
test - just changes to test files.
ci - changes to our CI configuration files and scripts.
perf - a code change that improves performance.

Use the labels of the issue you are working on to determine the best tag.
The message summary should be a one-sentence description of the change, and it must be 72 characters in length or shorter. If the pull request addresses an issue, then the issue number should be mentioned in the body of the commit message in the format Fixes #1234. If the commit doesn’t completely fix the issue, then use Refs #1234 instead of Fixes #1234.
Here are some good commit message summary examples:


    build: Update Travis to only test Node 0.10
fix: Semi rule incorrectly flagging extra semicolon
chore: Upgrade Esprima to 1.2, switch to using comment attachment
123
    
        Copy code to clipboard
        
    

Step 3: Rebase onto upstream
Before you send the pull request, be sure to rebase onto the upstream source. This ensures your code is running on the latest available code.


    git fetch upstream
git rebase upstream/main
12
    
        Copy code to clipboard
        
    

Step 4: Run the tests
After rebasing, be sure to run all of the tests once again to make sure nothing broke:


    npm test
1
    
        Copy code to clipboard
        
    

If there are any failing tests, update your code until all tests pass.
Step 5: Double check your submission
With your code ready to go, this is a good time to double-check your submission to make sure it follows our conventions. Here are the things to check:

The commit message is properly formatted.
The change introduces no functional regression. Be sure to run npm test to verify your changes before submitting a pull request.
Make separate pull requests for unrelated changes. Large pull requests with multiple unrelated changes may be closed without merging.
All changes must be accompanied by tests, even if the feature you’re working on previously had no tests.
All user-facing changes must be accompanied by appropriate documentation.
Follow the Code Conventions.

Step 6: Push your changes
Next, push your changes to your clone:


    git push origin issue1234
1
    
        Copy code to clipboard
        
    

If you are unable to push because some references are old, do a forced push instead:


    git push -f origin issue1234
1
    
        Copy code to clipboard
        
    

Step 7: Send the pull request
Now you’re ready to send the pull request. Go to your ESLint fork and then follow the GitHub documentation on how to send a pull request.
In order to submit code or documentation to an ESLint project, you’ll be asked to sign our CLA when you send your first pull request. (Read more about the OpenJS Foundation CLA process at https://cla.openjsf.org/.)
The pull request title is autogenerated from the summary of the first commit, but it can be edited before the pull request is submitted.
The description of a pull request should explain what you did and how its effects can be seen.
When a pull request is merged, its commits will be squashed into one single commit. The first line of the squashed commit message will contain the title of the pull request and the pull request number.
The pull request title format is important because the titles are used to create a changelog for each release. The tag and the issue number help to create more consistent and useful changelogs.
Following Up
Once your pull request is sent, it’s time for the team to review it. As such, please make sure to:

Monitor the status of the GitHub Actions CI build for your pull request. If it fails, please investigate why. We cannot merge pull requests that fail the CI build for any reason.
Respond to comments left on the pull request from team members. Remember, we want to help you land your code, so please be receptive to our feedback.
We may ask you to make changes, rebase, or squash your commits.

Updating the Pull Request Title
If your pull request title is in the incorrect format, you’ll be asked to update it. You can do so via the GitHub user interface.
Updating the Code
If we ask you to make code changes, there’s no need to close the pull request and create a new one. Just go back to the branch on your fork and make your changes. Then, when you’re ready, you can add your changes into the branch:


    git add -A
git commit
git push origin issue1234
123
    
        Copy code to clipboard
        
    

When updating the code, it’s usually better to add additional commits to your branch rather than amending the original commit, because reviewers can easily tell which changes were made in response to a particular review. When we merge pull requests, we will squash all the commits from your branch into a single commit on the main branch.
The commit messages in subsequent commits do not need to be in any specific format because these commits do not show up in the changelog.
Rebasing
If your code is out-of-date, we might ask you to rebase. That means we want you to apply your changes on top of the latest upstream code. Make sure you have set up a development environment and then you can rebase using these commands:


    git fetch upstream
git rebase upstream/main
12
    
        Copy code to clipboard
        
    

You might find that there are merge conflicts when you attempt to rebase. Please resolve the conflicts and then do a forced push to your branch:


    git push origin issue1234 -f
1
    
        Copy code to clipboard
        
    


            

            
                Edit this page\n\nSubmit a Pull Request
                

                Table of Contents
    
        
                
                    
                    Getting Started
            		

                    Working with Code
            
                
                    
                    Step 1: Create a new branch
            		

                    Step 2: Make your changes
            		

                    Step 3: Rebase onto upstream
            		

                    Step 4: Run the tests
            		

                    Step 5: Double check your submission
            		

                    Step 6: Push your changes
            		

                    Step 7: Send the pull request
            		
                
            		

                    Following Up
            
                
                    
                    Updating the Pull Request Title
            		

                    Updating the Code
            		

                    Rebasing
            		
                
            		
                
            
    


                If you want to contribute to an ESLint repo, please use a GitHub pull request. This is the fastest way for us to evaluate your code and to merge it into the code base. Please don’t file an issue with snippets of code. Doing so means that we need to manually merge the changes in and update any appropriate tests. That decreases the likelihood that your code is going to get included in a timely manner. Please use pull requests.
Getting Started
If you’d like to work on a pull request and you’ve never submitted code before, follow these steps:

Set up a development environment.
If you want to implement a breaking change or a change to the core, ensure there’s an issue that describes what you’re doing and the issue has been accepted. You can create a new issue or just indicate you’re working on an existing issue. Bug fixes, documentation changes, and other pull requests do not require an issue.

After that, you’re ready to start working on code.
Working with Code
The process of submitting a pull request is fairly straightforward and generally follows the same pattern each time:

Create a new branch.
Make your changes.
Rebase onto upstream.
Run the tests.
Double check your submission.
Push your changes.
Submit the pull request.

Details about each step are found below.
Step 1: Create a new branch
The first step to sending a pull request is to create a new branch in your ESLint fork. Give the branch a descriptive name that describes what it is you’re fixing, such as:


    git checkout -b issue1234
1
    
        Copy code to clipboard
        
    

You should do all of your development for the issue in this branch.
Note: Do not combine fixes for multiple issues into one branch. Use a separate branch for each issue you’re working on.
Step 2: Make your changes
Make the changes to the code and tests, following the code conventions as you go. Once you have finished, commit the changes to your branch:


    git add -A
git commit
12
    
        Copy code to clipboard
        
    

All ESLint projects follow Conventional Commits for our commit messages. (Note: we don’t support the optional scope in messages.) Here’s an example commit message:


    tag: Short description of what you did

Longer description here if necessary

Fixes #1234
12345
    
        Copy code to clipboard
        
    

The first line of the commit message (the summary) must have a specific format. This format is checked by our build tools. Although the commit message is not checked directly, it will be used to generate the title of a pull request, which will be checked when the pull request is submitted.
The tag is one of the following:

fix - for a bug fix.
feat - either for a backwards-compatible enhancement or for a rule change that adds reported problems.
fix! - for a backwards-incompatible bug fix.
feat! - for a backwards-incompatible enhancement or feature.
docs - changes to documentation only.
chore - for changes that aren’t user-facing.
build - changes to build process only.
refactor - a change that doesn’t affect APIs or user experience.
test - just changes to test files.
ci - changes to our CI configuration files and scripts.
perf - a code change that improves performance.

Use the labels of the issue you are working on to determine the best tag.
The message summary should be a one-sentence description of the change, and it must be 72 characters in length or shorter. If the pull request addresses an issue, then the issue number should be mentioned in the body of the commit message in the format Fixes #1234. If the commit doesn’t completely fix the issue, then use Refs #1234 instead of Fixes #1234.
Here are some good commit message summary examples:


    build: Update Travis to only test Node 0.10
fix: Semi rule incorrectly flagging extra semicolon
chore: Upgrade Esprima to 1.2, switch to using comment attachment
123
    
        Copy code to clipboard
        
    

Step 3: Rebase onto upstream
Before you send the pull request, be sure to rebase onto the upstream source. This ensures your code is running on the latest available code.


    git fetch upstream
git rebase upstream/main
12
    
        Copy code to clipboard
        
    

Step 4: Run the tests
After rebasing, be sure to run all of the tests once again to make sure nothing broke:


    npm test
1
    
        Copy code to clipboard
        
    

If there are any failing tests, update your code until all tests pass.
Step 5: Double check your submission
With your code ready to go, this is a good time to double-check your submission to make sure it follows our conventions. Here are the things to check:

The commit message is properly formatted.
The change introduces no functional regression. Be sure to run npm test to verify your changes before submitting a pull request.
Make separate pull requests for unrelated changes. Large pull requests with multiple unrelated changes may be closed without merging.
All changes must be accompanied by tests, even if the feature you’re working on previously had no tests.
All user-facing changes must be accompanied by appropriate documentation.
Follow the Code Conventions.

Step 6: Push your changes
Next, push your changes to your clone:


    git push origin issue1234
1
    
        Copy code to clipboard
        
    

If you are unable to push because some references are old, do a forced push instead:


    git push -f origin issue1234
1
    
        Copy code to clipboard
        
    

Step 7: Send the pull request
Now you’re ready to send the pull request. Go to your ESLint fork and then follow the GitHub documentation on how to send a pull request.
In order to submit code or documentation to an ESLint project, you’ll be asked to sign our CLA when you send your first pull request. (Read more about the OpenJS Foundation CLA process at https://cla.openjsf.org/.)
The pull request title is autogenerated from the summary of the first commit, but it can be edited before the pull request is submitted.
The description of a pull request should explain what you did and how its effects can be seen.
When a pull request is merged, its commits will be squashed into one single commit. The first line of the squashed commit message will contain the title of the pull request and the pull request number.
The pull request title format is important because the titles are used to create a changelog for each release. The tag and the issue number help to create more consistent and useful changelogs.
Following Up
Once your pull request is sent, it’s time for the team to review it. As such, please make sure to:

Monitor the status of the GitHub Actions CI build for your pull request. If it fails, please investigate why. We cannot merge pull requests that fail the CI build for any reason.
Respond to comments left on the pull request from team members. Remember, we want to help you land your code, so please be receptive to our feedback.
We may ask you to make changes, rebase, or squash your commits.

Updating the Pull Request Title
If your pull request title is in the incorrect format, you’ll be asked to update it. You can do so via the GitHub user interface.
Updating the Code
If we ask you to make code changes, there’s no need to close the pull request and create a new one. Just go back to the branch on your fork and make your changes. Then, when you’re ready, you can add your changes into the branch:


    git add -A
git commit
git push origin issue1234
123
    
        Copy code to clipboard
        
    

When updating the code, it’s usually better to add additional commits to your branch rather than amending the original commit, because reviewers can easily tell which changes were made in response to a particular review. When we merge pull requests, we will squash all the commits from your branch into a single commit on the main branch.
The commit messages in subsequent commits do not need to be in any specific format because these commits do not show up in the changelog.
Rebasing
If your code is out-of-date, we might ask you to rebase. That means we want you to apply your changes on top of the latest upstream code. Make sure you have set up a development environment and then you can rebase using these commands:


    git fetch upstream
git rebase upstream/main
12
    
        Copy code to clipboard
        
    

You might find that there are merge conflicts when you attempt to rebase. Please resolve the conflicts and then do a forced push to your branch:


    git push origin issue1234 -f
1
    
        Copy code to clipboard
        
    


            

            
                Edit this page\n\n\n\nContribute to Core Rules
                

                Table of Contents
    
        
                
                    
                    Rule Writing Documentation
            		

                    File Structure
            		

                    Rule Unit Tests
            		

                    Performance Testing
            		

                    Rule Naming Conventions
            		

                    Frozen Rules
            		
                
            
    


                The ESLint core rules are the rules included in the ESLint package.
Rule Writing Documentation
For full reference information on writing rules, refer to Custom Rules. Both custom rules and core rules have the same API. The primary difference between core and custom rules are:

Core rules are included in the eslint package.
Core rules must adhere to the conventions documented on this page.

File Structure
Each core rule in ESLint has three files named with its identifier (for example, no-extra-semi).

in the lib/rules directory: a source file (for example, no-extra-semi.js).
in the tests/lib/rules directory: a test file (for example, no-extra-semi.js).
in the docs/src/rules directory: a Markdown documentation file (for example, no-extra-semi.md).

Important: If you submit a core rule to the ESLint repository, you must follow the conventions explained below.
Here is the basic format of the source file for a rule:


    /**
 * @fileoverview Rule to disallow unnecessary semicolons
 * @author Nicholas C. Zakas
 */

"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../types').Rule.RuleModule} */
module.exports = {
	meta: {
		type: "suggestion",

		docs: {
			description: "disallow unnecessary semicolons",
			recommended: true,
			url: "https://eslint.org/docs/rules/no-extra-semi",
		},
		fixable: "code",
		schema: [], // no options
	},
	create: function (context) {
		return {
			// callback functions
		};
	},
};
123456789101112131415161718192021222324252627282930
    
        Copy code to clipboard
        
    

Rule Unit Tests
Each bundled rule for ESLint core must have a set of unit tests submitted with it to be accepted. The test file is named the same as the source file but lives in tests/lib/. For example, if the rule source file is lib/rules/foo.js then the test file should be tests/lib/rules/foo.js.
ESLint provides the RuleTester utility to make it easy to write tests for rules.
Performance Testing
To keep the linting process efficient and unobtrusive, it is useful to verify the performance impact of new rules or modifications to existing rules.
To learn how to profile the performance of individual rules, refer to Profile Rule Performance in the custom rules documentation.
When developing in the ESLint core repository, the npm run perf command gives a high-level overview of ESLint running time with all core rules enabled.


    $ git checkout main
Switched to branch 'main'

$ npm run perf
CPU Speed is 2200 with multiplier 7500000
Performance Run #1:  1394.689313ms
Performance Run #2:  1423.295351ms
Performance Run #3:  1385.09515ms
Performance Run #4:  1382.406982ms
Performance Run #5:  1409.68566ms
Performance budget ok:  1394.689313ms (limit: 3409.090909090909ms)

$ git checkout my-rule-branch
Switched to branch 'my-rule-branch'

$ npm run perf
CPU Speed is 2200 with multiplier 7500000
Performance Run #1:  1443.736547ms
Performance Run #2:  1419.193291ms
Performance Run #3:  1436.018228ms
Performance Run #4:  1473.605485ms
Performance Run #5:  1457.455283ms
Performance budget ok:  1443.736547ms (limit: 3409.090909090909ms)
1234567891011121314151617181920212223
    
        Copy code to clipboard
        
    

Rule Naming Conventions
The rule naming conventions for ESLint are as follows:

Use dashes between words.
If your rule only disallows something, prefix it with no- such as no-eval for disallowing eval() and no-debugger for disallowing debugger.
If your rule is enforcing the inclusion of something, use a short name without a special prefix.

Frozen Rules
When rules are feature complete, they are marked as frozen (indicated with ❄️ in the documentation). Rules are considered feature complete when the intended purpose of the rule has been fully implemented such that it catches 80% or more of expected violations and covers the majority of common exceptions. After that point, we expect users to use disable comments when they find an edge case that isn’t covered.
When a rule is frozen, it means:

Bug fixes: We will still fix confirmed bugs.
New ECMAScript features: We will ensure compatibility with new ECMAScript features, meaning the rule will not break on new syntax.
New options: We will not add any new options unless an option is the only way to fix a bug or support a newly-added ECMAScript feature.

If you find that a frozen rule would work better for you with a change, we recommend copying the rule source code and modifying it to fit your needs.

            

            
                Edit this page\n\nContribute to Core Rules
                

                Table of Contents
    
        
                
                    
                    Rule Writing Documentation
            		

                    File Structure
            		

                    Rule Unit Tests
            		

                    Performance Testing
            		

                    Rule Naming Conventions
            		

                    Frozen Rules
            		
                
            
    


                The ESLint core rules are the rules included in the ESLint package.
Rule Writing Documentation
For full reference information on writing rules, refer to Custom Rules. Both custom rules and core rules have the same API. The primary difference between core and custom rules are:

Core rules are included in the eslint package.
Core rules must adhere to the conventions documented on this page.

File Structure
Each core rule in ESLint has three files named with its identifier (for example, no-extra-semi).

in the lib/rules directory: a source file (for example, no-extra-semi.js).
in the tests/lib/rules directory: a test file (for example, no-extra-semi.js).
in the docs/src/rules directory: a Markdown documentation file (for example, no-extra-semi.md).

Important: If you submit a core rule to the ESLint repository, you must follow the conventions explained below.
Here is the basic format of the source file for a rule:


    /**
 * @fileoverview Rule to disallow unnecessary semicolons
 * @author Nicholas C. Zakas
 */

"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../types').Rule.RuleModule} */
module.exports = {
	meta: {
		type: "suggestion",

		docs: {
			description: "disallow unnecessary semicolons",
			recommended: true,
			url: "https://eslint.org/docs/rules/no-extra-semi",
		},
		fixable: "code",
		schema: [], // no options
	},
	create: function (context) {
		return {
			// callback functions
		};
	},
};
123456789101112131415161718192021222324252627282930
    
        Copy code to clipboard
        
    

Rule Unit Tests
Each bundled rule for ESLint core must have a set of unit tests submitted with it to be accepted. The test file is named the same as the source file but lives in tests/lib/. For example, if the rule source file is lib/rules/foo.js then the test file should be tests/lib/rules/foo.js.
ESLint provides the RuleTester utility to make it easy to write tests for rules.
Performance Testing
To keep the linting process efficient and unobtrusive, it is useful to verify the performance impact of new rules or modifications to existing rules.
To learn how to profile the performance of individual rules, refer to Profile Rule Performance in the custom rules documentation.
When developing in the ESLint core repository, the npm run perf command gives a high-level overview of ESLint running time with all core rules enabled.


    $ git checkout main
Switched to branch 'main'

$ npm run perf
CPU Speed is 2200 with multiplier 7500000
Performance Run #1:  1394.689313ms
Performance Run #2:  1423.295351ms
Performance Run #3:  1385.09515ms
Performance Run #4:  1382.406982ms
Performance Run #5:  1409.68566ms
Performance budget ok:  1394.689313ms (limit: 3409.090909090909ms)

$ git checkout my-rule-branch
Switched to branch 'my-rule-branch'

$ npm run perf
CPU Speed is 2200 with multiplier 7500000
Performance Run #1:  1443.736547ms
Performance Run #2:  1419.193291ms
Performance Run #3:  1436.018228ms
Performance Run #4:  1473.605485ms
Performance Run #5:  1457.455283ms
Performance budget ok:  1443.736547ms (limit: 3409.090909090909ms)
1234567891011121314151617181920212223
    
        Copy code to clipboard
        
    

Rule Naming Conventions
The rule naming conventions for ESLint are as follows:

Use dashes between words.
If your rule only disallows something, prefix it with no- such as no-eval for disallowing eval() and no-debugger for disallowing debugger.
If your rule is enforcing the inclusion of something, use a short name without a special prefix.

Frozen Rules
When rules are feature complete, they are marked as frozen (indicated with ❄️ in the documentation). Rules are considered feature complete when the intended purpose of the rule has been fully implemented such that it catches 80% or more of expected violations and covers the majority of common exceptions. After that point, we expect users to use disable comments when they find an edge case that isn’t covered.
When a rule is frozen, it means:

Bug fixes: We will still fix confirmed bugs.
New ECMAScript features: We will ensure compatibility with new ECMAScript features, meaning the rule will not break on new syntax.
New options: We will not add any new options unless an option is the only way to fix a bug or support a newly-added ECMAScript feature.

If you find that a frozen rule would work better for you with a change, we recommend copying the rule source code and modifying it to fit your needs.

            

            
                Edit this page\n\n\n\nGovernance
                

                Table of Contents
    
        
                
                    
                    Roles and Responsibilities
            
                
                    
                    Users
            		

                    Contributors
            		

                    Website Team Member
            		

                    Committers
            		

                    Reviewers
            		

                    Technical Steering Committee (TSC)
            
                
                    
                    TSC Meetings
            		
                
            		
                
            		

                    Consensus Seeking Process
            		
                
            
    


                ESLint is an open source project that depends on contributions from the community. Anyone may contribute to the project at any time by submitting code, participating in discussions, making suggestions, or any other contribution they see fit. This document describes how various types of contributors work within the ESLint project.
Roles and Responsibilities
Users
Users are community members who have a need for the project. Anyone can be a User; there are no special requirements. Common User contributions include evangelizing the project (e.g., display a link on a website and raise awareness through word-of-mouth), informing developers of strengths and weaknesses from a new user perspective, or providing moral support (a “thank you” goes a long way).
Users who continue to engage with the project and its community will often become more and more involved. Such Users may find themselves becoming Contributors, as described in the next section.
Contributors
Contributors are community members who contribute in concrete ways to the project, most often in the form of code and/or documentation. Anyone can become a Contributor, and contributions can take many forms. There is no expectation of commitment to the project, no specific skill requirements, and no selection process.
Contributors have read-only access to source code and so submit changes via pull requests. Contributor pull requests have their contribution reviewed and merged by a TSC member. TSC members and Committers work with Contributors to review their code and prepare it for merging.
As Contributors gain experience and familiarity with the project, their profile within, and commitment to, the community will increase. At some stage, they may find themselves being nominated as either a Website Team Member or Committer by an existing Website Team Member or Committer.
Website Team Member
Website Team Members are community members who have shown that they are committed to the continued maintenance of eslint.org through ongoing engagement with the community. Website Team Members are given push access to the eslint.org GitHub repository and must abide by the project’s Contribution Guidelines.
Website Team Members:

Are expected to work at least one hour per week triaging issues and reviewing pull requests.
Are expected to work at least two hours total per week on ESLint.
May invoice for the hours they spend working on ESLint at a rate of $50 USD per hour.
Are expected to check in on the #team Discord channel once per week day (excluding holidays and other time off) for team updates.
Are expected to work on public branches of the source repository and submit pull requests from that branch to the master branch.
Are expected to delete their public branches when they are no longer necessary.
Must submit pull requests for all changes.
Have their work reviewed by Reviewers and TSC members before acceptance into the repository.
May label and close website-related issues (see Manage Issues).
May merge some pull requests (see Review Pull Requests).
May take time off whenever they want, and are expected to post in the #team Discord channel when they will be away for more than a couple of days.

To become a Website Team Member:

One must have shown a willingness and ability to participate in the maintenance of eslint.org as a team player. Typically, a potential Website Team Member will need to show that they have an understanding of the structure of the website and how it fits into the larger ESLint project’s objectives and strategy.
Website Team Members are expected to be respectful of every community member and to work collaboratively in the spirit of inclusion.
Have submitted a minimum of 10 website-related pull requests. What’s a website-related pull request? One that is made to the eslint.org repository or the docs directory in the eslint repository and requires little effort to accept because it’s well documented and tested.

New Website Team Members can be nominated by any existing Website Team Member or Committer. Once they have been nominated, there will be a vote by the TSC members.
It is important to recognize that membership on the website team is a privilege, not a right. That privilege must be earned and once earned it can be removed by the TSC members by a standard TSC motion. However, under normal circumstances Website Team Members remain for as long as they wish to continue engaging with the project.
Committers
Committers are community members who have shown that they are committed to the continued development of the project through ongoing engagement with the community. Committers are given push access to the project’s GitHub repos and must abide by the project’s Contribution Guidelines.
Committers:

Are expected to work at least one hour per week triaging issues and reviewing pull requests.
Are expected to work at least two hours total per week on ESLint.
May invoice for the hours they spend working on ESLint at a rate of $50 USD per hour.
Are expected to check in on the #team Discord channel once per week day (excluding holidays and other time off) for team updates.
Are expected to work on public branches of the source repository and submit pull requests from that branch to the master branch.
Are expected to delete their public branches when they are no longer necessary.
Are expected to provide feedback on issues in the “Feedback Needed” column of the Triage Board.
Are expected to work on at least one issue in the “Ready to Implement” column of the Triage Board that they didn’t create each month.
Must submit pull requests for all changes.
Have their work reviewed by TSC members before acceptance into the repository.
May label and close issues (see Manage Issues).
May merge some pull requests (see Review Pull Requests).
May take time off whenever they want, and are expected to post in the #team Discord channel when they will be away for more than a couple of days.

To become a Committer:

One must have shown a willingness and ability to participate in the project as a team player. Typically, a potential Committer will need to show that they have an understanding of and alignment with the project, its objectives, and its strategy.
Committers are expected to be respectful of every community member and to work collaboratively in the spirit of inclusion.
Have submitted a minimum of 10 qualifying pull requests. What’s a qualifying pull request? One that carries significant technical weight and requires little effort to accept because it’s well documented and tested.

New Committers can be nominated by any existing Committer. Once they have been nominated, there will be a vote by the TSC members.
It is important to recognize that committership is a privilege, not a right. That privilege must be earned and once earned it can be removed by the TSC members by a standard TSC motion. However, under normal circumstances committership exists for as long as the Committer wishes to continue engaging with the project.
A Committer who shows an above-average level of contribution to the project, particularly with respect to its strategic direction and long-term health, may be nominated to become a reviewer, described below.
Reviewers
Reviewers are community members who have contributed a significant amount of time to the project through triaging of issues, fixing bugs, implementing enhancements/features, and are trusted community leaders.
Reviewers may perform all of the duties of Committers, and also:

May merge external pull requests for accepted issues upon reviewing and approving the changes.
May merge their own pull requests once they have collected the feedback they deem necessary. (No pull request should be merged without at least one Committer/Reviewer/TSC member comment stating they’ve looked at the code.)
May invoice for the hours they spend working on ESLint at a rate of $80 USD per hour.

To become a Reviewer:

Work in a helpful and collaborative way with the community.
Have given good feedback on others’ submissions and displayed an overall understanding of the code quality standards for the project.
Commit to being a part of the community for the long-term.
Have submitted a minimum of 50 qualifying pull requests.

A Committer is invited to become a Reviewer by existing Reviewers and TSC members. A nomination will result in discussion and then a decision by the TSC.
Technical Steering Committee (TSC)
The ESLint project is jointly governed by a Technical Steering Committee (TSC) which is responsible for high-level guidance of the project.
The TSC has final authority over this project including:

Technical direction
Project governance and process (including this policy)
Contribution policy
GitHub repository hosting

TSC seats are not time-limited. The size of the TSC can not be larger than five members. This size ensures adequate coverage of important areas of expertise balanced with the ability to make decisions efficiently.
The TSC may add additional members to the TSC by a standard TSC motion.
A TSC member may be removed from the TSC by voluntary resignation, by a standard TSC motion, or by missing four consecutive TSC meetings. In all cases, the TSC member will revert to Reviewer status unless they prefer Alumni status.
Changes to TSC membership should be posted in the agenda, and may be suggested as any other agenda item (see “TSC Meetings” below).
No more than 1/3 of the TSC members may be affiliated with the same employer. If removal or resignation of a TSC member, or a change of employment by a TSC member, creates a situation where more than 1/3 of the TSC membership shares an employer, then the situation must be immediately remedied by the resignation or removal of one or more TSC members affiliated with the over-represented employer(s).
TSC members have additional responsibilities over and above those of a Reviewer. These responsibilities ensure the smooth running of the project. TSC members are expected to review code contributions, approve changes to this document, manage the copyrights within the project outputs, and attend regular TSC meetings.
TSC members may perform all of the duties of Reviewers, and also:

May release new versions of all ESLint projects.
May participate in TSC meetings.
May propose budget items.
May propose new ESLint projects.

There is no specific set of requirements or qualifications for TSC members beyond those that are expected of Reviewers.
A Reviewer is invited to become a TSC member by existing TSC members. A nomination will result in discussion and then a decision by the TSC.
TSC Meetings
The TSC meets every other week in the TSC Meeting Discord channel. The meeting is run by a designated moderator approved by the TSC.
Items are added to the TSC agenda which are considered contentious or
are modifications of governance, contribution policy, TSC membership,
or release process.
The intention of the agenda is not to approve or review all patches.
That should happen continuously on GitHub and be handled by the larger
group of Committers.
Any community member, Committer, or Reviewer can ask that something be added to
the next meeting’s agenda by logging a GitHub Issue. Anyone can add the item to the agenda by adding
the “tsc agenda” tag to the issue.
Prior to each TSC meeting, the moderator will share the Agenda with
members of the TSC. TSC members can add any items they like to the
agenda at the beginning of each meeting. The moderator and the TSC
cannot veto or remove items.
No binding votes on TSC agenda items can take place without a quorum of
TSC members present in the meeting. Quorum is achieved when more than
half of the TSC members (minus non-attending members) are present.
The TSC may invite persons or representatives from certain projects to
participate in a non-voting capacity.
The moderator is responsible for summarizing the discussion of each
agenda item and sending it as a pull request after the meeting.
Consensus Seeking Process
The TSC follows a
Consensus Seeking
decision making model.
When an agenda item has appeared to reach a consensus, the moderator
will ask “Does anyone object?” as a final call for dissent from the
consensus.
If an agenda item cannot reach a consensus, a TSC member can call for
either a closing vote or a vote to table the issue to the next
meeting. The call for a vote must be approved by a majority of the TSC
or else the discussion will continue. Simple majority wins.

This work is a derivative of YUI Contributor Model and the Node.js Project Governance Model.
This work is licensed under a Creative Commons Attribution-ShareAlike 2.0 UK: England & Wales License.

            

            
                Edit this page\n\nGovernance
                

                Table of Contents
    
        
                
                    
                    Roles and Responsibilities
            
                
                    
                    Users
            		

                    Contributors
            		

                    Website Team Member
            		

                    Committers
            		

                    Reviewers
            		

                    Technical Steering Committee (TSC)
            
                
                    
                    TSC Meetings
            		
                
            		
                
            		

                    Consensus Seeking Process
            		
                
            
    


                ESLint is an open source project that depends on contributions from the community. Anyone may contribute to the project at any time by submitting code, participating in discussions, making suggestions, or any other contribution they see fit. This document describes how various types of contributors work within the ESLint project.
Roles and Responsibilities
Users
Users are community members who have a need for the project. Anyone can be a User; there are no special requirements. Common User contributions include evangelizing the project (e.g., display a link on a website and raise awareness through word-of-mouth), informing developers of strengths and weaknesses from a new user perspective, or providing moral support (a “thank you” goes a long way).
Users who continue to engage with the project and its community will often become more and more involved. Such Users may find themselves becoming Contributors, as described in the next section.
Contributors
Contributors are community members who contribute in concrete ways to the project, most often in the form of code and/or documentation. Anyone can become a Contributor, and contributions can take many forms. There is no expectation of commitment to the project, no specific skill requirements, and no selection process.
Contributors have read-only access to source code and so submit changes via pull requests. Contributor pull requests have their contribution reviewed and merged by a TSC member. TSC members and Committers work with Contributors to review their code and prepare it for merging.
As Contributors gain experience and familiarity with the project, their profile within, and commitment to, the community will increase. At some stage, they may find themselves being nominated as either a Website Team Member or Committer by an existing Website Team Member or Committer.
Website Team Member
Website Team Members are community members who have shown that they are committed to the continued maintenance of eslint.org through ongoing engagement with the community. Website Team Members are given push access to the eslint.org GitHub repository and must abide by the project’s Contribution Guidelines.
Website Team Members:

Are expected to work at least one hour per week triaging issues and reviewing pull requests.
Are expected to work at least two hours total per week on ESLint.
May invoice for the hours they spend working on ESLint at a rate of $50 USD per hour.
Are expected to check in on the #team Discord channel once per week day (excluding holidays and other time off) for team updates.
Are expected to work on public branches of the source repository and submit pull requests from that branch to the master branch.
Are expected to delete their public branches when they are no longer necessary.
Must submit pull requests for all changes.
Have their work reviewed by Reviewers and TSC members before acceptance into the repository.
May label and close website-related issues (see Manage Issues).
May merge some pull requests (see Review Pull Requests).
May take time off whenever they want, and are expected to post in the #team Discord channel when they will be away for more than a couple of days.

To become a Website Team Member:

One must have shown a willingness and ability to participate in the maintenance of eslint.org as a team player. Typically, a potential Website Team Member will need to show that they have an understanding of the structure of the website and how it fits into the larger ESLint project’s objectives and strategy.
Website Team Members are expected to be respectful of every community member and to work collaboratively in the spirit of inclusion.
Have submitted a minimum of 10 website-related pull requests. What’s a website-related pull request? One that is made to the eslint.org repository or the docs directory in the eslint repository and requires little effort to accept because it’s well documented and tested.

New Website Team Members can be nominated by any existing Website Team Member or Committer. Once they have been nominated, there will be a vote by the TSC members.
It is important to recognize that membership on the website team is a privilege, not a right. That privilege must be earned and once earned it can be removed by the TSC members by a standard TSC motion. However, under normal circumstances Website Team Members remain for as long as they wish to continue engaging with the project.
Committers
Committers are community members who have shown that they are committed to the continued development of the project through ongoing engagement with the community. Committers are given push access to the project’s GitHub repos and must abide by the project’s Contribution Guidelines.
Committers:

Are expected to work at least one hour per week triaging issues and reviewing pull requests.
Are expected to work at least two hours total per week on ESLint.
May invoice for the hours they spend working on ESLint at a rate of $50 USD per hour.
Are expected to check in on the #team Discord channel once per week day (excluding holidays and other time off) for team updates.
Are expected to work on public branches of the source repository and submit pull requests from that branch to the master branch.
Are expected to delete their public branches when they are no longer necessary.
Are expected to provide feedback on issues in the “Feedback Needed” column of the Triage Board.
Are expected to work on at least one issue in the “Ready to Implement” column of the Triage Board that they didn’t create each month.
Must submit pull requests for all changes.
Have their work reviewed by TSC members before acceptance into the repository.
May label and close issues (see Manage Issues).
May merge some pull requests (see Review Pull Requests).
May take time off whenever they want, and are expected to post in the #team Discord channel when they will be away for more than a couple of days.

To become a Committer:

One must have shown a willingness and ability to participate in the project as a team player. Typically, a potential Committer will need to show that they have an understanding of and alignment with the project, its objectives, and its strategy.
Committers are expected to be respectful of every community member and to work collaboratively in the spirit of inclusion.
Have submitted a minimum of 10 qualifying pull requests. What’s a qualifying pull request? One that carries significant technical weight and requires little effort to accept because it’s well documented and tested.

New Committers can be nominated by any existing Committer. Once they have been nominated, there will be a vote by the TSC members.
It is important to recognize that committership is a privilege, not a right. That privilege must be earned and once earned it can be removed by the TSC members by a standard TSC motion. However, under normal circumstances committership exists for as long as the Committer wishes to continue engaging with the project.
A Committer who shows an above-average level of contribution to the project, particularly with respect to its strategic direction and long-term health, may be nominated to become a reviewer, described below.
Reviewers
Reviewers are community members who have contributed a significant amount of time to the project through triaging of issues, fixing bugs, implementing enhancements/features, and are trusted community leaders.
Reviewers may perform all of the duties of Committers, and also:

May merge external pull requests for accepted issues upon reviewing and approving the changes.
May merge their own pull requests once they have collected the feedback they deem necessary. (No pull request should be merged without at least one Committer/Reviewer/TSC member comment stating they’ve looked at the code.)
May invoice for the hours they spend working on ESLint at a rate of $80 USD per hour.

To become a Reviewer:

Work in a helpful and collaborative way with the community.
Have given good feedback on others’ submissions and displayed an overall understanding of the code quality standards for the project.
Commit to being a part of the community for the long-term.
Have submitted a minimum of 50 qualifying pull requests.

A Committer is invited to become a Reviewer by existing Reviewers and TSC members. A nomination will result in discussion and then a decision by the TSC.
Technical Steering Committee (TSC)
The ESLint project is jointly governed by a Technical Steering Committee (TSC) which is responsible for high-level guidance of the project.
The TSC has final authority over this project including:

Technical direction
Project governance and process (including this policy)
Contribution policy
GitHub repository hosting

TSC seats are not time-limited. The size of the TSC can not be larger than five members. This size ensures adequate coverage of important areas of expertise balanced with the ability to make decisions efficiently.
The TSC may add additional members to the TSC by a standard TSC motion.
A TSC member may be removed from the TSC by voluntary resignation, by a standard TSC motion, or by missing four consecutive TSC meetings. In all cases, the TSC member will revert to Reviewer status unless they prefer Alumni status.
Changes to TSC membership should be posted in the agenda, and may be suggested as any other agenda item (see “TSC Meetings” below).
No more than 1/3 of the TSC members may be affiliated with the same employer. If removal or resignation of a TSC member, or a change of employment by a TSC member, creates a situation where more than 1/3 of the TSC membership shares an employer, then the situation must be immediately remedied by the resignation or removal of one or more TSC members affiliated with the over-represented employer(s).
TSC members have additional responsibilities over and above those of a Reviewer. These responsibilities ensure the smooth running of the project. TSC members are expected to review code contributions, approve changes to this document, manage the copyrights within the project outputs, and attend regular TSC meetings.
TSC members may perform all of the duties of Reviewers, and also:

May release new versions of all ESLint projects.
May participate in TSC meetings.
May propose budget items.
May propose new ESLint projects.

There is no specific set of requirements or qualifications for TSC members beyond those that are expected of Reviewers.
A Reviewer is invited to become a TSC member by existing TSC members. A nomination will result in discussion and then a decision by the TSC.
TSC Meetings
The TSC meets every other week in the TSC Meeting Discord channel. The meeting is run by a designated moderator approved by the TSC.
Items are added to the TSC agenda which are considered contentious or
are modifications of governance, contribution policy, TSC membership,
or release process.
The intention of the agenda is not to approve or review all patches.
That should happen continuously on GitHub and be handled by the larger
group of Committers.
Any community member, Committer, or Reviewer can ask that something be added to
the next meeting’s agenda by logging a GitHub Issue. Anyone can add the item to the agenda by adding
the “tsc agenda” tag to the issue.
Prior to each TSC meeting, the moderator will share the Agenda with
members of the TSC. TSC members can add any items they like to the
agenda at the beginning of each meeting. The moderator and the TSC
cannot veto or remove items.
No binding votes on TSC agenda items can take place without a quorum of
TSC members present in the meeting. Quorum is achieved when more than
half of the TSC members (minus non-attending members) are present.
The TSC may invite persons or representatives from certain projects to
participate in a non-voting capacity.
The moderator is responsible for summarizing the discussion of each
agenda item and sending it as a pull request after the meeting.
Consensus Seeking Process
The TSC follows a
Consensus Seeking
decision making model.
When an agenda item has appeared to reach a consensus, the moderator
will ask “Does anyone object?” as a final call for dissent from the
consensus.
If an agenda item cannot reach a consensus, a TSC member can call for
either a closing vote or a vote to table the issue to the next
meeting. The call for a vote must be approved by a majority of the TSC
or else the discussion will continue. Simple majority wins.

This work is a derivative of YUI Contributor Model and the Node.js Project Governance Model.
This work is licensed under a Creative Commons Attribution-ShareAlike 2.0 UK: England & Wales License.

            

            
                Edit this page\n\n\n\nReport a Security Vulnerability
                

                


                To report a security vulnerability in ESLint, please use our create an advisory form on GitHub.

            

            
                Edit this page\n\nReport a Security Vulnerability
                

                


                To report a security vulnerability in ESLint, please use our create an advisory form on GitHub.

            

            
                Edit this page\n\n\n\nMaintain ESLint
                

                Table of Contents
    
        
                
                    
                    How ESLint is Maintained
            		

                    Manage Issues
            		

                    Review Pull Requests
            		

                    Manage Releases
            		

                    Working Groups
            		
                
            
    


                This guide is intended for those who work as part of the ESLint project team.
How ESLint is Maintained
Explains how ESLint is maintained, including information about team, governance, and funding.
Manage Issues
Describes how to deal with issues when they’re opened, how to interact with users who open issues, and how to close issues effectively.
Review Pull Requests
Describes how to review incoming pull requests.
Manage Releases
Describes how to do an ESLint project release.
Working Groups
Describes how working groups are created and how they function within the ESLint project.

            

            
                Edit this page\n\nMaintain ESLint
                

                Table of Contents
    
        
                
                    
                    How ESLint is Maintained
            		

                    Manage Issues
            		

                    Review Pull Requests
            		

                    Manage Releases
            		

                    Working Groups
            		
                
            
    


                This guide is intended for those who work as part of the ESLint project team.
How ESLint is Maintained
Explains how ESLint is maintained, including information about team, governance, and funding.
Manage Issues
Describes how to deal with issues when they’re opened, how to interact with users who open issues, and how to close issues effectively.
Review Pull Requests
Describes how to review incoming pull requests.
Manage Releases
Describes how to do an ESLint project release.
Working Groups
Describes how working groups are created and how they function within the ESLint project.

            

            
                Edit this page\n\n\n\nHow ESLint is Maintained
                

                Table of Contents
    
        
                
                    
                    The ESLint Team
            		

                    Organization Structure
            		

                    Funding
            		

                    Joining the Maintainer Team
            		
                
            
    


                This page explains the different roles and structures involved in maintaining ESLint.
The ESLint Team
The ESLint team works together to develop and maintain ESLint. To learn more about the different roles on the ESLint team, refer to Governance. To see the current team members, refer to Team.
Organization Structure
ESLint is part of the OpenJS Foundation, a nonprofit organization that supports open-source projects and communities in the JavaScript ecosystem.
The OpenJS Foundation provides legal infrastructure for JavaScript projects like ESLint. It is the owner of the intellectual property related to ESLint, including copyrights and trademarks, and ensures the independence of the project. They are also a resource for ESLint if we need legal advice or representation.
The OpenJS Foundation does not participate in the day-to-day functioning of ESLint.
Funding
ESLint is funded through several sources, including:

Open Collective: A platform for financing open source projects.
GitHub Sponsors: A platform for funding open source projects associated with GitHub.
Tidelift: A subscription service that lets enterprises manage and fund the open source projects that their organization uses.
Carbon Ads: Developer-centric advertising provider used on eslint.org.
Stackaid.us: Tool that developers can use to allocate funding to the open source projects they use.

ESLint uses this funding for the following purposes:

Pay team members and contractors.
Fund projects.
Pay for services that keep ESLint running (web hosting, software subscriptions, etc.).
Provide financial support to our dependencies and ecosystem.

Joining the Maintainer Team
ESLint is an open-source project, and anyone can contribute to the project. If you’re interested in becoming part of the maintainer team, stop by our Discord and introduce yourself.

            

            
                Edit this page\n\nHow ESLint is Maintained
                

                Table of Contents
    
        
                
                    
                    The ESLint Team
            		

                    Organization Structure
            		

                    Funding
            		

                    Joining the Maintainer Team
            		
                
            
    


                This page explains the different roles and structures involved in maintaining ESLint.
The ESLint Team
The ESLint team works together to develop and maintain ESLint. To learn more about the different roles on the ESLint team, refer to Governance. To see the current team members, refer to Team.
Organization Structure
ESLint is part of the OpenJS Foundation, a nonprofit organization that supports open-source projects and communities in the JavaScript ecosystem.
The OpenJS Foundation provides legal infrastructure for JavaScript projects like ESLint. It is the owner of the intellectual property related to ESLint, including copyrights and trademarks, and ensures the independence of the project. They are also a resource for ESLint if we need legal advice or representation.
The OpenJS Foundation does not participate in the day-to-day functioning of ESLint.
Funding
ESLint is funded through several sources, including:

Open Collective: A platform for financing open source projects.
GitHub Sponsors: A platform for funding open source projects associated with GitHub.
Tidelift: A subscription service that lets enterprises manage and fund the open source projects that their organization uses.
Carbon Ads: Developer-centric advertising provider used on eslint.org.
Stackaid.us: Tool that developers can use to allocate funding to the open source projects they use.

ESLint uses this funding for the following purposes:

Pay team members and contractors.
Fund projects.
Pay for services that keep ESLint running (web hosting, software subscriptions, etc.).
Provide financial support to our dependencies and ecosystem.

Joining the Maintainer Team
ESLint is an open-source project, and anyone can contribute to the project. If you’re interested in becoming part of the maintainer team, stop by our Discord and introduce yourself.

            

            
                Edit this page\n\n\n\nManage Issues and Pull Requests
                

                Table of Contents
    
        
                
                    
                    Things to Keep in Mind
            		

                    Types of Issues and Pull Requests
            		

                    Triaging Process
            
                
                    
                    When an Issue or Pull Request is Opened
            		
                
            		

                    Evaluation Process
            		

                    Accepting Issues and Pull Requests
            		

                    Championing Issues
            		

                    Consensus
            		

                    When to Send to TSC
            		

                    Evaluating Core Features and Enhancements (TSC members only)
            		

                    Request Feedback from TSC
            		

                    When to Close an Issue
            		
                
            
    


                New issues and pull requests are filed frequently, and how we respond to those issues directly affects the success of the project. Being part of the project team means helping to triage and address issues as they come in so the project can continue to run smoothly.
Things to Keep in Mind

Be nice. Even if the people are being rude or aggressive on an issue, you must be the mature one in the conversation as a project team member. Do your best to work with everyone no matter their style. Remember, poor wording choice can also be a sign of someone who doesn’t know English very well, so be sure to consider that when trying to determine the tone of someone’s message. Being rude, even when someone is being rude to you, reflects poorly on the team and the project as a whole.
Be inquisitive. Ask questions on the issue whenever something isn’t clear. Don’t assume you understand what’s being reported if there are details missing. Whenever you are unsure, it’s best to ask for more information.
Not all requests are equal. It’s unlikely we’ll be able to accommodate every request, so don’t be afraid to say that something doesn’t fit into the scope of the project or isn’t practical. It’s better to give such feedback if that’s the case.
Close when appropriate. Don’t be afraid to close issues that you don’t think will be done, or when it’s become clear from the conversation that there’s no further work to do. Issues can always be reopened if they are closed incorrectly, so feel free to close issues when appropriate. Just be sure to leave a comment explaining why the issue is being closed (if not closed by a commit).

Types of Issues and Pull Requests
There are five primary categories:

Bug: Something isn’t working the way it’s expected to work.
Enhancement: A change to something that already exists. For instance, adding a new option to an existing rule or fixing a bug in a rule where fixing it will result in the rule reporting more problems (in this case, use both “Bug” and “Enhancement”).
Feature: Adding something that doesn’t already exist. For example, adding a new rule, new formatter, or new command line flag.
Documentation: Adding, updating, or removing project documentation.
Question: An inquiry about how something works that won’t result in a code change. We prefer if people use GitHub Discussions or Discord for questions, but sometimes they’ll open an issue.

The first goal when evaluating an issue or pull request is to determine which category the issue falls into.
Triaging Process
All of ESLint’s issues and pull requests, across all GitHub repositories, are managed on our Triage Project. Please use the Triage project instead of the issues list when reviewing issues to determine what to work on. The Triage project has several columns:

Needs Triage: Issues and pull requests that have not yet been reviewed by anyone.
Triaging: Issues and pull requests that someone has reviewed but has not been able to fully triage yet.
Ready for Dev Team: Issues and pull requests that have been triaged and have all the information necessary for the dev team to take a look.
Evaluating: The dev team is evaluating these issues and pull requests to determine whether to move forward or not.
Feedback Needed: A team member is requesting more input from the rest of the team before proceeding.
Waiting for RFC: The next step in the process is for an RFC to be written.
RFC Opened: An RFC is opened to address these issues.
Blocked: The issue can’t move forward due to some dependency.
Ready to Implement: These issues have all the details necessary to start implementation.
Implementing: There is an open pull request for each of these issues or this is a pull request that has been approved.
Second Review Needed: Pull requests that already have one approval and the approver is requesting a second review before merging.
Merge Candidates: Pull requests that already have at least one approval and at least one approver believes the pull request is ready to merge into the next release but would still like a TSC member to verify.
Completed: The issue has been closed (either via pull request merge or by the team manually closing the issue).

We make every attempt to automate movement between as many columns as we can, but sometimes moving issues needs to be done manually.
When an Issue or Pull Request is Opened
When an issue or pull request is opened, it is automatically added to the “Needs Triage” column in the Triage project. These issues and pull requests need to be evaluated to determine the next steps. Anyone on the support team or dev team can follow these steps to properly triage issues.
Note: If an issue or pull request is in the “Triaging” column, that means someone is already triaging it, and you should let them finish. There’s no need to comment on issues or pull requests in the “Triaging” column unless someone asks for help.
The steps for triaging an issue or pull request are:

Move the issue or pull request from “Needs Triage” to “Triaging” in the Triage project.
Check: Has all the information in the issue template been provided?

No: If information is missing from the issue template, or you can’t tell what is being requested, please ask the author to provide the missing information:

Add the “needs info” label to the issue so we know that this issue is stalled due to lack of information.
Don’t move on to other steps until the necessary information has been provided.
If the issue author hasn’t provided the necessary information after 7 days, please close the issue. The bot will add a comment stating that the issue was closed because there was information missing.


Yes:

If the issue is actually a question (rather than something the dev team needs to change), please convert it to a discussion. You can continue the conversation as a discussion.
If the issue is reporting a bug, or if a pull request is fixing a bug, try to reproduce the issue following the instructions in the issue. If you can reproduce the bug, please add the “repro:yes” label. (The bot will automatically remove the “repro:needed” label.) If you can’t reproduce the bug, ask the author for more information about their environment or to clarify reproduction steps.
If the issue or pull request is reporting something that works as intended, please add the “works as intended” label and close the issue.
Please add labels describing the part of ESLint affected:

3rd party plugin: Related to third-party functionality (plugins, parsers, rules, etc.).
build: Related to commands run during a build (testing, linting, release scripts, etc.).
cli: Related to command line input or output, or to CLIEngine.
core: Related to internal APIs.
documentation: Related to content on eslint.org.
infrastructure: Related to resources needed for builds or deployment (VMs, CI tools, bots, etc.).
rule: Related to core rules.


Please assign an initial priority based on the importance of the issue or pull request. If you’re not sure, use your best judgment. We can always change the priority later.

P1: Urgent and important, we need to address this immediately.
P2: Important but not urgent. Should be handled by a TSC member or reviewer.
P3: Nice to have but not important. Can be handled by any team member.
P4: A good idea that we’d like to have but may take a while for the team to get to it.
P5: A good idea that the core team can’t commit to. Will likely need to be done by an outside contributor.


Please assign an initial impact assessment (make your best guess):

Low: Doesn’t affect many users.
Medium: Affects most users or has a noticeable effect on user experience.
High: Affects a lot of users, is a breaking change, or otherwise will be very noticeable to users.


If you can’t properly triage the issue or pull request, move the issue back to the “Needs Triage” column in the Triage project so someone else can triage it.
If a pull request references an already accepted issue, move it to the “Implementing” column in the Triage project.
If you have triaged the issue, move the issue to the “Ready for Dev Team” column in the Triage project.





Evaluation Process
When an issue has been moved to the “Ready for Dev Team” column, any dev team member can pick up the issue to start evaluating it.

Move the issue into the “Evaluating” column.
Next steps:

Bugs: If you can verify the bug, add the “accepted” label and ask if they would like to submit a pull request.
New Rules: If you are willing to champion the rule (meaning you believe it should be included in ESLint core and you will take ownership of the process for including it), add a comment saying you will champion the issue, assign the issue to yourself, and follow the guidelines below.
Rule Changes: If you are willing to champion the change and it would not be a breaking change (requiring a major version increment), add a comment saying that you will champion the issue, assign the issue to yourself, and follow the guidelines below.
Breaking Changes: If you suspect or can verify that a change would be breaking, label it as “Breaking”.
Duplicates: If you can verify the issue is a duplicate, add a comment mentioning the duplicate issue (such as, “Duplicate of #1234”) and close the issue.


Regardless of the above, always leave a comment. Don’t just add labels; engage with the person who opened the issue by asking a question (request more information if necessary) or stating your opinion of the issue. If it’s a verified bug, ask if the user would like to submit a pull request.
If the issue can’t be implemented because it needs an external dependency to be updated or needs to wait for another issue to be resolved, move the issue to the “Blocked” column.
If the issue has been accepted and an RFC is required as the next step, move the issue to the “Waiting for RFC” column and comment on the issue that an RFC is needed.

Note: “Good first issue” issues are intended to help new contributors feel welcome and empowered to make a contribution to ESLint. To ensure that new contributors are given a chance to work on these issues, issues labeled “good first issue” must be open for 30 days from the day the issue was labeled before a team member is permitted to work on them.
Accepting Issues and Pull Requests
Issues may be labeled as “accepted” when the issue is:

A bug that you’ve been able to reproduce and verify (i.e. you’re sure it’s a bug).
A new rule or rule change that you’re championing and consensus has been reached for its inclusion in the project.

The “accepted” label will be added to other issues by a TSC member if it’s appropriate for the roadmap.
When an issue is accepted and implementation can begin, it should be moved to the “Ready to Implement” column.
Championing Issues
New rules and rule changes require a champion. As champion, it’s your job to:

Gain consensus from the ESLint team on inclusion.
Guide the rule creation process until it’s complete (so only champion a rule that you have time to implement or help another contributor implement).

Once consensus has been reached on inclusion, add the “accepted” label. Optionally, add “help wanted” and “good first issue” labels, as necessary.
Consensus
Consensus is reached on issues when there are at least three team members who believe the change is a good idea and no one who believes the change is a bad idea. In order to indicate your support for an issue, leave a +1 reaction (thumbs up) on the original issue description in addition to any comments you might have.
When to Send to TSC
If consensus cannot be reached on an issue, or an issue’s progress has been stalled and it’s not clear if the issue should be closed, then you can refer the issue to the TSC for resolution. To do so, add the “tsc agenda” label to the issue and add a comment including the following information:

A one-paragraph summary of the discussion to this point. This should begin with “TSC Summary:”.
The question you would like the TSC to answer. This should begin with “TSC Question:”.

The issue will be discussed at the next TSC meeting and the resolution will be posted back to the issue.
Evaluating Core Features and Enhancements (TSC members only)
In addition to the above, changes to the core (including CLI changes) that would result in a minor or major version release must be approved by the TSC by standard TSC motion. Add the label “tsc agenda” to the issue and it will be discussed at the next TSC meeting. In general, requests should meet the following criteria to be considered:

The feature or enhancement is in scope for the project and should be added to the roadmap.
Someone is committed to including the change within the next year.
There is reasonable certainty about who will do the work.

When a suggestion is too ambitious or would take too much time to complete, it’s better not to accept the proposal. Stick to small, incremental changes and lay out a roadmap of where you’d like the project to go eventually. Don’t let the project get bogged down in big features that will take a long time to complete.
Breaking Changes: Be on the lookout for changes that would be breaking. Issues that represent breaking changes should be labeled as “breaking”.
Request Feedback from TSC
To request feedback from the TSC, team members can ping @eslint/eslint-tsc and add the label “tsc waiting” on an issue or pull request.
Unless otherwise requested, every TSC member should provide feedback on issues labeled “tsc waiting”.
If a TSC member is unable to respond in a timely manner, they should post a comment indicating when they expect to be able to leave their feedback.
The last TSC member who provides feedback on an issue labeled “tsc waiting” should remove the label.
When to Close an Issue
All team members are allowed to close issues depending on how the issue has been resolved.
Team members may close an issue immediately if:

The issue is a duplicate of an existing issue.
The issue is just a question and has been answered.

Team members may close an issue where the consensus is to not accept the issue after a waiting period (to ensure that other team members have a chance to review the issue before it is closed):

Wait 2 days if the issue was opened Monday through Friday.
Wait 3 days if the issue was opened on Saturday or Sunday.

In an effort to keep the issues backlog manageable, team members may also close an issue if the following conditions are met:

Unaccepted: Close after it has been open for 21 days, as these issues do not have enough support to move forward.
Accepted: Close after 90 days if no one from the team or the community is willing to step forward and own the work to complete to it.
Help wanted: Close after 90 days if it has not been completed.


            

            
                Edit this page\n\nManage Issues and Pull Requests
                

                Table of Contents
    
        
                
                    
                    Things to Keep in Mind
            		

                    Types of Issues and Pull Requests
            		

                    Triaging Process
            
                
                    
                    When an Issue or Pull Request is Opened
            		
                
            		

                    Evaluation Process
            		

                    Accepting Issues and Pull Requests
            		

                    Championing Issues
            		

                    Consensus
            		

                    When to Send to TSC
            		

                    Evaluating Core Features and Enhancements (TSC members only)
            		

                    Request Feedback from TSC
            		

                    When to Close an Issue
            		
                
            
    


                New issues and pull requests are filed frequently, and how we respond to those issues directly affects the success of the project. Being part of the project team means helping to triage and address issues as they come in so the project can continue to run smoothly.
Things to Keep in Mind

Be nice. Even if the people are being rude or aggressive on an issue, you must be the mature one in the conversation as a project team member. Do your best to work with everyone no matter their style. Remember, poor wording choice can also be a sign of someone who doesn’t know English very well, so be sure to consider that when trying to determine the tone of someone’s message. Being rude, even when someone is being rude to you, reflects poorly on the team and the project as a whole.
Be inquisitive. Ask questions on the issue whenever something isn’t clear. Don’t assume you understand what’s being reported if there are details missing. Whenever you are unsure, it’s best to ask for more information.
Not all requests are equal. It’s unlikely we’ll be able to accommodate every request, so don’t be afraid to say that something doesn’t fit into the scope of the project or isn’t practical. It’s better to give such feedback if that’s the case.
Close when appropriate. Don’t be afraid to close issues that you don’t think will be done, or when it’s become clear from the conversation that there’s no further work to do. Issues can always be reopened if they are closed incorrectly, so feel free to close issues when appropriate. Just be sure to leave a comment explaining why the issue is being closed (if not closed by a commit).

Types of Issues and Pull Requests
There are five primary categories:

Bug: Something isn’t working the way it’s expected to work.
Enhancement: A change to something that already exists. For instance, adding a new option to an existing rule or fixing a bug in a rule where fixing it will result in the rule reporting more problems (in this case, use both “Bug” and “Enhancement”).
Feature: Adding something that doesn’t already exist. For example, adding a new rule, new formatter, or new command line flag.
Documentation: Adding, updating, or removing project documentation.
Question: An inquiry about how something works that won’t result in a code change. We prefer if people use GitHub Discussions or Discord for questions, but sometimes they’ll open an issue.

The first goal when evaluating an issue or pull request is to determine which category the issue falls into.
Triaging Process
All of ESLint’s issues and pull requests, across all GitHub repositories, are managed on our Triage Project. Please use the Triage project instead of the issues list when reviewing issues to determine what to work on. The Triage project has several columns:

Needs Triage: Issues and pull requests that have not yet been reviewed by anyone.
Triaging: Issues and pull requests that someone has reviewed but has not been able to fully triage yet.
Ready for Dev Team: Issues and pull requests that have been triaged and have all the information necessary for the dev team to take a look.
Evaluating: The dev team is evaluating these issues and pull requests to determine whether to move forward or not.
Feedback Needed: A team member is requesting more input from the rest of the team before proceeding.
Waiting for RFC: The next step in the process is for an RFC to be written.
RFC Opened: An RFC is opened to address these issues.
Blocked: The issue can’t move forward due to some dependency.
Ready to Implement: These issues have all the details necessary to start implementation.
Implementing: There is an open pull request for each of these issues or this is a pull request that has been approved.
Second Review Needed: Pull requests that already have one approval and the approver is requesting a second review before merging.
Merge Candidates: Pull requests that already have at least one approval and at least one approver believes the pull request is ready to merge into the next release but would still like a TSC member to verify.
Completed: The issue has been closed (either via pull request merge or by the team manually closing the issue).

We make every attempt to automate movement between as many columns as we can, but sometimes moving issues needs to be done manually.
When an Issue or Pull Request is Opened
When an issue or pull request is opened, it is automatically added to the “Needs Triage” column in the Triage project. These issues and pull requests need to be evaluated to determine the next steps. Anyone on the support team or dev team can follow these steps to properly triage issues.
Note: If an issue or pull request is in the “Triaging” column, that means someone is already triaging it, and you should let them finish. There’s no need to comment on issues or pull requests in the “Triaging” column unless someone asks for help.
The steps for triaging an issue or pull request are:

Move the issue or pull request from “Needs Triage” to “Triaging” in the Triage project.
Check: Has all the information in the issue template been provided?

No: If information is missing from the issue template, or you can’t tell what is being requested, please ask the author to provide the missing information:

Add the “needs info” label to the issue so we know that this issue is stalled due to lack of information.
Don’t move on to other steps until the necessary information has been provided.
If the issue author hasn’t provided the necessary information after 7 days, please close the issue. The bot will add a comment stating that the issue was closed because there was information missing.


Yes:

If the issue is actually a question (rather than something the dev team needs to change), please convert it to a discussion. You can continue the conversation as a discussion.
If the issue is reporting a bug, or if a pull request is fixing a bug, try to reproduce the issue following the instructions in the issue. If you can reproduce the bug, please add the “repro:yes” label. (The bot will automatically remove the “repro:needed” label.) If you can’t reproduce the bug, ask the author for more information about their environment or to clarify reproduction steps.
If the issue or pull request is reporting something that works as intended, please add the “works as intended” label and close the issue.
Please add labels describing the part of ESLint affected:

3rd party plugin: Related to third-party functionality (plugins, parsers, rules, etc.).
build: Related to commands run during a build (testing, linting, release scripts, etc.).
cli: Related to command line input or output, or to CLIEngine.
core: Related to internal APIs.
documentation: Related to content on eslint.org.
infrastructure: Related to resources needed for builds or deployment (VMs, CI tools, bots, etc.).
rule: Related to core rules.


Please assign an initial priority based on the importance of the issue or pull request. If you’re not sure, use your best judgment. We can always change the priority later.

P1: Urgent and important, we need to address this immediately.
P2: Important but not urgent. Should be handled by a TSC member or reviewer.
P3: Nice to have but not important. Can be handled by any team member.
P4: A good idea that we’d like to have but may take a while for the team to get to it.
P5: A good idea that the core team can’t commit to. Will likely need to be done by an outside contributor.


Please assign an initial impact assessment (make your best guess):

Low: Doesn’t affect many users.
Medium: Affects most users or has a noticeable effect on user experience.
High: Affects a lot of users, is a breaking change, or otherwise will be very noticeable to users.


If you can’t properly triage the issue or pull request, move the issue back to the “Needs Triage” column in the Triage project so someone else can triage it.
If a pull request references an already accepted issue, move it to the “Implementing” column in the Triage project.
If you have triaged the issue, move the issue to the “Ready for Dev Team” column in the Triage project.





Evaluation Process
When an issue has been moved to the “Ready for Dev Team” column, any dev team member can pick up the issue to start evaluating it.

Move the issue into the “Evaluating” column.
Next steps:

Bugs: If you can verify the bug, add the “accepted” label and ask if they would like to submit a pull request.
New Rules: If you are willing to champion the rule (meaning you believe it should be included in ESLint core and you will take ownership of the process for including it), add a comment saying you will champion the issue, assign the issue to yourself, and follow the guidelines below.
Rule Changes: If you are willing to champion the change and it would not be a breaking change (requiring a major version increment), add a comment saying that you will champion the issue, assign the issue to yourself, and follow the guidelines below.
Breaking Changes: If you suspect or can verify that a change would be breaking, label it as “Breaking”.
Duplicates: If you can verify the issue is a duplicate, add a comment mentioning the duplicate issue (such as, “Duplicate of #1234”) and close the issue.


Regardless of the above, always leave a comment. Don’t just add labels; engage with the person who opened the issue by asking a question (request more information if necessary) or stating your opinion of the issue. If it’s a verified bug, ask if the user would like to submit a pull request.
If the issue can’t be implemented because it needs an external dependency to be updated or needs to wait for another issue to be resolved, move the issue to the “Blocked” column.
If the issue has been accepted and an RFC is required as the next step, move the issue to the “Waiting for RFC” column and comment on the issue that an RFC is needed.

Note: “Good first issue” issues are intended to help new contributors feel welcome and empowered to make a contribution to ESLint. To ensure that new contributors are given a chance to work on these issues, issues labeled “good first issue” must be open for 30 days from the day the issue was labeled before a team member is permitted to work on them.
Accepting Issues and Pull Requests
Issues may be labeled as “accepted” when the issue is:

A bug that you’ve been able to reproduce and verify (i.e. you’re sure it’s a bug).
A new rule or rule change that you’re championing and consensus has been reached for its inclusion in the project.

The “accepted” label will be added to other issues by a TSC member if it’s appropriate for the roadmap.
When an issue is accepted and implementation can begin, it should be moved to the “Ready to Implement” column.
Championing Issues
New rules and rule changes require a champion. As champion, it’s your job to:

Gain consensus from the ESLint team on inclusion.
Guide the rule creation process until it’s complete (so only champion a rule that you have time to implement or help another contributor implement).

Once consensus has been reached on inclusion, add the “accepted” label. Optionally, add “help wanted” and “good first issue” labels, as necessary.
Consensus
Consensus is reached on issues when there are at least three team members who believe the change is a good idea and no one who believes the change is a bad idea. In order to indicate your support for an issue, leave a +1 reaction (thumbs up) on the original issue description in addition to any comments you might have.
When to Send to TSC
If consensus cannot be reached on an issue, or an issue’s progress has been stalled and it’s not clear if the issue should be closed, then you can refer the issue to the TSC for resolution. To do so, add the “tsc agenda” label to the issue and add a comment including the following information:

A one-paragraph summary of the discussion to this point. This should begin with “TSC Summary:”.
The question you would like the TSC to answer. This should begin with “TSC Question:”.

The issue will be discussed at the next TSC meeting and the resolution will be posted back to the issue.
Evaluating Core Features and Enhancements (TSC members only)
In addition to the above, changes to the core (including CLI changes) that would result in a minor or major version release must be approved by the TSC by standard TSC motion. Add the label “tsc agenda” to the issue and it will be discussed at the next TSC meeting. In general, requests should meet the following criteria to be considered:

The feature or enhancement is in scope for the project and should be added to the roadmap.
Someone is committed to including the change within the next year.
There is reasonable certainty about who will do the work.

When a suggestion is too ambitious or would take too much time to complete, it’s better not to accept the proposal. Stick to small, incremental changes and lay out a roadmap of where you’d like the project to go eventually. Don’t let the project get bogged down in big features that will take a long time to complete.
Breaking Changes: Be on the lookout for changes that would be breaking. Issues that represent breaking changes should be labeled as “breaking”.
Request Feedback from TSC
To request feedback from the TSC, team members can ping @eslint/eslint-tsc and add the label “tsc waiting” on an issue or pull request.
Unless otherwise requested, every TSC member should provide feedback on issues labeled “tsc waiting”.
If a TSC member is unable to respond in a timely manner, they should post a comment indicating when they expect to be able to leave their feedback.
The last TSC member who provides feedback on an issue labeled “tsc waiting” should remove the label.
When to Close an Issue
All team members are allowed to close issues depending on how the issue has been resolved.
Team members may close an issue immediately if:

The issue is a duplicate of an existing issue.
The issue is just a question and has been answered.

Team members may close an issue where the consensus is to not accept the issue after a waiting period (to ensure that other team members have a chance to review the issue before it is closed):

Wait 2 days if the issue was opened Monday through Friday.
Wait 3 days if the issue was opened on Saturday or Sunday.

In an effort to keep the issues backlog manageable, team members may also close an issue if the following conditions are met:

Unaccepted: Close after it has been open for 21 days, as these issues do not have enough support to move forward.
Accepted: Close after 90 days if no one from the team or the community is willing to step forward and own the work to complete to it.
Help wanted: Close after 90 days if it has not been completed.


            

            
                Edit this page\n\n\n\nReview Pull Requests
                

                Table of Contents
    
        
                
                    
                    Who Can Review Pull Requests?
            		

                    Reviewing a Pull Request
            		

                    Required Approvals for Pull Requests
            		

                    Moving a Pull Request Through the Triage Board
            		

                    Who Can Merge a Pull Request
            		

                    When to Merge a Pull Request
            		

                    When to Close a Pull Request
            
                
                    
                    Example Closing Comments
            		
                
            		
                
            
    


                Pull requests are submitted frequently and represent our best opportunity to interact with the community. As such, it’s important that pull requests are well-reviewed before being merged and that interactions on pull requests are positive.
Who Can Review Pull Requests?
Anyone, both team members and the public, may leave comments on pull requests.
Reviewing a Pull Request
When a pull request is opened, the bot will check the following:

Has the submitter signed a CLA?
Is the commit message summary in the correct format?
Is the commit summary too long?

The bot will add a comment specifying the problems that it finds. You do not need to look at the pull request any further until those problems have been addressed (there’s no need to comment on the pull request to ask the submitter to do what the bot asked - that’s why we have the bot!).
Once the bot checks have been satisfied, you check the following:

Double-check that the pull request title is correct based on the issue (or, if no issue is referenced, based on the stated problem).
If the pull request makes a change to core, ensure that an issue exists and the pull request references the issue in the commit message.
Does the code follow our conventions (including header comments, JSDoc comments, etc.)? If not, please leave that feedback and reference the Code Conventions documentation.
For code changes:

Are there tests that verify the change? If not, please ask for them.
Is documentation needed for the change? If yes, please ask the submitter to add the necessary documentation.


Are there any automated testing errors? If yes, please ask the submitter to check on them.
If you’ve reviewed the pull request and there are no outstanding issues, leave a comment “LGTM” to indicate your approval. If you would like someone else to verify the change, comment “LGTM but would like someone else to verify.”

Note: If you are a team member and you’ve left a comment on the pull request, please follow up to verify that your comments have been addressed.
Required Approvals for Pull Requests
Any committer, reviewer, or TSC member may approve a pull request, but the approvals required for merging differ based on the type of pull request.
One committer approval is required to merge a non-breaking change that is:

A documentation change
A bug fix (for either rules or core)
A dependency upgrade
Related to the build
A chore

For a non-breaking feature, pull requests require approval from one reviewer or TSC member, plus one additional approval from any other team member.
For a breaking change, pull requests require an approval from two TSC members.

                    
                    
                        Important
                        If you approve a pull request and don’t merge it, please leave a comment explaining why you didn’t merge it. You might say something like, “LGTM. Waiting three days before merging.” or “LGTM. Requires TSC member approval before merging.” or “LGTM. Would like another review before merging.”.

                    
                Moving a Pull Request Through the Triage Board
When a pull request is created, whether by a team member or an outside contributor, it is placed in the “Needs Triage” column of the Triage board automatically. The pull request should remain in that column until a team member begins reviewing it.
If the pull request does not have a related issue, then it should be moved through the normal triage process for issues to be marked as accepted. Once accepted, move the pull request to the “Implementing” column.
If the pull request does have a related issue, then:

If the issue is accepted, move the pull request to the “Implementing” column.
If the issue is not accepted, move the pull request to the “Evaluating” column until the issue is marked as accepted, at which point move the pull request to “Implementing”.

Once the pull request has one approval, one of three things can happen:

The pull request has the required approvals and the waiting period (see below) has passed so it can be merged.
The pull request has the required approvals and the waiting period has not passed, so it should be moved to the “Merge Candidates” column.
The pull request requires another approval before it can be merged, so it should be moved to the “Second Review Needed” column.

When the pull request has a second approval, it should either be merged (if 100% ready) or moved to the “Merge Candidates” column if there are any outstanding concerns that should be reviewed before the next release.
Who Can Merge a Pull Request
TSC members, reviewers, committers, and website team members may merge pull requests, depending on the contents of the pull request, once it has received the required approvals.
Website Team Members may merge a pull request in the eslint.org repository if it is:

A documentation change
A dependency upgrade
A chore

When to Merge a Pull Request
We use the “Merge” button to merge requests into the repository. Before merging a pull request, verify that:

All comments have been addressed.
Any team members who made comments have verified that their concerns were addressed.
All automated tests are passing (never merge a pull request with failing tests).

Be sure to say thank you to the submitter before merging, especially if they put a lot of work into the pull request.
Team members may merge a pull request immediately if it:

Makes a small documentation change.
Is a chore.
Fixes a block of other work on the repository (build-related, test-related, dependency-related, etc.).
Is an important fix to get into a patch release.

Otherwise, team members should observe a waiting period before merging a pull request:

Wait 2 days if the pull request was opened Monday through Friday.
Wait 3 days if the pull request was opened on Saturday or Sunday.

The waiting period ensures that other team members have a chance to review the pull request before it is merged.
Note: You should not merge your pull request unless you receive the required approvals.
When to Close a Pull Request
There are several times when it’s appropriate to close a pull request without merging:

The pull request addresses an issue that is already fixed.
The pull request hasn’t been updated in 17 days.
The pull request submitter isn’t willing to follow project guidelines.

In any of these cases, please be sure to leave a comment stating why the pull request is being closed.
Example Closing Comments
If a pull request hasn’t been updated in 17 days:

Closing because there hasn’t been activity for 17 days. If you’re still interested in submitting this code, please feel free to resubmit.

If a pull request submitter isn’t willing to follow project guidelines.

Unfortunately, we can’t accept pull requests that don’t follow our guidelines. I’m going to close this pull request now, but if you’d like to resubmit following our guidelines, we’ll be happy to review.


            

            
                Edit this page\n\nReview Pull Requests
                

                Table of Contents
    
        
                
                    
                    Who Can Review Pull Requests?
            		

                    Reviewing a Pull Request
            		

                    Required Approvals for Pull Requests
            		

                    Moving a Pull Request Through the Triage Board
            		

                    Who Can Merge a Pull Request
            		

                    When to Merge a Pull Request
            		

                    When to Close a Pull Request
            
                
                    
                    Example Closing Comments
            		
                
            		
                
            
    


                Pull requests are submitted frequently and represent our best opportunity to interact with the community. As such, it’s important that pull requests are well-reviewed before being merged and that interactions on pull requests are positive.
Who Can Review Pull Requests?
Anyone, both team members and the public, may leave comments on pull requests.
Reviewing a Pull Request
When a pull request is opened, the bot will check the following:

Has the submitter signed a CLA?
Is the commit message summary in the correct format?
Is the commit summary too long?

The bot will add a comment specifying the problems that it finds. You do not need to look at the pull request any further until those problems have been addressed (there’s no need to comment on the pull request to ask the submitter to do what the bot asked - that’s why we have the bot!).
Once the bot checks have been satisfied, you check the following:

Double-check that the pull request title is correct based on the issue (or, if no issue is referenced, based on the stated problem).
If the pull request makes a change to core, ensure that an issue exists and the pull request references the issue in the commit message.
Does the code follow our conventions (including header comments, JSDoc comments, etc.)? If not, please leave that feedback and reference the Code Conventions documentation.
For code changes:

Are there tests that verify the change? If not, please ask for them.
Is documentation needed for the change? If yes, please ask the submitter to add the necessary documentation.


Are there any automated testing errors? If yes, please ask the submitter to check on them.
If you’ve reviewed the pull request and there are no outstanding issues, leave a comment “LGTM” to indicate your approval. If you would like someone else to verify the change, comment “LGTM but would like someone else to verify.”

Note: If you are a team member and you’ve left a comment on the pull request, please follow up to verify that your comments have been addressed.
Required Approvals for Pull Requests
Any committer, reviewer, or TSC member may approve a pull request, but the approvals required for merging differ based on the type of pull request.
One committer approval is required to merge a non-breaking change that is:

A documentation change
A bug fix (for either rules or core)
A dependency upgrade
Related to the build
A chore

For a non-breaking feature, pull requests require approval from one reviewer or TSC member, plus one additional approval from any other team member.
For a breaking change, pull requests require an approval from two TSC members.

                    
                    
                        Important
                        If you approve a pull request and don’t merge it, please leave a comment explaining why you didn’t merge it. You might say something like, “LGTM. Waiting three days before merging.” or “LGTM. Requires TSC member approval before merging.” or “LGTM. Would like another review before merging.”.

                    
                Moving a Pull Request Through the Triage Board
When a pull request is created, whether by a team member or an outside contributor, it is placed in the “Needs Triage” column of the Triage board automatically. The pull request should remain in that column until a team member begins reviewing it.
If the pull request does not have a related issue, then it should be moved through the normal triage process for issues to be marked as accepted. Once accepted, move the pull request to the “Implementing” column.
If the pull request does have a related issue, then:

If the issue is accepted, move the pull request to the “Implementing” column.
If the issue is not accepted, move the pull request to the “Evaluating” column until the issue is marked as accepted, at which point move the pull request to “Implementing”.

Once the pull request has one approval, one of three things can happen:

The pull request has the required approvals and the waiting period (see below) has passed so it can be merged.
The pull request has the required approvals and the waiting period has not passed, so it should be moved to the “Merge Candidates” column.
The pull request requires another approval before it can be merged, so it should be moved to the “Second Review Needed” column.

When the pull request has a second approval, it should either be merged (if 100% ready) or moved to the “Merge Candidates” column if there are any outstanding concerns that should be reviewed before the next release.
Who Can Merge a Pull Request
TSC members, reviewers, committers, and website team members may merge pull requests, depending on the contents of the pull request, once it has received the required approvals.
Website Team Members may merge a pull request in the eslint.org repository if it is:

A documentation change
A dependency upgrade
A chore

When to Merge a Pull Request
We use the “Merge” button to merge requests into the repository. Before merging a pull request, verify that:

All comments have been addressed.
Any team members who made comments have verified that their concerns were addressed.
All automated tests are passing (never merge a pull request with failing tests).

Be sure to say thank you to the submitter before merging, especially if they put a lot of work into the pull request.
Team members may merge a pull request immediately if it:

Makes a small documentation change.
Is a chore.
Fixes a block of other work on the repository (build-related, test-related, dependency-related, etc.).
Is an important fix to get into a patch release.

Otherwise, team members should observe a waiting period before merging a pull request:

Wait 2 days if the pull request was opened Monday through Friday.
Wait 3 days if the pull request was opened on Saturday or Sunday.

The waiting period ensures that other team members have a chance to review the pull request before it is merged.
Note: You should not merge your pull request unless you receive the required approvals.
When to Close a Pull Request
There are several times when it’s appropriate to close a pull request without merging:

The pull request addresses an issue that is already fixed.
The pull request hasn’t been updated in 17 days.
The pull request submitter isn’t willing to follow project guidelines.

In any of these cases, please be sure to leave a comment stating why the pull request is being closed.
Example Closing Comments
If a pull request hasn’t been updated in 17 days:

Closing because there hasn’t been activity for 17 days. If you’re still interested in submitting this code, please feel free to resubmit.

If a pull request submitter isn’t willing to follow project guidelines.

Unfortunately, we can’t accept pull requests that don’t follow our guidelines. I’m going to close this pull request now, but if you’d like to resubmit following our guidelines, we’ll be happy to review.


            

            
                Edit this page\n\n\n\nManage Releases
                

                Table of Contents
    
        
                
                    
                    Release Manager
            		

                    Release Communication
            		

                    Process
            
                
                    
                    Release Parameters
            		
                
            		

                    Emergency Releases
            		

                    Troubleshooting
            
                
                    
                    npm publish returns a 404
            		
                
            		
                
            
    


                Releases are when a project formally publishes a new version so the community can use it. There are two types of releases:

Regular releases that follow semantic versioning and are considered production-ready.
Prereleases that are not considered production-ready and are intended to give the community a preview of upcoming changes.

Release Manager
One member of the Technical Steering Committee (TSC) is assigned to manage each scheduled release. The release manager is determined at the TSC meeting the day before the release.
The release manager is responsible for:

The scheduled release on Friday.
Monitoring issues over the weekend.
Determining if a patch release is necessary on Monday.
Publishing the patch release (if necessary).

The release manager should seek input from the whole team on the Monday following a release to double-check if a patch release is necessary.
The release manager needs to have access to ESLint’s two-factor authentication for npm in order to do a release.
Release Communication
Each scheduled release is associated with an autogenerated release issue (example). The release issue is the source of information for the team about the status of a release and contains a checklist that the release manager should follow.
Process
On the day of a scheduled release, the release manager should follow the steps in the release issue.
All release-related communications occur in a thread in the #team channel on Discord.
On the Monday following the scheduled release, the release manager needs to determine if a patch release is necessary. A patch release is considered necessary if any of the following occurred since the scheduled release:

A regression bug is causing people’s lint builds to fail when it previously passed.
Any bug that is causing a lot of problems for users (frequently happens due to new functionality).

The patch release decision should be made as early on Monday as possible. If a patch release is necessary, then follow the same steps as the scheduled release process.
In rare cases, a second patch release might be necessary if the release is known to have a severe regression that hasn’t been fixed by Monday. If this occurs, the release manager should announce the situation on the release issue, and leave the issue open until all patch releases are complete. However, it’s usually better to fix bugs for the next release cycle rather than doing a second patch release.
After the patch release has been published (or no patch release is necessary), close the release issue and inform the team that they can start merging in semver-minor changes again.
Release Parameters
The following tables show examples of the option to select as RELEASE_TYPE when starting eslint-js Release (the @eslint/js package release) and eslint Release (the eslint package release) jobs on Jenkins to release a new version with the latest features. In both jobs, main should be selected as RELEASE_BRANCH.



HEAD Version
Desired Next Version
eslint-js ReleaseRELEASE_TYPE




9.25.0
9.25.1
patch


9.25.0
9.26.0
minor


9.25.0
10.0.0-alpha.0
alpha.0


10.0.0-alpha.0
10.0.0-alpha.1
alpha


10.0.0-alpha.1
10.0.0-beta.0
beta


10.0.0-beta.0
10.0.0-beta.1
beta


10.0.0-beta.1
10.0.0-rc.0
rc


10.0.0-rc.0
10.0.0-rc.1
rc


10.0.0-rc.1
10.0.0
major






HEAD Version
Desired Next Version
eslint ReleaseRELEASE_TYPE




9.25.0
9.25.1 or 9.26.0
latest


9.25.0
10.0.0-alpha.0
alpha


10.0.0-alpha.0
10.0.0-alpha.1
alpha


10.0.0-alpha.1
10.0.0-beta.0
beta


10.0.0-beta.0
10.0.0-beta.1
beta


10.0.0-beta.1
10.0.0-rc.0
rc


10.0.0-rc.0
10.0.0-rc.1
rc


10.0.0-rc.1
10.0.0
latest



When releasing a new version of the previous major line, the option to select as RELEASE_TYPE depends on whether the HEAD version is a prerelease or not. In both jobs, the corresponding development branch (for example, v9.x-dev) should be selected as RELEASE_BRANCH.



HEAD Version
Previous Major Line Version
Desired Next Version
eslint-js ReleaseRELEASE_TYPE




10.0.0-alpha.0
9.25.0
9.25.1
patch


10.0.0-alpha.0
9.25.0
9.26.0
minor


10.0.0
9.25.0
9.25.1
maintenance.patch


10.0.0
9.25.0
9.26.0
maintenance.minor






HEAD Version
Previous Major Line Version
Desired Next Version
eslint ReleaseRELEASE_TYPE




10.0.0-alpha.0
9.25.0
9.25.1 or 9.26.0
latest


10.0.0
9.25.0
9.25.1 or 9.26.0
maintenance



Emergency Releases
An emergency release is unplanned and isn’t the regularly scheduled release or the anticipated patch release.
In general, we try not to do emergency releases. Even if there is a regression, it’s best to wait until Monday to see if any other problems arise so a patch release can fix as many issues as possible.
The only real exception is if ESLint is completely unusable by most of the current users. For instance, we once pushed a release that errored for everyone because it was missing some core files. In that case, an emergency release is appropriate.
Troubleshooting
npm publish returns a 404
This typically happens due to a permission error related to the npm token.

release-please uses a granular access token that expires after a year. This token is tied to the eslintbot npm account and needs to be regenerated every year in March. If the access token is expired, npm publish returns a 404.
Jenkins uses a classic access token without an expiration date, but it does require a 2FA code to publish. If the 2FA code is incorrect, then npm publish returns a 404.


            

            
                Edit this page\n\nManage Releases
                

                Table of Contents
    
        
                
                    
                    Release Manager
            		

                    Release Communication
            		

                    Process
            
                
                    
                    Release Parameters
            		
                
            		

                    Emergency Releases
            		

                    Troubleshooting
            
                
                    
                    npm publish returns a 404
            		
                
            		
                
            
    


                Releases are when a project formally publishes a new version so the community can use it. There are two types of releases:

Regular releases that follow semantic versioning and are considered production-ready.
Prereleases that are not considered production-ready and are intended to give the community a preview of upcoming changes.

Release Manager
One member of the Technical Steering Committee (TSC) is assigned to manage each scheduled release. The release manager is determined at the TSC meeting the day before the release.
The release manager is responsible for:

The scheduled release on Friday.
Monitoring issues over the weekend.
Determining if a patch release is necessary on Monday.
Publishing the patch release (if necessary).

The release manager should seek input from the whole team on the Monday following a release to double-check if a patch release is necessary.
The release manager needs to have access to ESLint’s two-factor authentication for npm in order to do a release.
Release Communication
Each scheduled release is associated with an autogenerated release issue (example). The release issue is the source of information for the team about the status of a release and contains a checklist that the release manager should follow.
Process
On the day of a scheduled release, the release manager should follow the steps in the release issue.
All release-related communications occur in a thread in the #team channel on Discord.
On the Monday following the scheduled release, the release manager needs to determine if a patch release is necessary. A patch release is considered necessary if any of the following occurred since the scheduled release:

A regression bug is causing people’s lint builds to fail when it previously passed.
Any bug that is causing a lot of problems for users (frequently happens due to new functionality).

The patch release decision should be made as early on Monday as possible. If a patch release is necessary, then follow the same steps as the scheduled release process.
In rare cases, a second patch release might be necessary if the release is known to have a severe regression that hasn’t been fixed by Monday. If this occurs, the release manager should announce the situation on the release issue, and leave the issue open until all patch releases are complete. However, it’s usually better to fix bugs for the next release cycle rather than doing a second patch release.
After the patch release has been published (or no patch release is necessary), close the release issue and inform the team that they can start merging in semver-minor changes again.
Release Parameters
The following tables show examples of the option to select as RELEASE_TYPE when starting eslint-js Release (the @eslint/js package release) and eslint Release (the eslint package release) jobs on Jenkins to release a new version with the latest features. In both jobs, main should be selected as RELEASE_BRANCH.



HEAD Version
Desired Next Version
eslint-js ReleaseRELEASE_TYPE




9.25.0
9.25.1
patch


9.25.0
9.26.0
minor


9.25.0
10.0.0-alpha.0
alpha.0


10.0.0-alpha.0
10.0.0-alpha.1
alpha


10.0.0-alpha.1
10.0.0-beta.0
beta


10.0.0-beta.0
10.0.0-beta.1
beta


10.0.0-beta.1
10.0.0-rc.0
rc


10.0.0-rc.0
10.0.0-rc.1
rc


10.0.0-rc.1
10.0.0
major






HEAD Version
Desired Next Version
eslint ReleaseRELEASE_TYPE




9.25.0
9.25.1 or 9.26.0
latest


9.25.0
10.0.0-alpha.0
alpha


10.0.0-alpha.0
10.0.0-alpha.1
alpha


10.0.0-alpha.1
10.0.0-beta.0
beta


10.0.0-beta.0
10.0.0-beta.1
beta


10.0.0-beta.1
10.0.0-rc.0
rc


10.0.0-rc.0
10.0.0-rc.1
rc


10.0.0-rc.1
10.0.0
latest



When releasing a new version of the previous major line, the option to select as RELEASE_TYPE depends on whether the HEAD version is a prerelease or not. In both jobs, the corresponding development branch (for example, v9.x-dev) should be selected as RELEASE_BRANCH.



HEAD Version
Previous Major Line Version
Desired Next Version
eslint-js ReleaseRELEASE_TYPE




10.0.0-alpha.0
9.25.0
9.25.1
patch


10.0.0-alpha.0
9.25.0
9.26.0
minor


10.0.0
9.25.0
9.25.1
maintenance.patch


10.0.0
9.25.0
9.26.0
maintenance.minor






HEAD Version
Previous Major Line Version
Desired Next Version
eslint ReleaseRELEASE_TYPE




10.0.0-alpha.0
9.25.0
9.25.1 or 9.26.0
latest


10.0.0
9.25.0
9.25.1 or 9.26.0
maintenance



Emergency Releases
An emergency release is unplanned and isn’t the regularly scheduled release or the anticipated patch release.
In general, we try not to do emergency releases. Even if there is a regression, it’s best to wait until Monday to see if any other problems arise so a patch release can fix as many issues as possible.
The only real exception is if ESLint is completely unusable by most of the current users. For instance, we once pushed a release that errored for everyone because it was missing some core files. In that case, an emergency release is appropriate.
Troubleshooting
npm publish returns a 404
This typically happens due to a permission error related to the npm token.

release-please uses a granular access token that expires after a year. This token is tied to the eslintbot npm account and needs to be regenerated every year in March. If the access token is expired, npm publish returns a 404.
Jenkins uses a classic access token without an expiration date, but it does require a 2FA code to publish. If the 2FA code is incorrect, then npm publish returns a 404.


            

            
                Edit this page\n\n\n\n