Documentation #

Math.js is an extensive math library for JavaScript and Node.js. It features a flexible expression parser with support for symbolic computation, comes with a large set of built-in functions and constants, and offers an integrated solution to work with different data types like numbers, big numbers, complex numbers, fractions, units, and matrices.

Math.js can be used in the browser, in node.js and in any JavaScript engine. Installation and download instructions are available on the Download page of the website.

Getting Started #


  Getting Started
  Examples


Documentation #


  Core
    
      Configuration
      Chaining
      Extension
      Serialization
    
  
  Expressions
    
      Parsing and evaluation
      Syntax
      Expression trees
      Algebra
      Customization
      Security
    
  
  Data Types
    
      Numbers
      BigNumbers
      bigints
      Fractions
      Complex Numbers
      Matrices
      Units
    
  
  Reference
    
      Classes
      Functions
      Constants
    
  
  Custom bundling
  Command Line Interface
  History\n\n\n\nAn extensive math library for JavaScript and Node.js #

Math.js is an extensive math library for JavaScript and Node.js. It features a flexible expression parser with support for symbolic computation, comes with a large set of built-in functions and constants, and offers an integrated solution to work with different data types like numbers, big numbers, complex numbers, fractions, units, and matrices. Powerful and easy to use.

Features #


  Supports numbers, big numbers, bigint, complex numbers, fractions, units, strings, arrays, and matrices.
  Is compatible with JavaScript’s built-in Math library.
  Contains a flexible expression parser.
  Does symbolic computation.
  Comes with a large set of built-in functions and constants.
  Can be used as a command line application as well.
  Runs on any JavaScript engine.
  Is easily extensible.
  Open source.



  
    Example #
    
      Here some example code demonstrating how to use the library.
      Click here to fiddle around.
    
    
// functions and constants
math.round(math.e, 3)                // 2.718
math.atan2(3, -3) / math.pi          // 0.75
math.log(10000, 10)                  // 4
math.sqrt(-4)                        // 2i
math.derivative('x^2 + x', 'x')      // 2*x+1
math.pow([[-1, 2], [3, 1]], 2)
     // [[7, 0], [0, 7]]

// expressions
math.evaluate('1.2 * (2 + 4.5)')     // 7.8
math.evaluate('12.7 cm to inch')     // 5 inch
math.evaluate('sin(45 deg) ^ 2')     // 0.5
math.evaluate('9 / 3 + 2i')          // 3 + 2i
math.evaluate('det([-1, 2; 3, 1])')  // -7

// chaining
math.chain(3)
    .add(4)
    .multiply(2)
    .done() // 14
  
  
  
    Demo #
    
      Try the expression parser below.
      See Math Notepad for a full application.
    
    loading...
    
      Shortcut keys:
      
        Press S to set focus to the input field
        Press Ctrl+F11 to toggle full screen
        Press Tab to autocomplete (repeat to cycle choices)
        Enter "clear" to clear history
      
    
  
   



  
  
    Sponsor
    
  

  
  
  
    
  

  
  
    Tweet
    
  

  
  
    
    
  

  
  
    
    
    
  

  

  
    Sponsored by\n\n\n\nAn extensive math library for JavaScript and Node.js #

Math.js is an extensive math library for JavaScript and Node.js. It features a flexible expression parser with support for symbolic computation, comes with a large set of built-in functions and constants, and offers an integrated solution to work with different data types like numbers, big numbers, complex numbers, fractions, units, and matrices. Powerful and easy to use.

Features #


  Supports numbers, big numbers, bigint, complex numbers, fractions, units, strings, arrays, and matrices.
  Is compatible with JavaScript’s built-in Math library.
  Contains a flexible expression parser.
  Does symbolic computation.
  Comes with a large set of built-in functions and constants.
  Can be used as a command line application as well.
  Runs on any JavaScript engine.
  Is easily extensible.
  Open source.



  
    Example #
    
      Here some example code demonstrating how to use the library.
      Click here to fiddle around.
    
    
// functions and constants
math.round(math.e, 3)                // 2.718
math.atan2(3, -3) / math.pi          // 0.75
math.log(10000, 10)                  // 4
math.sqrt(-4)                        // 2i
math.derivative('x^2 + x', 'x')      // 2*x+1
math.pow([[-1, 2], [3, 1]], 2)
     // [[7, 0], [0, 7]]

// expressions
math.evaluate('1.2 * (2 + 4.5)')     // 7.8
math.evaluate('12.7 cm to inch')     // 5 inch
math.evaluate('sin(45 deg) ^ 2')     // 0.5
math.evaluate('9 / 3 + 2i')          // 3 + 2i
math.evaluate('det([-1, 2; 3, 1])')  // -7

// chaining
math.chain(3)
    .add(4)
    .multiply(2)
    .done() // 14
  
  
  
    Demo #
    
      Try the expression parser below.
      See Math Notepad for a full application.
    
    loading...
    
      Shortcut keys:
      
        Press S to set focus to the input field
        Press Ctrl+F11 to toggle full screen
        Press Tab to autocomplete (repeat to cycle choices)
        Enter "clear" to clear history
      
    
  
   



  
  
    Sponsor
    
  

  
  
  
    
  

  
  
    Tweet
    
  

  
  
    
    
  

  
  
    
    
    
  

  

  
    Sponsored by\n\n\n\nInstall #

Math.js can be installed via npm:

npm install mathjs


When installed globally with npm (using the -g option), math.js is available as a command line application mathjs, see documentation on Command Line Interface. Math.js ships with built-in TypeScript type definitions.

Download #

Math.js can be downloaded or linked from various content delivery networks:


  
    
      CDN
      Url
    
  
  
    
      unpkg
      https://unpkg.com/mathjs@14.4.0/
    
    
      cdnjs
      https://cdnjs.com/libraries/mathjs
        
    
      jsDelivr
      https://www.jsdelivr.com/package/npm/mathjs
    
    
      PageCDN 
      https://pagecdn.com/lib/mathjs
    
  


Or download the full bundle directly from unpkg:


    math.js (version 14.4.0, 186 kB, minified and gzipped) 
    and if needed the source map


Too large for you? Create your own custom bundle.

Web Service #

Math.js is available as a RESTful web service: https://api.mathjs.org

Extensions #

Here some notable extensions for mathjs:


  
    
      Extension
      Description
    
  
  
    
      mathsteps
      A step-by-step math solver library that is focused on pedagogy (how best to teach). The math problems it focuses on are pre-algebra and algebra problems involving simplifying expressions.
    
    
      mathjs‑expression‑parser
      This custom build of mathjs contains just the expression parser and basic arithmetic functions for numbers. About four times as small as the full mathjs library.
    
    
      mathjs-simple-integral
      Extends Math.js to be able to compute simple integrals.
    
    
      math.diff.js
      Symbolic differentiation plugin for Math.js
    
    
      postcss-math
      PostCSS plugin for making calculations with math.js
    
  


Other math libraries #

Here some other interesting JavaScript math libraries. Some can be imported into math.js using math.import.


  
    
      Extension
      Description
    
  
  
    
      math‑expression‑evaluator
      An extremely efficient, flexible and amazing evaluator for Math expression in Javascript.
    
    
      numbers.js
      Advanced Mathematics Library for Node.js and JavaScript
    
    
      numeric.js
      Numerical analysis in Javascript
    
    
      decimal.js
      An arbitrary-precision Decimal type for JavaScript. Used by mathjs for BigNumber support.
    
    
      ndarray
      Multidimensional arrays for JavaScript
    
    
      Algebrite
      Computer Algebra System in Javascript (Coffeescript)
    
    
      algebra.js
      Build, display, and solve algebraic equations
    
    
      Nerdamer
      Symbolic Math for Javascript
    
    
      numeral-js
      A javascript library for formatting and manipulating numbers
    
    
      Cortex Compute Engine
      The Cortex Compute Engine can parse LaTeX to MathJSON, serialize MathJSON to LaTeX, format, simplify and evaluate MathJSON expressions
    
  


History #

A changelog describing the changes with each release is available on the page History.

Browser support #

Math.js works on any ES5 compatible JavaScript engine: node.js, Chrome, Firefox, Safari, Edge, and IE11.

Though there is no official support for older browsers, math.js should still work on older browsers
when using the es5-shim.

Source code #

The source code of math.js is available on GitHub: https://github.com/josdejong/mathjs.

License #

Math.js is open source and licensed under the
Apache 2.0 License\n\n\n\nGetting Started #

This getting started describes how to install, load, and use math.js.

Install #

Math.js can be installed using various package managers like npm, or by just downloading the library from the website: https://mathjs.org/download.html.

To install via npm, run:

npm install mathjs


Other ways to install math.js are described on the website.

Load #

Math.js can be used in node.js and in the browser. The library must be loaded
and instantiated. When creating an instance, one can optionally provide
configuration options as described in
Configuration.

ES modules #

Load the functions you need and use them:

import { sqrt } from 'mathjs'

console.log(sqrt(-4).toString()) // 2i


To use lightweight, number only implementations of all functions:

import { sqrt } from 'mathjs/number'

console.log(sqrt(4).toString()) // 2
console.log(sqrt(-4).toString()) // NaN


You can create a mathjs instance allowing configuration and importing of external functions as follows:

import { create, all } from 'mathjs'

const config = { }
const math = create(all, config)

console.log(math.sqrt(-4).toString()) // 2i


How to optimize your bundle size using tree-shaking is described on the page
Custom bundling.

Node.js #

Load math.js in node.js (CommonJS module system):

const { sqrt } = require('mathjs')

console.log(sqrt(-4).toString()) // 2i


Browser #

Math.js can be loaded as a regular JavaScript file in the browser, use the global
variable math to access the libary once loaded:

<!DOCTYPE HTML>
<html>
<head>
  <script src="math.js" type="text/javascript"></script>
</head>
<body>
  <script type="text/javascript">
    console.log(math.sqrt(-4).toString()) // 2i
  </script>
</body>
</html>


Use #

Math.js can be used similar to JavaScript’s built-in Math library. Besides that,
math.js can evaluate expressions (see Expressions) and
supports chaining (see Chaining).

The example code below shows how to use math.js. More examples can be found in the
section Examples.

// functions and constants
math.round(math.e, 3)                // 2.718
math.atan2(3, -3) / math.pi          // 0.75
math.log(10000, 10)                  // 4
math.sqrt(-4)                        // 2i
math.pow([[-1, 2], [3, 1]], 2)       // [[7, 0], [0, 7]]

// expressions
math.evaluate('12 / (2.3 + 0.7)')    // 4
math.evaluate('12.7 cm to inch')     // 5 inch
math.evaluate('sin(45 deg) ^ 2')     // 0.5
math.evaluate('9 / 3 + 2i')          // 3 + 2i
math.evaluate('det([-1, 2; 3, 1])')  // -7

// chained operations
math.chain(3)
    .add(4)
    .multiply(2)
    .done() // 14


Next #

To learn more about math.js, check out the available documentation and examples:


  Documentation
  Examples\n\n\n\nExamples


  Algebra
  Basic usage
  Bignumbers
  Chaining
  Complex numbers
  Expressions
  Fractions
  Import
  Matrices
  Objects
  Serialization
  Sparse matrices
  Units


Browser examples


  Angle configuration
  Basic usage
  Currency conversion
  Custom separators
  Lorenz
  Lorenz interactive
  Plot
  Pretty printing with mathjax
  Printing html
  Requirejs loading
  Rocket trajectory optimization
  Webworkers


Advanced examples


  Convert fraction to bignumber
  Custom argument parsing
  Custom datatype
  Custom evaluate using factories
  Custom evaluate using import
  Custom loading
  Custom relational functions
  Custom scope objects
  Expression trees
  Function transform
  More secure eval
  Web server\n\n\n\nDocumentation #

Math.js is an extensive math library for JavaScript and Node.js. It features a flexible expression parser with support for symbolic computation, comes with a large set of built-in functions and constants, and offers an integrated solution to work with different data types like numbers, big numbers, complex numbers, fractions, units, and matrices.

Math.js can be used in the browser, in node.js and in any JavaScript engine. Installation and download instructions are available on the Download page of the website.

Getting Started #


  Getting Started
  Examples


Documentation #


  Core
    
      Configuration
      Chaining
      Extension
      Serialization
    
  
  Expressions
    
      Parsing and evaluation
      Syntax
      Expression trees
      Algebra
      Customization
      Security
    
  
  Data Types
    
      Numbers
      BigNumbers
      bigints
      Fractions
      Complex Numbers
      Matrices
      Units
    
  
  Reference
    
      Classes
      Functions
      Constants
    
  
  Custom bundling
  Command Line Interface
  History\n\n\n\nDocumentation #

Math.js is an extensive math library for JavaScript and Node.js. It features a flexible expression parser with support for symbolic computation, comes with a large set of built-in functions and constants, and offers an integrated solution to work with different data types like numbers, big numbers, complex numbers, fractions, units, and matrices.

Math.js can be used in the browser, in node.js and in any JavaScript engine. Installation and download instructions are available on the Download page of the website.

Getting Started #


  Getting Started
  Examples


Documentation #


  Core
    
      Configuration
      Chaining
      Extension
      Serialization
    
  
  Expressions
    
      Parsing and evaluation
      Syntax
      Expression trees
      Algebra
      Customization
      Security
    
  
  Data Types
    
      Numbers
      BigNumbers
      bigints
      Fractions
      Complex Numbers
      Matrices
      Units
    
  
  Reference
    
      Classes
      Functions
      Constants
    
  
  Custom bundling
  Command Line Interface
  History\n\n\n\nCore #

Usage #

The core of math.js is the math namespace containing all functions and constants. There are three ways to do calculations in math.js:


  Doing regular function calls like math.add(math.sqrt(4), 2).
  Evaluating expressions like math.evaluate('sqrt(4) + 2')
  Chaining operations like math.chain(4).sqrt().add(2).


Configuration #

math.js can be configured using the math.config(), see page Configuration.

Extension #

math.js can be extended with new functions and constants using the function math.import(), see page Extension.

Serialization #

To persist or exchange data structures like matrices and units, the data types of math.js can be stringified as JSON. This is explained on the page Serialization.\n\n\n\nConfiguration #

Math.js contains a number of configuration options.
These options can be applied on a created mathjs instance and changed afterwards.

import { create, all } from 'mathjs'

// create a mathjs instance with configuration
const config = {
  relTol: 1e-12,
  absTol: 1e-15,
  matrix: 'Matrix',
  number: 'number',
  precision: 64,
  predictable: false,
  randomSeed: null
}
const math = create(all, config)

// read the applied configuration
console.log(math.config())

// change the configuration
math.config({
  number: 'BigNumber'
})


The following configuration options are available:


  
    relTol. The minimum relative difference used to test equality between two
compared values. This value is used by all relational functions.
Default value is 1e-12.
  
  
    absTol. The minimum absolute difference used to test equality between two
compared values. This value is used by all relational functions.
Default value is 1e-15.
  
  
    matrix. The default type of matrix output for functions.
Available values are: 'Matrix' (default) or 'Array'.
Where possible, the type of matrix output from functions is determined from
the function input: An array as input will return an Array, a Matrix as input
will return a Matrix. In case of no matrix as input, the type of output is
determined by the option matrix. In case of mixed matrix
inputs, a matrix will be returned always.
  
  
    number. The type used to parse strings into a numeric value or create a new
numeric value internally.

    For most functions, the type of output is determined from the input: 
a number as input will return a number as output, a BigNumber as input 
returns a BigNumber as output. But for example the functions 
math.evaluate('2+3'), math.parse('2+3'), math.range('1:10'), 
and math.unit('5cm') use the number configuration setting.

    Note that math.sqrt(4) will always return the number 2 regardless of 
the number configuration, because the numeric type can be determined from 
the input value.

    Available values are: 'number' (default), 'BigNumber', 'bigint', or 'Fraction'.
BigNumbers have higher precision than the default numbers of JavaScript, 
bigint can represent large integer numbers, 
and Fractions store values in terms of a numerator and 
denominator.
  
  
    numberFallback. When number is configured for example with value 'bigint',
and a value cannot be represented as bigint like in math.evaluate('2.3'), 
the value will be parsed in the type configured with numberFallback. 
Available values: 'number' (default) or 'BigNumber'.
  
  
    precision. The maximum number of significant digits for BigNumbers.
This setting only applies to BigNumbers, not to numbers.
Default value is 64.
  
  
    predictable. Predictable output type of functions. When true, output type
depends only on the input types. When false (default), output type can vary
depending on input values. For example math.sqrt(-4) returns complex('2i') when
predictable is false, and returns NaN when true.
Predictable output can be needed when programmatically handling the result of
a calculation, but can be inconvenient for users when evaluating dynamic
equations.
  
  
    randomSeed. Set this option to seed pseudo random number generation, making it deterministic. The pseudo random number generator is reset with the seed provided each time this option is set. For example, setting it to 'a' will cause math.random() to return 0.43449421599986604 upon the first call after setting the option every time. Set to null to seed the pseudo random number generator with a random seed. Default value is null.
  


Examples #

This section shows a number of configuration examples.

node.js #

import { create, all } from 'mathjs'

const config = {
  matrix: 'Array' // Choose 'Matrix' (default) or 'Array'
}
const math = create(all, config)

// range will output an Array
math.range(0, 4) // Array [0, 1, 2, 3]

// change the configuration from Arrays to Matrices
math.config({
  matrix: 'Matrix' // Choose 'Matrix' (default) or 'Array'
})

// range will output a Matrix
math.range(0, 4) // Matrix [0, 1, 2, 3]

// create an instance of math.js with BigNumber configuration
const bigmath = create(all, {
  number: 'BigNumber', // Choose 'number' (default), 'BigNumber', or 'Fraction'
  precision: 32        // 64 by default, only applicable for BigNumbers
})

// parser will parse numbers as BigNumber now:
bigmath.evaluate('1 / 3') // BigNumber, 0.33333333333333333333333333333333


browser #

<!DOCTYPE HTML>
<html>
<head>
  <script src="math.js" type="text/javascript"></script>
</head>
<body>
  <script type="text/javascript">
    // the default instance of math.js is available as 'math'

    // range will output a Matrix
    math.range(0, 4)          // Matrix [0, 1, 2, 3]

    // change the configuration of math from Matrices to Arrays
    math.config({
      matrix: 'Array'         // Choose 'Matrix' (default) or 'Array'
    })

    // range will output an Array
    math.range(0, 4)          // Array [0, 1, 2, 3]

    // create a new instance of math.js with bignumber configuration
    const bigmath = math.create({
      number: 'BigNumber',    // Choose 'number' (default), 'BigNumber', or 'Fraction'
      precision: 32           // 64 by default, only applicable for BigNumbers
    })

    // parser will parse numbers as BigNumber now:
    bigmath.evaluate('1 / 3') // BigNumber, 0.33333333333333333333333333333333
  </script>
</body>
</html>\n\n\n\nChaining #

Math.js supports chaining operations by wrapping a value into a Chain.
A chain can be created with the function math.chain(value)
(formerly math.select(value)).
All functions available in the math namespace can be executed via the chain.
The functions will be executed with the chain’s value as the first argument,
followed by extra arguments provided by the function call itself.

math.chain(3)
    .add(4)
    .subtract(2)
    .done() // 5

math.chain( [[1, 2], [3, 4]] )
    .subset(math.index(0, 0), 8)
    .multiply(3)
    .done() // [[24, 6], [9, 12]]


API #

A Chain is constructed as:

math.chain()
math.chain(value)


The Chain has all functions available in the math namespace, and has
a number of special functions:


  done()
Finalize the chain and return the chain’s value.
  valueOf()
The same as done(), returns the chain’s value.
  toString()
Executes math.format(value) onto the chain’s value, returning
a string representation of the value.


Note that a “rest” or “…” parameter may not be broken across the value
in the chain and a function call. For example

math.chain(3).median(4,5).done() // throws error


does not compute the median of 3, 4, and 5.\n\n\n\nExtension #

The library can easily be extended with functions and variables using the
import function. The import function is available on a mathjs instance, which can be created using the create function.

import { create, all } from 'mathjs'

const math = create(all)

math.import(/* ... */)


The function import accepts an object with functions and variables, or an array with factory functions. It has the following syntax:

math.import(functions: Object [, options: Object])


Where:


  
    functions is an object or array containing the functions and/or values to be
imported. import support regular values and functions, typed functions
(see section Typed functions), and factory functions
(see section Factory functions).
An array is only applicable when it contains factory functions.
  
  
    options is an optional second argument with options.
The following options are available:

    
      {boolean} override
If true, existing functions will be overwritten. The default value is false.
      {boolean} silent
If true, the function will not throw errors on duplicates or invalid
types. Default value is false.
      {boolean} wrap
If true, the functions will be wrapped in a wrapper function which
converts data types like Matrix to primitive data types like Array.
The wrapper is needed when extending math.js with libraries which do not
support the math.js data types. The default value is false.
    
  


The following code example shows how to import a function and a value into math.js:

// define new functions and variables
math.import({
  myvalue: 42,
  hello: function (name) {
    return 'hello, ' + name + '!'
  }
})

// defined functions can be used in both JavaScript as well as the parser
math.myvalue * 2                 // 84
math.hello('user')               // 'hello, user!'

const parser = math.parser()
parser.evaluate('myvalue + 10')  // 52
parser.evaluate('hello("user")') // 'hello, user!'


Import external libraries #

External libraries like
numbers.js and
numeric.js can be imported as follows.
The libraries must be installed using npm:

$ npm install numbers
$ npm install numeric


The libraries can be easily imported into math.js using import.
In order to convert math.js specific data types like Matrix to primitive types
like Array, the imported functions can be wrapped by enabling {wrap: true}.

import { create, all } from 'mathjs'
import * as numbers from 'numbers'
import * as numeric from 'numeric'

// create a mathjs instance and import the numbers.js and numeric.js libraries
const math = create(all)
math.import(numbers, {wrap: true, silent: true})
math.import(numeric, {wrap: true, silent: true})

// use functions from numbers.js
math.fibonacci(7)                           // 13
math.evaluate('fibonacci(7)')               // 13

// use functions from numeric.js
math.evaluate('eig([1, 2; 4, 3])').lambda.x // [5, -1]


Typed functions #

Typed functions can be created using math.typed. A typed function is a function
which does type checking on the input arguments. It can have multiple signatures.
And can automatically convert input types where needed.

A typed function can be created like:

const max = typed('max', {
  'number, number': function (a, b) {
    return Math.max(a, b)
  },

  'BigNumber, BigNumber': function (a, b) {
    return a.greaterThan(b) ? a : b
  }
})


Typed functions can be merged as long as there are no conflicts in the signatures.
This allows for extending existing functions in math.js with support for new
data types.

// create a new data type
function MyType (value) {
  this.value = value
}
MyType.prototype.isMyType = true
MyType.prototype.toString = function () {
  return 'MyType:' + this.value
}

// define a new datatype
math.typed.addType({
  name: 'MyType',
  test: function (x) {
    // test whether x is of type MyType
    return x && x.isMyType
  }
})

// use the type in a new typed function
const add = typed('add', {
  'MyType, MyType': function (a, b) {
    return new MyType(a.value + b.value)
  }
})

// import in math.js, extend the existing function `add` with support for MyType
math.import({add: add})

// use the new type
const ans = math.add(new MyType(2), new MyType(3)) // returns MyType(5)
console.log(ans)                                 // outputs 'MyType:5'


Detailed information on typed functions is available here:
https://github.com/josdejong/typed-function

Factory functions #

Regular JavaScript functions can be imported in math.js using math.import:

math.import({
  myFunction: function (a, b) {
     // ...
  }
})


The function can be stored in a separate file:

export function myFunction (a, b) {
  // ...
}


Which can be imported like:

import { myFunction } from './myFunction.js'

math.import({
  myFunction
})


An issue arises when myFunction needs functionality from math.js:
it doesn’t have access to the current instance of math.js when in a separate file.
Factory functions can be used to solve this issue. A factory function allows to inject dependencies into a function when creating it.

A syntax of factory function is:

factory(name: string, dependencies: string[], create: function, meta?: Object): function


where:


  name is the name of the created function.
  dependencies is an array with names of the dependent functions.
  create is a function which creates the function.
An object with the dependencies is passed as first argument.
  meta An optional object which can contain any meta data you want.
This will be attached as a property meta on the created function.
Known meta data properties used by the mathjs instance are:
    
      isClass: boolean  If true, the created function is supposed to be a
class, and for example will not be exposed in the expression parser
for security reasons.
      lazy: boolean.  By default, everything is imported lazily by import.
only as soon as the imported function or constant is actually used, it
will be constructed. A function can be forced to be created immediately
by setting lazy: false in the meta data.
      isTransformFunction: boolean. If true, the created function is imported
as a transform function. It will not be imported in math itself, only
in the internal mathWithTransform namespace that is used by the
expression parser.
      recreateOnConfigChange: boolean. If true, the imported factory will be
created again when there is a change in the configuration. This is for
example used for the constants like pi, which is different depending
on the configsetting number which can be numbers or BigNumbers.
      formerly: string. If present, the created function will also be
accessible on the instance under the name given by the value of
formerly as a (deprecated) synonym for the specified name. This
facility should only be used when a function is renamed, to allow
temporary use of the previous name, for backward compatibility.
    
  


Here an example of a factory function which depends on multiply:

import { factory, create, all } from 'mathjs'

// create a factory function
const name = 'negativeSquare'
const dependencies = ['multiply', 'unaryMinus']
const createNegativeSquare = factory(name, dependencies, function ({ multiply, unaryMinus }) {
    return function negativeSquare (x) {
      return unaryMinus(multiply(x, x))
    }
  })

// create an instance of the function yourself:
const multiply = (a, b) => a * b
const unaryMinus = (a) => -a
const negativeSquare = createNegativeSquare({ multiply, unaryMinus })
console.log(negativeSquare(3)) // -9

// or import the factory in a mathjs instance and use it there
const math = create(all)
math.import(createNegativeSquare)
console.log(math.negativeSquare(4)) // -16
console.log(math.evaluate('negativeSquare(5)')) // -25


You may wonder why you would inject functions multiply and unaryMinus
instead of just doing these calculations inside the function itself. The
reason is that this makes the factory function negativeSquare work for
different implementations: numbers, BigNumbers, units, etc.

import { Decimal } from 'decimal.js'

// create an instance of our negativeSquare supporting BigNumbers instead of numbers
const multiply = (a, b) => a.mul(b)
const unaryMinus = (a) => new Decimal(0).minus(a)
const negativeSquare = createNegativeSquare({ multiply, unaryMinus })\n\n\n\nSerialization #

Math.js has a number of data types like Matrix, Complex, and Unit. These
types are instantiated JavaScript objects. To be able to store these data types
or send them between processes, they must be serialized. The data types of
math.js can be serialized to JSON. Use cases:


  Store data in a database or on disk.
  Interchange of data between a server and a client.
  Interchange of data between a web worker and the browser.


Math.js types can be serialized using JavaScript’s built-in JSON.stringify
function:

const x = math.complex('2 + 3i')
const str = JSON.stringify(x, math.replacer)
console.log(str)
// outputs a string '{"mathjs":"Complex","re":2,"im":3}'



  IMPORTANT: in most cases works, serialization correctly without
passing the math.replacer function as second argument. This is because
in most cases we can rely on the default behavior of JSON.stringify, which 
uses the .toJSON method on classes like Unit and Complex to correctly 
serialize them. However, there are a few special cases like the 
number Infinity which does require the replacer function in order to be 
serialized without losing information: without it, Infinity will be 
serialized as "null" and cannot be deserialized correctly.

  So, it’s best to always pass the math.replacer function to prevent 
weird edge cases.


In order to deserialize a string, containing math.js data types, JSON.parse
can be used. In order to recognize the data types of math.js, JSON.parse must
be called with the reviver function of math.js:

const json = '{"mathjs":"Unit","value":5,"unit":"cm","fixPrefix":false}'
const x = JSON.parse(json, math.reviver)   // Unit 5 cm


Note that if math.js is used in conjunction with other data types, it is
possible to use multiple reviver functions at the same time by cascading them:

const reviver = function (key, value) {
  return reviver1(key, reviver2(key, value))
}\n\n\n\nExpressions #

Math.js contains a flexible and easy to use expression parser.
The parser supports all data types, functions and constants available in math.js.

Whilst the math.js library is aimed at JavaScript developers, the expression
parser is aimed at end users: mathematicians, engineers, students, pupils.
The syntax of the expression parser differs from JavaScript and the low-level
math.js library.

This section is divided in the following pages:


  Parsing and evaluation describes how to parse and
evaluate expressions with math.js.
  Syntax describes how to write expressions.
  Expression trees explains how to parse an expression into an
expression tree, and use this to analyse and manipulate the expression.
  Algebra describing symbolic computation in math.js.
  Customization describes how to customize processing and
evaluation of expressions.
  Security about security risks of executing arbitrary expressions.\n\n\n\nExpression parsing and evaluation #

Expressions can be parsed and evaluated in various ways:


  Using the function math.evaluate(expr [,scope]).
  Using the function math.compile(expr).
  Using the function math.parse(expr).
  By creating a parser, math.parser(), which contains a method
evaluate and keeps a scope with assigned variables in memory.


Evaluate #

Math.js comes with a function math.evaluate to evaluate expressions. Syntax:

math.evaluate(expr)
math.evaluate(expr, scope)
math.evaluate([expr1, expr2, expr3, ...])
math.evaluate([expr1, expr2, expr3, ...], scope)


Function evaluate accepts a single expression or an array with
expressions as the first argument and has an optional second argument
containing a scope with variables and functions. The scope can be a regular
JavaScript Map (recommended), a plain JavaScript object, or any custom 
class that implements the Map interface with methods get, set, keys 
and has. The scope will be used to resolve symbols, and to write assigned
variables and functions.

When an Object is used as scope, mathjs will internally wrap it in an 
ObjectWrappingMap interface since the internal functions can only use a Map 
interface. In case of custom defined functions like f(x) = x^2, the scope 
will be wrapped in a PartitionedMap, which reads and writes the function
variables (like x in this example) from a temporary map, and reads and writes
other variables from the original scope. The original scope is never copied, it
is only wrapped around when needed.

The following code demonstrates how to evaluate expressions.

// evaluate expressions
math.evaluate('sqrt(3^2 + 4^2)')        // 5
math.evaluate('sqrt(-4)')               // 2i
math.evaluate('2 inch to cm')           // 5.08 cm
math.evaluate('cos(45 deg)')            // 0.7071067811865476

// provide a scope
let scope = {
    a: 3,
    b: 4
}
math.evaluate('a * b', scope)           // 12
math.evaluate('c = 2.3 + 4.5', scope)   // 6.8
scope.c                                 // 6.8


Compile #

Math.js contains a function math.compile which compiles expressions
into JavaScript code. This is a shortcut for first parsing and then
compiling an expression. The syntax is:

math.compile(expr)
math.compile([expr1, expr2, expr3, ...])


Function compile accepts a single expression or an array with
expressions as the argument. Function compile returns an object with a function
evaluate([scope]), which can be executed to evaluate the expression against an
(optional) scope:

const code = math.compile(expr)       // compile an expression
const result = code.evaluate([scope]) // evaluate the code with an optional scope


An expression needs to be compiled only once, after which the
expression can be evaluated repeatedly and against different scopes.
The optional scope is used to resolve symbols and to write assigned
variables or functions. Parameter scope can be a regular Object, or Map.

Example usage:

// parse an expression into a node, and evaluate the node
const code1 = math.compile('sqrt(3^2 + 4^2)')
code1.evaluate()  // 5


Parse #

Math.js contains a function math.parse to parse expressions into an
expression tree. The syntax is:

math.parse(expr)
math.parse([expr1, expr2, expr3, ...])


Function parse accepts a single expression or an array with
expressions as the argument. Function parse returns the root node of the tree,
which can be successively compiled and evaluated:

const node = math.parse(expr)         // parse expression into a node tree
const code = node.compile()           // compile the node tree
const result = code.evaluate([scope]) // evaluate the code with an optional scope


The API of nodes is described in detail on the page
Expression trees.

An expression needs to be parsed and compiled only once, after which the
expression can be evaluated repeatedly. On evaluation, an optional scope
can be provided, which is used to resolve symbols and to write assigned
variables or functions. Parameter scope is a regular Object or Map.

Example usage:

// parse an expression into a node, and evaluate the node
const node1 = math.parse('sqrt(3^2 + 4^2)')
const code1 = node1.compile()
code1.evaluate() // 5

// provide a scope
const node2 = math.parse('x^a')
const code2 = node2.compile()
let scope = {
    x: 3,
    a: 2
}
code2.evaluate(scope) // 9

// change a value in the scope and re-evaluate the node
scope.a = 3
code2.evaluate(scope) // 27


Parsed expressions can be exported to text using node.toString(), and can
be exported to LaTeX using node.toTex(). The LaTeX export can be used to
pretty print an expression in the browser with a library like
MathJax. Example usage:

// parse an expression
const node = math.parse('sqrt(x/x+1)')
node.toString()   // returns 'sqrt((x / x) + 1)'
node.toTex()      // returns ' qrt{ {\frac{x}{x} }+{1} }'


Parser #

In addition to the static functions math.evaluate and
math.parse, math.js contains a parser with functions evaluate and
parse, which automatically keeps a scope with assigned variables in memory.
The parser also contains some convenience functions to get, set, and remove
variables from memory.

A parser can be created by:

const parser = math.parser()


The parser contains the following functions:


  clear()
Completely clear the parser’s scope.
  evaluate(expr)
Evaluate an expression. Returns the result of the expression.
  get(name)
Retrieve a variable or function from the parser’s scope.
  getAll()
Retrieve an object with all defined variables in the parser’s scope.
  getAllAsMap()
Retrieve a map with all defined variables in the parser’s scope.
  remove(name)
Remove a variable or function from the parser’s scope.
  set(name, value)
Set a variable or function in the parser’s scope.


The following code shows how to create and use a parser.

// create a parser
const parser = math.parser()

// evaluate expressions
parser.evaluate('sqrt(3^2 + 4^2)')      // 5
parser.evaluate('sqrt(-4)')             // 2i
parser.evaluate('2 inch to cm')         // 5.08 cm
parser.evaluate('cos(45 deg)')          // 0.7071067811865476

// define variables and functions
parser.evaluate('x = 7 / 2')            // 3.5
parser.evaluate('x + 3')                // 6.5
parser.evaluate('f(x, y) = x^y')        // f(x, y)
parser.evaluate('f(2, 3)')              // 8

// get and set variables and functions
const x = parser.get('x')               // x = 3.5
const f = parser.get('f')               // function
const g = f(3, 3)                       // g = 27
parser.set('h', 500)
parser.evaluate('h / 2')                // 250
parser.set('hello', function (name) {
    return 'hello, ' + name + '!'
})
parser.evaluate('hello("user")')        // "hello, user!"

// clear defined functions and variables
parser.clear()


Scope #

The scope is a data-structure used to store and lookup variables and functions defined and used by expressions.

It is passed to mathjs via calls to math.evaluate or simplify.

For ease of use, it can be a Plain Javascript Object; for safety it can be a plain Map and for flexibility, any object that has
the methods get/set/has/keys, seen on Map.

Some care is taken to mutate the same object that is passed into mathjs, so they can collect the definitions from mathjs scripts and expressions.

evaluate will fail if the expression uses a blacklisted symbol, preventing mathjs expressions to escape into Javascript. This is enforced by access to the scope.

For less reliance on this blacklist, scope can also be a Map, which allows mathjs expressions to define variables and functions of any name.

For more, see examples of custom scopes.\n\n\n\nExpression syntax #

This page describes the syntax of expression parser of math.js. It describes
how to work with the available data types, functions, operators, variables,
and more.

Differences from JavaScript #

The expression parser of math.js is aimed at a mathematical audience,
not a programming audience. The syntax is similar to most calculators and
mathematical applications. This is close to JavaScript as well, though there
are a few important differences between the syntax of the expression parser and
the lower level syntax of math.js. Differences are:


  No need to prefix functions and constants with the math.* namespace,
you can just enter sin(pi / 4).
  Matrix indexes are one-based instead of zero-based.
  There are index and range operators which allow more conveniently getting
and setting matrix indexes, like A[2:4, 1].
  Both indexes and ranges and have the upper-bound included.
  There is a differing syntax for defining functions. Example: f(x) = x^2.
  There are custom operators like x + y instead of add(x, y).
  Some operators are different. For example  ^ is used for exponentiation,
not bitwise xor.
  Implicit multiplication, like 2 pi, is supported and has special rules.
  Relational operators (<, >, <=, >=, ==, and !=) are chained, so the expression 5 < x < 10 is equivalent to 5 < x and x < 10.
  Multi-expression constructs like a = 1; b = 2; a + b or
"a = 1;\n cos(a)\n sin(a)" (where \n denotes newline)
produce a collection (“ResultSet”) of values. Those expressions
terminated by ; are evaluated for side effect only and their values
are suppressed from the result.


Operators #

The expression parser has operators for all common arithmetic operations such
as addition and multiplication. The expression parser uses conventional infix
notation for operators: an operator is placed between its arguments.
Round parentheses can be used to override the default precedence of operators.

// use operators
math.evaluate('2 + 3')       // 5
math.evaluate('2 * 3')       // 6

// use parentheses to override the default precedence
math.evaluate('2 + 3 * 4')   // 14
math.evaluate('(2 + 3) * 4') // 20


The following operators are available. Note that almost every operator listed
also has a function form with identical meaning that can be used
interchangeably. For example, x+y will always evaluate identically to
add(x,y). For a full list of the equivalences, see the section on
Functions below.


  
    
      Operator
      Name
      Syntax
      Associativity
      Example
      Result
    
  
  
    
      (, )
      Grouping
      (x)
      None
      2 * (3 + 4)
      14
    
    
      [, ]
      Matrix, Index
      [...]
      None
      [[1,2],[3,4]]
      [[1,2],[3,4]]
    
    
      {, }
      Object
      {...}
      None
      {a: 1, b: 2}
      {a: 1, b: 2}
    
    
      ,
      Parameter separator
      x, y
      Left to right
      max(2, 1, 5)
      5
    
    
      .
      Property accessor
      obj.prop
      Left to right
      obj={a: 12}; obj.a
      12
    
    
      ;
      Statement separator
      x; y
      Left to right
      a=2; b=3; a*b
      [6]
    
    
      ;
      Row separator
      [x; y]
      Left to right
      [1,2;3,4]
      [[1,2],[3,4]]
    
    
      \n
      Statement separator
      x \n y
      Left to right
      a=2 \n b=3 \n a*b
      [2,3,6]
    
    
      +
      Add
      x + y
      Left to right
      4 + 5
      9
    
    
      +
      Unary plus
      +y
      Right to left
      +4
      4
    
    
      -
      Subtract
      x - y
      Left to right
      7 - 3
      4
    
    
      -
      Unary minus
      -y
      Right to left
      -4
      -4
    
    
      *
      Multiply
      x * y
      Left to right
      2 * 3
      6
    
    
      .*
      Element-wise multiply
      x .* y
      Left to right
      [1,2,3] .* [1,2,3]
      [1,4,9]
    
    
      /
      Divide
      x / y
      Left to right
      6 / 2
      3
    
    
      ./
      Element-wise divide
      x ./ y
      Left to right
      [9,6,4] ./ [3,2,2]
      [3,3,2]
    
    
      %
      Percentage
      x%
      None
      8%
      0.08
    
    
      %
      Addition with Percentage
      x + y%
      Left to right
      100 + 3%
      103
    
    
      %
      Subtraction with Percentage
      x - y%
      Left to right
      100 - 3%
      97
    
    
      % mod
      Modulus
      x % y
      Left to right
      8 % 3
      2
    
    
      ^
      Power
      x ^ y
      Right to left
      2 ^ 3
      8
    
    
      .^
      Element-wise power
      x .^ y
      Right to left
      [2,3] .^ [3,3]
      [8,27]
    
    
      '
      Transpose
      y'
      Left to right
      [[1,2],[3,4]]'
      [[1,3],[2,4]]
    
    
      !
      Factorial
      y!
      Left to right
      5!
      120
    
    
      &
      Bitwise and
      x & y
      Left to right
      5 & 3
      1
    
    
      ~
      Bitwise not
      ~x
      Right to left
      ~2
      -3
    
    
      |
      Bitwise or
      x | y
      Left to right
      5 | 3
      7
    
    
      ^|
      Bitwise xor
      x ^| y
      Left to right
      5 ^| 2
      7
    
    
      <<
      Left shift
      x << y
      Left to right
      4 << 1
      8
    
    
      >>
      Right arithmetic shift
      x >> y
      Left to right
      8 >> 1
      4
    
    
      >>>
      Right logical shift
      x >>> y
      Left to right
      -8 >>> 1
      2147483644
    
    
      and
      Logical and
      x and y
      Left to right
      true and false
      false
    
    
      not
      Logical not
      not y
      Right to left
      not true
      false
    
    
      or
      Logical or
      x or y
      Left to right
      true or false
      true
    
    
      xor
      Logical xor
      x xor y
      Left to right
      true xor true
      false
    
    
      =
      Assignment
      x = y
      Right to left
      a = 5
      5
    
    
      ? :
      Conditional expression
      x ? y : z
      Right to left
      15 > 100 ? 1 : -1
      -1
    
    
      :
      Range
      x : y
      Right to left
      1:4
      [1,2,3,4]
    
    
      to, in
      Unit conversion
      x to y
      Left to right
      2 inch to cm
      5.08 cm
    
    
      ==
      Equal
      x == y
      Left to right
      2 == 4 - 2
      true
    
    
      !=
      Unequal
      x != y
      Left to right
      2 != 3
      true
    
    
      <
      Smaller
      x < y
      Left to right
      2 < 3
      true
    
    
      >
      Larger
      x > y
      Left to right
      2 > 3
      false
    
    
      <=
      Smallereq
      x <= y
      Left to right
      4 <= 3
      false
    
    
      >=
      Largereq
      x >= y
      Left to right
      2 + 4 >= 6
      true
    
  


Precedence #

The operators have the following precedence, from highest to lowest:


  
    
      Operators
      Description
    
  
  
    
      (...)[...]{...}
      GroupingMatrixObject
    
    
      x(...)x[...]obj.prop:
      Function callMatrix indexProperty accessorKey/value separator
    
    
      '
      Matrix transpose
    
    
      !
      Factorial
    
    
      ^, .^
      Exponentiation
    
    
      +, -, ~, not
      Unary plus, unary minus, bitwise not, logical not
    
    
      See section below
      Implicit multiplication
    
    
      *, /, .*, ./,%, mod
      Multiply, divide , percentage, modulus
    
    
      +, -
      Add, subtract
    
    
      :
      Range
    
    
      to, in
      Unit conversion
    
    
      <<, >>, >>>
      Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift
    
    
      ==, !=, <, >, <=, >=
      Relational
    
    
      &
      Bitwise and (lazily evaluated)
    
    
      ^|
      Bitwise xor
    
    
      |
      Bitwise or (lazily evaluated)
    
    
      and
      Logical and (lazily evaluated)
    
    
      xor
      Logical xor
    
    
      or
      Logical or (lazily evaluated)
    
    
      ?, :
      Conditional expression
    
    
      =
      Assignment
    
    
      ,
      Parameter and column separator
    
    
      ;
      Row separator
    
    
      \n, ;
      Statement separators
    
  


Lazy evaluation is used where logically possible for bitwise and logical
operators. In the following example, the value of x will not even be 
evaluated because it cannot effect the final result:
math.evaluate('false and x')        // false, no matter what x equals


Functions #

Functions are called by entering their name, followed by zero or more
arguments enclosed by parentheses. All available functions are listed on the
page Functions.

math.evaluate('sqrt(25)')           // 5
math.evaluate('log(10000, 3 + 7)')  // 4
math.evaluate('sin(pi / 4)')        // 0.7071067811865475


New functions can be defined by “assigning” an expression to a function call
with one or more variables. Such function assignments are limited: they can
only be defined on a single line.

const parser = math.parser()

parser.evaluate('f(x) = x ^ 2 - 5')
parser.evaluate('f(2)')     // -1
parser.evaluate('f(3)')     // 4

parser.evaluate('g(x, y) = x ^ y')
parser.evaluate('g(2, 3)')  // 8


Note that these function assignments do not create closures; put another way,
all free variables in mathjs are dynamic:

const parser = math.parser()

parser.evaluate('x = 7')
parser.evaluate('h(y) = x + y')
parser.evaluate('h(3)')         // 10
parser.evaluate('x = 3')
parser.evaluate('h(3)')         // 6, *not* 10


It is however possible to pass functions as parameters:

const parser = math.parser()

parser.evaluate('twice(func, x) = func(func(x))')
parser.evaluate('twice(square, 2)')    // 16
parser.evaluate('f(x) = 3*x')
parser.evaluate('twice(f, 2)')         // 18

// a simplistic "numerical derivative":
parser.evaluate('eps = 1e-10')
parser.evaluate('nd(f, x) = (f(x+eps) - func(x-eps))/(2*eps)')
parser.evaluate('nd(square,2)')        // 4.000000330961484


Math.js itself heavily uses typed functions, which ensure correct inputs and
throws meaningful errors when the input arguments are invalid. One can create
a typed-function in the
expression parser like:

const parser = math.parser()

parser.evaluate('f = typed({"number": f(x) = x ^ 2 - 5})')


Finally, as mentioned above, there is a function form for nearly every one of
the mathematical operator symbols. Moreover, for some associative operators,
the corresponding function allows arbitrarily many arguments. The table below
gives the full correspondence.


  
    
      Operator Expression
      Equivalent Function Expression
    
  
  
    
      a or b
      or(a,b)
    
    
      a xor b
      xor(a,b)
    
    
      a and b
      and(a,b)
    
    
      a \| b
      bitOr(a,b)
    
    
      a ^\| b
      bitXor(a,b)
    
    
      a & b
      bitAnd(a,b)
    
    
      a == b
      equal(a,b)
    
    
      a != b
      unequal(a,b)
    
    
      a < b
      smaller(a,b)
    
    
      a > b
      larger(a,b)
    
    
      a <= b
      smallerEq(a,b)
    
    
      a << 3
      leftShift(a,3)
    
    
      a >> 3
      rightArithShift(a,3)
    
    
      a >>> 3
      rightLogShift(a,3)
    
    
      u to cm
      to(u, cm)
    
    
      a + b + c + ...
      add(a,b,c,...)
    
    
      a - b
      subtract(a,b)
    
    
      a * b * c * ...
      multiply(a,b,c,...)
    
    
      A .* B
      dotMultiply(A,B)
    
    
      A ./ B
      dotDivide(A,B)
    
    
      a mod b
      mod(a,b)
    
    
      +a
      unaryPlus(a)
    
    
      -a
      unaryMinus(a)
    
    
      ~a
      bitNot(a)
    
    
      not a
      not(a)
    
    
      a^b
      pow(a,b)
    
    
      A .^ B
      dotPow(A,B)
    
    
      a!
      factorial(a)
    
    
      A'
      ctranspose(A)
    
  


Note that math.js embodies a preference for the operator forms, in that calling
simplify (see Algebra) converts any instances of the function
form into the corresponding operator.

Map and forEach #

The map and forEach functions can be used to apply a callback function to each element of an array or matrix.

The callback functions can be functions, typed functions, inline functions (only in the parser) or compiled inline functions (only in the parser).

The callback can have the following inputs:

  value: the current value in the array or matrix.
  index: the index of the current value expressed as an array of numbers.
  array: the array or matrix being iterated.


Below is the syntax for both functions:

map #

The map function applies a function to each element of an array and returns a new array with the results.

const parser = math.parser()

// Define a square function
parser.evaluate('square(x) = x ^ 2')

// Apply the square function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], square)')
// result: [1, 4, 9, 16]

// Apply an inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], f(x) = x ^ 2)')
// result: [1, 4, 9, 16]

// Apply a compiled inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], x ^ 2)')
// result: [1, 4, 9, 16]


forEach #
The forEach function applies a function to each element of an array or matrix but does not return a new array. It is useful for executing side effects.

// Define a function that prints each element
math.import({consoleLog: x => console.log(x)})
const parser = math.parser()

// Define a squareConsleLog function
parser.evaluate('squareConsoleLog(x) = consoleLog(x ^ 2)')

// Apply the squareConsleLog function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], squareConsleLog)')
// Prints: 1, 4, 9, 16

// Apply an inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], f(x) = consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16

// Apply a compiled inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16


These functions are useful for performing element-wise operations on arrays or matrices.

Constants and variables #

Math.js has a number of built-in constants such as pi and e.
All available constants are listed on he page
Constants.

// use constants
math.evaluate('pi')                 // 3.141592653589793
math.evaluate('e ^ 2')              // 7.3890560989306495
math.evaluate('log(e)')             // 1
math.evaluate('e ^ (pi * i) + 1')   // ~0 (Euler)


Variables can be defined using the assignment operator =, and can be used
like constants.

const parser = math.parser()

// define variables
parser.evaluate('a = 3.4')      // 3.4
parser.evaluate('b = 5 / 2')    // 2.5

// use variables
parser.evaluate('a * b')        // 8.5


Variable names must:


  Begin with an “alpha character”, which is:
    
      A latin letter (upper or lower case). Ascii: a-z, A-Z
      An underscore.                        Ascii: _
      A dollar sign.                        Ascii: $
      A latin letter with accents.          Unicode: \u00C0 - \u02AF
      A greek letter.                       Unicode: \u0370 - \u03FF
      A letter-like character.              Unicode: \u2100 - \u214F
      A mathematical alphanumeric symbol.   Unicode: \u{1D400} - \u{1D7FF} excluding invalid code points
    
  
  Contain only alpha characters (above) and digits 0-9
  Not be any of the following: mod, to, in, and, xor, or, not, end. It is possible to assign to some of these, but that’s not recommended.


It is possible to customize the allowed alpha characters, see Customize supported characters for more information.

Data types #

The expression parser supports booleans, numbers, complex numbers, units,
strings, matrices, and objects.

Booleans #

Booleans true and false can be used in expressions.

// use booleans
math.evaluate('true')               // true
math.evaluate('false')              // false
math.evaluate('(2 == 3) == false')  // true


Booleans can be converted to numbers and strings and vice versa using the
functions number and boolean, and string.

// convert booleans
math.evaluate('number(true)')       // 1
math.evaluate('string(false)')      // "false"
math.evaluate('boolean(1)')         // true
math.evaluate('boolean("false")')   // false


Numbers #

The most important and basic data type in math.js are numbers. Numbers use a
point as decimal mark. Numbers can be entered with exponential notation.
Examples:

// numbers in math.js
math.evaluate('2')        // 2
math.evaluate('3.14')     // 3.14
math.evaluate('1.4e3')    // 1400
math.evaluate('22e-3')    // 0.022


A number can be converted to a string and vice versa using the functions
number and string.

// convert a string into a number
math.evaluate('number("2.3")')    // 2.3
math.evaluate('string(2.3)')      // "2.3"


Math.js uses regular JavaScript numbers, which are floating points with a
limited precision and limited range. The limitations are described in detail
on the page Numbers.

math.evaluate('1e-325')   // 0
math.evaluate('1e309')    // Infinity
math.evaluate('-1e309')   // -Infinity


When doing calculations with floats, one can very easily get round-off errors:

// round-off error due to limited floating point precision
math.evaluate('0.1 + 0.2')  // 0.30000000000000004


When outputting results, the function math.format can be used to hide
these round-off errors when outputting results for the user:

const ans = math.evaluate('0.1 + 0.2')  //  0.30000000000000004
math.format(ans, {precision: 14})       // "0.3"


Numbers can be expressed as binary, octal, and hexadecimal literals:

math.evaluate('0b11')  //  3
math.evaluate('0o77')  //  63
math.evaluate('0xff')  //  255


A word size suffix can be used to change the behavior of non decimal literal evaluation:

math.evaluate('0xffi8')         // -1
math.evaluate('0xffffffffi32')  //  -1
math.evaluate('0xfffffffffi32') //  SyntaxError: String "0xfffffffff" is out of range


Non decimal numbers can include a radix point:
math.evaluate('0b1.1')         // 1.5
math.evaluate('0o1.4')         // 1.5
math.evaluate('0x1.8')         // 1.5


Numbers can be formatted as binary, octal, and hex strings using the notation option of the format function:

math.evaluate('format(3, {notation: "bin"})')    //  '0b11'
math.evaluate('format(63, {notation: "oct"})')   //  '0o77'
math.evaluate('format(255, {notation: "hex"})')  //  '0xff'
math.evaluate('format(-1, {notation: "hex"})')   //  '-0x1'
math.evaluate('format(2.3, {notation: "hex"})')  //  '0x2.4cccccccccccc'


The format function accepts a wordSize option to use in conjunction with the non binary notations:

math.evaluate('format(-1, {notation: "hex", wordSize: 8})')   //  '0xffi8'


The functions bin, oct, and hex are shorthand for the format function with notation set accordingly:

math.evaluate('bin(-1)')     // '-0b1'
math.evaluate('bin(-1, 8)')  // '0b11111111i8'


BigNumbers #

Math.js supports BigNumbers for calculations with an arbitrary precision.
The pros and cons of Number and BigNumber are explained in detail on the page
Numbers.

BigNumbers are slower but have a higher precision. Calculations with big
numbers are supported only by arithmetic functions.

BigNumbers can be created using the bignumber function:

math.evaluate('bignumber(0.1) + bignumber(0.2)') // BigNumber, 0.3


The default number type of the expression parser can be changed at instantiation
of math.js. The expression parser parses numbers as BigNumber by default:

// Configure the type of number: 'number' (default), 'BigNumber', or 'Fraction'
math.config({number: 'BigNumber'})

// all numbers are parsed as BigNumber
math.evaluate('0.1 + 0.2')  // BigNumber, 0.3


BigNumbers can be converted to numbers and vice versa using the functions
number and bignumber. When converting a BigNumber to a Number, the high
precision of the BigNumber will be lost. When a BigNumber is too large to be represented
as Number, it will be initialized as Infinity.

Complex numbers #

Complex numbers can be created using the imaginary unit i, which is defined
as i^2 = -1. Complex numbers have a real and complex part, which can be
retrieved using the functions re and im.

const parser = math.parser()

// create complex numbers
parser.evaluate('a = 2 + 3i')   // Complex, 2 + 3i
parser.evaluate('b = 4 - i')    // Complex, 4 - i

// get real and imaginary part of a complex number
parser.evaluate('re(a)')        // Number,  2
parser.evaluate('im(a)')        // Number,  3

// calculations with complex numbers
parser.evaluate('a + b')        // Complex, 6 + 2i
parser.evaluate('a * b')        // Complex, 11 + 10i
parser.evaluate('i * i')        // Number,  -1
parser.evaluate('sqrt(-4)')     // Complex, 2i


Units #

math.js supports units. Units can be used in the arithmetic operations
add, subtract, multiply, divide, and exponentiation.
Units can also be converted from one to another.
An overview of all available units can be found on the page
Units.

Units can be converted using the operator to or in.

// create a unit
math.evaluate('5.4 kg')                     // Unit, 5.4 kg

// convert a unit
math.evaluate('2 inch to cm')               // Unit, 5.08 cm
math.evaluate('20 celsius in fahrenheit')   // Unit, ~68 fahrenheit
math.evaluate('90 km/h to m/s')             // Unit, 25 m / s

// convert a unit to a number
// A second parameter with the unit for the exported number must be provided
math.evaluate('number(5 cm, mm)')           // Number, 50

// calculations with units
math.evaluate('0.5kg + 33g')                // Unit, 0.533 kg
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('12 seconds * 2')             // Unit, 24 seconds
math.evaluate('sin(45 deg)')                // Number, 0.7071067811865475
math.evaluate('9.81 m/s^2 * 5 s to mi/h')   // Unit, 109.72172512527 mi / h


Strings #

Strings are enclosed by double quotes “ or single quotes ‘. Strings can be concatenated using the
function concat (not by adding them using + like in JavaScript). Parts of
a string can be retrieved or replaced by using indexes. Strings can be converted
to a number using function number, and numbers can be converted to a string
using function string.

When setting the value of a character in a string, the character that has been
set is returned. Likewise, when a range of characters is set, that range of
characters is returned.

const parser = math.parser()

// create a string
parser.evaluate('"hello"')                        // String, "hello"

// string manipulation
parser.evaluate('a = concat("hello", " world")')  // String, "hello world"
parser.evaluate('size(a)')                        // Matrix [11]
parser.evaluate('a[1:5]')                         // String, "hello"
parser.evaluate('a[1] = "H"')                     // String, "H"
parser.evaluate('a[7:12] = "there!"')             // String, "there!"
parser.evaluate('a')                              // String, "Hello there!"

// string conversion
parser.evaluate('number("300")')                  // Number, 300
parser.evaluate('string(300)')                    // String, "300"


Strings can be used in the evaluate function, to parse expressions inside
the expression parser:

math.evaluate('evaluate("2 + 3")')  // 5


Matrices #

Matrices can be created by entering a series of values between square brackets,
elements are separated by a comma ,.
A matrix like [1, 2, 3] will create a vector, a 1-dimensional matrix with
size [3]. To create a multi-dimensional matrix, matrices can be nested into
each other. For easier creation of two-dimensional matrices, a semicolon ;
can be used to separate rows in a matrix.

// create a matrix
math.evaluate('[1, 2, 3]')                                // Matrix, size [3]
math.evaluate('[[1, 2, 3], [4, 5, 6]]')                   // Matrix, size [2, 3]
math.evaluate('[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]')     // Matrix, size [2, 2, 2]

// create a two dimensional matrix
math.evaluate('[1, 2, 3; 4, 5, 6]')                       // Matrix, size [2, 3]


Another way to create filled matrices is using the functions zeros, ones,
identity, and range.

// initialize a matrix with ones or zeros
math.evaluate('zeros(3, 2)')      // Matrix, [[0, 0], [0, 0], [0, 0]],  size [3, 2]
math.evaluate('ones(3)')          // Matrix, [1, 1, 1],                 size [3]
math.evaluate('5 * ones(2, 2)')   // Matrix, [[5, 5], [5, 5]],          size [2, 2]

// create an identity matrix
math.evaluate('identity(2)')      // Matrix, [[1, 0], [0, 1]],          size [2, 2]

// create a range
math.evaluate('1:4')              // Matrix, [1, 2, 3, 4],              size [4]
math.evaluate('0:2:10')           // Matrix, [0, 2, 4, 6, 8, 10],       size [6]


A subset can be retrieved from a matrix using indexes and a subset of a matrix
can be replaced by using indexes. Indexes are enclosed in square brackets, and
contain a number or a range for each of the matrix dimensions. A range can have
its start and/or end undefined. When the start is undefined, the range will start
at 1, when the end is undefined, the range will end at the end of the matrix.

There is a context variable end available as well to denote the end of the
matrix. This variable cannot be used in multiple nested indices. In that case,
end will be resolved as the end of the innermost matrix. To solve this, 
resolving of the nested index needs to be split in two separate operations.

IMPORTANT: matrix indexes and ranges work differently from the math.js indexes
in JavaScript: They are one-based with an included upper-bound, similar to most
math applications.

parser = math.parser()

// create matrices
parser.evaluate('a = [1, 2; 3, 4]')       // Matrix, [[1, 2], [3, 4]]
parser.evaluate('b = zeros(2, 2)')        // Matrix, [[0, 0], [0, 0]]
parser.evaluate('c = 5:9')                // Matrix, [5, 6, 7, 8, 9]

// replace a subset in a matrix
parser.evaluate('b[1, 1:2] = [5, 6]')     // Matrix, [[5, 6], [0, 0]]
parser.evaluate('b[2, :] = [7, 8]')       // Matrix, [[5, 6], [7, 8]]

// perform a matrix calculation
parser.evaluate('d = a * b')              // Matrix, [[19, 22], [43, 50]]

// retrieve a subset of a matrix
parser.evaluate('d[2, 1]')                // 43
parser.evaluate('d[2, 1:end]')            // Matrix, [[43, 50]]
parser.evaluate('c[end - 1 : -1 : 2]')    // Matrix, [8, 7, 6]


Objects #

Objects in math.js work the same as in languages like JavaScript and Python.
An object is enclosed by curly brackets {, }, and contains a set of
comma separated key/value pairs. Keys and values are separated by a colon :.
Keys can be a symbol like prop or a string like "prop".

math.evaluate('{a: 2 + 1, b: 4}')         // {a: 3, b: 4}
math.evaluate('{"a": 2 + 1, "b": 4}')     // {a: 3, b: 4}


Objects can contain objects:

math.evaluate('{a: 2, b: {c: 3, d: 4}}')  // {a: 2, b: {c: 3, d: 4}}


Object properties can be retrieved or replaced using dot notation or bracket
notation. Unlike JavaScript, when setting a property value, the whole object
is returned, not the property value

let scope = {
  obj: {
    prop: 42
  }
}

// retrieve properties
math.evaluate('obj.prop', scope)          // 42
math.evaluate('obj["prop"]', scope)       // 42

// set properties (returns the whole object, not the property value!)
math.evaluate('obj.prop = 43', scope)     // {prop: 43}
math.evaluate('obj["prop"] = 43', scope)  // {prop: 43}
scope.obj                                 // {prop: 43}


Multi-line expressions #

An expression can contain multiple lines, and expressions can be spread over
multiple lines. Lines can be separated by a newline character \n or by a
semicolon ;. Output of statements followed by a semicolon will be hidden from
the output, and empty lines are ignored. The output is returned as a ResultSet,
with an entry for every visible statement.

// a multi-line expression
math.evaluate('1 * 3 \n 2 * 3 \n 3 * 3')    // ResultSet, [3, 6, 9]

// semicolon statements are hidden from the output
math.evaluate('a=3; b=4; a + b \n a * b')   // ResultSet, [7, 12]

// single expression spread over multiple lines
math.evaluate('a = 2 +\n  3')               // 5
math.evaluate('[\n  1, 2;\n  3, 4\n]')      // Matrix, [[1, 2], [3, 4]]


The results can be read from a ResultSet via the property ResultSet.entries
which is an Array, or by calling ResultSet.valueOf(), which returns the
array with results.

Implicit multiplication #

Implicit multiplication means the multiplication of two symbols, numbers, or a grouped expression inside parentheses without using the * operator. This type of syntax allows a more natural way to enter expressions. For example:

math.evaluate('2 pi')         // 6.283185307179586
math.evaluate('(1+2)(3+4)')   // 21


Parentheses are parsed as a function call when there is a symbol or accessor on
the left hand side, like sqrt(4) or obj.method(4). In other cases the
parentheses are interpreted as an implicit multiplication.

Math.js will always evaluate implicit multiplication before explicit multiplication *, so that the expression x * y z is parsed as x * (y * z). Math.js also gives implicit multiplication higher precedence than division, except when the division matches the pattern [unaryPrefixOp]?[number] / [number] [symbol] or [unaryPrefixOp]?[number] / [number] [left paren]. In that special case, the division is evaluated first:

math.evaluate('20 kg / 4 kg')   // 5      Evaluated as (20 kg) / (4 kg)
math.evaluate('20 / 4 kg')      // 5 kg   Evaluated as (20 / 4) kg


The behavior of implicit multiplication can be summarized by these operator precedence rules, listed from highest to lowest precedence:


  Function calls: [symbol] [left paren]
  Explicit division / when the division matches this pattern: [+-~]?[number] / [+-~]?[number] [symbol] or [number] / [number] [left paren]
  Implicit multiplication
  All other division / and multiplication *


Implicit multiplication is tricky as there can appear to be ambiguity in how an expression will be evaluated. Experience has shown that the above rules most closely match user intent when entering expressions that could be interpreted different ways. It’s also possible that these rules could be tweaked in future major releases.  Use implicit multiplication carefully. If you don’t like the uncertainty introduced by implicit multiplication, use explicit * operators and parentheses to ensure your expression is evaluated the way you intend.

Here are some more examples using implicit multiplication:


  
    
      Expression
      Evaluated as
      Result
    
  
  
    
      (1 + 3) pi
      (1 + 3) * pi
      12.566370614359172
    
    
      (4 - 1) 2
      (4 - 1) * 2
      6
    
    
      3 / 4 mm
      (3 / 4) * mm
      0.75 mm
    
    
      2 + 3 i
      2 + (3 * i)
      2 + 3i
    
    
      (1 + 2) (4 - 2)
      (1 + 2) * (4 - 2)
      6
    
    
      sqrt(4) (1 + 2)
      sqrt(4) * (1 + 2)
      6
    
    
      8 pi / 2 pi
      (8 * pi) / (2 * pi)
      4
    
    
      pi / 2 pi
      pi / (2 * pi)
      0.5
    
    
      1 / 2i
      (1 / 2) * i
      0.5 i
    
    
      8.314 J / mol K
      8.314 J / (mol * K)
      8.314 J / (mol * K)
    
  


Comments #

Comments can be added to explain or describe calculations in the text. A comment
starts with a sharp sign character #, and ends at the end of the line. A line
can contain a comment only, or can contain an expression followed by a comment.

const parser = math.parser()

parser.evaluate('# define some variables')
parser.evaluate('width = 3')                              // 3
parser.evaluate('height = 4')                             // 4
parser.evaluate('width * height   # calculate the area')  // 12\n\n\n\nExpression trees #

When parsing an expression via math.parse(expr), math.js generates an
expression tree and returns the root node of the tree. An expression tree can
be used to analyze, manipulate, and evaluate expressions.

Example:

const node = math.parse('sqrt(2 + x)')


In this case, the expression sqrt(2 + x) is parsed as:

  FunctionNode    sqrt
                   |
  OperatorNode     +
                  / \
  ConstantNode   2   x   SymbolNode


Alternatively, this expression tree can be built by manually creating nodes:

const node1 = new math.ConstantNode(2)
const node2 = new math.SymbolNode('x')
const node3 = new math.OperatorNode('+', 'add', [node1, node2])
const node4 = new math.FunctionNode('sqrt', [node3])


The resulting expression tree with root node node4 is equal to the expression
tree generated by math.parse('sqrt(2 + x)').

API #

Methods #

All nodes have the following methods:


  
    clone() : Node

    Create a shallow clone of the node.
The node itself is cloned, its childs are not cloned.
  
  
    cloneDeep() : Node

    Create a deep clone of the node.
Both the node as well as all its childs are cloned recursively.
  
  
    compile() : Object

    Compile an expression into optimized JavaScript code. compile returns an
object with a function evaluate([scope]) to evaluate. Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const code = node.compile()        // returns {evaluate: function (scope) {...}}
const evaluate = code.evaluate({x: 3}) // returns 5
    
  
  
    evaluate([scope]) : Object

    Compile and evaluate an expression, this is the equivalent of doing
node.compile().evaluate(scope). Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const evaluate = node.evaluate({x: 3}) // returns 5
    
  
  
    equals(other: Node) : boolean

    Test whether this node equals an other node. Does a deep comparison of the
values of both nodes.
  
  
    filter(callback: function) : Node[]

    Recursively filter nodes in an expression tree. The callback function is
called as callback(node: Node, path: string, parent: Node) : boolean for
every node in the tree, and must return a boolean. The function filter
returns an array with nodes for which the test returned true.
Parameter path is a string containing a relative JSON Path.

    Example:

    const node = math.parse('x^2 + x/4 + 3*y')
const filtered = node.filter(function (node) {
  return node.isSymbolNode && node.name === 'x'
})
// returns an array with two entries: two SymbolNodes 'x'
    
  
  
    forEach(callback: function) : void

    Execute a callback for each of the child nodes of this node. The callback
function is called as callback(child: Node, path: string, parent: Node): void.
Parameter path is a string containing a relative JSON Path.

    See also traverse, which is a recursive version of forEach.

    Example:

    const node = math.parse('3 * x + 2')
node.forEach(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode *
//   ConstantNode 2
    
  
  
    map(callback: function) : Node[]

    Transform a node. Creates a new Node having it’s childs be the results of
calling the provided callback function for each of the childs of the original
node. The callback function is called as callback(child: Node, path: string,
parent: Node) and must return a Node. Parameter path is a string containing
a relative JSON Path.

    See also transform, which is a recursive version of map.
  
  
    toHTML(options: object): string

    Get a HTML representation of the parsed expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toHTML()
// returns
// <span class="math-function">sqrt</span>
// <span class="math-paranthesis math-round-parenthesis">(</span>
// <span class="math-number">2</span>
// <span class="math-operator math-binary-operator math-explicit-binary-operator">/</span>
// <span class="math-number">3</span>
// <span class="math-paranthesis math-round-parenthesis">)</span>
    

    Information about the available HTML classes in HTML Classes.
Information about the options in Customization.
  
  
    toString(options: object) : string

    Get a string representation of the parsed expression. This is not exactly
the same as the original input. Example:

    const node = math.parse('3+4*2')
node.toString()  // returns '3 + (4 * 2)'
    

    Information about the options in Customization.
  
  
    toTex(options: object): string

    Get a LaTeX representation of the
expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toTex() // returns ' qrt{\frac{2}{3}}'
    

    Information about the options in Customization.
  
  
    transform(callback: function)

    Recursively transform an expression tree via a transform function. Similar
to Array.map, but recursively executed on all nodes in the expression tree.
The callback function is a mapping function accepting a node, and returning
a replacement for the node or the original node. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree, and must return a Node. Parameter path is a string containing
a relative JSON Path.

    The transform function will stop iterating when a node is replaced by the
callback function, it will not iterate over replaced nodes.

    For example, to replace all nodes of type SymbolNode having name ‘x’ with a
ConstantNode with value 3:

    const node = math.parse('x^2 + 5*x')
const transformed = node.transform(function (node, path, parent) {
  if (node.isSymbolNode && node.name === 'x') {
    return new math.ConstantNode(3)
  }
  else {
    return node
  }
})
transformed.toString() // returns '3 ^ 2 + 5 * 3'
    
  
  
    traverse(callback: function): void

    Recursively traverse all nodes in a node tree. Executes given callback for
this node and each of its child nodes. Similar to Array.forEach, except
recursive.
The callback function is a mapping function accepting a node, and returning
nothing. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree. Parameter path is a string containing a relative JSON Path.
Example:

    const node = math.parse('3 * x + 2')
node.traverse(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode +
//   OperatorNode *
//   ConstantNode 3
//   SymbolNode x
//   ConstantNode 2
    
  


Properties #

Each Node has the following properties:


  
    comment: string

    A string holding a comment if there was any in the expression, or else the
string will be empty string. A comment can be attached to the root node of
an expression or to each of the childs nodes of a BlockNode.
  
  
    isNode: true

    Is defined with value true on Nodes. Additionally, each type of node
adds it’s own flag, for example a SymbolNode as has a property
isSymbolNode: true.
  
  
    type: string

    The type of the node, for example 'SymbolNode' in case of a SymbolNode.
  


Nodes #

math.js has the following types of nodes. All nodes are available at the
namespace math.

AccessorNode #

Construction:

new AccessorNode(object: Node, index: IndexNode)


Properties:


  object: Node
  index: IndexNode
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a[3]')

const object = new math.SymbolNode('a')
const constant3 = new math.ConstantNode(3)
const index = new math.IndexNode([constant3])
const node2 = new math.AccessorNode(object, index)


ArrayNode #

Construction:

new ArrayNode(items: Node[])


Properties:


  items: Node[]


Examples:

const node1 = math.parse('[1, 2, 3]')

const one    = new math.ConstantNode(1)
const two    = new math.ConstantNode(2)
const three  = new math.ConstantNode(3)
const node2  = new math.ArrayNode([one, two, three])


AssignmentNode #

Construction:

new AssignmentNode(object: SymbolNode, value: Node)
new AssignmentNode(object: SymbolNode | AccessorNode, index: IndexNode, value: Node)


Properties:


  object: SymbolNode | AccessorNode
  index: IndexNode | null
  value: Node
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a = 3')

const object = new math.SymbolNode('a')
const value = new math.ConstantNode(3)
const node2 = new math.AssignmentNode(object, value)


BlockNode #

A BlockNode is created when parsing a multi line expression like a=2;b=3 or
a=2\nb=3. Evaluating a BlockNode returns a ResultSet. The results can be
retrieved via ResultSet.entries or ResultSet.valueOf(), which contains
an Array with the results of the visible lines (i.e. lines not ending with
a semicolon).

Construction:

block = new BlockNode(Array.<{node: Node} | {node: Node, visible: boolean}>)


Properties:


  blocks: Array.<{node: Node, visible: boolean}>


Examples:

const block1 = math.parse('a=1; b=2; c=3')

const a = new math.SymbolNode('a')
const one = new math.ConstantNode(1)
const ass1 = new math.AssignmentNode(a, one)

const b = new math.SymbolNode('b')
const two = new math.ConstantNode(2)
const ass2 = new math.AssignmentNode(b, two)

const c = new math.SymbolNode('c')
const three = new math.ConstantNode(3)
const ass3 = new math.AssignmentNode(c, three)

const block2 = new BlockNode([
  {node: ass1, visible: false},
  {node: ass2, visible: false},
  {node: ass3, visible: true}
])


ConditionalNode #

Construction:

new ConditionalNode(condition: Node, trueExpr: Node, falseExpr: Node)


Properties:


  condition: Node
  trueExpr: Node
  falseExpr: Node


Examples:

const node1 = math.parse('a > 0 ? a : -a')

const a         = new math.SymbolNode('a')
const zero      = new math.ConstantNode(0)
const condition = new math.OperatorNode('>', 'larger', [a, zero])
const trueExpr  = a
const falseExpr = new math.OperatorNode('-', 'unaryMinus', [a])
const node2     = new math.ConditionalNode(condition, trueExpr, falseExpr)


ConstantNode #

Construction:

new ConstantNode(value: *)


Properties:


  value: *


Examples:

const node1 = math.parse('2.4')

const node2 = new math.ConstantNode(2.4)
const node3 = new math.ConstantNode('foo')


FunctionAssignmentNode #

Construction:

new FunctionAssignmentNode(name: string, params: string[], expr: Node)


Properties:


  name: string
  params: string[]
  expr: Node


Examples:

const node1 = math.parse('f(x) = x^2')

const x      = new math.SymbolNode('x')
const two    = new math.ConstantNode(2)
const expr   = new math.OperatorNode('^', 'pow', [x, 2])
const node2  = new math.FunctionAssignmentNode('f', ['x'], expr)


FunctionNode #

Construction:

new FunctionNode(fn: Node | string, args: Node[])


Properties:


  fn: Node | string (read-only) The object or function name which to invoke.
  args: Node[]


Static functions:


  FunctionNode.onUndefinedFunction(name: string). This function is invoked when an undefined function is evaluated. By default, the function throws an exception “Undefined function x”. The function can be overwritten to customize this behavior. See also SymbolNode.onUndefinedSymbol.


Examples:

const node1 = math.parse('sqrt(4)')

const four  = new math.ConstantNode(4)
const node3 = new math.FunctionNode(new SymbolNode('sqrt'), [four])


IndexNode #

Construction:

new IndexNode(dimensions: Node[])
new IndexNode(dimensions: Node[], dotNotation: boolean)


Each dimension can be a single value, a range, or a property. The values of
indices are one-based, including range end.

An optional property dotNotation can be provided describing whether this index
was written using dot notation like a.b, or using bracket notation
like a["b"]. Default value is false. This information is used when
stringifying the IndexNode.

Properties:


  dimensions: Node[]
  dotNotation: boolean


Examples:

const node1 = math.parse('A[1:3, 2]')

const A     = new math.SymbolNode('A')
const one   = new math.ConstantNode(1)
const two   = new math.ConstantNode(2)
const three = new math.ConstantNode(3)

const range = new math.RangeNode(one, three)
const index = new math.IndexNode([range, two])
const node2 = new math.AccessorNode(A, index)


ObjectNode #

Construction:

new ObjectNode(properties: Object.<string, Node>)


Properties:


  properties: Object.<string, Node>


Examples:

const node1 = math.parse('{a: 1, b: 2, c: 3}')

const a = new math.ConstantNode(1)
const b = new math.ConstantNode(2)
const c = new math.ConstantNode(3)
const node2 = new math.ObjectNode({a: a, b: b, c: c})


OperatorNode #

Construction:

new OperatorNode(op: string, fn: string, args: Node[], implicit: boolean = false)


Additional methods:


  
    isUnary() : boolean

    Returns true when the OperatorNode contains exactly one argument,
like with a unary minus:

    const a = new math.ConstantNode(2)
const b = new math.OperatorNode('-', 'unaryMinus', [a])
b.isUnary() // true
    
  
  
    isBinary() : boolean

    Returns true when the OperatorNode contains exactly two arguments,
like with most regular operators:

    const a = new math.ConstantNode(2)
const b = new math.ConstantNode(3)
const c = new math.OperatorNode('+', 'add', [a, b])
c.isBinary() // true
    
  


Properties:


  op: string
  fn: string
  args: Node[]
  implicit: boolean True in case of an implicit multiplication, false otherwise


Examples:

const node1 = math.parse('2.3 + 5')

const a     = new math.ConstantNode(2.3)
const b     = new math.ConstantNode(5)
const node2 = new math.OperatorNode('+', 'add', [a, b])


ParenthesisNode #

Construction:

new ParenthesisNode(content: Node)


Properties:


  content: Node


Examples:

const node1 = math.parse('(1)')

const a     = new math.ConstantNode(1)
const node2 = new math.ParenthesisNode(a)


RangeNode #

Construction:

new RangeNode(start: Node, end: Node [, step: Node])


Properties:


  start: Node
  end: Node
  step: Node | null


Examples:

const node1 = math.parse('1:10')
const node2 = math.parse('0:2:10')

const zero = new math.ConstantNode(0)
const one = new math.ConstantNode(1)
const two = new math.ConstantNode(2)
const ten = new math.ConstantNode(10)

const node3 = new math.RangeNode(one, ten)
const node4 = new math.RangeNode(zero, ten, two)


RelationalNode #

Construction:

new RelationalNode(conditionals: string[], params: Node[])


conditionals is an array of strings, each of which may be ‘smaller’, ‘larger’, ‘smallerEq’, ‘largerEq’, ‘equal’, or ‘unequal’. The conditionals array must contain exactly one fewer item than params.

Properties:


  conditionals: string[]
  params: Node[]


A RelationalNode efficiently represents a chained conditional expression with two or more comparison operators, such as 10 < x <= 50. The expression is equivalent to 10 < x and x <= 50, except that x is evaluated only once, and evaluation stops (is “short-circuited”) once any condition tests false. Operators that are subject to chaining are <, >, <=, >=, ==, and !=. For backward compatibility, math.parse will return an OperatorNode if only a single conditional is present (such as x > 2).

Examples:


const ten = new math.ConstantNode(10)
const x = new math.SymbolNode('x')
const fifty = new math.ConstantNode(50)

const node1 = new math.RelationalNode(['smaller', 'smallerEq'], [ten, x, fifty])
const node2 = math.parse('10 < x <= 50')


SymbolNode #

Construction:

new SymbolNode(name: string)


Properties:


  name: string


Static functions:


  SymbolNode.onUndefinedSymbol(name: string). This function is invoked when an undefined symbol is evaluated. By default, the function throws an exception “Undefined symbol x”. The function can be overwritten to customize this behavior. See also FunctionNode.onUndefinedFunction.


Examples:

const node = math.parse('x')

const x = new math.SymbolNode('x')\n\n\n\nAlgebra (symbolic computation) #

math.js has built-in support for symbolic computation (CAS). It can parse expressions into an expression tree and do algebraic operations like simplification and derivation on the tree.


  It’s worth mentioning an excellent extension on math.js here: mathsteps, a step-by-step math solver library that is focused on pedagogy (how best to teach). The math problems it focuses on are pre-algebra and algebra problems involving simplifying expressions.


Simplify #

The function math.simplify simplifies an expression tree:

// simplify an expression
console.log(math.simplify('3 + 2 / 4').toString())              // '7 / 2'
console.log(math.simplify('2x + 3x').toString())                // '5 * x'
console.log(math.simplify('x^2 + x + 3 + x^2').toString())      // '2 * x ^ 2 + x + 3'
console.log(math.simplify('x * y * -x / (x ^ 2)').toString())   // '-y'


The function accepts either a string or an expression tree (Node) as input, and outputs a simplified expression tree (Node). This node tree can be transformed and evaluated as described in detail on the page Expression trees.

// work with an expression tree, evaluate results
const f = math.parse('2x + x')
const simplified = math.simplify(f)
console.log(simplified.toString())       // '3 * x'
console.log(simplified.evaluate({x: 4})) // 12


Among its other actions, calling simplify() on an expression will convert
any functions that have operator equivalents to their operator form:
console.log(math.simplify('multiply(x,3)').toString)  // '3 * x'


Note that simplify has an optional argument scope that allows the definitions of variables in the expression (as numeric values, or as further expressions) to be specified and used in the simplification, e.g. continuing the previous example,

console.log(math.simplify(f, {x: 4}).toString()) // 12
console.log(math.simplify(f, {x: math.parse('y+z')}).toString()) // '3*(y+z)'


In general, simplification is an inherently dfficult problem; in fact, for certain classes of expressions and algebraic equivalences, it is undecidable whether a given expression is equivalent to zero. Moreover, simplification generally depends on the properties of the operations involved; since multiplication (for example) may have different properties (e.g., it might or might not be commutative) depending on the domain under consideration, different simplifications might be appropriate.

As a result, simplify() has an additional optional argument, options, which controls its behavior. This argument is an object specifying any of various properties concerning the simplification process. See the detailed documentation for a complete list, but currently the two most important properties are as follows. Note that the options argument may only be specified if the scope is as well.


  exactFractions - a boolean which specifies whether non-integer numerical constants should be simplified to rational numbers when possible (true), or always converted to decimal notation (false).
  context - an object whose keys are the names of operations (‘add’, ‘multiply’, etc.) and whose values specify algebraic properties of the corresponding operation (currently any of ‘total’, ‘trivial’, ‘commutative’, and ‘associative’). Simplifications will only be performed if the properties they rely on are true in the given context. For example,
    const expr = math.parse('x*y-y*x')
console.log(math.simplify(expr).toString())  // 0; * is commutative by default
console.log(math.simplify(expr, {}, {context: {multiply: {commutative: false}}}))
// 'x*y-y*x'; the order of the right multiplication can't be reversed.
    
  


Note that the default context is very permissive (allows a lot of simplifications) but that there is also a math.simplify.realContext that only allows simplifications that are guaranteed to preserve the value of the expression on all real numbers:
const rational = math.parse('(x-1)*x/(x-1)')
console.log(math.simplify(expr, {}, {context: math.simplify.realContext})
  // '(x-1)*x/(x-1)'; canceling the 'x-1' makes the expression defined at 1


For more details on the theory of expression simplification, see:


  Strategies for simplifying math expressions (Stackoverflow)
  Symbolic computation - Simplification (Wikipedia)


Derivative #

The function math.derivative finds the symbolic derivative of an expression:

// calculate a derivative
console.log(math.derivative('2x^2 + 3x + 4', 'x').toString())   // '4 * x + 3'
console.log(math.derivative('sin(2x)', 'x').toString())         // '2 * cos(2 * x)'


Similar to the function math.simplify, math.derivative accepts either a string or an expression tree (Node) as input, and outputs a simplified expression tree (Node).

// work with an expression tree, evaluate results
const h = math.parse('x^2 + x')
const x = math.parse('x')
const dh = math.derivative(h, x)
console.log(dh.toString())        // '2 * x + 1'
console.log(dh.evaluate({x: 3}))  // '7'


The rules used by math.derivative can be found on Wikipedia:


  Differentiation rules (Wikipedia)


Rationalize #

The function math.rationalize transforms a rationalizable expression in a rational fraction.
If rational fraction is one variable polynomial then converts the numerator and denominator in canonical form, with decreasing exponents, returning the coefficients of numerator.


math.rationalize('2x/y - y/(x+1)')
              // (2*x^2-y^2+2*x)/(x*y+y)
math.rationalize('(2x+1)^6')
              // 64*x^6+192*x^5+240*x^4+160*x^3+60*x^2+12*x+1
math.rationalize('2x/( (2x-1) / (3x+2) ) - 5x/ ( (3x+4) / (2x^2-5) ) + 3')
              // -20*x^4+28*x^3+104*x^2+6*x-12)/(6*x^2+5*x-4)

math.rationalize('x+x+x+y',{y:1}) // 3*x+1
math.rationalize('x+x+x+y',{})    // 3*x+y

const ret = math.rationalize('x+x+x+y',{},true)
              // ret.expression=3*x+y, ret.variables = ["x","y"]
const ret = math.rationalize('-2+5x^2',{},true)
              // ret.expression=5*x^2-2, ret.variables = ["x"], ret.coefficients=[-2,0,5]\n\n\n\nCustomization #

Besides parsing and evaluating expressions, the expression parser supports
a number of features to customize processing and evaluation of expressions
and outputting expressions.

On this page:


  Function transforms
  Custom argument parsing
  Custom LaTeX handlers
  Custom HTML, LaTeX and string output
  Customize supported characters


Function transforms #

It is possible to preprocess function arguments and post process a functions
return value by writing a transform for the function. A transform is a
function wrapping around a function to be transformed or completely replaces
a function.

For example, the functions for math.js use zero-based matrix indices (as is
common in programing languages), but the expression parser uses one-based
indices. To enable this, all functions dealing with indices have a transform,
which changes input from one-based to zero-based, and transforms output (and
error message) from zero-based to one-based.

// using plain JavaScript, indices are zero-based:
const a = [[1, 2], [3, 4]]       // a 2x2 matrix
math.subset(a, math.index(0, 1)) // returns 2

// using the expression parser, indices are transformed to one-based:
const a = [[1, 2], [3, 4]] // a 2x2 matrix
let scope = {
  a: a
}
math.evaluate('subset(a, index(1, 2))', scope) // returns 2


To create a transform for a function, the transform function must be attached
to the function as property transform:

import { create, all } from 'mathjs'
const math = create(all)

// create a function
function addIt(a, b) {
  return a + b
}

// attach a transform function to the function addIt
addIt.transform = function (a, b) {
  console.log('input: a=' + a + ', b=' + b)
  // we can manipulate input here before executing addIt

  const res = addIt(a, b)

  console.log('result: ' + res)
  // we can manipulate result here before returning

  return res
}

// import the function into math.js
math.import({
  addIt: addIt
})

// use the function via the expression parser
console.log('Using expression parser:')
console.log('2+4=' + math.evaluate('addIt(2, 4)'))
// This will output:
//
//     input: a=2, b=4
//     result: 6
//     2+4=6

// when used via plain JavaScript, the transform is not invoked
console.log('')
console.log('Using plain JavaScript:')
console.log('2+4=' + math.addIt(2, 4))
// This will output:
//
//     6


Functions with a transform must be imported in the math namespace, as they
need to be processed at compile time. They are not supported when passed via a
scope at evaluation time.

Custom argument parsing #

The expression parser of math.js has support for letting functions
parse and evaluate arguments themselves, instead of calling them with
evaluated arguments. This is useful for example when creating a function
like plot(f(x), x) or integrate(f(x), x, start, end), where some of the
arguments need to be processed in a special way. In these cases, the expression
f(x) will be evaluated repeatedly by the function, and x is not evaluated
but used to specify the variable looping over the function f(x).

Functions having a property rawArgs with value true are treated in a special
way by the expression parser: they will be invoked with unevaluated arguments,
allowing the function to process the arguments in a customized way. Raw
functions are called as:

rawFunction(args: Node[], math: Object, scope: Map)


Where :


  args is an Array with nodes of the parsed arguments.
  math is the math namespace against which the expression was compiled.
  scope is a Map 
interface containing the variables defined in the scope 
passed via evaluate(scope). The passed scope is always a Map interface,
and normally a PartitionedMap is used to separate local function variables
like x in a custom defined function f(x) = rawFunction(x) ^ 2 from the 
scope variables. Note that a PartitionedMap can recursively link to another
PartitionedMap.


Raw functions must be imported in the math namespace, as they need to be
processed at compile time. They are not supported when passed via a scope
at evaluation time.

A simple example:

function myFunction(args, math, scope) {
  // get string representation of the arguments
  const str = args.map(function (arg) {
    return arg.toString()
  })

  // evaluate the arguments
  const res = args.map(function (arg) {
    return arg.compile().evaluate(scope)
  })

  return 'arguments: ' + str.join(',') + ', evaluated: ' + res.join(',')
}

// mark the function as "rawArgs", so it will be called with unevaluated arguments
myFunction.rawArgs = true

// import the new function in the math namespace
math.import({
  myFunction: myFunction
})

// use the function
math.evaluate('myFunction(2 + 3, sqrt(4))')
// returns 'arguments: 2 + 3, sqrt(4), evaluated: 5, 2'


Custom LaTeX handlers #

You can attach a toTex property to your custom functions before importing them to define their LaTeX output. This
toTex property can be a handler in the format described in the next section ‘Custom LaTeX and String conversion’
or a template string similar to ES6 templates.

Template syntax #


  ${name}: Gets replaced by the name of the function
  ${args}: Gets replaced by a comma separated list of the arguments of the function.
  ${args[0]}: Gets replaced by the first argument of a function
  $$: Gets replaced by $


Example #

const customFunctions = {
  plus: function (a, b) {
    return a + b
  },
  minus: function (a, b) {
    return a - b
  },
  binom: function (n, k) {
    return 1
  }
}

customFunctions.plus.toTex = '${args[0]}+${args[1]}' //template string
customFunctions.binom.toTex = '\\mathrm{${name}}\\left(${args}\\right)' //template string
customFunctions.minus.toTex = function (node, options) { //handler function
  return node.args[0].toTex(options) + node.name + node.args[1].toTex(options)
}

math.import(customFunctions)

math.parse('plus(1,2)').toTex()    // '1+2'
math.parse('binom(1,2)').toTex()   // '\\mathrm{binom}\\left(1,2\\right)'
math.parse('minus(1,2)').toTex()   // '1minus2'


Custom HTML, LaTeX and string output #

All expression nodes have a method toTex and toString to output an expression respectively in HTML or LaTex format or as regular text .
The functions toHTML, toTex and toString accept an options argument to customise output. This object is of the following form:

{
  parenthesis: 'keep',    // parenthesis option
  handler: someHandler,   // handler to change the output
  implicit: 'hide'        // how to treat implicit multiplication
}


Parenthesis #

The parenthesis option changes the way parentheses are used in the output. There are three options available:


  keep Keep the parentheses from the input and display them as is. This is the default.
  auto Only display parentheses that are necessary. Mathjs tries to get rid of as much parentheses as possible.
  all Display all parentheses that are given by the structure of the node tree. This makes the output precedence unambiguous.


There’s two ways of passing callbacks:


  Pass an object that maps function names to callbacks. Those callbacks will be used for FunctionNodes with
functions of that name.
  Pass a function to toTex. This function will then be used for every node.


const expression = math.parse('(1+1+1)')

expression.toString()                      // (1 + 1 + 1)
expression.toString({parenthesis: 'keep'}) // (1 + 1 + 1)
expression.toString({parenthesis: 'auto'}) // 1 + 1 + 1
expression.toString({parenthesis: 'all'})  // (1 + 1) + 1


Handler #

You can provide the toTex and toString functions of an expression with your own custom handlers that override the internal behaviour. This is especially useful to provide LaTeX/string output for your own custom functions. This can be done in two ways:


  Pass an object that maps function names to callbacks. Those callbacks will be used for FunctionNodes that contain functions with that name.
  Pass a callback directly. This callback will run for every node, so you can replace the output of anything you like.


A callback function has the following form:

function callback (node, options) {
  ...
}

Where options is the object passed to toHTML/toTex/toString. Don’t forget to pass this on to the child nodes, and node is a reference to the current node.

If a callback returns nothing, the standard output will be used. If your callback returns a string, this string will be used.

Although the following examples use toTex, it works for toString and toHTML in the same way

Examples for option 1 #

const customFunctions = {
  binomial: function (n, k) {
    //calculate n choose k
    // (do some stuff)
    return result
  }
}

const customLaTeX = {
  'binomial': function (node, options) { //provide toTex for your own custom function
    return '\\binom{' + node.args[0].toTex(options) + '}{' + node.args[1].toTex(options) + '}'
  },
  'factorial': function (node, options) { //override toTex for builtin functions
  	return 'factorial\\left(' + node.args[0] + '\\right)'
  }
}


You can simply use your custom toTex functions by passing them to toTex:

math.import(customFunctions)
const expression = math.parse('binomial(factorial(2),1)')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains "\binom{factorial\\left(2\\right)}{1}"


Examples for option 2: #

function customLaTeX(node, options) {
  if ((node.type === 'OperatorNode') && (node.fn === 'add')) {
    //don't forget to pass the options to the toTex functions
    return node.args[0].toTex(options) + ' plus ' + node.args[1].toTex(options)
  }
  else if (node.type === 'ConstantNode') {
    if (node.value === 0) {
        return '\\mbox{zero}'
    }
    else if (node.value === 1) {
        return '\\mbox{one}'
    }
    else if (node.value === 2) {
        return '\\mbox{two}'
    }
    else {
        return node.value
    }
  }
}

const expression = math.parse('1+2')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains '\mbox{one} plus \mbox{two}'


Another example in conjunction with custom functions:

const customFunctions = {
  binomial: function (n, k) {
    //calculate n choose k
    // (do some stuff)
    return result
  }
}

function customLaTeX(node, options) {
  if ((node.type === 'FunctionNode') && (node.name === 'binomial')) {
      return '\\binom{' + node.args[0].toTex(options) + '}{' + node.args[1].toTex(options) + '}'
  }
}

math.import(customFunctions)
const expression = math.parse('binomial(2,1)')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains "\binom{2}{1}"


Implicit multiplication #

You can change the way that implicit multiplication is converted to a string or LaTeX. The two options are hide, to not show a multiplication operator for implicit multiplication and show to show it.

Example:

const node = math.parse('2a')

node.toString()                   // '2 a'
node.toString({implicit: 'hide'}) // '2 a'
node.toString({implicit: 'show'}) // '2 * a'

node.toTex()                      // '2~ a'
node.toTex({implicit: 'hide'})    // '2~ a'
node.toTex({implicit: 'show'})    // '2\\cdot a'


Customize supported characters #

It is possible to customize the characters allowed in symbols and digits.
The parse function exposes the following test functions:


  math.parse.isAlpha(c, cPrev, cNext)
  math.parse.isWhitespace(c, nestingLevel)
  math.parse.isDecimalMark(c, cNext)
  math.parse.isDigitDot(c)
  math.parse.isDigit(c)


The exact signature and implementation of these functions can be looked up in
the source code of the parser. The allowed alpha characters are described here: Constants and variables.

For example, the phone character ☎ is not supported by default. It can be enabled
by replacing the isAlpha function:

const isAlphaOriginal = math.parse.isAlpha
math.parse.isAlpha = function (c, cPrev, cNext) {
  return isAlphaOriginal(c, cPrev, cNext) || (c === '\u260E')
}

// now we can use the \u260E (phone) character in expressions
const result = math.evaluate('\u260Efoo', {'\u260Efoo': 42}) // returns 42
console.log(result)\n\n\n\nSecurity #

Executing arbitrary expressions like enabled by the expression parser of
mathjs involves a risk in general. When you’re using mathjs to let users
execute arbitrary expressions, it’s good to take a moment to think about
possible security and stability implications, especially when running
the code server side.

Security risks #

A user could try to inject malicious JavaScript code via the expression
parser. The expression parser of mathjs offers a sandboxed environment
to execute expressions which should make this impossible. It’s possible
though that there are unknown security vulnerabilities, so it’s important
to be careful, especially when allowing server side execution of
arbitrary expressions.

The expression parser of mathjs parses the input in a controlled
way into an expression tree or abstract syntax tree (AST).
In a “compile” step, it does as much as possible preprocessing on the
static parts of the expression, and creates a fast performing function
which can be used to evaluate the expression repeatedly using a
dynamically passed scope.

The parser actively prevents access to JavaScripts internal eval and
new Function which are the main cause of security attacks. Mathjs
versions 4 and newer does not use JavaScript’s eval under the hood.
Version 3 and older did use eval for the compile step. This is not
directly a security issue but results in a larger possible attack surface.

When running a node.js server, it’s good to be aware of the different
types of security risks. The risk when running inside a browser may be
limited, though it’s good to be aware of Cross side scripting (XSS) vulnerabilities. A nice overview of
the security risks of node.js servers is listed in the article Node.js security checklist by Gergely Nemeth.

Less vulnerable expression parser #

There is a small number of functions which yield the biggest security
risk in the expression parser:


  import and createUnit which alter the built-in functionality and
allow overriding existing functions and units, and reviver which parses 
values into class instances.
  evaluate, parse, simplify, derivative, and resolve which parse 
arbitrary input into a manipulable expression tree.


To make the expression parser less vulnerable whilst still supporting
most functionality, these functions can be disabled:

import { create, all } from 'mathjs'

const math = create(all)
const limitedEvaluate = math.evaluate

math.import({
  // most important (hardly any functional impact)
  'import':     function () { throw new Error('Function import is disabled') },
  'createUnit': function () { throw new Error('Function createUnit is disabled') },
  'reviver':    function () { throw new Error('Function reviver is disabled') },

  // extra (has functional impact)
  'evaluate':   function () { throw new Error('Function evaluate is disabled') },
  'parse':      function () { throw new Error('Function parse is disabled') },
  'simplify':   function () { throw new Error('Function simplify is disabled') },
  'derivative': function () { throw new Error('Function derivative is disabled') },
  'resolve':    function () { throw new Error('Function resolve is disabled') },
}, { override: true })

console.log(limitedEvaluate('sqrt(16)'))     // Ok, 4
console.log(limitedEvaluate('parse("2+3")')) // Error: Function parse is disabled


Found a security vulnerability? Please report in private! #

You found a security vulnerability? Awesome! We hope you don’t have bad
intentions and want to help fix the issue. Please report the
vulnerability in a private way by contacting one of the maintainers
via mail or another private channel. That way we can work together
on a fix before sharing the issue with everybody including the bad guys.

Stability risks #

A user could accidentally or on purpose execute a
heavy expression like creating a huge matrix. That can let the
JavaScript engine run out of memory or freeze it when the CPU goes
to 100% for a long time.

To protect against this sort of issue, one can run the expression parser
in a separate Web Worker or child_process, so it can’t affect the
main process. The workers can be killed when it runs for too
long or consumes too much memory. A useful library in this regard
is workerpool, which makes
it easy to manage a pool of workers in both browser and node.js.\n\n\n\nData Types #

The functions of math.js support multiple data types, both native JavaScript
types as well as more advanced types implemented in math.js. The data types can
be mixed together in calculations, for example by adding a Number to a
Complex number or Array.

The supported data types are:


  Boolean
  Number
  BigNumber
  Complex
  Fraction
  Array
  Matrix
  Unit
  String


Function math.typeOf(x) can be used to get
the type of a variable.

Example usage:

// use numbers
math.subtract(7.1, 2.3)          // 4.8
math.round(math.pi, 3)           // 3.142
math.sqrt(4.41e2)                // 21

// use BigNumbers
math.add(math.bignumber(0.1), math.bignumber(0.2)) // BigNumber, 0.3

// use bigint
math.add(300000000000000000n, 1n) // 300000000000000001n

// use Fractions
math.add(math.fraction(1), math.fraction(3)) // Fraction, 0.(3)

// use strings
math.add('hello ', 'world')      // 'hello world'
math.max('A', 'D', 'C')          // 'D'

// use complex numbers
const a = math.complex(2, 3)     // 2 + 3i
a.re                             // 2
a.im                             // 3
const b = math.complex('4 - 2i') // 4 - 2i
math.add(a, b)                   // 6 + i
math.sqrt(-4)                    // 2i

// use arrays
const array = [1, 2, 3, 4, 5]
math.factorial(array)            // Array,  [1, 2, 6, 24, 120]
math.add(array, 3)               // Array,  [3, 5, 6, 7, 8]

// use matrices
const matrix = math.matrix([1, 4, 9, 16, 25]) // Matrix, [1, 4, 9, 16, 25]
math.sqrt(matrix)                             // Matrix, [1, 2, 3, 4, 5]

// use units
const a = math.unit(55, 'cm')    // 550 mm
const b = math.unit('0.1m')      // 100 mm
math.add(a, b)                   // 0.65 m

// check the type of a variable
math.typeOf(2)                   // 'number'
math.typeOf(math.unit('2 inch')) // 'Unit'
math.typeOf(math.sqrt(-4))       // 'Complex'\n\n\n\nNumbers #

Math.js supports three types of numbers:


  Number for fast floating point arithmetic, described on this page.
  BigNumber for arbitrary precision arithmetic, described on the page
BigNumbers.
  Fraction, which stores numbers in terms of a numerator and denominators, 
described on the page Fractions.


Configuration #

Most functions can determine the type of output from the type of input:
a number as input will return a number as output, a BigNumber as input returns
a BigNumber as output. Functions which cannot determine the type of output
from the input (for example math.evaluate) use the default number type, which
can be configured when instantiating math.js:

math.config({
  number: 'number' // Default type of number: 
                   // 'number' (default), 'BigNumber', or 'Fraction'
})


Round-off errors #

Math.js uses the built-in JavaScript Number type. A Number is a floating point
number with a limited precision of 64 bits, about 16 digits. The largest integer
number which can be represented by a JavaScript Number
is +/- 9007199254740992 (+/- 2^53). Because of the limited precision of
floating point numbers round-off errors can occur during calculations.
This can be easily demonstrated:

// a round-off error
0.1 + 0.2            // 0.30000000000000004
math.add(0.1, 0.2)   // 0.30000000000000004


In most cases, round-off errors don’t matter: they have no significant
impact on the results. However, it looks ugly when displaying output to a user.
A solution is to limit the precision just below the actual precision of 16
digits in the displayed output:

// prevent round-off errors showing up in output
const ans = math.add(0.1, 0.2)     //  0.30000000000000004
math.format(ans, {precision: 14})  // '0.3'


Alternatives are to use Fractions which store a number as a numerator and denominator, BigNumbers which store a number with a higher precision, or bigint which can store larger integer numbers.

Minimum and maximum #

A Number can store values between 5e-324 and 1.7976931348623157e+308.
Values smaller than the minimum are stored as 0, and values larger than the
maximum are stored as +/- Infinity.

// exceeding the maximum and minimum number
console.log(1e309)   // Infinity
console.log(1e-324)  // 0


Equality #

Because of rounding errors in calculations, it is unsafe to compare JavaScript
Numbers. For example executing 0.1 + 0.2 == 0.3 in JavaScript will return
false, as the addition 0.1 + 0.2 introduces a round-off error and does not
return exactly 0.3.

To solve this problem, the relational functions of math.js check whether the
relative and absolute differences between the compared values is smaller than the configured
option relTol and absTol. In pseudo code (without exceptions for 0, Infinity and NaN):

abs(a-b) <= max(relTol * max(abs(a), abs(b)), absTol)


where:


  relTol is the relative tolerance between x and y and absTol the absolute tolerance. Relative tolerance and absolute tolerance are configurable and are 1e-12 and 1e-15 respectively by default. See Configuration.
  DBL_EPSILON is the minimum positive floating point number such that
1.0 + DBL_EPSILON !== 1.0. This is a constant with a value of approximately
2.2204460492503130808472633361816e-16.


Note that the relational functions cannot be used to compare small values
(< 2.22e-16). These values are all considered equal to zero.

Examples:

// compare values having a round-off error
console.log(0.1 + 0.2 === 0.3)           // false
console.log(math.equal(0.1 + 0.2, 0.3))  // true

// small values (< 2.22e-16) cannot be compared
console.log(3e-20 === 3.1e-20)           // false
console.log(math.equal(3e-20, 3.1e-20))  // true


The available relational functions are: compare, equal, larger,
largerEq, smaller, smallerEq, unequal.\n\n\n\nBigNumbers #

For calculations with an arbitrary precision, math.js supports a BigNumber
datatype. BigNumber support is powered by
decimal.js.

Usage #

A BigNumber can be created using the function bignumber:

math.bignumber('2.3e+500') // BigNumber, 2.3e+500


Most functions can determine the type of output from the type of input:
a number as input will return a number as output, a BigNumber as input returns
a BigNumber as output. Functions which cannot determine the type of output
from the input (for example math.evaluate) use the default number type number,
which can be configured when instantiating math.js. To configure the use of
BigNumbers instead of numbers by default, configure math.js like:

math.config({
  number: 'BigNumber',      // Default type of number:
                            // 'number' (default), 'BigNumber', or 'Fraction'
  precision: 64,            // Number of significant digits for BigNumbers
  relTol: 1e-60,
  absTol: 1e-63
})

// use math
math.evaluate('0.1 + 0.2')  // BigNumber, 0.3


The default precision for BigNumber is 64 digits, and can be configured with
the option precision.

Note that we also change the configuration of relTol and absTol 
to be close to the precision limit of our BigNumbers. relTol and absTol are used for 
example in relational and rounding functions (equal, larger, smaller, 
round, floor, etc) to determine when a value is nearly equal, 
see Equality. If we would leave relTol and absTol  unchanged, 
having the default value of 1e-12 and 1e-15 respectively, we could get inaccurate and misleading 
results since we’re now working with a higher precision.

Support #

Most functions in math.js support BigNumbers, but not all of them.
For example the function random doesn’t support BigNumbers.

Round-off errors #

Calculations with BigNumber are much slower than calculations with Number,
but they can be executed with an arbitrary precision. By using a higher
precision, it is less likely that round-off errors occur:

// round-off errors with numbers
math.add(0.1, 0.2)                                     // Number, 0.30000000000000004
math.divide(0.3, 0.2)                                  // Number, 1.4999999999999998

// no round-off errors with BigNumbers :)
math.add(math.bignumber(0.1), math.bignumber(0.2))     // BigNumber, 0.3
math.divide(math.bignumber(0.3), math.bignumber(0.2))  // BigNumber, 1.5


Limitations #

It’s important to realize that BigNumbers do not solve all problems related
to precision and round-off errors. Numbers with an infinite number of digits
cannot be represented with a regular number nor a BigNumber. Though a BigNumber
can store a much larger number of digits, the amount of digits remains limited
if only to keep calculations fast enough to remain practical.

const one = math.bignumber(1)
const three = math.bignumber(3)
const third = math.divide(one, three)
console.log(third.toString())
// outputs 0.3333333333333333333333333333333333333333333333333333333333333333

const ans = math.multiply(third, three)
console.log(ans.toString())
// outputs 0.9999999999999999999999999999999999999999999999999999999999999999
// this should be 1 again, but `third` is rounded to a limited number of digits 3


Conversion #

BigNumbers can be converted to numbers and vice versa using the functions
number and bignumber. When converting a BigNumber to a number, the high
precision of the BigNumber will be lost. When a BigNumber is too large to be represented
as Number, it will be initialized as Infinity.

// converting numbers and BigNumbers
const a = math.number(0.3)                         // number, 0.3
const b = math.bignumber(a)                        // BigNumber, 0.3
const c = math.number(b)                           // number, 0.3

// exceeding the maximum of a number
const d = math.bignumber('1.2e500')                // BigNumber, 1.2e+500
const e = math.number(d)                           // number, Infinity

// loosing precision when converting to number
const f = math.bignumber('0.2222222222222222222')  // BigNumber, 0.2222222222222222222
const g = math.number(f)                           // number,    0.2222222222222222\n\n\n\nBigInts #

For calculations with large integer numbers, math.js supports the built-in bigint data type.

Usage #

A bigint can be created either by adding the suffix n to a number, using the BigInt constructor function, or using the util function math.bigint:

42n
BigInt('42')
math.bigint('42')


Most functions can determine the type of output from the type of input:
a number as input will return a number as output, a bigint as input returns
a bigint as output. Functions which cannot determine the type of output
from the input (for example math.evaluate) use the default number type number,
which can be configured when instantiating math.js. To configure the use of
bigint instead of numbers by default, configure math.js like:

math.config({
  number: 'bigint'
})

// use math
math.evaluate('70000000000000000123')  // bigint 70000000000000000123n


Support #

All basic arithmetic functions in math.js support bigint. Since bigint can only hold integer values, it is not applicable to for example trigonometric functions. When using a bigint in a function that does not support it, like sqrt, it will convert the bigint into a regular number and then execute the function:

math.sin(2n) // number 0.9092974268256817


Conversion #

There are utility functions to convert a bigint into a number or BigNumber:

// convert a number to bigint or BigNumber
math.bigint(42)                    // bigint, 42n
math.bignumber(42)                 // BigNumber, 42

// convert a bigint to a number or BigNumber
math.number(42n)                   // number, 42
math.bignumber(42n)                // BigNumber, 42

// losing digits when converting to number
math.number(70000000000000000123n) // number, 7000000000000000000\n\n\n\nFractions #

For calculations with fractions, math.js supports a Fraction data type. 
Fraction support is powered by fraction.js.
Unlike numbers and BigNumbers, fractions can 
store numbers with infinitely repeating decimals, for example 1/3 = 0.3333333..., 
which can be represented as 0.(3), or 2/7 which can be represented as 0.(285714).

Usage #

A Fraction can be created using the function fraction:

math.fraction('1/3')   // Fraction, 1/3
math.fraction(2, 3)    // Fraction, 2/3
math.fraction('0.(3)') // Fraction, 1/3


And can be used in functions like add and multiply like:

math.add(math.fraction('1/3'), math.fraction('1/6'))      // Fraction, 1/2
math.multiply(math.fraction('1/4'), math.fraction('1/2')) // Fraction, 1/8


Note that not all functions support fractions. For example trigonometric 
functions doesn’t support fractions. When not supported, the functions
will convert the input to numbers and return a number as result.

Most functions will determine the type of output from the type of input:
a number as input will return a number as output, a Fraction as input returns
a Fraction as output. Functions which cannot determine the type of output
from the input (for example math.evaluate) use the default number type number,
which can be configured when instantiating math.js. To configure the use of
fractions instead of numbers by default, configure math.js like:

// Configure the default type of number: 'number' (default), 'BigNumber', or 'Fraction'
math.config({
  number: 'Fraction'
})

// use the expression parser
math.evaluate('0.32 + 0.08') // Fraction, 2/5


Support #

The following functions support fractions:


  Arithmetic functions: abs, add, ceil, cube, divide, dotDivide, dotMultiply, fix, floor, gcd, mod, multiply, round, sign, square, subtract, unaryMinus, unaryPlus.
  Construction functions: fraction.
  Relational functions: compare, deepEqual, equal, larger, largerEq, smaller, smallerEq, unequal.
  Utils functions: format.


Conversion #

Fractions can be converted to numbers and vice versa using the functions
number and fraction. When converting a Fraction to a number, precision
may be lost when the value cannot represented in 16 digits.

// converting numbers and fractions
const a = math.number(0.3)                       // number, 0.3
const b = math.fraction(a)                       // Fraction, 3/10
const c = math.number(b)                         // number, 0.3

// loosing precision when converting to number: a fraction can represent
// a number with an infinite number of repeating decimals, a number just
// stores about 16 digits and cuts consecutive digits.
const d = math.fraction('2/5')                   // Fraction, 2/5
const e = math.number(d)                         // number, 0.4\n\n\n\nComplex Numbers #

Math.js supports the creation, manipulation, and calculations with complex numbers.
Support of complex numbers is powered by the library complex.js.

In mathematics, a complex number is an expression of the form a + bi,
where a and b are real numbers and i represents the imaginary number
defined as i^2 = -1. (In other words, i is the square root of -1.)
The real number a is called the real part of the complex number,
and the real number b is the imaginary part. For example, 3 + 2i is a
complex number, having real part 3 and imaginary part 2.
Complex numbers are often used in applied mathematics, control theory,
signal analysis, fluid dynamics and other fields.

Usage #

A complex number is created using the function math.complex. This function
accepts:


  two numbers representing the real and imaginary part of the value,
  a single string containing a complex value in the form a + bi where a
and b respectively represent the real and imaginary part of the complex number.
  an object with either properties re and im for the real and imaginary
part of the value, or two properties r and phi containing the polar
coordinates of a complex value.
The function returns a Complex object.


Syntax:

math.complex(re: number) : Complex
math.complex(re: number, im: number) : Complex
math.complex(complex: Complex) : Complex
math.complex({re: Number, im: Number}) : Complex
math.complex({r: number, phi: number}) : Complex
math.complex({abs: number, arg: number}) : Complex
math.complex(str: string) : Complex


Examples:

const a = math.complex(2, 3)     // Complex 2 + 3i
a.re                             // Number 2
a.im                             // Number 3

const b = math.complex('4 - 2i') // Complex 4 - 2i
b.re = 5                         // Number 5
b                                // Complex 5 - 2i


Calculations #

Most functions of math.js support complex numbers. Complex and real numbers
can be used together.

const a = math.complex(2, 3)     // Complex 2 + 3i
const b = math.complex('4 - 2i') // Complex 4 - 2i

math.re(a)                       // Number 2
math.im(a)                       // Number 3
math.conj(a)                     // Complex 2 - 3i

math.add(a, b)                   // Complex 6 + i
math.multiply(a, 2)              // Complex 4 + 6i
math.sqrt(-4)                    // Complex 2i


API #
A Complex object created by math.complex contains the following properties and functions:

complex.re #

A number containing the real part of the complex number. Can be read and replaced.

complex.im #

A number containing the imaginary part of the complex number. Can be read and replaced.

complex.clone() #

Create a clone of the complex number.

complex.equals(other) #

Test whether a complex number equals another complex value.

Two complex numbers are equal when both their real and imaginary parts are
  equal.

complex.neg() #

Returns a complex number with a real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.conjugate() #

Returns a complex number with an equal real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.inverse() #

Returns a complex number that is inverse of the current complex number.

complex.toVector() #

Get the vector representation of the current complex number. Returns an array of size 2.

complex.toJSON() #

Returns a JSON representation of the complex number, with signature
  {mathjs: 'Complex', re: number, im: number}.
  Used when serializing a complex number, see Serialization.

complex.toPolar() #

Get the polar coordinates of the complex number, returns
  an object with properties r and phi.

complex.toString() #

Returns a string representation of the complex number, formatted
  as a + bi where a is the real part and b the imaginary part.

complex.format([precision: number]) #

Get a string representation of the complex number,
  formatted as a + bi where a is the real part and b the imaginary part.
  If precision is defined, the units value will be rounded to the provided
  number of digits.

Static methods #
The following static methods can be accessed using math.Complex

Complex.fromJSON(json) #

Revive a complex number from a JSON object. Accepts
  An object {mathjs: 'Complex', re: number, im: number}, where the property
  mathjs is optional.
  Used when deserializing a complex number, see Serialization.

Complex.fromPolar(r: number, phi: number) #

Create a complex number from polar coordinates.

Complex.compare(a: Complex, b: Complex) #

Returns the comparision result of two complex number:


  Returns 1 when the real part of a is larger than the real part of b
  Returns -1 when the real part of a is smaller than the real part of b
  Returns 1 when the real parts are equal
and the imaginary part of a is larger than the imaginary part of b
  Returns -1 when the real parts are equal
and the imaginary part of a is smaller than the imaginary part of b
  Returns 0 when both real and imaginary parts are equal.


Example:
const a = math.complex(2, 3)   // Complex 2 + 3i
const b = math.complex(2, 1)   // Complex 2 + 1i
math.Complex.compare(a,b) // returns 1

//create from json 
const c = math.Complex.fromJSON({mathjs: 'Complex', re: 4, im: 3})  // Complex 4 + 3i\n\n\n\nMatrices #

Math.js supports multi dimensional matrices and arrays. Matrices can be
created, manipulated, and used in calculations. Both regular JavaScript
arrays as well as the matrix type implemented by math.js can be used
interchangeably in all relevant math.js functions. math.js supports both
dense and sparse matrices.

Arrays and matrices #

Math.js supports two types of matrices:


  Array, a regular JavaScript array. A multi dimensional array can be created
by nesting arrays.
  Matrix, a matrix implementation by math.js. A Matrix is an object wrapped
around a regular JavaScript Array, providing utility functions for easy
matrix manipulation such as subset, size, resize, clone, and more.


In most cases, the type of matrix output from functions is determined by the
function input: An Array as input will return an Array, a Matrix as input
will return a Matrix. In case of mixed input, a Matrix is returned.
For functions where the type of output cannot be determined from the
input, the output is determined by the configuration option matrix,
which can be a string 'Matrix' (default) or 'Array'.

// create an array and a matrix
const array = [[2, 0], [-1, 3]]               // Array
const matrix = math.matrix([[7, 1], [-2, 3]]) // Matrix

// perform a calculation on an array and matrix
math.map(array, math.square)                  // Array,  [[4, 0], [1, 9]]
math.map(matrix, math.square)                 // Matrix, [[49, 1], [4, 9]]

// perform calculations with mixed array and matrix input
math.add(array, matrix)                       // Matrix, [[9, 1], [-3, 6]]
math.multiply(array, matrix)                  // Matrix, [[14, 2], [-13, 8]]

// create a matrix. Type of output of function ones is determined by the
// configuration option `matrix`
math.ones(2, 3)                               // Matrix, [[1, 1, 1], [1, 1, 1]]


Creation #

A matrix can be created from an array using the function math.matrix. The
provided array can contain nested arrays in order to create a multi-dimensional matrix. When called without arguments, an empty matrix will be
created.

// create matrices
math.matrix()                           // Matrix, size [0]
math.matrix([0, 1, 2])                  // Matrix, size [3]
math.matrix([[0, 1], [2, 3], [4, 5]])   // Matrix, size [3, 2]


Math.js supports regular Arrays. Multiple dimensions can be created
by nesting Arrays in each other.

// create arrays
[]                                      // Array, size [0]
[0, 1, 2]                               // Array, size [3]
[[0, 1], [2, 3], [4, 5]]                // Array, size [3, 2]


Matrices can contain different types of values: numbers, complex numbers,
units, or strings. Different types can be mixed together in a single matrix.

// create a matrix with mixed types
const a = math.matrix([2.3, 'hello', math.complex(3, -4), math.unit('5.2 mm')]) 
a.subset(math.index(1))  // 'hello'


There are a number of functions to create a matrix with a specific size and
content: ones, zeros, identity.

// zeros creates a matrix filled with zeros
math.zeros(3)           // Matrix, size [3],    [0, 0, 0]
math.zeros(3, 2)        // Matrix, size [3, 2], [[0, 0], [0, 0], [0, 0]]
math.zeros(2, 2, 2)     // Matrix, size [2, 2, 2],
                        //   [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]

// ones creates a matrix filled with ones
math.ones(3)                        // Matrix, size [3],    [1, 1, 1]
math.multiply(math.ones(2, 2), 5)   // Matrix, size [2, 2], [[5, 5], [5, 5]]

// identity creates an identity matrix
math.identity(3)      // Matrix, size [3, 3], [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
math.identity(2, 3)   // Matrix, size [2, 3], [[1, 0, 0], [0, 1, 0]]


The functions ones, zeros, and identity also accept a single array
or matrix containing the dimensions for the matrix. When the input is an Array,
the functions will output an Array. When the input is a Matrix, the output will
be a Matrix. Note that in case of numbers as arguments, the output is
determined by the option matrix as discussed in section
Arrays and matrices.

// Array as input gives Array as output
math.ones([2, 3])               // Array,  size [3, 2], [[1, 1, 1], [1, 1, 1]]
math.ones(math.matrix([2, 3]))  // Matrix, size [3, 2], [[1, 1, 1], [1, 1, 1]]


Ranges can be created using the function range. The function range is
called with parameters start and end, and optionally a parameter step.
The start of the range is included, the end of the range is excluded.

math.range(0, 4)        // [0, 1, 2, 3]
math.range(0, 8, 2)     // [0, 2, 4, 6]
math.range(3, -1, -1)   // [3, 2, 1, 0]


Calculations #

Most functions of math.js support matrices and arrays. Unary functions can be applied element-wise using via math.map(matrix, function).

// perform an element-wise operation on a matrix using math.map
const a = math.matrix([1, 4, 9, 16, 25])  // Matrix, [1, 4, 9, 16, 25]
math.map(a, math.sqrt)                    // Matrix, [1, 2, 3, 4, 5]

// use a function that has built-in matrix and array support
const b = [1, 2, 3, 4, 5] 
math.factorial(b)                         // Array,  [1, 2, 6, 24, 120]

// multiply an array with a matrix
const c = [[2, 0], [-1, 3]]               // Array
const d = math.matrix([[7, 1], [-2, 3]])  // Matrix
math.multiply(c, d)                       // Matrix, [[14, 2], [-13, 8]]

// add a number to a matrix (see broadcasting)
math.add(c, 2)                            // Array, [[4, 2], [1, 5]]

// calculate the determinant of a matrix
math.det(c)                               // 6
math.det(d)                               // 23

Broadcasting #

Functions that require two or more matrix like arguments that operate elementwise automatically operate as if the arguments were the same size.

A = math.matrix([1, 2])       // Matrix, [1, 2]
math.add(A, 3)                // Matrix, [3, 4]

B = math.matrix([[3], [4]])   // Matrix, [[3], [4]]
math.add(A, B)                // Matrix, [[4, 5], [5, 6]]

Any index that is in one of the arguments, can be found as if it existed on the others when the size on that dimension is one or not existing. This is valid in N dimensions.

It’s not possible to broadcast in cases where the size in that dimension is higher than one.

math.add([1, 2], [3, 4, 5])
// Error: shape missmatch: missmatch is found in arg with shape (2) not possible to broadcast dimension 0 with size 2 to size 3

math.add([[1], [2], [3]], [[4], [5]])
// Error: shape missmatch: missmatch is found in arg with shape (2,1) not possible to broadcast dimension 0 with size 2 to size 3


Size and Dimensions #

Math.js uses geometric dimensions:


  A scalar is zero-dimensional.
  A vector is one-dimensional.
  A matrix is two or multi-dimensional.


The size of a matrix can be calculated with the function size. Function size
returns a Matrix or Array, depending on the configuration option matrix.
Furthermore, matrices have a function size as well, which always returns
an Array.

// get the size of a scalar
math.size(2.4)                                // Matrix, []
math.size(math.complex(3, 2))                 // Matrix, []
math.size(math.unit('5.3 mm'))                // Matrix, []

// get the size of a one-dimensional matrix (a vector) and a string
math.size([0, 1, 2, 3])                       // Array, [4]
math.size('hello world')                      // Matrix, [11]

// get the size of a two-dimensional matrix
const a = [[0, 1, 2, 3]]                      // Array
const b = math.matrix([[0, 1, 2], [3, 4, 5]]) // Matrix
math.size(a)                                  // Array, [1, 4]
math.size(b)                                  // Matrix, [2, 3]

// matrices have a function size (always returns an Array)
b.size()                                      // Array, [2, 3]

// get the size of a multi-dimensional matrix
const c = [[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]
math.size(c)                                  // Array, [2, 2, 3]


Note that the dimensions themselves do not have a meaning attached. 
When creating and printing a two dimensional matrix, the first dimension is 
normally rendered as the column, and the second dimension is rendered as 
the row. For example:

console.table(math.zeros([2, 4]))
// 0 0 0 0
// 0 0 0 0


If you have a matrix where the first dimension means x and the second 
means y, this will look confusing since x is printed as column 
(vertically) and y as row (horizontally).

Resizing #

Matrices can be resized using their resize function. This function is called
with an Array with the new size as the first argument, and accepts an optional
default value. By default, new entries will be set to 0, but it is possible
to pass a different default value like null to clearly indicate that
the entries haven’t been explicitly set.

const a = math.matrix() // Matrix, size [0],       []
a.resize([2, 3])        // Matrix, size [2, 3],    [[0, 0, 0], [0, 0, 0]]
a.resize([2, 2, 2])     // Matrix, size [2, 2, 2],
                        //   [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]

const b = math.matrix()
b.resize([3], 7)        // Matrix, size [3],    [7, 7, 7]
b.resize([5], 9)        // Matrix, size [5],    [7, 7, 7, 9, 9]
b.resize([2])           // Matrix, size [2],    [7, 7]


Outer dimensions of a matrix can be squeezed using the function squeeze. When
getting or setting a single value in a matrix using subset, the value is automatically squeezed
or unsqueezed too.

// squeeze a matrix
const a = [[[0, 1, 2]]]
math.squeeze(a)             // [0, 1, 2]
math.squeeze([[3]])         // 3

// when getting/setting a single value in a matrix using subset, 
// it automatically squeeze/unsqueeze the value
const b = math.matrix([[0, 1], [2, 3]])
b.subset(math.index(1, 0))  // 2 and not [[2]]


Getting or replacing subsets #

Subsets of a matrix can be retrieved or replaced using the function subset.
Matrices have a subset function, which is applied to the matrix itself:
Matrix.subset(index [, replacement]). For both matrices and arrays,
the static function subset(matrix, index [, replacement]) can be used.
When parameter replacement is provided, the function will replace a subset
in the matrix, and if not, a subset of the matrix will be returned.

A subset can be defined using an Index. An Index contains a single value
or a set of values for each dimension of a matrix. An Index can be
created using the function index. When getting a single value from a matrix,
subset will return the value itself instead of a matrix containing just this 
value.

The function subset normally returns a subset, but when getting or setting a
single value in a matrix, the value itself is returned.

Matrix indexes in math.js are zero-based, like most programming languages
including JavaScript itself. Note that mathematical applications like Matlab 
and Octave work differently, as they use one-based indexes.

// create some matrices
const a = [0, 1, 2, 3]
const b = [[0, 1], [2, 3]]
const c = math.zeros(2, 2)
const d = math.matrix([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
const e = math.matrix()

// get a subset
math.subset(a, math.index(1))                 // 1
math.subset(a, math.index([2, 3]))            // Array, [2, 3]
math.subset(a, math.index(math.range(0,4)))   // Array, [0, 1, 2, 3]
math.subset(b, math.index(1, 0))              // 2
math.subset(b, math.index(1, [0, 1]))         // Array, [2, 3]
math.subset(b, math.index([0, 1], 0))         // Matrix, [[0], [2]]

// get a subset
d.subset(math.index([1, 2], [0, 1]))          // Matrix, [[3, 4], [6, 7]]
d.subset(math.index(1, 2))                    // 5

// replace a subset. The subset will be applied to a clone of the matrix
math.subset(b, math.index(1, 0), 9)           // Array, [[0, 1], [9, 3]]
math.subset(b, math.index(2, [0, 1]), [4, 5]) // Array, [[0, 1], [2, 3], [4, 5]]

// replace a subset. The subset will be applied to the matrix itself
c.subset(math.index(0, 1),1)                  // Matrix, [[0, 1], [0, 0]]
c.subset(math.index(1, [0, 1]), [2, 3])       // Matrix, [[0, 1], [2, 3]]
e.resize([2, 3], 0)                           // Matrix, [[0, 0, 0], [0, 0, 0]]
e.subset(math.index(1, 2), 5)                 // Matrix, [[0, 0, 0], [0, 0, 5]]


Getting and setting a value in a matrix #

There are two methods available on matrices that allow to get or set a single 
value inside a matrix. It is important to note that the set method will 
mutate the matrix.

const p = math.matrix([[1, 2], [3, 4]])
p.set([0, 1], 5)
// p is now [[1, 5], [3, 4]]
p.get([1, 0]) // 3


When setting a value at a location outside of the current matrix size using the
method .set(), the matrix will be resized. By default, new items will be 
initialized with zero, but it is possible to specify an alternative value using
the optional third argument defaultValue.

Advanced Indexing #

Boolean array indexing is a technique that allows you to filter, replace, and set values in an array based on logical conditions. This can be done by creating a boolean array that represents the desired conditions, and then using that array as an index to select the elements of the original array that meet those conditions.

For example, a boolean array can be created to represent all the even numbers in an array, and then used to filter the original array to only include the even numbers. Alternatively, a boolean array can be created to represent all the elements of an array that are greater than a certain value, and then used to replace all the elements of the original array that are greater than that value with a new value.

const q = [1, 2, 3, 4]
math.subset(q, math.index([true, false, true, false]))      // Array [1, 3]

// filtering
math.subset(q, math.index(math.larger(q, 2)))               // Array [3, 4]

// filtering with no matches
math.subset(q, math.index(math.larger(q, 5)))               // Array []

// setting specific values, please note that the replacement value is broadcasted
q = math.subset(q, math.index(math.smaller(q, 3)), 0)       // q = [0, 0, 3, 4]

// replacing specific values
math.subset(q, math.index(math.equal(q, 0)), [1, 2])        // q = [1, 2, 3, 4]


The same can be accomplished in the parser in a much more compact manner. Please note that everything after # are comments.
math.evaluate(`
q = [1, 2, 3, 4]
q[[true, false, true, false]] # Matrix [1, 3]
q[q>2]                        # Matrix [3, 4]
q[q>5]                        # Matrix []
q[q <3] = 0                   # q = [0, 0, 3, 4]
q[q==0] = [1, 2]              # q = [1, 2, 3, 4]
`)

The expression inside the index can be as complex as needed as long it evaluates to an array of booleans of the same size.
math.evaluate(`
q = [1, 2, 3, 4]
r = [6, 5, 4, 3]
q[q > 3 and r < 4]     # [4]
`)


Iterating #

Matrices contain functions map and forEach to iterate over all elements of
the (multidimensional) matrix. The callback function of map and forEach has
three parameters: value (the value of the currently iterated element),
index (an array with the index value for each dimension), and matrix (the
matrix being iterated). This syntax is similar to the map and forEach
functions of native JavaScript Arrays, except that the index is no number but
an Array with numbers for each dimension.

const a = math.matrix([[0, 1], [2, 3], [4, 5]])

// The iteration below will output the following in the console:
//    value: 0 index: [0, 0]
//    value: 1 index: [0, 1]
//    value: 2 index: [1, 0]
//    value: 3 index: [1, 1]
//    value: 4 index: [2, 0]
//    value: 5 index: [2, 1]
a.forEach(function (value, index, matrix) {
  console.log('value:', value, 'index:', index) 
}) 

// Apply a transformation on the matrix
const b = a.map(function (value, index, matrix) {
  return math.multiply(math.sin(value), math.exp(math.abs(value))) 
}) 
console.log(b.format(5))  // [[0, 2.2874], [6.7188, 2.8345], [-41.32, -142.32]]

// Create a matrix with the cumulative of all elements
let count = 0
const cum = a.map(function (value, index, matrix) {
  count += value 
  return count 
}) 
console.log(cum.toString())  // [[0, 1], [3, 6], [10, 15]]


Iterating over multiple Matrixes or Arrays #

You can iterate over multiple matrices or arrays by using the map function. Mapping allows to perform element-wise operations on matrices by automatically adjusting their sizes to match each other.

To iterate over multiple matrices, you can use the map function. The map function applies a given function to each element of the matrices and returns a new matrix with the results.

Here’s an example of iterating over two matrices and adding their corresponding elements:

const a = math.matrix([[1, 2], [3, 4]]);
const b = math.matrix([[5, 6], [7, 8]]);

const result = math.map(a, b, (x, y) => x + y);

console.log(result); // [[6, 8], [10, 12]]


In this example, the map function takes matrices as the first two arguments and a callback function (x, y) => x + y as the third argument. The callback function is applied to each element of the matrices, where x represents the corresponding element from matrix a and y represents the corresponding element from matrix b. The result is a new matrix with the element-wise sum of the two matrices.

By using broadcasting and the map function, you can easily iterate over multiple matrices and perform element-wise operations.

const a = math.matrix([10, 20])
const b = math.matrix([[3, 4], [5, 6]])

const result = math.map(a, b, (x, y) => x + y)
console.log(result); // [[13, 24], [15, 26]]


It’s also possible to provide a callback with an index and the broadcasted arrays. Like (valueA, valueB, index) or even (valueA, valueB, index, broadcastedMatrixA, broadcastedMatrixB). There is no specific limit for the number of matrices N that can be mapped. Thus, the callback can have N arguments, N+1 arguments in the case of including the index, or 2N+1 arguments in the case of including the index and the broadcasted matrices in the callback.

At this moment forEach doesn’t include the same functionality.

Storage types #

Math.js supports both dense matrices as well as sparse matrices. Sparse matrices are efficient for matrices largely containing zeros. In that case they save a lot of memory, and calculations can be much faster than for dense matrices.

Math.js supports two type of matrices:


  Dense matrix ('dense', default) A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.
  Sparse matrix ('sparse'): A two dimensional sparse matrix implementation.


The type of matrix can be selected when creating a matrix using the construction functions matrix, diag, identity, ones, and zeros.

// create sparse matrices
const m1 = math.matrix([[0, 1], [0, 0]], 'sparse')
const m2 = math.identity(1000, 1000, 'sparse')


You can also coerce an array or matrix into sparse storage format with the
sparse function.
const md = math.matrix([[0, 1], [0,0]])  // dense
const ms = math.sparse(md)               // sparse


Caution: sparse called on a JavaScript array of n plain numbers produces
a matrix with one column and n rows – in contrast to matrix, which
produces a 1-dimensional matrix object with n entries, i.e., a vector
(not a 1 by n “row vector” nor an n by 1 “column vector”, but just a plain
vector of length n).
const mv = math.matrix([0, 0, 1])  // Has size [3]
const mc = math.sparse([0, 0, 1])  // A "column vector," has size [3, 1]


API #

All relevant functions in math.js support Matrices and Arrays. Functions like math.add and math.subtract, math.sqrt handle matrices element wise. There is a set of functions specifically for creating or manipulating matrices, such as:


  Functions like math.matrix and math.sparse, math.ones, math.zeros, and math.identity to create a matrix.
  Functions like math.subset and math.index to get or replace a part of a matrix
  Functions like math.transpose and math.diag to manipulate matrices.


A full list of matrix functions is available on the functions reference page.

Two types of matrix classes are available in math.js, for storage of dense and sparse matrices. Although they contain public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  DenseMatrix
  SparseMatrix\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nReference #


  Classes
  Constants
  Functions\n\n\n\nClass Reference #

This page lists all the various class types in Math.js. Every top-level function is listed here and links to its detailed reference to other parts of the documentation.

math #

The “math” namespace contains the entire math.js functionality. All of the mathematical functions are available in the “math” namespace, and allow for inputs of various types.


  Function reference
  Constant reference


Unit #

Stores values for a scalar unit and its postfix. (eg 100 mm or 100 kg). Although the Unit class contains public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  Overview
  Class API


Fraction #

Stores values for a fractional number.


  Overview
  Class API


BigNumber #

Stores values for a arbitrary-precision floating point number.


  Overview
  Class API


Matrix #

Two types of matrix classes are available in math.js, for storage of dense and sparse matrices. Although they contain public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  Overview
  DenseMatrix
  SparseMatrix


Classes used internally that may be of use to developers:


  Index
  Range
  ResultSet
  FibonacciHeap


Complex #

Stores values for a complex number.


  Overview
  Class API


Parser #

The Parser object returned by math.parser().


  Overview


Node #

A node in an expression-tree, which can be used to analyze, manipulate, and evaluate expressions.


  Overview


Node is the base class of all other node classes:


  AccessorNode
  ArrayNode
  AssignmentNode
  BlockNode
  ConditionalNode
  ConstantNode
  FunctionAssignmentNode
  FunctionNode
  IndexNode
  ObjectNode
  OperatorNode
  ParenthesisNode
  RangeNode
  SymbolNode\n\n\n\nFunction reference #

Expression functions #


  
    
      Function
      Description
    
  
  
    
      math.compile(expr)
      Parse and compile an expression.
    
    
      math.evaluate(expr [, scope])
      Evaluate an expression.
    
    
      math.help(search)
      Retrieve help on a function or data type.
    
    
      math.parser()
      Create a parser.
    
  


Algebra functions #


  
    
      Function
      Description
    
  
  
    
      math.derivative(expr, variable)
      Takes the derivative of an expression expressed in parser Nodes.
    
    
      math.leafCount(expr)
      Gives the number of “leaf nodes” in the parse tree of the given expression A leaf node is one that has no subexpressions, essentially either a symbol or a constant.
    
    
      math.lsolve(L, b)
      Finds one solution of a linear equation system by forwards substitution.
    
    
      math.lsolveAll(L, b)
      Finds all solutions of a linear equation system by forwards substitution.
    
    
      math.lup(A)
      Calculate the Matrix LU decomposition with partial pivoting.
    
    
      math.lusolve(A, b)
      Solves the linear system A * x = b where A is an [n x n] matrix and b is a [n] column vector.
    
    
      math.lyap(A, Q)
      Solves the Continuous-time Lyapunov equation AP+PA’+Q=0 for P, where Q is an input matrix.
    
    
      math.polynomialRoot(constant, linearCoeff, quadraticCoeff, cubicCoeff)
      Finds the numerical values of the distinct roots of a polynomial with real or complex coefficients.
    
    
      math.qr(A)
      Calculate the Matrix QR decomposition.
    
    
      math.rationalize(expr)
      Transform a rationalizable expression in a rational fraction.
    
    
      math.resolve(expr, scope)
      resolve(expr, scope) replaces variable nodes with their scoped values.
    
    
      math.schur(A)
      Performs a real Schur decomposition of the real matrix A = UTU’ where U is orthogonal and T is upper quasi-triangular.
    
    
      math.simplify(expr)
      Simplify an expression tree.
    
    
      math.simplifyConstant(expr)
      simplifyConstant() takes a mathjs expression (either a Node representing a parse tree or a string which it parses to produce a node), and replaces any subexpression of it consisting entirely of constants with the computed value of that subexpression.
    
    
      math.simplifyCore(expr)
      simplifyCore() performs single pass simplification suitable for applications requiring ultimate performance.
    
    
      math.slu(A, order, threshold)
      Calculate the Sparse Matrix LU decomposition with full pivoting.
    
    
      math.sylvester(A, B, C)
      Solves the real-valued Sylvester equation AX+XB=C for X, where A, B and C are matrices of appropriate dimensions, being A and B squared.
    
    
      math.symbolicEqual(expr1, expr2)
      Attempts to determine if two expressions are symbolically equal, i.
    
    
      math.usolve(U, b)
      Finds one solution of a linear equation system by backward substitution.
    
    
      math.usolveAll(U, b)
      Finds all solutions of a linear equation system by backward substitution.
    
  


Arithmetic functions #


  
    
      Function
      Description
    
  
  
    
      math.abs(x)
      Calculate the absolute value of a number.
    
    
      math.add(x, y)
      Add two or more values, x + y.
    
    
      math.cbrt(x [, allRoots])
      Calculate the cubic root of a value.
    
    
      math.ceil(x)
      Round a value towards plus infinity If x is complex, both real and imaginary part are rounded towards plus infinity.
    
    
      math.cube(x)
      Compute the cube of a value, x * x * x.
    
    
      math.divide(x, y)
      Divide two values, x / y.
    
    
      math.dotDivide(x, y)
      Divide two matrices element wise.
    
    
      math.dotMultiply(x, y)
      Multiply two matrices element wise.
    
    
      math.dotPow(x, y)
      Calculates the power of x to y element wise.
    
    
      math.exp(x)
      Calculate the exponential of a value.
    
    
      math.expm1(x)
      Calculate the value of subtracting 1 from the exponential value.
    
    
      math.fix(x)
      Round a value towards zero.
    
    
      math.floor(x)
      Round a value towards minus infinity.
    
    
      math.gcd(a, b)
      Calculate the greatest common divisor for two or more values or arrays.
    
    
      math.hypot(a, b, …)
      Calculate the hypotenuse of a list with values.
    
    
      math.invmod(a, b)
      Calculate the (modular) multiplicative inverse of a modulo b.
    
    
      math.lcm(a, b)
      Calculate the least common multiple for two or more values or arrays.
    
    
      math.log(x [, base])
      Calculate the logarithm of a value.
    
    
      math.log10(x)
      Calculate the 10-base logarithm of a value.
    
    
      math.log1p(x)
      Calculate the logarithm of a value+1.
    
    
      math.log2(x)
      Calculate the 2-base of a value.
    
    
      math.mod(x, y)
      Calculates the modulus, the remainder of an integer division.
    
    
      math.multiply(x, y)
      Multiply two or more values, x * y.
    
    
      math.norm(x [, p])
      Calculate the norm of a number, vector or matrix.
    
    
      math.nthRoot(a)
      Calculate the nth root of a value.
    
    
      math.nthRoots(x)
      Calculate the nth roots of a value.
    
    
      math.pow(x, y)
      Calculates the power of x to y, x ^ y.
    
    
      math.round(x [, n])
      Round a value towards the nearest rounded value.
    
    
      math.sign(x)
      Compute the sign of a value.
    
    
      math.sqrt(x)
      Calculate the square root of a value.
    
    
      math.square(x)
      Compute the square of a value, x * x.
    
    
      math.subtract(x, y)
      Subtract two values, x - y.
    
    
      math.unaryMinus(x)
      Inverse the sign of a value, apply a unary minus operation.
    
    
      math.unaryPlus(x)
      Unary plus operation.
    
    
      math.xgcd(a, b)
      Calculate the extended greatest common divisor for two values.
    
  


Bitwise functions #


  
    
      Function
      Description
    
  
  
    
      math.bitAnd(x, y)
      Bitwise AND two values, x & y.
    
    
      math.bitNot(x)
      Bitwise NOT value, ~x.
    
    
      math.bitOr(x, y)
      Bitwise OR two values, x | y.
    
    
      math.bitXor(x, y)
      Bitwise XOR two values, x ^ y.
    
    
      math.leftShift(x, y)
      Bitwise left logical shift of a value x by y number of bits, x << y.
    
    
      math.rightArithShift(x, y)
      Bitwise right arithmetic shift of a value x by y number of bits, x >> y.
    
    
      math.rightLogShift(x, y)
      Bitwise right logical shift of value x by y number of bits, x >>> y.
    
  


Combinatorics functions #


  
    
      Function
      Description
    
  
  
    
      math.bellNumbers(n)
      The Bell Numbers count the number of partitions of a set.
    
    
      math.catalan(n)
      The Catalan Numbers enumerate combinatorial structures of many different types.
    
    
      math.composition(n, k)
      The composition counts of n into k parts.
    
    
      math.stirlingS2(n, k)
      The Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets.
    
  


Complex functions #


  
    
      Function
      Description
    
  
  
    
      math.arg(x)
      Compute the argument of a complex value.
    
    
      math.conj(x)
      Compute the complex conjugate of a complex value.
    
    
      math.im(x)
      Get the imaginary part of a complex number.
    
    
      math.re(x)
      Get the real part of a complex number.
    
  


Geometry functions #


  
    
      Function
      Description
    
  
  
    
      math.distance([x1,y1], [x2,y2])
      Calculates:    The eucledian distance between two points in N-dimensional spaces.
    
    
      math.intersect(endPoint1Line1, endPoint2Line1, endPoint1Line2, endPoint2Line2)
      Calculates the point of intersection of two lines in two or three dimensions and of a line and a plane in three dimensions.
    
  


Logical functions #


  
    
      Function
      Description
    
  
  
    
      math.and(x, y)
      Logical and.
    
    
      math.not(x)
      Logical not.
    
    
      math.or(x, y)
      Logical or.
    
    
      math.xor(x, y)
      Logical xor.
    
  


Matrix functions #


  
    
      Function
      Description
    
  
  
    
      math.column(value, index)
      Return a column from a Matrix.
    
    
      math.concat(a, b, c, … [, dim])
      Concatenate two or more matrices.
    
    
      math.count(x)
      Count the number of elements of a matrix, array or string.
    
    
      math.cross(x, y)
      Calculate the cross product for two vectors in three dimensional space.
    
    
      math.ctranspose(x)
      Transpose and complex conjugate a matrix.
    
    
      math.det(x)
      Calculate the determinant of a matrix.
    
    
      math.diag(X)
      Create a diagonal matrix or retrieve the diagonal of a matrix  When x is a vector, a matrix with vector x on the diagonal will be returned.
    
    
      math.diff(arr)
      Create a new matrix or array of the difference between elements of the given array The optional dim parameter lets you specify the dimension to evaluate the difference of If no dimension parameter is passed it is assumed as dimension 0  Dimension is zero-based in javascript and one-based in the parser and can be a number or bignumber Arrays must be ‘rectangular’ meaning arrays like [1, 2] If something is passed as a matrix it will be returned as a matrix but other than that all matrices are converted to arrays.
    
    
      math.dot(x, y)
      Calculate the dot product of two vectors.
    
    
      math.eigs(x, [prec])
      Compute eigenvalues and optionally eigenvectors of a square matrix.
    
    
      math.expm(x)
      Compute the matrix exponential, expm(A) = e^A.
    
    
      math.fft(arr)
      Calculate N-dimensional Fourier transform.
    
    
      math.filter(x, test)
      Filter the items in an array or one dimensional matrix.
    
    
      math.flatten(x)
      Flatten a multidimensional matrix into a single dimensional matrix.
    
    
      math.forEach(x, callback)
      Iterate over all elements of a matrix/array, and executes the given callback function.
    
    
      math.getMatrixDataType(x)
      Find the data type of all elements in a matrix or array, for example ‘number’ if all items are a number and ‘Complex’ if all values are complex numbers.
    
    
      math.identity(n)
      Create a 2-dimensional identity matrix with size m x n or n x n.
    
    
      math.ifft(arr)
      Calculate N-dimensional inverse Fourier transform.
    
    
      math.inv(x)
      Calculate the inverse of a square matrix.
    
    
      math.kron(x, y)
      Calculates the Kronecker product of 2 matrices or vectors.
    
    
      math.map(x, callback)
      Create a new matrix or array with the results of a callback function executed on each entry of a given matrix/array.
    
    
      math.mapSlices(A, dim, callback)
      Apply a function that maps an array to a scalar along a given axis of a matrix or array.
    
    
      math.matrixFromColumns(…arr)
      Create a dense matrix from vectors as individual columns.
    
    
      math.matrixFromFunction(size, fn)
      Create a matrix by evaluating a generating function at each index.
    
    
      math.matrixFromRows(…arr)
      Create a dense matrix from vectors as individual rows.
    
    
      math.ones(m, n, p, …)
      Create a matrix filled with ones.
    
    
      math.partitionSelect(x, k)
      Partition-based selection of an array or 1D matrix.
    
    
      math.pinv(x)
      Calculate the Moore–Penrose inverse of a matrix.
    
    
      math.range(start, end [, step])
      Create an array from a range.
    
    
      math.reshape(x, sizes)
      Reshape a multi dimensional array to fit the specified dimensions.
    
    
      math.resize(x, size [, defaultValue])
      Resize a matrix.
    
    
      math.rotate(w, theta)
      Rotate a vector of size 1x2 counter-clockwise by a given angle Rotate a vector of size 1x3 counter-clockwise by a given angle around the given axis.
    
    
      math.rotationMatrix(theta)
      Create a 2-dimensional counter-clockwise rotation matrix (2x2) for a given angle (expressed in radians).
    
    
      math.row(value, index)
      Return a row from a Matrix.
    
    
      math.size(x)
      Calculate the size of a matrix or scalar.
    
    
      math.sort(x)
      Sort the items in a matrix.
    
    
      math.sqrtm(A)
      Calculate the principal square root of a square matrix.
    
    
      math.squeeze(x)
      Squeeze a matrix, remove inner and outer singleton dimensions from a matrix.
    
    
      math.subset(x, index [, replacement])
      Get or set a subset of a matrix or string.
    
    
      math.trace(x)
      Calculate the trace of a matrix: the sum of the elements on the main diagonal of a square matrix.
    
    
      math.transpose(x)
      Transpose a matrix.
    
    
      math.zeros(m, n, p, …)
      Create a matrix filled with zeros.
    
  


Numeric functions #


  
    
      Function
      Description
    
  
  
    
      math.solveODE(func, tspan, y0)
      Numerical Integration of Ordinary Differential Equations  Two variable step methods are provided: - “RK23”: Bogacki–Shampine method - “RK45”: Dormand-Prince method RK5(4)7M (default)  The arguments are expected as follows.
    
  


Probability functions #


  
    
      Function
      Description
    
  
  
    
      math.combinations(n, k)
      Compute the number of ways of picking k unordered outcomes from n possibilities.
    
    
      math.combinationsWithRep(n, k)
      Compute the number of ways of picking k unordered outcomes from n possibilities, allowing individual outcomes to be repeated more than once.
    
    
      math.factorial(n)
      Compute the factorial of a value  Factorial only supports an integer value as argument.
    
    
      math.gamma(n)
      Compute the gamma function of a value using Lanczos approximation for small values, and an extended Stirling approximation for large values.
    
    
      math.kldivergence(x, y)
      Calculate the Kullback-Leibler (KL) divergence  between two distributions.
    
    
      math.lgamma(n)
      Logarithm of the gamma function for real, positive numbers and complex numbers, using Lanczos approximation for numbers and Stirling series for complex numbers.
    
    
      math.multinomial(a)
      Multinomial Coefficients compute the number of ways of picking a1, a2, .
    
    
      math.permutations(n [, k])
      Compute the number of ways of obtaining an ordered subset of k elements from a set of n elements.
    
    
      math.pickRandom(array)
      Random pick one or more values from a one dimensional array.
    
    
      math.random([min, max])
      Return a random number larger or equal to min and smaller than max using a uniform distribution.
    
    
      math.randomInt([min, max])
      Return a random integer number larger or equal to min and smaller than max using a uniform distribution.
    
  


Relational functions #


  
    
      Function
      Description
    
  
  
    
      math.compare(x, y)
      Compare two values.
    
    
      math.compareNatural(x, y)
      Compare two values of any type in a deterministic, natural way.
    
    
      math.compareText(x, y)
      Compare two strings lexically.
    
    
      math.deepEqual(x, y)
      Test element wise whether two matrices are equal.
    
    
      math.equal(x, y)
      Test whether two values are equal.
    
    
      math.equalText(x, y)
      Check equality of two strings.
    
    
      math.larger(x, y)
      Test whether value x is larger than y.
    
    
      math.largerEq(x, y)
      Test whether value x is larger or equal to y.
    
    
      math.smaller(x, y)
      Test whether value x is smaller than y.
    
    
      math.smallerEq(x, y)
      Test whether value x is smaller or equal to y.
    
    
      math.unequal(x, y)
      Test whether two values are unequal.
    
  


Set functions #


  
    
      Function
      Description
    
  
  
    
      math.setCartesian(set1, set2)
      Create the cartesian product of two (multi)sets.
    
    
      math.setDifference(set1, set2)
      Create the difference of two (multi)sets: every element of set1, that is not the element of set2.
    
    
      math.setDistinct(set)
      Collect the distinct elements of a multiset.
    
    
      math.setIntersect(set1, set2)
      Create the intersection of two (multi)sets.
    
    
      math.setIsSubset(set1, set2)
      Check whether a (multi)set is a subset of another (multi)set.
    
    
      math.setMultiplicity(element, set)
      Count the multiplicity of an element in a multiset.
    
    
      math.setPowerset(set)
      Create the powerset of a (multi)set.
    
    
      math.setSize(set)
      Count the number of elements of a (multi)set.
    
    
      math.setSymDifference(set1, set2)
      Create the symmetric difference of two (multi)sets.
    
    
      math.setUnion(set1, set2)
      Create the union of two (multi)sets.
    
  


Signal functions #


  
    
      Function
      Description
    
  
  
    
      math.freqz(b, a)
      Calculates the frequency response of a filter given its numerator and denominator coefficients.
    
    
      math.zpk2tf(z, p, k)
      Compute the transfer function of a zero-pole-gain model.
    
  


Special functions #


  
    
      Function
      Description
    
  
  
    
      math.erf(x)
      Compute the erf function of a value using a rational Chebyshev approximations for different intervals of x.
    
    
      math.zeta(n)
      Compute the Riemann Zeta function of a value using an infinite series for all of the complex plane using Riemann’s Functional equation.
    
  


Statistics functions #


  
    
      Function
      Description
    
  
  
    
      math.corr(A, B)
      Compute the correlation coefficient of a two list with values, For matrices, the matrix correlation coefficient is calculated.
    
    
      math.cumsum(a, b, c, …)
      Compute the cumulative sum of a matrix or a list with values.
    
    
      math.mad(a, b, c, …)
      Compute the median absolute deviation of a matrix or a list with values.
    
    
      math.max(a, b, c, …)
      Compute the maximum value of a matrix or a  list with values.
    
    
      math.mean(a, b, c, …)
      Compute the mean value of matrix or a list with values.
    
    
      math.median(a, b, c, …)
      Compute the median of a matrix or a list with values.
    
    
      math.min(a, b, c, …)
      Compute the minimum value of a matrix or a  list of values.
    
    
      math.mode(a, b, c, …)
      Computes the mode of a set of numbers or a list with values(numbers or characters).
    
    
      math.prod(a, b, c, …)
      Compute the product of a matrix or a list with values.
    
    
      math.quantileSeq(A, prob[, sorted])
      Compute the prob order quantile of a matrix or a list with values.
    
    
      math.std(a, b, c, …)
      Compute the standard deviation of a matrix or a  list with values.
    
    
      math.sum(a, b, c, …)
      Compute the sum of a matrix or a list with values.
    
    
      math.variance(a, b, c, …)
      Compute the variance of a matrix or a  list with values.
    
  


String functions #


  
    
      Function
      Description
    
  
  
    
      math.bin(value)
      Format a number as binary.
    
    
      math.format(value [, precision])
      Format a value of any type into a string.
    
    
      math.hex(value)
      Format a number as hexadecimal.
    
    
      math.oct(value)
      Format a number as octal.
    
    
      math.print(template, values [, precision])
      Interpolate values into a string template.
    
  


Trigonometry functions #


  
    
      Function
      Description
    
  
  
    
      math.acos(x)
      Calculate the inverse cosine of a value.
    
    
      math.acosh(x)
      Calculate the hyperbolic arccos of a value, defined as acosh(x) = ln(sqrt(x^2 - 1) + x).
    
    
      math.acot(x)
      Calculate the inverse cotangent of a value, defined as acot(x) = atan(1/x).
    
    
      math.acoth(x)
      Calculate the inverse hyperbolic tangent of a value, defined as acoth(x) = atanh(1/x) = (ln((x+1)/x) + ln(x/(x-1))) / 2.
    
    
      math.acsc(x)
      Calculate the inverse cosecant of a value, defined as acsc(x) = asin(1/x).
    
    
      math.acsch(x)
      Calculate the inverse hyperbolic cosecant of a value, defined as acsch(x) = asinh(1/x) = ln(1/x + sqrt(1/x^2 + 1)).
    
    
      math.asec(x)
      Calculate the inverse secant of a value.
    
    
      math.asech(x)
      Calculate the hyperbolic arcsecant of a value, defined as asech(x) = acosh(1/x) = ln(sqrt(1/x^2 - 1) + 1/x).
    
    
      math.asin(x)
      Calculate the inverse sine of a value.
    
    
      math.asinh(x)
      Calculate the hyperbolic arcsine of a value, defined as asinh(x) = ln(x + sqrt(x^2 + 1)).
    
    
      math.atan(x)
      Calculate the inverse tangent of a value.
    
    
      math.atan2(y, x)
      Calculate the inverse tangent function with two arguments, y/x.
    
    
      math.atanh(x)
      Calculate the hyperbolic arctangent of a value, defined as atanh(x) = ln((1 + x)/(1 - x)) / 2.
    
    
      math.cos(x)
      Calculate the cosine of a value.
    
    
      math.cosh(x)
      Calculate the hyperbolic cosine of a value, defined as cosh(x) = 1/2 * (exp(x) + exp(-x)).
    
    
      math.cot(x)
      Calculate the cotangent of a value.
    
    
      math.coth(x)
      Calculate the hyperbolic cotangent of a value, defined as coth(x) = 1 / tanh(x).
    
    
      math.csc(x)
      Calculate the cosecant of a value, defined as csc(x) = 1/sin(x).
    
    
      math.csch(x)
      Calculate the hyperbolic cosecant of a value, defined as csch(x) = 1 / sinh(x).
    
    
      math.sec(x)
      Calculate the secant of a value, defined as sec(x) = 1/cos(x).
    
    
      math.sech(x)
      Calculate the hyperbolic secant of a value, defined as sech(x) = 1 / cosh(x).
    
    
      math.sin(x)
      Calculate the sine of a value.
    
    
      math.sinh(x)
      Calculate the hyperbolic sine of a value, defined as sinh(x) = 1/2 * (exp(x) - exp(-x)).
    
    
      math.tan(x)
      Calculate the tangent of a value.
    
    
      math.tanh(x)
      Calculate the hyperbolic tangent of a value, defined as tanh(x) = (exp(2 * x) - 1) / (exp(2 * x) + 1).
    
  


Unit functions #


  
    
      Function
      Description
    
  
  
    
      math.to(x, unit)
      Change the unit of a value.
    
  


Utils functions #


  
    
      Function
      Description
    
  
  
    
      math.clone(x)
      Clone an object.
    
    
      math.hasNumericValue(x)
      Test whether a value is an numeric value.
    
    
      math.isInteger(x)
      Test whether a value is an integer number.
    
    
      math.isNaN(x)
      Test whether a value is NaN (not a number).
    
    
      math.isNegative(x)
      Test whether a value is negative: smaller than zero.
    
    
      math.isNumeric(x)
      Test whether a value is an numeric value.
    
    
      math.isPositive(x)
      Test whether a value is positive: larger than zero.
    
    
      math.isPrime(x)
      Test whether a value is prime: has no divisors other than itself and one.
    
    
      math.isZero(x)
      Test whether a value is zero.
    
    
      math.numeric(x)
      Convert a numeric input to a specific numeric type: number, BigNumber, bigint, or Fraction.
    
    
      math.typeOf(x)
      Determine the type of an entity.\n\n\n\nConstant reference #

Math.js contains the following constants.


  
    
      Constant
      Description
      Value
    
  
  
    
      e, E
      Euler’s number, the base of the natural logarithm.
      2.718281828459045
    
    
      i
      Imaginary unit, defined as i * i = -1. A complex number is described as a + b * i, where a is the real part, and b is the imaginary part.
      sqrt(-1)
    
    
      Infinity
      Infinity, a number which is larger than the maximum number that can be handled by a floating point number.
      Infinity
    
    
      LN2
      Returns the natural logarithm of 2.
      0.6931471805599453
    
    
      LN10
      Returns the natural logarithm of 10.
      2.302585092994046
    
    
      LOG2E
      Returns the base-2 logarithm of E.
      1.4426950408889634
    
    
      LOG10E
      Returns the base-10 logarithm of E.
      0.4342944819032518
    
    
      NaN
      Not a number.
      NaN
    
    
      null
      Value null.
      null
    
    
      phi
      Phi is the golden ratio. Two quantities are in the golden ratio if their ratio is the same as the ratio of their sum to the larger of the two quantities. Phi is defined as (1 + sqrt(5)) / 2
      1.618033988749895
    
    
      pi, PI
      The number pi is a mathematical constant that is the ratio of a circle's circumference to its diameter.
      3.141592653589793
    
    
      SQRT1_2
      Returns the square root of 1/2.
      0.7071067811865476
    
    
      SQRT2
      Returns the square root of 2.
      1.4142135623730951
    
    
      tau
      Tau is the ratio constant of a circle's circumference to radius, equal to 2 * pi.
      6.283185307179586
    
    
      undefined
      An undefined value. Preferably, use null to indicate undefined values.
      undefined
    
    
      version
      Returns the version number of math.js.
      For example 0.24.1
    
  


Example usage:

math.sin(math.pi / 4)          // 0.70711
math.multiply(math.i, math.i)  // -1\n\n\n\nCustom bundling #

Math.js is a large library containing many data types and functions.
It is well possible that you only need a small portion of the library.
Math.js allows for picking just the functions and data types you need.
This gives faster load times and smaller browser bundles. Math.js uses
ES modules, and creating small bundles using tree-shaking works out of
the box when using Webpack for example.

This page describes:


  How to use just a few functions for faster load times and smaller bundles.
  How to use light-weight, number only implementations of functions.
  What to expect from bundle sizes when using tree-shaking.


Using just a few functions #

Using the function create, a mathjs instance can be created.
The all object contains all functionality available in mathjs,
and a mathjs instance containing everything can be created like:

import { create, all } from 'mathjs'

const math = create(all)


To create an instance with just a few functions, you have to pass the
factory functions of the functions you need, and all their dependencies.
For example the function add depends on the functions addScalar,
equalScalar, classes DenseMatrix and SparseMatrix, and more.
Because it is hard to figure out what the dependencies of a function are,
and the dependencies of the dependencies, mathjs provides ready made
collections of all dependencies for every function. For example all
factory functions of function add and its dependencies are available
as addDependencies.

Here is a full example of loading just a few functions in a mathjs instance:

// file: custom_loading.js

import {
  create,
  fractionDependencies,
  addDependencies,
  divideDependencies,
  formatDependencies
} from 'mathjs'

const config = {
  // optionally, you can specify configuration
}

// Create just the functions we need
const { fraction, add, divide, format } = create({
  fractionDependencies,
  addDependencies,
  divideDependencies,
  formatDependencies
}, config)

// Use the created functions
const a = fraction(1, 3)
const b = fraction(3, 7)
const c = add(a, b)
const d = divide(a, b)
console.log('c =', format(c)) // outputs "c = 16/21"
console.log('d =', format(d)) // outputs "d = 7/9"


This example can be bundled using for example Webpack:

npx webpack custom_loading.js -o custom_loading.bundle.js --mode=production


Only the used parts of mathjs will be bundled thanks to tree-shaking.

Numbers only #

The functions of mathjs support multiple data types out of the box, like
numbers, bignumbers, complex numbers, units, and matrices. Quite commonly however,
only support for numbers is needed and the other data-types are overkill.

To accomodate for this use case where just the JavaScript number type
suffices, mathjs offers light-weight,
number-only implementations of all relevant functions. These are available by
importing from 'mathjs/number' instead of 'mathjs':

// use light-weight, number-only implementations of functions
import { create, all } from 'mathjs/number'

const math = create(all)
console.log(math.add(2, 3)) // 5


Bundle size #

When using just a few functions of mathjs instead of the whole library,
you may expect the size of the bundle to be just a small fraction of the
complete library. However, to create the function add supporting all data
types, all these data types must be included: Unit, BigNumber, Complex,
DenseMatrix, SparseMatrix, etc. A rough idea of the size of different parts of
mathjs:


  About 5% is coming from core functionality like create, import, factory,
typed-function, etc.
  About 30% of the bundle size comes from the data classes Complex, BigNumber, Fraction, Unit, SparseMatrix, DenseMatrix.
  About 25%  of the bundle size comes from the expression parser.
Half of this comes from the embedded docs.
  About 40% comes from the about 200 built-in functions and some constants.


To get a better insight in what is in your JavaScript bundle, you can use
a tool like source-map-explorer.\n\n\n\nCommand Line Interface (CLI) #

When math.js is installed globally using npm, its expression parser can be used
from the command line. To install math.js globally:

$ npm install -g mathjs


Normally, a global installation must be run with admin rights (precede the
command with sudo). After installation, the application mathjs is available
via the command line:

$ mathjs
> 12 / (2.3 + 0.7)
4
> 12.7 cm to inch
5 inch
> sin(45 deg) ^ 2
0.5
> 9 / 3 + 2i
3 + 2i
> det([-1, 2; 3, 1])
-7


The command line interface can be used to open a prompt, to execute a script,
or to pipe input and output streams:

$ mathjs                                 # Open a command prompt
$ mathjs script.txt                      # Run a script file, output to console
$ mathjs script1.txt script2.txt         # Run two script files
$ mathjs script.txt > results.txt        # Run a script file, output to file
$ cat script.txt | mathjs                # Run input stream, output to console
$ cat script.txt | mathjs > results.txt  # Run input stream, output to file


You can also use it to create LaTeX from or sanitize your expressions using the
--tex and --string options:

$ mathjs --tex
> 1/2
\frac{1}{2}


$ mathjs --string
> (1+1+1)
(1 + 1 + 1)


To change the parenthesis option use the --parenthesis= flag:

$ mathjs --string --parenthesis=auto
> (1+1+1)
1 + 1 + 1


$ mathjs --string --parenthesis=all
> (1+1+1)
(1 + 1) + 1


Command line debugging (REPL) #

The library also provides a REPL (Read Evaluate Print Loop) via bin/repl.js which
loads mathjs in a Node.js command line environment.
You can either start it directly (./bin/repl.js) or via node (node bin/repl.js).

You can exit using either [ctrl]-[C] or [ctrl]-[D].

$ ./bin/repl.js 
> math.parse('1+1')
{ op: '+',
  fn: 'add',
  args: 
   [ { value: '1', valueType: 'number' },
     { value: '1', valueType: 'number' } ] }
>\n\n\n\nHistory #

2025-03-28, 14.4.0 #


  Feat: improve the performance of function flatten (#3400). Thanks @dvd101x.
  Feat: improve the performance of map and forEach (#3409).
Thanks @dvd101x.
  Feat: add LaTeX representation for fractions (#3434, #3419). Thanks @orelbn.
  Fix: #3422 allow dot operators after symbol E (#3425).
  Fix: issue in the nthRoots latex function template string (#3427).
Thanks @aitee.
  Fix: upgrade to the latest version of @babel/runtime.


2025-03-06, 14.3.1 #


  Fix: #3350 cannot import a constant that is a complex number.


2025-02-28, 14.3.0 #


  Feat: improved performance of function flatten (#3354). Thanks @dvd101x.
  Feat: improved performance of DenseMatrix Symbol.iterator (#3395). 
Thanks @dvd101x.
  Feat: improved performance of functions map and forEach (#3399).
Thanks @dvd101x.
  Fix: #3390 issue in callback optimization and add error handling for invalid
argument types (#3394). Thanks @dvd101x.
  Fix: #3356 add missing eigsDependencies export to TypeScript definitions 
(#3397). Thanks @porst17.
  Fix: #3406 infer the correct type for multi-dimensional arrays in function 
multiply (#3408). Thanks @orelbn.
  Fix: #3387 use utility math.isNaN for consistent max and min results 
(#3389). Thanks @orelbn.


2025-02-05, 14.2.1 #


  Fix: #3377 remove redundant dependency @lambdatest/node-tunnel.


2025-01-30, 14.2.0 #


  Feat: #3041, #3340 rename apply to mapSlices (#3357). Function
apply is still available but is now marked deprecated. Thanks @gwhitney.
  Fix: #3247 don’t override type-native floor/ceil within tolerance of value 
(#3369). Thanks @gwhitney.
  Fix: #3360 add bigint support to matrix indices and ranges (#3361).
Thanks @gwhitney.
  Fix: #3115 type definitions for matrixFrom* (#3371). Thanks @Hudsxn 
and @gwhitney.


2025-01-24, 14.1.0 #


  Feat: implement bigint support in functions log, log2, log10, 
larger, smaller, max, min (#3345). Thanks @gwhitney.
  Fix: #3342 hexadecimal input not turned into a bigint (#3348).
  Fix randomInt() not working (#3345).
  Docs: fixed description of sign in the embedded docs (#3338). 
Thanks @witer33.


2024-12-11, 14.0.1 #


  Fix: make derivative much faster (#3322). Thanks @paulftw.
  Fix: #3317 export Fraction type from the fraction.js library instead of
using a custom interface (#3330). Thanks @fchu.


2024-11-20, 14.0.0 #

!!! BE CAREFUL: BREAKING CHANGES !!!


  Feat: Upgrade to fraction.js@5, using bigint under the hood (#3283).
  Feat: Implement support for Unit in functions ceil, floor, and fix.
Possible breaking changes in the type definitions of arrays and matrices
due to the introduction of generics (#3269). Thanks @orelbn.
  Feat: Implement support for log(x: Fraction, base: Fraction).
  Fix: #3301 precedence of % (mod) being higher than * and / (#3311).
Thanks @nkumawat34.
  Fix: #3222 prevent math.import(...) from overriding units unless you 
specify { override: true } (#3225).
  Fix: #3219 let functions dotDivide, dotPow, bitXor, xor, equal,
larger, largerEq, smaller, smallerEq, and unequal return a sparse 
matrix when the input is two sparse matrices (#3307). Thanks @Aakash-Rana.
  Fix: Improve type definitions of arrays (#3306). Thanks @orelbn.


2024-11-20, 13.2.3 #


  Fix: #3260 improve type definitions and documentation on the callback 
indices of map, filter, and forEach.
  Fix: #3323 support functions in function clone.
  Docs: fix a broken link in the documentation (#3316). 
Thanks @emmanuel-ferdman.


2024-11-13, 13.2.2 #


  Fix: #1455 implicit multiplication of a fraction with unit in is incorrect 
(#3315). Thanks @nkumawat34.


2024-11-06, 13.2.1 #


  Update to the latest version of complex.js.
  Fix Index.dimension(dim) accepting non-numeric input.
  Fix: #3290 should validate variables names in method Parser.set (#3308).
Thanks @nkumawat34.


2024-10-02, 13.2.0 #


  Feat: improve performance of functions map, filter and forEach (#3256).
Thanks @dvd101x.
  Feat: improve performance of the methods map() and forEach()
of DenseMatrix (#3251). Thanks @Galm007.
  Fix: #3253 cannot use identifiers containing special characters in function
derivative.
  Fix: improve the type definitions of ConstantNode to support all data 
types (#3257). Thanks @smith120bh.
  Fix: #3259 function symbolicEqual missing in the TypeScript definitions.
  Fix: #3246 function leafCount missing in the TypeScript definitions.
  Fix: #3267 implicit multiplication with a negative number and unit in.
  Docs: fix broken links on the Configuration page. Thanks @vassudanagunta.
  Docs: document the syntax of map and forEach in the expression parser
(#3272). Thanks @dvd101x.


2024-08-27, 13.1.1 #


  Fix security vulnerability in the CLI and web API allowing to call functions
import, createUnit and reviver, allowing to get access to the internal
math namespace and allowing arbitrary code execution. Thanks @StarlightPWN.
  Fix security vulnerability: when overwriting a rawArgs function with a 
non-rawArgs function, it was still called with raw arguments. This was both
a functional issue and a security issue. Thanks @StarlightPWN.
  Fix security vulnerability: ensure that ObjectWrappingMap cannot delete
unsafe properties. Thanks @StarlightPWN.
  Fix: not being able to use methods and properties on arrays inside the
expression parser.


2024-08-26, 13.1.0 #


  Feat: support multiple inputs in function map (#3228, #3196). 
Thanks @dvd101x.
  Feat: add matrix datatypes in more cases (#3235). Thanks @dvd101x.
  Feat: export util functions isMap, isPartitionedMap, and 
isObjectWrappingMap.
  Fix: #3241 function map not always working with matrices (#3242). 
Thanks @dvd101x.
  Fix: #3244 fix broken link to ResultSet in the docs about classes.
  Docs: add a link to the documentation page about the syntax expression
from the function evaluate (see #3238).
  Docs: improve the documentation of scope and fix the example
custom_scope_objects.js (#3150)
  Docs: spelling fixes in the embedded docs (#3252). Thanks @dvd101x.


2024-07-19, 13.0.3 #


  Fix: #3232 fix type definitions of function format to support notations
hex, bin, and oct.
  Fix: use more precise definitions for US liquid volume units (#3229).
Thanks @Vistinum.
  Fix: #2286 types static methods and members for Unit class (#3230).
Thanks @orelbn.


2024-07-04, 13.0.2 #


  Fix an error in the type definitions of quantileSeq (#3223).
Thanks @domdomegg.


2024-06-28, 13.0.1 #


  Fix: #3227 generated bundle containing catch blocks without parameters.
  Fix: #2348 update type definitions of the Parser methods (#3226).
Thanks @orelbn.


2024-05-31, 13.0.0 #

Breaking changes:


  Change isZero, isPositive, and isNegative to respect config.epsilon
(#3139, #2838). Thanks @dvd101x.
  Change the behavior of the internal nearlyEqual to align with Python and
Julia (#3152, #2838). Thanks @dvd101x.
  Upgrade to fraction.js@4.3.7,
see https://github.com/rawify/Fraction.js/issues/68.
  Dropped support for JavaScript engines that do not fully support ES6 or
bigint, or are not actively maintained. ES2020 is now the minimum required
EcmaScript version.


Non-breaking changes:


  Implemented support for bigint (#3207, #3207)
  Implemented a new config option config.numberFallback needed for bigint
(#3207).
  Internal: refactored tooling to ES modules and upgraded all devDependencies.


2024-05-31, 12.4.3 #


  Fix: serialization of Units without a value, see #1240.
  Fix: outdated, incorrect documentation about the order of precedence for
operator modulus %. See #3189.
  Fix: #3197 improve quantileSeq type definitions (#3198). Thanks @domdomegg.


2024-04-24, 12.4.2 #


  Fix #3192: function isNaN returns false for NaN units in a matrix or
array (#3193). Thanks @lgerin.
  Fix: #3180 fix type definitions of functions add and multiply to allow
more than two arguments.
  Docs: correct the docs about traverse returning void (#3177).
Thanks @rohildshah.


2024-03-13, 12.4.1 #


  Docs: implement an interactive version of the Lorenz example, and show the
chart full screen (#3151). Thanks @dvd101x.
  Fix #3172: simplify "true and true".
  Fix #3163: toTex wrongly returning Infinity for large BigNumbers.
  Fix #3162: add license information about CSParse (#3164).
  Fix #3175: cannot delete units using math.Unit.deleteUnit.
  Fix: faster startup time of the CLI and REPL by loading the bundle.
  Fix: remove using polyfill.io inside the example
pretty_printing_with_mathjax.html (#3167). Thanks @SukkaW.


2024-02-22, 12.4.0 #


  Feat: implement support for trailing commas in matrices (#3154, #2968).
Thanks @dvd101x.
  Feat: improve the performance of multiply a lot by adding matrix type
inferencing (#3149). Thanks @RandomGamingDev.
  Fix: #3100 function round not handling round-off errors (#3136).
Thanks @BrianFugate.
  Fix: PartitionedMap and ObjectWrappingMap missing a property
Symbol.iterator, causing problems when trying new Map(scope) (#3156).
  Fix: type definitions of function mode (#3153). Thanks @rich-martinez.
  Docs: describe method getAllAsMap in the Parser docs (#3158, #3157).
Thanks @dvd101x.


2024-02-08, 12.3.2 #


  Improved the performance of custom defined functions in the expression
parser (#3150).
  Fix: #3143 cannot use and and or inside a function definition.
Regression since v12.1.0 (#3150).


2024-02-01, 12.3.1 #


  Improved the typings of the arguments of ArrayNode, FunctionNode,
IndexNode, OperatorNode, and RelationalNode (#3123). Thanks @sylee957.
  Added a fully featured code editor example with CodeMirror and Katex (#3027).
Thanks @dvd101x.
  Fix: #3114 build warnings related to a number of wrong /* #__PURE__ */
annotations.
  Fix: #3142 support BigNumber values for the options of function format:
precision, wordSize, lowerExp, upperExp. Support BigNumber values
for the option wordSize in the functions hex, bin, and oct.
  Fix: #3125 type definitions of function hypot (#3144).
Thanks @silentmissile.
  Fix: #3141 help(config) altering the actual config when evaluating the
examples.
  Docs: #3145 fix documentation about REPL, it does require a build step
nowadays.


2024-01-12, 12.3.0 #


  Implement support new metric prefixes: ronna (R), quetta (Q),
ronto (r), and quecto (q) (#3113, #3112). Thanks @AlexEdgcomb.
  Fix a bug converting a unitless unit (#3117). Thanks @costerwi.
  Fix: #3097 toSI() wrongly converting degC (#3118). Thanks @costerwi.


2023-12-20, 12.2.1 #


  Fix #3109: method Node.toHTML not accepting a custom handler.


2023-12-08, 12.2.0 #


  Feat: lazy evaluation of operators and, or, &, | (#3090, #3101,
#2766). Thanks @smith120bh.
  Fix: passing a 4th argument with a scope to raw functions.
  Fix: #3096 embedded docs of eigs throwing an error.


2023-11-17, 12.1.0 #


  Feat: Extend function round with support for units (#2761, #3095).
  Feat: Extend function mod with support for negative divisors in when
using BigNumber or Fraction (#3087).
  Fix: #3092 a typo in an error message when converting a string into a number.
  Fix: #3094 function derivative mutates the input expression when it fails.


2023-10-26, 12.0.0 #

Breaking changes:


  
    Fix #2879, #2927, #3014: change the confusing interface of eigs (#3037),
thanks @gwhitney.
Before, functions eigs returned an object:

    { values: MathCollection; vectors: MathCollection }
    

    where vectors was a 2d matrix of which the columns contained the vectors.
This is changed to eigs returning an object:

    { 
  values: MathCollection
  eigenvectors: Array<{
    value: number | BigNumber
    vector: MathCollection
  }>
}
    

    Where eigenvectors is an array containing an object with the corresponding
eigenvalue and vector.
  
  Refactored the TypeScript type definitions to make them work with a NodeNext
module resolution (#3079, #2919).
    
      Type MathJsStatic is renamed to MathJsInstance.
      Type FactoryDependencies is deprecated, use MathJsFactory instead, and
import dependency maps directly from the library.
    
  
  Change the assignment operator of .toTex() output from := to = (see
#2980, #2987).
  Drop official support for Node.js 14 and 16.


Features:


  Function eigs now has an option to turn off calculation of eigenvectors
(#3057, #2180). Thanks @gwhitney.


Fixes:


  Find eigenvectors of defective matrices (#3037). Thanks @gwhitney.


2023-10-26, 11.12.0 #


  Implemented function subtractScalar (#3081, #2643), thanks @vrushaket.
  Fix #3073: function format not escaping control characters and double
quotes (#3082).
  Fix: function clone not throwing an error when passing an unsupported
type like a function.
  Fix: #2960 add type definition of function symbolicEqual (#3035),
thanks @juancodeaudio.


2023-10-11, 11.11.2 #


  Fix #3025: improve handling of matrices and error handling
in function corr (#3030). Thanks @vrushaket.
  Fix #3074: improve error message when using function max in derivative.
  Fix #3073: fix parsing quotes inside a string.
  Fix #2027: cannot use named operators like to or mod as property name.


2023-09-20, 11.11.1 #


  Fix #2989: use one-based indices in print in the parser (#3009).
Thanks @dvd101x.
  Fix #2936: mod sometimes giving wrong results due to internal round-off
errors (#3011). Thanks @praisennamonu1.
  Internal refactor of quantileSeq, and fixed the embedded help (#3003).
Thanks @dvd101x.
  Updated dependencies and devDependencies.


2023-09-05, 11.11.0 #


  Implement function corr to calculate the correlation between two matrices
(#3015, #2624). Thanks @vrushaket.
  Lock fraction.js at version 4.3.4 for now, see #3024, 3022,
https://github.com/rawify/Fraction.js/issues/68.


2023-08-31, 11.10.1 #


  Upgrade to fraction.js@4.3.4, see #3022.
  Fix #3020: lruQueue using the global hasOwnProperty which may be
polluted.
  Add support for prefixes for the unit erg, and restrict prefixes of the
unit joule to only long prefixes like kilo and no short prefixes
like k (#3019). Thanks @costerwi.
  Add a new browser example examples/browser/lorenz.html that uses solveODE
and plots the result in a chart (#3018). Thanks @dvd101x.


2023-08-23, 11.10.0 #


  Extend function quantileSeq with support for a dimension (#3002).
Thanks @dvd101x.
  Implement #2735: Support indexing with an array of booleans, for
example a[[true, false, true]] and a[a > 2] (#2994). Thanks @dvd101x.
  Implement function zeta (#2950, #2975, #2904). Thanks @Bobingstern.
  Fix #2990: DenseMatrix can mutate input arrays (#2991).


2023-07-24, 11.9.1 #


  Fix a security vulnerability in FunctionNode and SymbolNode allowing
arbitrary code execution via math.evaluate. Thanks Harry Chen.
  Fix #3001: mathjs bundle containing new Function(...) (CSP issue).


2023-07-19, 11.9.0 #


  Implement function solveODE (#2958). Thanks @dvd101x.
  Implement functions zpk2tf and freqz (#2988, #2969). Thanks @alykhaled.
  Implement support for units in function range (#2997). Thanks @dvd101x.
  Fix #2974: simplify puts plus and minus signs next to each other (#2981).
Thanks @MaybePixem.
  Fix #2973: fixes and improvements in the embedded docs (#2976).
Thanks @dvd101x.
  Fix #2996: two errors in the examples in the documentation about Expression
trees.
  Fix round-off errors near zero when converting temperatures (#2962).
Thanks @costerwi.
  Refactored function range, reducing the amount of code (#2995).
Thanks @dvd101x.


2023-06-20, 11.8.2 #


  Fix #2971: improve typings of statistics functions min, max, mean,
median, mode, std, sum, prod, variance. Fixes a regression
introduced in v11.8.1.
  Fix #2972: type definitions of Unit.divide(Unit) have a wrong return type.


2023-06-13, 11.8.1 #


  Fix #2964: issue in function distance when calculate the distance from
a point to a line (#2965). Thanks @Kiku-CN.
  Fix math.format not working correctly for engineering notation when using
BigNumbers and for fixed notation with precision: 0 configured (#2956).
Thanks @mgreminger.
  Fix #2880: not possible to map cube root cbrt.
  Fix #2938: make the syntax description of all functions consistent in the
docs (#2941). Thanks @dvd101x.
  Fix #2954: improve the TypeScript definitions the return type of functions
min and max (#2955). Thanks @Maxim-Mazurok.
  Fix #2959: typo in an example in the docs. Thanks @kunalagrwl.
  Drop official support for Node.js 14, has reached end of life.


2023-04-03, 11.8.0 #


  Extended functions fraction, bignumber, and number with support for
units, see #2918 (#2926).
  Implemented aliases amp and amps for unit ampere (#2917).
Thanks @veggiesaurus.
  Improve TypeScript definitions of function gcd (#2922). Thanks @brunoSnoww.
  Fix #2923: improve docs of the function distance (#2924). Thanks @tmtron.


2023-03-15, 11.7.0 #


  Implement #2567: accept array as parameter for function gcd (#2878).
Thanks @jakubriegel.
  Fix #2908: improvements in the docs and examples of functions
partitionSelect, diff, expm1, round, nthRoots, sign,
rigthArithShift, setIsSubset, setSize, and the docs about units.
Thanks @tmtron.
  Fix #2907: determinant of empty matrix should be 1.
  Refactor index.d.ts by writing function declarations using a generic,
reducing a lot of repetition (#2913). Thanks @brunoSnoww.


2023-02-24, 11.6.0 #


  Implement broadcasting for the following functions and their corresponding
operator: add, dotDivide, dotMultiply, dotPow, gcd, lcm, mod,
nthRoot, subtract, bitAnd, bitOr, bitXor, leftShift,
rightArithShift, rightLogShift, and, or, xor, compare,
compareText, equal, larger, largerEq, smaller, smallerEq,
unequal, atan2 and to (#2895, #2753). Thanks @dvd101x.
  Implement support for non-power-of-2 fft (#2900, #2577). Thanks @cyavictor88.
  Fix #2888: update type definitions of function unit to allow creating a
unit from a fraction or complex number.
  Fix #2892: an error in the examples of the embedded help of function sort.
  Fix #2891: functions column and row sometimes returning a scalar number.
  Fix #2896: define the fourth argument of function intersect as optional
in the TypeScript definitions. Thanks @wodndb.
  Fix: quantileSeq not accepting a matrix as second argument prob (see #2902).
  Fix broken examples in functions to, distance, getMatrixDataType,
subset, and max (see #2902).


2023-01-31, 11.5.1 #


  Add type definitions for function rotationMatrix (#2860).
Thanks @brunoSnoww.
  Add type signature for lusolve(LUDecomposition, ...) (#2864).
Thanks @evanmiller.
  Fix #2873: the rocket_trajectory_optimization.html example being partly
broken. Thanks @dvd101x.
  Fix #2871: coverage report broken (#2877). Thanks @bornova.
  Fix #2883: update documentation for stat functions, describe missing syntax.
  Fix #2884: fix examples in the embedded docs of function pow and some other
functions.
  Fix type definition of function complex for one numeric input (#2886),
thanks @ariymarkowitz.
  Fix type definitions of map() and forEach() (#2887), thanks @xiaohk.
  Fix #2606: improve type definitions of dotMultiply, dotPow and
dotDivide (#2890). Thanks @brunoSnoww.


2022-12-05, 11.5.0 #


  Improve simplify rule matches in non-commutative contexts (#2841).
Thanks @samueltlg.
  Simplify: add rules and restructure tests for non-commutative contexts
(#2847). Thanks @samueltlg.
  Fix function reshape mutating the input in case of a matrix (see #2854).
  Fix TypeScript types for multiply() with number[] and number[][]
(#2852). Thanks @hfhchan.


2022-11-18, 11.4.0 #


  Implemented more wildcards to describe rules for simplify, making it easier
for example to describe unary minus (#1915). Thanks @thatcomputerguy0101.
  Implemented functions schur, sylvester, and lyap (#2646).
Thanks @egidioln.
  Implemented function polynomialRoot, and use it in a benchmark (#2839).
Thanks @gwhitney.
  Fix #2825 partly: improve simplifying operations on constants in
non-commutative contexts (#2827). Thanks @samueltlg.
  Fix #2840: a bug in the docs and type definitions of Node.traverse and
Node.forEach, they do return void.


2022-11-07, 11.3.3 #


  Fix #2830: Prevent inserting zero values when creating a SparseMatrix from a
DenseMatrix (#2836). Thanks @AlexandreAlvesDB.
  Fix #2835: a regression in the type definitions of FunctionNode, introduced
in v11.3.2. See #2733. Thanks @dsteve.


2022-10-25, 11.3.2 #


  Add generics to remaining Node type definitions (#2733). Thanks @mattvague.
  Allow unit prefixes for (absolute) temperatures kelvin, rankine,
celsius, and fahrenheit (#2824). Thanks @jfeist


2022-10-19, 11.3.1 #


  Fix #2809: code completion issues in some IDE’s (#2812).
  Fix #2818: throw an error when a function assignment has duplicate
parameter names (#2819).
  Update decimal.js to version 10.4.2.


2022-10-11, 11.3.0 #


  Allow creating new subclasses of Node in TypeScript (#2772).
Note that this disables being able to narrow MathNodes by using the .type
property. Use typeguards like isOperatorNode(...) instead (see #2810).
Thanks @mattvague.
  Fix #2793: flatten() cloning entries of array/Matrix (#2799).
  Fix #2627: TypeScript definitions of pinv missing (#2804).
Thanks @HanchaiN.
  Update dependencies to decimal.js@10.4.1.


2022-09-13, 11.2.1 #


  Fix doc generator being broken, not generating a function reference.


2022-09-12, 11.2.0 #


  Implement function isRelationalNode (#2731). Thanks @isaacbyr.
  Added missing types 'largerEq' and 'or' in OperatorNodeMap in the
TypeScript definitions. Thanks @ajinkyac03.
  Fixed typos in min func type defs (#2768). Thanks @mabdullahadeel.
  Improved the TypeScript definitions for pickRandom. Thanks @mattvague.
  Fixed documentation of unit min which means minutes, not minim (#2773).
Thanks @jasonhornsby.


2022-08-23, 11.1.0 #


  Add Unit constructor from value and pure (valueless) Unit (#2628).
Thanks @costerwi
  Fix #2144: examples/advanced/custom_loading.js was broken.
  Fix JSON replacer function missing in the TypeScript definitions.
Thanks @mattvague.
  Update dependencies to typed-function@4.1.0 and decimal.js@10.4.0.


2022-07-25, version 11.0.1 #


  Fix #2632: TypeScript issue of simplifyConstant and simplifyCore
not having a return type defined.


2022-07-23, version 11.0.0 #

!!! BE CAREFUL: BREAKING CHANGES !!!

Breaking changes:


  Dropped official support for IE11.
  Upgraded to typed-function@3, see josdejong/typed-function/HISTORY.md. Thanks @gwhitney. Most importantly:
    
      Conversions now have preference over any.
      The this variable is no longer bound to the typed function itself.
      The properties typed.types, typed.conversions, and typed.ignore
  have been removed.
      There are new static functions available like typed.referTo,
  typed.referToSelf, typed.addTypes, typed.addConversions.
    
  
  Implement amended “Rule 2” for implicit multiplication (#2370, #2460):
when having a division followed by an implicit multiplication, the division
gets higher precedence over the implicit multiplication when (a) the
numerator is a constant with optionally a prefix operator (-, +, ~),
and (b) the denominator is a constant. For example: formerly -1 / 2 x was
interpreted as -1 / (2 * x) and now it is interpreted as (-1 / 2) * x.
Thanks @gwhitney.
  Drop elementwise matrix support for trigonometric functions, exp, log, gamma,
square, sqrt, cube, and cbrt to prevent confusion with standard matrix
functions (#2440, #2465). Instead, use math.map(matrix, fn).
Thanks @gwhitney.
  Simplify: convert equivalent function calls into operators, for example,
add(2, x) will now be simplified into 2 + x (#2415, #2466).
Thanks @gwhitney.
  Removed the automatic conversion from number to string (#2482).
Thanks @gwhitney.
  Fix #2412: let function diff return an empty matrix when the input contains
only one element (#2422).
  Internal refactoring in the simplifyCore logic (#2490, #2484, #2459).
The function simplifyCore will no longer (partially) merge constants, that
behavior has been moved to simplifyConstant. The combination of
simplifyConstant and simplifyCore is still close to the old behavior
of simplifyCore, but there are some differences. To reproduce the same
behavior as the old simplifyCore, you can use
math.simplify(expr, [math.simplifyCore, math.simplifyConstant]).
Thanks to the refactoring, simplify is more thorough in reducing constants.
Thanks @gwhitney.
  Disable support for splitting rest parameters in chained calculations
(#2485, #2474). For example: math.chain(3).max(4, 2).done() will now throw
an error rather than return 4, because the rest parameter of
math.max(...number) has been split between the contents of the chain and
the arguments to the max call. Thanks @gwhitney.
  Function typeOf now returns function (lowercase) for a function instead
of Function (#2560). Thanks @gwhitney.


Non-breaking changes:


  Fix #2600: improve the TypeScript definitions of simplify.
Thanks @laureen-m and @mattvague.
  Fix #2607: improve type definition of createUnit. Thanks @egziko.
  Fix #2608: clarify the docs on the need to configure a smaller epsilon
when using BigNumbers.
  Fix #2613: describe matrix methods get and set in the docs.
  Fix link to math.rationalize in the docs (#2616). Thanks @nukisman.
  Fix #2621: add TypeScript definitions for count (#2622). Thanks @Hansuku.
  Improved TypeScript definitions of multiply (#2623). Thanks @Windrill.


2022-06-28, version 10.6.4 #


  Improve TypeScript definitions of the factory function, thanks @mattvague.


2022-06-24, version 10.6.3 #


  Revert the TypeScript definition fixes for factory applied in v10.6.2,
they give some complications.


2022-06-24, version 10.6.2 #


  Improve TypeScript definitions of ParenthesisNode. Thanks @mattvague.
  Change the TypeScript definition of MathNodeCommon['type'] into a less
strict string, so it is possible to extend with new Node classes.
Thanks @mattvague.
  Improve TypeScript definitions of the factory function, thanks @mattvague.


2022-05-31, version 10.6.1 #


  Improve the  TypeScript types For OperatorNode: you can now define generic
types like OperatorNode<'+', 'add'>. Thanks @mattvague.


2022-05-24, version 10.6.0 #


  Implementation of Fourier transform functions fft and ifft (#2540).
Thanks @HanchaiN.
  Fix TypeScript types not being listed in the exported fields (#2569).
Thanks @mattvague.
  Large improvements in TypeScript definitions for chained expressions (#2537).
Thanks @mattvague.
  Fix #2571: improve TypeScript definition of functions clone and cloneDeep
(#2572). Thanks @mattvague.
  Fix the first argument of derivative holding the expression not correctly
being converted when using .toTex() (#2564). Thanks @mattvague.


2022-05-11, version 10.5.3 #


  Fix #2337: npm package containing examples and docs to solve security
vulnerabilities being reported on the examples and their dependencies.
  Fix core, construction, and some other functions missing in docs.
  Drop official support for Node.js 12 which has reached its end of life.


2022-05-09, version 10.5.2 #


  Fix #2553: @types/mocha defined in dependencies instead of
devDependencies, causing problems in projects that use a different version
of this dependency. Thanks @Kolahzary.
  Fix #2550: remove examples/node_modules folder from the npm package.
  Fix #2528: improve contribution guidelines (#2548).
  Document SymbolNode.onUndefinedSymbol and
FunctionNode.onUndefinedFunction.


2022-05-02, version 10.5.1 #


  Fix #2526, #2529: improve TypeScript definitions of function round, fix,
floor, ceil, and nthRoot, and improved the number only implementations
of those functions  (#2531, #2539). Thanks @simlaticak and @gwhitney.
  Fix #2532: matrix index symbol end not working when used inside
a sub-expression.
  Fix #2524: In generating AUTHORS list, ignore a list of specific commits
(e.g., to avoid spurious duplicates in list). (#2543)
  Add type definitions of function resolve (#2536). Thanks @mattvague.


2022-04-19, version 10.5.0 #


  Implement #1563: function pinv, Moore–Penrose inverse (#2521).
Thanks @HanchaiN.
  Optimize function det for integers by switching to the Bareiss algorithm:
no more round-off errors for integer input (#2516). Thanks @HanchaiN.
  Implement #2463: allow negative integer powers of invertible square matrices
(#2517). Thanks @HanchaiN.
  Implement the lgamma function (defined as log(gamma(z))) for number and
Complex types. Supersedes #320. (#2417). Thanks @yifanwww.
  Fix #2523: update to the latest complex.js to improve sin(z) for small
im(z) (#2525). Thanks @gwhitney.
  Fix #2526: update TypeScript definition of ceil (#2531). Thanks @simlaticak
  Change mocha reporter to ‘dot’ to avoid excessively long log files. (#2520)


2022-04-08, version 10.4.3 #


  Fix #2508: improve the precision of stirlingS2 (#2509). Thanks @gwhitney.
  Fix #2514: implement optional argument base in the number implementation
of function log (#2515). Thanks @gwhitney.
  Improve the documentation on operator ; (#2512). Thanks @gwhitney.


2022-03-29, version 10.4.2 #


  Fix #2499: different behavior for unit conversion “degC” and “K” (#2501).
Also disables getting the sign for units with an offset, which is ambiguous.
Thanks @gwhitney.
  Fix #2503: fix an issue in log() for complex numbers in which the imaginary
part is much larger in absolute value than the real part, fixed in
complex.js@2.1.0 (#2505), thanks @gwhitney, @infusion.
  Fix #2493: unclear error message when an entity that is not a function
is being called as a function (#2494). Thanks @gwhitney.
  Some fixes in the docs on units (#2498). Thanks @dvd101x.
  Add forEach example in embedded docs (#2507). Thanks @dvd101x.
  Correct approx.deepEqual() to accept an epsilon argument giving the
comparison tolerance. It was already being called this way, but was
silently ignoring the tolerance. Thanks @yifanwww.


2022-03-23, version 10.4.1 #


  Improve TypeScript definitions for function unit (#2479).
Thanks @SinanAkkoyun.
  Add tests for type declarations (#2448). Thanks @samestep.
  Further improvement to TypeScript definitions of std and variance
(make dimension parameter optional, #2474). Thanks @NattapongSiri.
  Next step (as per #2431) for full publication of “is” functions like
isMatrix etc: Provide TypeScript definitions of “is” functions and
make them type guards. (#2432). Thanks @ChristopherChudzicki.
  Fix #2491: Multi line object expressions don’t work with comments (#2492).
Thanks @gwhitney.
  Fix #2478: a bug in calculating the eigenvectors when dealing with complex
numbers (#2496). Thanks @gwhitney.
  Update project dependencies and devDependencies.


2022-03-07, version 10.4.0 #


  Fix #2461: make sure simplifyCore recurses over all binary nodes (#2462).
Thanks @gwhitney.
  Fix #2429: fix the TypeScript definitions of functions std and variance
(#2455). Thanks @NattapongSiri.
  Fix #1633: implement a cumsum function generating cumulative sums of a list
of values or a matrix. (#1870). Thanks @hjonasson.
  Upgrade to the latest version of Fraction.js, having more strict input,
only accepting an integer numerator and denominator. See #2427.
  Fix typo in documentation example for format. (#2468) Thanks @abranhe.
  Write unit tests for all jsdoc examples. See #2452. Thanks @gwhitney.


2021-03-02, version 10.3.0 #


  Fix #1260: implement function symbolicEqual (#2424). Thanks @gwhitney.
  Fix #2441, #2442: support passing a function as argument to functions created
in the expression parser (#2443). Thanks @gwhitney.
  Fix #2325: improve documentation of subset indices (#2446). Thanks @gwhitney.
  Fix #2439: fix a bug in complexEigs in which real-valued norms were
inadvertently being typed as complex numbers (#2445). Thanks @gwhitney.
  Fix #2436: improve documentation and error message of function map (#2457).
Thanks @gwhitney.


2022-03-01, version 10.2.0 #


  Implemented context options to control simplifications allowed in simplify,
see #2399, #2391. Thanks @gwhitney.
  Implemented function leafCount as a first simple measure of the complexity
of an expression, see #2411, #2389. Thanks @gwhitney.
  Fix #2413: improve combinations to return an integer result without rounding
errors for larger values, see #2414. Thanks @gwhitney.
  Fix #2385: function rotate missing in TypeScript definitions.
Thanks @DIVYA-19.
  Fix #2450: Add BigNumber to parameter type in math.unit and add TypeScript
types for Unit.simplify and Unit.units (#2353). Thanks @joshhansen.
  Fix #2383: detect infinite loops in simplify (#2405). Thanks @gwhitney.
  Fix #1423: collect like factors and cancel like terms in sums (#2388).
Thanks @gwhitney.


2022-02-02, version 10.1.1 #


  Improvements and fixes in function simplify, thanks @gwhitney:
    
      Fix #2393: regression bug in simplify('2-(x+1)').
      Ad option consoleDebug to simplify to see what is going on.
    
  
  Fix TypeScript definition of ConfigOptions, which was missing option
predictable.


2022-01-15, version 10.1.0 #


  Implemented function invmod, see #2368, #1744. Thanks @thetazero.
  Improvements and fixes in function simplify, thanks @gwhitney:
    
      Fix #1179, #1290: improve collection of non-constant like terms (#2384).
      Fix #2152: do not transform strings into numbers (#2372).
      Fix #1913: implement support for array and object simplification (#2382).
    
  
  Fix #2379: add embedded documentation for function print.
  Remove broken example from the embedded documentation of function forEach.


2021-12-29, version 10.0.2 #


  Fix #2156: simplify expressions like -1 / (-x) to 1/x. Thanks @ony3000.
  Fix #2363: remove a redundant part of the regex to split a number.
  Fix #2291: add support for fractions in function intersect.
Thanks @thetazero.
  Fix #2358: bug in SparseMatrix when replacing a subset of a matrix with
a non-consecutive index. Thanks @Al-0.


2021-12-22, version 10.0.1 #


  Fix #1681: function gamma giving inaccurate complex results in some cases.
Thanks @kmdrGroch.
  Fixed a typo in an example, see #2366. Thanks @blackwindforce.


2021-11-03, version 10.0.0 #

!!! BE CAREFUL: BREAKING CHANGES IN THE TYPESCRIPT DEFINITIONS !!!


  
    Improvements to the Typescript typings (commit fc5c202e).
Thanks @joshhansen. First introduced in v9.5.1, but reverted because
it contains breaking changes.

    Breaking changes: interface MathNode is now renamed to MathNodeCommon
and the related interfaces are structured in a different way.
  
  
    Fixed a typo in the TypeScript definition of toHTML. Thanks @TheToto.
  


2021-11-03, version 9.5.2` #


  Revert the improvements to the Typescript typings because they contain
breaking changes. The improvements will be published in v10.0.0. See #2339.


2021-10-13, version 9.5.1 #


  Various improvements to the Typescript typings.
Thanks @joshhansen and @DianaTdr.


2021-09-22, version 9.5.0 #


  Implemented support for calculations with percentage, see #2303.
Thanks @rvramesh.
  Fix #2319: make the API of Parser.evaluate consistent with math.evaluate:
support a list with expressions as input.
  Improved documentation of function setCartesian. Thanks @fieldfoxWim.


2021-09-15, version 9.4.5 #


  Improved the performance of Node.equals by improving the internal
function deepStrictEqual. Thanks @tomlarkworthy.
  Fixes in the TypeScript definitions:
    
      Define hasNumericValue. Thanks @write2kcl.
      Define MathNode.isRelationalNode. Thanks @m93a.
      Fix typo in MathNode.isConditionalNode. Thanks @m93a.
    
  


2021-07-07, version 9.4.4 #


  Fixed ArrayNode.toTex(): remove the row delimiter on the last row,
see #2267. Thanks @davidtranhq.
  Fix #2269: intersect  not returning null for matrix input. Thanks @m93a.
  Fix #2245: mathjs not working in IE11 anymore due to a missing polyfill for
Symbol. The browser bundle now includes the necessary polyfills (it is
larger now because of that, see also #2266). Thanks @m93a.
  Update dependencies (complex.js@2.0.15, decimal.js@10.3.1)
  Drop official support for node.js 10, which has reached end of life.
See #2258.


2021-06-23, version 9.4.3 #


  Fix #2222: mathjs polluting the Decimal prototype. Thanks @m93a.
  Fix #2253: expression parser throwing an error when accessing nested object
properties named e.
  Fixes in the TypeScript definitions:
    
      function floor, #2159, #2246. Thanks @write2kcl.
      function simplify, see #2252. Thanks @nitroin.
    
  
  Upgraded to decimal.js@10.3.0


2021-06-05, version 9.4.2 #


  Implemented iterative eigenvalue finder for eigs, making it much more
robust. See #2179, #2237. Thanks @m93a.
  Improved TypeScript definitions of function parse. Thanks @OpportunityLiu.


2021-05-24, version 9.4.1 #


  Fix #2100: add TypeScript declaration for eigs. Thanks @andrebianchessi.
  Fix #2220: add TypeScript files to published npm package. Thanks @dhritzkiv.
  Update readme regarding TypeScript definition files. Thanks @dhritzkiv.
  Update to fraction.js@4.1.1


2021-05-16, version 9.4.0 #


  Implemented support to use objects with a Map interface as scope,
see #2143, #2166. Thanks @jhugman.
  Extend eigs to support general complex matrices, see #1741. Thanks @m93a.
  DenseMatrix and SparseMatrix are now iterable, see #1184. Thanks @m93a.
  Implemented utility functions matrixFromRows, matrixFromColumns, and
matrixFromFunction, see #2155, #2153. Thanks @m93a.
  Added TypeScript definitions to the project, making it redundant to install
@types/mathjs, and making it easier to improve the definitions. See #2187,
#2192. Thanks @CatsMiaow.
  Upgraded dependencies
    
      complex.js@2.0.13 (fixing #2211). Thanks @infusion
      fraction.js@4.1.0 (pow now supporting rational exponents).
    
  
  Fix #2174: function pickRandom having no name. Thanks @HK-SHAO.
  Fix #2019: VSCode auto import keeps adding import { null } from ‘mathjs’.
  Fix #2185: Fix TypeScript definition of unit division, which can also return
a number.
  Fix #2123: add type definitions for functions row and column.
  Fix some files not exposed in the package, see #2213. Thanks @javiermarinros.


2021-04-12, version 9.3.2 #


  Fix #2169: mathjs requesting @babel/runtime dependency.
Regression introduced in v9.3.1.


2021-04-10, version 9.3.1 #


  Fix #2133: strongly improved the performance of isPrime, see #2139.
Thanks @Yaffle.
  Fix #2150: give a clear error “Error: Undefined function …” instead when
evaluating a non-existing function.
  Fix #660: expose internal functions FunctionNode.onUndefinedFunction(name)
and SymbolNode.onUndefinedSymbol(name), allowing to override the behavior.
By default, an Error is thrown.


2021-03-10, version 9.3.0 #


  Implemented support for parsing non decimal numbers with radix point,
see #2122, #2121. Thanks @clnhlzmn.
  Fix #2128: typo in docs of luSolveAll and usolveAll.


2021-02-03, version 9.2.0 #


  Implemented function count to count the total elements in a matrix,
see #2085. Thanks @Josef37.
  Fix #2096: cleanup old reference to external dependency crypto.
  Some refactoring in the code to remove duplications, see #2093.
Thanks @Josef37.


2021-01-27, version 9.1.0 #


  Extended function reshape with support for a wildcard -1 to automatically
calculate the remaining size, like reshape([1, 2, 3, 4, 5, 6], [-1, 2])
which will output [[0, 1], [2, 3], [4, 5]]. See #2075. Thanks @Josef37.
  Fix #2087: function simplify ignores second argument of log, for example
in simplify('log(e, 9)') . Thanks @quentintruong.


2021-01-16, version 9.0.0 #


  Improved support for bin, hex, and oct literals. See #1996. Thanks @clnhlzmn.
    
      Breaking change: parse literals with prefixes 0b, 0c, and 0x are
now unsigned by default. To parse them as signed, you have to specify a
suffix specifying the word size such as i16 or i32.
      Function format now supports more notations: bin, ‘hex’, and oct,
for example format(255, {notation: "hex"}).
      The functions format, bin, hex, oct now allow specifying a wordSize,
like bin(10, 32) and format(10, {notation: "bin", wordSize: 32}).
      BigNumber support for the bin, hex, and oct literals.
    
  
  Extended and improved the example rocket_trajectory_optimization.html.
Thanks @Josef37.


2020-12-30, version 8.1.1 #


  Improved the performance of parsing and evaluating units a lot, see #2065.
Thanks @flaviut.
  Upgraded dependency fraction.js to v4.0.13.
  Moved continuous integration testing from Travis CI to Github Workflow,
see #2024, #2041. Thanks @harrysarson.


2020-12-04, version 8.1.0 #


  Implemented units kilogramforce (kgf). Thanks @rnd-debug.
  Fix #2026: Implement a new option fractionsLimit for function simplify,
defaulting to Infinity.
  Improved the documentation of function clone. Thanks @redbar0n.


2020-11-09, version 8.0.1 #


  Fix #1979: missing “subset” dependency when using “mathjs/number” entry point.
  Fix #2022: update pretty printing with MathJax example to the latest version
of MathJax. Thanks @pkra.


2020-11-06, version 8.0.0 #

!!! BE CAREFUL: BREAKING CHANGES !!!


  You can now use mathjs directly in node.js using ES modules without need for
a transpiler (see #1928, #1941, #1962).
Automatically loading either commonjs code or ES modules code is improved.
All generated code is moved under /lib: the browser bundle is moved from
/dist to /lib/browser, ES module files are moved to /lib/esm,
and commonjs files are moved to /lib/cjs. Thanks @GreenImp.
  Non-minified bundle dist/math.js is no longer provided. Either use the
minified bundle, or create a bundle yourself.
  Replaced random library seed-random with seedrandom, see #1955.
Thanks @poppinlp.
  Breaking changes in pickRandom, see #1990, #1976.
    
      Will no longer return the input matrix when the given number is greater
than the length of the provided possibles. Instead, the function always
returns results with the requested number of picks.
      Will now return a Matrix as output when input was a Matrix.
      
        Introduced a new syntax:

        math.pickRandom(array, { weights, number, elementWise })
        
      
      Introduced a new option elementWise, which is true by default.
When setting elementWise to false, an array containing arrays will return
random pick of arrays instead of the elements inside of the nested arrays.
    
  


2020-11-02, version 7.6.0 #


  Implemented function rotate(w, theta). See #1992, #1160. Thanks @rnd-debug.
  Implemented support for custom characters in Units via Unit.isValidAlpha.
See #1663, #2000. Thanks @rnd-debug.


2020-10-10, version 7.5.1 #


  Fix object pollution vulnerability in math.config. Thanks Snyk.


2020-10-07, version 7.5.0 #


  Function pickRandom now allows randomly picking elements from matrices
with 2 or more dimensions instead of only from a vector, see #1974.
Thanks @KonradLinkowski.


2020-10-07, version 7.4.0 #


  Implemented support for passing a precision in functions ceil, floor,
and fix, similar to round, see #1967, #1901. Thanks @rnd-debug.
  Implemented function rotationMatrix, see #1160, #1984. Thanks @rnd-debug.
  Implement a clear error message when using sqrtm with a matrix having
more than two dimensions. Thanks @KonradLinkowski.
  Update dependency decimal.js to 10.2.1.


2020-09-26, version 7.3.0 #


  Implemented functions usolveAll and lsolveAll, see #1916. Thanks @m93a.
  Implemented support for units in functions std and variance, see #1950.
Thanks @rnd-debug.
  Implemented support for binary, octal, and hexadecimal notation in the
expression parser, and implemented functions bin, oct, and hex for
formatting. Thanks @clnhlzmn.
  Fix #1964: inconsistent calculation of negative dividend modulo for
BigNumber and Fraction. Thanks @ovk.


2020-08-24, version 7.2.0 #


  Implemented new function diff, see #1634, #1920. Thanks @Veeloxfire.
  Implemented support for norm 2 for matrices in function norm.
Thanks @rnd-debug.


2020-07-13, version 7.1.0 #


  Implement support for recursion (self-referencing) of typed-functions,
new in typed-function@2.0.0. This fixes #1885: functions which where
extended with a new data type did not always work. Thanks @nickewing.
  Fix #1899: documentation on expression trees still using old namespace
math.expression.node.* instead of math.*.


2020-06-24, version 7.0.2 #


  Fix #1882: have DenseMatrix.resize and SparseMatrix.resize accept
DenseMatrix and SparseMatrix as inputs too, not only Array.
  Fix functions sum, prod, min, and max not throwing a conversion error
when passing a single string, like sum("abc").


2020-05-30, version 7.0.1 #


  Fix #1844: clarify the documentation of function eigs. Thanks @Lazersmoke.
  Fix #1855: Fix error in the documentation for math.nthRoots(x).
  Fix #1856: make the library robust against Object prototype pollution.


2020-05-07, version 7.0.0 #

Breaking changes:


  Improvements in calculation of the dot product of complex values.
The first argument is now conjugated. See #1761. Thanks @m93a.
  Dropped official support for Node.js v8 which has reached end of life.
  Removed all deprecation warnings introduced in v6.
To upgrade smoothly from v5 to v7 or higher, upgrade to v6 first
and resolve all deprecation warnings.


2020-05-04, version 6.6.5 #


  Fix #1834: value Infinity cannot be serialized and deserialized.
This is solved now with a new math.replacer function used as
JSON.stringify(value, math.replacer).
  Fix #1842: value Infinity not turned into the latex symbol \\infty.


2020-04-15, version 6.6.4 #


  Fix published files containing Windows line endings (CRLF instead of LF).


2020-04-10, version 6.6.3 #


  Fix #1813: bug in engineering notation for numbers of function format,
sometimes resulting in needless trailing zeros.
  Fix #1808: methods .toNumber() and .toNumeric() not working on a
unitless unit.
  Fix #1645: not being able to use named operators mod, and, not, or,
xor, to, in as object keys. Thanks @Veeloxfire.
  Fix eigs not using config.epsilon.


2020-03-29, version 6.6.2 #


  Fix #1789: Function eigs not calculating with BigNumber precision
when input contains BigNumbers.
  Run the build script during npm prepare, so you can use the library
directly when installing directly from git. See #1751. Thanks @cinderblock.


2020-02-26, version 6.6.1 #


  Fix #1725: simplify a/(b/c). Thanks @dbramwell.
  Fix examples in documentation of row and column.


2020-02-01, version 6.6.0 #


  Implemented function eigs, see #1705, #542 #1175. Thanks @arkajitmandal.
  Fixed #1727: validate matrix size when creating a DenseMatrix using
fromJSON.
  Fixed DenseMatrix.map copying the size and datatype from the original
matrix instead of checking the returned dimensions and type of the callback.
  Add a caret to dependencies (like) ^1.2.3) to allow downstream updates
without having to await a new release of mathjs.


2020-01-08, version 6.5.0 #


  Implemented baseName option for createUnit, see #1707.
Thanks @ericman314.


2020-01-06, version 6.4.0 #


  Extended function dimension with support for n-dimensional points.
Thanks @Veeloxfire.


2019-12-31, version 6.3.0 #


  Improved performance of factorial for BigNumber up to a factor two,
see #1687. Thanks @kmdrGroch.


2019-11-20, version 6.2.5 #


  Fixed IndexNode using a hardcoded, one-based implementation of index,
making it impossible to instantiate a zero-based version of the expression
parser. See #782.


2019-11-20, version 6.2.4 #


  Fixed #1669: function ‘qr’ threw an error if the pivot was zero,
thanks @kevinkelleher12 and @harrysarson.
  Resolves #942: remove misleading assert in ‘qr’. Thanks @harrysarson.
  Work around a bug in complex.js where sign(0) returns complex NaN.
Thanks @harrysarson.


2019-10-06, version 6.2.3 #


  Fixed #1640: function mean not working for units. Thanks @clintonc.
  Fixed #1639: function min listed twice in the “See also” section of the
embedded docs of function std.
  Improved performance of isPrime, see #1641. Thanks @arguiot.


2019-09-23, version 6.2.2 #


  Fixed methods map and clone not copying the dotNotation property of
IndexNode. Thanks @rianmcguire.
  Fixed a typo in the documentation of toHTML. Thanks @maytanthegeek.
  Fixed #1615: error in the docs of isNumeric.
  Fixed #1628: Cannot call methods on empty strings or numbers with value 0.


2019-08-31, version 6.2.1 #


  Fixed #1606: function format not working for expressions.


2019-08-28, version 6.2.0 #


  Improved performance of combinationsWithRep. Thanks @waseemyusuf.
  Add unit aliases bit and byte.
  Fix docs referring to bit and byte instead of bits and bytes.
  Updated dependency typed-function@1.1.1.


2019-08-17, version 6.1.0 #


  Implemented function combinationsWithRep (see #1329). Thanks @waseemyusuf.


2019-08-05, version 6.0.4 #


  Fixed #1554, #1565: ES Modules where not transpiled to ES5, giving issues on
old browsers. Thanks @mockdeep for helping to find a solution.


2019-07-07, version 6.0.3 #


  Add unpkg and jsdelivr fields in package.json pointing to UMD build.
Thanks @tmcw.
  Fix #1550: nested user defined function not receiving variables of an
outer user defined function.


2019-06-11, version 6.0.2 #


  Fix not being able to set configuration after disabling function import
(regression since v6.0.0).


2019-06-09, version 6.0.1 #


  Fix function reference not published in npm library.
  Fix function evaluate and parse missing in generated docs.


2019-06-08, version 6.0.0 #

!!! BE CAREFUL: BREAKING CHANGES !!!

Most notable changes #


  
    Full support for ES modules. Support for tree-shaking out of the box.

    Load all functions:

     import * as math from 'mathjs'
    

    Use a few functions:

     import { add, multiply } from 'mathjs'
    

    Load all functions with custom configuration:

     import { create, all } from 'mathjs'
 const config = { number: 'BigNumber' }
 const math = create(all, config)
    

    Load a few functions with custom configuration:

     import { create, addDependencies, multiplyDependencies } from 'mathjs'
 const config = { number: 'BigNumber' }
 const { add, multiply } = create({
   addDependencies,
   multiplyDependencies
 }, config)
    
  
  
    Support for lightweight, number-only implementations of all functions:

     import { add, multiply } from 'mathjs/number'
    
  
  
    New dependency injection solution used under the hood.
  


Breaking changes #


  
    Node 6 is no longer supported.
  
  
    Functions config and import are not available anymore in the global
context:

    // v5
import * as mathjs from 'mathjs'
mathjs.config(...) // error in v6.0.0
mathjs.import(...) // error in v6.0.0
    

    Instead, create your own mathjs instance and pass config and imports
there:

    // v6
import { create, all } from 'mathjs'
const config = { number: 'BigNumber' }
const mathjs = create(all, config)
mathjs.import(...)
    
  
  Renamed function typeof to typeOf, var to variance,
and eval to evaluate. (the old function names are reserved keywords
which can not be used as a variable name).
  Deprecated the Matrix.storage function. Use math.matrix instead to create
a matrix.
  Deprecated function math.expression.parse, use math.parse instead.
Was used before for example to customize supported characters by replacing
math.parse.isAlpha.
  Moved all classes like math.type.Unit and math.expression.Parser to
math.Unit and math.Parser respectively.
  Fixed #1428: transform iterating over replaced nodes. New behavior
is that it stops iterating when a node is replaced.
  Dropped support for renaming factory functions when importing them.
  Dropped fake BigNumber support of function erf.
  
    Removed all index.js files used to load specific functions instead of all, like:

    // v5
// ... set up empty instance of mathjs, then load a set of functions:
math.import(require('mathjs/lib/function/arithmetic'))
    

    Individual functions are now loaded simply like:

    // v6
import { add, multiply } from 'mathjs'
    

    To set a specific configuration on the functions:

    // v6
import { create, addDependencies, multiplyDependencies } from 'mathjs'
const config = { number: 'BigNumber' }
const math = create({ addDependencies, multiplyDependencies }, config)
    

    See example advanced/custom_loading.js.
  
  Updated the values of all physical units to their latest official values.
See #1529. Thanks @ericman314.


Non breaking changes #


  Implemented units t, tonne, bel, decibel, dB, and prefixes
for candela. Thanks @mcvladthegoat.
  Fixed epsilon setting being applied globally to Complex numbers.
  Fix math.simplify('add(2, 3)') throwing an error.
  Fix #1530: number formatting first applied lowerExp and upperExp
and after that rounded the value instead of the other way around.
  Fix #1473: remove 'use strict' in every file, not needed anymore.


2019-05-18, version 5.10.3 #


  Fixed dependency del being a dependency instead of devDependency.


2019-05-18, version 5.10.2 #


  Fix #1515, #1516, #1517: broken package due to a naming conflict in
the build folder of a util file typeOf.js and typeof.js.
Solved by properly cleaning all build folders before building.


2019-05-17, version 5.10.1 #


  Fix #1512: format using notation engineering can give wrong results
when the value has less significant digits than the number of digits in
the output.


2019-05-08, version 5.10.0 #


  Fix lib/header.js not having filled in date and version. Thanks @kevjin.
  Upgraded dependency decimal.js@10.2.0, fixing an issue on node.js 12.


2019-04-08, version 5.9.0 #


  Implemented functions row and column (see #1413). Thanks @SzechuanSage.
  Fixed #1459: engineering notation of function format not available
for BigNumber.
  Fixed #1465: node.toHTML() not correct for unary operators like
factorial.


2019-03-20, version 5.8.0 #


  Implemented new function apply. Thanks @bnlcas.
  Implemented passing an optional dimension argument to std and var.
Thanks @bnlcas.


2019-03-10, version 5.7.0 #


  Implemented support for pow() in derivative. Thanks @sam-19.
  Gracefully handle round-off errors in fix, ceil, floor, and range
(Fixes #1429, see also #1434, #1432). Thanks @ericman314.


2019-03-02, version 5.6.0 #


  Upgrade decimal.js to v10.1.1 (#1421).
  Fixed #1418: missing whitespace when stringifying an expression
containing “not”.


2019-02-20, version 5.5.0 #


  Fixed #1401: methods map and forEach of SparseMatrix not working
correctly when indexes are unordered.
  Fixed #1404: inconsistent rounding of negative numbers.
  Upgrade tiny-emitter to v2.1.0 (#1397).


2019-01-25, version 5.4.2 #


  Fixed math.format not working for BigNumbers with a precision above
1025 digits (see #1385). Thanks @ericman314.
  Fixed incorrect LaTeX output of RelationalNode. Thanks @rianmcguire.
  Fixed a bug the methods map, forEach, traverse, and transform
of FunctionNode.


2019-01-10, version 5.4.1 #


  Fix #1378: negative bignumbers not formatted correctly.
  Upgrade fraction.js to version 4.0.12 (#1369).


2018-12-09, version 5.4.0 #


  Extended sum.js to accept a dimension input to calculate the sum over a
specific axis. Thanks @bnlcas.
  Fix #1328: objects can’t be written multi-line. Thanks @GHolk.
  Remove side effects caused by Unit.format and Unit.toString,
making changes to the unit on execution. Thanks @ericman314.


2018-12-03, version 5.3.1 #


  Fixed #1336: Unit.toSI() returning units with prefix like mm instead
of m. Thanks @ericman314.


2018-11-29, version 5.3.0 #


  Implemented function hasNumericValue. Thanks @Sathish-kumar-Subramani.
  Fix #1326: non-ascii character in print.js.
  Fix #1337: math.format not working correctly with { precision: 0 }.
Thanks @dkenul.


2018-10-30, version 5.2.3 #


  Fixed #1293: non-unicode characters in escape-latex giving issues in some
specific cases. Thanks @dangmai.
  Fixed incorrect LaTeX output of function bitNot, see #1299. Thanks @FSMaxB.
  Fixed #1304: function pow not supporting inputs pow(Unit, BigNumber).
  Upgraded dependencies (escape-latex@1.2.0)


2018-10-23, version 5.2.2 #


  Fixed #1286: Fixed unit base recognition and formatting for
user-defined units. Thanks @ericman314.


2018-10-18, version 5.2.1 #


  Fixed unit rod being defined as 5.02921 instead of 5.0292.
Thanks @ericman314.
  Upgraded dependencies (fraction.js@4.0.10)
  Upgraded devDependencies (@babel/core@7.1.2, nyc@13.1.0,
webpack@4.21.0).


2018-10-05, version 5.2.0 #


  Implemented support for chained conditionals like 10 < x <= 50.
Thanks @ericman314.
  Add an example showing a proof of concept of using BigInt in mathjs.
  Fixed #1269: Bugfix for BigNumber divided by unit. Thanks @ericman314.
  Fixed #1240: allow units having just a value and no unit.
Thanks @ericman314.


2018-09-09, version 5.1.2 #


  Fixed a typo in the docs of parse. Thanks @mathiasvr.
  Fixed #1222: a typo in the docs of subset.
  Fixed #1236: quantileSeq has inconsistent return.
  Fixed #1237: norm sometimes returning a complex number instead of
number.
  Upgraded dependencies (fraction.js@4.0.9)
  Upgraded devDependencies (babel@7, karma-webpack@3.0.4,
nyc@13.0.1, standard@12.0.0, uglify-js@3.4.9, webpack@4.17.2)


2018-08-21, version 5.1.1 #


  Function isNumeric now recognizes more types.
  Fixed #1214: functions sqrt, max, min, var, std, mode, mad,
median, and partitionSelect not neatly handling NaN inputs. In some
cases (median, mad, and partitionSelect) this resulted in an infinite
loop.
  Upgraded dependencies (escape-latex@1.1.1)
  Upgraded devDependencies (webpack@4.17.0)


2018-08-12, version 5.1.0 #


  Implemented support for strings enclosed in single quotes.
Thanks @jean-emmanuel.
  Implemented function getMatrixDataType. Thanks @JasonShin.
  Implemented new options argument in simplify. Thanks @paulobuchsbaum.
  Bug fixes in rationalize, see #1173. Thanks @paulobuchsbaum.


2018-07-22, version 5.0.4 #


  Strongly improved the performance of functions factorial for numbers.
This improves performance of functions gamma, permutation, and
combination too. See #1170. Thanks @honeybar.
  Strongly improved the performance of function reshape, thanks to a
friend of @honeybar.


2018-07-14, version 5.0.3 #


  Fixed many functions (for example add and subtract) not working
with matrices having a datatype defined.
  Fixed #1147: bug in format with engineering notation in outputting
the correct number of significant figures. Thanks @ericman314.
  Fixed #1162: transform functions not being cleaned up when overriding
it by importing a factory function with the same name.
  Fixed broken links in the documentation. Thanks @stropitek.
  Refactored the code of parse into a functional approach.
Thanks @harrysarson.
  Changed decimal.js import to ES6. Thanks @weinshel.


2018-07-07, version 5.0.2 #


  Fixed #1136: rocket trajectory example broken (since v4.0.0).
  Fixed #1137: simplify unnecessarily replacing implicit multiplication with
explicit multiplication.
  Fixed #1146: rationalize throwing exceptions for some input with decimals.
Thanks @maruta.
  Fixed #1088: function arguments not being passed to rawArgs functions.
  Fixed advanced example add_new_datatypes.
  Fixed mathjs core constants not working without complex numbers.
Thanks @ChristopherChudzicki.
  Fixed a broken link in the documentation on units. Thanks @stropitek.
  Upgraded dependencies (typed-function@1.0.4, complex.js@2.0.11).
  Upgraded devDependencies (babel-loader@7.1.5, uglify-js@3.4.3,
expr-eval@1.2.2, webpack@4.15.1).


2018-07-01, version 5.0.1 #


  Improved error messaging when converting units. Thanks @gap777.
  Upgraded devDependencies (kerma, uglify-js, webpack).


2018-06-16, version 5.0.0 #

!!! BE CAREFUL: BREAKING CHANGES !!!


  Implemented complex conjugate transpose math.ctranspose. See #1097.
Thanks @jackschmidt.
  Changed the behavior of A' (transpose) in the expression parser to
calculate the complex conjugate transpose. See #1097. Thanks @jackschmidt.
  Added support for complex({abs: 1, arg: 1}), and improved the docs on
complex numbers. Thanks @ssaket.
  Renamed eye to identity, see #1054.
  Math.js code can now contain ES6. The ES6 source code is moved from lib
to src, and lib now contains the compiled ES5 code.
  Upgraded dependencies:
    
      decimal.js from 9.0.1 to 10.0.1
      Upgraded dev dependencies
    
  
  Changed code style to https://standardjs.com/, run linter on npm test.
See #1110.
  Dropped support for bower. Use npm or an other package manages instead.
  Dropped support for (non-primitive) instances of Number, Boolean, and
String from functions clone and typeof.
  Dropped official support for IE9 (probably still works, but it’s not tested).
  Fixed #851: More consistent behavior of sqrt, nthRoot, and pow.
Thanks @dakotablair.
  Fixed #1103: Calling toTex on node that contains derivative causing
an exception. Thanks @joelhoover.


2018-06-02, version 4.4.2 #


  Drastically improved the performance of det. Thanks @ericman314.
  Fixed #1065, #1121: Fixed wrong documentation of function
compareNatural and clarified the behavior for strings.
  Fixed #1122 a regression in function inv (since v4.4.1).
Thanks @ericman314.


2018-05-29, version 4.4.1 #


  Fixed #1109: a bug in inv when dealing with values close to zero.
Thanks @ericman314.


2018-05-28, version 4.4.0 #


  Implemented functions equalText and compareText. See #1085.


2018-05-21, version 4.3.0 #


  Implemented matrix exponential math.expm. Thanks @ericman314.
  Fixed #1101: math.js bundle not working when loading in a WebWorker.
  Upgraded dependencies
    
      complex.js from v2.0.2 to v2.0.10.
      fraction.js from v4.0.4 to v4.0.8.
    
  
  Upgraded devDependencies (mocha, uglify-js, webpack).


2018-05-05, version 4.2.2 #


  Fixed calculating the Frobenius norm of complex matrices correctly,
see #1098. Thanks @jackschmidt.
  Fixed #1076: cannot use mathjs in React VR by updating to
escape-latex@1.0.3.


2018-05-02, version 4.2.1 #


  Fixed dist/math.js being minified.


2018-05-02, version 4.2.0 #


  Implemented function math.sqrtm. Thanks @ferrolho.
  Implemented functions math.log2, math.log1p, and math.expm1.
Thanks @BigFav and @harrysarson.
  Fixed some unit tests broken on nodejs v10.
  Upgraded development dependencies.
  Dropped integration testing on nodejs v4.


2018-04-18, version 4.1.2 #


  Fixed #1082: implemented support for unit plurals decades, centuries,
and millennia.
  Fixed #1083: units decade and watt having a wrong name when stringifying.
Thanks @ericman314.


2018-04-11, version 4.1.1 #


  Fixed #1063: derivative not working when resolving a variable with unary
minus like math.derivative('-x', 'x').


2018-04-08, version 4.1.0 #


  Extended function math.print with support for arrays and matrices.
Thanks @jean-emmanuel.
  Fixed #1077: Serialization/deserialization to JSON with reviver not being
supported by nodes.
  Fixed #1016: Extended math.typeof with support for ResultSet and nodes
like SymbolNode.
  Fixed #1072: Added support for long and short prefixes for the unit bar
(i.e. millibar and mbar).


2018-03-17, version 4.0.1 #


  Fixed #1062: mathjs not working on ES5 browsers like IE11 and Safari 9.3.
  Fixed #1061: math.unit not accepting input like 1/s.


2018-02-25, version 4.0.0 #

!!! BE CAREFUL: BREAKING CHANGES !!!

Breaking changes (see also #682):


  
    New expression compiler

    The compiler of the expression parser is replaced with one that doesn’t use
  eval internally. See #1019. This means:

    
      a slightly improved performance on most browsers.
      less risk of security exploits.
      
        the code of the new compiler is easier to understand, maintain, and debug.

        Breaking change here: When using custom nodes in the expression parser,
the syntax of _compile has changed. This is an undocumented feature though.
      
    
  
  
    Parsed expressions

    
      
        The class ConstantNode is changed such that it just holds a value
  instead of holding a stringified value and it’s type.
  ConstantNode(valueStr, valueType) is now ConstantNode(value)
  Stringification uses math.format, which may result in differently
  formatted numeric output.
      
      
        The constants true, false, null, undefined, NaN, Infinity,
  and uninitialized are now parsed as ConstantNodes instead of
  SymbolNodes in the expression parser. See #833.
      
    
  
  
    Implicit multiplication

    
      
        Changed the behavior of implicit multiplication to have higher
  precedence than explicit multiplication and division, except in
  a number of specific cases. This gives a more natural behavior
  for implicit multiplications. For example 24h / 6h now returns 4,
  whilst 1/2 kg evaluates to 0.5 kg. Thanks @ericman314. See: #792.
  Detailed documentation: https://github.com/josdejong/mathjs/blob/v4/docs/expressions/syntax.md#implicit-multiplication.
      
      
        Immediately invoking a function returned by a function like partialAdd(2)(3)
  is no longer supported, instead these expressions are evaluated as
  an implicit multiplication partialAdd(2) * (3). See #1035.
      
    
  
  
    String formatting

    
      
        In function math.format, the options {exponential: {lower: number, upper: number}}
  (where lower and upper are values) are replaced with {lowerExp: number, upperExp: number}
  (where lowerExp and upperExp are exponents). See #676. For example:

          math.format(2000, {exponential: {lower: 1e-2, upper: 1e2}})
        

        is now:

          math.format(2000, {lowerExp: -2, upperExp: 2})
        
      
      
        In function math.format, the option notation: 'fixed' no longer rounds to
  zero digits  when no precision is specified: it leaves the digits as is.
  See #676.
      
    
  
  
    String comparison

    Changed the behavior of relational functions (compare, equal,
  equalScalar, larger, largerEq, smaller, smallerEq, unequal)
  to compare strings by their numeric value they contain instead of
  alphabetically. This also impacts functions deepEqual, sort, min,
  max, median, and partitionSelect. Use compareNatural if you
  need to sort an array with text. See #680.
  
  
    Angle units

    Changed rad, deg, and grad to have short prefixes,
  and introduced radian, degree, and gradian and their plurals
  having long prefixes. See #749.
  
  
    Null

    
      
        null is no longer implicitly casted to a number 0, so input like
  math.add(2, null) is no longer supported. See #830, #353.
      
      
        Dropped constant uninitialized, which was used to initialize
  leave new entries undefined when resizing a matrix is removed.
  Use undefined instead to indicate entries that are not explicitly
  set. See #833.
      
    
  
  
    New typed-function library

    
      The typed-function library used to check the input types
  of functions is completely rewritten and doesn’t use eval under
  the hood anymore. This means a reduced security risk, and easier
  to debug code. The API is the same, but error messages may differ
  a bit. Performance is comparable but may differ in specific
  use cases and browsers.
    
  


Non breaking changes:


  Thanks to the new expression compiler and typed-function implementation,
mathjs doesn’t use JavaScript’s eval anymore under the hood.
This allows using mathjs in environments with security restrictions.
See #401.
  Implemented additional methods isUnary() and isBinary() on
OperatorNode. See #1025.
  Improved error messages for statistical functions.
  Upgraded devDependencies.
  Fixed #1014: derivative silently dropping additional arguments
from operator nodes with more than two arguments.


2018-02-07, version 3.20.2 #


  Upgraded to typed-function@0.10.7 (bug-fix release).
  Fixed option implicit not being copied from an OperatorNode
when applying function map. Thanks @HarrySarson.
  Fixed #995: spaces and underscores not property being escaped
in toTex(). Thanks @FSMaxB.


2018-01-17, version 3.20.1 #


  Fixed #1018: simplifyCore failing in some cases with parentheses.
Thanks @firepick1.


2018-01-14, version 3.20.0 #


  Implement support for 3 or more arguments for operators + and * in
derivative. Thanks @HarrySarson. See #1002.
  Fixed simplify evalution of simplify of functions with more than two
arguments wrongly: simplify('f(x, y, z)') evaluated tof(f(x, y), z)
instead of f(x, y, z)`. Thanks @joelhoover.
  Fixed simplify throwing an error in some cases when simplifying unknown
functions, for example simplify('f(4)'). Thanks @joelhoover.
  Fixed #1013: simplify wrongly simplifing some expressions containing unary
minus, like 0 - -x. Thanks @joelhoover.
  Fixed an error in an example in the documentation of xor. Thanks @denisx.


2018-01-06, version 3.19.0 #


  Extended functions distance and intersect with support for BigNumbers.
Thanks @ovk.
  Improvements in function simplify: added a rule that allows combining
of like terms in embedded quantities. Thanks @joelhoover.


2017-12-28, version 3.18.1 #


  Fixed #998: An issue with simplifying an expression containing a subtraction.
Thanks @firepick1.


2017-12-16, version 3.18.0 #


  Implemented function rationalize. Thanks @paulobuchsbaum.
  
    Upgraded dependencies:

    decimal.js    7.2.3  →  9.0.1 (no breaking changes affecting mathjs)
fraction.js   4.0.2  →  4.0.4
tiny-emitter  2.0.0  →  2.0.2
    
  
  Upgraded dev dependencies.
  Fixed #975: a wrong example in the docs of lusolve.
  Fixed #983: pickRandom returning an array instead of single value
when input was an array with just one value. Clarified docs.
  Fixed #969: preven issues with yarn autoclean by renaming an
interally used folder “docs” to “embeddedDocs”.


2017-11-18, version 3.17.0 #


  Improved simplify for nested exponentiations. Thanks @IvanVergiliev.
  Fixed a security issue in typed-function allowing arbitrary code execution
in the JavaScript engine by creating a typed function with JavaScript code
in the name. Thanks Masato Kinugawa.
  Fixed a security issue where forbidden properties like constructor could be
replaced by using unicode characters when creating an object. No known exploit,
but could possibly allow arbitrary code execution. Thanks Masato Kinugawa.


2017-10-18, version 3.16.5 #


  Fixed #954: Functions add and multiply not working when
passing three or more arrays or matrices.


2017-10-01, version 3.16.4 #


  Fixed #948, #949: function simplify returning wrong results or
running into an infinite recursive loop. Thanks @ericman314.
  Fixed many small issues in the embedded docs.  Thanks @Schnark.


2017-08-28, version 3.16.3 #


  Fixed #934: Wrong simplification of unary minus. Thanks @firepick1.
  Fixed #933: function simplify reordering operations. Thanks @firepick1.
  Fixed #930: function isNaN returning wrong result for complex
numbers having just one of their parts (re/im) being NaN.
  Fixed #929: FibonacciHeap.isEmpty returning wrong result.


2017-08-20, version 3.16.2 #


  Fixed #924: a regression in simplify not accepting the signature
simplify(expr, rules, scope) anymore. Thanks @firepick1.
  Fixed missing parenthesis when stringifying expressions containing
implicit multiplications (see #922). Thanks @FSMaxB.


2017-08-12, version 3.16.1 #


  For security reasons, type checking is now done in a more strict
way using functions like isComplex(x) instead of duck type checking
like x && x.isComplex === true.
  Fixed #915: No access to property “name”.
  Fixed #901: Simplify units when calling unit.toNumeric().
Thanks @AlexanderBeyn.
  Fixed toString of a parsed expression tree containing an
immediately invoked function assignment not being wrapped in
parenthesis (for example (f(x) = x^2)(4)).


2017-08-06, version 3.16.0 #


  Significant performance improvements in math.simplify.
Thanks @firepick1.
  Improved API for math.simplify, optionally pass a scope with
variables which are resolved, see #907. Thanks @firepick1.
  Fixed #912: math.js didn’t work on IE10 anymore (regression
since 3.15.0).


2017-07-29, version 3.15.0 #


  Added support for the dollar character $ in symbol names (see #895).
  Allow objects with prototypes as scope again in the expression parser,
this was disabled for security reasons some time ago. See #888, #899.
Thanks @ThomasBrierley.
  Fixed #846: Issues in the functions map, forEach, and filter
when used in the expression parser:
    
      Not being able to use a function assignment as inline expression
for the callback function.
      Not being able to pass an inline expression as callback for map
and forEach.
      Index and original array/matrix not passed in map and filter.
    
  


2017-07-05, version 3.14.2 #


  Upgraded to fraction.js@4.0.2
  Fixed #891 using BigNumbers not working in browser environments.


2017-06-30, version 3.14.1 #


  Reverted to fraction.js@4.0.0, there is an issue with 4.0.1
in the browser.


2017-06-30, version 3.14.0 #


  Implemented set methods setCartesian, setDifference,
setDistinct, setIntersect, setIsSubset, setPowerset,
setSize. Thanks @Nekomajin42.
  Implemented method toHTML on nodes. Thanks @Nekomajin42.
  Implemented compareNatural and sort([...], 'natural').
  Upgraded dependencies to the latest versions:
    
      complex.js@2.0.4
      decimal.js@7.2.3
      fraction.js@4.0.1
      tiny-emitter@2.0.0
      And all devDependencies.
    
  
  Fixed #865: splitUnit can now deal with round-off errors.
Thanks @ericman314.
  Fixed #876: incorrect definition for unit erg. Thanks @pjhampton.
  More informative error message when using single quotes instead of
double quotes around a string. Thanks @HarrySarson.


2017-05-27, version 3.13.3 #


  Fixed a bug in function intersection of line and plane.
Thanks @viclai.
  Fixed security vulnerabilities.


2017-05-26, version 3.13.2 #


  Disabled function chain inside the expression parser for security
reasons (it’s not needed there anyway).
  Fixed #856: function subset not returning non-primitive scalars
from Arrays correctly. (like math.eval('arr[1]', {arr: [math.bignumber(2)]}).
  Fixed #861: physical constants not available in the expression parser.


2017-05-12, version 3.13.1 #


  Fixed creating units with an alias not working within the expression
parser.
  Fixed security vulnerabilities. Thanks Sam.


2017-05-12, version 3.13.0 #


  Command line application can now evaluate inline expressions
like mathjs 1+2. Thanks @slavaGanzin.
  Function derivative now supports abs. Thanks @tetslee.
  Function simplify now supports BigNumbers. Thanks @tetslee.
  Prevent against endless loops in simplify. Thanks @tetslee.
  Fixed #813: function simplify converting small numbers to inexact
Fractions. Thanks @tetslee.
  Fixed #838: Function simplify now supports constants like e.
Thanks @tetslee.


2017-05-05, version 3.12.3 #


  Fixed security vulnerabilities. Thanks Dan and Sam.


2017-04-30, version 3.12.2 #


  Added a rocket trajectory optimization example.


2017-04-24, version 3.12.1 #


  Fixed #804
    
      Improved handling of powers of Infinity. Thanks @HarrySarson.
      Fixed wrong formatting of complex NaN.
    
  
  Fixed security vulnerabilities in the expression parser.
Thanks Sam and Dan.


2017-04-17, version 3.12.0 #


  Implemented QR decomposition, function math.qr. Thanks @HarrySarson.
  Fixed #824: Calling math.random() freezes IE and node.js.


2017-04-08, version 3.11.5 #


  More security measures in the expression parser.
WARNING: the behavior of the expression parser is now more strict,
some undocumented features may not work any longer.
    
      Accessing and assigning properties is now only allowed on plain
objects, not on classes, arrays, and functions anymore.
      Accessing methods is restricted to a set of known, safe methods.
    
  


2017-04-03, version 3.11.4 #


  Fixed a security vulnerability in the expression parser. Thanks @xfix.


2017-04-03, version 3.11.3 #


  Fixed a security vulnerability in the expression parser. Thanks @xfix.


2017-04-03, version 3.11.2 #


  Fixed a security vulnerability in the expression parser. Thanks @xfix.


2017-04-02, version 3.11.1 #


  Fixed security vulnerabilities in the expression parser.
Thanks Joe Vennix and @xfix.


2017-04-02, version 3.11.0 #


  Implemented method Unit.toSI() to convert a unit to base SI units.
Thanks @ericman314.
  Fixed #821, #822: security vulnerabilities in the expression parser.
Thanks @comex and @xfix.


2017-03-31, version 3.10.3 #


  More security fixes related to the ones fixed in v3.10.2.


2017-03-31, version 3.10.2 #


  Fixed a security vulnerability in the expression parser allowing
execution of arbitrary JavaScript. Thanks @CapacitorSet and @denvit.


2017-03-26, version 3.10.1 #


  Fixed xgcd for negative values. Thanks @litmit.
  Fixed #807: function transform of existing functions not being removed when
overriding such a function.


2017-03-05, version 3.10.0 #


  Implemented function reshape. Thanks @patgrasso and @ericman314.
  Implemented configuration option seedRandom for deterministic random
numbers. Thanks @morsecodist.
  Small fixes in the docs. Thanks @HarrySarson.
  Dropped support for component package manager (which became deprecated about
one and a half year ago).


2017-02-22, version 3.9.3 #


  Fixed #797: issue with production builds of React Native projects.
  Fixed math.round not accepting inputs NaN, Infinity, -Infinity.
  Upgraded all dependencies.


2017-02-16, version 3.9.2 #


  Fixed #795: Parse error in case of a multi-line expression with just comments.


2017-02-06, version 3.9.1 #


  Fixed #789: Math.js not supporting conversion of string to BigNumber,
Fraction, or Complex number.
  Fixed #790: Expression parser did not pass function arguments of enclosing
functions via scope to functions having rawArgs = true.
  Small fixes in the docs. Thanks @HarrySarson.


2017-01-23, version 3.9.0 #


  Implemented support for algebra: powerful new functions simplify and
derivative. Thanks @ericman314, @tetslee, and @BigFav.
  Implemented Kronecker Product kron. Thanks @adamisntdead.
  Reverted FunctionNode not accepting a string as function name anymore.
  Fixed #765: FunctionAssignmentNode.toString() returning a string
incompatible with the function assignment syntax.


2016-12-15, version 3.8.1 #


  Implemented function mad (median absolute deviation). Thanks @ruhleder.
  Fixed #762: expression parser failing to invoke a function returned
by a function.


2016-11-18, version 3.8.0 #


  Functions add and multiply now accept more than two arguments. See #739.
  OperatorNode now supports more than two arguments. See #739. Thanks @FSMaxB.
  Implemented a method Node.cloneDeep for the expression nodes. See #745.
  Fixed a bug in Node.clone() not cloning implicit multiplication correctly.
Thanks @FSMaxB.
  Fixed #737: Improved algorithm determining the best prefix for units.
It will now retain the original unit like 1 cm when close enough,
instead of returning 10 mm. Thanks @ericman314.
  Fixed #732: Allow letter-like unicode characters like Ohm \u2126.
  Fixed #749: Units rad, deg, and grad can now have prefixes like millirad.
  Some fixes in the docs and comments of examples. Thanks @HarrySarson.


2016-11-05, version 3.7.0 #


  Implemented method Node.equals(other) for all nodes of the expression parser.
  Implemented BigNumber support in function arg().
  Command Line Interface loads faster.
  Implicit conversions between Fractions and BigNumbers throw a neat error now
(See #710).


2016-10-21, version 3.6.0 #


  Implemented function erf(). THanks @patgrasso.
  Extended function cross() to support n-d vectors. Thanks @patgrasso.
  Extended function pickRandom with the option to pick multiple values from
an array and give the values weights: pickRandom(possibles, number, weights).
Thanks @woylie.
  Parser now exposes test functions like isAlpha which can be replaced in
order to adjust the allowed characters in variables names (See #715).
  Fixed #727: Parser not throwing an error for invalid implicit multiplications
like -2 2 and 2^3 4 (right after the second value of an operator).
  Fixed #688: Describe allowed variable names in the docs.


2016-09-21, version 3.5.3 #


  Some more fixes regarding numbers ending with a decimal mark (like 2.).


2016-09-20, version 3.5.2 #


  Fixed numbers ending with a decimal mark (like 2.) not being supported by
the parser, solved the underlying ambiguity in the parser. See #707, #711.


2016-09-12, version 3.5.1 #


  Removed a left over console.log statement. Thanks @eknkc.


2016-09-07, version 3.5.0 #


  Comments of expressions are are now stored in the parsed nodes. See #690.
  Fixed function print not accepting an Object with formatting options as
third parameter Thanks @ThomasBrierley.
  Fixed #707: The expression parser no longer accepts numbers ending with a dot
like 2..


2016-08-08, version 3.4.1 #


  Fixed broken bundle files (dist/math.js, dist/math.min.js).
  Fixed some layout issues in the function reference docs.


2016-08-07, version 3.4.0 #


  Implemented support for custom units using createUnit. Thanks @ericman314.
  Implemented function splitUnits. Thanks @ericman314.
  Implemented function isPrime. Thanks @MathBunny.


2016-07-05, version 3.3.0 #


  Implemented function isNaN.
  Function math.filter now passes three arguments to the callback function:
value, index, and array.
  Removed the check on the number of arguments from functions defined in the
expression parser (see #665).
  Fixed #665: functions map, forEach, and filter now invoke callbacks
which are a typed-function with the correct number of arguments.


2016-04-26, version 3.2.1 #


  Fixed #651: unable to perform calculations on “Unit-less” units.
  Fixed matrix.subset mutating the replacement matrix when unsqueezing it.


2016-04-16, version 3.2.0 #


  Implemented #644: method Parser.getAll() to retrieve all defined variables.
  Upgraded dependencies (decimal.js@5.0.8, fraction.js@3.3.1,
typed-function@0.10.4).
  Fixed #601: Issue with unnamed typed-functions by upgrading to
typed-function v0.10.4.
  Fixed #636: More strict toTex templates, reckon with number of arguments.
  Fixed #641: Bug in expression parser parsing implicit multiplication with
wrong precedence in specific cases.
  Fixed #645: Added documentation about engineering notation of function
math.format.


2016-04-03, version 3.1.4 #


  Using ES6 Math functions like Math.sinh, Math.cbrt, Math.sign, etc when
available.
  Fixed #631: unit aliases weeks, months, and years where missing.
  Fixed #632: problem with escaped backslashes at the end of strings.
  Fixed #635: Node.toString options where not passed to function arguments.
  Fixed #629: expression parser throws an error when passing a number with
decimal exponent instead of parsing them as implicit multiplication.
  Fixed #484, #555: inaccuracy of math.sinh for values between -1 and 1.
  Fixed #625: Unit in (inch) not always working due to ambiguity with
the operator a in b (alias of a to b).


2016-03-24, version 3.1.3 #


  Fix broken bundle.


2016-03-24, version 3.1.2 #


  Fix broken npm release.


2016-03-24, version 3.1.1 #


  Fixed #621: a bug in parsing implicit multiplications like (2)(3)+4.
  Fixed #623: nthRoot of zero with a negative root returned 0 instead of
Infinity.
  Throw an error when functions min, max, mean, or median are invoked
with multiple matrices as arguments (see #598).


2016-03-19, version 3.1.0 #


  Hide multiplication operator by default when outputting toTex and toString
for implicit multiplications. Implemented and option to output the operator.
  Implemented unit kip and alias kips. Thanks @hgupta9.
  Added support for prefixes for units mol and mole. Thanks @stu-blair.
  Restored support for implicit multiplications like 2(3+4) and (2+3)(4+5).
  Some improvements in the docs.
  Added automatic conversions from boolean and null to Fraction,
and conversions from Fraction to Complex.


2016-03-04, version 3.0.0 #

breaking changes #


  More restricted support for implicit multiplication in the expression
parser: (...)(...) is now evaluated as a function invocation,
and [...][...] as a matrix subset.
  Matrix multiplication no longer squeezes scalar outputs to a scalar value,
but leaves them as they are: a vector or matrix containing a single value.
See #529.
  
    Assignments in the expression parser now return the assigned value rather
than the created or updated object (see #533). Example:

    A = eye(3)
A[1,1] = 2   # this assignment now returns 2 instead of A
    
  
  Expression parser now supports objects. This involves a refactoring and
extension in expression nodes:
    
      Implemented new node ObjectNode.
      Refactored AssignmentNode, UpdateNode, and IndexNode are refactored
into AccessorNode, AssignmentNode, and IndexNode having a different API.
    
  
  Upgraded the used BigNumber library decimal.js to v5. Replaced the
trigonometric functions of math.js with those provided in decimal.js v5.
This can give slightly different behavior qua round-off errors.
  Replaced the internal Complex.js class with the complex.js library
created by @infusion.
  Entries in a matrix (typically numbers, BigNumbers, Units, etc) are now
considered immutable, they are no longer copied when performing operations on
the entries, improving performance.
  Implemented nearly equal comparison for relational functions (equal,
larger, smaller, etc.) when using BigNumbers.
  Changed the casing of the configuration options matrix (Array or Matrix)
and number (number, BigNumber, Fraction) such that they now match
the type returned by math.typeof. Wrong casing gives a console warning but
will still work.
  Changed the default config value for epsilon from 1e-14 to 1e-12,
see #561.


non-breaking changes #


  Extended function pow to return the real root for cubic roots of negative
numbers. See #525, #482, #567.
  Implemented support for JSON objects in the expression parser and the
function math.format.
  Function math.fraction now supports BigNumber, and function
math.bignumber now supports Fraction.
  Expression parser now allows function and/or variable assignments inside
accessors and conditionals, like A[x=2] or a > 2 ? b="ok" : b="fail".
  Command line interface:
    
      Outputs the variable name of assignments.
      Fixed not rounding BigNumbers to 14 digits like numbers.
      Fixed non-working autocompletion of user defined variables.
    
  
  Reorganized and extended docs, added docs on classes and more. Thanks @hgupta9.
  Added new units acre, hectare, torr, bar, mmHg, mmH2O, cmH2O,
and added new aliases acres, hectares, sqfeet, sqyard, sqmile,
sqmiles, mmhg, mmh2o, cmh2o. Thanks @hgupta9.
  Fixed a bug in the toString method of an IndexNode.
  Fixed angle units deg, rad, grad, cycle, arcsec, and arcmin not
being defined as BigNumbers when configuring to use BigNumbers.


2016-02-03, version 2.7.0 #


  Added more unit aliases for time: secs, mins, hr, hrs. See #551.
  Added support for doing operations with mixed Fractions and BigNumbers.
  Fixed #540: math.intersect() returning null in some cases. Thanks @void42.
  Fixed #546: Cannot import BigNumber, Fraction, Matrix, Array.
Thanks @brettjurgens.


2016-01-08, version 2.6.0 #


  Implemented (complex) units VA and VAR.
  Implemented time units for weeks, months, years, decades, centuries, and
millennia. Thanks @owenversteeg.
  Implemented new notation engineering in function math.format.
Thanks @johnmarinelli.
  Fixed #523: In some circumstances, matrix subset returned a scalar instead
of the correct subset.
  Fixed #536: A bug in an internal method used for sparse matrices.


2015-12-05, version 2.5.0 #


  Implemented support for numeric types Fraction and BigNumber in units.
  Implemented new method toNumeric for units.
  Implemented new units arcsec, arcsecond, arcmin, arcminute.
Thanks @devdevdata222.
  Implemented new unit Herts (Hz). Thanks @SwamWithTurtles.
  Fixed #485: Scoping issue with variables both used globally as well as in a
function definition.
  Fixed: Function number didn’t support Fraction as input.


2015-11-14, version 2.4.2 #


  Fixed #502: Issue with format in some JavaScript engines.
  Fixed #503: Removed trailing commas and the use of keyword import as
property, as this gives issues with old JavaScript engines.


2015-10-29, version 2.4.1 #


  Fixed #480: nthRoot not working on Internet Explorer (up to IE11).
  Fixed #490: nthRoot returning an error for negative values like
nthRoot(-2, 3).
  Fixed #489: an issue with initializing a sparse matrix without data.
Thanks @Retsam.
  Fixed: #493: function combinations did not throw an exception for
non-integer values of k.
  Fixed: function import did not override typed functions when the option
override was set true.
  Fixed: added functions math.sparse and math.index to the reference docs,
they where missing.
  Fixed: removed memoization from gamma and factorial functions, this
could blow up memory.


2015-10-09, version 2.4.0 #


  Added support in the expression parser for mathematical alphanumeric symbols
in the expression parser: unicode range \u{1D400} to \u{1D7FF} excluding
invalid code points.
  Extended function distance with more signatures. Thanks @kv-kunalvyas.
  Fixed a bug in functions sin and cos, which gave wrong results for
BigNumber integer values around multiples of tau (i.e. sin(bignumber(7))).
  Fixed value of unit stone. Thanks @Esvandiary for finding the error.


2015-09-19, version 2.3.0 #


  Implemented function distance. Thanks @devanp92.
  Implemented support for Fractions in function lcm. Thanks @infusion.
  Implemented function cbrt for numbers, complex numbers, BigNumbers, Units.
  Implemented function hypot.
  Upgraded to fraction.js v3.0.0.
  Fixed #450: issue with non sorted index in sparse matrices.
  Fixed #463, #322: inconsistent handling of implicit multiplication.
  Fixed #444: factorial of infinity not returning infinity.


2015-08-30, version 2.2.0 #


  Units with powers (like m^2 and s^-1) now output with the best prefix.
  Implemented support for units to abs, cube, sign, sqrt, square.
Thanks @ericman314.
  Implemented function catalan (Combinatorics). Thanks @devanp92.
  Improved the canDefineProperty check to return false in case of IE8, which
has a broken implementation of defineProperty. Thanks @golmansax.
  Fixed function to not working in case of a simplified unit.
  Fixed #437: an issue with row swapping in lup, also affecting lusolve.


2015-08-12, version 2.1.1 #


  Fixed wrong values of the physical constants speedOfLight, molarMassC12,
and magneticFluxQuantum. Thanks @ericman314 for finding two of them.


2015-08-11, version 2.1.0 #


  Implemented derived units (like 110 km/h in m/s). Thanks @ericman314.
  Implemented support for electric units. Thanks @ericman314.
  Implemented about 50 physical constants like speedOfLight, gravity, etc.
  Implemented function kldivergence (Kullback-Leibler divergence).
Thanks @saromanov.
  Implemented function mode. Thanks @kv-kunalvyas.
  Added support for unicode characters in the expression parser: greek letters
and latin letters with accents. See #265.
  Internal functions Unit.parse and Complex.parse now throw an Error
instead of returning null when passing invalid input.


2015-07-29, version 2.0.1 #


  Fixed operations with mixed fractions and numbers be converted to numbers
instead of fractions.


2015-07-28, version 2.0.0 #


  Large internal refactoring:
    
      performance improvements.
      allows to create custom bundles
      functions are composed using typed-function and are extensible
    
  
  Implemented support for fractions, powered by the library fraction.js.
  Implemented matrix LU decomposition with partial pivoting and a LU based
linear equations solver (functions lup and lusolve). Thanks @rjbaucells.
  Implemented a new configuration option predictable, which can be set to
true in order to ensure predictable function output types.
  Implemented function intersect. Thanks @kv-kunalvyas.
  Implemented support for adding toTex properties to custom functions.
Thanks @FSMaxB.
  Implemented support for complex values to nthRoot. Thanks @gangachris.
  Implemented util functions isInteger, isNegative, isNumeric,
isPositive, and isZero.


breaking changes #


  String input is now converted to numbers by default for all functions.
  Adding two strings will no longer concatenate them, but will convert the
strings to numbers and add them.
  Function index does no longer accept an array [start, end, step], but
instead accepts an array with arbitrary index values. It also accepts
a Range object as input.
  Function typeof no longer returns lower case names, but now returns lower
case names for primitives (like number, boolean, string), and
upper-camel-case for non-primitives (like Array, Complex, Function).
  Function import no longer supports a module name as argument. Instead,
modules can be loaded using require: math.import(require('module-name')).
  Function import has a new option silent to ignore errors, and throws
errors on duplicates by default.
  Method Node.compile() no longer needs math to be passed as argument.
  Reintroduced method Node.eval([scope]).
  Function sum now returns zero when input is an empty array. Thanks @FSMAxB.
  The size of Arrays is no longer validated. Matrices will validate this on
creation.


2015-07-12, version 1.7.1 #


  Fixed #397: Inaccuracies in nthRoot for very large values, and wrong results
for very small values. (backported from v2)
  Fixed #405: Parser throws error when defining a function in a multiline
expression.


2015-05-31, version 1.7.0 #


  Implemented function quantileSeq and partitionSelect. Thanks @BigFav.
  Implemented functions stirlingS2, bellNumbers, composition, and
multinomial. Thanks @devanp92.
  Improved the performance of median (see #373). Thanks @BigFav.
  Extended the command line interface with a mode option to output either
the expressions result, string representation, or tex representation.
Thanks @FSMaxB.
  Fixed #309: Function median mutating the input matrix. Thanks @FSMaxB.
  Fixed Node.transform not recursing over replaced parts of the
node tree (see #349).
  Fixed #381: issue in docs of randomInt.


2015-04-22, version 1.6.0 #


  Improvements in toTex. Thanks @FSMaxB.
  Fixed #328: abs(0 + 0i) evaluated to NaN.
  Fixed not being able to override lazy loaded constants.


2015-04-09, version 1.5.2 #


  Fixed #313: parsed functions did not handle recursive calls correctly.
  Fixed #251: binary prefix and SI prefix incorrectly used for byte. Now
following SI standards (1 KiB == 1024 B, 1 kB == 1000 B).
  Performance improvements in parsed functions.


2015-04-08, version 1.5.1 #


  Fixed #316: a bug in rounding values when formatting.
  Fixed #317, #319: a bug in formatting negative values.


2015-03-28, version 1.5.0 #


  Added unit stone (6.35 kg).
  Implemented support for sparse matrices. Thanks @rjbaucells.
  Implemented BigNumber support for function atan2. Thanks @BigFav.
  Implemented support for custom LaTeX representations. Thanks @FSMaxB.
  Improvements and bug fixes in outputting parentheses in Node.toString and
Node.toTex functions. Thanks @FSMaxB.
  Fixed #291: function format sometimes returning exponential notation when
it should return a fixed notation.


2015-02-28, version 1.4.0 #


  Implemented trigonometric functions:
acosh, acoth, acsch, asech, asinh, atanh, acot, acsc, asec.
Thanks @BigFav.
  Added BigNumber support for functions: cot, csc, sec, coth,
csch, sech. Thanks @BigFav.
  Implemented support for serialization and deserialization of math.js data
types.
  Fixed the calculation of norm() and abs() for large complex numbers.
Thanks @rjbaucells.
  Fixed #281: improved formatting complex numbers. Round the real or imaginary
part to zero when the difference is larger than the configured precision.


2015-02-09, version 1.3.0 #


  Implemented BigNumber implementations of most trigonometric functions: sin,
cos, tan, asin, acos, atan, cosh, sinh, tanh. Thanks @BigFav.
  Implemented function trace. Thanks @pcorey.
  Faster loading of BigNumber configuration with a high precision by lazy
loading constants like pi and e.
  Fixed constants NaN and Infinity not being BigNumber objects when
BigNumbers are configured.
  Fixed missing parentheses in the toTex representation of function
permutations.
  Some minor fixes in the docs. Thanks @KenanY.


2014-12-25, version 1.2.0 #


  Support for bitwise operations bitAnd, bitNot, bitOr, bitXor,
leftShift, rightArithShift, and rightLogShift. Thanks @BigFav.
  Support for boolean operations and, not, or, xor. Thanks @BigFav.
  Support for gamma function. Thanks @BigFav.
  Converting a unit without value will now result in a unit with value,
i.e. inch in cm will return 2.54 cm instead of cm.
  Improved accuracy of sinh and complex cos and sin. Thanks @pavpanchekha.
  Renamed function select to chain. The old function select will remain
functional until math.js v2.0.
  Upgraded to decimal.js v4.0.1 (BigNumber library).


2014-11-22, version 1.1.1 #


  Fixed Unit divided by Number returning zero.
  Fixed BigNumber downgrading to Number for a negative base in pow.
  Fixed some typos in error messaging (thanks @andy0130tw) and docs.


2014-11-15, version 1.1.0 #


  Implemented functions dot (dot product), cross (cross product), and
nthRoot.
  Officially opened up the API of expression trees:
    
      Documented the API.
      Implemented recursive functions clone, map, forEach, traverse,
transform, and filter for expression trees.
      Parameter index in the callbacks of map and forEach are now cloned
for every callback.
      Some internal refactoring inside nodes to make the API consistent:
        
          Renamed params to args and vice versa to make things consistent.
          Renamed Block.nodes to Block.blocks.
          FunctionNode now has a name: string instead of a symbol: SymbolNode.
          Changed constructor of RangeNode to
new RangeNode(start: Node, end: Node [, step: Node]).
          Nodes for a BlockNode must now be passed via the constructor instead
of via a function add.
        
      
    
  
  Fixed 2e giving a syntax error instead of being parsed as 2 * e.


2014-09-12, version 1.0.1 #


  Disabled array notation for ranges in a matrix index in the expression parser
(it is confusing and redundant there).
  Fixed a regression in the build of function subset not being able to return
a scalar.
  Fixed some missing docs and broken links in the docs.


2014-09-04, version 1.0.0 #


  Implemented a function filter(x, test).
  Removed math.distribution for now, needs some rethinking.
  math.number can convert units to numbers (requires a second argument)
  Fixed some precedence issues with the range and conversion operators.
  Fixed an zero-based issue when getting a matrix subset using an index
containing a matrix.


2014-08-21, version 0.27.0 #


  Implemented functions sort(x [, compare]) and flatten(x).
  Implemented support for null in all functions.
  Implemented support for “rawArgs” functions in the expression parser. Raw
functions are invoked with unevaluated parameters (nodes).
  Expressions in the expression parser can now be spread over multiple lines,
like ‘2 +\n3’.
  Changed default value of the option wrap of function math.import to false.
  Changed the default value for new entries in a resized matrix when to zero.
To leave new entries uninitialized, use the new constant math.uninitialized
as default value.
  Renamed transform property from __transform__ to transform, and documented
the transform feature.
  Fixed a bug in math.import not applying options when passing a module name.
  A returned matrix subset is now only squeezed when the index consists of
scalar values, and no longer for ranges resolving into a single value.


2014-08-03, version 0.26.0 #


  A new instance of math.js can no longer be created like math([options]),
to prevent side effects from math being a function instead of an object.
Instead, use the function math.create([options]) to create a new instance.
  Implemented BigNumber support for all constants: pi, tau, e, phi,
E, LN2, LN10, LOG2E, LOG10E, PI, SQRT1_2, and SQRT2.
  Implemented BigNumber support for functions gcd, xgcd, and lcm.
  Fixed function gxcd returning an Array when math.js was configured
as {matrix: 'matrix'}.
  Multi-line expressions now return a ResultSet instead of an Array.
  Implemented transforms (used right now to transform one-based indices to
zero-based for expressions).
  When used inside the expression parser, functions concat, min, max,
and mean expect an one-based dimension number.
  Functions map and forEach invoke the callback with one-based indices
when used from within the expression parser.
  When adding or removing dimensions when resizing a matrix, the dimensions
are added/removed from the inner side (right) instead of outer side (left).
  Improved index out of range errors.
  Fixed function concat not accepting a BigNumber for parameter dim.
  Function squeeze now squeezes both inner and outer singleton dimensions.
  Output of getting a matrix subset is not automatically squeezed anymore
except for scalar output.
  Renamed FunctionNode to FunctionAssignmentNode, and renamed ParamsNode
to FunctionNode for more clarity.
  Fixed broken auto completion in CLI.
  Some minor fixes.


2014-07-01, version 0.25.0 #


  
    The library now immediately returns a default instance of mathjs, there is
no need to instantiate math.js in a separate step unless one ones to set
configuration options:

      // instead of:
  var mathjs = require('mathjs'),  // load math.js
      math = mathjs();             // create an instance

  // just do:
  var math = require('mathjs');
    
  
  Implemented support for implicit multiplication, like math.eval('2a', {a:3})
and math.eval('(2+3)(1-3)'). This changes behavior of matrix indexes as
well: an expression like [...][...] is not evaluated as taking a subset of
the first matrix, but as an implicit multiplication of two matrices.
  Removed utility function ifElse. This function is redundant now the
expression parser has a conditional operator a ? b : c.
  Fixed a bug with multiplying a number with a temperature,
like math.eval('10 * celsius').
  Fixed a bug with symbols having value undefined not being evaluated.


2014-06-20, version 0.24.1 #


  Something went wrong with publishing on npm.


2014-06-20, version 0.24.0 #


  Added constant null.
  Functions equal and unequal support null and undefined now.
  Function typeof now recognizes regular expressions as well.
  Objects Complex, Unit, and Help now return their string representation
when calling .valueOf().
  Changed the default number of significant digits for BigNumbers from 20 to 64.
  Changed the behavior of the conditional operator (a ? b : c) to lazy
evaluating.
  Fixed imported, wrapped functions not accepting null and undefined as
function arguments.


2014-06-10, version 0.23.0 #


  Renamed some functions (everything now has a logical, camel case name):
    
      Renamed functions edivide, emultiply, and epow to dotDivide,
dotMultiply, and dotPow respectively.
      Renamed functions smallereq and largereq to smallerEq and largerEq.
      Renamed function unary to unaryMinus and added support for strings.
    
  
  end is now a reserved keyword which cannot be used as function or symbol
name in the expression parser, and is not allowed in the scope against which
an expression is evaluated.
  Implemented function unaryPlus and unary plus operator.
  Implemented function deepEqual for matrix comparisons.
  Added constant phi, the golden ratio (phi = 1.618...).
  Added constant version, returning the version number of math.js as string.
  Added unit drop (gtt).
  Fixed not being able to load math.js using AMD/require.js.
  Changed signature of math.parse(expr, nodes) to math.parse(expr, options)
where options: {nodes: Object.<String, Node>}
  Removed matrix support from conditional function ifElse.
  
    Removed automatic assignment of expression results to variable ans.
This functionality can be restored by pre- or postprocessing every evaluation,
something like:

      function evalWithAns (expr, scope) {
    var ans = math.eval(expr, scope);
    if (scope) {
      scope.ans = ans;
    }
    return ans;
  }
    
  


2014-05-22, version 0.22.0 #


  Implemented support to export expressions to LaTeX. Thanks Niels Heisterkamp
(@nheisterkamp).
  Output of matrix multiplication is now consistently squeezed.
  Added reference documentation in the section /docs/reference.
  Fixed a bug in multiplying units without value with a number (like 5 * cm).
  Fixed a bug in multiplying two matrices containing vectors (worked fine for
arrays).
  Fixed random functions not accepting Matrix as input, and always returning
a Matrix as output.


2014-05-13, version 0.21.1 #


  Removed crypto library from the bundle.
  Deprecated functions Parser.parse and Parser.compile. Use
math.parse and math.compile instead.
  Fixed function add not adding strings and matrices element wise.
  Fixed parser not being able to evaluate an exponent followed by a unary minus
like 2^-3, and a transpose followed by an index like [3]'[1].


2014-04-24, version 0.21.0 #


  Implemented trigonometric hyperbolic functions cosh, coth, csch,
sech, sinh, tanh. Thanks Rogelio J. Baucells (@rjbaucells).
  Added property type to all expression nodes in an expression tree.
  Fixed functions log, log10, pow, and sqrt not supporting complex
results from BigNumber input (like sqrt(bignumber(-4))).


2014-04-16, version 0.20.0 #


  Switched to module decimal.js for BigNumber support, instead of
bignumber.js.
  Implemented support for polar coordinates to the Complex datatype.
Thanks Finn Pauls (@finnp).
  Implemented BigNumber support for functions exp, log, and log10.
  Implemented conditional operator a ? b : c in expression parser.
  Improved floating point comparison: the functions now check whether values
are nearly equal, against a configured maximum relative difference epsilon.
Thanks Rogelio J. Baucells (@rjbaucells).
  Implemented function norm. Thanks Rogelio J. Baucells (@rjbaucells).
  Improved function ifElse, is now specified for special data types too.
  Improved function det. Thanks Bryan Cuccioli (@bcuccioli).
  Implemented BigNumber support for functions det and diag.
  Added unit alias lbs (pound mass).
  Changed configuration option decimals to precision (applies to BigNumbers
only).
  Fixed support for element-wise comparisons between a string and a matrix.
  Fixed: expression parser now trows IndexErrors with one-based indices instead
of zero-based.
  Minor bug fixes.


2014-03-30, version 0.19.0 #


  Implemented functions compare, sum, prod, var, std, median.
  Implemented function ifElse Thanks @mtraynham.
  Minor bug fixes.


2014-02-15, version 0.18.1 #


  Added unit feet.
  Implemented function compile (shortcut for parsing and then compiling).
  Improved performance of function pow for matrices. Thanks @hamadu.
  Fixed broken auto completion in the command line interface.
  Fixed an error in function combinations for large numbers, and
improved performance of both functions combinations and permutations.


2014-01-18, version 0.18.0 #


  Changed matrix index notation of expression parser from round brackets to
square brackets, for example A[1, 1:3] instead of A(1, 1:3).
  Removed need to use the function keyword for function assignments in the
expression parser, you can define a function now like f(x) = x^2.
  Implemented a compilation step in the expression parser: expressions are
compiled into JavaScript, giving much better performance (easily 10x as fast).
  Renamed unit conversion function and operator in to to. Operator in is
still available in the expression parser as an alias for to. Added unit
in, an abbreviation for inch. Thanks Elijah Insua (@tmpvar).
  Added plurals and aliases for units.
  Implemented an argument includeEnd for function range (false by default).
  Ranges in the expression parser now support big numbers.
  Implemented functions permutations and combinations.
Thanks Daniel Levin (@daniel-levin).
  Added lower case abbreviation l for unit litre.


2013-12-19, version 0.17.1 #


  Fixed a bug with negative temperatures.
  Fixed a bug with prefixes of units squared meter m2 and cubic meter m3.


2013-12-12, version 0.17.0 #


  Renamed and flattened configuration settings:
    
      number.defaultType is now number.
      number.precision is now decimals.
      matrix.defaultType is now matrix.
    
  
  Function multiply now consistently outputs a complex number on complex input.
  Fixed mod and in not working as function (only as operator).
  Fixed support for old browsers (IE8 and older), compatible when using es5-shim.
  Fixed support for Java’s ScriptEngine.


2013-11-28, version 0.16.0 #


  Implemented BigNumber support for arbitrary precision calculations.
Added settings number.defaultType and number.precision to configure
big numbers.
  Documentation is extended.
  Removed utility functions isScalar, toScalar, isVector, toVector
from Matrix and Range. Use math.squeeze and math.size instead.
  Implemented functions get and set on Matrix, for easier and faster
retrieval/replacement of elements in a matrix.
  Implemented function resize, handling matrices, scalars, and strings.
  Functions ones and zeros now return an empty matrix instead of a
number 1 or 0 when no arguments are provided.
  Implemented functions min and max for Range and Index.
  Resizing matrices now leaves new elements undefined by default instead of
filling them with zeros. Function resize now has an extra optional
parameter defaultValue.
  Range operator : in expression parser has been given a higher precedence.
  Functions don’t allow arguments of unknown type anymore.
  Options be set when constructing a math.js instance or using the new function
config(options. Options are no longer accessible via math.options.
  Renamed scientific notation to exponential in function format.
  Function format outputs exponential notation with positive exponents now
always with + sign, so outputs 2.1e+3 instead of 2.1e3.
  Fixed function squeeze not being able squeeze into a scalar.
  Some fixes and performance improvements in the resize and subset
functions.
  Function size now adheres to the option matrix.defaultType for scalar
input.
  Minor bug fixes.


2013-10-26, version 0.15.0 #


  Math.js must be instantiated now, static calls are no longer supported. Usage:
    
      node.js: var math = require('mathjs')();
      browser: var math = mathjs();
    
  
  Implemented support for multiplying vectors with matrices.
  Improved number formatting:
    
      Function format now support various options: precision, different
notations (fixed, scientific, auto), and more.
      Numbers are no longer rounded to 5 digits by default when formatted.
      Implemented a function format for Matrix, Complex, Unit, Range,
and Selector to format using options.
      Function format does only stringify values now, and has a new parameter
precision to round to a specific number of digits.
      Removed option math.options.precision,
use math.format(value [, precision]) instead.
      Fixed formatting numbers as scientific notation in some cases returning
a zero digit left from the decimal point. (like “0.33333e8” rather than
“3.3333e7”). Thanks @husayt.
    
  
  Implemented a function print to interpolate values in a template string,
this functionality was moved from the function format.
  Implemented statistics function mean. Thanks Guillermo Indalecio Fernandez
(@guillermobox).
  Extended and changed max and min for multi dimensional matrices: they now
return the maximum and minimum of the flattened array. An optional second
argument dim allows to calculate the max or min for specified dimension.
  Renamed option math.options.matrix.default to
math.options.matrix.defaultType.
  Removed support for comparing complex numbers in functions smaller,
smallereq, larger, largereq. Complex numbers cannot be ordered.


2013-10-08, version 0.14.0 #


  Introduced an option math.options.matrix.default which can have values
matrix (default) or array. This option is used by the functions eye,
ones, range, and zeros, to determine the type of matrix output.
  Getting a subset of a matrix will automatically squeeze the resulting subset,
setting a subset of a matrix will automatically unsqueeze the given subset.
  Removed concatenation of nested arrays in the expression parser.
You can now input nested arrays like in JavaScript. Matrices can be
concatenated using the function concat.
  The matrix syntax [...] in the expression parser now creates 1 dimensional
matrices by default. math.eval('[1,2,3,4]') returns a matrix with
size [4], math.eval('[1,2;3,4]') returns a matrix with size [2,2].
  Documentation is restructured and extended.
  Fixed non working operator mod (modulus operator).


2013-09-03, version 0.13.0 #


  Implemented support for booleans in all relevant functions.
  Implemented functions map and forEach. Thanks Sebastien Piquemal (@sebpic).
  All construction functions can be used to convert the type of variables,
also element-wise for all elements in an Array or Matrix.
  Changed matrix indexes of the expression parser to one-based with the
upper-bound included, similar to most math applications. Note that on a
JavaScript level, math.js uses zero-based indexes with excluded upper-bound.
  Removed support for scalars in the function subset, it now only supports
Array, Matrix, and String.
  Removed the functions get and set from a selector, they are a duplicate
of the function subset.
  Replaced functions get and set of Matrix with a single function
subset.
  Some moving around with code and namespaces:
    
      Renamed namespace math.expr to math.expression (contains Scope, Parser,
node objects).
      Renamed namespace math.docs to math.expression.docs.
      Moved math.expr.Selector to math.chaining.Selector.
    
  
  Fixed some edge cases in functions lcm and xgcd.


2013-08-22, version 0.12.1 #


  Fixed outdated version of README.md.
  Fixed a broken unit test.


2013-08-22, version 0.12.0 #


  Implemented functions random([min, max]), randomInt([min, max]),
pickRandom(array). Thanks Sebastien Piquemal (@sebpic).
  Implemented function distribution(name), generating a distribution object
with functions random, randomInt, pickRandom for different
distributions. Currently supporting uniform and normal.
  Changed the behavior of range to exclude the upper bound, so range(1, 4)
now returns [1, 2, 3] instead of [1, 2, 3, 4].
  Changed the syntax of range, which is now range(start, end [, step])
instead of range(start, [step, ] end).
  Changed the behavior of ones and zeros to geometric dimensions, for
example ones(3) returns a vector with length 3, filled with ones, and
ones(3,3) returns a 2D array with size [3, 3].
  Changed the return type of ones and zeros: they now return an Array when
arguments are Numbers or an Array, and returns a Matrix when the argument
is a Matrix.
  Change matrix index notation in parser from round brackets to square brackets,
for example A[0, 0:3].
  Removed the feature introduced in v0.10.0 to automatically convert a complex
value with an imaginary part equal to zero to a number.
  Fixed zeros being formatted as null. Thanks @TimKraft.


2013-07-23, version 0.11.1 #


  Fixed missing development dependency


2013-07-23, version 0.11.0 #


  Changed math.js from one-based to zero-based indexes.
    
      Getting and setting matrix subset is now zero-based.
      The dimension argument in function concat is now zero-based.
    
  
  Improvements in the string output of function help.
  Added constants true and false.
  Added constructor function boolean.
  Fixed function select not accepting 0 as input.
Thanks Elijah Manor (@elijahmanor).
  Parser now supports multiple unary minus operators after each other.
  Fixed not accepting empty matrices like [[], []].
  Some fixes in the end user documentation.


2013-07-08, version 0.10.0 #


  For complex calculations, all functions now automatically replace results
having an imaginary part of zero with a Number. (2i * 2i now returns a
Number -4 instead of a Complex -4 + 0i).
  Implemented support for injecting custom node handlers in the parser. Can be
used for example to implement a node handler for plotting a graph.
  Implemented end user documentation and a new help function.
  Functions size and squeeze now return a Matrix instead of an Array as
output on Matrix input.
  Added a constant tau (2 * pi). Thanks Zak Zibrat (@palimpsests).
  Renamed function unaryminus to unary.
  Fixed a bug in determining node dependencies in function assignments.


2013-06-14, version 0.9.1 #


  Implemented element-wise functions and operators: emultiply (x .* y),
edivide (x ./ y), epow (x .^ y).
  Added constants Infinity and NaN.
  Removed support for Workspace to keep the library focused on its core task.
  Fixed a bug in the Complex constructor, not accepting NaN values.
  Fixed division by zero in case of pure complex values.
  Fixed a bug in function multiply multiplying a pure complex value with
Infinity.


2013-05-29, version 0.9.0 #


  Implemented function math.parse(expr [,scope]). Optional parameter scope can
be a plain JavaScript Object containing variables.
  Extended function math.expr(expr [, scope]) with an additional parameter
scope, similar to parse. Example: math.eval('x^a', {x:3, a:2});.
  Implemented function subset, to get or set a subset from a matrix, string,
or other data types.
  Implemented construction functions number and string (mainly useful inside
the parser).
  Improved function det. Thanks Bryan Cuccioli (@bcuccioli).
  Moved the parse code from prototype math.expr.Parser to function math.parse,
simplified Parser a little bit.
  Strongly simplified the code of Scope and Workspace.
  Fixed function mod for negative numerators, and added error messages in case
of wrong input.


2013-05-18, version 0.8.2 #


  Extended the import function and some other minor improvements.
  Fixed a bug in merging one dimensional vectors into a matrix.
  Fixed a bug in function subtract, when subtracting a complex number from a
real number.


2013-05-10, version 0.8.1 #


  Fixed an npm warning when installing mathjs globally.


2013-05-10, version 0.8.0 #


  Implemented a command line interface. When math.js is installed globally via
npm, the application is available on your system as ‘mathjs’.
  Implemented end keyword for index operator, and added support for implicit
start and end (expressions like a(2,:) and b(2:end,3:end-1) are supported
now).
  Function math.eval is more flexible now: it supports variables and multi-line
expressions.
  Removed the read-only option from Parser and Scope.
  Fixed non-working unequal operator != in the parser.
  Fixed a bug in resizing matrices when replacing a subset.
  Fixed a bug in updating a subset of a non-existing variable.
  Minor bug fixes.


2013-05-04, version 0.7.2 #


  Fixed method unequal, which was checking for equality instead of inequality.
Thanks @FJS2.


2013-04-27, version 0.7.1 #


  Improvements in the parser:
    
      Added support for chained arguments.
      Added support for chained variable assignments.
      Added a function remove(name) to remove a variable from the parsers scope.
      Renamed nodes for more consistency and to resolve naming conflicts.
      Improved stringification of an expression tree.
      Some simplifications in the code.
      Minor bug fixes.
    
  
  Fixed a bug in the parser, returning NaN instead of throwing an error for a
number with multiple decimal separators like 2.3.4.
  Fixed a bug in Workspace.insertAfter.
  Fixed: math.js now works on IE 6-8 too.


2013-04-20, version 0.7.0 #


  Implemented method math.eval, which uses a readonly parser to evaluate
expressions.
  Implemented method xgcd (extended eucledian algorithm). Thanks Bart Kiers
(@bkiers).
  Improved math.format, which now rounds values to a maximum number of digits
instead of decimals (default is 5 digits, for example math.format(math.pi)
returns 3.1416).
  Added examples.
  Changed methods square and cube to evaluate matrices element wise (consistent
with all other methods).
  Changed second parameter of method import to an object with options.
  Fixed method math.typeof on IE.
  Minor bug fixes and improvements.


2013-04-13, version 0.6.0 #


  Implemented chained operations via method math.select(). For example
math.select(3).add(4).subtract(2).done() will return 5.
  Implemented methods gcd and lcm.
  Implemented method Unit.in(unit), which creates a clone of the unit with a
fixed representation. For example math.unit('5.08 cm').in('inch') will
return a unit which string representation always is in inch, thus 2 inch.
Unit.in(unit) is the same as method math.in(x, unit).
  Implemented Unit.toNumber(unit), which returns the value of the unit when
represented with given unit. For example
math.unit('5.08 cm').toNumber('inch') returns the number 2, as the
representation of the unit in inches has 2 as value.
  Improved: method math.in(x, unit) now supports a string as second parameter,
for example math.in(math.unit('5.08 cm'), 'inch').
  Split the end user documentation of the parser functions from the source
files.
  Removed function help and the built-in documentation from the core library.
  Fixed constant i being defined as -1i instead of 1i.
  Minor bug fixes.


2013-04-06, version 0.5.0 #


  Implemented data types Matrix and Range.
  Implemented matrix methods clone, concat, det, diag, eye, inv, ones, size,
squeeze, transpose, zeros.
  Implemented range operator :, and transpose operator ' in parser.
  Changed: created construction methods for easy object creation for all data
types and for the parser. For example, a complex value is now created
with math.complex(2, 3) instead of new math.Complex(2, 3), and a parser
is now created with math.parser() instead of new math.parser.Parser().
  Changed: moved all data types under the namespace math.type, and moved the
Parser, Workspace, etc. under the namespace math.expr.
  Changed: changed operator precedence of the power operator:
    
      it is now right associative instead of left associative like most scripting
languages. So 2^3^4 is now calculated as 2^(3^4).
      it has now higher precedence than unary minus most languages, thus -3^2 is
now calculated as -(3^2).
    
  
  Changed: renamed the parsers method ‘put’ into ‘set’.
  Fixed: method ‘in’ did not check for units to have the same base.


2013-03-16, version 0.4.0 #


  Implemented Array support for all methods.
  Implemented Array support in the Parser.
  Implemented method format.
  Implemented parser for units, math.Unit.parse(str).
  Improved parser for complex values math.Complex.parse(str);
  Improved method help: it now evaluates the examples.
  Fixed: a scoping issue with the Parser when defining functions.
  Fixed: method ‘typeof’ was not working well with minified and mangled code.
  Fixed: errors in determining the best prefix for a unit.


2013-03-09, version 0.3.0 #


  Implemented Workspace
  Implemented methods cot, csc, sec.
  Implemented Array support for methods with one parameter.


2013-02-25, version 0.2.0 #


  Parser, Scope, and expression tree with Nodes implemented.
  Implemented method import which makes it easy to extend math.js.
  Implemented methods arg, conj, cube, equal, factorial, im, largereq,
log(x, base), log10, mod, re, sign, smallereq, square, unequal.


2013-02-18, version 0.1.0 #


  Reached full compatibility with Javascripts built-in Math library.
  More functions implemented.
  Some bugfixes.


2013-02-16, version 0.0.2 #


  All constants of Math implemented, plus the imaginary unit i.
  Data types Complex and Unit implemented.
  First set of functions implemented.


2013-02-15, version 0.0.1 #


  First publish of the mathjs package. (package is still empty)\n\n\n\nAn extensive math library for JavaScript and Node.js #

Math.js is an extensive math library for JavaScript and Node.js. It features a flexible expression parser with support for symbolic computation, comes with a large set of built-in functions and constants, and offers an integrated solution to work with different data types like numbers, big numbers, complex numbers, fractions, units, and matrices. Powerful and easy to use.

Features #


  Supports numbers, big numbers, bigint, complex numbers, fractions, units, strings, arrays, and matrices.
  Is compatible with JavaScript’s built-in Math library.
  Contains a flexible expression parser.
  Does symbolic computation.
  Comes with a large set of built-in functions and constants.
  Can be used as a command line application as well.
  Runs on any JavaScript engine.
  Is easily extensible.
  Open source.



  
    Example #
    
      Here some example code demonstrating how to use the library.
      Click here to fiddle around.
    
    
// functions and constants
math.round(math.e, 3)                // 2.718
math.atan2(3, -3) / math.pi          // 0.75
math.log(10000, 10)                  // 4
math.sqrt(-4)                        // 2i
math.derivative('x^2 + x', 'x')      // 2*x+1
math.pow([[-1, 2], [3, 1]], 2)
     // [[7, 0], [0, 7]]

// expressions
math.evaluate('1.2 * (2 + 4.5)')     // 7.8
math.evaluate('12.7 cm to inch')     // 5 inch
math.evaluate('sin(45 deg) ^ 2')     // 0.5
math.evaluate('9 / 3 + 2i')          // 3 + 2i
math.evaluate('det([-1, 2; 3, 1])')  // -7

// chaining
math.chain(3)
    .add(4)
    .multiply(2)
    .done() // 14
  
  
  
    Demo #
    
      Try the expression parser below.
      See Math Notepad for a full application.
    
    loading...
    
      Shortcut keys:
      
        Press S to set focus to the input field
        Press Ctrl+F11 to toggle full screen
        Press Tab to autocomplete (repeat to cycle choices)
        Enter "clear" to clear history
      
    
  
   



  
  
    Sponsor
    
  

  
  
  
    
  

  
  
    Tweet
    
  

  
  
    
    
  

  
  
    
    
    
  

  

  
    Sponsored by\n\n\n\nAn extensive math library for JavaScript and Node.js #

Math.js is an extensive math library for JavaScript and Node.js. It features a flexible expression parser with support for symbolic computation, comes with a large set of built-in functions and constants, and offers an integrated solution to work with different data types like numbers, big numbers, complex numbers, fractions, units, and matrices. Powerful and easy to use.

Features #


  Supports numbers, big numbers, bigint, complex numbers, fractions, units, strings, arrays, and matrices.
  Is compatible with JavaScript’s built-in Math library.
  Contains a flexible expression parser.
  Does symbolic computation.
  Comes with a large set of built-in functions and constants.
  Can be used as a command line application as well.
  Runs on any JavaScript engine.
  Is easily extensible.
  Open source.



  
    Example #
    
      Here some example code demonstrating how to use the library.
      Click here to fiddle around.
    
    
// functions and constants
math.round(math.e, 3)                // 2.718
math.atan2(3, -3) / math.pi          // 0.75
math.log(10000, 10)                  // 4
math.sqrt(-4)                        // 2i
math.derivative('x^2 + x', 'x')      // 2*x+1
math.pow([[-1, 2], [3, 1]], 2)
     // [[7, 0], [0, 7]]

// expressions
math.evaluate('1.2 * (2 + 4.5)')     // 7.8
math.evaluate('12.7 cm to inch')     // 5 inch
math.evaluate('sin(45 deg) ^ 2')     // 0.5
math.evaluate('9 / 3 + 2i')          // 3 + 2i
math.evaluate('det([-1, 2; 3, 1])')  // -7

// chaining
math.chain(3)
    .add(4)
    .multiply(2)
    .done() // 14
  
  
  
    Demo #
    
      Try the expression parser below.
      See Math Notepad for a full application.
    
    loading...
    
      Shortcut keys:
      
        Press S to set focus to the input field
        Press Ctrl+F11 to toggle full screen
        Press Tab to autocomplete (repeat to cycle choices)
        Enter "clear" to clear history
      
    
  
   



  
  
    Sponsor
    
  

  
  
  
    
  

  
  
    Tweet
    
  

  
  
    
    
  

  
  
    
    
    
  

  

  
    Sponsored by\n\n\n\nAn extensive math library for JavaScript and Node.js #

Math.js is an extensive math library for JavaScript and Node.js. It features a flexible expression parser with support for symbolic computation, comes with a large set of built-in functions and constants, and offers an integrated solution to work with different data types like numbers, big numbers, complex numbers, fractions, units, and matrices. Powerful and easy to use.

Features #


  Supports numbers, big numbers, bigint, complex numbers, fractions, units, strings, arrays, and matrices.
  Is compatible with JavaScript’s built-in Math library.
  Contains a flexible expression parser.
  Does symbolic computation.
  Comes with a large set of built-in functions and constants.
  Can be used as a command line application as well.
  Runs on any JavaScript engine.
  Is easily extensible.
  Open source.



  
    Example #
    
      Here some example code demonstrating how to use the library.
      Click here to fiddle around.
    
    
// functions and constants
math.round(math.e, 3)                // 2.718
math.atan2(3, -3) / math.pi          // 0.75
math.log(10000, 10)                  // 4
math.sqrt(-4)                        // 2i
math.derivative('x^2 + x', 'x')      // 2*x+1
math.pow([[-1, 2], [3, 1]], 2)
     // [[7, 0], [0, 7]]

// expressions
math.evaluate('1.2 * (2 + 4.5)')     // 7.8
math.evaluate('12.7 cm to inch')     // 5 inch
math.evaluate('sin(45 deg) ^ 2')     // 0.5
math.evaluate('9 / 3 + 2i')          // 3 + 2i
math.evaluate('det([-1, 2; 3, 1])')  // -7

// chaining
math.chain(3)
    .add(4)
    .multiply(2)
    .done() // 14
  
  
  
    Demo #
    
      Try the expression parser below.
      See Math Notepad for a full application.
    
    loading...
    
      Shortcut keys:
      
        Press S to set focus to the input field
        Press Ctrl+F11 to toggle full screen
        Press Tab to autocomplete (repeat to cycle choices)
        Enter "clear" to clear history
      
    
  
   



  
  
    Sponsor
    
  

  
  
  
    
  

  
  
    Tweet
    
  

  
  
    
    
  

  
  
    
    
    
  

  

  
    Sponsored by\n\n\n\nAn extensive math library for JavaScript and Node.js #

Math.js is an extensive math library for JavaScript and Node.js. It features a flexible expression parser with support for symbolic computation, comes with a large set of built-in functions and constants, and offers an integrated solution to work with different data types like numbers, big numbers, complex numbers, fractions, units, and matrices. Powerful and easy to use.

Features #


  Supports numbers, big numbers, bigint, complex numbers, fractions, units, strings, arrays, and matrices.
  Is compatible with JavaScript’s built-in Math library.
  Contains a flexible expression parser.
  Does symbolic computation.
  Comes with a large set of built-in functions and constants.
  Can be used as a command line application as well.
  Runs on any JavaScript engine.
  Is easily extensible.
  Open source.



  
    Example #
    
      Here some example code demonstrating how to use the library.
      Click here to fiddle around.
    
    
// functions and constants
math.round(math.e, 3)                // 2.718
math.atan2(3, -3) / math.pi          // 0.75
math.log(10000, 10)                  // 4
math.sqrt(-4)                        // 2i
math.derivative('x^2 + x', 'x')      // 2*x+1
math.pow([[-1, 2], [3, 1]], 2)
     // [[7, 0], [0, 7]]

// expressions
math.evaluate('1.2 * (2 + 4.5)')     // 7.8
math.evaluate('12.7 cm to inch')     // 5 inch
math.evaluate('sin(45 deg) ^ 2')     // 0.5
math.evaluate('9 / 3 + 2i')          // 3 + 2i
math.evaluate('det([-1, 2; 3, 1])')  // -7

// chaining
math.chain(3)
    .add(4)
    .multiply(2)
    .done() // 14
  
  
  
    Demo #
    
      Try the expression parser below.
      See Math Notepad for a full application.
    
    loading...
    
      Shortcut keys:
      
        Press S to set focus to the input field
        Press Ctrl+F11 to toggle full screen
        Press Tab to autocomplete (repeat to cycle choices)
        Enter "clear" to clear history
      
    
  
   



  
  
    Sponsor
    
  

  
  
  
    
  

  
  
    Tweet
    
  

  
  
    
    
  

  
  
    
    
    
  

  

  
    Sponsored by\n\n\n\nAn extensive math library for JavaScript and Node.js #

Math.js is an extensive math library for JavaScript and Node.js. It features a flexible expression parser with support for symbolic computation, comes with a large set of built-in functions and constants, and offers an integrated solution to work with different data types like numbers, big numbers, complex numbers, fractions, units, and matrices. Powerful and easy to use.

Features #


  Supports numbers, big numbers, bigint, complex numbers, fractions, units, strings, arrays, and matrices.
  Is compatible with JavaScript’s built-in Math library.
  Contains a flexible expression parser.
  Does symbolic computation.
  Comes with a large set of built-in functions and constants.
  Can be used as a command line application as well.
  Runs on any JavaScript engine.
  Is easily extensible.
  Open source.



  
    Example #
    
      Here some example code demonstrating how to use the library.
      Click here to fiddle around.
    
    
// functions and constants
math.round(math.e, 3)                // 2.718
math.atan2(3, -3) / math.pi          // 0.75
math.log(10000, 10)                  // 4
math.sqrt(-4)                        // 2i
math.derivative('x^2 + x', 'x')      // 2*x+1
math.pow([[-1, 2], [3, 1]], 2)
     // [[7, 0], [0, 7]]

// expressions
math.evaluate('1.2 * (2 + 4.5)')     // 7.8
math.evaluate('12.7 cm to inch')     // 5 inch
math.evaluate('sin(45 deg) ^ 2')     // 0.5
math.evaluate('9 / 3 + 2i')          // 3 + 2i
math.evaluate('det([-1, 2; 3, 1])')  // -7

// chaining
math.chain(3)
    .add(4)
    .multiply(2)
    .done() // 14
  
  
  
    Demo #
    
      Try the expression parser below.
      See Math Notepad for a full application.
    
    loading...
    
      Shortcut keys:
      
        Press S to set focus to the input field
        Press Ctrl+F11 to toggle full screen
        Press Tab to autocomplete (repeat to cycle choices)
        Enter "clear" to clear history
      
    
  
   



  
  
    Sponsor
    
  

  
  
  
    
  

  
  
    Tweet
    
  

  
  
    
    
  

  
  
    
    
    
  

  

  
    Sponsored by\n\n\n\nAn extensive math library for JavaScript and Node.js #

Math.js is an extensive math library for JavaScript and Node.js. It features a flexible expression parser with support for symbolic computation, comes with a large set of built-in functions and constants, and offers an integrated solution to work with different data types like numbers, big numbers, complex numbers, fractions, units, and matrices. Powerful and easy to use.

Features #


  Supports numbers, big numbers, bigint, complex numbers, fractions, units, strings, arrays, and matrices.
  Is compatible with JavaScript’s built-in Math library.
  Contains a flexible expression parser.
  Does symbolic computation.
  Comes with a large set of built-in functions and constants.
  Can be used as a command line application as well.
  Runs on any JavaScript engine.
  Is easily extensible.
  Open source.



  
    Example #
    
      Here some example code demonstrating how to use the library.
      Click here to fiddle around.
    
    
// functions and constants
math.round(math.e, 3)                // 2.718
math.atan2(3, -3) / math.pi          // 0.75
math.log(10000, 10)                  // 4
math.sqrt(-4)                        // 2i
math.derivative('x^2 + x', 'x')      // 2*x+1
math.pow([[-1, 2], [3, 1]], 2)
     // [[7, 0], [0, 7]]

// expressions
math.evaluate('1.2 * (2 + 4.5)')     // 7.8
math.evaluate('12.7 cm to inch')     // 5 inch
math.evaluate('sin(45 deg) ^ 2')     // 0.5
math.evaluate('9 / 3 + 2i')          // 3 + 2i
math.evaluate('det([-1, 2; 3, 1])')  // -7

// chaining
math.chain(3)
    .add(4)
    .multiply(2)
    .done() // 14
  
  
  
    Demo #
    
      Try the expression parser below.
      See Math Notepad for a full application.
    
    loading...
    
      Shortcut keys:
      
        Press S to set focus to the input field
        Press Ctrl+F11 to toggle full screen
        Press Tab to autocomplete (repeat to cycle choices)
        Enter "clear" to clear history
      
    
  
   



  
  
    Sponsor
    
  

  
  
  
    
  

  
  
    Tweet
    
  

  
  
    
    
  

  
  
    
    
    
  

  

  
    Sponsored by\n\n\n\nAn extensive math library for JavaScript and Node.js #

Math.js is an extensive math library for JavaScript and Node.js. It features a flexible expression parser with support for symbolic computation, comes with a large set of built-in functions and constants, and offers an integrated solution to work with different data types like numbers, big numbers, complex numbers, fractions, units, and matrices. Powerful and easy to use.

Features #


  Supports numbers, big numbers, bigint, complex numbers, fractions, units, strings, arrays, and matrices.
  Is compatible with JavaScript’s built-in Math library.
  Contains a flexible expression parser.
  Does symbolic computation.
  Comes with a large set of built-in functions and constants.
  Can be used as a command line application as well.
  Runs on any JavaScript engine.
  Is easily extensible.
  Open source.



  
    Example #
    
      Here some example code demonstrating how to use the library.
      Click here to fiddle around.
    
    
// functions and constants
math.round(math.e, 3)                // 2.718
math.atan2(3, -3) / math.pi          // 0.75
math.log(10000, 10)                  // 4
math.sqrt(-4)                        // 2i
math.derivative('x^2 + x', 'x')      // 2*x+1
math.pow([[-1, 2], [3, 1]], 2)
     // [[7, 0], [0, 7]]

// expressions
math.evaluate('1.2 * (2 + 4.5)')     // 7.8
math.evaluate('12.7 cm to inch')     // 5 inch
math.evaluate('sin(45 deg) ^ 2')     // 0.5
math.evaluate('9 / 3 + 2i')          // 3 + 2i
math.evaluate('det([-1, 2; 3, 1])')  // -7

// chaining
math.chain(3)
    .add(4)
    .multiply(2)
    .done() // 14
  
  
  
    Demo #
    
      Try the expression parser below.
      See Math Notepad for a full application.
    
    loading...
    
      Shortcut keys:
      
        Press S to set focus to the input field
        Press Ctrl+F11 to toggle full screen
        Press Tab to autocomplete (repeat to cycle choices)
        Enter "clear" to clear history
      
    
  
   



  
  
    Sponsor
    
  

  
  
  
    
  

  
  
    Tweet
    
  

  
  
    
    
  

  
  
    
    
    
  

  

  
    Sponsored by\n\n\n\nAn extensive math library for JavaScript and Node.js #

Math.js is an extensive math library for JavaScript and Node.js. It features a flexible expression parser with support for symbolic computation, comes with a large set of built-in functions and constants, and offers an integrated solution to work with different data types like numbers, big numbers, complex numbers, fractions, units, and matrices. Powerful and easy to use.

Features #


  Supports numbers, big numbers, bigint, complex numbers, fractions, units, strings, arrays, and matrices.
  Is compatible with JavaScript’s built-in Math library.
  Contains a flexible expression parser.
  Does symbolic computation.
  Comes with a large set of built-in functions and constants.
  Can be used as a command line application as well.
  Runs on any JavaScript engine.
  Is easily extensible.
  Open source.



  
    Example #
    
      Here some example code demonstrating how to use the library.
      Click here to fiddle around.
    
    
// functions and constants
math.round(math.e, 3)                // 2.718
math.atan2(3, -3) / math.pi          // 0.75
math.log(10000, 10)                  // 4
math.sqrt(-4)                        // 2i
math.derivative('x^2 + x', 'x')      // 2*x+1
math.pow([[-1, 2], [3, 1]], 2)
     // [[7, 0], [0, 7]]

// expressions
math.evaluate('1.2 * (2 + 4.5)')     // 7.8
math.evaluate('12.7 cm to inch')     // 5 inch
math.evaluate('sin(45 deg) ^ 2')     // 0.5
math.evaluate('9 / 3 + 2i')          // 3 + 2i
math.evaluate('det([-1, 2; 3, 1])')  // -7

// chaining
math.chain(3)
    .add(4)
    .multiply(2)
    .done() // 14
  
  
  
    Demo #
    
      Try the expression parser below.
      See Math Notepad for a full application.
    
    loading...
    
      Shortcut keys:
      
        Press S to set focus to the input field
        Press Ctrl+F11 to toggle full screen
        Press Tab to autocomplete (repeat to cycle choices)
        Enter "clear" to clear history
      
    
  
   



  
  
    Sponsor
    
  

  
  
  
    
  

  
  
    Tweet
    
  

  
  
    
    
  

  
  
    
    
    
  

  

  
    Sponsored by\n\n\n\nInstall #

Math.js can be installed via npm:

npm install mathjs


When installed globally with npm (using the -g option), math.js is available as a command line application mathjs, see documentation on Command Line Interface. Math.js ships with built-in TypeScript type definitions.

Download #

Math.js can be downloaded or linked from various content delivery networks:


  
    
      CDN
      Url
    
  
  
    
      unpkg
      https://unpkg.com/mathjs@14.4.0/
    
    
      cdnjs
      https://cdnjs.com/libraries/mathjs
        
    
      jsDelivr
      https://www.jsdelivr.com/package/npm/mathjs
    
    
      PageCDN 
      https://pagecdn.com/lib/mathjs
    
  


Or download the full bundle directly from unpkg:


    math.js (version 14.4.0, 186 kB, minified and gzipped) 
    and if needed the source map


Too large for you? Create your own custom bundle.

Web Service #

Math.js is available as a RESTful web service: https://api.mathjs.org

Extensions #

Here some notable extensions for mathjs:


  
    
      Extension
      Description
    
  
  
    
      mathsteps
      A step-by-step math solver library that is focused on pedagogy (how best to teach). The math problems it focuses on are pre-algebra and algebra problems involving simplifying expressions.
    
    
      mathjs‑expression‑parser
      This custom build of mathjs contains just the expression parser and basic arithmetic functions for numbers. About four times as small as the full mathjs library.
    
    
      mathjs-simple-integral
      Extends Math.js to be able to compute simple integrals.
    
    
      math.diff.js
      Symbolic differentiation plugin for Math.js
    
    
      postcss-math
      PostCSS plugin for making calculations with math.js
    
  


Other math libraries #

Here some other interesting JavaScript math libraries. Some can be imported into math.js using math.import.


  
    
      Extension
      Description
    
  
  
    
      math‑expression‑evaluator
      An extremely efficient, flexible and amazing evaluator for Math expression in Javascript.
    
    
      numbers.js
      Advanced Mathematics Library for Node.js and JavaScript
    
    
      numeric.js
      Numerical analysis in Javascript
    
    
      decimal.js
      An arbitrary-precision Decimal type for JavaScript. Used by mathjs for BigNumber support.
    
    
      ndarray
      Multidimensional arrays for JavaScript
    
    
      Algebrite
      Computer Algebra System in Javascript (Coffeescript)
    
    
      algebra.js
      Build, display, and solve algebraic equations
    
    
      Nerdamer
      Symbolic Math for Javascript
    
    
      numeral-js
      A javascript library for formatting and manipulating numbers
    
    
      Cortex Compute Engine
      The Cortex Compute Engine can parse LaTeX to MathJSON, serialize MathJSON to LaTeX, format, simplify and evaluate MathJSON expressions
    
  


History #

A changelog describing the changes with each release is available on the page History.

Browser support #

Math.js works on any ES5 compatible JavaScript engine: node.js, Chrome, Firefox, Safari, Edge, and IE11.

Though there is no official support for older browsers, math.js should still work on older browsers
when using the es5-shim.

Source code #

The source code of math.js is available on GitHub: https://github.com/josdejong/mathjs.

License #

Math.js is open source and licensed under the
Apache 2.0 License\n\n\n\nInstall #

Math.js can be installed via npm:

npm install mathjs


When installed globally with npm (using the -g option), math.js is available as a command line application mathjs, see documentation on Command Line Interface. Math.js ships with built-in TypeScript type definitions.

Download #

Math.js can be downloaded or linked from various content delivery networks:


  
    
      CDN
      Url
    
  
  
    
      unpkg
      https://unpkg.com/mathjs@14.4.0/
    
    
      cdnjs
      https://cdnjs.com/libraries/mathjs
        
    
      jsDelivr
      https://www.jsdelivr.com/package/npm/mathjs
    
    
      PageCDN 
      https://pagecdn.com/lib/mathjs
    
  


Or download the full bundle directly from unpkg:


    math.js (version 14.4.0, 186 kB, minified and gzipped) 
    and if needed the source map


Too large for you? Create your own custom bundle.

Web Service #

Math.js is available as a RESTful web service: https://api.mathjs.org

Extensions #

Here some notable extensions for mathjs:


  
    
      Extension
      Description
    
  
  
    
      mathsteps
      A step-by-step math solver library that is focused on pedagogy (how best to teach). The math problems it focuses on are pre-algebra and algebra problems involving simplifying expressions.
    
    
      mathjs‑expression‑parser
      This custom build of mathjs contains just the expression parser and basic arithmetic functions for numbers. About four times as small as the full mathjs library.
    
    
      mathjs-simple-integral
      Extends Math.js to be able to compute simple integrals.
    
    
      math.diff.js
      Symbolic differentiation plugin for Math.js
    
    
      postcss-math
      PostCSS plugin for making calculations with math.js
    
  


Other math libraries #

Here some other interesting JavaScript math libraries. Some can be imported into math.js using math.import.


  
    
      Extension
      Description
    
  
  
    
      math‑expression‑evaluator
      An extremely efficient, flexible and amazing evaluator for Math expression in Javascript.
    
    
      numbers.js
      Advanced Mathematics Library for Node.js and JavaScript
    
    
      numeric.js
      Numerical analysis in Javascript
    
    
      decimal.js
      An arbitrary-precision Decimal type for JavaScript. Used by mathjs for BigNumber support.
    
    
      ndarray
      Multidimensional arrays for JavaScript
    
    
      Algebrite
      Computer Algebra System in Javascript (Coffeescript)
    
    
      algebra.js
      Build, display, and solve algebraic equations
    
    
      Nerdamer
      Symbolic Math for Javascript
    
    
      numeral-js
      A javascript library for formatting and manipulating numbers
    
    
      Cortex Compute Engine
      The Cortex Compute Engine can parse LaTeX to MathJSON, serialize MathJSON to LaTeX, format, simplify and evaluate MathJSON expressions
    
  


History #

A changelog describing the changes with each release is available on the page History.

Browser support #

Math.js works on any ES5 compatible JavaScript engine: node.js, Chrome, Firefox, Safari, Edge, and IE11.

Though there is no official support for older browsers, math.js should still work on older browsers
when using the es5-shim.

Source code #

The source code of math.js is available on GitHub: https://github.com/josdejong/mathjs.

License #

Math.js is open source and licensed under the
Apache 2.0 License\n\n\n\nInstall #

Math.js can be installed via npm:

npm install mathjs


When installed globally with npm (using the -g option), math.js is available as a command line application mathjs, see documentation on Command Line Interface. Math.js ships with built-in TypeScript type definitions.

Download #

Math.js can be downloaded or linked from various content delivery networks:


  
    
      CDN
      Url
    
  
  
    
      unpkg
      https://unpkg.com/mathjs@14.4.0/
    
    
      cdnjs
      https://cdnjs.com/libraries/mathjs
        
    
      jsDelivr
      https://www.jsdelivr.com/package/npm/mathjs
    
    
      PageCDN 
      https://pagecdn.com/lib/mathjs
    
  


Or download the full bundle directly from unpkg:


    math.js (version 14.4.0, 186 kB, minified and gzipped) 
    and if needed the source map


Too large for you? Create your own custom bundle.

Web Service #

Math.js is available as a RESTful web service: https://api.mathjs.org

Extensions #

Here some notable extensions for mathjs:


  
    
      Extension
      Description
    
  
  
    
      mathsteps
      A step-by-step math solver library that is focused on pedagogy (how best to teach). The math problems it focuses on are pre-algebra and algebra problems involving simplifying expressions.
    
    
      mathjs‑expression‑parser
      This custom build of mathjs contains just the expression parser and basic arithmetic functions for numbers. About four times as small as the full mathjs library.
    
    
      mathjs-simple-integral
      Extends Math.js to be able to compute simple integrals.
    
    
      math.diff.js
      Symbolic differentiation plugin for Math.js
    
    
      postcss-math
      PostCSS plugin for making calculations with math.js
    
  


Other math libraries #

Here some other interesting JavaScript math libraries. Some can be imported into math.js using math.import.


  
    
      Extension
      Description
    
  
  
    
      math‑expression‑evaluator
      An extremely efficient, flexible and amazing evaluator for Math expression in Javascript.
    
    
      numbers.js
      Advanced Mathematics Library for Node.js and JavaScript
    
    
      numeric.js
      Numerical analysis in Javascript
    
    
      decimal.js
      An arbitrary-precision Decimal type for JavaScript. Used by mathjs for BigNumber support.
    
    
      ndarray
      Multidimensional arrays for JavaScript
    
    
      Algebrite
      Computer Algebra System in Javascript (Coffeescript)
    
    
      algebra.js
      Build, display, and solve algebraic equations
    
    
      Nerdamer
      Symbolic Math for Javascript
    
    
      numeral-js
      A javascript library for formatting and manipulating numbers
    
    
      Cortex Compute Engine
      The Cortex Compute Engine can parse LaTeX to MathJSON, serialize MathJSON to LaTeX, format, simplify and evaluate MathJSON expressions
    
  


History #

A changelog describing the changes with each release is available on the page History.

Browser support #

Math.js works on any ES5 compatible JavaScript engine: node.js, Chrome, Firefox, Safari, Edge, and IE11.

Though there is no official support for older browsers, math.js should still work on older browsers
when using the es5-shim.

Source code #

The source code of math.js is available on GitHub: https://github.com/josdejong/mathjs.

License #

Math.js is open source and licensed under the
Apache 2.0 License\n\n\n\nInstall #

Math.js can be installed via npm:

npm install mathjs


When installed globally with npm (using the -g option), math.js is available as a command line application mathjs, see documentation on Command Line Interface. Math.js ships with built-in TypeScript type definitions.

Download #

Math.js can be downloaded or linked from various content delivery networks:


  
    
      CDN
      Url
    
  
  
    
      unpkg
      https://unpkg.com/mathjs@14.4.0/
    
    
      cdnjs
      https://cdnjs.com/libraries/mathjs
        
    
      jsDelivr
      https://www.jsdelivr.com/package/npm/mathjs
    
    
      PageCDN 
      https://pagecdn.com/lib/mathjs
    
  


Or download the full bundle directly from unpkg:


    math.js (version 14.4.0, 186 kB, minified and gzipped) 
    and if needed the source map


Too large for you? Create your own custom bundle.

Web Service #

Math.js is available as a RESTful web service: https://api.mathjs.org

Extensions #

Here some notable extensions for mathjs:


  
    
      Extension
      Description
    
  
  
    
      mathsteps
      A step-by-step math solver library that is focused on pedagogy (how best to teach). The math problems it focuses on are pre-algebra and algebra problems involving simplifying expressions.
    
    
      mathjs‑expression‑parser
      This custom build of mathjs contains just the expression parser and basic arithmetic functions for numbers. About four times as small as the full mathjs library.
    
    
      mathjs-simple-integral
      Extends Math.js to be able to compute simple integrals.
    
    
      math.diff.js
      Symbolic differentiation plugin for Math.js
    
    
      postcss-math
      PostCSS plugin for making calculations with math.js
    
  


Other math libraries #

Here some other interesting JavaScript math libraries. Some can be imported into math.js using math.import.


  
    
      Extension
      Description
    
  
  
    
      math‑expression‑evaluator
      An extremely efficient, flexible and amazing evaluator for Math expression in Javascript.
    
    
      numbers.js
      Advanced Mathematics Library for Node.js and JavaScript
    
    
      numeric.js
      Numerical analysis in Javascript
    
    
      decimal.js
      An arbitrary-precision Decimal type for JavaScript. Used by mathjs for BigNumber support.
    
    
      ndarray
      Multidimensional arrays for JavaScript
    
    
      Algebrite
      Computer Algebra System in Javascript (Coffeescript)
    
    
      algebra.js
      Build, display, and solve algebraic equations
    
    
      Nerdamer
      Symbolic Math for Javascript
    
    
      numeral-js
      A javascript library for formatting and manipulating numbers
    
    
      Cortex Compute Engine
      The Cortex Compute Engine can parse LaTeX to MathJSON, serialize MathJSON to LaTeX, format, simplify and evaluate MathJSON expressions
    
  


History #

A changelog describing the changes with each release is available on the page History.

Browser support #

Math.js works on any ES5 compatible JavaScript engine: node.js, Chrome, Firefox, Safari, Edge, and IE11.

Though there is no official support for older browsers, math.js should still work on older browsers
when using the es5-shim.

Source code #

The source code of math.js is available on GitHub: https://github.com/josdejong/mathjs.

License #

Math.js is open source and licensed under the
Apache 2.0 License\n\n\n\nInstall #

Math.js can be installed via npm:

npm install mathjs


When installed globally with npm (using the -g option), math.js is available as a command line application mathjs, see documentation on Command Line Interface. Math.js ships with built-in TypeScript type definitions.

Download #

Math.js can be downloaded or linked from various content delivery networks:


  
    
      CDN
      Url
    
  
  
    
      unpkg
      https://unpkg.com/mathjs@14.4.0/
    
    
      cdnjs
      https://cdnjs.com/libraries/mathjs
        
    
      jsDelivr
      https://www.jsdelivr.com/package/npm/mathjs
    
    
      PageCDN 
      https://pagecdn.com/lib/mathjs
    
  


Or download the full bundle directly from unpkg:


    math.js (version 14.4.0, 186 kB, minified and gzipped) 
    and if needed the source map


Too large for you? Create your own custom bundle.

Web Service #

Math.js is available as a RESTful web service: https://api.mathjs.org

Extensions #

Here some notable extensions for mathjs:


  
    
      Extension
      Description
    
  
  
    
      mathsteps
      A step-by-step math solver library that is focused on pedagogy (how best to teach). The math problems it focuses on are pre-algebra and algebra problems involving simplifying expressions.
    
    
      mathjs‑expression‑parser
      This custom build of mathjs contains just the expression parser and basic arithmetic functions for numbers. About four times as small as the full mathjs library.
    
    
      mathjs-simple-integral
      Extends Math.js to be able to compute simple integrals.
    
    
      math.diff.js
      Symbolic differentiation plugin for Math.js
    
    
      postcss-math
      PostCSS plugin for making calculations with math.js
    
  


Other math libraries #

Here some other interesting JavaScript math libraries. Some can be imported into math.js using math.import.


  
    
      Extension
      Description
    
  
  
    
      math‑expression‑evaluator
      An extremely efficient, flexible and amazing evaluator for Math expression in Javascript.
    
    
      numbers.js
      Advanced Mathematics Library for Node.js and JavaScript
    
    
      numeric.js
      Numerical analysis in Javascript
    
    
      decimal.js
      An arbitrary-precision Decimal type for JavaScript. Used by mathjs for BigNumber support.
    
    
      ndarray
      Multidimensional arrays for JavaScript
    
    
      Algebrite
      Computer Algebra System in Javascript (Coffeescript)
    
    
      algebra.js
      Build, display, and solve algebraic equations
    
    
      Nerdamer
      Symbolic Math for Javascript
    
    
      numeral-js
      A javascript library for formatting and manipulating numbers
    
    
      Cortex Compute Engine
      The Cortex Compute Engine can parse LaTeX to MathJSON, serialize MathJSON to LaTeX, format, simplify and evaluate MathJSON expressions
    
  


History #

A changelog describing the changes with each release is available on the page History.

Browser support #

Math.js works on any ES5 compatible JavaScript engine: node.js, Chrome, Firefox, Safari, Edge, and IE11.

Though there is no official support for older browsers, math.js should still work on older browsers
when using the es5-shim.

Source code #

The source code of math.js is available on GitHub: https://github.com/josdejong/mathjs.

License #

Math.js is open source and licensed under the
Apache 2.0 License\n\n\n\nInstall #

Math.js can be installed via npm:

npm install mathjs


When installed globally with npm (using the -g option), math.js is available as a command line application mathjs, see documentation on Command Line Interface. Math.js ships with built-in TypeScript type definitions.

Download #

Math.js can be downloaded or linked from various content delivery networks:


  
    
      CDN
      Url
    
  
  
    
      unpkg
      https://unpkg.com/mathjs@14.4.0/
    
    
      cdnjs
      https://cdnjs.com/libraries/mathjs
        
    
      jsDelivr
      https://www.jsdelivr.com/package/npm/mathjs
    
    
      PageCDN 
      https://pagecdn.com/lib/mathjs
    
  


Or download the full bundle directly from unpkg:


    math.js (version 14.4.0, 186 kB, minified and gzipped) 
    and if needed the source map


Too large for you? Create your own custom bundle.

Web Service #

Math.js is available as a RESTful web service: https://api.mathjs.org

Extensions #

Here some notable extensions for mathjs:


  
    
      Extension
      Description
    
  
  
    
      mathsteps
      A step-by-step math solver library that is focused on pedagogy (how best to teach). The math problems it focuses on are pre-algebra and algebra problems involving simplifying expressions.
    
    
      mathjs‑expression‑parser
      This custom build of mathjs contains just the expression parser and basic arithmetic functions for numbers. About four times as small as the full mathjs library.
    
    
      mathjs-simple-integral
      Extends Math.js to be able to compute simple integrals.
    
    
      math.diff.js
      Symbolic differentiation plugin for Math.js
    
    
      postcss-math
      PostCSS plugin for making calculations with math.js
    
  


Other math libraries #

Here some other interesting JavaScript math libraries. Some can be imported into math.js using math.import.


  
    
      Extension
      Description
    
  
  
    
      math‑expression‑evaluator
      An extremely efficient, flexible and amazing evaluator for Math expression in Javascript.
    
    
      numbers.js
      Advanced Mathematics Library for Node.js and JavaScript
    
    
      numeric.js
      Numerical analysis in Javascript
    
    
      decimal.js
      An arbitrary-precision Decimal type for JavaScript. Used by mathjs for BigNumber support.
    
    
      ndarray
      Multidimensional arrays for JavaScript
    
    
      Algebrite
      Computer Algebra System in Javascript (Coffeescript)
    
    
      algebra.js
      Build, display, and solve algebraic equations
    
    
      Nerdamer
      Symbolic Math for Javascript
    
    
      numeral-js
      A javascript library for formatting and manipulating numbers
    
    
      Cortex Compute Engine
      The Cortex Compute Engine can parse LaTeX to MathJSON, serialize MathJSON to LaTeX, format, simplify and evaluate MathJSON expressions
    
  


History #

A changelog describing the changes with each release is available on the page History.

Browser support #

Math.js works on any ES5 compatible JavaScript engine: node.js, Chrome, Firefox, Safari, Edge, and IE11.

Though there is no official support for older browsers, math.js should still work on older browsers
when using the es5-shim.

Source code #

The source code of math.js is available on GitHub: https://github.com/josdejong/mathjs.

License #

Math.js is open source and licensed under the
Apache 2.0 License\n\n\n\nInstall #

Math.js can be installed via npm:

npm install mathjs


When installed globally with npm (using the -g option), math.js is available as a command line application mathjs, see documentation on Command Line Interface. Math.js ships with built-in TypeScript type definitions.

Download #

Math.js can be downloaded or linked from various content delivery networks:


  
    
      CDN
      Url
    
  
  
    
      unpkg
      https://unpkg.com/mathjs@14.4.0/
    
    
      cdnjs
      https://cdnjs.com/libraries/mathjs
        
    
      jsDelivr
      https://www.jsdelivr.com/package/npm/mathjs
    
    
      PageCDN 
      https://pagecdn.com/lib/mathjs
    
  


Or download the full bundle directly from unpkg:


    math.js (version 14.4.0, 186 kB, minified and gzipped) 
    and if needed the source map


Too large for you? Create your own custom bundle.

Web Service #

Math.js is available as a RESTful web service: https://api.mathjs.org

Extensions #

Here some notable extensions for mathjs:


  
    
      Extension
      Description
    
  
  
    
      mathsteps
      A step-by-step math solver library that is focused on pedagogy (how best to teach). The math problems it focuses on are pre-algebra and algebra problems involving simplifying expressions.
    
    
      mathjs‑expression‑parser
      This custom build of mathjs contains just the expression parser and basic arithmetic functions for numbers. About four times as small as the full mathjs library.
    
    
      mathjs-simple-integral
      Extends Math.js to be able to compute simple integrals.
    
    
      math.diff.js
      Symbolic differentiation plugin for Math.js
    
    
      postcss-math
      PostCSS plugin for making calculations with math.js
    
  


Other math libraries #

Here some other interesting JavaScript math libraries. Some can be imported into math.js using math.import.


  
    
      Extension
      Description
    
  
  
    
      math‑expression‑evaluator
      An extremely efficient, flexible and amazing evaluator for Math expression in Javascript.
    
    
      numbers.js
      Advanced Mathematics Library for Node.js and JavaScript
    
    
      numeric.js
      Numerical analysis in Javascript
    
    
      decimal.js
      An arbitrary-precision Decimal type for JavaScript. Used by mathjs for BigNumber support.
    
    
      ndarray
      Multidimensional arrays for JavaScript
    
    
      Algebrite
      Computer Algebra System in Javascript (Coffeescript)
    
    
      algebra.js
      Build, display, and solve algebraic equations
    
    
      Nerdamer
      Symbolic Math for Javascript
    
    
      numeral-js
      A javascript library for formatting and manipulating numbers
    
    
      Cortex Compute Engine
      The Cortex Compute Engine can parse LaTeX to MathJSON, serialize MathJSON to LaTeX, format, simplify and evaluate MathJSON expressions
    
  


History #

A changelog describing the changes with each release is available on the page History.

Browser support #

Math.js works on any ES5 compatible JavaScript engine: node.js, Chrome, Firefox, Safari, Edge, and IE11.

Though there is no official support for older browsers, math.js should still work on older browsers
when using the es5-shim.

Source code #

The source code of math.js is available on GitHub: https://github.com/josdejong/mathjs.

License #

Math.js is open source and licensed under the
Apache 2.0 License\n\n\n\nInstall #

Math.js can be installed via npm:

npm install mathjs


When installed globally with npm (using the -g option), math.js is available as a command line application mathjs, see documentation on Command Line Interface. Math.js ships with built-in TypeScript type definitions.

Download #

Math.js can be downloaded or linked from various content delivery networks:


  
    
      CDN
      Url
    
  
  
    
      unpkg
      https://unpkg.com/mathjs@14.4.0/
    
    
      cdnjs
      https://cdnjs.com/libraries/mathjs
        
    
      jsDelivr
      https://www.jsdelivr.com/package/npm/mathjs
    
    
      PageCDN 
      https://pagecdn.com/lib/mathjs
    
  


Or download the full bundle directly from unpkg:


    math.js (version 14.4.0, 186 kB, minified and gzipped) 
    and if needed the source map


Too large for you? Create your own custom bundle.

Web Service #

Math.js is available as a RESTful web service: https://api.mathjs.org

Extensions #

Here some notable extensions for mathjs:


  
    
      Extension
      Description
    
  
  
    
      mathsteps
      A step-by-step math solver library that is focused on pedagogy (how best to teach). The math problems it focuses on are pre-algebra and algebra problems involving simplifying expressions.
    
    
      mathjs‑expression‑parser
      This custom build of mathjs contains just the expression parser and basic arithmetic functions for numbers. About four times as small as the full mathjs library.
    
    
      mathjs-simple-integral
      Extends Math.js to be able to compute simple integrals.
    
    
      math.diff.js
      Symbolic differentiation plugin for Math.js
    
    
      postcss-math
      PostCSS plugin for making calculations with math.js
    
  


Other math libraries #

Here some other interesting JavaScript math libraries. Some can be imported into math.js using math.import.


  
    
      Extension
      Description
    
  
  
    
      math‑expression‑evaluator
      An extremely efficient, flexible and amazing evaluator for Math expression in Javascript.
    
    
      numbers.js
      Advanced Mathematics Library for Node.js and JavaScript
    
    
      numeric.js
      Numerical analysis in Javascript
    
    
      decimal.js
      An arbitrary-precision Decimal type for JavaScript. Used by mathjs for BigNumber support.
    
    
      ndarray
      Multidimensional arrays for JavaScript
    
    
      Algebrite
      Computer Algebra System in Javascript (Coffeescript)
    
    
      algebra.js
      Build, display, and solve algebraic equations
    
    
      Nerdamer
      Symbolic Math for Javascript
    
    
      numeral-js
      A javascript library for formatting and manipulating numbers
    
    
      Cortex Compute Engine
      The Cortex Compute Engine can parse LaTeX to MathJSON, serialize MathJSON to LaTeX, format, simplify and evaluate MathJSON expressions
    
  


History #

A changelog describing the changes with each release is available on the page History.

Browser support #

Math.js works on any ES5 compatible JavaScript engine: node.js, Chrome, Firefox, Safari, Edge, and IE11.

Though there is no official support for older browsers, math.js should still work on older browsers
when using the es5-shim.

Source code #

The source code of math.js is available on GitHub: https://github.com/josdejong/mathjs.

License #

Math.js is open source and licensed under the
Apache 2.0 License\n\n\n\nInstall #

Math.js can be installed via npm:

npm install mathjs


When installed globally with npm (using the -g option), math.js is available as a command line application mathjs, see documentation on Command Line Interface. Math.js ships with built-in TypeScript type definitions.

Download #

Math.js can be downloaded or linked from various content delivery networks:


  
    
      CDN
      Url
    
  
  
    
      unpkg
      https://unpkg.com/mathjs@14.4.0/
    
    
      cdnjs
      https://cdnjs.com/libraries/mathjs
        
    
      jsDelivr
      https://www.jsdelivr.com/package/npm/mathjs
    
    
      PageCDN 
      https://pagecdn.com/lib/mathjs
    
  


Or download the full bundle directly from unpkg:


    math.js (version 14.4.0, 186 kB, minified and gzipped) 
    and if needed the source map


Too large for you? Create your own custom bundle.

Web Service #

Math.js is available as a RESTful web service: https://api.mathjs.org

Extensions #

Here some notable extensions for mathjs:


  
    
      Extension
      Description
    
  
  
    
      mathsteps
      A step-by-step math solver library that is focused on pedagogy (how best to teach). The math problems it focuses on are pre-algebra and algebra problems involving simplifying expressions.
    
    
      mathjs‑expression‑parser
      This custom build of mathjs contains just the expression parser and basic arithmetic functions for numbers. About four times as small as the full mathjs library.
    
    
      mathjs-simple-integral
      Extends Math.js to be able to compute simple integrals.
    
    
      math.diff.js
      Symbolic differentiation plugin for Math.js
    
    
      postcss-math
      PostCSS plugin for making calculations with math.js
    
  


Other math libraries #

Here some other interesting JavaScript math libraries. Some can be imported into math.js using math.import.


  
    
      Extension
      Description
    
  
  
    
      math‑expression‑evaluator
      An extremely efficient, flexible and amazing evaluator for Math expression in Javascript.
    
    
      numbers.js
      Advanced Mathematics Library for Node.js and JavaScript
    
    
      numeric.js
      Numerical analysis in Javascript
    
    
      decimal.js
      An arbitrary-precision Decimal type for JavaScript. Used by mathjs for BigNumber support.
    
    
      ndarray
      Multidimensional arrays for JavaScript
    
    
      Algebrite
      Computer Algebra System in Javascript (Coffeescript)
    
    
      algebra.js
      Build, display, and solve algebraic equations
    
    
      Nerdamer
      Symbolic Math for Javascript
    
    
      numeral-js
      A javascript library for formatting and manipulating numbers
    
    
      Cortex Compute Engine
      The Cortex Compute Engine can parse LaTeX to MathJSON, serialize MathJSON to LaTeX, format, simplify and evaluate MathJSON expressions
    
  


History #

A changelog describing the changes with each release is available on the page History.

Browser support #

Math.js works on any ES5 compatible JavaScript engine: node.js, Chrome, Firefox, Safari, Edge, and IE11.

Though there is no official support for older browsers, math.js should still work on older browsers
when using the es5-shim.

Source code #

The source code of math.js is available on GitHub: https://github.com/josdejong/mathjs.

License #

Math.js is open source and licensed under the
Apache 2.0 License\n\n\n\nGetting Started #

This getting started describes how to install, load, and use math.js.

Install #

Math.js can be installed using various package managers like npm, or by just downloading the library from the website: https://mathjs.org/download.html.

To install via npm, run:

npm install mathjs


Other ways to install math.js are described on the website.

Load #

Math.js can be used in node.js and in the browser. The library must be loaded
and instantiated. When creating an instance, one can optionally provide
configuration options as described in
Configuration.

ES modules #

Load the functions you need and use them:

import { sqrt } from 'mathjs'

console.log(sqrt(-4).toString()) // 2i


To use lightweight, number only implementations of all functions:

import { sqrt } from 'mathjs/number'

console.log(sqrt(4).toString()) // 2
console.log(sqrt(-4).toString()) // NaN


You can create a mathjs instance allowing configuration and importing of external functions as follows:

import { create, all } from 'mathjs'

const config = { }
const math = create(all, config)

console.log(math.sqrt(-4).toString()) // 2i


How to optimize your bundle size using tree-shaking is described on the page
Custom bundling.

Node.js #

Load math.js in node.js (CommonJS module system):

const { sqrt } = require('mathjs')

console.log(sqrt(-4).toString()) // 2i


Browser #

Math.js can be loaded as a regular JavaScript file in the browser, use the global
variable math to access the libary once loaded:

<!DOCTYPE HTML>
<html>
<head>
  <script src="math.js" type="text/javascript"></script>
</head>
<body>
  <script type="text/javascript">
    console.log(math.sqrt(-4).toString()) // 2i
  </script>
</body>
</html>


Use #

Math.js can be used similar to JavaScript’s built-in Math library. Besides that,
math.js can evaluate expressions (see Expressions) and
supports chaining (see Chaining).

The example code below shows how to use math.js. More examples can be found in the
section Examples.

// functions and constants
math.round(math.e, 3)                // 2.718
math.atan2(3, -3) / math.pi          // 0.75
math.log(10000, 10)                  // 4
math.sqrt(-4)                        // 2i
math.pow([[-1, 2], [3, 1]], 2)       // [[7, 0], [0, 7]]

// expressions
math.evaluate('12 / (2.3 + 0.7)')    // 4
math.evaluate('12.7 cm to inch')     // 5 inch
math.evaluate('sin(45 deg) ^ 2')     // 0.5
math.evaluate('9 / 3 + 2i')          // 3 + 2i
math.evaluate('det([-1, 2; 3, 1])')  // -7

// chained operations
math.chain(3)
    .add(4)
    .multiply(2)
    .done() // 14


Next #

To learn more about math.js, check out the available documentation and examples:


  Documentation
  Examples\n\n\n\nGetting Started #

This getting started describes how to install, load, and use math.js.

Install #

Math.js can be installed using various package managers like npm, or by just downloading the library from the website: https://mathjs.org/download.html.

To install via npm, run:

npm install mathjs


Other ways to install math.js are described on the website.

Load #

Math.js can be used in node.js and in the browser. The library must be loaded
and instantiated. When creating an instance, one can optionally provide
configuration options as described in
Configuration.

ES modules #

Load the functions you need and use them:

import { sqrt } from 'mathjs'

console.log(sqrt(-4).toString()) // 2i


To use lightweight, number only implementations of all functions:

import { sqrt } from 'mathjs/number'

console.log(sqrt(4).toString()) // 2
console.log(sqrt(-4).toString()) // NaN


You can create a mathjs instance allowing configuration and importing of external functions as follows:

import { create, all } from 'mathjs'

const config = { }
const math = create(all, config)

console.log(math.sqrt(-4).toString()) // 2i


How to optimize your bundle size using tree-shaking is described on the page
Custom bundling.

Node.js #

Load math.js in node.js (CommonJS module system):

const { sqrt } = require('mathjs')

console.log(sqrt(-4).toString()) // 2i


Browser #

Math.js can be loaded as a regular JavaScript file in the browser, use the global
variable math to access the libary once loaded:

<!DOCTYPE HTML>
<html>
<head>
  <script src="math.js" type="text/javascript"></script>
</head>
<body>
  <script type="text/javascript">
    console.log(math.sqrt(-4).toString()) // 2i
  </script>
</body>
</html>


Use #

Math.js can be used similar to JavaScript’s built-in Math library. Besides that,
math.js can evaluate expressions (see Expressions) and
supports chaining (see Chaining).

The example code below shows how to use math.js. More examples can be found in the
section Examples.

// functions and constants
math.round(math.e, 3)                // 2.718
math.atan2(3, -3) / math.pi          // 0.75
math.log(10000, 10)                  // 4
math.sqrt(-4)                        // 2i
math.pow([[-1, 2], [3, 1]], 2)       // [[7, 0], [0, 7]]

// expressions
math.evaluate('12 / (2.3 + 0.7)')    // 4
math.evaluate('12.7 cm to inch')     // 5 inch
math.evaluate('sin(45 deg) ^ 2')     // 0.5
math.evaluate('9 / 3 + 2i')          // 3 + 2i
math.evaluate('det([-1, 2; 3, 1])')  // -7

// chained operations
math.chain(3)
    .add(4)
    .multiply(2)
    .done() // 14


Next #

To learn more about math.js, check out the available documentation and examples:


  Documentation
  Examples\n\n\n\nGetting Started #

This getting started describes how to install, load, and use math.js.

Install #

Math.js can be installed using various package managers like npm, or by just downloading the library from the website: https://mathjs.org/download.html.

To install via npm, run:

npm install mathjs


Other ways to install math.js are described on the website.

Load #

Math.js can be used in node.js and in the browser. The library must be loaded
and instantiated. When creating an instance, one can optionally provide
configuration options as described in
Configuration.

ES modules #

Load the functions you need and use them:

import { sqrt } from 'mathjs'

console.log(sqrt(-4).toString()) // 2i


To use lightweight, number only implementations of all functions:

import { sqrt } from 'mathjs/number'

console.log(sqrt(4).toString()) // 2
console.log(sqrt(-4).toString()) // NaN


You can create a mathjs instance allowing configuration and importing of external functions as follows:

import { create, all } from 'mathjs'

const config = { }
const math = create(all, config)

console.log(math.sqrt(-4).toString()) // 2i


How to optimize your bundle size using tree-shaking is described on the page
Custom bundling.

Node.js #

Load math.js in node.js (CommonJS module system):

const { sqrt } = require('mathjs')

console.log(sqrt(-4).toString()) // 2i


Browser #

Math.js can be loaded as a regular JavaScript file in the browser, use the global
variable math to access the libary once loaded:

<!DOCTYPE HTML>
<html>
<head>
  <script src="math.js" type="text/javascript"></script>
</head>
<body>
  <script type="text/javascript">
    console.log(math.sqrt(-4).toString()) // 2i
  </script>
</body>
</html>


Use #

Math.js can be used similar to JavaScript’s built-in Math library. Besides that,
math.js can evaluate expressions (see Expressions) and
supports chaining (see Chaining).

The example code below shows how to use math.js. More examples can be found in the
section Examples.

// functions and constants
math.round(math.e, 3)                // 2.718
math.atan2(3, -3) / math.pi          // 0.75
math.log(10000, 10)                  // 4
math.sqrt(-4)                        // 2i
math.pow([[-1, 2], [3, 1]], 2)       // [[7, 0], [0, 7]]

// expressions
math.evaluate('12 / (2.3 + 0.7)')    // 4
math.evaluate('12.7 cm to inch')     // 5 inch
math.evaluate('sin(45 deg) ^ 2')     // 0.5
math.evaluate('9 / 3 + 2i')          // 3 + 2i
math.evaluate('det([-1, 2; 3, 1])')  // -7

// chained operations
math.chain(3)
    .add(4)
    .multiply(2)
    .done() // 14


Next #

To learn more about math.js, check out the available documentation and examples:


  Documentation
  Examples\n\n\n\nGetting Started #

This getting started describes how to install, load, and use math.js.

Install #

Math.js can be installed using various package managers like npm, or by just downloading the library from the website: https://mathjs.org/download.html.

To install via npm, run:

npm install mathjs


Other ways to install math.js are described on the website.

Load #

Math.js can be used in node.js and in the browser. The library must be loaded
and instantiated. When creating an instance, one can optionally provide
configuration options as described in
Configuration.

ES modules #

Load the functions you need and use them:

import { sqrt } from 'mathjs'

console.log(sqrt(-4).toString()) // 2i


To use lightweight, number only implementations of all functions:

import { sqrt } from 'mathjs/number'

console.log(sqrt(4).toString()) // 2
console.log(sqrt(-4).toString()) // NaN


You can create a mathjs instance allowing configuration and importing of external functions as follows:

import { create, all } from 'mathjs'

const config = { }
const math = create(all, config)

console.log(math.sqrt(-4).toString()) // 2i


How to optimize your bundle size using tree-shaking is described on the page
Custom bundling.

Node.js #

Load math.js in node.js (CommonJS module system):

const { sqrt } = require('mathjs')

console.log(sqrt(-4).toString()) // 2i


Browser #

Math.js can be loaded as a regular JavaScript file in the browser, use the global
variable math to access the libary once loaded:

<!DOCTYPE HTML>
<html>
<head>
  <script src="math.js" type="text/javascript"></script>
</head>
<body>
  <script type="text/javascript">
    console.log(math.sqrt(-4).toString()) // 2i
  </script>
</body>
</html>


Use #

Math.js can be used similar to JavaScript’s built-in Math library. Besides that,
math.js can evaluate expressions (see Expressions) and
supports chaining (see Chaining).

The example code below shows how to use math.js. More examples can be found in the
section Examples.

// functions and constants
math.round(math.e, 3)                // 2.718
math.atan2(3, -3) / math.pi          // 0.75
math.log(10000, 10)                  // 4
math.sqrt(-4)                        // 2i
math.pow([[-1, 2], [3, 1]], 2)       // [[7, 0], [0, 7]]

// expressions
math.evaluate('12 / (2.3 + 0.7)')    // 4
math.evaluate('12.7 cm to inch')     // 5 inch
math.evaluate('sin(45 deg) ^ 2')     // 0.5
math.evaluate('9 / 3 + 2i')          // 3 + 2i
math.evaluate('det([-1, 2; 3, 1])')  // -7

// chained operations
math.chain(3)
    .add(4)
    .multiply(2)
    .done() // 14


Next #

To learn more about math.js, check out the available documentation and examples:


  Documentation
  Examples\n\n\n\nGetting Started #

This getting started describes how to install, load, and use math.js.

Install #

Math.js can be installed using various package managers like npm, or by just downloading the library from the website: https://mathjs.org/download.html.

To install via npm, run:

npm install mathjs


Other ways to install math.js are described on the website.

Load #

Math.js can be used in node.js and in the browser. The library must be loaded
and instantiated. When creating an instance, one can optionally provide
configuration options as described in
Configuration.

ES modules #

Load the functions you need and use them:

import { sqrt } from 'mathjs'

console.log(sqrt(-4).toString()) // 2i


To use lightweight, number only implementations of all functions:

import { sqrt } from 'mathjs/number'

console.log(sqrt(4).toString()) // 2
console.log(sqrt(-4).toString()) // NaN


You can create a mathjs instance allowing configuration and importing of external functions as follows:

import { create, all } from 'mathjs'

const config = { }
const math = create(all, config)

console.log(math.sqrt(-4).toString()) // 2i


How to optimize your bundle size using tree-shaking is described on the page
Custom bundling.

Node.js #

Load math.js in node.js (CommonJS module system):

const { sqrt } = require('mathjs')

console.log(sqrt(-4).toString()) // 2i


Browser #

Math.js can be loaded as a regular JavaScript file in the browser, use the global
variable math to access the libary once loaded:

<!DOCTYPE HTML>
<html>
<head>
  <script src="math.js" type="text/javascript"></script>
</head>
<body>
  <script type="text/javascript">
    console.log(math.sqrt(-4).toString()) // 2i
  </script>
</body>
</html>


Use #

Math.js can be used similar to JavaScript’s built-in Math library. Besides that,
math.js can evaluate expressions (see Expressions) and
supports chaining (see Chaining).

The example code below shows how to use math.js. More examples can be found in the
section Examples.

// functions and constants
math.round(math.e, 3)                // 2.718
math.atan2(3, -3) / math.pi          // 0.75
math.log(10000, 10)                  // 4
math.sqrt(-4)                        // 2i
math.pow([[-1, 2], [3, 1]], 2)       // [[7, 0], [0, 7]]

// expressions
math.evaluate('12 / (2.3 + 0.7)')    // 4
math.evaluate('12.7 cm to inch')     // 5 inch
math.evaluate('sin(45 deg) ^ 2')     // 0.5
math.evaluate('9 / 3 + 2i')          // 3 + 2i
math.evaluate('det([-1, 2; 3, 1])')  // -7

// chained operations
math.chain(3)
    .add(4)
    .multiply(2)
    .done() // 14


Next #

To learn more about math.js, check out the available documentation and examples:


  Documentation
  Examples\n\n\n\nGetting Started #

This getting started describes how to install, load, and use math.js.

Install #

Math.js can be installed using various package managers like npm, or by just downloading the library from the website: https://mathjs.org/download.html.

To install via npm, run:

npm install mathjs


Other ways to install math.js are described on the website.

Load #

Math.js can be used in node.js and in the browser. The library must be loaded
and instantiated. When creating an instance, one can optionally provide
configuration options as described in
Configuration.

ES modules #

Load the functions you need and use them:

import { sqrt } from 'mathjs'

console.log(sqrt(-4).toString()) // 2i


To use lightweight, number only implementations of all functions:

import { sqrt } from 'mathjs/number'

console.log(sqrt(4).toString()) // 2
console.log(sqrt(-4).toString()) // NaN


You can create a mathjs instance allowing configuration and importing of external functions as follows:

import { create, all } from 'mathjs'

const config = { }
const math = create(all, config)

console.log(math.sqrt(-4).toString()) // 2i


How to optimize your bundle size using tree-shaking is described on the page
Custom bundling.

Node.js #

Load math.js in node.js (CommonJS module system):

const { sqrt } = require('mathjs')

console.log(sqrt(-4).toString()) // 2i


Browser #

Math.js can be loaded as a regular JavaScript file in the browser, use the global
variable math to access the libary once loaded:

<!DOCTYPE HTML>
<html>
<head>
  <script src="math.js" type="text/javascript"></script>
</head>
<body>
  <script type="text/javascript">
    console.log(math.sqrt(-4).toString()) // 2i
  </script>
</body>
</html>


Use #

Math.js can be used similar to JavaScript’s built-in Math library. Besides that,
math.js can evaluate expressions (see Expressions) and
supports chaining (see Chaining).

The example code below shows how to use math.js. More examples can be found in the
section Examples.

// functions and constants
math.round(math.e, 3)                // 2.718
math.atan2(3, -3) / math.pi          // 0.75
math.log(10000, 10)                  // 4
math.sqrt(-4)                        // 2i
math.pow([[-1, 2], [3, 1]], 2)       // [[7, 0], [0, 7]]

// expressions
math.evaluate('12 / (2.3 + 0.7)')    // 4
math.evaluate('12.7 cm to inch')     // 5 inch
math.evaluate('sin(45 deg) ^ 2')     // 0.5
math.evaluate('9 / 3 + 2i')          // 3 + 2i
math.evaluate('det([-1, 2; 3, 1])')  // -7

// chained operations
math.chain(3)
    .add(4)
    .multiply(2)
    .done() // 14


Next #

To learn more about math.js, check out the available documentation and examples:


  Documentation
  Examples\n\n\n\nGetting Started #

This getting started describes how to install, load, and use math.js.

Install #

Math.js can be installed using various package managers like npm, or by just downloading the library from the website: https://mathjs.org/download.html.

To install via npm, run:

npm install mathjs


Other ways to install math.js are described on the website.

Load #

Math.js can be used in node.js and in the browser. The library must be loaded
and instantiated. When creating an instance, one can optionally provide
configuration options as described in
Configuration.

ES modules #

Load the functions you need and use them:

import { sqrt } from 'mathjs'

console.log(sqrt(-4).toString()) // 2i


To use lightweight, number only implementations of all functions:

import { sqrt } from 'mathjs/number'

console.log(sqrt(4).toString()) // 2
console.log(sqrt(-4).toString()) // NaN


You can create a mathjs instance allowing configuration and importing of external functions as follows:

import { create, all } from 'mathjs'

const config = { }
const math = create(all, config)

console.log(math.sqrt(-4).toString()) // 2i


How to optimize your bundle size using tree-shaking is described on the page
Custom bundling.

Node.js #

Load math.js in node.js (CommonJS module system):

const { sqrt } = require('mathjs')

console.log(sqrt(-4).toString()) // 2i


Browser #

Math.js can be loaded as a regular JavaScript file in the browser, use the global
variable math to access the libary once loaded:

<!DOCTYPE HTML>
<html>
<head>
  <script src="math.js" type="text/javascript"></script>
</head>
<body>
  <script type="text/javascript">
    console.log(math.sqrt(-4).toString()) // 2i
  </script>
</body>
</html>


Use #

Math.js can be used similar to JavaScript’s built-in Math library. Besides that,
math.js can evaluate expressions (see Expressions) and
supports chaining (see Chaining).

The example code below shows how to use math.js. More examples can be found in the
section Examples.

// functions and constants
math.round(math.e, 3)                // 2.718
math.atan2(3, -3) / math.pi          // 0.75
math.log(10000, 10)                  // 4
math.sqrt(-4)                        // 2i
math.pow([[-1, 2], [3, 1]], 2)       // [[7, 0], [0, 7]]

// expressions
math.evaluate('12 / (2.3 + 0.7)')    // 4
math.evaluate('12.7 cm to inch')     // 5 inch
math.evaluate('sin(45 deg) ^ 2')     // 0.5
math.evaluate('9 / 3 + 2i')          // 3 + 2i
math.evaluate('det([-1, 2; 3, 1])')  // -7

// chained operations
math.chain(3)
    .add(4)
    .multiply(2)
    .done() // 14


Next #

To learn more about math.js, check out the available documentation and examples:


  Documentation
  Examples\n\n\n\nGetting Started #

This getting started describes how to install, load, and use math.js.

Install #

Math.js can be installed using various package managers like npm, or by just downloading the library from the website: https://mathjs.org/download.html.

To install via npm, run:

npm install mathjs


Other ways to install math.js are described on the website.

Load #

Math.js can be used in node.js and in the browser. The library must be loaded
and instantiated. When creating an instance, one can optionally provide
configuration options as described in
Configuration.

ES modules #

Load the functions you need and use them:

import { sqrt } from 'mathjs'

console.log(sqrt(-4).toString()) // 2i


To use lightweight, number only implementations of all functions:

import { sqrt } from 'mathjs/number'

console.log(sqrt(4).toString()) // 2
console.log(sqrt(-4).toString()) // NaN


You can create a mathjs instance allowing configuration and importing of external functions as follows:

import { create, all } from 'mathjs'

const config = { }
const math = create(all, config)

console.log(math.sqrt(-4).toString()) // 2i


How to optimize your bundle size using tree-shaking is described on the page
Custom bundling.

Node.js #

Load math.js in node.js (CommonJS module system):

const { sqrt } = require('mathjs')

console.log(sqrt(-4).toString()) // 2i


Browser #

Math.js can be loaded as a regular JavaScript file in the browser, use the global
variable math to access the libary once loaded:

<!DOCTYPE HTML>
<html>
<head>
  <script src="math.js" type="text/javascript"></script>
</head>
<body>
  <script type="text/javascript">
    console.log(math.sqrt(-4).toString()) // 2i
  </script>
</body>
</html>


Use #

Math.js can be used similar to JavaScript’s built-in Math library. Besides that,
math.js can evaluate expressions (see Expressions) and
supports chaining (see Chaining).

The example code below shows how to use math.js. More examples can be found in the
section Examples.

// functions and constants
math.round(math.e, 3)                // 2.718
math.atan2(3, -3) / math.pi          // 0.75
math.log(10000, 10)                  // 4
math.sqrt(-4)                        // 2i
math.pow([[-1, 2], [3, 1]], 2)       // [[7, 0], [0, 7]]

// expressions
math.evaluate('12 / (2.3 + 0.7)')    // 4
math.evaluate('12.7 cm to inch')     // 5 inch
math.evaluate('sin(45 deg) ^ 2')     // 0.5
math.evaluate('9 / 3 + 2i')          // 3 + 2i
math.evaluate('det([-1, 2; 3, 1])')  // -7

// chained operations
math.chain(3)
    .add(4)
    .multiply(2)
    .done() // 14


Next #

To learn more about math.js, check out the available documentation and examples:


  Documentation
  Examples\n\n\n\nAlgebra

File: algebra.js

// algebra
//
// math.js has support for symbolic computation (CAS). It can parse
// expressions in an expression tree and do algebraic operations like
// simplification and derivation on this tree.
import { simplify, parse, derivative } from 'mathjs'

// simplify an expression
console.log('simplify expressions')
console.log(simplify('3 + 2 / 4').toString()) // '7 / 2'
console.log(simplify('2x + 3x').toString()) // '5 * x'
console.log(simplify('2 * 3 * x', { x: 4 }).toString()) // '24'
console.log(simplify('x^2 + x + 3 + x^2').toString()) // '2 * x ^ 2 + x + 3'
console.log(simplify('x * y * -x / (x ^ 2)').toString()) // '-y'

// work with an expression tree, evaluate results
const f = parse('2x + x')
const simplified = simplify(f)
console.log(simplified.toString()) // '3 * x'
console.log(simplified.evaluate({ x: 4 })) // 12
console.log()

// calculate a derivative
console.log('calculate derivatives')
console.log(derivative('2x^2 + 3x + 4', 'x').toString()) // '4 * x + 3'
console.log(derivative('sin(2x)', 'x').toString()) // '2 * cos(2 * x)'

// work with an expression tree, evaluate results
const h = parse('x^2 + x')
const dh = derivative(h, 'x')
console.log(dh.toString()) // '2 * x + 1'
console.log(dh.evaluate({ x: 3 })) // '7'\n\n\n\nBasic usage

File: basic_usage.js

// basic usage
import {
  add,
  atan2,
  chain,
  derivative,
  e,
  evaluate,
  format,
  log,
  matrix,
  multiply,
  pi,
  pow,
  round,
  sqrt,
  subtract,
  unit
} from 'mathjs'

// functions and constants
console.log('functions and constants')
print(round(e, 3)) // 2.718
print(atan2(3, -3) / pi) // 0.75
print(log(10000, 10)) // 4
print(sqrt(-4)) // 2i
print(pow([[-1, 2], [3, 1]], 2)) // [[7, 0], [0, 7]]
print(derivative('x^2 + x', 'x')) // 2 * x + 1
console.log()

// expressions
console.log('expressions')
print(evaluate('1.2 * (2 + 4.5)')) // 7.8
print(evaluate('12.7 cm to inch')) // 5 inch
print(evaluate('sin(45 deg) ^ 2')) // 0.5
print(evaluate('9 / 3 + 2i')) // 3 + 2i
print(evaluate('det([-1, 2; 3, 1])')) // -7
console.log()

// chained operations
console.log('chained operations')
const a = chain(3)
  .add(4)
  .multiply(2)
  .done()
print(a) // 14
console.log()

// mixed use of different data types in functions
console.log('mixed use of data types')
print(add(4, [5, 6])) // number + Array, [9, 10]
print(multiply(unit('5 mm'), 3)) // Unit * number,  15 mm
print(subtract([2, 3, 4], 5)) // Array - number, [-3, -2, -1]
print(add(matrix([2, 3]), [4, 5])) // Matrix + Array, [6, 8]
console.log()

/**
 * Helper function to output a value in the console. Value will be formatted.
 * @param {*} value
 */
function print (value) {
  const precision = 14
  console.log(format(value, precision))
}\n\n\n\nBignumbers

File: bignumbers.js

// BigNumbers
import { create, all } from 'mathjs'

// configure the default type of numbers as BigNumbers
const config = {
  // Default type of number
  // Available options: 'number' (default), 'BigNumber', or 'Fraction'
  number: 'BigNumber',

  // Number of significant digits for BigNumbers
  precision: 20
}
const math = create(all, config)

console.log('round-off errors with numbers')
print(math.add(0.1, 0.2)) // number, 0.30000000000000004
print(math.divide(0.3, 0.2)) // number, 1.4999999999999998
console.log()

console.log('no round-off errors with BigNumbers')
print(math.add(math.bignumber(0.1), math.bignumber(0.2))) // BigNumber, 0.3
print(math.divide(math.bignumber(0.3), math.bignumber(0.2))) // BigNumber, 1.5
console.log()

console.log('create BigNumbers from strings when exceeding the range of a number')
print(math.bignumber(1.2e+500)) // BigNumber, Infinity      WRONG
print(math.bignumber('1.2e+500')) // BigNumber, 1.2e+500
console.log()

console.log('BigNumbers still have a limited precision and are no silve bullet')
const third = math.divide(math.bignumber(1), math.bignumber(3))
const total = math.add(third, third, third)
print(total) // BigNumber, 0.99999999999999999999
console.log()

// one can work conveniently with BigNumbers using the expression parser.
// note though that BigNumbers are only supported in arithmetic functions
console.log('use BigNumbers in the expression parser')
print(math.evaluate('0.1 + 0.2')) // BigNumber, 0.3
print(math.evaluate('0.3 / 0.2')) // BigNumber, 1.5
console.log()

/**
 * Helper function to output a value in the console. Value will be formatted.
 * @param {*} value
 */
function print (value) {
  console.log(math.format(value))
}\n\n\n\nChaining

File: chaining.js

// chaining
import { chain, format, index, pi } from 'mathjs'

// create a chained operation using the function `chain(value)`
// end a chain using done(). Let's calculate (3 + 4) * 2
const a = chain(3)
  .add(4)
  .multiply(2)
  .done()
print(a) // 14

// Another example, calculate square(sin(pi / 4))
const b = chain(pi)
  .divide(4)
  .sin()
  .square()
  .done()
print(b) // 0.5

// A chain has a few special methods: done, toString, valueOf, get, and set.
// these are demonstrated in the following examples

// toString will return a string representation of the chain's value
const myChain = chain(2).divide(3)
const str = myChain.toString()
print(str) // "0.6666666666666666"

// a chain has a function .valueOf(), which returns the value hold by the chain.
// This allows using it in regular operations. The function valueOf() acts the
// same as function done().
print(myChain.valueOf()) // 0.66666666666667
print(myChain + 2) // 2.6666666666667

// the function subset can be used to get or replace sub matrices
const array = [[1, 2], [3, 4]]
const v = chain(array)
  .subset(index(1, 0))
  .done()
print(v) // 3

const m = chain(array)
  .subset(index(0, 0), 8)
  .multiply(3)
  .done()
print(m) // [[24, 6], [9, 12]]

/**
 * Helper function to output a value in the console. Value will be formatted.
 * @param {*} value
 */
function print (value) {
  const precision = 14
  console.log(format(value, precision))
}\n\n\n\nComplex numbers

File: complex_numbers.js

// complex numbers
import { complex, add, multiply, sin, sqrt, pi, equal, sort, format } from 'mathjs'

// create a complex number with a numeric real and complex part
console.log('create and manipulate complex numbers')
const a = complex(2, 3)
print(a) // 2 + 3i

// read the real and complex parts of the complex number
print(a.re) // 2
print(a.im) // 3

// clone a complex value
const clone = a.clone()
print(clone) // 2 + 3i

// adjust the complex value
a.re = 5
print(a) // 5 + 3i

// create a complex number by providing a string with real and complex parts
const b = complex('3-7i')
print(b) // 3 - 7i
console.log()

// perform operations with complex numbers
console.log('perform operations')
print(add(a, b)) // 8 - 4i
print(multiply(a, b)) // 36 - 26i
print(sin(a)) // -9.6541254768548 + 2.8416922956064i

// some operations will return a complex number depending on the arguments
print(sqrt(4)) // 2
print(sqrt(-4)) // 2i
console.log()

// create a complex number from polar coordinates
console.log('create complex numbers with polar coordinates')
const c = complex({ r: sqrt(2), phi: pi / 4 })
print(c) // 1 + i

// get polar coordinates of a complex number
const d = complex(3, 4)
console.log(d.abs(), d.arg()) // radius = 5, phi = 0.9272952180016122
console.log()

// comparision operations
// note that there is no mathematical ordering defined for complex numbers
// we can only check equality. To sort a list with complex numbers,
// the natural sorting can be used
console.log('\ncomparision and sorting operations')
console.log('equal', equal(a, b)) // returns false
const values = [a, b, c]
console.log('values:', format(values, 14)) // [5 + 3i, 3 - 7i, 1 + i]
sort(values, 'natural')
console.log('sorted:', format(values, 14)) // [1 + i, 3 - 7i, 5 + 3i]

/**
 * Helper function to output a value in the console. Value will be formatted.
 * @param {*} value
 */
function print (value) {
  const precision = 14
  console.log(format(value, precision))
}\n\n\n\nExpressions

File: expressions.js

/**
 * Expressions can be evaluated in various ways:
 *
 * 1. using the function evaluate
 * 2. using the function parse
 * 3. using a parser. A parser contains functions evaluate and parse,
 *    and keeps a scope with assigned variables in memory
 */
import { compile, evaluate, format, parse, parser } from 'mathjs'

// 1. using the function evaluate
//
// Function `evaluate` accepts a single expression or an array with
// expressions as first argument, and has an optional second argument
// containing a scope with variables and functions. The scope is a regular
// JavaScript Object. The scope will be used to resolve symbols, and to write
// assigned variables or function.
console.log('1. USING FUNCTION MATH.EVAL')

// evaluate expressions
console.log('\nevaluate expressions')
print(evaluate('sqrt(3^2 + 4^2)')) // 5
print(evaluate('sqrt(-4)')) // 2i
print(evaluate('2 inch to cm')) // 5.08 cm
print(evaluate('cos(45 deg)')) // 0.70711

// evaluate multiple expressions at once
console.log('\nevaluate multiple expressions at once')
print(evaluate([
  'f = 3',
  'g = 4',
  'f * g'
])) // [3, 4, 12]

// provide a scope (just a regular JavaScript Object)
console.log('\nevaluate expressions providing a scope with variables and functions')
const scope = {
  a: 3,
  b: 4
}

// variables can be read from the scope
print(evaluate('a * b', scope)) // 12

// variable assignments are written to the scope
print(evaluate('c = 2.3 + 4.5', scope)) // 6.8
print(scope.c) // 6.8

// scope can contain both variables and functions
scope.hello = function (name) {
  return 'hello, ' + name + '!'
}
print(evaluate('hello("hero")', scope)) // "hello, hero!"

// define a function as an expression
const f = evaluate('f(x) = x ^ a', scope)
print(f(2)) // 8
print(scope.f(2)) // 8

// 2. using function parse
//
// Function `parse` parses expressions into a node tree. The syntax is
// similar to function `evaluate`.
// Function `parse` accepts a single expression or an array with
// expressions as first argument. The function returns a node tree, which
// then can be compiled against math, and then evaluated against an (optional
// scope. This scope is a regular JavaScript Object. The scope will be used
// to resolve symbols, and to write assigned variables or function.
console.log('\n2. USING FUNCTION MATH.PARSE')

// parse an expression
console.log('\nparse an expression into a node tree')
const node1 = parse('sqrt(3^2 + 4^2)')
print(node1.toString()) // "sqrt((3 ^ 2) + (4 ^ 2))"

// compile and evaluate the compiled code
// you could also do this in two steps: node1.compile().evaluate()
print(node1.evaluate()) // 5

// provide a scope
console.log('\nprovide a scope')
const node2 = parse('x^a')
const code2 = node2.compile()
print(node2.toString()) // "x ^ a"
const scope2 = {
  x: 3,
  a: 2
}
print(code2.evaluate(scope2)) // 9

// change a value in the scope and re-evaluate the node
scope2.a = 3
print(code2.evaluate(scope2)) // 27

// 3. using function compile
//
// Function `compile` compiles expressions into a node tree. The syntax is
// similar to function `evaluate`.
// Function `compile` accepts a single expression or an array with
// expressions as first argument, and returns an object with a function evaluate
// to evaluate the compiled expression. On evaluation, an optional scope can
// be provided. This scope will be used to resolve symbols, and to write
// assigned variables or function.
console.log('\n3. USING FUNCTION MATH.COMPILE')

// parse an expression
console.log('\ncompile an expression')
const code3 = compile('sqrt(3^2 + 4^2)')

// evaluate the compiled code
print(code3.evaluate()) // 5

// provide a scope for the variable assignment
console.log('\nprovide a scope')
const code4 = compile('a = a + 3')
const scope3 = {
  a: 7
}
code4.evaluate(scope3)
print(scope3.a) // 10

// 4. using a parser
//
// In addition to the static functions `evaluate` and `parse`, js
// contains a parser with functions `evaluate` and `parse`, which automatically
// keeps a scope with assigned variables in memory. The parser also contains
// some convenience methods to get, set, and remove variables from memory.
console.log('\n4. USING A PARSER')
const myParser = parser()

// evaluate with parser
console.log('\nevaluate expressions')
print(myParser.evaluate('sqrt(3^2 + 4^2)')) // 5
print(myParser.evaluate('sqrt(-4)')) // 2i
print(myParser.evaluate('2 inch to cm')) // 5.08 cm
print(myParser.evaluate('cos(45 deg)')) // 0.70710678118655

// define variables and functions
console.log('\ndefine variables and functions')
print(myParser.evaluate('x = 7 / 2')) // 3.5
print(myParser.evaluate('x + 3')) // 6.5
print(myParser.evaluate('f2(x, y) = x^y')) // f2(x, y)
print(myParser.evaluate('f2(2, 3)')) // 8

// manipulate matrices
// Note that matrix indexes in the expression parser are one-based with the
// upper-bound included. On a JavaScript level however, js uses zero-based
// indexes with an excluded upper-bound.
console.log('\nmanipulate matrices')
print(myParser.evaluate('k = [1, 2; 3, 4]')) // [[1, 2], [3, 4]]
print(myParser.evaluate('l = zeros(2, 2)')) // [[0, 0], [0, 0]]
print(myParser.evaluate('l[1, 1:2] = [5, 6]')) // [5, 6]
print(myParser.evaluate('l')) // [[5, 6], [0, 0]]
print(myParser.evaluate('l[2, :] = [7, 8]')) // [7, 8]
print(myParser.evaluate('l')) // [[5, 6], [7, 8]]
print(myParser.evaluate('m = k * l')) // [[19, 22], [43, 50]]
print(myParser.evaluate('n = m[2, 1]')) // 43
print(myParser.evaluate('n = m[:, 1]')) // [[19], [43]]

// get and set variables and functions
console.log('\nget and set variables and function in the scope of the parser')
const x = myParser.get('x')
console.log('x =', x) // x = 3.5
const f2 = myParser.get('f2')
console.log('f2 =', format(f2)) // f2 = f2(x, y)
const h = f2(3, 3)
console.log('h =', h) // h = 27

myParser.set('i', 500)
print(myParser.evaluate('i / 2')) // 250
myParser.set('hello', function (name) {
  return 'hello, ' + name + '!'
})
print(myParser.evaluate('hello("hero")')) // "hello, hero!"

// clear defined functions and variables
myParser.clear()

/**
 * Helper function to output a value in the console. Value will be formatted.
 * @param {*} value
 */
function print (value) {
  const precision = 14
  console.log(format(value, precision))
}\n\n\n\nFractions

File: fractions.js

// Fractions
import { create, all } from 'mathjs'

// configure the default type of numbers as Fractions
const config = {
  // Default type of number
  // Available options: 'number' (default), 'BigNumber', or 'Fraction'
  number: 'Fraction'
}

// create a mathjs instance with everything included
const math = create(all, config)

console.log('basic usage')
printRatio(math.fraction(0.125)) // Fraction, 1/8
printRatio(math.fraction(0.32)) // Fraction, 8/25
printRatio(math.fraction('1/3')) // Fraction, 1/3
printRatio(math.fraction('0.(3)')) // Fraction, 1/3
printRatio(math.fraction(2, 3)) // Fraction, 2/3
printRatio(math.fraction('0.(285714)')) // Fraction, 2/7
console.log()

console.log('round-off errors with numbers')
print(math.add(0.1, 0.2)) // number, 0.30000000000000004
print(math.divide(0.3, 0.2)) // number, 1.4999999999999998
console.log()

console.log('no round-off errors with fractions :)')
print(math.add(math.fraction(0.1), math.fraction(0.2))) // Fraction, 0.3
print(math.divide(math.fraction(0.3), math.fraction(0.2))) // Fraction, 1.5
console.log()

console.log('represent an infinite number of repeating digits')
print(math.fraction('1/3')) // Fraction, 0.(3)
print(math.fraction('2/7')) // Fraction, 0.(285714)
print(math.fraction('23/11')) // Fraction, 2.(09)
console.log()

// one can work conveniently with fractions using the expression parser.
// note though that Fractions are only supported by basic arithmetic functions
console.log('use fractions in the expression parser')
printRatio(math.evaluate('0.1 + 0.2')) // Fraction,  3/10
printRatio(math.evaluate('0.3 / 0.2')) // Fraction,  3/2
printRatio(math.evaluate('23 / 11')) // Fraction, 23/11
console.log()

// output formatting
console.log('output formatting of fractions')
const a = math.fraction('2/3')
console.log(math.format(a)) // Fraction,  2/3
console.log(math.format(a, { fraction: 'ratio' })) // Fraction,  2/3
console.log(math.format(a, { fraction: 'decimal' })) // Fraction,  0.(6)
console.log(a.toString()) // Fraction,  0.(6)
console.log()

/**
 * Helper function to output a value in the console.
 * Fractions will be formatted as ratio, like '1/3'.
 * @param {*} value
 */
function printRatio (value) {
  console.log(math.format(value, { fraction: 'ratio' }))
}

/**
 * Helper function to output a value in the console.
 * Fractions will be formatted as decimal, like '0.(3)'.
 * @param {*} value
 */
function print (value) {
  console.log(math.format(value, { fraction: 'decimal' }))
}\n\n\n\nImport

File: import.js

/**
 * Math.js can easily be extended with functions and variables using the
 * `import` function. The function `import` accepts a module name or an object
 * containing functions and variables.
 */
import { create, all } from 'mathjs'
const math = create(all)

/**
 * Define new functions and variables
 */
math.import({
  myConstant: 42,
  hello: function (name) {
    return 'hello, ' + name + '!'
  }
})

// defined methods can be used in both JavaScript as well as the parser
print(math.myConstant * 2) // 84
print(math.hello('user')) // 'hello, user!'

print(math.evaluate('myConstant + 10')) // 52
print(math.evaluate('hello("user")')) // 'hello, user!'

/**
 * Import the math library numbers.js, https://github.com/sjkaliski/numbers.js
 * The library must be installed first using npm:
 *     npm install numbers
 */
try {
  // load the numbers.js library
  const numbers = require('numbers')

  // import the numbers.js library into math.js
  math.import(numbers, { wrap: true, silent: true })

  if (math.fibonacci) {
    // calculate fibonacci
    print(math.fibonacci(7)) // 13
    print(math.evaluate('fibonacci(7)')) // 13
  }
} catch (err) {
  console.log('Warning: To use numbers.js, the library must ' +
      'be installed first via `npm install numbers`.')
}

/**
 * Import the math library numeric.js, https://github.com/sloisel/numeric
 * The library must be installed first using npm:
 *     npm install numeric
 */
try {
  // load the numeric.js library
  const numeric = require('numeric')

  // import the numeric.js library into math.js
  math.import(numeric, { wrap: true, silent: true })

  if (math.eig) {
    // calculate eigenvalues of a matrix
    print(math.evaluate('eig([1, 2; 4, 3])').lambda.x) // [5, -1]

    // solve AX = b
    const A = math.evaluate('[1, 2, 3; 2, -1, 1; 3, 0, -1]')
    const b = [9, 8, 3]
    print(math.solve(A, b)) // [2, -1, 3]
  }
} catch (err) {
  console.log('Warning: To use numeric.js, the library must ' +
      'be installed first via `npm install numeric`.')
}

/**
 * By default, the function import does not allow overriding existing functions.
 * Existing functions can be overridden by specifying option `override: true`
 */
math.import({
  pi: 3.14
}, {
  override: true
})

print(math.pi) // returns 3.14 instead of 3.141592653589793

/**
 * Helper function to output a value in the console. Value will be formatted.
 * @param {*} value
 */
function print (value) {
  const precision = 14
  console.log(math.format(value, precision))
}\n\n\n\nMatrices

File: matrices.js

// matrices
import { diag, factorial, format, index, map, matrix, multiply, ones, range, sqrt } from 'mathjs'

// create matrices and arrays. a matrix is just a wrapper around an Array,
// providing some handy utilities.
console.log('create a matrix')
const a = matrix([1, 4, 9, 16, 25])
print(a) // [1, 4, 9, 16, 25]
const b = matrix(ones([2, 3]))
print(b) // [[1, 1, 1], [1, 1, 1]]
print(b.size()) // [2, 3]

// the Array data of a Matrix can be retrieved using valueOf()
const array = a.valueOf()
print(array) // [1, 4, 9, 16, 25]

// Matrices can be cloned
const clone = a.clone()
print(clone) // [1, 4, 9, 16, 25]
console.log()

// perform operations with matrices
console.log('perform operations')
print(map(a, sqrt)) // [1, 2, 3, 4, 5]
const c = [1, 2, 3, 4, 5]
print(factorial(c)) // [1, 2, 6, 24, 120]
console.log()

// create and manipulate matrices. Arrays and Matrices can be used mixed.
console.log('manipulate matrices')
const d = [[1, 2], [3, 4]]
print(d) // [[1, 2], [3, 4]]
const e = matrix([[5, 6], [1, 1]])
print(e) // [[5, 6], [1, 1]]

// set a submatrix
// Matrix indexes are zero-based.
e.subset(index(1, [0, 1]), [[7, 8]])
print(e) // [[5, 6], [7, 8]]
const f = multiply(d, e)
print(f) // [[19, 22], [43, 50]]
const g = f.subset(index(1, 0))
print(g) // 43
console.log()

// get a sub matrix
// Matrix indexes are zero-based.
console.log('get a sub matrix')
const h = diag(range(1, 4))
print(h) // [[1, 0, 0], [0, 2, 0], [0, 0, 3]]
print(h.subset(index([1, 2], [1, 2]))) // [[2, 0], [0, 3]]
const i = range(1, 6)
print(i) // [1, 2, 3, 4, 5]
print(i.subset(index(range(1, 4)))) // [2, 3, 4]
console.log()

// replace a single value in a matrix
// this will mutate the matrix
console.log('set and get a value')
const p = matrix([[1, 2], [3, 4]])
p.set([0, 1], 5)
print(p) // [[1, 5], [3, 4]]
const p21 = p.get([1, 0])
print(p21) // 3
console.log()

// resize a multi dimensional matrix
console.log('resizing a matrix')
const j = matrix()
let defaultValue = 0
j.resize([2, 2, 2], defaultValue)
print(j) // [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]
print(j.size()) // [2, 2, 2]
j.resize([2, 2])
print(j) // [[0, 0], [0, 0]]
print(j.size()) // [2, 2]
console.log()

// setting a value outside the matrices range will resize the matrix.
// new elements will be initialized with zero.
console.log('set a value outside a matrices range')
const k = matrix()
k.subset(index(2), 6)
print(k) // [0, 0, 6]
console.log()

console.log('set a value outside a matrices range, setting other new entries to null')
const m = matrix()
defaultValue = null
m.subset(index(2), 6, defaultValue)
print(m) // [null, null, 6]
console.log()

// create ranges
console.log('create ranges')
print(range(1, 6)) // [1, 2, 3, 4, 5]
print(range(0, 18, 3)) // [0, 3, 6, 9, 12, 15]
print(range('2:-1:-3')) // [2, 1, 0, -1, -2]
print(factorial(range('1:6'))) // [1, 2, 6, 24, 120]
console.log()

/**
 * Helper function to output a value in the console. Value will be formatted.
 * @param {*} value
 */
function print (value) {
  const precision = 14
  console.log(format(value, precision))
}\n\n\n\nObjects

File: objects.js

// objects
import { evaluate, format } from 'mathjs'

// create an object. Keys can be symbols or strings
print(evaluate('{x: 2 + 1, y: 4}')) // {"x": 3, "y": 4}
print(evaluate('{"name": "John"}')) // {"name": "John"}

// create an object containing an object
print(evaluate('{a: 2, b: {c: 3, d: 4}}')) // {"a": 2, "b": {"c": 3, "d": 4}}

const scope = {
  obj: {
    prop: 42
  }
}

// retrieve properties using dot notation or bracket notation
print(evaluate('obj.prop', scope)) // 42
print(evaluate('obj["prop"]', scope)) // 42

// set properties (returns the whole object, not the property value!)
print(evaluate('obj.prop = 43', scope)) // 43
print(evaluate('obj["prop"] = 43', scope)) // 43
print(scope.obj) // {"prop": 43}

/**
 * Helper function to output a value in the console. Value will be formatted.
 * @param {*} value
 */
function print (value) {
  const precision = 14
  console.log(format(value, precision))
}\n\n\n\nSerialization

File: serialization.js

// serialization
import { complex, replacer, reviver, typeOf } from 'mathjs'

// serialize a math.js data type into a JSON string
// the replacer function is needed to correctly stringify a value like Infinity
const x = complex('2+3i')
const str1 = JSON.stringify(x, replacer)
console.log(str1)
// outputs {"mathjs":"Complex","re":2,"im":3}

// deserialize a JSON string into a math.js data type
// note that the reviver of math.js is needed for this:
const str2 = '{"mathjs":"Unit","value":5,"unit":"cm"}'
const y = JSON.parse(str2, reviver)
console.log(typeOf(y)) // 'Unit'
console.log(y.toString()) // 5 cm\n\n\n\nSparse matrices

File: sparse_matrices.js

// Sparse matrices
import { identity, multiply, transpose, complex } from 'mathjs'

// create a sparse matrix
console.log('creating a 1000x1000 sparse matrix...')
const a = identity(1000, 1000, 'sparse')

// do operations with a sparse matrix
console.log('doing some operations on the sparse matrix...')
const b = multiply(a, a)
const c = multiply(b, complex(2, 2))
const d = transpose(c)
const e = multiply(d, a)
console.log('size(e)=', e.size())

// we will not print the output, but doing the same operations
// with a dense matrix are very slow, try it for yourself.
console.log('already done')
console.log('now try this with a dense matrix :)')\n\n\n\nUnits

File: units.js

// units
import { add, cross, divide, evaluate, format as _format, multiply, number, pow, to, unit } from 'mathjs'

// units can be created by providing a value and unit name, or by providing
// a string with a valued unit.
console.log('create units')
const a = unit(45, 'cm')
const b = unit('0.1m')
print(a) // 45 cm
print(b) // 0.1 m
console.log()

// units can be added, subtracted, and multiplied or divided by numbers and by other units
console.log('perform operations')
print(add(a, b)) // 55 cm
print(multiply(b, 2)) // 0.2 m
print(divide(unit('1 m'), unit('1 s'))) // 1 m / s
print(pow(unit('12 in'), 3)) // 1728 in^3
console.log()

// units can be converted to a specific type, or to a number
console.log('convert to another type or to a number')
print(b.to('cm')) // 10 cm  Alternatively: to(b, 'cm')
print(to(b, 'inch')) // 3.9370078740157 inch
print(b.toNumber('cm')) // 10
print(number(b, 'cm')) // 10
console.log()

// the expression parser supports units too
console.log('parse expressions')
print(evaluate('2 inch to cm')) // 5.08 cm
print(evaluate('cos(45 deg)')) // 0.70710678118655
print(evaluate('90 km/h to m/s')) // 25 m / s
console.log()

// convert a unit to a number
// A second parameter with the unit for the exported number must be provided
print(evaluate('number(5 cm, mm)')) // number, 50
console.log()

// simplify units
console.log('simplify units')
print(evaluate('100000 N / m^2')) // 100 kPa
print(evaluate('9.81 m/s^2 * 100 kg * 40 m')) // 39.24 kJ
console.log()

// example engineering calculations
console.log('compute molar volume of ideal gas at 65 Fahrenheit, 14.7 psi in L/mol')
const Rg = unit('8.314 N m / (mol K)')
const T = unit('65 degF')
const P = unit('14.7 psi')
const v = divide(multiply(Rg, T), P)
console.log('gas constant (Rg) = ', format(Rg))
console.log('P = ' + format(P))
console.log('T = ' + format(T))
console.log('v = Rg * T / P = ' + format(to(v, 'L/mol')))
// 23.910432393453 L / mol
console.log()

console.log('compute speed of fluid flowing out of hole in a container')
const g = unit('9.81 m / s^2')
const h = unit('1 m')
const v2 = pow(multiply(2, multiply(g, h)), 0.5) // Can also use sqrt
console.log('g = ' + format(g))
console.log('h = ' + format(h))
console.log('v = (2 g h) ^ 0.5 = ' + format(v2))
// 4.42944691807 m / s
console.log()

console.log('electrical power consumption:')
const expr1 = '460 V * 20 A * 30 days to kWh'
console.log(expr1 + ' = ' + evaluate(expr1)) // 6624 kWh
console.log()

console.log('circuit design:')
const expr2 = '24 V / (6 mA)'
console.log(expr2 + ' = ' + evaluate(expr2)) // 4 kohm
console.log()

console.log('operations on arrays:')
const B = evaluate('[1, 0, 0] T')
const v3 = evaluate('[0, 1, 0] m/s')
const q = evaluate('1 C')
const F = multiply(q, cross(v3, B))
console.log('B (magnetic field strength) = ' + format(B)) // [1 T, 0 T, 0 T]
console.log('v (particle velocity) = ' + format(v3)) // [0 m / s, 1 m / s, 0 m / s]
console.log('q (particle charge) = ' + format(q)) // 1 C
console.log('F (force) = q (v cross B) = ' + format(F)) // [0 N, 0 N, -1 N]

/**
 * Helper function to output a value in the console. Value will be formatted.
 * @param {*} value
 */
function print (value) {
  console.log(format(value))
}

/**
 * Helper function to format an output a value.
 * @param {*} value
 * @return {string} Returns the formatted value
 */
function format (value) {
  const precision = 14
  return _format(value, precision)
}\n\n\n\nAngle configuration

File: angle_configuration.html (click for a live demo)

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>math.js | angle configuration</title>
  <style>
    body, input, select {
      font: 11pt sans-serif;
    }
    input, select, th, #result {
      padding: 5px 10px;
    }
    th {
      text-align: left;
    }
  </style>

  <script src="https://unpkg.com/mathjs@14.4.0/lib/browser/math.js"></script>
</head>
<body>

<p>
  This code example extends the trigonometric functions of math.js with configurable angles: degrees, radians, or gradians.
</p>

<table>
  <tr>
    <th>Angles</th>
    <td>
      <select id="angles">
        <option value="deg">deg</option>
        <option value="grad">grad</option>
        <option value="rad">rad</option>
      </select>
    </td>
  </tr>
  <tr>
    <th>Expression</th>
    <td>
      <input id="expression" type="text" value="sin(45)" />
      <input id="evaluate" type="button" value="Evaluate">
    </td>
  </tr>
  <tr>
    <th>Result</th>
    <td id="result"></td>
  </tr>
</table>

<script>
  let replacements = {}

  // our extended configuration options
  const config = {
    angles: 'deg' // 'rad', 'deg', 'grad'
  }

  // create trigonometric functions replacing the input depending on angle config
  const fns1 = ['sin', 'cos', 'tan', 'sec', 'cot', 'csc']
  fns1.forEach(function(name) {
    const fn = math[name] // the original function

    const fnNumber = function (x) {
      // convert from configured type of angles to radians
      switch (config.angles) {
        case 'deg':
          return fn(x / 360 * 2 * Math.PI)
        case 'grad':
          return fn(x / 400 * 2 * Math.PI)
        default:
          return fn(x)
      }
    }

    // create a typed-function which check the input types
    replacements[name] = math.typed(name, {
      'number': fnNumber,
      'Array | Matrix': function (x) {
        return math.map(x, fnNumber)
      }
    })
  })

  // create trigonometric functions replacing the output depending on angle config
  const fns2 = ['asin', 'acos', 'atan', 'atan2', 'acot', 'acsc', 'asec']
  fns2.forEach(function(name) {
    const fn = math[name] // the original function

    const fnNumber = function (x) {
      const result = fn(x)

      if (typeof result === 'number') {
        // convert to radians to configured type of angles
        switch(config.angles) {
          case 'deg':  return result / 2 / Math.PI * 360
          case 'grad': return result / 2 / Math.PI * 400
          default: return result
        }
      }

      return result
    }

    // create a typed-function which check the input types
    replacements[name] = math.typed(name, {
      'number': fnNumber,
      'Array | Matrix': function (x) {
        return math.map(x, fnNumber)
      }
    })
  })

  // import all replacements into math.js, override existing trigonometric functions
  math.import(replacements, {override: true})

  // pointers to the input elements
  const expression = document.getElementById('expression')
  const evaluate   = document.getElementById('evaluate')
  const result     = document.getElementById('result')
  const angles     = document.getElementById('angles')

  // attach event handlers for select box and button
  angles.onchange = function () {
    config.angles = this.value
    config.angles = this.value
  }
  evaluate.onclick = function () {
    result.innerHTML = math.evaluate(expression.value)
  }
</script>


</body>
</html>\n\n\n\nBasic usage

File: basic_usage.html (click for a live demo)

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>math.js | basic usage</title>
  <script src="https://unpkg.com/mathjs@14.4.0/lib/browser/math.js"></script>
</head>
<body>

<script>
  function print(value) {
    const precision = 14
    document.write(math.format(value, precision) + '<br>')
  }

  // functions and constants
  print(math.round(math.e, 3))            // 2.718
  print(math.atan2(3, -3) / math.pi)      // 0.75
  print(math.log(10000, 10))              // 4
  print(math.sqrt(-4))                    // 2i
  print(math.pow([[-1, 2], [3, 1]], 2))   // [[7, 0], [0, 7]]
  print(math.derivative('x^2 + x', 'x'))  // 2 * x + 1

  // expressions
  print(math.evaluate('12 / (2.3 + 0.7)'))    // 4
  print(math.evaluate('12.7 cm to inch'))     // 5 inch
  print(math.evaluate('9 / 3 + 2i'))          // 3 + 2i
  print(math.evaluate('det([-1, 2; 3, 1])'))  // -7

  // chained operations
  const a = math.chain(3)
      .add(4)
      .multiply(2)
      .done()
  print(a)  // 14
</script>

</body>
</html>\n\n\n\nCurrency conversion

File: currency_conversion.html (click for a live demo)

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>math.js | currency conversion</title>

  <script src="https://unpkg.com/mathjs@14.4.0/lib/browser/math.js"></script>

  <style>
    body,
    html,
    input {
      font-size: 11pt;
      font-family: verdana, arial, sans-serif;
      color: #4d4d4d;
      max-width: 600px;
    }

    h1 {
      font-size: 120%;
    }

    input {
      padding: 5px;
      width: 400px;
    }
    button {
      padding: 5px;
    }
  </style>
</head>
<body>

<h1>Currency conversion with math.js</h1>

<p>
  This example demonstrates how you can fetch actual currencies from <a href="https://fixer.io">fixer.io</a> and use them in math.js.
</p>

<p>
  Create a (free) account at <a href="https://fixer.io">fixer.io</a> and fill in your API access key below:
</p>

<form id="fetchForm">
    <input type="text" id="apiKey" placeholder="fixer.io API access key..." />
    <button type="submit" id="ok">Fetch currencies</button>
</form>

<p id="info">
</p>
<div id="form" style="display: none;">
  <p>
    <label for="expr">Enter an expression with currencies:</label>
  </p>
  <p>
    <input id="expr" value="5 EUR + 2 * 3 EUR in USD" /><br/>
  </p>
  <p id="result"></p>
</div>

<script>
  const accessKey = document.getElementById('apiKey')
  const fetchForm = document.getElementById('fetchForm')

  fetchForm.onsubmit = function (event) {
    event.preventDefault()

    document.getElementById('info').innerHTML = 'Fetching currencies...'

    fetchAndImportCurrencies(accessKey.value)
      .then(function (currencies) {
        document.getElementById('expr').oninput = evaluate
        document.getElementById('form').style.display = ''
        document.getElementById('info').innerHTML = 'Available currencies: ' + currencies.join(', ')

        evaluate()
      })
      .catch(function (err) {
        console.error(err)
        document.getElementById('info').innerHTML = '<span style="color: red;">' + err.toString() + '</span>'
      })
  }

  function fetchAndImportCurrencies (accessKey) {
    // fetch actual currency conversion rates
    return fetch('http://data.fixer.io/api/latest?access_key=' + accessKey)
      .then(function (response) {
        return response.json()
      })
      .then(function (data) {
        if (data.success) {
          // import the currencies
          math.createUnit(data.base)
          Object.keys(data.rates)
            .filter(function (currency) {
              return currency !== data.base
            })
            .forEach(function (currency) {
              math.createUnit(currency, math.unit(1 / data.rates[currency], data.base))
            })

          // return an array with all available currencies
          return Object.keys(data.rates).concat(data.base)
        }
        else {
          throw new Error(data.error.info)
        }
      })
  }

  function evaluate () {
    const expr = document.getElementById('expr')
    const result = document.getElementById('result')

    try {
      const resultStr = math.format(math.evaluate(expr.value), {notation: 'fixed', precision: 2})
      result.innerHTML = '<span style="color: dodgerblue;">' + resultStr + '</span>'
    }
    catch (err) {
      result.innerHTML = '<span style="color: red;">' + err.toString() + '</span>'
    }
  }
</script>
</body>
</html>\n\n\n\nCustom separators

File: custom_separators.html (click for a live demo)

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>math.js | custom separators</title>
  <style>
    body, input, select {
      font: 11pt sans-serif;
    }
    input, select, th, #result {
      padding: 5px 10px;
    }
    th {
      text-align: left;
    }
  </style>

  <script src="https://unpkg.com/mathjs@14.4.0/lib/browser/math.js"></script>
</head>
<body>

<p>
  This code example shows how to apply custom separators for function arguments and decimal separator.
</p>

<table>
  <tr>
    <th>Argument separator</th>
    <td>
      <input id="args" type="text" value=";">
    </td>
  </tr>
  <tr>
    <th>Decimal separator</th>
    <td>
      <input id="decimals" type="text" value=",">
    </td>
  </tr>
  <tr>
    <th>Expression</th>
    <td>
      <input id="expression" type="text" value="sum(3,4; 2,1; 2,0)" />
      <input id="evaluate" type="button" value="Evaluate">
    </td>
  </tr>
  <tr>
    <th>Result</th>
    <td id="result"></td>
  </tr>
</table>

<script>
  // pointers to the input elements
  const expression = document.getElementById('expression')
  const evaluate   = document.getElementById('evaluate')
  const result     = document.getElementById('result')
  const args       = document.getElementById('args')
  const decimals   = document.getElementById('decimals')

  // attach event handler to the button
  evaluate.onclick = function () {
    // replace the custom separators in the input with the default separators
    const expr = expression.value
        .replace(new RegExp('\\' + decimals.value + '|\\' + args.value, 'g'), function (match) {
          return match === decimals.value ? '.': ','
        })

    // do the actual evaluation
    const res = math.evaluate(expr)

    // replace the default separators in the output with custom separators
    result.innerHTML = res.toString()
        .replace(new RegExp(',|\\.', 'g'), function (match) {
          return match === '.' ? decimals.value : args.value
        })
  }
</script>


</body>
</html>\n\n\n\nLorenz

File: lorenz.html (click for a live demo)

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>math.js | Lorenz Attractor</title>
    <script src="https://unpkg.com/mathjs@14.4.0/lib/browser/math.js"></script>

    <script src="https://cdn.plot.ly/plotly-2.25.2.min.js" charset="utf-8"></script>
    <style>
        html, body {
            width: 100%;
            height: 100vh;
            padding: 0;
            margin: 0;
        } 
        body {
            display: flex;
            flex-direction: column;
        }

        #LorenzGraph {
            flex: 1;
        }
    </style>
</head>

<body>
    <div id="LorenzGraph"></div>
</body>
<script defer>

    // define the constants for the Lorenz attractor
    const sigma = 10
    const beta = 2.7
    const rho = 28

    // solve the Lorenz attractor
    const sol = math.solveODE(lorenz, [0, 100], [1, 1, 1])

    // make colors that represents time differences in the solution
    const diff = math.diff(sol.t)
    const color = [diff[0], ...diff]

    // render the plot using plotly
    Plotly.newPlot('LorenzGraph',
        [{
            x: sol.y.map(u => u[0]),
            y: sol.y.map(u => u[1]),
            z: sol.y.map(u => u[2]),
            line: { color, colorscale: 'Jet' },
            type: "scatter3d",
            mode: "lines"
        }],
        {
            responsive: true,
            uirevision: 'true',
            title:"Lorenz Attractor",
        }
    )

    // define the lorenz attractor
    function lorenz(t, u) {
        const [x, y, z] = u
        return [
            sigma * (y - x),
            x * (rho - z) - y,
            x * y - beta * z
        ]
    }
</script>

</html>\n\n\n\nLorenz interactive

File: lorenz_interactive.html (click for a live demo)

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>math.js | Lorenz Attractor</title>
    <script src="https://unpkg.com/mathjs@14.4.0/lib/browser/math.js"></script>

    <script src="https://cdn.plot.ly/plotly-2.28.0.min.js" charset="utf-8"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js"
        integrity="sha512-LQNxIMR5rXv7o+b1l8+N1EZMfhG7iFZ9HhnbJkTp4zjNr5Wvst75AqUeFDxeRUa7l5vEDyUiAip//r+EFLLCyA=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css"
        integrity="sha512-fHwaWebuwA7NSF5Qg/af4UeDx9XqUpYpOGgubo3yWu+b2IQR4UeQwbb42Ti7gVAjNtVoI/I9TEoYeu9omwcC6g=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        body,
        html {
            width: 100%;
            height: 100vh;
            padding: 0;
            margin: 0;
        }

        body {
            display: flex;
            flex-direction: column;
        }

        #LorenzGraph {
            flex: 1;
        }

        #inputsDiv {
            z-index: 1;
            position: absolute;
            background: white;
        }
    </style>
</head>

<body>
    <div id="LorenzGraph"></div>
    <div id="inputsDiv">
        <fieldset name="inputs" id="inputs">
            <legend for="inputs">Inputs:</legend>
            <table>
                <tr>
                    <td>
                        <label for="sigma" id="sigmaLabel">sigma</label>
                    </td>
                    <td>
                        <input type="range" id="sigma" name="sigma" value=10 min=9 max=11 step=0.01>
                    </td>
                    <td>
                        <label for="beta" id="betaLabel">beta</label>
                    </td>
                    <td>
                        <input type="range" id="beta" name="beta" value=8/3 min=2 max=4 step=0.01>
                    </td>
                    <td>
                        <label for="rho" id="rhoLabel">rho</label>
                    </td>
                    <td>
                        <input type="range" id="rho" name="rho" value=28 min=20 max=30 step=0.01>
                    </td>
                </tr>
                <tr>
                    <td>
                        <label for="x0" id="x0Label">x0</label>
                    </td>
                    <td>
                        <input type="range" id="x0" name="x0" value=1 min=-5 max=5 step=0.01>
                    </td>
                    <td>
                        <label for="y0" id="y0Label">y0</label>
                    </td>
                    <td>
                        <input type="range" id="y0" name="y0" value=1 min=-5 max=5 step=0.01>

                    </td>
                    <td>
                        <label for="z0" id="z0Label">z0</label>
                    </td>
                    <td>
                        <input type="range" id="z0" name="z0" value=0 min=-5 max=5 step=0.01>
                    </td>
                </tr>
                <tr>
                    <td>
                        <label for="epsilon" id="epsilonLabel">epsilon</label>
                    </td>
                    <td>
                        <input type="range" id="epsilon" name="epsilon" value=0.01 min=0.0001 max=0.1 step=0.0001>
                    </td>
                </tr>
            </table>
        </fieldset>
    </div>
</body>
<script defer>
    katex.render(String.raw` igma`, document.querySelector("#sigmaLabel"))
    katex.render(String.raw`\beta`, document.querySelector("#betaLabel"))
    katex.render(String.raw`\rho`, document.querySelector("#rhoLabel"))
    katex.render(String.raw`x_0`, document.querySelector("#x0Label"))
    katex.render(String.raw`y_0`, document.querySelector("#y0Label"))
    katex.render(String.raw`z_0`, document.querySelector("#z0Label"))
    katex.render(String.raw`\epsilon`, document.querySelector("#epsilonLabel"))

    const inputs = document.querySelector("#inputs")

    // define the constants for the Lorenz attractor
    const sigma = document.querySelector("#sigma")
    const beta = document.querySelector("#beta")
    const rho = document.querySelector("#rho")

    // define the initial location
    const x0 = document.querySelector('#x0')
    const y0 = document.querySelector('#y0')
    const z0 = document.querySelector('#z0')

    // define the tolerance for the solution
    const epsilon = document.querySelector('#epsilon')

    const layout = {
        interactive: true,
        title: 'Lorenz Attractor',
        uirevision: 'true',
        sliders: [{
            name: 'sigma',
            currentvalue: {
                xanchor: 'right',
                prefix: 'color: ',
                font: {
                    color: '#888',
                    size: 20
                }
            },
            steps: [{ label: 'g', method: "updateSolution" }, { label: 'f' }]
        }]
    }

    const t_span = [0, 100]

    inputs.addEventListener("change", updateSolution)

    let trace
    // solve the Lorenz attractor with the initial values
    updateSolution()

    // crates a trace in the format needed for plotly
    function createTrace(sol) {
        // make colors that represents time differences in the solution
        const diff = math.diff(sol.t)
        const color = [diff[0], ...diff]
        const trace = [{
            x: sol.y.map(u => u[0]),
            y: sol.y.map(u => u[1]),
            z: sol.y.map(u => u[2]),
            line: {
                color,
                colorscale: 'Jet'
            },
            type: "scatter3d",
            mode: "lines"
        }]
        return trace
    }

    function createLorenz(sigma, rho, beta) {
        // define the lorenz attractor as a function of t and u in the format needed for solveODE
        return function lorenz(t, u) {
            const [x, y, z] = u
            // return x', y', z'
            return [
                sigma * (y - x),
                x * (rho - z) - y,
                x * y - beta * z
            ]
        }
    }

    function updateSolution() {
        const y_0 = [x0.value, y0.value, z0.value]
        const sol = math.solveODE(createLorenz(sigma.value, rho.value, beta.value), t_span, y_0, { tol: epsilon.value })
        trace = createTrace(sol)
        // reactively render the plot on update
        Plotly.react('LorenzGraph', trace, layout)
    }

</script>

</html>\n\n\n\nPlot

File: plot.html (click for a live demo)

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>math.js | plot</title>
  <script src="https://unpkg.com/mathjs@14.4.0/lib/browser/math.js"></script>

  <script src="https://cdn.plot.ly/plotly-1.35.2.min.js"></script>

  <style>
    input[type=text] {
      width: 300px;
    }
    input {
      padding: 6px;
    }
    body, html, input {
      font-family: sans-serif;
      font-size: 11pt;

    }
    form {
      margin: 20px 0;
    }
  </style>
</head>
<body>

<form id="form">
  <label for="eq">Enter an equation:</label>
  <input type="text" id="eq" value="4 * sin(x) + 5 * cos(x/2)" />
  <input type="submit" value="Draw" />
</form>

<div id="plot"></div>

<p>
  Used plot library: <a href="https://plot.ly/javascript/">Plotly</a>
</p>

<script>
  function draw() {
    try {
      // compile the expression once
      const expression = document.getElementById('eq').value
      const expr = math.compile(expression)

      // evaluate the expression repeatedly for different values of x
      const xValues = math.range(-10, 10, 0.5).toArray()
      const yValues = xValues.map(function (x) {
        return expr.evaluate({x: x})
      })

      // render the plot using plotly
      const trace1 = {
        x: xValues,
        y: yValues,
        type: 'scatter'
      }
      const data = [trace1]
      Plotly.newPlot('plot', data)
    }
    catch (err) {
      console.error(err)
      alert(err)
    }
  }

  document.getElementById('form').onsubmit = function (event) {
    event.preventDefault()
    draw()
  }

  draw()
</script>

</body>
</html>\n\n\n\nPretty printing with mathjax

File: pretty_printing_with_mathjax.html (click for a live demo)

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>math.js | pretty printing with MathJax</title>

  <script src="https://unpkg.com/mathjs@14.4.0/lib/browser/math.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

  <style>
    body,
    html,
    table td,
    table th,
    input[type=text] {
      font-size: 11pt;
      font-family: verdana, arial, sans-serif;
    }

    h1 {
      font-size: 11pt;
    }

    input[type=text] {
      padding: 5px;
      width: 400px;
    }

    table {
      border-collapse: collapse;
    }

    table td,
    table th {
      padding: 5px;
      border: 1px solid lightgray;
    }

    table th {
      background-color: lightgray;
    }

  </style>
</head>
<body>

<h1>
  Expression evaluation with math.js, pretty printing with MathJax
</h1>

<table>
  <tr>
    <th>Expression</th>
    <td><input type="text" id="expr"/></td>
  </tr>
  <tr>
    <th>Pretty print</th>
    <td><div id="pretty"></div></td>
  </tr>
  <tr>
    <th>Result</th>
    <td><div id="result"></div></td>
  </tr>
</table>
<b>Parenthesis option:</b>
<input type="radio" name="parenthesis" value="keep" onclick="parenthesis = 'keep'; expr.oninput();" checked>keep
<input type="radio" name="parenthesis" value="auto" onclick="parenthesis = 'auto'; expr.oninput();">auto
<input type="radio" name="parenthesis" value="all" onclick="parenthesis = 'all'; expr.oninput();">all
<br/>
<b>Implicit multiplication:</b>
<input type="radio" name="implicit" value="hide" onclick="implicit = 'hide'; expr.oninput();" checked>hide
<input type="radio" name="implicit" value="show" onclick="implicit = 'show'; expr.oninput();">show


<script>
  const expr = document.getElementById('expr')
  const pretty = document.getElementById('pretty')
  const result = document.getElementById('result')
  let parenthesis = 'keep'
  let implicit = 'hide'

  const mj = function (tex) {
    return MathJax.tex2svg(tex, {em: 16, ex: 6, display: false});
  }

  // initialize with an example expression
  expr.value = 'sqrt(75 / 3) + det([[-1, 2], [3, 1]]) - sin(pi / 4)^2'
  pretty.innerHTML = '';
  pretty.appendChild(mj(math.parse(expr.value).toTex({parenthesis: parenthesis})));
  result.innerHTML = math.format(math.evaluate(expr.value))

  expr.oninput = function () {
    let node = null

    try {
      // parse the expression
      node = math.parse(expr.value)

      // evaluate the result of the expression
      result.innerHTML = math.format(node.compile().evaluate())
    }
    catch (err) {
      result.innerHTML = '<span style="color: red;">' + err.toString() + '</span>'
    }

    try {
      // export the expression to LaTeX
      const latex = node ? node.toTex({parenthesis: parenthesis, implicit: implicit}) : ''
      console.log('LaTeX expression:', latex)

      // display and re-render the expression
      MathJax.typesetClear();
      pretty.innerHTML = '';
      pretty.appendChild(mj(latex));
    }
    catch (err) {}
  }
</script>

</body>
</html>\n\n\n\nPrinting html

File: printing_html.html (click for a live demo)

<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>math.js | printing HTML</title>

	<script src="https://unpkg.com/mathjs@14.4.0/lib/browser/math.js"></script>

	<style>
		body {
			font-size: 11pt;
			font-family: verdana, arial, sans-serif;
		}

		h1 {
			font-size: 1rem;
		}

		fieldset {
			display: inline;
			margin: 0 50px 10px 0;
			padding: 0;
			border: none;
		}

		input[type=text] {
			font-size: 11pt;
			font-family: verdana, arial, sans-serif;
			padding: 5px;
			width: calc(100% - 14px);
		}

		label {
			margin: 0 5px 0 0;
		}

		table {
			width: 100%;
			border-collapse: collapse;
		}

		table td,
		table th {
			padding: 5px;
			border: 1px solid LightGrey;
		}

		table th {
			background-color: LightGrey;
		}

		/* style the HTML output */
		.math-function {
			color: Purple;
			font-weight: bold;
		}

		.math-number {
			color: Blue;
		}

		.math-boolean {
			color: Green;
		}

		.math-string {
			color: Grey;
		}

		.math-string::before,
		.math-string::after {
			content: "\"";
		}

		.math-property {
			font-style: italic;
		}

		.math-explicit-binary-operator::before,
		.math-explicit-binary-operator::after {
			content: " ";
		}

		.math-separator::after,
		.math-assignment-operator::after {
			content: " ";
		}
	</style>
</head>
<body>
<h1>Expression evaluation and HTML code generation with math.js</h1>
<form>
	<fieldset>
		Parenthesis option:
		<label><input type="radio" name="parenthesis" value="keep" checked>keep</label>
		<label><input type="radio" name="parenthesis" value="auto">auto</label>
		<label><input type="radio" name="parenthesis" value="all">all</label>
	</fieldset>
	<fieldset>
		Implicit multiplication:
		<label><input type="radio" name="implicit" value="hide" checked>hide</label>
		<label><input type="radio" name="implicit" value="show">show</label>
	</fieldset>
</form>
<table>
	<tr>
		<th>Expression</th>
		<td><input type="text" id="expr"/></td>
	</tr>
	<tr>
		<th>Result</th>
		<td><div id="result"></div></td>
	</tr>
	<tr>
		<th>HTML output</th>
		<td><div id="output">$$$$</div></td>
	</tr>
	<tr>
		<th>HTML code</th>
		<td><div id="code">$$$$</div></td>
	</tr>
</table>
<script>
  const expr = document.getElementById('expr')
  const output = document.getElementById('output')
  const code = document.getElementById('code')
  const result = document.getElementById('result')
  let options = {parenthesis: 'keep', implicit: 'hide'}

  // initialize with an example expression
  expr.value = 'sqrt(75/3)+det([[-1,2],[3,1]])-sin(pi/4)^2'

  function print () {
    let parsed = null

    try {
      // parse the expression
      parsed = math.parse(expr.value)

      // evaluate the result of the expression
      result.innerHTML = math.format(parsed.compile().evaluate())

      // print the HTML output
      const html = math.parse(expr.value).toHTML(options)
      output.innerHTML = html

      // print the HTML code
      code.innerHTML = html.replace(/</g, '&lt;').
      replace(/>/g, '&gt;').
      replace(/&lt;\/span&gt;/g, '&lt;/span&gt;<br />')
    }
    catch (err) {
      result.innerHTML = '<span style="color: red;">' + err.toString() + '</span>'
    }
  }

  window.onload = print
  expr.oninput = print

  // make the controls work
  const controls = document.querySelectorAll('input[type=radio]')
  controls.forEach(function (control) {
    control.onclick = function() {
      options[control.name] = control.value
      print()
    }
  })
</script>
</body>
</html>\n\n\n\nRequirejs loading

File: requirejs_loading.html (click for a live demo)

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>math.js | require.js loading</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.20/require.min.js"></script>
</head>
<body>

<script>
  // load math.js using require.js
  require(['https://unpkg.com/mathjs@14.4.0/lib/browser/math.js'], function (math) {
    // evaluate some expression
    const result = math.evaluate('1.2 * (2 + 4.5)')
    document.write(result)
  })
</script>

</body>
</html>\n\n\n\nRocket trajectory optimization

File: rocket_trajectory_optimization.html (click for a live demo)

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>math.js | rocket trajectory optimization</title>

  <script src="https://unpkg.com/mathjs@14.4.0/lib/browser/math.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.5.0/Chart.min.js"></script>

  <style>
    body {
      font-family: sans-serif;
    }

    #canvas-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 5%;
      margin-top: 5%;
    }

    #canvas-grid>div {
      overflow: hidden;
    }
  </style>
</head>

<body>
  <h1>Rocket trajectory optimization</h1>
  <p>
    This example simulates the launch of a SpaceX Falcon 9 modeled using a system of ordinary differential equations.
  </p>

  <canvas id="canvas" width="1600" height="600"></canvas>
  <div id="canvas-grid"></div>

  <script>
    // Solve ODE `dx/dt = f(x,t), x(0) = x0` numerically.
    function ndsolve(f, x0, dt, tmax) {
      let x = x0.clone()  // Current values of variables
      const result = [x]  // Contains entire solution
      const nsteps = math.divide(tmax, dt)   // Number of time steps
      for (let i = 0; i < nsteps; i++) {
        // Compute derivatives
        const dxdt = f.map(func => func(...x.toArray()))
        // Euler method to compute next time step
        const dx = math.multiply(dxdt, dt)
        x = math.add(x, dx)
        result.push(x)
      }
      return math.matrix(result)
    }

    // Import the numerical ODE solver
    math.import({ ndsolve })

    // Create a math.js context for our simulation. Everything else occurs in the context of the expression parser!
    const sim = math.parser()

    sim.evaluate("G = 6.67408e-11 m^3 kg^-1 s^-2")  // Gravitational constant
    sim.evaluate("mbody = 5.9724e24 kg")            // Mass of Earth
    sim.evaluate("mu = G * mbody")                  // Standard gravitational parameter
    sim.evaluate("g0 = 9.80665 m/s^2")              // Standard gravity: used for calculating prop consumption (dmdt)
    sim.evaluate("r0 = 6371 km")                    // Mean radius of Earth
    sim.evaluate("t0 = 0 s")                        // Simulation start
    sim.evaluate("dt = 0.5 s")                      // Simulation timestep
    sim.evaluate("tfinal = 149.5 s")                // Simulation duration
    sim.evaluate("isp_sea = 282 s")                 // Specific impulse (at sea level)
    sim.evaluate("isp_vac = 311 s")                 // Specific impulse (in vacuum)
    sim.evaluate("gamma0 = 89.99970 deg")           // Initial pitch angle (90 deg is vertical)
    sim.evaluate("v0 = 1 m/s")                      // Initial velocity (must be non-zero because ODE is ill-conditioned)
    sim.evaluate("phi0 = 0 deg")                    // Initial orbital reference angle
    sim.evaluate("m1 = 433100 kg")                  // First stage mass
    sim.evaluate("m2 = 111500 kg")                  // Second stage mass
    sim.evaluate("m3 = 1700 kg")                    // Third stage / fairing mass
    sim.evaluate("mp = 5000 kg")                    // Payload mass
    sim.evaluate("m0 = m1+m2+m3+mp")                // Initial mass of rocket
    sim.evaluate("dm = 2750 kg/s")                  // Mass flow rate
    sim.evaluate("A = (3.66 m)^2 * pi")             // Area of the rocket
    sim.evaluate("dragCoef = 0.2")                  // Drag coefficient

    // Define the equations of motion. We just thrust into current direction of motion, e.g. making a gravity turn.
    sim.evaluate("gravity(r) = mu / r^2")
    sim.evaluate("angVel(r, v, gamma) = v/r * cos(gamma) * rad")   // Angular velocity of rocket around moon
    sim.evaluate("density(r) = 1.2250 kg/m^3 * exp(-g0 * (r - r0) / (83246.8 m^2/s^2))") // Assume constant temperature
    sim.evaluate("drag(r, v) = 1/2 * density(r) .* v.^2 * A * dragCoef")
    sim.evaluate("isp(r) = isp_vac + (isp_sea - isp_vac) * density(r)/density(r0)") // pressure ~ density for constant temperature
    sim.evaluate("thrust(isp) = g0 * isp * dm")
    // It is important to maintain the same argument order for each of these functions.
    sim.evaluate("drdt(r, v, m, phi, gamma, t) = v sin(gamma)")
    sim.evaluate("dvdt(r, v, m, phi, gamma, t) = - gravity(r) * sin(gamma) + (thrust(isp(r)) - drag(r, v)) / m")
    sim.evaluate("dmdt(r, v, m, phi, gamma, t) = - dm")
    sim.evaluate("dphidt(r, v, m, phi, gamma, t) = angVel(r, v, gamma)")
    sim.evaluate("dgammadt(r, v, m, phi, gamma, t) = angVel(r, v, gamma) - gravity(r) * cos(gamma) / v * rad")
    sim.evaluate("dtdt(r, v, m, phi, gamma, t) = 1")

    // Remember to maintain the same variable order in the call to ndsolve.
    sim.evaluate("result_stage1 = ndsolve([drdt, dvdt, dmdt, dphidt, dgammadt, dtdt], [r0, v0, m0, phi0, gamma0, t0], dt, tfinal)")

    // Reset initial conditions for interstage flight
    sim.evaluate("dm = 0 kg/s")
    sim.evaluate("tfinal = 10 s")
    sim.evaluate("x = flatten(result_stage1[end,:])")
    sim.evaluate("x[3] = m2+m3+mp") // New mass after stage seperation
    sim.evaluate("result_interstage = ndsolve([drdt, dvdt, dmdt, dphidt, dgammadt, dtdt], x, dt, tfinal)")

    // Reset initial conditions for stage 2 flight
    sim.evaluate("dm = 270.8 kg/s")
    sim.evaluate("isp_vac = 348 s")
    sim.evaluate("tfinal = 350 s")
    sim.evaluate("x = flatten(result_interstage[end,:])")
    sim.evaluate("result_stage2 = ndsolve([drdt, dvdt, dmdt, dphidt, dgammadt, dtdt], x, dt, tfinal)")

    // Reset initial conditions for unpowered flight
    sim.evaluate("dm = 0 kg/s")
    sim.evaluate("tfinal = 900 s")
    sim.evaluate("dt = 10 s")
    sim.evaluate("x = flatten(result_stage2[end,:])")
    sim.evaluate("result_unpowered1 = ndsolve([drdt, dvdt, dmdt, dphidt, dgammadt, dtdt], x, dt, tfinal)")

    // Reset initial conditions for final orbit insertion
    sim.evaluate("dm = 270.8 kg/s")
    sim.evaluate("tfinal = 39 s")
    sim.evaluate("dt = 0.5 s")
    sim.evaluate("x = flatten(result_unpowered1[end,:])")
    sim.evaluate("result_insertion = ndsolve([drdt, dvdt, dmdt, dphidt, dgammadt, dtdt], x, dt, tfinal)")

    // Reset initial conditions for unpowered flight
    sim.evaluate("dm = 0 kg/s")
    sim.evaluate("tfinal = 250 s")
    sim.evaluate("dt = 10 s")
    sim.evaluate("x = flatten(result_insertion[end,:])")
    sim.evaluate("result_unpowered2 = ndsolve([drdt, dvdt, dmdt, dphidt, dgammadt, dtdt], x, dt, tfinal)")

    // Now it's time to prepare results for plotting
    const resultNames = ['stage1', 'interstage', 'stage2', 'unpowered1', 'insertion', 'unpowered2']
      .map(stageName => `result_${stageName}`)

    // Concat result matrices
    sim.set('result',
      math.concat(
        ...resultNames.map(resultName =>
          sim.evaluate(`${resultName}[:end-1, :]`)  // Avoid overlap
        ),
        0 // Concat in row-dimension
      )
    )

    const mainDatasets = resultNames.map((resultName, i) => ({
      label: resultName.slice(7),
      data: sim.evaluate(
        'concat('
        + `(${resultName}[:,4] - phi0) * r0 / rad / km,`  // Surface distance from start (in km)
        + `(${resultName}[:,1] - r0) / km`                // Height above surface (in km)
        + ')'
      ).toArray().map(([x, y]) => ({ x, y })),
      borderColor: i % 2 ? '#999' : '#dc3912',
      fill: false,
      pointRadius: 0,
    }))
    new Chart(document.getElementById('canvas'), {
      type: 'line',
      data: { datasets: mainDatasets },
      options: getMainChartOptions()
    })

    createChart([{
      label: 'velocity (in m/s)',
      data: sim.evaluate("result[:,[2,6]]")
        .toArray()
        .map(([v, t]) => ({ x: t.toNumber('s'), y: v.toNumber('m/s') }))
    }])
    createChart([{
      label: 'height (in km)',
      data: sim.evaluate("concat((result[:, 1] - r0), result[:, 6])")
        .toArray()
        .map(([r, t]) => ({ x: t.toNumber('s'), y: r.toNumber('km') })),
    }])
    createChart([{
      label: 'gamma (in deg)',
      data: sim.evaluate("result[:, [5,6]]")
        .toArray()
        .map(([gamma, t]) => ({ x: t.toNumber('s'), y: gamma.toNumber('deg') })),
    }])
    createChart([{
      label: 'acceleration (in m/s^2)',
      data: sim.evaluate("concat(diff(result[:, 2]) ./ diff(result[:, 6]), result[:end-1, 6])")
        .toArray()
        .map(([acc, t]) => ({ x: t.toNumber('s'), y: acc.toNumber('m/s^2') })),
    }])
    createChart([{
      label: 'drag acceleration (in m/s^2)',
      data: sim.evaluate('result')
        .toArray()
        .map(([r, v, m, phi, gamma, t]) => ({
          x: t.toNumber('s'),
          y: sim.evaluate(`drag(${r},${v})/${m}`).toNumber('m/s^2')
        }))
    }])
    createChart(
      [
        {
          data: sim.evaluate("result[:, [1,4]]")
            .toArray()
            .map(([r, phi]) => math.rotate([r.toNumber('km'), 0], phi))
            .map(([x, y]) => ({ x, y })),
        },
        {
          data: sim.evaluate("map(0:0.25:360, function(angle) = rotate([r0/km, 0], angle))")
            .toArray()
            .map(([x, y]) => ({ x, y })),
          borderColor: "#999",
          fill: true
        }
      ],
      getEarthChartOptions()
    )

    // Helper functions for plotting data (nothing to learn about math.js from here on)
    function createChart(datasets, options = {}) {
      const container = document.createElement("div")
      document.querySelector("#canvas-grid").appendChild(container)
      const canvas = document.createElement("canvas")
      container.appendChild(canvas)
      new Chart(canvas, {
        type: 'line',
        data: {
          datasets: datasets.map(dataset => ({
            borderColor: "#dc3912",
            fill: false,
            pointRadius: 0,
            ...dataset
          }))
        },
        options: getChartOptions(options)
      })
    }

    function getMainChartOptions() {
      return {
        scales: {
          xAxes: [{
            type: 'linear',
            position: 'bottom',
            scaleLabel: {
              display: true,
              labelString: 'surface distance travelled (in km)'
            }
          }],
          yAxes: [{
            type: 'linear',
            scaleLabel: {
              display: true,
              labelString: 'height above surface (in km)'
            }
          }]
        },
        animation: false
      }
    }

    function getChartOptions(options) {
      return {
        scales: {
          xAxes: [{
            type: 'linear',
            position: 'bottom',
            scaleLabel: {
              display: true,
              labelString: 'time (in s)'
            }
          }]
        },
        animation: false,
        ...options
      }
    }

    function getEarthChartOptions() {
      return {
        aspectRatio: 1,
        scales: {
          xAxes: [{
            type: 'linear',
            position: 'bottom',
            min: -8000,
            max: 8000,
            display: false
          }],
          yAxes: [{
            type: 'linear',
            min: -8000,
            max: 8000,
            display: false
          }]
        },
        legend: { display: false }
      }
    }
  </script>
</body>

</html>\n\n\n\nWebworkers

File: webworkers.html (click for a live demo)

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>math.js | web workers</title>
</head>
<body>

<p>
  In this example, a math.js parser is running in a separate
  <a href="https://www.html5rocks.com/en/tutorials/workers/basics/">web worker</a>,
  preventing the user interface from freezing during heavy calculations.
</p>

<p id="results"></p>

<script>
  /**
   * MathWorker evaluates expressions asynchronously in a web worker.
   *
   * Example usage:
   *
   *     const worker = new MathWorker()
   *     const expr = '12 / (2.3 + 0.7)'
   *     worker.evaluate(expr, function (err, result) {
   *       console.log(err, result)
   *     })
   */
  function MathWorker () {
    this.worker = new Worker('worker.js')
    this.callbacks = {}
    this.seq = 0

    // create a listener to receive responses from the web worker
    const me = this
    this.worker.addEventListener('message', function(event) {
      const response = JSON.parse(event.data)

      // find the callback corresponding to this response
      const callback = me.callbacks[response.id]
      delete me.callbacks[response.id]

      // call the requests callback with the result
      callback(response.err, response.result)
    }, false)
  }

  /**
   * Evaluate an expression
   * @param {string} expr
   * @param {Function} callback   Called as callback(err, result)
   */
  MathWorker.prototype.evaluate = function evaluate (expr, callback) {
    // build a request,
    // add an id so we can link returned responses to the right callback
    const id = this.seq++
    const request = {
      id: id,
      expr: expr
    }

    // queue the callback, it will be called when the worker returns the result
    this.callbacks[id] = callback

    // send the request to the worker
    this.worker.postMessage(JSON.stringify(request))
  }

  // create a MathWorker
  const worker = new MathWorker()

  // evaluate an expression via the worker
  worker.evaluate('12 / (2.3 + 0.7)', function (err, result) {
    document.getElementById('results').innerHTML += 'result: ' + result + '<br>'
  })

</script>

</body>
</html>


File: worker.js

importScripts('https://unpkg.com/mathjs@14.4.0/lib/browser/math.js')

// create a parser
const parser = self.math.parser()

self.addEventListener('message', function (event) {
  const request = JSON.parse(event.data)
  let result = null
  let err = null

  try {
    // evaluate the expression
    result = parser.evaluate(request.expr)
  } catch (e) {
    // return the error
    err = e
  }

  // build a response
  const response = {
    id: request.id,
    result: self.math.format(result),
    err: err
  }

  // send the response back
  self.postMessage(JSON.stringify(response))
}, false)\n\n\n\nConvert fraction to bignumber

File: convert_fraction_to_bignumber.js

// Convert from Fraction to BigNumber
//
// In the configuration of math.js one can specify the default number type to
// be `number`, `BigNumber`, or `Fraction`. Not all functions support `Fraction`
// or `BigNumber`, and if not supported these input types will be converted to
// numbers.
//
// When `Fraction` is configured, one may want to fallback to `BigNumber`
// instead of `number`. Also, one may want to be able to mix `Fraction` and
// `BigNumber` in operations like summing them up. This can be achieved by
// adding an extra conversion to the list of conversions as demonstrated in
// this example.

// Create an empty math.js instance, with only typed
// (every instance contains `import` and `config` also out of the box)
import { create, typedDependencies, all } from 'mathjs'
const math = create({
  typedDependencies
})

// TODO: this should be much easier
const allExceptLoaded = Object.keys(all)
  .map(key => all[key])
  .filter(factory => math[factory.fn] === undefined)

// Configure to use fractions by default
math.config({ number: 'Fraction' })

// Add a conversion from Faction -> BigNumber
// This conversion will to override the existing conversion from Fraction to 
// BigNumber. It must be added *after* the default conversions are loaded
// and *before* the actual functions are imported into math.js.
math.typed.addConversion({
  from: 'Fraction',
  to: 'BigNumber',
  convert: (fraction) => new math.BigNumber(fraction.n).div(fraction.d)
}, { override: true })

// Import all data types, functions, constants, the expression parser, etc.
math.import(allExceptLoaded)

// Operators `add` and `divide` do have support for Fractions, so the result
// will simply be a Fraction (default behavior of math.js).
const ans1 = math.evaluate('1/3 + 1/4')
console.log(math.typeOf(ans1), math.format(ans1))
// outputs "Fraction 7/12"

// Function sqrt doesn't have Fraction support, will now fall back to BigNumber
// instead of number.
const ans2 = math.evaluate('sqrt(4)')
console.log(math.typeOf(ans2), math.format(ans2))
// outputs "BigNumber 2"

// We can now do operations with mixed Fractions and BigNumbers
const ans3 = math.add(math.fraction(2, 5), math.bignumber(3))
console.log(math.typeOf(ans3), math.format(ans3))
// outputs "BigNumber 3.4"\n\n\n\nCustom argument parsing

File: custom_argument_parsing.js

/**
 * The expression parser of math.js has support for letting functions
 * parse and evaluate arguments themselves, instead of calling them with
 * evaluated arguments.
 *
 * By adding a property `raw` with value true to a function, the function
 * will be invoked with unevaluated arguments, allowing the function
 * to process the arguments in a customized way.
 */
import { create, all } from 'mathjs'
const math = create(all)

/**
 * Calculate the numeric integration of a function
 * @param {Function} f
 * @param {number} start
 * @param {number} end
 * @param {number} [step=0.01]
 */
function integrate (f, start, end, step) {
  let total = 0
  step = step || 0.01
  for (let x = start; x < end; x += step) {
    total += f(x + step / 2) * step
  }
  return total
}

/**
 * A transformation for the integrate function. This transformation will be
 * invoked when the function is used via the expression parser of math.js.
 *
 * Syntax:
 *
 *     integrate(integrand, variable, start, end)
 *     integrate(integrand, variable, start, end, step)
 *
 * Usage:
 *
 *     math.evaluate('integrate(2*x, x, 0, 2)')
 *     math.evaluate('integrate(2*x, x, 0, 2, 0.01)')
 *
 * @param {Array.<math.Node>} args
 *            Expects the following arguments: [f, x, start, end, step]
 * @param {Object} math
 * @param {Map} [scope]
 */
integrate.transform = function (args, math, scope) {
  // determine the variable name
  if (!args[1].isSymbolNode) {
    throw new Error('Second argument must be a symbol')
  }
  const variable = args[1].name

  // evaluate start, end, and step
  const start = args[2].compile().evaluate(scope)
  const end = args[3].compile().evaluate(scope)
  const step = args[4] && args[4].compile().evaluate(scope) // step is optional

  // construct a function which evaluates the first parameter f after applying
  // a value for parameter x.
  const fnCode = args[0].compile()
  const f = function (x) {
    scope.set(variable, x)
    return fnCode.evaluate(scope)
  }

  // execute the integration
  return integrate(f, start, end, step)
}

// mark the transform function with a "rawArgs" property, so it will be called
// with uncompiled, unevaluated arguments.
integrate.transform.rawArgs = true

// import the function into math.js. Raw functions must be imported in the
// math namespace, they can't be used via `evaluate(scope)`.
math.import({
  integrate
})

// use the function in JavaScript
function f (x) {
  return math.pow(x, 0.5)
}
console.log(math.integrate(f, 0, 1)) // outputs 0.6667254718034714

// use the function via the expression parser
console.log(math.evaluate('integrate(x^0.5, x, 0, 1)')) // outputs 0.6667254718034714

// use the function via the expression parser (2)
const scope = new Map()
math.evaluate('f(x) = 2 * x', scope)
console.log(math.evaluate('integrate(f(x), x, 0, 2)', scope)) // outputs 4.000000000000003\n\n\n\nCustom datatype

File: custom_datatype.js

// This example demonstrates importing a custom data type,
// and extending an existing function (add) with support for this data type.

import { all, create, factory } from 'mathjs'

const math = create(all)

// factory function which defines a new data type CustomValue
const createCustomValue = factory('CustomValue', ['typed'], ({ typed }) => {
  // create a new data type
  function CustomValue (value) {
    this.value = value
  }
  CustomValue.prototype.isCustomValue = true
  CustomValue.prototype.toString = function () {
    return 'CustomValue:' + this.value
  }

  // define a new data type with typed-function
  typed.addType({
    name: 'CustomValue',
    test: function (x) {
      // test whether x is of type CustomValue
      return x && x.isCustomValue === true
    }
  })

  return CustomValue
})

// function add which can add the CustomValue data type
// When imported in math.js, the existing function `add` with support for
// CustomValue, because both implementations are typed-functions and do not
// have conflicting signatures.
const createAddCustomValue = factory('add', ['typed', 'CustomValue'], ({ typed, CustomValue }) => {
  return typed('add', {
    'CustomValue, CustomValue': function (a, b) {
      return new CustomValue(a.value + b.value)
    }
  })
})

// import the new data type and function
math.import([
  createCustomValue,
  createAddCustomValue
])

// use the new type
const ans1 = math.add(new math.CustomValue(2), new math.CustomValue(3))
console.log(ans1.toString())
// outputs 'CustomValue:5'

// you can automatically use the new type in functions which use `add` under the hood:
const ans2 = math.sum(new math.CustomValue(6), new math.CustomValue(1), new math.CustomValue(2))
console.log(ans2.toString())
// outputs 'CustomValue:9'\n\n\n\nCustom evaluate using factories

File: custom_evaluate_using_factories.js

// we use the number only implementation in order to not pull in
// the `Unit` class for example. when using as library,
// use import 'mathjs/number'
import { create, evaluateDependencies, factory } from 'mathjs/number'

// custom implementations of all functions you want to support
const add = (a, b) => a + b
const subtract = (a, b) => a - b
const multiply = (a, b) => a * b
const divide = (a, b) => a / b

// create factories for the functions, and create an evaluate function with those
// these functions will also be used by the classes like Unit.
const { evaluate } = create({
  evaluateDependencies,
  createAdd: factory('add', [], () => add),
  createSubtract: factory('subtract', [], () => subtract),
  createMultiply: factory('multiply', [], () => multiply),
  createDivide: factory('divide', [], () => divide)
})

console.log(evaluate('2 + 3 * 4')) // 14\n\n\n\nCustom evaluate using import

File: custom_evaluate_using_import.js

// we use the number only implementation in order to not pull in
// the `Unit` class for example. when using as library,
// use require('mathjs/number')
import { create, evaluateDependencies } from 'mathjs/number'

// custom implementations of all functions you want to support
const add = (a, b) => a + b
const subtract = (a, b) => a - b
const multiply = (a, b) => a * b
const divide = (a, b) => a / b

// create a mathjs instance with hardly any functions
// there are some functions created which are used internally by evaluate though,
// for example by the Unit class which has dependencies on addScalar, subtractScalar,
// multiplyScalar, etc.
const math = create(evaluateDependencies)

// import your own functions
math.import({ add, subtract, multiply, divide }, { override: true })

console.log(math.evaluate('2 + 3 * 4')) // 14\n\n\n\nCustom loading

File: custom_loading.js

import {
  addDependencies,
  create,
  divideDependencies,
  formatDependencies,
  fractionDependencies
} from 'mathjs'

const config = {
  // optionally, you can specify configuration
}

// Create just the functions we need
const { fraction, add, divide, format } = create({
  fractionDependencies,
  addDependencies,
  divideDependencies,
  formatDependencies
}, config)

// Use the created functions
const a = fraction(1, 3)
const b = fraction(3, 7)
const c = add(a, b)
const d = divide(a, b)
console.log('c =', format(c)) // outputs "c = 16/21"
console.log('d =', format(d)) // outputs "d = 7/9"

// Now, when bundling your application for use in the browser, only the used
// parts of math.js will be bundled. For example to create a bundle using Webpack:
//
//     npx webpack-cli ./custom_loading.mjs --output-path custom_loading_bundle --mode=production
//
// Read more about what bundle sizes you can expect here:
//
//     https://mathjs.org/docs/custom_bundling.html\n\n\n\nCustom relational functions

File: custom_relational_functions.js

import { all, create, factory } from 'mathjs'

// First let's see what the default behavior is:
// strings are compared by their numerical value
console.log('default (compare string by their numerical value)')
const { evaluate } = create(all)
evaluateAndLog(evaluate, '2 < 10') // true
evaluateAndLog(evaluate, '"2" < "10"') // true
evaluateAndLog(evaluate, '"a" == "b"') // Error: Cannot convert "a" to a number
evaluateAndLog(evaluate, '"a" == "a"') // Error: Cannot convert "a" to a number
console.log('')

// Suppose we want different behavior for string comparisons. To achieve
// this we can replace the factory functions for all relational functions
// with our own. In this simple example we use the JavaScript implementation.
console.log('custom (compare strings lexically)')

const allWithCustomFunctions = {
  ...all,

  createEqual: factory('equal', [], () => function equal (a, b) {
    return a === b
  }),

  createUnequal: factory('unequal', [], () => function unequal (a, b) {
    return a !== b
  }),

  createSmaller: factory('smaller', [], () => function smaller (a, b) {
    return a < b
  }),

  createSmallerEq: factory('smallerEq', [], () => function smallerEq (a, b) {
    return a <= b
  }),

  createLarger: factory('larger', [], () => function larger (a, b) {
    return a > b
  }),

  createLargerEq: factory('largerEq', [], () => function largerEq (a, b) {
    return a >= b
  }),

  createCompare: factory('compare', [], () => function compare (a, b) {
    return a > b ? 1 : a < b ? -1 : 0
  })
}
const evaluateCustom = create(allWithCustomFunctions).evaluate
evaluateAndLog(evaluateCustom, '2 < 10') // true
evaluateAndLog(evaluateCustom, '"2" < "10"') // false
evaluateAndLog(evaluateCustom, '"a" == "b"') // false
evaluateAndLog(evaluateCustom, '"a" == "a"') // true

// helper function to evaluate an expression and print the results
function evaluateAndLog (evaluate, expression) {
  try {
    console.log(expression, evaluate(expression))
  } catch (err) {
    console.error(expression, err.toString())
  }
}\n\n\n\nCustom scope objects

File: custom_scope_objects.js

import { all, create } from 'mathjs'

const math = create(all)

// The expression evaluator accepts an optional scope Map or object that can
// be used to keep additional variables and functions.

// Scope can be a bare object.
function withObjectScope () {
  const scope = { x: 3 }

  math.evaluate('x', scope) // 1
  math.evaluate('y = 2 x', scope)
  math.evaluate('scalar = 1', scope)
  math.evaluate('area(length, width) = length * width * scalar', scope)
  math.evaluate('A = area(x, y)', scope)

  console.log('Object scope:', scope)
}

// Where flexibility is important, scope can duck type appear to be a Map.
function withMapScope (scope, name) {
  scope.set('x', 3)

  math.evaluate('x', scope) // 1
  math.evaluate('y = 2 x', scope)
  math.evaluate('scalar = 1', scope)
  math.evaluate('area(length, width) = length * width * scalar', scope)
  math.evaluate('A = area(x, y)', scope)

  console.log(`Map-like scope (${name}):`, scope)
}

// This is a minimal set of functions to look like a Map.
class CustomMap {
  constructor () {
    this.localScope = new Map()
  }

  get (key) {
    // Remember to sanitize your inputs, or use
    // a datastructure that isn't a footgun.
    return this.localScope.get(key)
  }

  set (key, value) {
    return this.localScope.set(key, value)
  }

  has (key) {
    return this.localScope.has(key)
  }

  keys () {
    return this.localScope.keys()
  }
}

/*
 * This is a more fully featured example, with all methods
 * used in mathjs.
 *
 */
class AdvancedCustomMap extends CustomMap {
  constructor (parent) {
    super()
    this.parentScope = parent
  }

  get (key) {
    return this.localScope.get(key) ?? this.parentScope?.get(key)
  }

  has (key) {
    return this.localScope.has(key) ?? this.parentScope?.get(key)
  }

  keys () {
    if (this.parentScope) {
      return new Set([...this.localScope.keys(), ...this.parentScope.keys()])
    } else {
      return this.localScope.keys()
    }
  }

  delete () {
    return this.localScope.delete()
  }

  clear () {
    return this.localScope.clear()
  }

  toString () {
    return this.localScope.toString()
  }
}

// Use a plain JavaScript object
withObjectScope()

// use a Map (recommended)
withMapScope(new Map(), 'Map example')

// Use a custom Map implementation
withMapScope(new CustomMap(), 'CustomMap example')

// Use a more advanced custom Map implementation
withMapScope(new AdvancedCustomMap(), 'AdvancedCustomMap example')\n\n\n\nExpression trees

File: expression_trees.js

import { parse, ConstantNode } from 'mathjs'

// Filter an expression tree
console.log('Filter all symbol nodes "x" in the expression "x^2 + x/4 + 3*y"')
const node = parse('x^2 + x/4 + 3*y')
const filtered = node.filter(function (node) {
  return node.isSymbolNode && node.name === 'x'
})
// returns an array with two entries: two SymbolNodes 'x'

filtered.forEach(function (node) {
  console.log(node.type, node.toString())
})
// outputs:
//  SymbolNode x
//  SymbolNode x

// Traverse an expression tree
console.log()
console.log('Traverse the expression tree of expression "3 * x + 2"')
const node1 = parse('3 * x + 2')
node1.traverse(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default: console.log(node.type)
  }
})
// outputs:
//   OperatorNode +
//   OperatorNode *
//   ConstantNode 3
//   SymbolNode x
//   ConstantNode 2

// transform an expression tree
console.log()
console.log('Replace all symbol nodes "x" in expression "x^2 + 5*x" with a constant 3')
const node2 = parse('x^2 + 5*x')
const transformed = node2.transform(function (node, path, parent) {
  if (node.isSymbolNode && node.name === 'x') {
    return new ConstantNode(3)
  } else {
    return node
  }
})
console.log(transformed.toString())
// outputs: '3 ^ 2 + 5 * 3'\n\n\n\nFunction transform

File: function_transform.js

/**
 * Function transforms
 *
 * When using functions via the expression parser, it is possible to preprocess
 * function arguments and post process a functions return value by writing a
 * *transform* for the function. A transform is a function wrapping around a
 * function to be transformed or completely replaces a function.
 */
import { all, create } from 'mathjs'
const math = create(all)

// create a function
function addIt (a, b) {
  return a + b
}

// attach a transform function to the function addIt
addIt.transform = function (a, b) {
  console.log('input: a=' + a + ', b=' + b)
  // we can manipulate the input arguments here before executing addIt

  const res = addIt(a, b)

  console.log('result: ' + res)
  // we can manipulate the result here before returning

  return res
}

// import the function into math.js
math.import({
  addIt: addIt
})

// use the function via the expression parser
console.log('Using expression parser:')
console.log('2+4=' + math.evaluate('addIt(2, 4)'))
// This will output:
//
//     input: a=2, b=4
//     result: 6
//     2+4=6

// when used via plain JavaScript, the transform is not invoked
console.log('')
console.log('Using plain JavaScript:')
console.log('2+4=' + math.addIt(2, 4))
// This will output:
//
//     6\n\n\n\nMore secure eval

File: more_secure_eval.js

// Expression parser security
//
// Executing arbitrary expressions like enabled by the expression parser of
// mathjs involves a risk in general. When you're using mathjs to let users
// execute arbitrary expressions, it's good to take a moment to think about
// possible security and stability implications, especially when running the
// code server side.
//
// There is a small number of functions which yield the biggest security risk
// in the expression parser of math.js:
//
// - `import` and `createUnit` which alter the built-in functionality and allow
//   overriding existing functions and units.
// - `evaluate`, `parse`, `simplify`, and `derivative` which parse arbitrary input
//   into a manipulable expression tree.
//
// To make the expression parser less vulnerable whilst still supporting most
// functionality, these functions can be disabled, as demonstrated in this
// example.

import { all, create } from 'mathjs'
const math = create(all)

const limitedEvaluate = math.evaluate

math.import({
  import: function () { throw new Error('Function import is disabled') },
  createUnit: function () { throw new Error('Function createUnit is disabled') },
  evaluate: function () { throw new Error('Function evaluate is disabled') },
  parse: function () { throw new Error('Function parse is disabled') },
  simplify: function () { throw new Error('Function simplify is disabled') },
  derivative: function () { throw new Error('Function derivative is disabled') }
}, { override: true })

console.log(limitedEvaluate('sqrt(16)')) // Ok, 4
console.log(limitedEvaluate('parse("2+3")')) // Error: Function parse is disabled\n\n\n\nWeb server

File: math_worker.js

const { create, all } = require('../../..')
const workerpool = require('workerpool')
const math = create(all)

// disable the import function so the math.js instance cannot be changed
function noImport () {
  throw new Error('function import is disabled.')
}
math.import({ import: noImport }, { override: true })

/**
 * Evaluate an expression
 * @param {string} expr
 * @return {string} result
 */
function evaluate (expr) {
  const ans = math.evaluate(expr)
  return math.format(ans)
}

// create a worker and register public functions
workerpool.worker({
  evaluate: evaluate
})



File: server.js

/**
 * This example demonstrates how to run math.js in a child process with limited
 * execution time.
 *
 * Prerequisites:
 *
 *     npm install express workerpool
 *
 * Start the server:
 *
 *     node ./server.js
 *
 * Make a request to the server:
 *
 *     GET http://localhost:8080/mathjs?expr=sqrt(16)
 *
 * Note that the query parameter `expr` should be properly url encoded.
 */
const path = require('path')

let express
let workerpool
try {
  express = require('express')
  workerpool = require('workerpool')
} catch (err) {
  console.log('Error: To run this example, install express and workerpool first via:\n\n' +
      '    npm install express workerpool\n')
  process.exit()
}

const app = express()
const pool = workerpool.pool(path.join(__dirname, '/math_worker.js'))

const TIMEOUT = 10000 // milliseconds

/**
 * GET /mathjs?expr=...
 */
app.get('/mathjs', function (req, res) {
  const expr = req.query.expr
  if (expr === undefined) {
    return res.status(400).send('Error: Required query parameter "expr" missing in url.')
  }

  pool.exec('evaluate', [expr])
    .timeout(TIMEOUT)
    .then(function (result) {
      res.send(result)
    })
    .catch(function (err) {
      res.status(400).send(formatError(err))
    })
})

/**
 * Format error messages as string
 * @param {Error} err
 * @return {String} message
 */
function formatError (err) {
  if (err instanceof workerpool.Promise.TimeoutError) {
    return 'TimeoutError: Evaluation exceeded maximum duration of ' + TIMEOUT / 1000 + ' seconds'
  } else {
    return err.toString()
  }
}

// handle uncaught exceptions so the application cannot crash
process.on('uncaughtException', function (err) {
  console.log('Caught exception: ' + err)
  console.trace()
})

// start the server
const PORT = process.env.PORT || 8080
app.listen(PORT, function () {
  console.log('Listening at http://localhost:' + PORT)
  console.log('Example request:\n    GET http://localhost:' + PORT + '/mathjs?expr=sqrt(16)')
})\n\n\n\nCore #

Usage #

The core of math.js is the math namespace containing all functions and constants. There are three ways to do calculations in math.js:


  Doing regular function calls like math.add(math.sqrt(4), 2).
  Evaluating expressions like math.evaluate('sqrt(4) + 2')
  Chaining operations like math.chain(4).sqrt().add(2).


Configuration #

math.js can be configured using the math.config(), see page Configuration.

Extension #

math.js can be extended with new functions and constants using the function math.import(), see page Extension.

Serialization #

To persist or exchange data structures like matrices and units, the data types of math.js can be stringified as JSON. This is explained on the page Serialization.\n\n\n\nCore #

Usage #

The core of math.js is the math namespace containing all functions and constants. There are three ways to do calculations in math.js:


  Doing regular function calls like math.add(math.sqrt(4), 2).
  Evaluating expressions like math.evaluate('sqrt(4) + 2')
  Chaining operations like math.chain(4).sqrt().add(2).


Configuration #

math.js can be configured using the math.config(), see page Configuration.

Extension #

math.js can be extended with new functions and constants using the function math.import(), see page Extension.

Serialization #

To persist or exchange data structures like matrices and units, the data types of math.js can be stringified as JSON. This is explained on the page Serialization.\n\n\n\nCore #

Usage #

The core of math.js is the math namespace containing all functions and constants. There are three ways to do calculations in math.js:


  Doing regular function calls like math.add(math.sqrt(4), 2).
  Evaluating expressions like math.evaluate('sqrt(4) + 2')
  Chaining operations like math.chain(4).sqrt().add(2).


Configuration #

math.js can be configured using the math.config(), see page Configuration.

Extension #

math.js can be extended with new functions and constants using the function math.import(), see page Extension.

Serialization #

To persist or exchange data structures like matrices and units, the data types of math.js can be stringified as JSON. This is explained on the page Serialization.\n\n\n\nCore #

Usage #

The core of math.js is the math namespace containing all functions and constants. There are three ways to do calculations in math.js:


  Doing regular function calls like math.add(math.sqrt(4), 2).
  Evaluating expressions like math.evaluate('sqrt(4) + 2')
  Chaining operations like math.chain(4).sqrt().add(2).


Configuration #

math.js can be configured using the math.config(), see page Configuration.

Extension #

math.js can be extended with new functions and constants using the function math.import(), see page Extension.

Serialization #

To persist or exchange data structures like matrices and units, the data types of math.js can be stringified as JSON. This is explained on the page Serialization.\n\n\n\nCore #

Usage #

The core of math.js is the math namespace containing all functions and constants. There are three ways to do calculations in math.js:


  Doing regular function calls like math.add(math.sqrt(4), 2).
  Evaluating expressions like math.evaluate('sqrt(4) + 2')
  Chaining operations like math.chain(4).sqrt().add(2).


Configuration #

math.js can be configured using the math.config(), see page Configuration.

Extension #

math.js can be extended with new functions and constants using the function math.import(), see page Extension.

Serialization #

To persist or exchange data structures like matrices and units, the data types of math.js can be stringified as JSON. This is explained on the page Serialization.\n\n\n\nConfiguration #

Math.js contains a number of configuration options.
These options can be applied on a created mathjs instance and changed afterwards.

import { create, all } from 'mathjs'

// create a mathjs instance with configuration
const config = {
  relTol: 1e-12,
  absTol: 1e-15,
  matrix: 'Matrix',
  number: 'number',
  precision: 64,
  predictable: false,
  randomSeed: null
}
const math = create(all, config)

// read the applied configuration
console.log(math.config())

// change the configuration
math.config({
  number: 'BigNumber'
})


The following configuration options are available:


  
    relTol. The minimum relative difference used to test equality between two
compared values. This value is used by all relational functions.
Default value is 1e-12.
  
  
    absTol. The minimum absolute difference used to test equality between two
compared values. This value is used by all relational functions.
Default value is 1e-15.
  
  
    matrix. The default type of matrix output for functions.
Available values are: 'Matrix' (default) or 'Array'.
Where possible, the type of matrix output from functions is determined from
the function input: An array as input will return an Array, a Matrix as input
will return a Matrix. In case of no matrix as input, the type of output is
determined by the option matrix. In case of mixed matrix
inputs, a matrix will be returned always.
  
  
    number. The type used to parse strings into a numeric value or create a new
numeric value internally.

    For most functions, the type of output is determined from the input: 
a number as input will return a number as output, a BigNumber as input 
returns a BigNumber as output. But for example the functions 
math.evaluate('2+3'), math.parse('2+3'), math.range('1:10'), 
and math.unit('5cm') use the number configuration setting.

    Note that math.sqrt(4) will always return the number 2 regardless of 
the number configuration, because the numeric type can be determined from 
the input value.

    Available values are: 'number' (default), 'BigNumber', 'bigint', or 'Fraction'.
BigNumbers have higher precision than the default numbers of JavaScript, 
bigint can represent large integer numbers, 
and Fractions store values in terms of a numerator and 
denominator.
  
  
    numberFallback. When number is configured for example with value 'bigint',
and a value cannot be represented as bigint like in math.evaluate('2.3'), 
the value will be parsed in the type configured with numberFallback. 
Available values: 'number' (default) or 'BigNumber'.
  
  
    precision. The maximum number of significant digits for BigNumbers.
This setting only applies to BigNumbers, not to numbers.
Default value is 64.
  
  
    predictable. Predictable output type of functions. When true, output type
depends only on the input types. When false (default), output type can vary
depending on input values. For example math.sqrt(-4) returns complex('2i') when
predictable is false, and returns NaN when true.
Predictable output can be needed when programmatically handling the result of
a calculation, but can be inconvenient for users when evaluating dynamic
equations.
  
  
    randomSeed. Set this option to seed pseudo random number generation, making it deterministic. The pseudo random number generator is reset with the seed provided each time this option is set. For example, setting it to 'a' will cause math.random() to return 0.43449421599986604 upon the first call after setting the option every time. Set to null to seed the pseudo random number generator with a random seed. Default value is null.
  


Examples #

This section shows a number of configuration examples.

node.js #

import { create, all } from 'mathjs'

const config = {
  matrix: 'Array' // Choose 'Matrix' (default) or 'Array'
}
const math = create(all, config)

// range will output an Array
math.range(0, 4) // Array [0, 1, 2, 3]

// change the configuration from Arrays to Matrices
math.config({
  matrix: 'Matrix' // Choose 'Matrix' (default) or 'Array'
})

// range will output a Matrix
math.range(0, 4) // Matrix [0, 1, 2, 3]

// create an instance of math.js with BigNumber configuration
const bigmath = create(all, {
  number: 'BigNumber', // Choose 'number' (default), 'BigNumber', or 'Fraction'
  precision: 32        // 64 by default, only applicable for BigNumbers
})

// parser will parse numbers as BigNumber now:
bigmath.evaluate('1 / 3') // BigNumber, 0.33333333333333333333333333333333


browser #

<!DOCTYPE HTML>
<html>
<head>
  <script src="math.js" type="text/javascript"></script>
</head>
<body>
  <script type="text/javascript">
    // the default instance of math.js is available as 'math'

    // range will output a Matrix
    math.range(0, 4)          // Matrix [0, 1, 2, 3]

    // change the configuration of math from Matrices to Arrays
    math.config({
      matrix: 'Array'         // Choose 'Matrix' (default) or 'Array'
    })

    // range will output an Array
    math.range(0, 4)          // Array [0, 1, 2, 3]

    // create a new instance of math.js with bignumber configuration
    const bigmath = math.create({
      number: 'BigNumber',    // Choose 'number' (default), 'BigNumber', or 'Fraction'
      precision: 32           // 64 by default, only applicable for BigNumbers
    })

    // parser will parse numbers as BigNumber now:
    bigmath.evaluate('1 / 3') // BigNumber, 0.33333333333333333333333333333333
  </script>
</body>
</html>\n\n\n\nConfiguration #

Math.js contains a number of configuration options.
These options can be applied on a created mathjs instance and changed afterwards.

import { create, all } from 'mathjs'

// create a mathjs instance with configuration
const config = {
  relTol: 1e-12,
  absTol: 1e-15,
  matrix: 'Matrix',
  number: 'number',
  precision: 64,
  predictable: false,
  randomSeed: null
}
const math = create(all, config)

// read the applied configuration
console.log(math.config())

// change the configuration
math.config({
  number: 'BigNumber'
})


The following configuration options are available:


  
    relTol. The minimum relative difference used to test equality between two
compared values. This value is used by all relational functions.
Default value is 1e-12.
  
  
    absTol. The minimum absolute difference used to test equality between two
compared values. This value is used by all relational functions.
Default value is 1e-15.
  
  
    matrix. The default type of matrix output for functions.
Available values are: 'Matrix' (default) or 'Array'.
Where possible, the type of matrix output from functions is determined from
the function input: An array as input will return an Array, a Matrix as input
will return a Matrix. In case of no matrix as input, the type of output is
determined by the option matrix. In case of mixed matrix
inputs, a matrix will be returned always.
  
  
    number. The type used to parse strings into a numeric value or create a new
numeric value internally.

    For most functions, the type of output is determined from the input: 
a number as input will return a number as output, a BigNumber as input 
returns a BigNumber as output. But for example the functions 
math.evaluate('2+3'), math.parse('2+3'), math.range('1:10'), 
and math.unit('5cm') use the number configuration setting.

    Note that math.sqrt(4) will always return the number 2 regardless of 
the number configuration, because the numeric type can be determined from 
the input value.

    Available values are: 'number' (default), 'BigNumber', 'bigint', or 'Fraction'.
BigNumbers have higher precision than the default numbers of JavaScript, 
bigint can represent large integer numbers, 
and Fractions store values in terms of a numerator and 
denominator.
  
  
    numberFallback. When number is configured for example with value 'bigint',
and a value cannot be represented as bigint like in math.evaluate('2.3'), 
the value will be parsed in the type configured with numberFallback. 
Available values: 'number' (default) or 'BigNumber'.
  
  
    precision. The maximum number of significant digits for BigNumbers.
This setting only applies to BigNumbers, not to numbers.
Default value is 64.
  
  
    predictable. Predictable output type of functions. When true, output type
depends only on the input types. When false (default), output type can vary
depending on input values. For example math.sqrt(-4) returns complex('2i') when
predictable is false, and returns NaN when true.
Predictable output can be needed when programmatically handling the result of
a calculation, but can be inconvenient for users when evaluating dynamic
equations.
  
  
    randomSeed. Set this option to seed pseudo random number generation, making it deterministic. The pseudo random number generator is reset with the seed provided each time this option is set. For example, setting it to 'a' will cause math.random() to return 0.43449421599986604 upon the first call after setting the option every time. Set to null to seed the pseudo random number generator with a random seed. Default value is null.
  


Examples #

This section shows a number of configuration examples.

node.js #

import { create, all } from 'mathjs'

const config = {
  matrix: 'Array' // Choose 'Matrix' (default) or 'Array'
}
const math = create(all, config)

// range will output an Array
math.range(0, 4) // Array [0, 1, 2, 3]

// change the configuration from Arrays to Matrices
math.config({
  matrix: 'Matrix' // Choose 'Matrix' (default) or 'Array'
})

// range will output a Matrix
math.range(0, 4) // Matrix [0, 1, 2, 3]

// create an instance of math.js with BigNumber configuration
const bigmath = create(all, {
  number: 'BigNumber', // Choose 'number' (default), 'BigNumber', or 'Fraction'
  precision: 32        // 64 by default, only applicable for BigNumbers
})

// parser will parse numbers as BigNumber now:
bigmath.evaluate('1 / 3') // BigNumber, 0.33333333333333333333333333333333


browser #

<!DOCTYPE HTML>
<html>
<head>
  <script src="math.js" type="text/javascript"></script>
</head>
<body>
  <script type="text/javascript">
    // the default instance of math.js is available as 'math'

    // range will output a Matrix
    math.range(0, 4)          // Matrix [0, 1, 2, 3]

    // change the configuration of math from Matrices to Arrays
    math.config({
      matrix: 'Array'         // Choose 'Matrix' (default) or 'Array'
    })

    // range will output an Array
    math.range(0, 4)          // Array [0, 1, 2, 3]

    // create a new instance of math.js with bignumber configuration
    const bigmath = math.create({
      number: 'BigNumber',    // Choose 'number' (default), 'BigNumber', or 'Fraction'
      precision: 32           // 64 by default, only applicable for BigNumbers
    })

    // parser will parse numbers as BigNumber now:
    bigmath.evaluate('1 / 3') // BigNumber, 0.33333333333333333333333333333333
  </script>
</body>
</html>\n\n\n\nConfiguration #

Math.js contains a number of configuration options.
These options can be applied on a created mathjs instance and changed afterwards.

import { create, all } from 'mathjs'

// create a mathjs instance with configuration
const config = {
  relTol: 1e-12,
  absTol: 1e-15,
  matrix: 'Matrix',
  number: 'number',
  precision: 64,
  predictable: false,
  randomSeed: null
}
const math = create(all, config)

// read the applied configuration
console.log(math.config())

// change the configuration
math.config({
  number: 'BigNumber'
})


The following configuration options are available:


  
    relTol. The minimum relative difference used to test equality between two
compared values. This value is used by all relational functions.
Default value is 1e-12.
  
  
    absTol. The minimum absolute difference used to test equality between two
compared values. This value is used by all relational functions.
Default value is 1e-15.
  
  
    matrix. The default type of matrix output for functions.
Available values are: 'Matrix' (default) or 'Array'.
Where possible, the type of matrix output from functions is determined from
the function input: An array as input will return an Array, a Matrix as input
will return a Matrix. In case of no matrix as input, the type of output is
determined by the option matrix. In case of mixed matrix
inputs, a matrix will be returned always.
  
  
    number. The type used to parse strings into a numeric value or create a new
numeric value internally.

    For most functions, the type of output is determined from the input: 
a number as input will return a number as output, a BigNumber as input 
returns a BigNumber as output. But for example the functions 
math.evaluate('2+3'), math.parse('2+3'), math.range('1:10'), 
and math.unit('5cm') use the number configuration setting.

    Note that math.sqrt(4) will always return the number 2 regardless of 
the number configuration, because the numeric type can be determined from 
the input value.

    Available values are: 'number' (default), 'BigNumber', 'bigint', or 'Fraction'.
BigNumbers have higher precision than the default numbers of JavaScript, 
bigint can represent large integer numbers, 
and Fractions store values in terms of a numerator and 
denominator.
  
  
    numberFallback. When number is configured for example with value 'bigint',
and a value cannot be represented as bigint like in math.evaluate('2.3'), 
the value will be parsed in the type configured with numberFallback. 
Available values: 'number' (default) or 'BigNumber'.
  
  
    precision. The maximum number of significant digits for BigNumbers.
This setting only applies to BigNumbers, not to numbers.
Default value is 64.
  
  
    predictable. Predictable output type of functions. When true, output type
depends only on the input types. When false (default), output type can vary
depending on input values. For example math.sqrt(-4) returns complex('2i') when
predictable is false, and returns NaN when true.
Predictable output can be needed when programmatically handling the result of
a calculation, but can be inconvenient for users when evaluating dynamic
equations.
  
  
    randomSeed. Set this option to seed pseudo random number generation, making it deterministic. The pseudo random number generator is reset with the seed provided each time this option is set. For example, setting it to 'a' will cause math.random() to return 0.43449421599986604 upon the first call after setting the option every time. Set to null to seed the pseudo random number generator with a random seed. Default value is null.
  


Examples #

This section shows a number of configuration examples.

node.js #

import { create, all } from 'mathjs'

const config = {
  matrix: 'Array' // Choose 'Matrix' (default) or 'Array'
}
const math = create(all, config)

// range will output an Array
math.range(0, 4) // Array [0, 1, 2, 3]

// change the configuration from Arrays to Matrices
math.config({
  matrix: 'Matrix' // Choose 'Matrix' (default) or 'Array'
})

// range will output a Matrix
math.range(0, 4) // Matrix [0, 1, 2, 3]

// create an instance of math.js with BigNumber configuration
const bigmath = create(all, {
  number: 'BigNumber', // Choose 'number' (default), 'BigNumber', or 'Fraction'
  precision: 32        // 64 by default, only applicable for BigNumbers
})

// parser will parse numbers as BigNumber now:
bigmath.evaluate('1 / 3') // BigNumber, 0.33333333333333333333333333333333


browser #

<!DOCTYPE HTML>
<html>
<head>
  <script src="math.js" type="text/javascript"></script>
</head>
<body>
  <script type="text/javascript">
    // the default instance of math.js is available as 'math'

    // range will output a Matrix
    math.range(0, 4)          // Matrix [0, 1, 2, 3]

    // change the configuration of math from Matrices to Arrays
    math.config({
      matrix: 'Array'         // Choose 'Matrix' (default) or 'Array'
    })

    // range will output an Array
    math.range(0, 4)          // Array [0, 1, 2, 3]

    // create a new instance of math.js with bignumber configuration
    const bigmath = math.create({
      number: 'BigNumber',    // Choose 'number' (default), 'BigNumber', or 'Fraction'
      precision: 32           // 64 by default, only applicable for BigNumbers
    })

    // parser will parse numbers as BigNumber now:
    bigmath.evaluate('1 / 3') // BigNumber, 0.33333333333333333333333333333333
  </script>
</body>
</html>\n\n\n\nConfiguration #

Math.js contains a number of configuration options.
These options can be applied on a created mathjs instance and changed afterwards.

import { create, all } from 'mathjs'

// create a mathjs instance with configuration
const config = {
  relTol: 1e-12,
  absTol: 1e-15,
  matrix: 'Matrix',
  number: 'number',
  precision: 64,
  predictable: false,
  randomSeed: null
}
const math = create(all, config)

// read the applied configuration
console.log(math.config())

// change the configuration
math.config({
  number: 'BigNumber'
})


The following configuration options are available:


  
    relTol. The minimum relative difference used to test equality between two
compared values. This value is used by all relational functions.
Default value is 1e-12.
  
  
    absTol. The minimum absolute difference used to test equality between two
compared values. This value is used by all relational functions.
Default value is 1e-15.
  
  
    matrix. The default type of matrix output for functions.
Available values are: 'Matrix' (default) or 'Array'.
Where possible, the type of matrix output from functions is determined from
the function input: An array as input will return an Array, a Matrix as input
will return a Matrix. In case of no matrix as input, the type of output is
determined by the option matrix. In case of mixed matrix
inputs, a matrix will be returned always.
  
  
    number. The type used to parse strings into a numeric value or create a new
numeric value internally.

    For most functions, the type of output is determined from the input: 
a number as input will return a number as output, a BigNumber as input 
returns a BigNumber as output. But for example the functions 
math.evaluate('2+3'), math.parse('2+3'), math.range('1:10'), 
and math.unit('5cm') use the number configuration setting.

    Note that math.sqrt(4) will always return the number 2 regardless of 
the number configuration, because the numeric type can be determined from 
the input value.

    Available values are: 'number' (default), 'BigNumber', 'bigint', or 'Fraction'.
BigNumbers have higher precision than the default numbers of JavaScript, 
bigint can represent large integer numbers, 
and Fractions store values in terms of a numerator and 
denominator.
  
  
    numberFallback. When number is configured for example with value 'bigint',
and a value cannot be represented as bigint like in math.evaluate('2.3'), 
the value will be parsed in the type configured with numberFallback. 
Available values: 'number' (default) or 'BigNumber'.
  
  
    precision. The maximum number of significant digits for BigNumbers.
This setting only applies to BigNumbers, not to numbers.
Default value is 64.
  
  
    predictable. Predictable output type of functions. When true, output type
depends only on the input types. When false (default), output type can vary
depending on input values. For example math.sqrt(-4) returns complex('2i') when
predictable is false, and returns NaN when true.
Predictable output can be needed when programmatically handling the result of
a calculation, but can be inconvenient for users when evaluating dynamic
equations.
  
  
    randomSeed. Set this option to seed pseudo random number generation, making it deterministic. The pseudo random number generator is reset with the seed provided each time this option is set. For example, setting it to 'a' will cause math.random() to return 0.43449421599986604 upon the first call after setting the option every time. Set to null to seed the pseudo random number generator with a random seed. Default value is null.
  


Examples #

This section shows a number of configuration examples.

node.js #

import { create, all } from 'mathjs'

const config = {
  matrix: 'Array' // Choose 'Matrix' (default) or 'Array'
}
const math = create(all, config)

// range will output an Array
math.range(0, 4) // Array [0, 1, 2, 3]

// change the configuration from Arrays to Matrices
math.config({
  matrix: 'Matrix' // Choose 'Matrix' (default) or 'Array'
})

// range will output a Matrix
math.range(0, 4) // Matrix [0, 1, 2, 3]

// create an instance of math.js with BigNumber configuration
const bigmath = create(all, {
  number: 'BigNumber', // Choose 'number' (default), 'BigNumber', or 'Fraction'
  precision: 32        // 64 by default, only applicable for BigNumbers
})

// parser will parse numbers as BigNumber now:
bigmath.evaluate('1 / 3') // BigNumber, 0.33333333333333333333333333333333


browser #

<!DOCTYPE HTML>
<html>
<head>
  <script src="math.js" type="text/javascript"></script>
</head>
<body>
  <script type="text/javascript">
    // the default instance of math.js is available as 'math'

    // range will output a Matrix
    math.range(0, 4)          // Matrix [0, 1, 2, 3]

    // change the configuration of math from Matrices to Arrays
    math.config({
      matrix: 'Array'         // Choose 'Matrix' (default) or 'Array'
    })

    // range will output an Array
    math.range(0, 4)          // Array [0, 1, 2, 3]

    // create a new instance of math.js with bignumber configuration
    const bigmath = math.create({
      number: 'BigNumber',    // Choose 'number' (default), 'BigNumber', or 'Fraction'
      precision: 32           // 64 by default, only applicable for BigNumbers
    })

    // parser will parse numbers as BigNumber now:
    bigmath.evaluate('1 / 3') // BigNumber, 0.33333333333333333333333333333333
  </script>
</body>
</html>\n\n\n\nChaining #

Math.js supports chaining operations by wrapping a value into a Chain.
A chain can be created with the function math.chain(value)
(formerly math.select(value)).
All functions available in the math namespace can be executed via the chain.
The functions will be executed with the chain’s value as the first argument,
followed by extra arguments provided by the function call itself.

math.chain(3)
    .add(4)
    .subtract(2)
    .done() // 5

math.chain( [[1, 2], [3, 4]] )
    .subset(math.index(0, 0), 8)
    .multiply(3)
    .done() // [[24, 6], [9, 12]]


API #

A Chain is constructed as:

math.chain()
math.chain(value)


The Chain has all functions available in the math namespace, and has
a number of special functions:


  done()
Finalize the chain and return the chain’s value.
  valueOf()
The same as done(), returns the chain’s value.
  toString()
Executes math.format(value) onto the chain’s value, returning
a string representation of the value.


Note that a “rest” or “…” parameter may not be broken across the value
in the chain and a function call. For example

math.chain(3).median(4,5).done() // throws error


does not compute the median of 3, 4, and 5.\n\n\n\nChaining #

Math.js supports chaining operations by wrapping a value into a Chain.
A chain can be created with the function math.chain(value)
(formerly math.select(value)).
All functions available in the math namespace can be executed via the chain.
The functions will be executed with the chain’s value as the first argument,
followed by extra arguments provided by the function call itself.

math.chain(3)
    .add(4)
    .subtract(2)
    .done() // 5

math.chain( [[1, 2], [3, 4]] )
    .subset(math.index(0, 0), 8)
    .multiply(3)
    .done() // [[24, 6], [9, 12]]


API #

A Chain is constructed as:

math.chain()
math.chain(value)


The Chain has all functions available in the math namespace, and has
a number of special functions:


  done()
Finalize the chain and return the chain’s value.
  valueOf()
The same as done(), returns the chain’s value.
  toString()
Executes math.format(value) onto the chain’s value, returning
a string representation of the value.


Note that a “rest” or “…” parameter may not be broken across the value
in the chain and a function call. For example

math.chain(3).median(4,5).done() // throws error


does not compute the median of 3, 4, and 5.\n\n\n\nExtension #

The library can easily be extended with functions and variables using the
import function. The import function is available on a mathjs instance, which can be created using the create function.

import { create, all } from 'mathjs'

const math = create(all)

math.import(/* ... */)


The function import accepts an object with functions and variables, or an array with factory functions. It has the following syntax:

math.import(functions: Object [, options: Object])


Where:


  
    functions is an object or array containing the functions and/or values to be
imported. import support regular values and functions, typed functions
(see section Typed functions), and factory functions
(see section Factory functions).
An array is only applicable when it contains factory functions.
  
  
    options is an optional second argument with options.
The following options are available:

    
      {boolean} override
If true, existing functions will be overwritten. The default value is false.
      {boolean} silent
If true, the function will not throw errors on duplicates or invalid
types. Default value is false.
      {boolean} wrap
If true, the functions will be wrapped in a wrapper function which
converts data types like Matrix to primitive data types like Array.
The wrapper is needed when extending math.js with libraries which do not
support the math.js data types. The default value is false.
    
  


The following code example shows how to import a function and a value into math.js:

// define new functions and variables
math.import({
  myvalue: 42,
  hello: function (name) {
    return 'hello, ' + name + '!'
  }
})

// defined functions can be used in both JavaScript as well as the parser
math.myvalue * 2                 // 84
math.hello('user')               // 'hello, user!'

const parser = math.parser()
parser.evaluate('myvalue + 10')  // 52
parser.evaluate('hello("user")') // 'hello, user!'


Import external libraries #

External libraries like
numbers.js and
numeric.js can be imported as follows.
The libraries must be installed using npm:

$ npm install numbers
$ npm install numeric


The libraries can be easily imported into math.js using import.
In order to convert math.js specific data types like Matrix to primitive types
like Array, the imported functions can be wrapped by enabling {wrap: true}.

import { create, all } from 'mathjs'
import * as numbers from 'numbers'
import * as numeric from 'numeric'

// create a mathjs instance and import the numbers.js and numeric.js libraries
const math = create(all)
math.import(numbers, {wrap: true, silent: true})
math.import(numeric, {wrap: true, silent: true})

// use functions from numbers.js
math.fibonacci(7)                           // 13
math.evaluate('fibonacci(7)')               // 13

// use functions from numeric.js
math.evaluate('eig([1, 2; 4, 3])').lambda.x // [5, -1]


Typed functions #

Typed functions can be created using math.typed. A typed function is a function
which does type checking on the input arguments. It can have multiple signatures.
And can automatically convert input types where needed.

A typed function can be created like:

const max = typed('max', {
  'number, number': function (a, b) {
    return Math.max(a, b)
  },

  'BigNumber, BigNumber': function (a, b) {
    return a.greaterThan(b) ? a : b
  }
})


Typed functions can be merged as long as there are no conflicts in the signatures.
This allows for extending existing functions in math.js with support for new
data types.

// create a new data type
function MyType (value) {
  this.value = value
}
MyType.prototype.isMyType = true
MyType.prototype.toString = function () {
  return 'MyType:' + this.value
}

// define a new datatype
math.typed.addType({
  name: 'MyType',
  test: function (x) {
    // test whether x is of type MyType
    return x && x.isMyType
  }
})

// use the type in a new typed function
const add = typed('add', {
  'MyType, MyType': function (a, b) {
    return new MyType(a.value + b.value)
  }
})

// import in math.js, extend the existing function `add` with support for MyType
math.import({add: add})

// use the new type
const ans = math.add(new MyType(2), new MyType(3)) // returns MyType(5)
console.log(ans)                                 // outputs 'MyType:5'


Detailed information on typed functions is available here:
https://github.com/josdejong/typed-function

Factory functions #

Regular JavaScript functions can be imported in math.js using math.import:

math.import({
  myFunction: function (a, b) {
     // ...
  }
})


The function can be stored in a separate file:

export function myFunction (a, b) {
  // ...
}


Which can be imported like:

import { myFunction } from './myFunction.js'

math.import({
  myFunction
})


An issue arises when myFunction needs functionality from math.js:
it doesn’t have access to the current instance of math.js when in a separate file.
Factory functions can be used to solve this issue. A factory function allows to inject dependencies into a function when creating it.

A syntax of factory function is:

factory(name: string, dependencies: string[], create: function, meta?: Object): function


where:


  name is the name of the created function.
  dependencies is an array with names of the dependent functions.
  create is a function which creates the function.
An object with the dependencies is passed as first argument.
  meta An optional object which can contain any meta data you want.
This will be attached as a property meta on the created function.
Known meta data properties used by the mathjs instance are:
    
      isClass: boolean  If true, the created function is supposed to be a
class, and for example will not be exposed in the expression parser
for security reasons.
      lazy: boolean.  By default, everything is imported lazily by import.
only as soon as the imported function or constant is actually used, it
will be constructed. A function can be forced to be created immediately
by setting lazy: false in the meta data.
      isTransformFunction: boolean. If true, the created function is imported
as a transform function. It will not be imported in math itself, only
in the internal mathWithTransform namespace that is used by the
expression parser.
      recreateOnConfigChange: boolean. If true, the imported factory will be
created again when there is a change in the configuration. This is for
example used for the constants like pi, which is different depending
on the configsetting number which can be numbers or BigNumbers.
      formerly: string. If present, the created function will also be
accessible on the instance under the name given by the value of
formerly as a (deprecated) synonym for the specified name. This
facility should only be used when a function is renamed, to allow
temporary use of the previous name, for backward compatibility.
    
  


Here an example of a factory function which depends on multiply:

import { factory, create, all } from 'mathjs'

// create a factory function
const name = 'negativeSquare'
const dependencies = ['multiply', 'unaryMinus']
const createNegativeSquare = factory(name, dependencies, function ({ multiply, unaryMinus }) {
    return function negativeSquare (x) {
      return unaryMinus(multiply(x, x))
    }
  })

// create an instance of the function yourself:
const multiply = (a, b) => a * b
const unaryMinus = (a) => -a
const negativeSquare = createNegativeSquare({ multiply, unaryMinus })
console.log(negativeSquare(3)) // -9

// or import the factory in a mathjs instance and use it there
const math = create(all)
math.import(createNegativeSquare)
console.log(math.negativeSquare(4)) // -16
console.log(math.evaluate('negativeSquare(5)')) // -25


You may wonder why you would inject functions multiply and unaryMinus
instead of just doing these calculations inside the function itself. The
reason is that this makes the factory function negativeSquare work for
different implementations: numbers, BigNumbers, units, etc.

import { Decimal } from 'decimal.js'

// create an instance of our negativeSquare supporting BigNumbers instead of numbers
const multiply = (a, b) => a.mul(b)
const unaryMinus = (a) => new Decimal(0).minus(a)
const negativeSquare = createNegativeSquare({ multiply, unaryMinus })\n\n\n\nFunction import #

Import functions from an object or a module.

This function is only available on a mathjs instance created using create.

Syntax #

math.import(functions)
math.import(functions, options)


Where #


  functions: Object
An object with functions or factories to be imported.
  options: Object An object with import options. Available options:
    
      override: boolean
If true, existing functions will be overwritten. False by default.
      silent: boolean
If true, the function will not throw errors on duplicates or invalid
types. False by default.
      wrap: boolean
If true, the functions will be wrapped in a wrapper function
which converts data types like Matrix to primitive data types like Array.
The wrapper is needed when extending math.js with libraries which do not
support these data type. False by default.
    
  


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      functions
      Object | Array
      Object with functions to be imported.
    
    
      options
      Object
      Import options.
    
  


Throws #

Type | Description
—- | ———–

Examples #

import { create, all } from 'mathjs'
import * as numbers from 'numbers'

// create a mathjs instance
const math = create(all)

// define new functions and variables
math.import({
  myvalue: 42,
  hello: function (name) {
    return 'hello, ' + name + '!'
  }
})

// use the imported function and variable
math.myvalue * 2               // 84
math.hello('user')             // 'hello, user!'

// import the npm module 'numbers'
// (must be installed first with `npm install numbers`)
math.import(numbers, {wrap: true})

math.fibonacci(7) // returns 13\n\n\n\nExtension #

The library can easily be extended with functions and variables using the
import function. The import function is available on a mathjs instance, which can be created using the create function.

import { create, all } from 'mathjs'

const math = create(all)

math.import(/* ... */)


The function import accepts an object with functions and variables, or an array with factory functions. It has the following syntax:

math.import(functions: Object [, options: Object])


Where:


  
    functions is an object or array containing the functions and/or values to be
imported. import support regular values and functions, typed functions
(see section Typed functions), and factory functions
(see section Factory functions).
An array is only applicable when it contains factory functions.
  
  
    options is an optional second argument with options.
The following options are available:

    
      {boolean} override
If true, existing functions will be overwritten. The default value is false.
      {boolean} silent
If true, the function will not throw errors on duplicates or invalid
types. Default value is false.
      {boolean} wrap
If true, the functions will be wrapped in a wrapper function which
converts data types like Matrix to primitive data types like Array.
The wrapper is needed when extending math.js with libraries which do not
support the math.js data types. The default value is false.
    
  


The following code example shows how to import a function and a value into math.js:

// define new functions and variables
math.import({
  myvalue: 42,
  hello: function (name) {
    return 'hello, ' + name + '!'
  }
})

// defined functions can be used in both JavaScript as well as the parser
math.myvalue * 2                 // 84
math.hello('user')               // 'hello, user!'

const parser = math.parser()
parser.evaluate('myvalue + 10')  // 52
parser.evaluate('hello("user")') // 'hello, user!'


Import external libraries #

External libraries like
numbers.js and
numeric.js can be imported as follows.
The libraries must be installed using npm:

$ npm install numbers
$ npm install numeric


The libraries can be easily imported into math.js using import.
In order to convert math.js specific data types like Matrix to primitive types
like Array, the imported functions can be wrapped by enabling {wrap: true}.

import { create, all } from 'mathjs'
import * as numbers from 'numbers'
import * as numeric from 'numeric'

// create a mathjs instance and import the numbers.js and numeric.js libraries
const math = create(all)
math.import(numbers, {wrap: true, silent: true})
math.import(numeric, {wrap: true, silent: true})

// use functions from numbers.js
math.fibonacci(7)                           // 13
math.evaluate('fibonacci(7)')               // 13

// use functions from numeric.js
math.evaluate('eig([1, 2; 4, 3])').lambda.x // [5, -1]


Typed functions #

Typed functions can be created using math.typed. A typed function is a function
which does type checking on the input arguments. It can have multiple signatures.
And can automatically convert input types where needed.

A typed function can be created like:

const max = typed('max', {
  'number, number': function (a, b) {
    return Math.max(a, b)
  },

  'BigNumber, BigNumber': function (a, b) {
    return a.greaterThan(b) ? a : b
  }
})


Typed functions can be merged as long as there are no conflicts in the signatures.
This allows for extending existing functions in math.js with support for new
data types.

// create a new data type
function MyType (value) {
  this.value = value
}
MyType.prototype.isMyType = true
MyType.prototype.toString = function () {
  return 'MyType:' + this.value
}

// define a new datatype
math.typed.addType({
  name: 'MyType',
  test: function (x) {
    // test whether x is of type MyType
    return x && x.isMyType
  }
})

// use the type in a new typed function
const add = typed('add', {
  'MyType, MyType': function (a, b) {
    return new MyType(a.value + b.value)
  }
})

// import in math.js, extend the existing function `add` with support for MyType
math.import({add: add})

// use the new type
const ans = math.add(new MyType(2), new MyType(3)) // returns MyType(5)
console.log(ans)                                 // outputs 'MyType:5'


Detailed information on typed functions is available here:
https://github.com/josdejong/typed-function

Factory functions #

Regular JavaScript functions can be imported in math.js using math.import:

math.import({
  myFunction: function (a, b) {
     // ...
  }
})


The function can be stored in a separate file:

export function myFunction (a, b) {
  // ...
}


Which can be imported like:

import { myFunction } from './myFunction.js'

math.import({
  myFunction
})


An issue arises when myFunction needs functionality from math.js:
it doesn’t have access to the current instance of math.js when in a separate file.
Factory functions can be used to solve this issue. A factory function allows to inject dependencies into a function when creating it.

A syntax of factory function is:

factory(name: string, dependencies: string[], create: function, meta?: Object): function


where:


  name is the name of the created function.
  dependencies is an array with names of the dependent functions.
  create is a function which creates the function.
An object with the dependencies is passed as first argument.
  meta An optional object which can contain any meta data you want.
This will be attached as a property meta on the created function.
Known meta data properties used by the mathjs instance are:
    
      isClass: boolean  If true, the created function is supposed to be a
class, and for example will not be exposed in the expression parser
for security reasons.
      lazy: boolean.  By default, everything is imported lazily by import.
only as soon as the imported function or constant is actually used, it
will be constructed. A function can be forced to be created immediately
by setting lazy: false in the meta data.
      isTransformFunction: boolean. If true, the created function is imported
as a transform function. It will not be imported in math itself, only
in the internal mathWithTransform namespace that is used by the
expression parser.
      recreateOnConfigChange: boolean. If true, the imported factory will be
created again when there is a change in the configuration. This is for
example used for the constants like pi, which is different depending
on the configsetting number which can be numbers or BigNumbers.
      formerly: string. If present, the created function will also be
accessible on the instance under the name given by the value of
formerly as a (deprecated) synonym for the specified name. This
facility should only be used when a function is renamed, to allow
temporary use of the previous name, for backward compatibility.
    
  


Here an example of a factory function which depends on multiply:

import { factory, create, all } from 'mathjs'

// create a factory function
const name = 'negativeSquare'
const dependencies = ['multiply', 'unaryMinus']
const createNegativeSquare = factory(name, dependencies, function ({ multiply, unaryMinus }) {
    return function negativeSquare (x) {
      return unaryMinus(multiply(x, x))
    }
  })

// create an instance of the function yourself:
const multiply = (a, b) => a * b
const unaryMinus = (a) => -a
const negativeSquare = createNegativeSquare({ multiply, unaryMinus })
console.log(negativeSquare(3)) // -9

// or import the factory in a mathjs instance and use it there
const math = create(all)
math.import(createNegativeSquare)
console.log(math.negativeSquare(4)) // -16
console.log(math.evaluate('negativeSquare(5)')) // -25


You may wonder why you would inject functions multiply and unaryMinus
instead of just doing these calculations inside the function itself. The
reason is that this makes the factory function negativeSquare work for
different implementations: numbers, BigNumbers, units, etc.

import { Decimal } from 'decimal.js'

// create an instance of our negativeSquare supporting BigNumbers instead of numbers
const multiply = (a, b) => a.mul(b)
const unaryMinus = (a) => new Decimal(0).minus(a)
const negativeSquare = createNegativeSquare({ multiply, unaryMinus })\n\n\n\nExtension #

The library can easily be extended with functions and variables using the
import function. The import function is available on a mathjs instance, which can be created using the create function.

import { create, all } from 'mathjs'

const math = create(all)

math.import(/* ... */)


The function import accepts an object with functions and variables, or an array with factory functions. It has the following syntax:

math.import(functions: Object [, options: Object])


Where:


  
    functions is an object or array containing the functions and/or values to be
imported. import support regular values and functions, typed functions
(see section Typed functions), and factory functions
(see section Factory functions).
An array is only applicable when it contains factory functions.
  
  
    options is an optional second argument with options.
The following options are available:

    
      {boolean} override
If true, existing functions will be overwritten. The default value is false.
      {boolean} silent
If true, the function will not throw errors on duplicates or invalid
types. Default value is false.
      {boolean} wrap
If true, the functions will be wrapped in a wrapper function which
converts data types like Matrix to primitive data types like Array.
The wrapper is needed when extending math.js with libraries which do not
support the math.js data types. The default value is false.
    
  


The following code example shows how to import a function and a value into math.js:

// define new functions and variables
math.import({
  myvalue: 42,
  hello: function (name) {
    return 'hello, ' + name + '!'
  }
})

// defined functions can be used in both JavaScript as well as the parser
math.myvalue * 2                 // 84
math.hello('user')               // 'hello, user!'

const parser = math.parser()
parser.evaluate('myvalue + 10')  // 52
parser.evaluate('hello("user")') // 'hello, user!'


Import external libraries #

External libraries like
numbers.js and
numeric.js can be imported as follows.
The libraries must be installed using npm:

$ npm install numbers
$ npm install numeric


The libraries can be easily imported into math.js using import.
In order to convert math.js specific data types like Matrix to primitive types
like Array, the imported functions can be wrapped by enabling {wrap: true}.

import { create, all } from 'mathjs'
import * as numbers from 'numbers'
import * as numeric from 'numeric'

// create a mathjs instance and import the numbers.js and numeric.js libraries
const math = create(all)
math.import(numbers, {wrap: true, silent: true})
math.import(numeric, {wrap: true, silent: true})

// use functions from numbers.js
math.fibonacci(7)                           // 13
math.evaluate('fibonacci(7)')               // 13

// use functions from numeric.js
math.evaluate('eig([1, 2; 4, 3])').lambda.x // [5, -1]


Typed functions #

Typed functions can be created using math.typed. A typed function is a function
which does type checking on the input arguments. It can have multiple signatures.
And can automatically convert input types where needed.

A typed function can be created like:

const max = typed('max', {
  'number, number': function (a, b) {
    return Math.max(a, b)
  },

  'BigNumber, BigNumber': function (a, b) {
    return a.greaterThan(b) ? a : b
  }
})


Typed functions can be merged as long as there are no conflicts in the signatures.
This allows for extending existing functions in math.js with support for new
data types.

// create a new data type
function MyType (value) {
  this.value = value
}
MyType.prototype.isMyType = true
MyType.prototype.toString = function () {
  return 'MyType:' + this.value
}

// define a new datatype
math.typed.addType({
  name: 'MyType',
  test: function (x) {
    // test whether x is of type MyType
    return x && x.isMyType
  }
})

// use the type in a new typed function
const add = typed('add', {
  'MyType, MyType': function (a, b) {
    return new MyType(a.value + b.value)
  }
})

// import in math.js, extend the existing function `add` with support for MyType
math.import({add: add})

// use the new type
const ans = math.add(new MyType(2), new MyType(3)) // returns MyType(5)
console.log(ans)                                 // outputs 'MyType:5'


Detailed information on typed functions is available here:
https://github.com/josdejong/typed-function

Factory functions #

Regular JavaScript functions can be imported in math.js using math.import:

math.import({
  myFunction: function (a, b) {
     // ...
  }
})


The function can be stored in a separate file:

export function myFunction (a, b) {
  // ...
}


Which can be imported like:

import { myFunction } from './myFunction.js'

math.import({
  myFunction
})


An issue arises when myFunction needs functionality from math.js:
it doesn’t have access to the current instance of math.js when in a separate file.
Factory functions can be used to solve this issue. A factory function allows to inject dependencies into a function when creating it.

A syntax of factory function is:

factory(name: string, dependencies: string[], create: function, meta?: Object): function


where:


  name is the name of the created function.
  dependencies is an array with names of the dependent functions.
  create is a function which creates the function.
An object with the dependencies is passed as first argument.
  meta An optional object which can contain any meta data you want.
This will be attached as a property meta on the created function.
Known meta data properties used by the mathjs instance are:
    
      isClass: boolean  If true, the created function is supposed to be a
class, and for example will not be exposed in the expression parser
for security reasons.
      lazy: boolean.  By default, everything is imported lazily by import.
only as soon as the imported function or constant is actually used, it
will be constructed. A function can be forced to be created immediately
by setting lazy: false in the meta data.
      isTransformFunction: boolean. If true, the created function is imported
as a transform function. It will not be imported in math itself, only
in the internal mathWithTransform namespace that is used by the
expression parser.
      recreateOnConfigChange: boolean. If true, the imported factory will be
created again when there is a change in the configuration. This is for
example used for the constants like pi, which is different depending
on the configsetting number which can be numbers or BigNumbers.
      formerly: string. If present, the created function will also be
accessible on the instance under the name given by the value of
formerly as a (deprecated) synonym for the specified name. This
facility should only be used when a function is renamed, to allow
temporary use of the previous name, for backward compatibility.
    
  


Here an example of a factory function which depends on multiply:

import { factory, create, all } from 'mathjs'

// create a factory function
const name = 'negativeSquare'
const dependencies = ['multiply', 'unaryMinus']
const createNegativeSquare = factory(name, dependencies, function ({ multiply, unaryMinus }) {
    return function negativeSquare (x) {
      return unaryMinus(multiply(x, x))
    }
  })

// create an instance of the function yourself:
const multiply = (a, b) => a * b
const unaryMinus = (a) => -a
const negativeSquare = createNegativeSquare({ multiply, unaryMinus })
console.log(negativeSquare(3)) // -9

// or import the factory in a mathjs instance and use it there
const math = create(all)
math.import(createNegativeSquare)
console.log(math.negativeSquare(4)) // -16
console.log(math.evaluate('negativeSquare(5)')) // -25


You may wonder why you would inject functions multiply and unaryMinus
instead of just doing these calculations inside the function itself. The
reason is that this makes the factory function negativeSquare work for
different implementations: numbers, BigNumbers, units, etc.

import { Decimal } from 'decimal.js'

// create an instance of our negativeSquare supporting BigNumbers instead of numbers
const multiply = (a, b) => a.mul(b)
const unaryMinus = (a) => new Decimal(0).minus(a)
const negativeSquare = createNegativeSquare({ multiply, unaryMinus })\n\n\n\nExtension #

The library can easily be extended with functions and variables using the
import function. The import function is available on a mathjs instance, which can be created using the create function.

import { create, all } from 'mathjs'

const math = create(all)

math.import(/* ... */)


The function import accepts an object with functions and variables, or an array with factory functions. It has the following syntax:

math.import(functions: Object [, options: Object])


Where:


  
    functions is an object or array containing the functions and/or values to be
imported. import support regular values and functions, typed functions
(see section Typed functions), and factory functions
(see section Factory functions).
An array is only applicable when it contains factory functions.
  
  
    options is an optional second argument with options.
The following options are available:

    
      {boolean} override
If true, existing functions will be overwritten. The default value is false.
      {boolean} silent
If true, the function will not throw errors on duplicates or invalid
types. Default value is false.
      {boolean} wrap
If true, the functions will be wrapped in a wrapper function which
converts data types like Matrix to primitive data types like Array.
The wrapper is needed when extending math.js with libraries which do not
support the math.js data types. The default value is false.
    
  


The following code example shows how to import a function and a value into math.js:

// define new functions and variables
math.import({
  myvalue: 42,
  hello: function (name) {
    return 'hello, ' + name + '!'
  }
})

// defined functions can be used in both JavaScript as well as the parser
math.myvalue * 2                 // 84
math.hello('user')               // 'hello, user!'

const parser = math.parser()
parser.evaluate('myvalue + 10')  // 52
parser.evaluate('hello("user")') // 'hello, user!'


Import external libraries #

External libraries like
numbers.js and
numeric.js can be imported as follows.
The libraries must be installed using npm:

$ npm install numbers
$ npm install numeric


The libraries can be easily imported into math.js using import.
In order to convert math.js specific data types like Matrix to primitive types
like Array, the imported functions can be wrapped by enabling {wrap: true}.

import { create, all } from 'mathjs'
import * as numbers from 'numbers'
import * as numeric from 'numeric'

// create a mathjs instance and import the numbers.js and numeric.js libraries
const math = create(all)
math.import(numbers, {wrap: true, silent: true})
math.import(numeric, {wrap: true, silent: true})

// use functions from numbers.js
math.fibonacci(7)                           // 13
math.evaluate('fibonacci(7)')               // 13

// use functions from numeric.js
math.evaluate('eig([1, 2; 4, 3])').lambda.x // [5, -1]


Typed functions #

Typed functions can be created using math.typed. A typed function is a function
which does type checking on the input arguments. It can have multiple signatures.
And can automatically convert input types where needed.

A typed function can be created like:

const max = typed('max', {
  'number, number': function (a, b) {
    return Math.max(a, b)
  },

  'BigNumber, BigNumber': function (a, b) {
    return a.greaterThan(b) ? a : b
  }
})


Typed functions can be merged as long as there are no conflicts in the signatures.
This allows for extending existing functions in math.js with support for new
data types.

// create a new data type
function MyType (value) {
  this.value = value
}
MyType.prototype.isMyType = true
MyType.prototype.toString = function () {
  return 'MyType:' + this.value
}

// define a new datatype
math.typed.addType({
  name: 'MyType',
  test: function (x) {
    // test whether x is of type MyType
    return x && x.isMyType
  }
})

// use the type in a new typed function
const add = typed('add', {
  'MyType, MyType': function (a, b) {
    return new MyType(a.value + b.value)
  }
})

// import in math.js, extend the existing function `add` with support for MyType
math.import({add: add})

// use the new type
const ans = math.add(new MyType(2), new MyType(3)) // returns MyType(5)
console.log(ans)                                 // outputs 'MyType:5'


Detailed information on typed functions is available here:
https://github.com/josdejong/typed-function

Factory functions #

Regular JavaScript functions can be imported in math.js using math.import:

math.import({
  myFunction: function (a, b) {
     // ...
  }
})


The function can be stored in a separate file:

export function myFunction (a, b) {
  // ...
}


Which can be imported like:

import { myFunction } from './myFunction.js'

math.import({
  myFunction
})


An issue arises when myFunction needs functionality from math.js:
it doesn’t have access to the current instance of math.js when in a separate file.
Factory functions can be used to solve this issue. A factory function allows to inject dependencies into a function when creating it.

A syntax of factory function is:

factory(name: string, dependencies: string[], create: function, meta?: Object): function


where:


  name is the name of the created function.
  dependencies is an array with names of the dependent functions.
  create is a function which creates the function.
An object with the dependencies is passed as first argument.
  meta An optional object which can contain any meta data you want.
This will be attached as a property meta on the created function.
Known meta data properties used by the mathjs instance are:
    
      isClass: boolean  If true, the created function is supposed to be a
class, and for example will not be exposed in the expression parser
for security reasons.
      lazy: boolean.  By default, everything is imported lazily by import.
only as soon as the imported function or constant is actually used, it
will be constructed. A function can be forced to be created immediately
by setting lazy: false in the meta data.
      isTransformFunction: boolean. If true, the created function is imported
as a transform function. It will not be imported in math itself, only
in the internal mathWithTransform namespace that is used by the
expression parser.
      recreateOnConfigChange: boolean. If true, the imported factory will be
created again when there is a change in the configuration. This is for
example used for the constants like pi, which is different depending
on the configsetting number which can be numbers or BigNumbers.
      formerly: string. If present, the created function will also be
accessible on the instance under the name given by the value of
formerly as a (deprecated) synonym for the specified name. This
facility should only be used when a function is renamed, to allow
temporary use of the previous name, for backward compatibility.
    
  


Here an example of a factory function which depends on multiply:

import { factory, create, all } from 'mathjs'

// create a factory function
const name = 'negativeSquare'
const dependencies = ['multiply', 'unaryMinus']
const createNegativeSquare = factory(name, dependencies, function ({ multiply, unaryMinus }) {
    return function negativeSquare (x) {
      return unaryMinus(multiply(x, x))
    }
  })

// create an instance of the function yourself:
const multiply = (a, b) => a * b
const unaryMinus = (a) => -a
const negativeSquare = createNegativeSquare({ multiply, unaryMinus })
console.log(negativeSquare(3)) // -9

// or import the factory in a mathjs instance and use it there
const math = create(all)
math.import(createNegativeSquare)
console.log(math.negativeSquare(4)) // -16
console.log(math.evaluate('negativeSquare(5)')) // -25


You may wonder why you would inject functions multiply and unaryMinus
instead of just doing these calculations inside the function itself. The
reason is that this makes the factory function negativeSquare work for
different implementations: numbers, BigNumbers, units, etc.

import { Decimal } from 'decimal.js'

// create an instance of our negativeSquare supporting BigNumbers instead of numbers
const multiply = (a, b) => a.mul(b)
const unaryMinus = (a) => new Decimal(0).minus(a)
const negativeSquare = createNegativeSquare({ multiply, unaryMinus })\n\n\n\nSerialization #

Math.js has a number of data types like Matrix, Complex, and Unit. These
types are instantiated JavaScript objects. To be able to store these data types
or send them between processes, they must be serialized. The data types of
math.js can be serialized to JSON. Use cases:


  Store data in a database or on disk.
  Interchange of data between a server and a client.
  Interchange of data between a web worker and the browser.


Math.js types can be serialized using JavaScript’s built-in JSON.stringify
function:

const x = math.complex('2 + 3i')
const str = JSON.stringify(x, math.replacer)
console.log(str)
// outputs a string '{"mathjs":"Complex","re":2,"im":3}'



  IMPORTANT: in most cases works, serialization correctly without
passing the math.replacer function as second argument. This is because
in most cases we can rely on the default behavior of JSON.stringify, which 
uses the .toJSON method on classes like Unit and Complex to correctly 
serialize them. However, there are a few special cases like the 
number Infinity which does require the replacer function in order to be 
serialized without losing information: without it, Infinity will be 
serialized as "null" and cannot be deserialized correctly.

  So, it’s best to always pass the math.replacer function to prevent 
weird edge cases.


In order to deserialize a string, containing math.js data types, JSON.parse
can be used. In order to recognize the data types of math.js, JSON.parse must
be called with the reviver function of math.js:

const json = '{"mathjs":"Unit","value":5,"unit":"cm","fixPrefix":false}'
const x = JSON.parse(json, math.reviver)   // Unit 5 cm


Note that if math.js is used in conjunction with other data types, it is
possible to use multiple reviver functions at the same time by cascading them:

const reviver = function (key, value) {
  return reviver1(key, reviver2(key, value))
}\n\n\n\nExpressions #

Math.js contains a flexible and easy to use expression parser.
The parser supports all data types, functions and constants available in math.js.

Whilst the math.js library is aimed at JavaScript developers, the expression
parser is aimed at end users: mathematicians, engineers, students, pupils.
The syntax of the expression parser differs from JavaScript and the low-level
math.js library.

This section is divided in the following pages:


  Parsing and evaluation describes how to parse and
evaluate expressions with math.js.
  Syntax describes how to write expressions.
  Expression trees explains how to parse an expression into an
expression tree, and use this to analyse and manipulate the expression.
  Algebra describing symbolic computation in math.js.
  Customization describes how to customize processing and
evaluation of expressions.
  Security about security risks of executing arbitrary expressions.\n\n\n\nExpression parsing and evaluation #

Expressions can be parsed and evaluated in various ways:


  Using the function math.evaluate(expr [,scope]).
  Using the function math.compile(expr).
  Using the function math.parse(expr).
  By creating a parser, math.parser(), which contains a method
evaluate and keeps a scope with assigned variables in memory.


Evaluate #

Math.js comes with a function math.evaluate to evaluate expressions. Syntax:

math.evaluate(expr)
math.evaluate(expr, scope)
math.evaluate([expr1, expr2, expr3, ...])
math.evaluate([expr1, expr2, expr3, ...], scope)


Function evaluate accepts a single expression or an array with
expressions as the first argument and has an optional second argument
containing a scope with variables and functions. The scope can be a regular
JavaScript Map (recommended), a plain JavaScript object, or any custom 
class that implements the Map interface with methods get, set, keys 
and has. The scope will be used to resolve symbols, and to write assigned
variables and functions.

When an Object is used as scope, mathjs will internally wrap it in an 
ObjectWrappingMap interface since the internal functions can only use a Map 
interface. In case of custom defined functions like f(x) = x^2, the scope 
will be wrapped in a PartitionedMap, which reads and writes the function
variables (like x in this example) from a temporary map, and reads and writes
other variables from the original scope. The original scope is never copied, it
is only wrapped around when needed.

The following code demonstrates how to evaluate expressions.

// evaluate expressions
math.evaluate('sqrt(3^2 + 4^2)')        // 5
math.evaluate('sqrt(-4)')               // 2i
math.evaluate('2 inch to cm')           // 5.08 cm
math.evaluate('cos(45 deg)')            // 0.7071067811865476

// provide a scope
let scope = {
    a: 3,
    b: 4
}
math.evaluate('a * b', scope)           // 12
math.evaluate('c = 2.3 + 4.5', scope)   // 6.8
scope.c                                 // 6.8


Compile #

Math.js contains a function math.compile which compiles expressions
into JavaScript code. This is a shortcut for first parsing and then
compiling an expression. The syntax is:

math.compile(expr)
math.compile([expr1, expr2, expr3, ...])


Function compile accepts a single expression or an array with
expressions as the argument. Function compile returns an object with a function
evaluate([scope]), which can be executed to evaluate the expression against an
(optional) scope:

const code = math.compile(expr)       // compile an expression
const result = code.evaluate([scope]) // evaluate the code with an optional scope


An expression needs to be compiled only once, after which the
expression can be evaluated repeatedly and against different scopes.
The optional scope is used to resolve symbols and to write assigned
variables or functions. Parameter scope can be a regular Object, or Map.

Example usage:

// parse an expression into a node, and evaluate the node
const code1 = math.compile('sqrt(3^2 + 4^2)')
code1.evaluate()  // 5


Parse #

Math.js contains a function math.parse to parse expressions into an
expression tree. The syntax is:

math.parse(expr)
math.parse([expr1, expr2, expr3, ...])


Function parse accepts a single expression or an array with
expressions as the argument. Function parse returns the root node of the tree,
which can be successively compiled and evaluated:

const node = math.parse(expr)         // parse expression into a node tree
const code = node.compile()           // compile the node tree
const result = code.evaluate([scope]) // evaluate the code with an optional scope


The API of nodes is described in detail on the page
Expression trees.

An expression needs to be parsed and compiled only once, after which the
expression can be evaluated repeatedly. On evaluation, an optional scope
can be provided, which is used to resolve symbols and to write assigned
variables or functions. Parameter scope is a regular Object or Map.

Example usage:

// parse an expression into a node, and evaluate the node
const node1 = math.parse('sqrt(3^2 + 4^2)')
const code1 = node1.compile()
code1.evaluate() // 5

// provide a scope
const node2 = math.parse('x^a')
const code2 = node2.compile()
let scope = {
    x: 3,
    a: 2
}
code2.evaluate(scope) // 9

// change a value in the scope and re-evaluate the node
scope.a = 3
code2.evaluate(scope) // 27


Parsed expressions can be exported to text using node.toString(), and can
be exported to LaTeX using node.toTex(). The LaTeX export can be used to
pretty print an expression in the browser with a library like
MathJax. Example usage:

// parse an expression
const node = math.parse('sqrt(x/x+1)')
node.toString()   // returns 'sqrt((x / x) + 1)'
node.toTex()      // returns ' qrt{ {\frac{x}{x} }+{1} }'


Parser #

In addition to the static functions math.evaluate and
math.parse, math.js contains a parser with functions evaluate and
parse, which automatically keeps a scope with assigned variables in memory.
The parser also contains some convenience functions to get, set, and remove
variables from memory.

A parser can be created by:

const parser = math.parser()


The parser contains the following functions:


  clear()
Completely clear the parser’s scope.
  evaluate(expr)
Evaluate an expression. Returns the result of the expression.
  get(name)
Retrieve a variable or function from the parser’s scope.
  getAll()
Retrieve an object with all defined variables in the parser’s scope.
  getAllAsMap()
Retrieve a map with all defined variables in the parser’s scope.
  remove(name)
Remove a variable or function from the parser’s scope.
  set(name, value)
Set a variable or function in the parser’s scope.


The following code shows how to create and use a parser.

// create a parser
const parser = math.parser()

// evaluate expressions
parser.evaluate('sqrt(3^2 + 4^2)')      // 5
parser.evaluate('sqrt(-4)')             // 2i
parser.evaluate('2 inch to cm')         // 5.08 cm
parser.evaluate('cos(45 deg)')          // 0.7071067811865476

// define variables and functions
parser.evaluate('x = 7 / 2')            // 3.5
parser.evaluate('x + 3')                // 6.5
parser.evaluate('f(x, y) = x^y')        // f(x, y)
parser.evaluate('f(2, 3)')              // 8

// get and set variables and functions
const x = parser.get('x')               // x = 3.5
const f = parser.get('f')               // function
const g = f(3, 3)                       // g = 27
parser.set('h', 500)
parser.evaluate('h / 2')                // 250
parser.set('hello', function (name) {
    return 'hello, ' + name + '!'
})
parser.evaluate('hello("user")')        // "hello, user!"

// clear defined functions and variables
parser.clear()


Scope #

The scope is a data-structure used to store and lookup variables and functions defined and used by expressions.

It is passed to mathjs via calls to math.evaluate or simplify.

For ease of use, it can be a Plain Javascript Object; for safety it can be a plain Map and for flexibility, any object that has
the methods get/set/has/keys, seen on Map.

Some care is taken to mutate the same object that is passed into mathjs, so they can collect the definitions from mathjs scripts and expressions.

evaluate will fail if the expression uses a blacklisted symbol, preventing mathjs expressions to escape into Javascript. This is enforced by access to the scope.

For less reliance on this blacklist, scope can also be a Map, which allows mathjs expressions to define variables and functions of any name.

For more, see examples of custom scopes.\n\n\n\nExpression parsing and evaluation #

Expressions can be parsed and evaluated in various ways:


  Using the function math.evaluate(expr [,scope]).
  Using the function math.compile(expr).
  Using the function math.parse(expr).
  By creating a parser, math.parser(), which contains a method
evaluate and keeps a scope with assigned variables in memory.


Evaluate #

Math.js comes with a function math.evaluate to evaluate expressions. Syntax:

math.evaluate(expr)
math.evaluate(expr, scope)
math.evaluate([expr1, expr2, expr3, ...])
math.evaluate([expr1, expr2, expr3, ...], scope)


Function evaluate accepts a single expression or an array with
expressions as the first argument and has an optional second argument
containing a scope with variables and functions. The scope can be a regular
JavaScript Map (recommended), a plain JavaScript object, or any custom 
class that implements the Map interface with methods get, set, keys 
and has. The scope will be used to resolve symbols, and to write assigned
variables and functions.

When an Object is used as scope, mathjs will internally wrap it in an 
ObjectWrappingMap interface since the internal functions can only use a Map 
interface. In case of custom defined functions like f(x) = x^2, the scope 
will be wrapped in a PartitionedMap, which reads and writes the function
variables (like x in this example) from a temporary map, and reads and writes
other variables from the original scope. The original scope is never copied, it
is only wrapped around when needed.

The following code demonstrates how to evaluate expressions.

// evaluate expressions
math.evaluate('sqrt(3^2 + 4^2)')        // 5
math.evaluate('sqrt(-4)')               // 2i
math.evaluate('2 inch to cm')           // 5.08 cm
math.evaluate('cos(45 deg)')            // 0.7071067811865476

// provide a scope
let scope = {
    a: 3,
    b: 4
}
math.evaluate('a * b', scope)           // 12
math.evaluate('c = 2.3 + 4.5', scope)   // 6.8
scope.c                                 // 6.8


Compile #

Math.js contains a function math.compile which compiles expressions
into JavaScript code. This is a shortcut for first parsing and then
compiling an expression. The syntax is:

math.compile(expr)
math.compile([expr1, expr2, expr3, ...])


Function compile accepts a single expression or an array with
expressions as the argument. Function compile returns an object with a function
evaluate([scope]), which can be executed to evaluate the expression against an
(optional) scope:

const code = math.compile(expr)       // compile an expression
const result = code.evaluate([scope]) // evaluate the code with an optional scope


An expression needs to be compiled only once, after which the
expression can be evaluated repeatedly and against different scopes.
The optional scope is used to resolve symbols and to write assigned
variables or functions. Parameter scope can be a regular Object, or Map.

Example usage:

// parse an expression into a node, and evaluate the node
const code1 = math.compile('sqrt(3^2 + 4^2)')
code1.evaluate()  // 5


Parse #

Math.js contains a function math.parse to parse expressions into an
expression tree. The syntax is:

math.parse(expr)
math.parse([expr1, expr2, expr3, ...])


Function parse accepts a single expression or an array with
expressions as the argument. Function parse returns the root node of the tree,
which can be successively compiled and evaluated:

const node = math.parse(expr)         // parse expression into a node tree
const code = node.compile()           // compile the node tree
const result = code.evaluate([scope]) // evaluate the code with an optional scope


The API of nodes is described in detail on the page
Expression trees.

An expression needs to be parsed and compiled only once, after which the
expression can be evaluated repeatedly. On evaluation, an optional scope
can be provided, which is used to resolve symbols and to write assigned
variables or functions. Parameter scope is a regular Object or Map.

Example usage:

// parse an expression into a node, and evaluate the node
const node1 = math.parse('sqrt(3^2 + 4^2)')
const code1 = node1.compile()
code1.evaluate() // 5

// provide a scope
const node2 = math.parse('x^a')
const code2 = node2.compile()
let scope = {
    x: 3,
    a: 2
}
code2.evaluate(scope) // 9

// change a value in the scope and re-evaluate the node
scope.a = 3
code2.evaluate(scope) // 27


Parsed expressions can be exported to text using node.toString(), and can
be exported to LaTeX using node.toTex(). The LaTeX export can be used to
pretty print an expression in the browser with a library like
MathJax. Example usage:

// parse an expression
const node = math.parse('sqrt(x/x+1)')
node.toString()   // returns 'sqrt((x / x) + 1)'
node.toTex()      // returns ' qrt{ {\frac{x}{x} }+{1} }'


Parser #

In addition to the static functions math.evaluate and
math.parse, math.js contains a parser with functions evaluate and
parse, which automatically keeps a scope with assigned variables in memory.
The parser also contains some convenience functions to get, set, and remove
variables from memory.

A parser can be created by:

const parser = math.parser()


The parser contains the following functions:


  clear()
Completely clear the parser’s scope.
  evaluate(expr)
Evaluate an expression. Returns the result of the expression.
  get(name)
Retrieve a variable or function from the parser’s scope.
  getAll()
Retrieve an object with all defined variables in the parser’s scope.
  getAllAsMap()
Retrieve a map with all defined variables in the parser’s scope.
  remove(name)
Remove a variable or function from the parser’s scope.
  set(name, value)
Set a variable or function in the parser’s scope.


The following code shows how to create and use a parser.

// create a parser
const parser = math.parser()

// evaluate expressions
parser.evaluate('sqrt(3^2 + 4^2)')      // 5
parser.evaluate('sqrt(-4)')             // 2i
parser.evaluate('2 inch to cm')         // 5.08 cm
parser.evaluate('cos(45 deg)')          // 0.7071067811865476

// define variables and functions
parser.evaluate('x = 7 / 2')            // 3.5
parser.evaluate('x + 3')                // 6.5
parser.evaluate('f(x, y) = x^y')        // f(x, y)
parser.evaluate('f(2, 3)')              // 8

// get and set variables and functions
const x = parser.get('x')               // x = 3.5
const f = parser.get('f')               // function
const g = f(3, 3)                       // g = 27
parser.set('h', 500)
parser.evaluate('h / 2')                // 250
parser.set('hello', function (name) {
    return 'hello, ' + name + '!'
})
parser.evaluate('hello("user")')        // "hello, user!"

// clear defined functions and variables
parser.clear()


Scope #

The scope is a data-structure used to store and lookup variables and functions defined and used by expressions.

It is passed to mathjs via calls to math.evaluate or simplify.

For ease of use, it can be a Plain Javascript Object; for safety it can be a plain Map and for flexibility, any object that has
the methods get/set/has/keys, seen on Map.

Some care is taken to mutate the same object that is passed into mathjs, so they can collect the definitions from mathjs scripts and expressions.

evaluate will fail if the expression uses a blacklisted symbol, preventing mathjs expressions to escape into Javascript. This is enforced by access to the scope.

For less reliance on this blacklist, scope can also be a Map, which allows mathjs expressions to define variables and functions of any name.

For more, see examples of custom scopes.\n\n\n\nExpression parsing and evaluation #

Expressions can be parsed and evaluated in various ways:


  Using the function math.evaluate(expr [,scope]).
  Using the function math.compile(expr).
  Using the function math.parse(expr).
  By creating a parser, math.parser(), which contains a method
evaluate and keeps a scope with assigned variables in memory.


Evaluate #

Math.js comes with a function math.evaluate to evaluate expressions. Syntax:

math.evaluate(expr)
math.evaluate(expr, scope)
math.evaluate([expr1, expr2, expr3, ...])
math.evaluate([expr1, expr2, expr3, ...], scope)


Function evaluate accepts a single expression or an array with
expressions as the first argument and has an optional second argument
containing a scope with variables and functions. The scope can be a regular
JavaScript Map (recommended), a plain JavaScript object, or any custom 
class that implements the Map interface with methods get, set, keys 
and has. The scope will be used to resolve symbols, and to write assigned
variables and functions.

When an Object is used as scope, mathjs will internally wrap it in an 
ObjectWrappingMap interface since the internal functions can only use a Map 
interface. In case of custom defined functions like f(x) = x^2, the scope 
will be wrapped in a PartitionedMap, which reads and writes the function
variables (like x in this example) from a temporary map, and reads and writes
other variables from the original scope. The original scope is never copied, it
is only wrapped around when needed.

The following code demonstrates how to evaluate expressions.

// evaluate expressions
math.evaluate('sqrt(3^2 + 4^2)')        // 5
math.evaluate('sqrt(-4)')               // 2i
math.evaluate('2 inch to cm')           // 5.08 cm
math.evaluate('cos(45 deg)')            // 0.7071067811865476

// provide a scope
let scope = {
    a: 3,
    b: 4
}
math.evaluate('a * b', scope)           // 12
math.evaluate('c = 2.3 + 4.5', scope)   // 6.8
scope.c                                 // 6.8


Compile #

Math.js contains a function math.compile which compiles expressions
into JavaScript code. This is a shortcut for first parsing and then
compiling an expression. The syntax is:

math.compile(expr)
math.compile([expr1, expr2, expr3, ...])


Function compile accepts a single expression or an array with
expressions as the argument. Function compile returns an object with a function
evaluate([scope]), which can be executed to evaluate the expression against an
(optional) scope:

const code = math.compile(expr)       // compile an expression
const result = code.evaluate([scope]) // evaluate the code with an optional scope


An expression needs to be compiled only once, after which the
expression can be evaluated repeatedly and against different scopes.
The optional scope is used to resolve symbols and to write assigned
variables or functions. Parameter scope can be a regular Object, or Map.

Example usage:

// parse an expression into a node, and evaluate the node
const code1 = math.compile('sqrt(3^2 + 4^2)')
code1.evaluate()  // 5


Parse #

Math.js contains a function math.parse to parse expressions into an
expression tree. The syntax is:

math.parse(expr)
math.parse([expr1, expr2, expr3, ...])


Function parse accepts a single expression or an array with
expressions as the argument. Function parse returns the root node of the tree,
which can be successively compiled and evaluated:

const node = math.parse(expr)         // parse expression into a node tree
const code = node.compile()           // compile the node tree
const result = code.evaluate([scope]) // evaluate the code with an optional scope


The API of nodes is described in detail on the page
Expression trees.

An expression needs to be parsed and compiled only once, after which the
expression can be evaluated repeatedly. On evaluation, an optional scope
can be provided, which is used to resolve symbols and to write assigned
variables or functions. Parameter scope is a regular Object or Map.

Example usage:

// parse an expression into a node, and evaluate the node
const node1 = math.parse('sqrt(3^2 + 4^2)')
const code1 = node1.compile()
code1.evaluate() // 5

// provide a scope
const node2 = math.parse('x^a')
const code2 = node2.compile()
let scope = {
    x: 3,
    a: 2
}
code2.evaluate(scope) // 9

// change a value in the scope and re-evaluate the node
scope.a = 3
code2.evaluate(scope) // 27


Parsed expressions can be exported to text using node.toString(), and can
be exported to LaTeX using node.toTex(). The LaTeX export can be used to
pretty print an expression in the browser with a library like
MathJax. Example usage:

// parse an expression
const node = math.parse('sqrt(x/x+1)')
node.toString()   // returns 'sqrt((x / x) + 1)'
node.toTex()      // returns ' qrt{ {\frac{x}{x} }+{1} }'


Parser #

In addition to the static functions math.evaluate and
math.parse, math.js contains a parser with functions evaluate and
parse, which automatically keeps a scope with assigned variables in memory.
The parser also contains some convenience functions to get, set, and remove
variables from memory.

A parser can be created by:

const parser = math.parser()


The parser contains the following functions:


  clear()
Completely clear the parser’s scope.
  evaluate(expr)
Evaluate an expression. Returns the result of the expression.
  get(name)
Retrieve a variable or function from the parser’s scope.
  getAll()
Retrieve an object with all defined variables in the parser’s scope.
  getAllAsMap()
Retrieve a map with all defined variables in the parser’s scope.
  remove(name)
Remove a variable or function from the parser’s scope.
  set(name, value)
Set a variable or function in the parser’s scope.


The following code shows how to create and use a parser.

// create a parser
const parser = math.parser()

// evaluate expressions
parser.evaluate('sqrt(3^2 + 4^2)')      // 5
parser.evaluate('sqrt(-4)')             // 2i
parser.evaluate('2 inch to cm')         // 5.08 cm
parser.evaluate('cos(45 deg)')          // 0.7071067811865476

// define variables and functions
parser.evaluate('x = 7 / 2')            // 3.5
parser.evaluate('x + 3')                // 6.5
parser.evaluate('f(x, y) = x^y')        // f(x, y)
parser.evaluate('f(2, 3)')              // 8

// get and set variables and functions
const x = parser.get('x')               // x = 3.5
const f = parser.get('f')               // function
const g = f(3, 3)                       // g = 27
parser.set('h', 500)
parser.evaluate('h / 2')                // 250
parser.set('hello', function (name) {
    return 'hello, ' + name + '!'
})
parser.evaluate('hello("user")')        // "hello, user!"

// clear defined functions and variables
parser.clear()


Scope #

The scope is a data-structure used to store and lookup variables and functions defined and used by expressions.

It is passed to mathjs via calls to math.evaluate or simplify.

For ease of use, it can be a Plain Javascript Object; for safety it can be a plain Map and for flexibility, any object that has
the methods get/set/has/keys, seen on Map.

Some care is taken to mutate the same object that is passed into mathjs, so they can collect the definitions from mathjs scripts and expressions.

evaluate will fail if the expression uses a blacklisted symbol, preventing mathjs expressions to escape into Javascript. This is enforced by access to the scope.

For less reliance on this blacklist, scope can also be a Map, which allows mathjs expressions to define variables and functions of any name.

For more, see examples of custom scopes.\n\n\n\nExpression parsing and evaluation #

Expressions can be parsed and evaluated in various ways:


  Using the function math.evaluate(expr [,scope]).
  Using the function math.compile(expr).
  Using the function math.parse(expr).
  By creating a parser, math.parser(), which contains a method
evaluate and keeps a scope with assigned variables in memory.


Evaluate #

Math.js comes with a function math.evaluate to evaluate expressions. Syntax:

math.evaluate(expr)
math.evaluate(expr, scope)
math.evaluate([expr1, expr2, expr3, ...])
math.evaluate([expr1, expr2, expr3, ...], scope)


Function evaluate accepts a single expression or an array with
expressions as the first argument and has an optional second argument
containing a scope with variables and functions. The scope can be a regular
JavaScript Map (recommended), a plain JavaScript object, or any custom 
class that implements the Map interface with methods get, set, keys 
and has. The scope will be used to resolve symbols, and to write assigned
variables and functions.

When an Object is used as scope, mathjs will internally wrap it in an 
ObjectWrappingMap interface since the internal functions can only use a Map 
interface. In case of custom defined functions like f(x) = x^2, the scope 
will be wrapped in a PartitionedMap, which reads and writes the function
variables (like x in this example) from a temporary map, and reads and writes
other variables from the original scope. The original scope is never copied, it
is only wrapped around when needed.

The following code demonstrates how to evaluate expressions.

// evaluate expressions
math.evaluate('sqrt(3^2 + 4^2)')        // 5
math.evaluate('sqrt(-4)')               // 2i
math.evaluate('2 inch to cm')           // 5.08 cm
math.evaluate('cos(45 deg)')            // 0.7071067811865476

// provide a scope
let scope = {
    a: 3,
    b: 4
}
math.evaluate('a * b', scope)           // 12
math.evaluate('c = 2.3 + 4.5', scope)   // 6.8
scope.c                                 // 6.8


Compile #

Math.js contains a function math.compile which compiles expressions
into JavaScript code. This is a shortcut for first parsing and then
compiling an expression. The syntax is:

math.compile(expr)
math.compile([expr1, expr2, expr3, ...])


Function compile accepts a single expression or an array with
expressions as the argument. Function compile returns an object with a function
evaluate([scope]), which can be executed to evaluate the expression against an
(optional) scope:

const code = math.compile(expr)       // compile an expression
const result = code.evaluate([scope]) // evaluate the code with an optional scope


An expression needs to be compiled only once, after which the
expression can be evaluated repeatedly and against different scopes.
The optional scope is used to resolve symbols and to write assigned
variables or functions. Parameter scope can be a regular Object, or Map.

Example usage:

// parse an expression into a node, and evaluate the node
const code1 = math.compile('sqrt(3^2 + 4^2)')
code1.evaluate()  // 5


Parse #

Math.js contains a function math.parse to parse expressions into an
expression tree. The syntax is:

math.parse(expr)
math.parse([expr1, expr2, expr3, ...])


Function parse accepts a single expression or an array with
expressions as the argument. Function parse returns the root node of the tree,
which can be successively compiled and evaluated:

const node = math.parse(expr)         // parse expression into a node tree
const code = node.compile()           // compile the node tree
const result = code.evaluate([scope]) // evaluate the code with an optional scope


The API of nodes is described in detail on the page
Expression trees.

An expression needs to be parsed and compiled only once, after which the
expression can be evaluated repeatedly. On evaluation, an optional scope
can be provided, which is used to resolve symbols and to write assigned
variables or functions. Parameter scope is a regular Object or Map.

Example usage:

// parse an expression into a node, and evaluate the node
const node1 = math.parse('sqrt(3^2 + 4^2)')
const code1 = node1.compile()
code1.evaluate() // 5

// provide a scope
const node2 = math.parse('x^a')
const code2 = node2.compile()
let scope = {
    x: 3,
    a: 2
}
code2.evaluate(scope) // 9

// change a value in the scope and re-evaluate the node
scope.a = 3
code2.evaluate(scope) // 27


Parsed expressions can be exported to text using node.toString(), and can
be exported to LaTeX using node.toTex(). The LaTeX export can be used to
pretty print an expression in the browser with a library like
MathJax. Example usage:

// parse an expression
const node = math.parse('sqrt(x/x+1)')
node.toString()   // returns 'sqrt((x / x) + 1)'
node.toTex()      // returns ' qrt{ {\frac{x}{x} }+{1} }'


Parser #

In addition to the static functions math.evaluate and
math.parse, math.js contains a parser with functions evaluate and
parse, which automatically keeps a scope with assigned variables in memory.
The parser also contains some convenience functions to get, set, and remove
variables from memory.

A parser can be created by:

const parser = math.parser()


The parser contains the following functions:


  clear()
Completely clear the parser’s scope.
  evaluate(expr)
Evaluate an expression. Returns the result of the expression.
  get(name)
Retrieve a variable or function from the parser’s scope.
  getAll()
Retrieve an object with all defined variables in the parser’s scope.
  getAllAsMap()
Retrieve a map with all defined variables in the parser’s scope.
  remove(name)
Remove a variable or function from the parser’s scope.
  set(name, value)
Set a variable or function in the parser’s scope.


The following code shows how to create and use a parser.

// create a parser
const parser = math.parser()

// evaluate expressions
parser.evaluate('sqrt(3^2 + 4^2)')      // 5
parser.evaluate('sqrt(-4)')             // 2i
parser.evaluate('2 inch to cm')         // 5.08 cm
parser.evaluate('cos(45 deg)')          // 0.7071067811865476

// define variables and functions
parser.evaluate('x = 7 / 2')            // 3.5
parser.evaluate('x + 3')                // 6.5
parser.evaluate('f(x, y) = x^y')        // f(x, y)
parser.evaluate('f(2, 3)')              // 8

// get and set variables and functions
const x = parser.get('x')               // x = 3.5
const f = parser.get('f')               // function
const g = f(3, 3)                       // g = 27
parser.set('h', 500)
parser.evaluate('h / 2')                // 250
parser.set('hello', function (name) {
    return 'hello, ' + name + '!'
})
parser.evaluate('hello("user")')        // "hello, user!"

// clear defined functions and variables
parser.clear()


Scope #

The scope is a data-structure used to store and lookup variables and functions defined and used by expressions.

It is passed to mathjs via calls to math.evaluate or simplify.

For ease of use, it can be a Plain Javascript Object; for safety it can be a plain Map and for flexibility, any object that has
the methods get/set/has/keys, seen on Map.

Some care is taken to mutate the same object that is passed into mathjs, so they can collect the definitions from mathjs scripts and expressions.

evaluate will fail if the expression uses a blacklisted symbol, preventing mathjs expressions to escape into Javascript. This is enforced by access to the scope.

For less reliance on this blacklist, scope can also be a Map, which allows mathjs expressions to define variables and functions of any name.

For more, see examples of custom scopes.\n\n\n\nExpression parsing and evaluation #

Expressions can be parsed and evaluated in various ways:


  Using the function math.evaluate(expr [,scope]).
  Using the function math.compile(expr).
  Using the function math.parse(expr).
  By creating a parser, math.parser(), which contains a method
evaluate and keeps a scope with assigned variables in memory.


Evaluate #

Math.js comes with a function math.evaluate to evaluate expressions. Syntax:

math.evaluate(expr)
math.evaluate(expr, scope)
math.evaluate([expr1, expr2, expr3, ...])
math.evaluate([expr1, expr2, expr3, ...], scope)


Function evaluate accepts a single expression or an array with
expressions as the first argument and has an optional second argument
containing a scope with variables and functions. The scope can be a regular
JavaScript Map (recommended), a plain JavaScript object, or any custom 
class that implements the Map interface with methods get, set, keys 
and has. The scope will be used to resolve symbols, and to write assigned
variables and functions.

When an Object is used as scope, mathjs will internally wrap it in an 
ObjectWrappingMap interface since the internal functions can only use a Map 
interface. In case of custom defined functions like f(x) = x^2, the scope 
will be wrapped in a PartitionedMap, which reads and writes the function
variables (like x in this example) from a temporary map, and reads and writes
other variables from the original scope. The original scope is never copied, it
is only wrapped around when needed.

The following code demonstrates how to evaluate expressions.

// evaluate expressions
math.evaluate('sqrt(3^2 + 4^2)')        // 5
math.evaluate('sqrt(-4)')               // 2i
math.evaluate('2 inch to cm')           // 5.08 cm
math.evaluate('cos(45 deg)')            // 0.7071067811865476

// provide a scope
let scope = {
    a: 3,
    b: 4
}
math.evaluate('a * b', scope)           // 12
math.evaluate('c = 2.3 + 4.5', scope)   // 6.8
scope.c                                 // 6.8


Compile #

Math.js contains a function math.compile which compiles expressions
into JavaScript code. This is a shortcut for first parsing and then
compiling an expression. The syntax is:

math.compile(expr)
math.compile([expr1, expr2, expr3, ...])


Function compile accepts a single expression or an array with
expressions as the argument. Function compile returns an object with a function
evaluate([scope]), which can be executed to evaluate the expression against an
(optional) scope:

const code = math.compile(expr)       // compile an expression
const result = code.evaluate([scope]) // evaluate the code with an optional scope


An expression needs to be compiled only once, after which the
expression can be evaluated repeatedly and against different scopes.
The optional scope is used to resolve symbols and to write assigned
variables or functions. Parameter scope can be a regular Object, or Map.

Example usage:

// parse an expression into a node, and evaluate the node
const code1 = math.compile('sqrt(3^2 + 4^2)')
code1.evaluate()  // 5


Parse #

Math.js contains a function math.parse to parse expressions into an
expression tree. The syntax is:

math.parse(expr)
math.parse([expr1, expr2, expr3, ...])


Function parse accepts a single expression or an array with
expressions as the argument. Function parse returns the root node of the tree,
which can be successively compiled and evaluated:

const node = math.parse(expr)         // parse expression into a node tree
const code = node.compile()           // compile the node tree
const result = code.evaluate([scope]) // evaluate the code with an optional scope


The API of nodes is described in detail on the page
Expression trees.

An expression needs to be parsed and compiled only once, after which the
expression can be evaluated repeatedly. On evaluation, an optional scope
can be provided, which is used to resolve symbols and to write assigned
variables or functions. Parameter scope is a regular Object or Map.

Example usage:

// parse an expression into a node, and evaluate the node
const node1 = math.parse('sqrt(3^2 + 4^2)')
const code1 = node1.compile()
code1.evaluate() // 5

// provide a scope
const node2 = math.parse('x^a')
const code2 = node2.compile()
let scope = {
    x: 3,
    a: 2
}
code2.evaluate(scope) // 9

// change a value in the scope and re-evaluate the node
scope.a = 3
code2.evaluate(scope) // 27


Parsed expressions can be exported to text using node.toString(), and can
be exported to LaTeX using node.toTex(). The LaTeX export can be used to
pretty print an expression in the browser with a library like
MathJax. Example usage:

// parse an expression
const node = math.parse('sqrt(x/x+1)')
node.toString()   // returns 'sqrt((x / x) + 1)'
node.toTex()      // returns ' qrt{ {\frac{x}{x} }+{1} }'


Parser #

In addition to the static functions math.evaluate and
math.parse, math.js contains a parser with functions evaluate and
parse, which automatically keeps a scope with assigned variables in memory.
The parser also contains some convenience functions to get, set, and remove
variables from memory.

A parser can be created by:

const parser = math.parser()


The parser contains the following functions:


  clear()
Completely clear the parser’s scope.
  evaluate(expr)
Evaluate an expression. Returns the result of the expression.
  get(name)
Retrieve a variable or function from the parser’s scope.
  getAll()
Retrieve an object with all defined variables in the parser’s scope.
  getAllAsMap()
Retrieve a map with all defined variables in the parser’s scope.
  remove(name)
Remove a variable or function from the parser’s scope.
  set(name, value)
Set a variable or function in the parser’s scope.


The following code shows how to create and use a parser.

// create a parser
const parser = math.parser()

// evaluate expressions
parser.evaluate('sqrt(3^2 + 4^2)')      // 5
parser.evaluate('sqrt(-4)')             // 2i
parser.evaluate('2 inch to cm')         // 5.08 cm
parser.evaluate('cos(45 deg)')          // 0.7071067811865476

// define variables and functions
parser.evaluate('x = 7 / 2')            // 3.5
parser.evaluate('x + 3')                // 6.5
parser.evaluate('f(x, y) = x^y')        // f(x, y)
parser.evaluate('f(2, 3)')              // 8

// get and set variables and functions
const x = parser.get('x')               // x = 3.5
const f = parser.get('f')               // function
const g = f(3, 3)                       // g = 27
parser.set('h', 500)
parser.evaluate('h / 2')                // 250
parser.set('hello', function (name) {
    return 'hello, ' + name + '!'
})
parser.evaluate('hello("user")')        // "hello, user!"

// clear defined functions and variables
parser.clear()


Scope #

The scope is a data-structure used to store and lookup variables and functions defined and used by expressions.

It is passed to mathjs via calls to math.evaluate or simplify.

For ease of use, it can be a Plain Javascript Object; for safety it can be a plain Map and for flexibility, any object that has
the methods get/set/has/keys, seen on Map.

Some care is taken to mutate the same object that is passed into mathjs, so they can collect the definitions from mathjs scripts and expressions.

evaluate will fail if the expression uses a blacklisted symbol, preventing mathjs expressions to escape into Javascript. This is enforced by access to the scope.

For less reliance on this blacklist, scope can also be a Map, which allows mathjs expressions to define variables and functions of any name.

For more, see examples of custom scopes.\n\n\n\nExpression parsing and evaluation #

Expressions can be parsed and evaluated in various ways:


  Using the function math.evaluate(expr [,scope]).
  Using the function math.compile(expr).
  Using the function math.parse(expr).
  By creating a parser, math.parser(), which contains a method
evaluate and keeps a scope with assigned variables in memory.


Evaluate #

Math.js comes with a function math.evaluate to evaluate expressions. Syntax:

math.evaluate(expr)
math.evaluate(expr, scope)
math.evaluate([expr1, expr2, expr3, ...])
math.evaluate([expr1, expr2, expr3, ...], scope)


Function evaluate accepts a single expression or an array with
expressions as the first argument and has an optional second argument
containing a scope with variables and functions. The scope can be a regular
JavaScript Map (recommended), a plain JavaScript object, or any custom 
class that implements the Map interface with methods get, set, keys 
and has. The scope will be used to resolve symbols, and to write assigned
variables and functions.

When an Object is used as scope, mathjs will internally wrap it in an 
ObjectWrappingMap interface since the internal functions can only use a Map 
interface. In case of custom defined functions like f(x) = x^2, the scope 
will be wrapped in a PartitionedMap, which reads and writes the function
variables (like x in this example) from a temporary map, and reads and writes
other variables from the original scope. The original scope is never copied, it
is only wrapped around when needed.

The following code demonstrates how to evaluate expressions.

// evaluate expressions
math.evaluate('sqrt(3^2 + 4^2)')        // 5
math.evaluate('sqrt(-4)')               // 2i
math.evaluate('2 inch to cm')           // 5.08 cm
math.evaluate('cos(45 deg)')            // 0.7071067811865476

// provide a scope
let scope = {
    a: 3,
    b: 4
}
math.evaluate('a * b', scope)           // 12
math.evaluate('c = 2.3 + 4.5', scope)   // 6.8
scope.c                                 // 6.8


Compile #

Math.js contains a function math.compile which compiles expressions
into JavaScript code. This is a shortcut for first parsing and then
compiling an expression. The syntax is:

math.compile(expr)
math.compile([expr1, expr2, expr3, ...])


Function compile accepts a single expression or an array with
expressions as the argument. Function compile returns an object with a function
evaluate([scope]), which can be executed to evaluate the expression against an
(optional) scope:

const code = math.compile(expr)       // compile an expression
const result = code.evaluate([scope]) // evaluate the code with an optional scope


An expression needs to be compiled only once, after which the
expression can be evaluated repeatedly and against different scopes.
The optional scope is used to resolve symbols and to write assigned
variables or functions. Parameter scope can be a regular Object, or Map.

Example usage:

// parse an expression into a node, and evaluate the node
const code1 = math.compile('sqrt(3^2 + 4^2)')
code1.evaluate()  // 5


Parse #

Math.js contains a function math.parse to parse expressions into an
expression tree. The syntax is:

math.parse(expr)
math.parse([expr1, expr2, expr3, ...])


Function parse accepts a single expression or an array with
expressions as the argument. Function parse returns the root node of the tree,
which can be successively compiled and evaluated:

const node = math.parse(expr)         // parse expression into a node tree
const code = node.compile()           // compile the node tree
const result = code.evaluate([scope]) // evaluate the code with an optional scope


The API of nodes is described in detail on the page
Expression trees.

An expression needs to be parsed and compiled only once, after which the
expression can be evaluated repeatedly. On evaluation, an optional scope
can be provided, which is used to resolve symbols and to write assigned
variables or functions. Parameter scope is a regular Object or Map.

Example usage:

// parse an expression into a node, and evaluate the node
const node1 = math.parse('sqrt(3^2 + 4^2)')
const code1 = node1.compile()
code1.evaluate() // 5

// provide a scope
const node2 = math.parse('x^a')
const code2 = node2.compile()
let scope = {
    x: 3,
    a: 2
}
code2.evaluate(scope) // 9

// change a value in the scope and re-evaluate the node
scope.a = 3
code2.evaluate(scope) // 27


Parsed expressions can be exported to text using node.toString(), and can
be exported to LaTeX using node.toTex(). The LaTeX export can be used to
pretty print an expression in the browser with a library like
MathJax. Example usage:

// parse an expression
const node = math.parse('sqrt(x/x+1)')
node.toString()   // returns 'sqrt((x / x) + 1)'
node.toTex()      // returns ' qrt{ {\frac{x}{x} }+{1} }'


Parser #

In addition to the static functions math.evaluate and
math.parse, math.js contains a parser with functions evaluate and
parse, which automatically keeps a scope with assigned variables in memory.
The parser also contains some convenience functions to get, set, and remove
variables from memory.

A parser can be created by:

const parser = math.parser()


The parser contains the following functions:


  clear()
Completely clear the parser’s scope.
  evaluate(expr)
Evaluate an expression. Returns the result of the expression.
  get(name)
Retrieve a variable or function from the parser’s scope.
  getAll()
Retrieve an object with all defined variables in the parser’s scope.
  getAllAsMap()
Retrieve a map with all defined variables in the parser’s scope.
  remove(name)
Remove a variable or function from the parser’s scope.
  set(name, value)
Set a variable or function in the parser’s scope.


The following code shows how to create and use a parser.

// create a parser
const parser = math.parser()

// evaluate expressions
parser.evaluate('sqrt(3^2 + 4^2)')      // 5
parser.evaluate('sqrt(-4)')             // 2i
parser.evaluate('2 inch to cm')         // 5.08 cm
parser.evaluate('cos(45 deg)')          // 0.7071067811865476

// define variables and functions
parser.evaluate('x = 7 / 2')            // 3.5
parser.evaluate('x + 3')                // 6.5
parser.evaluate('f(x, y) = x^y')        // f(x, y)
parser.evaluate('f(2, 3)')              // 8

// get and set variables and functions
const x = parser.get('x')               // x = 3.5
const f = parser.get('f')               // function
const g = f(3, 3)                       // g = 27
parser.set('h', 500)
parser.evaluate('h / 2')                // 250
parser.set('hello', function (name) {
    return 'hello, ' + name + '!'
})
parser.evaluate('hello("user")')        // "hello, user!"

// clear defined functions and variables
parser.clear()


Scope #

The scope is a data-structure used to store and lookup variables and functions defined and used by expressions.

It is passed to mathjs via calls to math.evaluate or simplify.

For ease of use, it can be a Plain Javascript Object; for safety it can be a plain Map and for flexibility, any object that has
the methods get/set/has/keys, seen on Map.

Some care is taken to mutate the same object that is passed into mathjs, so they can collect the definitions from mathjs scripts and expressions.

evaluate will fail if the expression uses a blacklisted symbol, preventing mathjs expressions to escape into Javascript. This is enforced by access to the scope.

For less reliance on this blacklist, scope can also be a Map, which allows mathjs expressions to define variables and functions of any name.

For more, see examples of custom scopes.\n\n\n\nExpression syntax #

This page describes the syntax of expression parser of math.js. It describes
how to work with the available data types, functions, operators, variables,
and more.

Differences from JavaScript #

The expression parser of math.js is aimed at a mathematical audience,
not a programming audience. The syntax is similar to most calculators and
mathematical applications. This is close to JavaScript as well, though there
are a few important differences between the syntax of the expression parser and
the lower level syntax of math.js. Differences are:


  No need to prefix functions and constants with the math.* namespace,
you can just enter sin(pi / 4).
  Matrix indexes are one-based instead of zero-based.
  There are index and range operators which allow more conveniently getting
and setting matrix indexes, like A[2:4, 1].
  Both indexes and ranges and have the upper-bound included.
  There is a differing syntax for defining functions. Example: f(x) = x^2.
  There are custom operators like x + y instead of add(x, y).
  Some operators are different. For example  ^ is used for exponentiation,
not bitwise xor.
  Implicit multiplication, like 2 pi, is supported and has special rules.
  Relational operators (<, >, <=, >=, ==, and !=) are chained, so the expression 5 < x < 10 is equivalent to 5 < x and x < 10.
  Multi-expression constructs like a = 1; b = 2; a + b or
"a = 1;\n cos(a)\n sin(a)" (where \n denotes newline)
produce a collection (“ResultSet”) of values. Those expressions
terminated by ; are evaluated for side effect only and their values
are suppressed from the result.


Operators #

The expression parser has operators for all common arithmetic operations such
as addition and multiplication. The expression parser uses conventional infix
notation for operators: an operator is placed between its arguments.
Round parentheses can be used to override the default precedence of operators.

// use operators
math.evaluate('2 + 3')       // 5
math.evaluate('2 * 3')       // 6

// use parentheses to override the default precedence
math.evaluate('2 + 3 * 4')   // 14
math.evaluate('(2 + 3) * 4') // 20


The following operators are available. Note that almost every operator listed
also has a function form with identical meaning that can be used
interchangeably. For example, x+y will always evaluate identically to
add(x,y). For a full list of the equivalences, see the section on
Functions below.


  
    
      Operator
      Name
      Syntax
      Associativity
      Example
      Result
    
  
  
    
      (, )
      Grouping
      (x)
      None
      2 * (3 + 4)
      14
    
    
      [, ]
      Matrix, Index
      [...]
      None
      [[1,2],[3,4]]
      [[1,2],[3,4]]
    
    
      {, }
      Object
      {...}
      None
      {a: 1, b: 2}
      {a: 1, b: 2}
    
    
      ,
      Parameter separator
      x, y
      Left to right
      max(2, 1, 5)
      5
    
    
      .
      Property accessor
      obj.prop
      Left to right
      obj={a: 12}; obj.a
      12
    
    
      ;
      Statement separator
      x; y
      Left to right
      a=2; b=3; a*b
      [6]
    
    
      ;
      Row separator
      [x; y]
      Left to right
      [1,2;3,4]
      [[1,2],[3,4]]
    
    
      \n
      Statement separator
      x \n y
      Left to right
      a=2 \n b=3 \n a*b
      [2,3,6]
    
    
      +
      Add
      x + y
      Left to right
      4 + 5
      9
    
    
      +
      Unary plus
      +y
      Right to left
      +4
      4
    
    
      -
      Subtract
      x - y
      Left to right
      7 - 3
      4
    
    
      -
      Unary minus
      -y
      Right to left
      -4
      -4
    
    
      *
      Multiply
      x * y
      Left to right
      2 * 3
      6
    
    
      .*
      Element-wise multiply
      x .* y
      Left to right
      [1,2,3] .* [1,2,3]
      [1,4,9]
    
    
      /
      Divide
      x / y
      Left to right
      6 / 2
      3
    
    
      ./
      Element-wise divide
      x ./ y
      Left to right
      [9,6,4] ./ [3,2,2]
      [3,3,2]
    
    
      %
      Percentage
      x%
      None
      8%
      0.08
    
    
      %
      Addition with Percentage
      x + y%
      Left to right
      100 + 3%
      103
    
    
      %
      Subtraction with Percentage
      x - y%
      Left to right
      100 - 3%
      97
    
    
      % mod
      Modulus
      x % y
      Left to right
      8 % 3
      2
    
    
      ^
      Power
      x ^ y
      Right to left
      2 ^ 3
      8
    
    
      .^
      Element-wise power
      x .^ y
      Right to left
      [2,3] .^ [3,3]
      [8,27]
    
    
      '
      Transpose
      y'
      Left to right
      [[1,2],[3,4]]'
      [[1,3],[2,4]]
    
    
      !
      Factorial
      y!
      Left to right
      5!
      120
    
    
      &
      Bitwise and
      x & y
      Left to right
      5 & 3
      1
    
    
      ~
      Bitwise not
      ~x
      Right to left
      ~2
      -3
    
    
      |
      Bitwise or
      x | y
      Left to right
      5 | 3
      7
    
    
      ^|
      Bitwise xor
      x ^| y
      Left to right
      5 ^| 2
      7
    
    
      <<
      Left shift
      x << y
      Left to right
      4 << 1
      8
    
    
      >>
      Right arithmetic shift
      x >> y
      Left to right
      8 >> 1
      4
    
    
      >>>
      Right logical shift
      x >>> y
      Left to right
      -8 >>> 1
      2147483644
    
    
      and
      Logical and
      x and y
      Left to right
      true and false
      false
    
    
      not
      Logical not
      not y
      Right to left
      not true
      false
    
    
      or
      Logical or
      x or y
      Left to right
      true or false
      true
    
    
      xor
      Logical xor
      x xor y
      Left to right
      true xor true
      false
    
    
      =
      Assignment
      x = y
      Right to left
      a = 5
      5
    
    
      ? :
      Conditional expression
      x ? y : z
      Right to left
      15 > 100 ? 1 : -1
      -1
    
    
      :
      Range
      x : y
      Right to left
      1:4
      [1,2,3,4]
    
    
      to, in
      Unit conversion
      x to y
      Left to right
      2 inch to cm
      5.08 cm
    
    
      ==
      Equal
      x == y
      Left to right
      2 == 4 - 2
      true
    
    
      !=
      Unequal
      x != y
      Left to right
      2 != 3
      true
    
    
      <
      Smaller
      x < y
      Left to right
      2 < 3
      true
    
    
      >
      Larger
      x > y
      Left to right
      2 > 3
      false
    
    
      <=
      Smallereq
      x <= y
      Left to right
      4 <= 3
      false
    
    
      >=
      Largereq
      x >= y
      Left to right
      2 + 4 >= 6
      true
    
  


Precedence #

The operators have the following precedence, from highest to lowest:


  
    
      Operators
      Description
    
  
  
    
      (...)[...]{...}
      GroupingMatrixObject
    
    
      x(...)x[...]obj.prop:
      Function callMatrix indexProperty accessorKey/value separator
    
    
      '
      Matrix transpose
    
    
      !
      Factorial
    
    
      ^, .^
      Exponentiation
    
    
      +, -, ~, not
      Unary plus, unary minus, bitwise not, logical not
    
    
      See section below
      Implicit multiplication
    
    
      *, /, .*, ./,%, mod
      Multiply, divide , percentage, modulus
    
    
      +, -
      Add, subtract
    
    
      :
      Range
    
    
      to, in
      Unit conversion
    
    
      <<, >>, >>>
      Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift
    
    
      ==, !=, <, >, <=, >=
      Relational
    
    
      &
      Bitwise and (lazily evaluated)
    
    
      ^|
      Bitwise xor
    
    
      |
      Bitwise or (lazily evaluated)
    
    
      and
      Logical and (lazily evaluated)
    
    
      xor
      Logical xor
    
    
      or
      Logical or (lazily evaluated)
    
    
      ?, :
      Conditional expression
    
    
      =
      Assignment
    
    
      ,
      Parameter and column separator
    
    
      ;
      Row separator
    
    
      \n, ;
      Statement separators
    
  


Lazy evaluation is used where logically possible for bitwise and logical
operators. In the following example, the value of x will not even be 
evaluated because it cannot effect the final result:
math.evaluate('false and x')        // false, no matter what x equals


Functions #

Functions are called by entering their name, followed by zero or more
arguments enclosed by parentheses. All available functions are listed on the
page Functions.

math.evaluate('sqrt(25)')           // 5
math.evaluate('log(10000, 3 + 7)')  // 4
math.evaluate('sin(pi / 4)')        // 0.7071067811865475


New functions can be defined by “assigning” an expression to a function call
with one or more variables. Such function assignments are limited: they can
only be defined on a single line.

const parser = math.parser()

parser.evaluate('f(x) = x ^ 2 - 5')
parser.evaluate('f(2)')     // -1
parser.evaluate('f(3)')     // 4

parser.evaluate('g(x, y) = x ^ y')
parser.evaluate('g(2, 3)')  // 8


Note that these function assignments do not create closures; put another way,
all free variables in mathjs are dynamic:

const parser = math.parser()

parser.evaluate('x = 7')
parser.evaluate('h(y) = x + y')
parser.evaluate('h(3)')         // 10
parser.evaluate('x = 3')
parser.evaluate('h(3)')         // 6, *not* 10


It is however possible to pass functions as parameters:

const parser = math.parser()

parser.evaluate('twice(func, x) = func(func(x))')
parser.evaluate('twice(square, 2)')    // 16
parser.evaluate('f(x) = 3*x')
parser.evaluate('twice(f, 2)')         // 18

// a simplistic "numerical derivative":
parser.evaluate('eps = 1e-10')
parser.evaluate('nd(f, x) = (f(x+eps) - func(x-eps))/(2*eps)')
parser.evaluate('nd(square,2)')        // 4.000000330961484


Math.js itself heavily uses typed functions, which ensure correct inputs and
throws meaningful errors when the input arguments are invalid. One can create
a typed-function in the
expression parser like:

const parser = math.parser()

parser.evaluate('f = typed({"number": f(x) = x ^ 2 - 5})')


Finally, as mentioned above, there is a function form for nearly every one of
the mathematical operator symbols. Moreover, for some associative operators,
the corresponding function allows arbitrarily many arguments. The table below
gives the full correspondence.


  
    
      Operator Expression
      Equivalent Function Expression
    
  
  
    
      a or b
      or(a,b)
    
    
      a xor b
      xor(a,b)
    
    
      a and b
      and(a,b)
    
    
      a \| b
      bitOr(a,b)
    
    
      a ^\| b
      bitXor(a,b)
    
    
      a & b
      bitAnd(a,b)
    
    
      a == b
      equal(a,b)
    
    
      a != b
      unequal(a,b)
    
    
      a < b
      smaller(a,b)
    
    
      a > b
      larger(a,b)
    
    
      a <= b
      smallerEq(a,b)
    
    
      a << 3
      leftShift(a,3)
    
    
      a >> 3
      rightArithShift(a,3)
    
    
      a >>> 3
      rightLogShift(a,3)
    
    
      u to cm
      to(u, cm)
    
    
      a + b + c + ...
      add(a,b,c,...)
    
    
      a - b
      subtract(a,b)
    
    
      a * b * c * ...
      multiply(a,b,c,...)
    
    
      A .* B
      dotMultiply(A,B)
    
    
      A ./ B
      dotDivide(A,B)
    
    
      a mod b
      mod(a,b)
    
    
      +a
      unaryPlus(a)
    
    
      -a
      unaryMinus(a)
    
    
      ~a
      bitNot(a)
    
    
      not a
      not(a)
    
    
      a^b
      pow(a,b)
    
    
      A .^ B
      dotPow(A,B)
    
    
      a!
      factorial(a)
    
    
      A'
      ctranspose(A)
    
  


Note that math.js embodies a preference for the operator forms, in that calling
simplify (see Algebra) converts any instances of the function
form into the corresponding operator.

Map and forEach #

The map and forEach functions can be used to apply a callback function to each element of an array or matrix.

The callback functions can be functions, typed functions, inline functions (only in the parser) or compiled inline functions (only in the parser).

The callback can have the following inputs:

  value: the current value in the array or matrix.
  index: the index of the current value expressed as an array of numbers.
  array: the array or matrix being iterated.


Below is the syntax for both functions:

map #

The map function applies a function to each element of an array and returns a new array with the results.

const parser = math.parser()

// Define a square function
parser.evaluate('square(x) = x ^ 2')

// Apply the square function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], square)')
// result: [1, 4, 9, 16]

// Apply an inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], f(x) = x ^ 2)')
// result: [1, 4, 9, 16]

// Apply a compiled inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], x ^ 2)')
// result: [1, 4, 9, 16]


forEach #
The forEach function applies a function to each element of an array or matrix but does not return a new array. It is useful for executing side effects.

// Define a function that prints each element
math.import({consoleLog: x => console.log(x)})
const parser = math.parser()

// Define a squareConsleLog function
parser.evaluate('squareConsoleLog(x) = consoleLog(x ^ 2)')

// Apply the squareConsleLog function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], squareConsleLog)')
// Prints: 1, 4, 9, 16

// Apply an inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], f(x) = consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16

// Apply a compiled inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16


These functions are useful for performing element-wise operations on arrays or matrices.

Constants and variables #

Math.js has a number of built-in constants such as pi and e.
All available constants are listed on he page
Constants.

// use constants
math.evaluate('pi')                 // 3.141592653589793
math.evaluate('e ^ 2')              // 7.3890560989306495
math.evaluate('log(e)')             // 1
math.evaluate('e ^ (pi * i) + 1')   // ~0 (Euler)


Variables can be defined using the assignment operator =, and can be used
like constants.

const parser = math.parser()

// define variables
parser.evaluate('a = 3.4')      // 3.4
parser.evaluate('b = 5 / 2')    // 2.5

// use variables
parser.evaluate('a * b')        // 8.5


Variable names must:


  Begin with an “alpha character”, which is:
    
      A latin letter (upper or lower case). Ascii: a-z, A-Z
      An underscore.                        Ascii: _
      A dollar sign.                        Ascii: $
      A latin letter with accents.          Unicode: \u00C0 - \u02AF
      A greek letter.                       Unicode: \u0370 - \u03FF
      A letter-like character.              Unicode: \u2100 - \u214F
      A mathematical alphanumeric symbol.   Unicode: \u{1D400} - \u{1D7FF} excluding invalid code points
    
  
  Contain only alpha characters (above) and digits 0-9
  Not be any of the following: mod, to, in, and, xor, or, not, end. It is possible to assign to some of these, but that’s not recommended.


It is possible to customize the allowed alpha characters, see Customize supported characters for more information.

Data types #

The expression parser supports booleans, numbers, complex numbers, units,
strings, matrices, and objects.

Booleans #

Booleans true and false can be used in expressions.

// use booleans
math.evaluate('true')               // true
math.evaluate('false')              // false
math.evaluate('(2 == 3) == false')  // true


Booleans can be converted to numbers and strings and vice versa using the
functions number and boolean, and string.

// convert booleans
math.evaluate('number(true)')       // 1
math.evaluate('string(false)')      // "false"
math.evaluate('boolean(1)')         // true
math.evaluate('boolean("false")')   // false


Numbers #

The most important and basic data type in math.js are numbers. Numbers use a
point as decimal mark. Numbers can be entered with exponential notation.
Examples:

// numbers in math.js
math.evaluate('2')        // 2
math.evaluate('3.14')     // 3.14
math.evaluate('1.4e3')    // 1400
math.evaluate('22e-3')    // 0.022


A number can be converted to a string and vice versa using the functions
number and string.

// convert a string into a number
math.evaluate('number("2.3")')    // 2.3
math.evaluate('string(2.3)')      // "2.3"


Math.js uses regular JavaScript numbers, which are floating points with a
limited precision and limited range. The limitations are described in detail
on the page Numbers.

math.evaluate('1e-325')   // 0
math.evaluate('1e309')    // Infinity
math.evaluate('-1e309')   // -Infinity


When doing calculations with floats, one can very easily get round-off errors:

// round-off error due to limited floating point precision
math.evaluate('0.1 + 0.2')  // 0.30000000000000004


When outputting results, the function math.format can be used to hide
these round-off errors when outputting results for the user:

const ans = math.evaluate('0.1 + 0.2')  //  0.30000000000000004
math.format(ans, {precision: 14})       // "0.3"


Numbers can be expressed as binary, octal, and hexadecimal literals:

math.evaluate('0b11')  //  3
math.evaluate('0o77')  //  63
math.evaluate('0xff')  //  255


A word size suffix can be used to change the behavior of non decimal literal evaluation:

math.evaluate('0xffi8')         // -1
math.evaluate('0xffffffffi32')  //  -1
math.evaluate('0xfffffffffi32') //  SyntaxError: String "0xfffffffff" is out of range


Non decimal numbers can include a radix point:
math.evaluate('0b1.1')         // 1.5
math.evaluate('0o1.4')         // 1.5
math.evaluate('0x1.8')         // 1.5


Numbers can be formatted as binary, octal, and hex strings using the notation option of the format function:

math.evaluate('format(3, {notation: "bin"})')    //  '0b11'
math.evaluate('format(63, {notation: "oct"})')   //  '0o77'
math.evaluate('format(255, {notation: "hex"})')  //  '0xff'
math.evaluate('format(-1, {notation: "hex"})')   //  '-0x1'
math.evaluate('format(2.3, {notation: "hex"})')  //  '0x2.4cccccccccccc'


The format function accepts a wordSize option to use in conjunction with the non binary notations:

math.evaluate('format(-1, {notation: "hex", wordSize: 8})')   //  '0xffi8'


The functions bin, oct, and hex are shorthand for the format function with notation set accordingly:

math.evaluate('bin(-1)')     // '-0b1'
math.evaluate('bin(-1, 8)')  // '0b11111111i8'


BigNumbers #

Math.js supports BigNumbers for calculations with an arbitrary precision.
The pros and cons of Number and BigNumber are explained in detail on the page
Numbers.

BigNumbers are slower but have a higher precision. Calculations with big
numbers are supported only by arithmetic functions.

BigNumbers can be created using the bignumber function:

math.evaluate('bignumber(0.1) + bignumber(0.2)') // BigNumber, 0.3


The default number type of the expression parser can be changed at instantiation
of math.js. The expression parser parses numbers as BigNumber by default:

// Configure the type of number: 'number' (default), 'BigNumber', or 'Fraction'
math.config({number: 'BigNumber'})

// all numbers are parsed as BigNumber
math.evaluate('0.1 + 0.2')  // BigNumber, 0.3


BigNumbers can be converted to numbers and vice versa using the functions
number and bignumber. When converting a BigNumber to a Number, the high
precision of the BigNumber will be lost. When a BigNumber is too large to be represented
as Number, it will be initialized as Infinity.

Complex numbers #

Complex numbers can be created using the imaginary unit i, which is defined
as i^2 = -1. Complex numbers have a real and complex part, which can be
retrieved using the functions re and im.

const parser = math.parser()

// create complex numbers
parser.evaluate('a = 2 + 3i')   // Complex, 2 + 3i
parser.evaluate('b = 4 - i')    // Complex, 4 - i

// get real and imaginary part of a complex number
parser.evaluate('re(a)')        // Number,  2
parser.evaluate('im(a)')        // Number,  3

// calculations with complex numbers
parser.evaluate('a + b')        // Complex, 6 + 2i
parser.evaluate('a * b')        // Complex, 11 + 10i
parser.evaluate('i * i')        // Number,  -1
parser.evaluate('sqrt(-4)')     // Complex, 2i


Units #

math.js supports units. Units can be used in the arithmetic operations
add, subtract, multiply, divide, and exponentiation.
Units can also be converted from one to another.
An overview of all available units can be found on the page
Units.

Units can be converted using the operator to or in.

// create a unit
math.evaluate('5.4 kg')                     // Unit, 5.4 kg

// convert a unit
math.evaluate('2 inch to cm')               // Unit, 5.08 cm
math.evaluate('20 celsius in fahrenheit')   // Unit, ~68 fahrenheit
math.evaluate('90 km/h to m/s')             // Unit, 25 m / s

// convert a unit to a number
// A second parameter with the unit for the exported number must be provided
math.evaluate('number(5 cm, mm)')           // Number, 50

// calculations with units
math.evaluate('0.5kg + 33g')                // Unit, 0.533 kg
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('12 seconds * 2')             // Unit, 24 seconds
math.evaluate('sin(45 deg)')                // Number, 0.7071067811865475
math.evaluate('9.81 m/s^2 * 5 s to mi/h')   // Unit, 109.72172512527 mi / h


Strings #

Strings are enclosed by double quotes “ or single quotes ‘. Strings can be concatenated using the
function concat (not by adding them using + like in JavaScript). Parts of
a string can be retrieved or replaced by using indexes. Strings can be converted
to a number using function number, and numbers can be converted to a string
using function string.

When setting the value of a character in a string, the character that has been
set is returned. Likewise, when a range of characters is set, that range of
characters is returned.

const parser = math.parser()

// create a string
parser.evaluate('"hello"')                        // String, "hello"

// string manipulation
parser.evaluate('a = concat("hello", " world")')  // String, "hello world"
parser.evaluate('size(a)')                        // Matrix [11]
parser.evaluate('a[1:5]')                         // String, "hello"
parser.evaluate('a[1] = "H"')                     // String, "H"
parser.evaluate('a[7:12] = "there!"')             // String, "there!"
parser.evaluate('a')                              // String, "Hello there!"

// string conversion
parser.evaluate('number("300")')                  // Number, 300
parser.evaluate('string(300)')                    // String, "300"


Strings can be used in the evaluate function, to parse expressions inside
the expression parser:

math.evaluate('evaluate("2 + 3")')  // 5


Matrices #

Matrices can be created by entering a series of values between square brackets,
elements are separated by a comma ,.
A matrix like [1, 2, 3] will create a vector, a 1-dimensional matrix with
size [3]. To create a multi-dimensional matrix, matrices can be nested into
each other. For easier creation of two-dimensional matrices, a semicolon ;
can be used to separate rows in a matrix.

// create a matrix
math.evaluate('[1, 2, 3]')                                // Matrix, size [3]
math.evaluate('[[1, 2, 3], [4, 5, 6]]')                   // Matrix, size [2, 3]
math.evaluate('[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]')     // Matrix, size [2, 2, 2]

// create a two dimensional matrix
math.evaluate('[1, 2, 3; 4, 5, 6]')                       // Matrix, size [2, 3]


Another way to create filled matrices is using the functions zeros, ones,
identity, and range.

// initialize a matrix with ones or zeros
math.evaluate('zeros(3, 2)')      // Matrix, [[0, 0], [0, 0], [0, 0]],  size [3, 2]
math.evaluate('ones(3)')          // Matrix, [1, 1, 1],                 size [3]
math.evaluate('5 * ones(2, 2)')   // Matrix, [[5, 5], [5, 5]],          size [2, 2]

// create an identity matrix
math.evaluate('identity(2)')      // Matrix, [[1, 0], [0, 1]],          size [2, 2]

// create a range
math.evaluate('1:4')              // Matrix, [1, 2, 3, 4],              size [4]
math.evaluate('0:2:10')           // Matrix, [0, 2, 4, 6, 8, 10],       size [6]


A subset can be retrieved from a matrix using indexes and a subset of a matrix
can be replaced by using indexes. Indexes are enclosed in square brackets, and
contain a number or a range for each of the matrix dimensions. A range can have
its start and/or end undefined. When the start is undefined, the range will start
at 1, when the end is undefined, the range will end at the end of the matrix.

There is a context variable end available as well to denote the end of the
matrix. This variable cannot be used in multiple nested indices. In that case,
end will be resolved as the end of the innermost matrix. To solve this, 
resolving of the nested index needs to be split in two separate operations.

IMPORTANT: matrix indexes and ranges work differently from the math.js indexes
in JavaScript: They are one-based with an included upper-bound, similar to most
math applications.

parser = math.parser()

// create matrices
parser.evaluate('a = [1, 2; 3, 4]')       // Matrix, [[1, 2], [3, 4]]
parser.evaluate('b = zeros(2, 2)')        // Matrix, [[0, 0], [0, 0]]
parser.evaluate('c = 5:9')                // Matrix, [5, 6, 7, 8, 9]

// replace a subset in a matrix
parser.evaluate('b[1, 1:2] = [5, 6]')     // Matrix, [[5, 6], [0, 0]]
parser.evaluate('b[2, :] = [7, 8]')       // Matrix, [[5, 6], [7, 8]]

// perform a matrix calculation
parser.evaluate('d = a * b')              // Matrix, [[19, 22], [43, 50]]

// retrieve a subset of a matrix
parser.evaluate('d[2, 1]')                // 43
parser.evaluate('d[2, 1:end]')            // Matrix, [[43, 50]]
parser.evaluate('c[end - 1 : -1 : 2]')    // Matrix, [8, 7, 6]


Objects #

Objects in math.js work the same as in languages like JavaScript and Python.
An object is enclosed by curly brackets {, }, and contains a set of
comma separated key/value pairs. Keys and values are separated by a colon :.
Keys can be a symbol like prop or a string like "prop".

math.evaluate('{a: 2 + 1, b: 4}')         // {a: 3, b: 4}
math.evaluate('{"a": 2 + 1, "b": 4}')     // {a: 3, b: 4}


Objects can contain objects:

math.evaluate('{a: 2, b: {c: 3, d: 4}}')  // {a: 2, b: {c: 3, d: 4}}


Object properties can be retrieved or replaced using dot notation or bracket
notation. Unlike JavaScript, when setting a property value, the whole object
is returned, not the property value

let scope = {
  obj: {
    prop: 42
  }
}

// retrieve properties
math.evaluate('obj.prop', scope)          // 42
math.evaluate('obj["prop"]', scope)       // 42

// set properties (returns the whole object, not the property value!)
math.evaluate('obj.prop = 43', scope)     // {prop: 43}
math.evaluate('obj["prop"] = 43', scope)  // {prop: 43}
scope.obj                                 // {prop: 43}


Multi-line expressions #

An expression can contain multiple lines, and expressions can be spread over
multiple lines. Lines can be separated by a newline character \n or by a
semicolon ;. Output of statements followed by a semicolon will be hidden from
the output, and empty lines are ignored. The output is returned as a ResultSet,
with an entry for every visible statement.

// a multi-line expression
math.evaluate('1 * 3 \n 2 * 3 \n 3 * 3')    // ResultSet, [3, 6, 9]

// semicolon statements are hidden from the output
math.evaluate('a=3; b=4; a + b \n a * b')   // ResultSet, [7, 12]

// single expression spread over multiple lines
math.evaluate('a = 2 +\n  3')               // 5
math.evaluate('[\n  1, 2;\n  3, 4\n]')      // Matrix, [[1, 2], [3, 4]]


The results can be read from a ResultSet via the property ResultSet.entries
which is an Array, or by calling ResultSet.valueOf(), which returns the
array with results.

Implicit multiplication #

Implicit multiplication means the multiplication of two symbols, numbers, or a grouped expression inside parentheses without using the * operator. This type of syntax allows a more natural way to enter expressions. For example:

math.evaluate('2 pi')         // 6.283185307179586
math.evaluate('(1+2)(3+4)')   // 21


Parentheses are parsed as a function call when there is a symbol or accessor on
the left hand side, like sqrt(4) or obj.method(4). In other cases the
parentheses are interpreted as an implicit multiplication.

Math.js will always evaluate implicit multiplication before explicit multiplication *, so that the expression x * y z is parsed as x * (y * z). Math.js also gives implicit multiplication higher precedence than division, except when the division matches the pattern [unaryPrefixOp]?[number] / [number] [symbol] or [unaryPrefixOp]?[number] / [number] [left paren]. In that special case, the division is evaluated first:

math.evaluate('20 kg / 4 kg')   // 5      Evaluated as (20 kg) / (4 kg)
math.evaluate('20 / 4 kg')      // 5 kg   Evaluated as (20 / 4) kg


The behavior of implicit multiplication can be summarized by these operator precedence rules, listed from highest to lowest precedence:


  Function calls: [symbol] [left paren]
  Explicit division / when the division matches this pattern: [+-~]?[number] / [+-~]?[number] [symbol] or [number] / [number] [left paren]
  Implicit multiplication
  All other division / and multiplication *


Implicit multiplication is tricky as there can appear to be ambiguity in how an expression will be evaluated. Experience has shown that the above rules most closely match user intent when entering expressions that could be interpreted different ways. It’s also possible that these rules could be tweaked in future major releases.  Use implicit multiplication carefully. If you don’t like the uncertainty introduced by implicit multiplication, use explicit * operators and parentheses to ensure your expression is evaluated the way you intend.

Here are some more examples using implicit multiplication:


  
    
      Expression
      Evaluated as
      Result
    
  
  
    
      (1 + 3) pi
      (1 + 3) * pi
      12.566370614359172
    
    
      (4 - 1) 2
      (4 - 1) * 2
      6
    
    
      3 / 4 mm
      (3 / 4) * mm
      0.75 mm
    
    
      2 + 3 i
      2 + (3 * i)
      2 + 3i
    
    
      (1 + 2) (4 - 2)
      (1 + 2) * (4 - 2)
      6
    
    
      sqrt(4) (1 + 2)
      sqrt(4) * (1 + 2)
      6
    
    
      8 pi / 2 pi
      (8 * pi) / (2 * pi)
      4
    
    
      pi / 2 pi
      pi / (2 * pi)
      0.5
    
    
      1 / 2i
      (1 / 2) * i
      0.5 i
    
    
      8.314 J / mol K
      8.314 J / (mol * K)
      8.314 J / (mol * K)
    
  


Comments #

Comments can be added to explain or describe calculations in the text. A comment
starts with a sharp sign character #, and ends at the end of the line. A line
can contain a comment only, or can contain an expression followed by a comment.

const parser = math.parser()

parser.evaluate('# define some variables')
parser.evaluate('width = 3')                              // 3
parser.evaluate('height = 4')                             // 4
parser.evaluate('width * height   # calculate the area')  // 12\n\n\n\nExpression syntax #

This page describes the syntax of expression parser of math.js. It describes
how to work with the available data types, functions, operators, variables,
and more.

Differences from JavaScript #

The expression parser of math.js is aimed at a mathematical audience,
not a programming audience. The syntax is similar to most calculators and
mathematical applications. This is close to JavaScript as well, though there
are a few important differences between the syntax of the expression parser and
the lower level syntax of math.js. Differences are:


  No need to prefix functions and constants with the math.* namespace,
you can just enter sin(pi / 4).
  Matrix indexes are one-based instead of zero-based.
  There are index and range operators which allow more conveniently getting
and setting matrix indexes, like A[2:4, 1].
  Both indexes and ranges and have the upper-bound included.
  There is a differing syntax for defining functions. Example: f(x) = x^2.
  There are custom operators like x + y instead of add(x, y).
  Some operators are different. For example  ^ is used for exponentiation,
not bitwise xor.
  Implicit multiplication, like 2 pi, is supported and has special rules.
  Relational operators (<, >, <=, >=, ==, and !=) are chained, so the expression 5 < x < 10 is equivalent to 5 < x and x < 10.
  Multi-expression constructs like a = 1; b = 2; a + b or
"a = 1;\n cos(a)\n sin(a)" (where \n denotes newline)
produce a collection (“ResultSet”) of values. Those expressions
terminated by ; are evaluated for side effect only and their values
are suppressed from the result.


Operators #

The expression parser has operators for all common arithmetic operations such
as addition and multiplication. The expression parser uses conventional infix
notation for operators: an operator is placed between its arguments.
Round parentheses can be used to override the default precedence of operators.

// use operators
math.evaluate('2 + 3')       // 5
math.evaluate('2 * 3')       // 6

// use parentheses to override the default precedence
math.evaluate('2 + 3 * 4')   // 14
math.evaluate('(2 + 3) * 4') // 20


The following operators are available. Note that almost every operator listed
also has a function form with identical meaning that can be used
interchangeably. For example, x+y will always evaluate identically to
add(x,y). For a full list of the equivalences, see the section on
Functions below.


  
    
      Operator
      Name
      Syntax
      Associativity
      Example
      Result
    
  
  
    
      (, )
      Grouping
      (x)
      None
      2 * (3 + 4)
      14
    
    
      [, ]
      Matrix, Index
      [...]
      None
      [[1,2],[3,4]]
      [[1,2],[3,4]]
    
    
      {, }
      Object
      {...}
      None
      {a: 1, b: 2}
      {a: 1, b: 2}
    
    
      ,
      Parameter separator
      x, y
      Left to right
      max(2, 1, 5)
      5
    
    
      .
      Property accessor
      obj.prop
      Left to right
      obj={a: 12}; obj.a
      12
    
    
      ;
      Statement separator
      x; y
      Left to right
      a=2; b=3; a*b
      [6]
    
    
      ;
      Row separator
      [x; y]
      Left to right
      [1,2;3,4]
      [[1,2],[3,4]]
    
    
      \n
      Statement separator
      x \n y
      Left to right
      a=2 \n b=3 \n a*b
      [2,3,6]
    
    
      +
      Add
      x + y
      Left to right
      4 + 5
      9
    
    
      +
      Unary plus
      +y
      Right to left
      +4
      4
    
    
      -
      Subtract
      x - y
      Left to right
      7 - 3
      4
    
    
      -
      Unary minus
      -y
      Right to left
      -4
      -4
    
    
      *
      Multiply
      x * y
      Left to right
      2 * 3
      6
    
    
      .*
      Element-wise multiply
      x .* y
      Left to right
      [1,2,3] .* [1,2,3]
      [1,4,9]
    
    
      /
      Divide
      x / y
      Left to right
      6 / 2
      3
    
    
      ./
      Element-wise divide
      x ./ y
      Left to right
      [9,6,4] ./ [3,2,2]
      [3,3,2]
    
    
      %
      Percentage
      x%
      None
      8%
      0.08
    
    
      %
      Addition with Percentage
      x + y%
      Left to right
      100 + 3%
      103
    
    
      %
      Subtraction with Percentage
      x - y%
      Left to right
      100 - 3%
      97
    
    
      % mod
      Modulus
      x % y
      Left to right
      8 % 3
      2
    
    
      ^
      Power
      x ^ y
      Right to left
      2 ^ 3
      8
    
    
      .^
      Element-wise power
      x .^ y
      Right to left
      [2,3] .^ [3,3]
      [8,27]
    
    
      '
      Transpose
      y'
      Left to right
      [[1,2],[3,4]]'
      [[1,3],[2,4]]
    
    
      !
      Factorial
      y!
      Left to right
      5!
      120
    
    
      &
      Bitwise and
      x & y
      Left to right
      5 & 3
      1
    
    
      ~
      Bitwise not
      ~x
      Right to left
      ~2
      -3
    
    
      |
      Bitwise or
      x | y
      Left to right
      5 | 3
      7
    
    
      ^|
      Bitwise xor
      x ^| y
      Left to right
      5 ^| 2
      7
    
    
      <<
      Left shift
      x << y
      Left to right
      4 << 1
      8
    
    
      >>
      Right arithmetic shift
      x >> y
      Left to right
      8 >> 1
      4
    
    
      >>>
      Right logical shift
      x >>> y
      Left to right
      -8 >>> 1
      2147483644
    
    
      and
      Logical and
      x and y
      Left to right
      true and false
      false
    
    
      not
      Logical not
      not y
      Right to left
      not true
      false
    
    
      or
      Logical or
      x or y
      Left to right
      true or false
      true
    
    
      xor
      Logical xor
      x xor y
      Left to right
      true xor true
      false
    
    
      =
      Assignment
      x = y
      Right to left
      a = 5
      5
    
    
      ? :
      Conditional expression
      x ? y : z
      Right to left
      15 > 100 ? 1 : -1
      -1
    
    
      :
      Range
      x : y
      Right to left
      1:4
      [1,2,3,4]
    
    
      to, in
      Unit conversion
      x to y
      Left to right
      2 inch to cm
      5.08 cm
    
    
      ==
      Equal
      x == y
      Left to right
      2 == 4 - 2
      true
    
    
      !=
      Unequal
      x != y
      Left to right
      2 != 3
      true
    
    
      <
      Smaller
      x < y
      Left to right
      2 < 3
      true
    
    
      >
      Larger
      x > y
      Left to right
      2 > 3
      false
    
    
      <=
      Smallereq
      x <= y
      Left to right
      4 <= 3
      false
    
    
      >=
      Largereq
      x >= y
      Left to right
      2 + 4 >= 6
      true
    
  


Precedence #

The operators have the following precedence, from highest to lowest:


  
    
      Operators
      Description
    
  
  
    
      (...)[...]{...}
      GroupingMatrixObject
    
    
      x(...)x[...]obj.prop:
      Function callMatrix indexProperty accessorKey/value separator
    
    
      '
      Matrix transpose
    
    
      !
      Factorial
    
    
      ^, .^
      Exponentiation
    
    
      +, -, ~, not
      Unary plus, unary minus, bitwise not, logical not
    
    
      See section below
      Implicit multiplication
    
    
      *, /, .*, ./,%, mod
      Multiply, divide , percentage, modulus
    
    
      +, -
      Add, subtract
    
    
      :
      Range
    
    
      to, in
      Unit conversion
    
    
      <<, >>, >>>
      Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift
    
    
      ==, !=, <, >, <=, >=
      Relational
    
    
      &
      Bitwise and (lazily evaluated)
    
    
      ^|
      Bitwise xor
    
    
      |
      Bitwise or (lazily evaluated)
    
    
      and
      Logical and (lazily evaluated)
    
    
      xor
      Logical xor
    
    
      or
      Logical or (lazily evaluated)
    
    
      ?, :
      Conditional expression
    
    
      =
      Assignment
    
    
      ,
      Parameter and column separator
    
    
      ;
      Row separator
    
    
      \n, ;
      Statement separators
    
  


Lazy evaluation is used where logically possible for bitwise and logical
operators. In the following example, the value of x will not even be 
evaluated because it cannot effect the final result:
math.evaluate('false and x')        // false, no matter what x equals


Functions #

Functions are called by entering their name, followed by zero or more
arguments enclosed by parentheses. All available functions are listed on the
page Functions.

math.evaluate('sqrt(25)')           // 5
math.evaluate('log(10000, 3 + 7)')  // 4
math.evaluate('sin(pi / 4)')        // 0.7071067811865475


New functions can be defined by “assigning” an expression to a function call
with one or more variables. Such function assignments are limited: they can
only be defined on a single line.

const parser = math.parser()

parser.evaluate('f(x) = x ^ 2 - 5')
parser.evaluate('f(2)')     // -1
parser.evaluate('f(3)')     // 4

parser.evaluate('g(x, y) = x ^ y')
parser.evaluate('g(2, 3)')  // 8


Note that these function assignments do not create closures; put another way,
all free variables in mathjs are dynamic:

const parser = math.parser()

parser.evaluate('x = 7')
parser.evaluate('h(y) = x + y')
parser.evaluate('h(3)')         // 10
parser.evaluate('x = 3')
parser.evaluate('h(3)')         // 6, *not* 10


It is however possible to pass functions as parameters:

const parser = math.parser()

parser.evaluate('twice(func, x) = func(func(x))')
parser.evaluate('twice(square, 2)')    // 16
parser.evaluate('f(x) = 3*x')
parser.evaluate('twice(f, 2)')         // 18

// a simplistic "numerical derivative":
parser.evaluate('eps = 1e-10')
parser.evaluate('nd(f, x) = (f(x+eps) - func(x-eps))/(2*eps)')
parser.evaluate('nd(square,2)')        // 4.000000330961484


Math.js itself heavily uses typed functions, which ensure correct inputs and
throws meaningful errors when the input arguments are invalid. One can create
a typed-function in the
expression parser like:

const parser = math.parser()

parser.evaluate('f = typed({"number": f(x) = x ^ 2 - 5})')


Finally, as mentioned above, there is a function form for nearly every one of
the mathematical operator symbols. Moreover, for some associative operators,
the corresponding function allows arbitrarily many arguments. The table below
gives the full correspondence.


  
    
      Operator Expression
      Equivalent Function Expression
    
  
  
    
      a or b
      or(a,b)
    
    
      a xor b
      xor(a,b)
    
    
      a and b
      and(a,b)
    
    
      a \| b
      bitOr(a,b)
    
    
      a ^\| b
      bitXor(a,b)
    
    
      a & b
      bitAnd(a,b)
    
    
      a == b
      equal(a,b)
    
    
      a != b
      unequal(a,b)
    
    
      a < b
      smaller(a,b)
    
    
      a > b
      larger(a,b)
    
    
      a <= b
      smallerEq(a,b)
    
    
      a << 3
      leftShift(a,3)
    
    
      a >> 3
      rightArithShift(a,3)
    
    
      a >>> 3
      rightLogShift(a,3)
    
    
      u to cm
      to(u, cm)
    
    
      a + b + c + ...
      add(a,b,c,...)
    
    
      a - b
      subtract(a,b)
    
    
      a * b * c * ...
      multiply(a,b,c,...)
    
    
      A .* B
      dotMultiply(A,B)
    
    
      A ./ B
      dotDivide(A,B)
    
    
      a mod b
      mod(a,b)
    
    
      +a
      unaryPlus(a)
    
    
      -a
      unaryMinus(a)
    
    
      ~a
      bitNot(a)
    
    
      not a
      not(a)
    
    
      a^b
      pow(a,b)
    
    
      A .^ B
      dotPow(A,B)
    
    
      a!
      factorial(a)
    
    
      A'
      ctranspose(A)
    
  


Note that math.js embodies a preference for the operator forms, in that calling
simplify (see Algebra) converts any instances of the function
form into the corresponding operator.

Map and forEach #

The map and forEach functions can be used to apply a callback function to each element of an array or matrix.

The callback functions can be functions, typed functions, inline functions (only in the parser) or compiled inline functions (only in the parser).

The callback can have the following inputs:

  value: the current value in the array or matrix.
  index: the index of the current value expressed as an array of numbers.
  array: the array or matrix being iterated.


Below is the syntax for both functions:

map #

The map function applies a function to each element of an array and returns a new array with the results.

const parser = math.parser()

// Define a square function
parser.evaluate('square(x) = x ^ 2')

// Apply the square function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], square)')
// result: [1, 4, 9, 16]

// Apply an inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], f(x) = x ^ 2)')
// result: [1, 4, 9, 16]

// Apply a compiled inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], x ^ 2)')
// result: [1, 4, 9, 16]


forEach #
The forEach function applies a function to each element of an array or matrix but does not return a new array. It is useful for executing side effects.

// Define a function that prints each element
math.import({consoleLog: x => console.log(x)})
const parser = math.parser()

// Define a squareConsleLog function
parser.evaluate('squareConsoleLog(x) = consoleLog(x ^ 2)')

// Apply the squareConsleLog function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], squareConsleLog)')
// Prints: 1, 4, 9, 16

// Apply an inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], f(x) = consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16

// Apply a compiled inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16


These functions are useful for performing element-wise operations on arrays or matrices.

Constants and variables #

Math.js has a number of built-in constants such as pi and e.
All available constants are listed on he page
Constants.

// use constants
math.evaluate('pi')                 // 3.141592653589793
math.evaluate('e ^ 2')              // 7.3890560989306495
math.evaluate('log(e)')             // 1
math.evaluate('e ^ (pi * i) + 1')   // ~0 (Euler)


Variables can be defined using the assignment operator =, and can be used
like constants.

const parser = math.parser()

// define variables
parser.evaluate('a = 3.4')      // 3.4
parser.evaluate('b = 5 / 2')    // 2.5

// use variables
parser.evaluate('a * b')        // 8.5


Variable names must:


  Begin with an “alpha character”, which is:
    
      A latin letter (upper or lower case). Ascii: a-z, A-Z
      An underscore.                        Ascii: _
      A dollar sign.                        Ascii: $
      A latin letter with accents.          Unicode: \u00C0 - \u02AF
      A greek letter.                       Unicode: \u0370 - \u03FF
      A letter-like character.              Unicode: \u2100 - \u214F
      A mathematical alphanumeric symbol.   Unicode: \u{1D400} - \u{1D7FF} excluding invalid code points
    
  
  Contain only alpha characters (above) and digits 0-9
  Not be any of the following: mod, to, in, and, xor, or, not, end. It is possible to assign to some of these, but that’s not recommended.


It is possible to customize the allowed alpha characters, see Customize supported characters for more information.

Data types #

The expression parser supports booleans, numbers, complex numbers, units,
strings, matrices, and objects.

Booleans #

Booleans true and false can be used in expressions.

// use booleans
math.evaluate('true')               // true
math.evaluate('false')              // false
math.evaluate('(2 == 3) == false')  // true


Booleans can be converted to numbers and strings and vice versa using the
functions number and boolean, and string.

// convert booleans
math.evaluate('number(true)')       // 1
math.evaluate('string(false)')      // "false"
math.evaluate('boolean(1)')         // true
math.evaluate('boolean("false")')   // false


Numbers #

The most important and basic data type in math.js are numbers. Numbers use a
point as decimal mark. Numbers can be entered with exponential notation.
Examples:

// numbers in math.js
math.evaluate('2')        // 2
math.evaluate('3.14')     // 3.14
math.evaluate('1.4e3')    // 1400
math.evaluate('22e-3')    // 0.022


A number can be converted to a string and vice versa using the functions
number and string.

// convert a string into a number
math.evaluate('number("2.3")')    // 2.3
math.evaluate('string(2.3)')      // "2.3"


Math.js uses regular JavaScript numbers, which are floating points with a
limited precision and limited range. The limitations are described in detail
on the page Numbers.

math.evaluate('1e-325')   // 0
math.evaluate('1e309')    // Infinity
math.evaluate('-1e309')   // -Infinity


When doing calculations with floats, one can very easily get round-off errors:

// round-off error due to limited floating point precision
math.evaluate('0.1 + 0.2')  // 0.30000000000000004


When outputting results, the function math.format can be used to hide
these round-off errors when outputting results for the user:

const ans = math.evaluate('0.1 + 0.2')  //  0.30000000000000004
math.format(ans, {precision: 14})       // "0.3"


Numbers can be expressed as binary, octal, and hexadecimal literals:

math.evaluate('0b11')  //  3
math.evaluate('0o77')  //  63
math.evaluate('0xff')  //  255


A word size suffix can be used to change the behavior of non decimal literal evaluation:

math.evaluate('0xffi8')         // -1
math.evaluate('0xffffffffi32')  //  -1
math.evaluate('0xfffffffffi32') //  SyntaxError: String "0xfffffffff" is out of range


Non decimal numbers can include a radix point:
math.evaluate('0b1.1')         // 1.5
math.evaluate('0o1.4')         // 1.5
math.evaluate('0x1.8')         // 1.5


Numbers can be formatted as binary, octal, and hex strings using the notation option of the format function:

math.evaluate('format(3, {notation: "bin"})')    //  '0b11'
math.evaluate('format(63, {notation: "oct"})')   //  '0o77'
math.evaluate('format(255, {notation: "hex"})')  //  '0xff'
math.evaluate('format(-1, {notation: "hex"})')   //  '-0x1'
math.evaluate('format(2.3, {notation: "hex"})')  //  '0x2.4cccccccccccc'


The format function accepts a wordSize option to use in conjunction with the non binary notations:

math.evaluate('format(-1, {notation: "hex", wordSize: 8})')   //  '0xffi8'


The functions bin, oct, and hex are shorthand for the format function with notation set accordingly:

math.evaluate('bin(-1)')     // '-0b1'
math.evaluate('bin(-1, 8)')  // '0b11111111i8'


BigNumbers #

Math.js supports BigNumbers for calculations with an arbitrary precision.
The pros and cons of Number and BigNumber are explained in detail on the page
Numbers.

BigNumbers are slower but have a higher precision. Calculations with big
numbers are supported only by arithmetic functions.

BigNumbers can be created using the bignumber function:

math.evaluate('bignumber(0.1) + bignumber(0.2)') // BigNumber, 0.3


The default number type of the expression parser can be changed at instantiation
of math.js. The expression parser parses numbers as BigNumber by default:

// Configure the type of number: 'number' (default), 'BigNumber', or 'Fraction'
math.config({number: 'BigNumber'})

// all numbers are parsed as BigNumber
math.evaluate('0.1 + 0.2')  // BigNumber, 0.3


BigNumbers can be converted to numbers and vice versa using the functions
number and bignumber. When converting a BigNumber to a Number, the high
precision of the BigNumber will be lost. When a BigNumber is too large to be represented
as Number, it will be initialized as Infinity.

Complex numbers #

Complex numbers can be created using the imaginary unit i, which is defined
as i^2 = -1. Complex numbers have a real and complex part, which can be
retrieved using the functions re and im.

const parser = math.parser()

// create complex numbers
parser.evaluate('a = 2 + 3i')   // Complex, 2 + 3i
parser.evaluate('b = 4 - i')    // Complex, 4 - i

// get real and imaginary part of a complex number
parser.evaluate('re(a)')        // Number,  2
parser.evaluate('im(a)')        // Number,  3

// calculations with complex numbers
parser.evaluate('a + b')        // Complex, 6 + 2i
parser.evaluate('a * b')        // Complex, 11 + 10i
parser.evaluate('i * i')        // Number,  -1
parser.evaluate('sqrt(-4)')     // Complex, 2i


Units #

math.js supports units. Units can be used in the arithmetic operations
add, subtract, multiply, divide, and exponentiation.
Units can also be converted from one to another.
An overview of all available units can be found on the page
Units.

Units can be converted using the operator to or in.

// create a unit
math.evaluate('5.4 kg')                     // Unit, 5.4 kg

// convert a unit
math.evaluate('2 inch to cm')               // Unit, 5.08 cm
math.evaluate('20 celsius in fahrenheit')   // Unit, ~68 fahrenheit
math.evaluate('90 km/h to m/s')             // Unit, 25 m / s

// convert a unit to a number
// A second parameter with the unit for the exported number must be provided
math.evaluate('number(5 cm, mm)')           // Number, 50

// calculations with units
math.evaluate('0.5kg + 33g')                // Unit, 0.533 kg
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('12 seconds * 2')             // Unit, 24 seconds
math.evaluate('sin(45 deg)')                // Number, 0.7071067811865475
math.evaluate('9.81 m/s^2 * 5 s to mi/h')   // Unit, 109.72172512527 mi / h


Strings #

Strings are enclosed by double quotes “ or single quotes ‘. Strings can be concatenated using the
function concat (not by adding them using + like in JavaScript). Parts of
a string can be retrieved or replaced by using indexes. Strings can be converted
to a number using function number, and numbers can be converted to a string
using function string.

When setting the value of a character in a string, the character that has been
set is returned. Likewise, when a range of characters is set, that range of
characters is returned.

const parser = math.parser()

// create a string
parser.evaluate('"hello"')                        // String, "hello"

// string manipulation
parser.evaluate('a = concat("hello", " world")')  // String, "hello world"
parser.evaluate('size(a)')                        // Matrix [11]
parser.evaluate('a[1:5]')                         // String, "hello"
parser.evaluate('a[1] = "H"')                     // String, "H"
parser.evaluate('a[7:12] = "there!"')             // String, "there!"
parser.evaluate('a')                              // String, "Hello there!"

// string conversion
parser.evaluate('number("300")')                  // Number, 300
parser.evaluate('string(300)')                    // String, "300"


Strings can be used in the evaluate function, to parse expressions inside
the expression parser:

math.evaluate('evaluate("2 + 3")')  // 5


Matrices #

Matrices can be created by entering a series of values between square brackets,
elements are separated by a comma ,.
A matrix like [1, 2, 3] will create a vector, a 1-dimensional matrix with
size [3]. To create a multi-dimensional matrix, matrices can be nested into
each other. For easier creation of two-dimensional matrices, a semicolon ;
can be used to separate rows in a matrix.

// create a matrix
math.evaluate('[1, 2, 3]')                                // Matrix, size [3]
math.evaluate('[[1, 2, 3], [4, 5, 6]]')                   // Matrix, size [2, 3]
math.evaluate('[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]')     // Matrix, size [2, 2, 2]

// create a two dimensional matrix
math.evaluate('[1, 2, 3; 4, 5, 6]')                       // Matrix, size [2, 3]


Another way to create filled matrices is using the functions zeros, ones,
identity, and range.

// initialize a matrix with ones or zeros
math.evaluate('zeros(3, 2)')      // Matrix, [[0, 0], [0, 0], [0, 0]],  size [3, 2]
math.evaluate('ones(3)')          // Matrix, [1, 1, 1],                 size [3]
math.evaluate('5 * ones(2, 2)')   // Matrix, [[5, 5], [5, 5]],          size [2, 2]

// create an identity matrix
math.evaluate('identity(2)')      // Matrix, [[1, 0], [0, 1]],          size [2, 2]

// create a range
math.evaluate('1:4')              // Matrix, [1, 2, 3, 4],              size [4]
math.evaluate('0:2:10')           // Matrix, [0, 2, 4, 6, 8, 10],       size [6]


A subset can be retrieved from a matrix using indexes and a subset of a matrix
can be replaced by using indexes. Indexes are enclosed in square brackets, and
contain a number or a range for each of the matrix dimensions. A range can have
its start and/or end undefined. When the start is undefined, the range will start
at 1, when the end is undefined, the range will end at the end of the matrix.

There is a context variable end available as well to denote the end of the
matrix. This variable cannot be used in multiple nested indices. In that case,
end will be resolved as the end of the innermost matrix. To solve this, 
resolving of the nested index needs to be split in two separate operations.

IMPORTANT: matrix indexes and ranges work differently from the math.js indexes
in JavaScript: They are one-based with an included upper-bound, similar to most
math applications.

parser = math.parser()

// create matrices
parser.evaluate('a = [1, 2; 3, 4]')       // Matrix, [[1, 2], [3, 4]]
parser.evaluate('b = zeros(2, 2)')        // Matrix, [[0, 0], [0, 0]]
parser.evaluate('c = 5:9')                // Matrix, [5, 6, 7, 8, 9]

// replace a subset in a matrix
parser.evaluate('b[1, 1:2] = [5, 6]')     // Matrix, [[5, 6], [0, 0]]
parser.evaluate('b[2, :] = [7, 8]')       // Matrix, [[5, 6], [7, 8]]

// perform a matrix calculation
parser.evaluate('d = a * b')              // Matrix, [[19, 22], [43, 50]]

// retrieve a subset of a matrix
parser.evaluate('d[2, 1]')                // 43
parser.evaluate('d[2, 1:end]')            // Matrix, [[43, 50]]
parser.evaluate('c[end - 1 : -1 : 2]')    // Matrix, [8, 7, 6]


Objects #

Objects in math.js work the same as in languages like JavaScript and Python.
An object is enclosed by curly brackets {, }, and contains a set of
comma separated key/value pairs. Keys and values are separated by a colon :.
Keys can be a symbol like prop or a string like "prop".

math.evaluate('{a: 2 + 1, b: 4}')         // {a: 3, b: 4}
math.evaluate('{"a": 2 + 1, "b": 4}')     // {a: 3, b: 4}


Objects can contain objects:

math.evaluate('{a: 2, b: {c: 3, d: 4}}')  // {a: 2, b: {c: 3, d: 4}}


Object properties can be retrieved or replaced using dot notation or bracket
notation. Unlike JavaScript, when setting a property value, the whole object
is returned, not the property value

let scope = {
  obj: {
    prop: 42
  }
}

// retrieve properties
math.evaluate('obj.prop', scope)          // 42
math.evaluate('obj["prop"]', scope)       // 42

// set properties (returns the whole object, not the property value!)
math.evaluate('obj.prop = 43', scope)     // {prop: 43}
math.evaluate('obj["prop"] = 43', scope)  // {prop: 43}
scope.obj                                 // {prop: 43}


Multi-line expressions #

An expression can contain multiple lines, and expressions can be spread over
multiple lines. Lines can be separated by a newline character \n or by a
semicolon ;. Output of statements followed by a semicolon will be hidden from
the output, and empty lines are ignored. The output is returned as a ResultSet,
with an entry for every visible statement.

// a multi-line expression
math.evaluate('1 * 3 \n 2 * 3 \n 3 * 3')    // ResultSet, [3, 6, 9]

// semicolon statements are hidden from the output
math.evaluate('a=3; b=4; a + b \n a * b')   // ResultSet, [7, 12]

// single expression spread over multiple lines
math.evaluate('a = 2 +\n  3')               // 5
math.evaluate('[\n  1, 2;\n  3, 4\n]')      // Matrix, [[1, 2], [3, 4]]


The results can be read from a ResultSet via the property ResultSet.entries
which is an Array, or by calling ResultSet.valueOf(), which returns the
array with results.

Implicit multiplication #

Implicit multiplication means the multiplication of two symbols, numbers, or a grouped expression inside parentheses without using the * operator. This type of syntax allows a more natural way to enter expressions. For example:

math.evaluate('2 pi')         // 6.283185307179586
math.evaluate('(1+2)(3+4)')   // 21


Parentheses are parsed as a function call when there is a symbol or accessor on
the left hand side, like sqrt(4) or obj.method(4). In other cases the
parentheses are interpreted as an implicit multiplication.

Math.js will always evaluate implicit multiplication before explicit multiplication *, so that the expression x * y z is parsed as x * (y * z). Math.js also gives implicit multiplication higher precedence than division, except when the division matches the pattern [unaryPrefixOp]?[number] / [number] [symbol] or [unaryPrefixOp]?[number] / [number] [left paren]. In that special case, the division is evaluated first:

math.evaluate('20 kg / 4 kg')   // 5      Evaluated as (20 kg) / (4 kg)
math.evaluate('20 / 4 kg')      // 5 kg   Evaluated as (20 / 4) kg


The behavior of implicit multiplication can be summarized by these operator precedence rules, listed from highest to lowest precedence:


  Function calls: [symbol] [left paren]
  Explicit division / when the division matches this pattern: [+-~]?[number] / [+-~]?[number] [symbol] or [number] / [number] [left paren]
  Implicit multiplication
  All other division / and multiplication *


Implicit multiplication is tricky as there can appear to be ambiguity in how an expression will be evaluated. Experience has shown that the above rules most closely match user intent when entering expressions that could be interpreted different ways. It’s also possible that these rules could be tweaked in future major releases.  Use implicit multiplication carefully. If you don’t like the uncertainty introduced by implicit multiplication, use explicit * operators and parentheses to ensure your expression is evaluated the way you intend.

Here are some more examples using implicit multiplication:


  
    
      Expression
      Evaluated as
      Result
    
  
  
    
      (1 + 3) pi
      (1 + 3) * pi
      12.566370614359172
    
    
      (4 - 1) 2
      (4 - 1) * 2
      6
    
    
      3 / 4 mm
      (3 / 4) * mm
      0.75 mm
    
    
      2 + 3 i
      2 + (3 * i)
      2 + 3i
    
    
      (1 + 2) (4 - 2)
      (1 + 2) * (4 - 2)
      6
    
    
      sqrt(4) (1 + 2)
      sqrt(4) * (1 + 2)
      6
    
    
      8 pi / 2 pi
      (8 * pi) / (2 * pi)
      4
    
    
      pi / 2 pi
      pi / (2 * pi)
      0.5
    
    
      1 / 2i
      (1 / 2) * i
      0.5 i
    
    
      8.314 J / mol K
      8.314 J / (mol * K)
      8.314 J / (mol * K)
    
  


Comments #

Comments can be added to explain or describe calculations in the text. A comment
starts with a sharp sign character #, and ends at the end of the line. A line
can contain a comment only, or can contain an expression followed by a comment.

const parser = math.parser()

parser.evaluate('# define some variables')
parser.evaluate('width = 3')                              // 3
parser.evaluate('height = 4')                             // 4
parser.evaluate('width * height   # calculate the area')  // 12\n\n\n\nExpression syntax #

This page describes the syntax of expression parser of math.js. It describes
how to work with the available data types, functions, operators, variables,
and more.

Differences from JavaScript #

The expression parser of math.js is aimed at a mathematical audience,
not a programming audience. The syntax is similar to most calculators and
mathematical applications. This is close to JavaScript as well, though there
are a few important differences between the syntax of the expression parser and
the lower level syntax of math.js. Differences are:


  No need to prefix functions and constants with the math.* namespace,
you can just enter sin(pi / 4).
  Matrix indexes are one-based instead of zero-based.
  There are index and range operators which allow more conveniently getting
and setting matrix indexes, like A[2:4, 1].
  Both indexes and ranges and have the upper-bound included.
  There is a differing syntax for defining functions. Example: f(x) = x^2.
  There are custom operators like x + y instead of add(x, y).
  Some operators are different. For example  ^ is used for exponentiation,
not bitwise xor.
  Implicit multiplication, like 2 pi, is supported and has special rules.
  Relational operators (<, >, <=, >=, ==, and !=) are chained, so the expression 5 < x < 10 is equivalent to 5 < x and x < 10.
  Multi-expression constructs like a = 1; b = 2; a + b or
"a = 1;\n cos(a)\n sin(a)" (where \n denotes newline)
produce a collection (“ResultSet”) of values. Those expressions
terminated by ; are evaluated for side effect only and their values
are suppressed from the result.


Operators #

The expression parser has operators for all common arithmetic operations such
as addition and multiplication. The expression parser uses conventional infix
notation for operators: an operator is placed between its arguments.
Round parentheses can be used to override the default precedence of operators.

// use operators
math.evaluate('2 + 3')       // 5
math.evaluate('2 * 3')       // 6

// use parentheses to override the default precedence
math.evaluate('2 + 3 * 4')   // 14
math.evaluate('(2 + 3) * 4') // 20


The following operators are available. Note that almost every operator listed
also has a function form with identical meaning that can be used
interchangeably. For example, x+y will always evaluate identically to
add(x,y). For a full list of the equivalences, see the section on
Functions below.


  
    
      Operator
      Name
      Syntax
      Associativity
      Example
      Result
    
  
  
    
      (, )
      Grouping
      (x)
      None
      2 * (3 + 4)
      14
    
    
      [, ]
      Matrix, Index
      [...]
      None
      [[1,2],[3,4]]
      [[1,2],[3,4]]
    
    
      {, }
      Object
      {...}
      None
      {a: 1, b: 2}
      {a: 1, b: 2}
    
    
      ,
      Parameter separator
      x, y
      Left to right
      max(2, 1, 5)
      5
    
    
      .
      Property accessor
      obj.prop
      Left to right
      obj={a: 12}; obj.a
      12
    
    
      ;
      Statement separator
      x; y
      Left to right
      a=2; b=3; a*b
      [6]
    
    
      ;
      Row separator
      [x; y]
      Left to right
      [1,2;3,4]
      [[1,2],[3,4]]
    
    
      \n
      Statement separator
      x \n y
      Left to right
      a=2 \n b=3 \n a*b
      [2,3,6]
    
    
      +
      Add
      x + y
      Left to right
      4 + 5
      9
    
    
      +
      Unary plus
      +y
      Right to left
      +4
      4
    
    
      -
      Subtract
      x - y
      Left to right
      7 - 3
      4
    
    
      -
      Unary minus
      -y
      Right to left
      -4
      -4
    
    
      *
      Multiply
      x * y
      Left to right
      2 * 3
      6
    
    
      .*
      Element-wise multiply
      x .* y
      Left to right
      [1,2,3] .* [1,2,3]
      [1,4,9]
    
    
      /
      Divide
      x / y
      Left to right
      6 / 2
      3
    
    
      ./
      Element-wise divide
      x ./ y
      Left to right
      [9,6,4] ./ [3,2,2]
      [3,3,2]
    
    
      %
      Percentage
      x%
      None
      8%
      0.08
    
    
      %
      Addition with Percentage
      x + y%
      Left to right
      100 + 3%
      103
    
    
      %
      Subtraction with Percentage
      x - y%
      Left to right
      100 - 3%
      97
    
    
      % mod
      Modulus
      x % y
      Left to right
      8 % 3
      2
    
    
      ^
      Power
      x ^ y
      Right to left
      2 ^ 3
      8
    
    
      .^
      Element-wise power
      x .^ y
      Right to left
      [2,3] .^ [3,3]
      [8,27]
    
    
      '
      Transpose
      y'
      Left to right
      [[1,2],[3,4]]'
      [[1,3],[2,4]]
    
    
      !
      Factorial
      y!
      Left to right
      5!
      120
    
    
      &
      Bitwise and
      x & y
      Left to right
      5 & 3
      1
    
    
      ~
      Bitwise not
      ~x
      Right to left
      ~2
      -3
    
    
      |
      Bitwise or
      x | y
      Left to right
      5 | 3
      7
    
    
      ^|
      Bitwise xor
      x ^| y
      Left to right
      5 ^| 2
      7
    
    
      <<
      Left shift
      x << y
      Left to right
      4 << 1
      8
    
    
      >>
      Right arithmetic shift
      x >> y
      Left to right
      8 >> 1
      4
    
    
      >>>
      Right logical shift
      x >>> y
      Left to right
      -8 >>> 1
      2147483644
    
    
      and
      Logical and
      x and y
      Left to right
      true and false
      false
    
    
      not
      Logical not
      not y
      Right to left
      not true
      false
    
    
      or
      Logical or
      x or y
      Left to right
      true or false
      true
    
    
      xor
      Logical xor
      x xor y
      Left to right
      true xor true
      false
    
    
      =
      Assignment
      x = y
      Right to left
      a = 5
      5
    
    
      ? :
      Conditional expression
      x ? y : z
      Right to left
      15 > 100 ? 1 : -1
      -1
    
    
      :
      Range
      x : y
      Right to left
      1:4
      [1,2,3,4]
    
    
      to, in
      Unit conversion
      x to y
      Left to right
      2 inch to cm
      5.08 cm
    
    
      ==
      Equal
      x == y
      Left to right
      2 == 4 - 2
      true
    
    
      !=
      Unequal
      x != y
      Left to right
      2 != 3
      true
    
    
      <
      Smaller
      x < y
      Left to right
      2 < 3
      true
    
    
      >
      Larger
      x > y
      Left to right
      2 > 3
      false
    
    
      <=
      Smallereq
      x <= y
      Left to right
      4 <= 3
      false
    
    
      >=
      Largereq
      x >= y
      Left to right
      2 + 4 >= 6
      true
    
  


Precedence #

The operators have the following precedence, from highest to lowest:


  
    
      Operators
      Description
    
  
  
    
      (...)[...]{...}
      GroupingMatrixObject
    
    
      x(...)x[...]obj.prop:
      Function callMatrix indexProperty accessorKey/value separator
    
    
      '
      Matrix transpose
    
    
      !
      Factorial
    
    
      ^, .^
      Exponentiation
    
    
      +, -, ~, not
      Unary plus, unary minus, bitwise not, logical not
    
    
      See section below
      Implicit multiplication
    
    
      *, /, .*, ./,%, mod
      Multiply, divide , percentage, modulus
    
    
      +, -
      Add, subtract
    
    
      :
      Range
    
    
      to, in
      Unit conversion
    
    
      <<, >>, >>>
      Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift
    
    
      ==, !=, <, >, <=, >=
      Relational
    
    
      &
      Bitwise and (lazily evaluated)
    
    
      ^|
      Bitwise xor
    
    
      |
      Bitwise or (lazily evaluated)
    
    
      and
      Logical and (lazily evaluated)
    
    
      xor
      Logical xor
    
    
      or
      Logical or (lazily evaluated)
    
    
      ?, :
      Conditional expression
    
    
      =
      Assignment
    
    
      ,
      Parameter and column separator
    
    
      ;
      Row separator
    
    
      \n, ;
      Statement separators
    
  


Lazy evaluation is used where logically possible for bitwise and logical
operators. In the following example, the value of x will not even be 
evaluated because it cannot effect the final result:
math.evaluate('false and x')        // false, no matter what x equals


Functions #

Functions are called by entering their name, followed by zero or more
arguments enclosed by parentheses. All available functions are listed on the
page Functions.

math.evaluate('sqrt(25)')           // 5
math.evaluate('log(10000, 3 + 7)')  // 4
math.evaluate('sin(pi / 4)')        // 0.7071067811865475


New functions can be defined by “assigning” an expression to a function call
with one or more variables. Such function assignments are limited: they can
only be defined on a single line.

const parser = math.parser()

parser.evaluate('f(x) = x ^ 2 - 5')
parser.evaluate('f(2)')     // -1
parser.evaluate('f(3)')     // 4

parser.evaluate('g(x, y) = x ^ y')
parser.evaluate('g(2, 3)')  // 8


Note that these function assignments do not create closures; put another way,
all free variables in mathjs are dynamic:

const parser = math.parser()

parser.evaluate('x = 7')
parser.evaluate('h(y) = x + y')
parser.evaluate('h(3)')         // 10
parser.evaluate('x = 3')
parser.evaluate('h(3)')         // 6, *not* 10


It is however possible to pass functions as parameters:

const parser = math.parser()

parser.evaluate('twice(func, x) = func(func(x))')
parser.evaluate('twice(square, 2)')    // 16
parser.evaluate('f(x) = 3*x')
parser.evaluate('twice(f, 2)')         // 18

// a simplistic "numerical derivative":
parser.evaluate('eps = 1e-10')
parser.evaluate('nd(f, x) = (f(x+eps) - func(x-eps))/(2*eps)')
parser.evaluate('nd(square,2)')        // 4.000000330961484


Math.js itself heavily uses typed functions, which ensure correct inputs and
throws meaningful errors when the input arguments are invalid. One can create
a typed-function in the
expression parser like:

const parser = math.parser()

parser.evaluate('f = typed({"number": f(x) = x ^ 2 - 5})')


Finally, as mentioned above, there is a function form for nearly every one of
the mathematical operator symbols. Moreover, for some associative operators,
the corresponding function allows arbitrarily many arguments. The table below
gives the full correspondence.


  
    
      Operator Expression
      Equivalent Function Expression
    
  
  
    
      a or b
      or(a,b)
    
    
      a xor b
      xor(a,b)
    
    
      a and b
      and(a,b)
    
    
      a \| b
      bitOr(a,b)
    
    
      a ^\| b
      bitXor(a,b)
    
    
      a & b
      bitAnd(a,b)
    
    
      a == b
      equal(a,b)
    
    
      a != b
      unequal(a,b)
    
    
      a < b
      smaller(a,b)
    
    
      a > b
      larger(a,b)
    
    
      a <= b
      smallerEq(a,b)
    
    
      a << 3
      leftShift(a,3)
    
    
      a >> 3
      rightArithShift(a,3)
    
    
      a >>> 3
      rightLogShift(a,3)
    
    
      u to cm
      to(u, cm)
    
    
      a + b + c + ...
      add(a,b,c,...)
    
    
      a - b
      subtract(a,b)
    
    
      a * b * c * ...
      multiply(a,b,c,...)
    
    
      A .* B
      dotMultiply(A,B)
    
    
      A ./ B
      dotDivide(A,B)
    
    
      a mod b
      mod(a,b)
    
    
      +a
      unaryPlus(a)
    
    
      -a
      unaryMinus(a)
    
    
      ~a
      bitNot(a)
    
    
      not a
      not(a)
    
    
      a^b
      pow(a,b)
    
    
      A .^ B
      dotPow(A,B)
    
    
      a!
      factorial(a)
    
    
      A'
      ctranspose(A)
    
  


Note that math.js embodies a preference for the operator forms, in that calling
simplify (see Algebra) converts any instances of the function
form into the corresponding operator.

Map and forEach #

The map and forEach functions can be used to apply a callback function to each element of an array or matrix.

The callback functions can be functions, typed functions, inline functions (only in the parser) or compiled inline functions (only in the parser).

The callback can have the following inputs:

  value: the current value in the array or matrix.
  index: the index of the current value expressed as an array of numbers.
  array: the array or matrix being iterated.


Below is the syntax for both functions:

map #

The map function applies a function to each element of an array and returns a new array with the results.

const parser = math.parser()

// Define a square function
parser.evaluate('square(x) = x ^ 2')

// Apply the square function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], square)')
// result: [1, 4, 9, 16]

// Apply an inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], f(x) = x ^ 2)')
// result: [1, 4, 9, 16]

// Apply a compiled inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], x ^ 2)')
// result: [1, 4, 9, 16]


forEach #
The forEach function applies a function to each element of an array or matrix but does not return a new array. It is useful for executing side effects.

// Define a function that prints each element
math.import({consoleLog: x => console.log(x)})
const parser = math.parser()

// Define a squareConsleLog function
parser.evaluate('squareConsoleLog(x) = consoleLog(x ^ 2)')

// Apply the squareConsleLog function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], squareConsleLog)')
// Prints: 1, 4, 9, 16

// Apply an inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], f(x) = consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16

// Apply a compiled inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16


These functions are useful for performing element-wise operations on arrays or matrices.

Constants and variables #

Math.js has a number of built-in constants such as pi and e.
All available constants are listed on he page
Constants.

// use constants
math.evaluate('pi')                 // 3.141592653589793
math.evaluate('e ^ 2')              // 7.3890560989306495
math.evaluate('log(e)')             // 1
math.evaluate('e ^ (pi * i) + 1')   // ~0 (Euler)


Variables can be defined using the assignment operator =, and can be used
like constants.

const parser = math.parser()

// define variables
parser.evaluate('a = 3.4')      // 3.4
parser.evaluate('b = 5 / 2')    // 2.5

// use variables
parser.evaluate('a * b')        // 8.5


Variable names must:


  Begin with an “alpha character”, which is:
    
      A latin letter (upper or lower case). Ascii: a-z, A-Z
      An underscore.                        Ascii: _
      A dollar sign.                        Ascii: $
      A latin letter with accents.          Unicode: \u00C0 - \u02AF
      A greek letter.                       Unicode: \u0370 - \u03FF
      A letter-like character.              Unicode: \u2100 - \u214F
      A mathematical alphanumeric symbol.   Unicode: \u{1D400} - \u{1D7FF} excluding invalid code points
    
  
  Contain only alpha characters (above) and digits 0-9
  Not be any of the following: mod, to, in, and, xor, or, not, end. It is possible to assign to some of these, but that’s not recommended.


It is possible to customize the allowed alpha characters, see Customize supported characters for more information.

Data types #

The expression parser supports booleans, numbers, complex numbers, units,
strings, matrices, and objects.

Booleans #

Booleans true and false can be used in expressions.

// use booleans
math.evaluate('true')               // true
math.evaluate('false')              // false
math.evaluate('(2 == 3) == false')  // true


Booleans can be converted to numbers and strings and vice versa using the
functions number and boolean, and string.

// convert booleans
math.evaluate('number(true)')       // 1
math.evaluate('string(false)')      // "false"
math.evaluate('boolean(1)')         // true
math.evaluate('boolean("false")')   // false


Numbers #

The most important and basic data type in math.js are numbers. Numbers use a
point as decimal mark. Numbers can be entered with exponential notation.
Examples:

// numbers in math.js
math.evaluate('2')        // 2
math.evaluate('3.14')     // 3.14
math.evaluate('1.4e3')    // 1400
math.evaluate('22e-3')    // 0.022


A number can be converted to a string and vice versa using the functions
number and string.

// convert a string into a number
math.evaluate('number("2.3")')    // 2.3
math.evaluate('string(2.3)')      // "2.3"


Math.js uses regular JavaScript numbers, which are floating points with a
limited precision and limited range. The limitations are described in detail
on the page Numbers.

math.evaluate('1e-325')   // 0
math.evaluate('1e309')    // Infinity
math.evaluate('-1e309')   // -Infinity


When doing calculations with floats, one can very easily get round-off errors:

// round-off error due to limited floating point precision
math.evaluate('0.1 + 0.2')  // 0.30000000000000004


When outputting results, the function math.format can be used to hide
these round-off errors when outputting results for the user:

const ans = math.evaluate('0.1 + 0.2')  //  0.30000000000000004
math.format(ans, {precision: 14})       // "0.3"


Numbers can be expressed as binary, octal, and hexadecimal literals:

math.evaluate('0b11')  //  3
math.evaluate('0o77')  //  63
math.evaluate('0xff')  //  255


A word size suffix can be used to change the behavior of non decimal literal evaluation:

math.evaluate('0xffi8')         // -1
math.evaluate('0xffffffffi32')  //  -1
math.evaluate('0xfffffffffi32') //  SyntaxError: String "0xfffffffff" is out of range


Non decimal numbers can include a radix point:
math.evaluate('0b1.1')         // 1.5
math.evaluate('0o1.4')         // 1.5
math.evaluate('0x1.8')         // 1.5


Numbers can be formatted as binary, octal, and hex strings using the notation option of the format function:

math.evaluate('format(3, {notation: "bin"})')    //  '0b11'
math.evaluate('format(63, {notation: "oct"})')   //  '0o77'
math.evaluate('format(255, {notation: "hex"})')  //  '0xff'
math.evaluate('format(-1, {notation: "hex"})')   //  '-0x1'
math.evaluate('format(2.3, {notation: "hex"})')  //  '0x2.4cccccccccccc'


The format function accepts a wordSize option to use in conjunction with the non binary notations:

math.evaluate('format(-1, {notation: "hex", wordSize: 8})')   //  '0xffi8'


The functions bin, oct, and hex are shorthand for the format function with notation set accordingly:

math.evaluate('bin(-1)')     // '-0b1'
math.evaluate('bin(-1, 8)')  // '0b11111111i8'


BigNumbers #

Math.js supports BigNumbers for calculations with an arbitrary precision.
The pros and cons of Number and BigNumber are explained in detail on the page
Numbers.

BigNumbers are slower but have a higher precision. Calculations with big
numbers are supported only by arithmetic functions.

BigNumbers can be created using the bignumber function:

math.evaluate('bignumber(0.1) + bignumber(0.2)') // BigNumber, 0.3


The default number type of the expression parser can be changed at instantiation
of math.js. The expression parser parses numbers as BigNumber by default:

// Configure the type of number: 'number' (default), 'BigNumber', or 'Fraction'
math.config({number: 'BigNumber'})

// all numbers are parsed as BigNumber
math.evaluate('0.1 + 0.2')  // BigNumber, 0.3


BigNumbers can be converted to numbers and vice versa using the functions
number and bignumber. When converting a BigNumber to a Number, the high
precision of the BigNumber will be lost. When a BigNumber is too large to be represented
as Number, it will be initialized as Infinity.

Complex numbers #

Complex numbers can be created using the imaginary unit i, which is defined
as i^2 = -1. Complex numbers have a real and complex part, which can be
retrieved using the functions re and im.

const parser = math.parser()

// create complex numbers
parser.evaluate('a = 2 + 3i')   // Complex, 2 + 3i
parser.evaluate('b = 4 - i')    // Complex, 4 - i

// get real and imaginary part of a complex number
parser.evaluate('re(a)')        // Number,  2
parser.evaluate('im(a)')        // Number,  3

// calculations with complex numbers
parser.evaluate('a + b')        // Complex, 6 + 2i
parser.evaluate('a * b')        // Complex, 11 + 10i
parser.evaluate('i * i')        // Number,  -1
parser.evaluate('sqrt(-4)')     // Complex, 2i


Units #

math.js supports units. Units can be used in the arithmetic operations
add, subtract, multiply, divide, and exponentiation.
Units can also be converted from one to another.
An overview of all available units can be found on the page
Units.

Units can be converted using the operator to or in.

// create a unit
math.evaluate('5.4 kg')                     // Unit, 5.4 kg

// convert a unit
math.evaluate('2 inch to cm')               // Unit, 5.08 cm
math.evaluate('20 celsius in fahrenheit')   // Unit, ~68 fahrenheit
math.evaluate('90 km/h to m/s')             // Unit, 25 m / s

// convert a unit to a number
// A second parameter with the unit for the exported number must be provided
math.evaluate('number(5 cm, mm)')           // Number, 50

// calculations with units
math.evaluate('0.5kg + 33g')                // Unit, 0.533 kg
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('12 seconds * 2')             // Unit, 24 seconds
math.evaluate('sin(45 deg)')                // Number, 0.7071067811865475
math.evaluate('9.81 m/s^2 * 5 s to mi/h')   // Unit, 109.72172512527 mi / h


Strings #

Strings are enclosed by double quotes “ or single quotes ‘. Strings can be concatenated using the
function concat (not by adding them using + like in JavaScript). Parts of
a string can be retrieved or replaced by using indexes. Strings can be converted
to a number using function number, and numbers can be converted to a string
using function string.

When setting the value of a character in a string, the character that has been
set is returned. Likewise, when a range of characters is set, that range of
characters is returned.

const parser = math.parser()

// create a string
parser.evaluate('"hello"')                        // String, "hello"

// string manipulation
parser.evaluate('a = concat("hello", " world")')  // String, "hello world"
parser.evaluate('size(a)')                        // Matrix [11]
parser.evaluate('a[1:5]')                         // String, "hello"
parser.evaluate('a[1] = "H"')                     // String, "H"
parser.evaluate('a[7:12] = "there!"')             // String, "there!"
parser.evaluate('a')                              // String, "Hello there!"

// string conversion
parser.evaluate('number("300")')                  // Number, 300
parser.evaluate('string(300)')                    // String, "300"


Strings can be used in the evaluate function, to parse expressions inside
the expression parser:

math.evaluate('evaluate("2 + 3")')  // 5


Matrices #

Matrices can be created by entering a series of values between square brackets,
elements are separated by a comma ,.
A matrix like [1, 2, 3] will create a vector, a 1-dimensional matrix with
size [3]. To create a multi-dimensional matrix, matrices can be nested into
each other. For easier creation of two-dimensional matrices, a semicolon ;
can be used to separate rows in a matrix.

// create a matrix
math.evaluate('[1, 2, 3]')                                // Matrix, size [3]
math.evaluate('[[1, 2, 3], [4, 5, 6]]')                   // Matrix, size [2, 3]
math.evaluate('[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]')     // Matrix, size [2, 2, 2]

// create a two dimensional matrix
math.evaluate('[1, 2, 3; 4, 5, 6]')                       // Matrix, size [2, 3]


Another way to create filled matrices is using the functions zeros, ones,
identity, and range.

// initialize a matrix with ones or zeros
math.evaluate('zeros(3, 2)')      // Matrix, [[0, 0], [0, 0], [0, 0]],  size [3, 2]
math.evaluate('ones(3)')          // Matrix, [1, 1, 1],                 size [3]
math.evaluate('5 * ones(2, 2)')   // Matrix, [[5, 5], [5, 5]],          size [2, 2]

// create an identity matrix
math.evaluate('identity(2)')      // Matrix, [[1, 0], [0, 1]],          size [2, 2]

// create a range
math.evaluate('1:4')              // Matrix, [1, 2, 3, 4],              size [4]
math.evaluate('0:2:10')           // Matrix, [0, 2, 4, 6, 8, 10],       size [6]


A subset can be retrieved from a matrix using indexes and a subset of a matrix
can be replaced by using indexes. Indexes are enclosed in square brackets, and
contain a number or a range for each of the matrix dimensions. A range can have
its start and/or end undefined. When the start is undefined, the range will start
at 1, when the end is undefined, the range will end at the end of the matrix.

There is a context variable end available as well to denote the end of the
matrix. This variable cannot be used in multiple nested indices. In that case,
end will be resolved as the end of the innermost matrix. To solve this, 
resolving of the nested index needs to be split in two separate operations.

IMPORTANT: matrix indexes and ranges work differently from the math.js indexes
in JavaScript: They are one-based with an included upper-bound, similar to most
math applications.

parser = math.parser()

// create matrices
parser.evaluate('a = [1, 2; 3, 4]')       // Matrix, [[1, 2], [3, 4]]
parser.evaluate('b = zeros(2, 2)')        // Matrix, [[0, 0], [0, 0]]
parser.evaluate('c = 5:9')                // Matrix, [5, 6, 7, 8, 9]

// replace a subset in a matrix
parser.evaluate('b[1, 1:2] = [5, 6]')     // Matrix, [[5, 6], [0, 0]]
parser.evaluate('b[2, :] = [7, 8]')       // Matrix, [[5, 6], [7, 8]]

// perform a matrix calculation
parser.evaluate('d = a * b')              // Matrix, [[19, 22], [43, 50]]

// retrieve a subset of a matrix
parser.evaluate('d[2, 1]')                // 43
parser.evaluate('d[2, 1:end]')            // Matrix, [[43, 50]]
parser.evaluate('c[end - 1 : -1 : 2]')    // Matrix, [8, 7, 6]


Objects #

Objects in math.js work the same as in languages like JavaScript and Python.
An object is enclosed by curly brackets {, }, and contains a set of
comma separated key/value pairs. Keys and values are separated by a colon :.
Keys can be a symbol like prop or a string like "prop".

math.evaluate('{a: 2 + 1, b: 4}')         // {a: 3, b: 4}
math.evaluate('{"a": 2 + 1, "b": 4}')     // {a: 3, b: 4}


Objects can contain objects:

math.evaluate('{a: 2, b: {c: 3, d: 4}}')  // {a: 2, b: {c: 3, d: 4}}


Object properties can be retrieved or replaced using dot notation or bracket
notation. Unlike JavaScript, when setting a property value, the whole object
is returned, not the property value

let scope = {
  obj: {
    prop: 42
  }
}

// retrieve properties
math.evaluate('obj.prop', scope)          // 42
math.evaluate('obj["prop"]', scope)       // 42

// set properties (returns the whole object, not the property value!)
math.evaluate('obj.prop = 43', scope)     // {prop: 43}
math.evaluate('obj["prop"] = 43', scope)  // {prop: 43}
scope.obj                                 // {prop: 43}


Multi-line expressions #

An expression can contain multiple lines, and expressions can be spread over
multiple lines. Lines can be separated by a newline character \n or by a
semicolon ;. Output of statements followed by a semicolon will be hidden from
the output, and empty lines are ignored. The output is returned as a ResultSet,
with an entry for every visible statement.

// a multi-line expression
math.evaluate('1 * 3 \n 2 * 3 \n 3 * 3')    // ResultSet, [3, 6, 9]

// semicolon statements are hidden from the output
math.evaluate('a=3; b=4; a + b \n a * b')   // ResultSet, [7, 12]

// single expression spread over multiple lines
math.evaluate('a = 2 +\n  3')               // 5
math.evaluate('[\n  1, 2;\n  3, 4\n]')      // Matrix, [[1, 2], [3, 4]]


The results can be read from a ResultSet via the property ResultSet.entries
which is an Array, or by calling ResultSet.valueOf(), which returns the
array with results.

Implicit multiplication #

Implicit multiplication means the multiplication of two symbols, numbers, or a grouped expression inside parentheses without using the * operator. This type of syntax allows a more natural way to enter expressions. For example:

math.evaluate('2 pi')         // 6.283185307179586
math.evaluate('(1+2)(3+4)')   // 21


Parentheses are parsed as a function call when there is a symbol or accessor on
the left hand side, like sqrt(4) or obj.method(4). In other cases the
parentheses are interpreted as an implicit multiplication.

Math.js will always evaluate implicit multiplication before explicit multiplication *, so that the expression x * y z is parsed as x * (y * z). Math.js also gives implicit multiplication higher precedence than division, except when the division matches the pattern [unaryPrefixOp]?[number] / [number] [symbol] or [unaryPrefixOp]?[number] / [number] [left paren]. In that special case, the division is evaluated first:

math.evaluate('20 kg / 4 kg')   // 5      Evaluated as (20 kg) / (4 kg)
math.evaluate('20 / 4 kg')      // 5 kg   Evaluated as (20 / 4) kg


The behavior of implicit multiplication can be summarized by these operator precedence rules, listed from highest to lowest precedence:


  Function calls: [symbol] [left paren]
  Explicit division / when the division matches this pattern: [+-~]?[number] / [+-~]?[number] [symbol] or [number] / [number] [left paren]
  Implicit multiplication
  All other division / and multiplication *


Implicit multiplication is tricky as there can appear to be ambiguity in how an expression will be evaluated. Experience has shown that the above rules most closely match user intent when entering expressions that could be interpreted different ways. It’s also possible that these rules could be tweaked in future major releases.  Use implicit multiplication carefully. If you don’t like the uncertainty introduced by implicit multiplication, use explicit * operators and parentheses to ensure your expression is evaluated the way you intend.

Here are some more examples using implicit multiplication:


  
    
      Expression
      Evaluated as
      Result
    
  
  
    
      (1 + 3) pi
      (1 + 3) * pi
      12.566370614359172
    
    
      (4 - 1) 2
      (4 - 1) * 2
      6
    
    
      3 / 4 mm
      (3 / 4) * mm
      0.75 mm
    
    
      2 + 3 i
      2 + (3 * i)
      2 + 3i
    
    
      (1 + 2) (4 - 2)
      (1 + 2) * (4 - 2)
      6
    
    
      sqrt(4) (1 + 2)
      sqrt(4) * (1 + 2)
      6
    
    
      8 pi / 2 pi
      (8 * pi) / (2 * pi)
      4
    
    
      pi / 2 pi
      pi / (2 * pi)
      0.5
    
    
      1 / 2i
      (1 / 2) * i
      0.5 i
    
    
      8.314 J / mol K
      8.314 J / (mol * K)
      8.314 J / (mol * K)
    
  


Comments #

Comments can be added to explain or describe calculations in the text. A comment
starts with a sharp sign character #, and ends at the end of the line. A line
can contain a comment only, or can contain an expression followed by a comment.

const parser = math.parser()

parser.evaluate('# define some variables')
parser.evaluate('width = 3')                              // 3
parser.evaluate('height = 4')                             // 4
parser.evaluate('width * height   # calculate the area')  // 12\n\n\n\nExpression syntax #

This page describes the syntax of expression parser of math.js. It describes
how to work with the available data types, functions, operators, variables,
and more.

Differences from JavaScript #

The expression parser of math.js is aimed at a mathematical audience,
not a programming audience. The syntax is similar to most calculators and
mathematical applications. This is close to JavaScript as well, though there
are a few important differences between the syntax of the expression parser and
the lower level syntax of math.js. Differences are:


  No need to prefix functions and constants with the math.* namespace,
you can just enter sin(pi / 4).
  Matrix indexes are one-based instead of zero-based.
  There are index and range operators which allow more conveniently getting
and setting matrix indexes, like A[2:4, 1].
  Both indexes and ranges and have the upper-bound included.
  There is a differing syntax for defining functions. Example: f(x) = x^2.
  There are custom operators like x + y instead of add(x, y).
  Some operators are different. For example  ^ is used for exponentiation,
not bitwise xor.
  Implicit multiplication, like 2 pi, is supported and has special rules.
  Relational operators (<, >, <=, >=, ==, and !=) are chained, so the expression 5 < x < 10 is equivalent to 5 < x and x < 10.
  Multi-expression constructs like a = 1; b = 2; a + b or
"a = 1;\n cos(a)\n sin(a)" (where \n denotes newline)
produce a collection (“ResultSet”) of values. Those expressions
terminated by ; are evaluated for side effect only and their values
are suppressed from the result.


Operators #

The expression parser has operators for all common arithmetic operations such
as addition and multiplication. The expression parser uses conventional infix
notation for operators: an operator is placed between its arguments.
Round parentheses can be used to override the default precedence of operators.

// use operators
math.evaluate('2 + 3')       // 5
math.evaluate('2 * 3')       // 6

// use parentheses to override the default precedence
math.evaluate('2 + 3 * 4')   // 14
math.evaluate('(2 + 3) * 4') // 20


The following operators are available. Note that almost every operator listed
also has a function form with identical meaning that can be used
interchangeably. For example, x+y will always evaluate identically to
add(x,y). For a full list of the equivalences, see the section on
Functions below.


  
    
      Operator
      Name
      Syntax
      Associativity
      Example
      Result
    
  
  
    
      (, )
      Grouping
      (x)
      None
      2 * (3 + 4)
      14
    
    
      [, ]
      Matrix, Index
      [...]
      None
      [[1,2],[3,4]]
      [[1,2],[3,4]]
    
    
      {, }
      Object
      {...}
      None
      {a: 1, b: 2}
      {a: 1, b: 2}
    
    
      ,
      Parameter separator
      x, y
      Left to right
      max(2, 1, 5)
      5
    
    
      .
      Property accessor
      obj.prop
      Left to right
      obj={a: 12}; obj.a
      12
    
    
      ;
      Statement separator
      x; y
      Left to right
      a=2; b=3; a*b
      [6]
    
    
      ;
      Row separator
      [x; y]
      Left to right
      [1,2;3,4]
      [[1,2],[3,4]]
    
    
      \n
      Statement separator
      x \n y
      Left to right
      a=2 \n b=3 \n a*b
      [2,3,6]
    
    
      +
      Add
      x + y
      Left to right
      4 + 5
      9
    
    
      +
      Unary plus
      +y
      Right to left
      +4
      4
    
    
      -
      Subtract
      x - y
      Left to right
      7 - 3
      4
    
    
      -
      Unary minus
      -y
      Right to left
      -4
      -4
    
    
      *
      Multiply
      x * y
      Left to right
      2 * 3
      6
    
    
      .*
      Element-wise multiply
      x .* y
      Left to right
      [1,2,3] .* [1,2,3]
      [1,4,9]
    
    
      /
      Divide
      x / y
      Left to right
      6 / 2
      3
    
    
      ./
      Element-wise divide
      x ./ y
      Left to right
      [9,6,4] ./ [3,2,2]
      [3,3,2]
    
    
      %
      Percentage
      x%
      None
      8%
      0.08
    
    
      %
      Addition with Percentage
      x + y%
      Left to right
      100 + 3%
      103
    
    
      %
      Subtraction with Percentage
      x - y%
      Left to right
      100 - 3%
      97
    
    
      % mod
      Modulus
      x % y
      Left to right
      8 % 3
      2
    
    
      ^
      Power
      x ^ y
      Right to left
      2 ^ 3
      8
    
    
      .^
      Element-wise power
      x .^ y
      Right to left
      [2,3] .^ [3,3]
      [8,27]
    
    
      '
      Transpose
      y'
      Left to right
      [[1,2],[3,4]]'
      [[1,3],[2,4]]
    
    
      !
      Factorial
      y!
      Left to right
      5!
      120
    
    
      &
      Bitwise and
      x & y
      Left to right
      5 & 3
      1
    
    
      ~
      Bitwise not
      ~x
      Right to left
      ~2
      -3
    
    
      |
      Bitwise or
      x | y
      Left to right
      5 | 3
      7
    
    
      ^|
      Bitwise xor
      x ^| y
      Left to right
      5 ^| 2
      7
    
    
      <<
      Left shift
      x << y
      Left to right
      4 << 1
      8
    
    
      >>
      Right arithmetic shift
      x >> y
      Left to right
      8 >> 1
      4
    
    
      >>>
      Right logical shift
      x >>> y
      Left to right
      -8 >>> 1
      2147483644
    
    
      and
      Logical and
      x and y
      Left to right
      true and false
      false
    
    
      not
      Logical not
      not y
      Right to left
      not true
      false
    
    
      or
      Logical or
      x or y
      Left to right
      true or false
      true
    
    
      xor
      Logical xor
      x xor y
      Left to right
      true xor true
      false
    
    
      =
      Assignment
      x = y
      Right to left
      a = 5
      5
    
    
      ? :
      Conditional expression
      x ? y : z
      Right to left
      15 > 100 ? 1 : -1
      -1
    
    
      :
      Range
      x : y
      Right to left
      1:4
      [1,2,3,4]
    
    
      to, in
      Unit conversion
      x to y
      Left to right
      2 inch to cm
      5.08 cm
    
    
      ==
      Equal
      x == y
      Left to right
      2 == 4 - 2
      true
    
    
      !=
      Unequal
      x != y
      Left to right
      2 != 3
      true
    
    
      <
      Smaller
      x < y
      Left to right
      2 < 3
      true
    
    
      >
      Larger
      x > y
      Left to right
      2 > 3
      false
    
    
      <=
      Smallereq
      x <= y
      Left to right
      4 <= 3
      false
    
    
      >=
      Largereq
      x >= y
      Left to right
      2 + 4 >= 6
      true
    
  


Precedence #

The operators have the following precedence, from highest to lowest:


  
    
      Operators
      Description
    
  
  
    
      (...)[...]{...}
      GroupingMatrixObject
    
    
      x(...)x[...]obj.prop:
      Function callMatrix indexProperty accessorKey/value separator
    
    
      '
      Matrix transpose
    
    
      !
      Factorial
    
    
      ^, .^
      Exponentiation
    
    
      +, -, ~, not
      Unary plus, unary minus, bitwise not, logical not
    
    
      See section below
      Implicit multiplication
    
    
      *, /, .*, ./,%, mod
      Multiply, divide , percentage, modulus
    
    
      +, -
      Add, subtract
    
    
      :
      Range
    
    
      to, in
      Unit conversion
    
    
      <<, >>, >>>
      Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift
    
    
      ==, !=, <, >, <=, >=
      Relational
    
    
      &
      Bitwise and (lazily evaluated)
    
    
      ^|
      Bitwise xor
    
    
      |
      Bitwise or (lazily evaluated)
    
    
      and
      Logical and (lazily evaluated)
    
    
      xor
      Logical xor
    
    
      or
      Logical or (lazily evaluated)
    
    
      ?, :
      Conditional expression
    
    
      =
      Assignment
    
    
      ,
      Parameter and column separator
    
    
      ;
      Row separator
    
    
      \n, ;
      Statement separators
    
  


Lazy evaluation is used where logically possible for bitwise and logical
operators. In the following example, the value of x will not even be 
evaluated because it cannot effect the final result:
math.evaluate('false and x')        // false, no matter what x equals


Functions #

Functions are called by entering their name, followed by zero or more
arguments enclosed by parentheses. All available functions are listed on the
page Functions.

math.evaluate('sqrt(25)')           // 5
math.evaluate('log(10000, 3 + 7)')  // 4
math.evaluate('sin(pi / 4)')        // 0.7071067811865475


New functions can be defined by “assigning” an expression to a function call
with one or more variables. Such function assignments are limited: they can
only be defined on a single line.

const parser = math.parser()

parser.evaluate('f(x) = x ^ 2 - 5')
parser.evaluate('f(2)')     // -1
parser.evaluate('f(3)')     // 4

parser.evaluate('g(x, y) = x ^ y')
parser.evaluate('g(2, 3)')  // 8


Note that these function assignments do not create closures; put another way,
all free variables in mathjs are dynamic:

const parser = math.parser()

parser.evaluate('x = 7')
parser.evaluate('h(y) = x + y')
parser.evaluate('h(3)')         // 10
parser.evaluate('x = 3')
parser.evaluate('h(3)')         // 6, *not* 10


It is however possible to pass functions as parameters:

const parser = math.parser()

parser.evaluate('twice(func, x) = func(func(x))')
parser.evaluate('twice(square, 2)')    // 16
parser.evaluate('f(x) = 3*x')
parser.evaluate('twice(f, 2)')         // 18

// a simplistic "numerical derivative":
parser.evaluate('eps = 1e-10')
parser.evaluate('nd(f, x) = (f(x+eps) - func(x-eps))/(2*eps)')
parser.evaluate('nd(square,2)')        // 4.000000330961484


Math.js itself heavily uses typed functions, which ensure correct inputs and
throws meaningful errors when the input arguments are invalid. One can create
a typed-function in the
expression parser like:

const parser = math.parser()

parser.evaluate('f = typed({"number": f(x) = x ^ 2 - 5})')


Finally, as mentioned above, there is a function form for nearly every one of
the mathematical operator symbols. Moreover, for some associative operators,
the corresponding function allows arbitrarily many arguments. The table below
gives the full correspondence.


  
    
      Operator Expression
      Equivalent Function Expression
    
  
  
    
      a or b
      or(a,b)
    
    
      a xor b
      xor(a,b)
    
    
      a and b
      and(a,b)
    
    
      a \| b
      bitOr(a,b)
    
    
      a ^\| b
      bitXor(a,b)
    
    
      a & b
      bitAnd(a,b)
    
    
      a == b
      equal(a,b)
    
    
      a != b
      unequal(a,b)
    
    
      a < b
      smaller(a,b)
    
    
      a > b
      larger(a,b)
    
    
      a <= b
      smallerEq(a,b)
    
    
      a << 3
      leftShift(a,3)
    
    
      a >> 3
      rightArithShift(a,3)
    
    
      a >>> 3
      rightLogShift(a,3)
    
    
      u to cm
      to(u, cm)
    
    
      a + b + c + ...
      add(a,b,c,...)
    
    
      a - b
      subtract(a,b)
    
    
      a * b * c * ...
      multiply(a,b,c,...)
    
    
      A .* B
      dotMultiply(A,B)
    
    
      A ./ B
      dotDivide(A,B)
    
    
      a mod b
      mod(a,b)
    
    
      +a
      unaryPlus(a)
    
    
      -a
      unaryMinus(a)
    
    
      ~a
      bitNot(a)
    
    
      not a
      not(a)
    
    
      a^b
      pow(a,b)
    
    
      A .^ B
      dotPow(A,B)
    
    
      a!
      factorial(a)
    
    
      A'
      ctranspose(A)
    
  


Note that math.js embodies a preference for the operator forms, in that calling
simplify (see Algebra) converts any instances of the function
form into the corresponding operator.

Map and forEach #

The map and forEach functions can be used to apply a callback function to each element of an array or matrix.

The callback functions can be functions, typed functions, inline functions (only in the parser) or compiled inline functions (only in the parser).

The callback can have the following inputs:

  value: the current value in the array or matrix.
  index: the index of the current value expressed as an array of numbers.
  array: the array or matrix being iterated.


Below is the syntax for both functions:

map #

The map function applies a function to each element of an array and returns a new array with the results.

const parser = math.parser()

// Define a square function
parser.evaluate('square(x) = x ^ 2')

// Apply the square function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], square)')
// result: [1, 4, 9, 16]

// Apply an inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], f(x) = x ^ 2)')
// result: [1, 4, 9, 16]

// Apply a compiled inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], x ^ 2)')
// result: [1, 4, 9, 16]


forEach #
The forEach function applies a function to each element of an array or matrix but does not return a new array. It is useful for executing side effects.

// Define a function that prints each element
math.import({consoleLog: x => console.log(x)})
const parser = math.parser()

// Define a squareConsleLog function
parser.evaluate('squareConsoleLog(x) = consoleLog(x ^ 2)')

// Apply the squareConsleLog function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], squareConsleLog)')
// Prints: 1, 4, 9, 16

// Apply an inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], f(x) = consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16

// Apply a compiled inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16


These functions are useful for performing element-wise operations on arrays or matrices.

Constants and variables #

Math.js has a number of built-in constants such as pi and e.
All available constants are listed on he page
Constants.

// use constants
math.evaluate('pi')                 // 3.141592653589793
math.evaluate('e ^ 2')              // 7.3890560989306495
math.evaluate('log(e)')             // 1
math.evaluate('e ^ (pi * i) + 1')   // ~0 (Euler)


Variables can be defined using the assignment operator =, and can be used
like constants.

const parser = math.parser()

// define variables
parser.evaluate('a = 3.4')      // 3.4
parser.evaluate('b = 5 / 2')    // 2.5

// use variables
parser.evaluate('a * b')        // 8.5


Variable names must:


  Begin with an “alpha character”, which is:
    
      A latin letter (upper or lower case). Ascii: a-z, A-Z
      An underscore.                        Ascii: _
      A dollar sign.                        Ascii: $
      A latin letter with accents.          Unicode: \u00C0 - \u02AF
      A greek letter.                       Unicode: \u0370 - \u03FF
      A letter-like character.              Unicode: \u2100 - \u214F
      A mathematical alphanumeric symbol.   Unicode: \u{1D400} - \u{1D7FF} excluding invalid code points
    
  
  Contain only alpha characters (above) and digits 0-9
  Not be any of the following: mod, to, in, and, xor, or, not, end. It is possible to assign to some of these, but that’s not recommended.


It is possible to customize the allowed alpha characters, see Customize supported characters for more information.

Data types #

The expression parser supports booleans, numbers, complex numbers, units,
strings, matrices, and objects.

Booleans #

Booleans true and false can be used in expressions.

// use booleans
math.evaluate('true')               // true
math.evaluate('false')              // false
math.evaluate('(2 == 3) == false')  // true


Booleans can be converted to numbers and strings and vice versa using the
functions number and boolean, and string.

// convert booleans
math.evaluate('number(true)')       // 1
math.evaluate('string(false)')      // "false"
math.evaluate('boolean(1)')         // true
math.evaluate('boolean("false")')   // false


Numbers #

The most important and basic data type in math.js are numbers. Numbers use a
point as decimal mark. Numbers can be entered with exponential notation.
Examples:

// numbers in math.js
math.evaluate('2')        // 2
math.evaluate('3.14')     // 3.14
math.evaluate('1.4e3')    // 1400
math.evaluate('22e-3')    // 0.022


A number can be converted to a string and vice versa using the functions
number and string.

// convert a string into a number
math.evaluate('number("2.3")')    // 2.3
math.evaluate('string(2.3)')      // "2.3"


Math.js uses regular JavaScript numbers, which are floating points with a
limited precision and limited range. The limitations are described in detail
on the page Numbers.

math.evaluate('1e-325')   // 0
math.evaluate('1e309')    // Infinity
math.evaluate('-1e309')   // -Infinity


When doing calculations with floats, one can very easily get round-off errors:

// round-off error due to limited floating point precision
math.evaluate('0.1 + 0.2')  // 0.30000000000000004


When outputting results, the function math.format can be used to hide
these round-off errors when outputting results for the user:

const ans = math.evaluate('0.1 + 0.2')  //  0.30000000000000004
math.format(ans, {precision: 14})       // "0.3"


Numbers can be expressed as binary, octal, and hexadecimal literals:

math.evaluate('0b11')  //  3
math.evaluate('0o77')  //  63
math.evaluate('0xff')  //  255


A word size suffix can be used to change the behavior of non decimal literal evaluation:

math.evaluate('0xffi8')         // -1
math.evaluate('0xffffffffi32')  //  -1
math.evaluate('0xfffffffffi32') //  SyntaxError: String "0xfffffffff" is out of range


Non decimal numbers can include a radix point:
math.evaluate('0b1.1')         // 1.5
math.evaluate('0o1.4')         // 1.5
math.evaluate('0x1.8')         // 1.5


Numbers can be formatted as binary, octal, and hex strings using the notation option of the format function:

math.evaluate('format(3, {notation: "bin"})')    //  '0b11'
math.evaluate('format(63, {notation: "oct"})')   //  '0o77'
math.evaluate('format(255, {notation: "hex"})')  //  '0xff'
math.evaluate('format(-1, {notation: "hex"})')   //  '-0x1'
math.evaluate('format(2.3, {notation: "hex"})')  //  '0x2.4cccccccccccc'


The format function accepts a wordSize option to use in conjunction with the non binary notations:

math.evaluate('format(-1, {notation: "hex", wordSize: 8})')   //  '0xffi8'


The functions bin, oct, and hex are shorthand for the format function with notation set accordingly:

math.evaluate('bin(-1)')     // '-0b1'
math.evaluate('bin(-1, 8)')  // '0b11111111i8'


BigNumbers #

Math.js supports BigNumbers for calculations with an arbitrary precision.
The pros and cons of Number and BigNumber are explained in detail on the page
Numbers.

BigNumbers are slower but have a higher precision. Calculations with big
numbers are supported only by arithmetic functions.

BigNumbers can be created using the bignumber function:

math.evaluate('bignumber(0.1) + bignumber(0.2)') // BigNumber, 0.3


The default number type of the expression parser can be changed at instantiation
of math.js. The expression parser parses numbers as BigNumber by default:

// Configure the type of number: 'number' (default), 'BigNumber', or 'Fraction'
math.config({number: 'BigNumber'})

// all numbers are parsed as BigNumber
math.evaluate('0.1 + 0.2')  // BigNumber, 0.3


BigNumbers can be converted to numbers and vice versa using the functions
number and bignumber. When converting a BigNumber to a Number, the high
precision of the BigNumber will be lost. When a BigNumber is too large to be represented
as Number, it will be initialized as Infinity.

Complex numbers #

Complex numbers can be created using the imaginary unit i, which is defined
as i^2 = -1. Complex numbers have a real and complex part, which can be
retrieved using the functions re and im.

const parser = math.parser()

// create complex numbers
parser.evaluate('a = 2 + 3i')   // Complex, 2 + 3i
parser.evaluate('b = 4 - i')    // Complex, 4 - i

// get real and imaginary part of a complex number
parser.evaluate('re(a)')        // Number,  2
parser.evaluate('im(a)')        // Number,  3

// calculations with complex numbers
parser.evaluate('a + b')        // Complex, 6 + 2i
parser.evaluate('a * b')        // Complex, 11 + 10i
parser.evaluate('i * i')        // Number,  -1
parser.evaluate('sqrt(-4)')     // Complex, 2i


Units #

math.js supports units. Units can be used in the arithmetic operations
add, subtract, multiply, divide, and exponentiation.
Units can also be converted from one to another.
An overview of all available units can be found on the page
Units.

Units can be converted using the operator to or in.

// create a unit
math.evaluate('5.4 kg')                     // Unit, 5.4 kg

// convert a unit
math.evaluate('2 inch to cm')               // Unit, 5.08 cm
math.evaluate('20 celsius in fahrenheit')   // Unit, ~68 fahrenheit
math.evaluate('90 km/h to m/s')             // Unit, 25 m / s

// convert a unit to a number
// A second parameter with the unit for the exported number must be provided
math.evaluate('number(5 cm, mm)')           // Number, 50

// calculations with units
math.evaluate('0.5kg + 33g')                // Unit, 0.533 kg
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('12 seconds * 2')             // Unit, 24 seconds
math.evaluate('sin(45 deg)')                // Number, 0.7071067811865475
math.evaluate('9.81 m/s^2 * 5 s to mi/h')   // Unit, 109.72172512527 mi / h


Strings #

Strings are enclosed by double quotes “ or single quotes ‘. Strings can be concatenated using the
function concat (not by adding them using + like in JavaScript). Parts of
a string can be retrieved or replaced by using indexes. Strings can be converted
to a number using function number, and numbers can be converted to a string
using function string.

When setting the value of a character in a string, the character that has been
set is returned. Likewise, when a range of characters is set, that range of
characters is returned.

const parser = math.parser()

// create a string
parser.evaluate('"hello"')                        // String, "hello"

// string manipulation
parser.evaluate('a = concat("hello", " world")')  // String, "hello world"
parser.evaluate('size(a)')                        // Matrix [11]
parser.evaluate('a[1:5]')                         // String, "hello"
parser.evaluate('a[1] = "H"')                     // String, "H"
parser.evaluate('a[7:12] = "there!"')             // String, "there!"
parser.evaluate('a')                              // String, "Hello there!"

// string conversion
parser.evaluate('number("300")')                  // Number, 300
parser.evaluate('string(300)')                    // String, "300"


Strings can be used in the evaluate function, to parse expressions inside
the expression parser:

math.evaluate('evaluate("2 + 3")')  // 5


Matrices #

Matrices can be created by entering a series of values between square brackets,
elements are separated by a comma ,.
A matrix like [1, 2, 3] will create a vector, a 1-dimensional matrix with
size [3]. To create a multi-dimensional matrix, matrices can be nested into
each other. For easier creation of two-dimensional matrices, a semicolon ;
can be used to separate rows in a matrix.

// create a matrix
math.evaluate('[1, 2, 3]')                                // Matrix, size [3]
math.evaluate('[[1, 2, 3], [4, 5, 6]]')                   // Matrix, size [2, 3]
math.evaluate('[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]')     // Matrix, size [2, 2, 2]

// create a two dimensional matrix
math.evaluate('[1, 2, 3; 4, 5, 6]')                       // Matrix, size [2, 3]


Another way to create filled matrices is using the functions zeros, ones,
identity, and range.

// initialize a matrix with ones or zeros
math.evaluate('zeros(3, 2)')      // Matrix, [[0, 0], [0, 0], [0, 0]],  size [3, 2]
math.evaluate('ones(3)')          // Matrix, [1, 1, 1],                 size [3]
math.evaluate('5 * ones(2, 2)')   // Matrix, [[5, 5], [5, 5]],          size [2, 2]

// create an identity matrix
math.evaluate('identity(2)')      // Matrix, [[1, 0], [0, 1]],          size [2, 2]

// create a range
math.evaluate('1:4')              // Matrix, [1, 2, 3, 4],              size [4]
math.evaluate('0:2:10')           // Matrix, [0, 2, 4, 6, 8, 10],       size [6]


A subset can be retrieved from a matrix using indexes and a subset of a matrix
can be replaced by using indexes. Indexes are enclosed in square brackets, and
contain a number or a range for each of the matrix dimensions. A range can have
its start and/or end undefined. When the start is undefined, the range will start
at 1, when the end is undefined, the range will end at the end of the matrix.

There is a context variable end available as well to denote the end of the
matrix. This variable cannot be used in multiple nested indices. In that case,
end will be resolved as the end of the innermost matrix. To solve this, 
resolving of the nested index needs to be split in two separate operations.

IMPORTANT: matrix indexes and ranges work differently from the math.js indexes
in JavaScript: They are one-based with an included upper-bound, similar to most
math applications.

parser = math.parser()

// create matrices
parser.evaluate('a = [1, 2; 3, 4]')       // Matrix, [[1, 2], [3, 4]]
parser.evaluate('b = zeros(2, 2)')        // Matrix, [[0, 0], [0, 0]]
parser.evaluate('c = 5:9')                // Matrix, [5, 6, 7, 8, 9]

// replace a subset in a matrix
parser.evaluate('b[1, 1:2] = [5, 6]')     // Matrix, [[5, 6], [0, 0]]
parser.evaluate('b[2, :] = [7, 8]')       // Matrix, [[5, 6], [7, 8]]

// perform a matrix calculation
parser.evaluate('d = a * b')              // Matrix, [[19, 22], [43, 50]]

// retrieve a subset of a matrix
parser.evaluate('d[2, 1]')                // 43
parser.evaluate('d[2, 1:end]')            // Matrix, [[43, 50]]
parser.evaluate('c[end - 1 : -1 : 2]')    // Matrix, [8, 7, 6]


Objects #

Objects in math.js work the same as in languages like JavaScript and Python.
An object is enclosed by curly brackets {, }, and contains a set of
comma separated key/value pairs. Keys and values are separated by a colon :.
Keys can be a symbol like prop or a string like "prop".

math.evaluate('{a: 2 + 1, b: 4}')         // {a: 3, b: 4}
math.evaluate('{"a": 2 + 1, "b": 4}')     // {a: 3, b: 4}


Objects can contain objects:

math.evaluate('{a: 2, b: {c: 3, d: 4}}')  // {a: 2, b: {c: 3, d: 4}}


Object properties can be retrieved or replaced using dot notation or bracket
notation. Unlike JavaScript, when setting a property value, the whole object
is returned, not the property value

let scope = {
  obj: {
    prop: 42
  }
}

// retrieve properties
math.evaluate('obj.prop', scope)          // 42
math.evaluate('obj["prop"]', scope)       // 42

// set properties (returns the whole object, not the property value!)
math.evaluate('obj.prop = 43', scope)     // {prop: 43}
math.evaluate('obj["prop"] = 43', scope)  // {prop: 43}
scope.obj                                 // {prop: 43}


Multi-line expressions #

An expression can contain multiple lines, and expressions can be spread over
multiple lines. Lines can be separated by a newline character \n or by a
semicolon ;. Output of statements followed by a semicolon will be hidden from
the output, and empty lines are ignored. The output is returned as a ResultSet,
with an entry for every visible statement.

// a multi-line expression
math.evaluate('1 * 3 \n 2 * 3 \n 3 * 3')    // ResultSet, [3, 6, 9]

// semicolon statements are hidden from the output
math.evaluate('a=3; b=4; a + b \n a * b')   // ResultSet, [7, 12]

// single expression spread over multiple lines
math.evaluate('a = 2 +\n  3')               // 5
math.evaluate('[\n  1, 2;\n  3, 4\n]')      // Matrix, [[1, 2], [3, 4]]


The results can be read from a ResultSet via the property ResultSet.entries
which is an Array, or by calling ResultSet.valueOf(), which returns the
array with results.

Implicit multiplication #

Implicit multiplication means the multiplication of two symbols, numbers, or a grouped expression inside parentheses without using the * operator. This type of syntax allows a more natural way to enter expressions. For example:

math.evaluate('2 pi')         // 6.283185307179586
math.evaluate('(1+2)(3+4)')   // 21


Parentheses are parsed as a function call when there is a symbol or accessor on
the left hand side, like sqrt(4) or obj.method(4). In other cases the
parentheses are interpreted as an implicit multiplication.

Math.js will always evaluate implicit multiplication before explicit multiplication *, so that the expression x * y z is parsed as x * (y * z). Math.js also gives implicit multiplication higher precedence than division, except when the division matches the pattern [unaryPrefixOp]?[number] / [number] [symbol] or [unaryPrefixOp]?[number] / [number] [left paren]. In that special case, the division is evaluated first:

math.evaluate('20 kg / 4 kg')   // 5      Evaluated as (20 kg) / (4 kg)
math.evaluate('20 / 4 kg')      // 5 kg   Evaluated as (20 / 4) kg


The behavior of implicit multiplication can be summarized by these operator precedence rules, listed from highest to lowest precedence:


  Function calls: [symbol] [left paren]
  Explicit division / when the division matches this pattern: [+-~]?[number] / [+-~]?[number] [symbol] or [number] / [number] [left paren]
  Implicit multiplication
  All other division / and multiplication *


Implicit multiplication is tricky as there can appear to be ambiguity in how an expression will be evaluated. Experience has shown that the above rules most closely match user intent when entering expressions that could be interpreted different ways. It’s also possible that these rules could be tweaked in future major releases.  Use implicit multiplication carefully. If you don’t like the uncertainty introduced by implicit multiplication, use explicit * operators and parentheses to ensure your expression is evaluated the way you intend.

Here are some more examples using implicit multiplication:


  
    
      Expression
      Evaluated as
      Result
    
  
  
    
      (1 + 3) pi
      (1 + 3) * pi
      12.566370614359172
    
    
      (4 - 1) 2
      (4 - 1) * 2
      6
    
    
      3 / 4 mm
      (3 / 4) * mm
      0.75 mm
    
    
      2 + 3 i
      2 + (3 * i)
      2 + 3i
    
    
      (1 + 2) (4 - 2)
      (1 + 2) * (4 - 2)
      6
    
    
      sqrt(4) (1 + 2)
      sqrt(4) * (1 + 2)
      6
    
    
      8 pi / 2 pi
      (8 * pi) / (2 * pi)
      4
    
    
      pi / 2 pi
      pi / (2 * pi)
      0.5
    
    
      1 / 2i
      (1 / 2) * i
      0.5 i
    
    
      8.314 J / mol K
      8.314 J / (mol * K)
      8.314 J / (mol * K)
    
  


Comments #

Comments can be added to explain or describe calculations in the text. A comment
starts with a sharp sign character #, and ends at the end of the line. A line
can contain a comment only, or can contain an expression followed by a comment.

const parser = math.parser()

parser.evaluate('# define some variables')
parser.evaluate('width = 3')                              // 3
parser.evaluate('height = 4')                             // 4
parser.evaluate('width * height   # calculate the area')  // 12\n\n\n\nExpression syntax #

This page describes the syntax of expression parser of math.js. It describes
how to work with the available data types, functions, operators, variables,
and more.

Differences from JavaScript #

The expression parser of math.js is aimed at a mathematical audience,
not a programming audience. The syntax is similar to most calculators and
mathematical applications. This is close to JavaScript as well, though there
are a few important differences between the syntax of the expression parser and
the lower level syntax of math.js. Differences are:


  No need to prefix functions and constants with the math.* namespace,
you can just enter sin(pi / 4).
  Matrix indexes are one-based instead of zero-based.
  There are index and range operators which allow more conveniently getting
and setting matrix indexes, like A[2:4, 1].
  Both indexes and ranges and have the upper-bound included.
  There is a differing syntax for defining functions. Example: f(x) = x^2.
  There are custom operators like x + y instead of add(x, y).
  Some operators are different. For example  ^ is used for exponentiation,
not bitwise xor.
  Implicit multiplication, like 2 pi, is supported and has special rules.
  Relational operators (<, >, <=, >=, ==, and !=) are chained, so the expression 5 < x < 10 is equivalent to 5 < x and x < 10.
  Multi-expression constructs like a = 1; b = 2; a + b or
"a = 1;\n cos(a)\n sin(a)" (where \n denotes newline)
produce a collection (“ResultSet”) of values. Those expressions
terminated by ; are evaluated for side effect only and their values
are suppressed from the result.


Operators #

The expression parser has operators for all common arithmetic operations such
as addition and multiplication. The expression parser uses conventional infix
notation for operators: an operator is placed between its arguments.
Round parentheses can be used to override the default precedence of operators.

// use operators
math.evaluate('2 + 3')       // 5
math.evaluate('2 * 3')       // 6

// use parentheses to override the default precedence
math.evaluate('2 + 3 * 4')   // 14
math.evaluate('(2 + 3) * 4') // 20


The following operators are available. Note that almost every operator listed
also has a function form with identical meaning that can be used
interchangeably. For example, x+y will always evaluate identically to
add(x,y). For a full list of the equivalences, see the section on
Functions below.


  
    
      Operator
      Name
      Syntax
      Associativity
      Example
      Result
    
  
  
    
      (, )
      Grouping
      (x)
      None
      2 * (3 + 4)
      14
    
    
      [, ]
      Matrix, Index
      [...]
      None
      [[1,2],[3,4]]
      [[1,2],[3,4]]
    
    
      {, }
      Object
      {...}
      None
      {a: 1, b: 2}
      {a: 1, b: 2}
    
    
      ,
      Parameter separator
      x, y
      Left to right
      max(2, 1, 5)
      5
    
    
      .
      Property accessor
      obj.prop
      Left to right
      obj={a: 12}; obj.a
      12
    
    
      ;
      Statement separator
      x; y
      Left to right
      a=2; b=3; a*b
      [6]
    
    
      ;
      Row separator
      [x; y]
      Left to right
      [1,2;3,4]
      [[1,2],[3,4]]
    
    
      \n
      Statement separator
      x \n y
      Left to right
      a=2 \n b=3 \n a*b
      [2,3,6]
    
    
      +
      Add
      x + y
      Left to right
      4 + 5
      9
    
    
      +
      Unary plus
      +y
      Right to left
      +4
      4
    
    
      -
      Subtract
      x - y
      Left to right
      7 - 3
      4
    
    
      -
      Unary minus
      -y
      Right to left
      -4
      -4
    
    
      *
      Multiply
      x * y
      Left to right
      2 * 3
      6
    
    
      .*
      Element-wise multiply
      x .* y
      Left to right
      [1,2,3] .* [1,2,3]
      [1,4,9]
    
    
      /
      Divide
      x / y
      Left to right
      6 / 2
      3
    
    
      ./
      Element-wise divide
      x ./ y
      Left to right
      [9,6,4] ./ [3,2,2]
      [3,3,2]
    
    
      %
      Percentage
      x%
      None
      8%
      0.08
    
    
      %
      Addition with Percentage
      x + y%
      Left to right
      100 + 3%
      103
    
    
      %
      Subtraction with Percentage
      x - y%
      Left to right
      100 - 3%
      97
    
    
      % mod
      Modulus
      x % y
      Left to right
      8 % 3
      2
    
    
      ^
      Power
      x ^ y
      Right to left
      2 ^ 3
      8
    
    
      .^
      Element-wise power
      x .^ y
      Right to left
      [2,3] .^ [3,3]
      [8,27]
    
    
      '
      Transpose
      y'
      Left to right
      [[1,2],[3,4]]'
      [[1,3],[2,4]]
    
    
      !
      Factorial
      y!
      Left to right
      5!
      120
    
    
      &
      Bitwise and
      x & y
      Left to right
      5 & 3
      1
    
    
      ~
      Bitwise not
      ~x
      Right to left
      ~2
      -3
    
    
      |
      Bitwise or
      x | y
      Left to right
      5 | 3
      7
    
    
      ^|
      Bitwise xor
      x ^| y
      Left to right
      5 ^| 2
      7
    
    
      <<
      Left shift
      x << y
      Left to right
      4 << 1
      8
    
    
      >>
      Right arithmetic shift
      x >> y
      Left to right
      8 >> 1
      4
    
    
      >>>
      Right logical shift
      x >>> y
      Left to right
      -8 >>> 1
      2147483644
    
    
      and
      Logical and
      x and y
      Left to right
      true and false
      false
    
    
      not
      Logical not
      not y
      Right to left
      not true
      false
    
    
      or
      Logical or
      x or y
      Left to right
      true or false
      true
    
    
      xor
      Logical xor
      x xor y
      Left to right
      true xor true
      false
    
    
      =
      Assignment
      x = y
      Right to left
      a = 5
      5
    
    
      ? :
      Conditional expression
      x ? y : z
      Right to left
      15 > 100 ? 1 : -1
      -1
    
    
      :
      Range
      x : y
      Right to left
      1:4
      [1,2,3,4]
    
    
      to, in
      Unit conversion
      x to y
      Left to right
      2 inch to cm
      5.08 cm
    
    
      ==
      Equal
      x == y
      Left to right
      2 == 4 - 2
      true
    
    
      !=
      Unequal
      x != y
      Left to right
      2 != 3
      true
    
    
      <
      Smaller
      x < y
      Left to right
      2 < 3
      true
    
    
      >
      Larger
      x > y
      Left to right
      2 > 3
      false
    
    
      <=
      Smallereq
      x <= y
      Left to right
      4 <= 3
      false
    
    
      >=
      Largereq
      x >= y
      Left to right
      2 + 4 >= 6
      true
    
  


Precedence #

The operators have the following precedence, from highest to lowest:


  
    
      Operators
      Description
    
  
  
    
      (...)[...]{...}
      GroupingMatrixObject
    
    
      x(...)x[...]obj.prop:
      Function callMatrix indexProperty accessorKey/value separator
    
    
      '
      Matrix transpose
    
    
      !
      Factorial
    
    
      ^, .^
      Exponentiation
    
    
      +, -, ~, not
      Unary plus, unary minus, bitwise not, logical not
    
    
      See section below
      Implicit multiplication
    
    
      *, /, .*, ./,%, mod
      Multiply, divide , percentage, modulus
    
    
      +, -
      Add, subtract
    
    
      :
      Range
    
    
      to, in
      Unit conversion
    
    
      <<, >>, >>>
      Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift
    
    
      ==, !=, <, >, <=, >=
      Relational
    
    
      &
      Bitwise and (lazily evaluated)
    
    
      ^|
      Bitwise xor
    
    
      |
      Bitwise or (lazily evaluated)
    
    
      and
      Logical and (lazily evaluated)
    
    
      xor
      Logical xor
    
    
      or
      Logical or (lazily evaluated)
    
    
      ?, :
      Conditional expression
    
    
      =
      Assignment
    
    
      ,
      Parameter and column separator
    
    
      ;
      Row separator
    
    
      \n, ;
      Statement separators
    
  


Lazy evaluation is used where logically possible for bitwise and logical
operators. In the following example, the value of x will not even be 
evaluated because it cannot effect the final result:
math.evaluate('false and x')        // false, no matter what x equals


Functions #

Functions are called by entering their name, followed by zero or more
arguments enclosed by parentheses. All available functions are listed on the
page Functions.

math.evaluate('sqrt(25)')           // 5
math.evaluate('log(10000, 3 + 7)')  // 4
math.evaluate('sin(pi / 4)')        // 0.7071067811865475


New functions can be defined by “assigning” an expression to a function call
with one or more variables. Such function assignments are limited: they can
only be defined on a single line.

const parser = math.parser()

parser.evaluate('f(x) = x ^ 2 - 5')
parser.evaluate('f(2)')     // -1
parser.evaluate('f(3)')     // 4

parser.evaluate('g(x, y) = x ^ y')
parser.evaluate('g(2, 3)')  // 8


Note that these function assignments do not create closures; put another way,
all free variables in mathjs are dynamic:

const parser = math.parser()

parser.evaluate('x = 7')
parser.evaluate('h(y) = x + y')
parser.evaluate('h(3)')         // 10
parser.evaluate('x = 3')
parser.evaluate('h(3)')         // 6, *not* 10


It is however possible to pass functions as parameters:

const parser = math.parser()

parser.evaluate('twice(func, x) = func(func(x))')
parser.evaluate('twice(square, 2)')    // 16
parser.evaluate('f(x) = 3*x')
parser.evaluate('twice(f, 2)')         // 18

// a simplistic "numerical derivative":
parser.evaluate('eps = 1e-10')
parser.evaluate('nd(f, x) = (f(x+eps) - func(x-eps))/(2*eps)')
parser.evaluate('nd(square,2)')        // 4.000000330961484


Math.js itself heavily uses typed functions, which ensure correct inputs and
throws meaningful errors when the input arguments are invalid. One can create
a typed-function in the
expression parser like:

const parser = math.parser()

parser.evaluate('f = typed({"number": f(x) = x ^ 2 - 5})')


Finally, as mentioned above, there is a function form for nearly every one of
the mathematical operator symbols. Moreover, for some associative operators,
the corresponding function allows arbitrarily many arguments. The table below
gives the full correspondence.


  
    
      Operator Expression
      Equivalent Function Expression
    
  
  
    
      a or b
      or(a,b)
    
    
      a xor b
      xor(a,b)
    
    
      a and b
      and(a,b)
    
    
      a \| b
      bitOr(a,b)
    
    
      a ^\| b
      bitXor(a,b)
    
    
      a & b
      bitAnd(a,b)
    
    
      a == b
      equal(a,b)
    
    
      a != b
      unequal(a,b)
    
    
      a < b
      smaller(a,b)
    
    
      a > b
      larger(a,b)
    
    
      a <= b
      smallerEq(a,b)
    
    
      a << 3
      leftShift(a,3)
    
    
      a >> 3
      rightArithShift(a,3)
    
    
      a >>> 3
      rightLogShift(a,3)
    
    
      u to cm
      to(u, cm)
    
    
      a + b + c + ...
      add(a,b,c,...)
    
    
      a - b
      subtract(a,b)
    
    
      a * b * c * ...
      multiply(a,b,c,...)
    
    
      A .* B
      dotMultiply(A,B)
    
    
      A ./ B
      dotDivide(A,B)
    
    
      a mod b
      mod(a,b)
    
    
      +a
      unaryPlus(a)
    
    
      -a
      unaryMinus(a)
    
    
      ~a
      bitNot(a)
    
    
      not a
      not(a)
    
    
      a^b
      pow(a,b)
    
    
      A .^ B
      dotPow(A,B)
    
    
      a!
      factorial(a)
    
    
      A'
      ctranspose(A)
    
  


Note that math.js embodies a preference for the operator forms, in that calling
simplify (see Algebra) converts any instances of the function
form into the corresponding operator.

Map and forEach #

The map and forEach functions can be used to apply a callback function to each element of an array or matrix.

The callback functions can be functions, typed functions, inline functions (only in the parser) or compiled inline functions (only in the parser).

The callback can have the following inputs:

  value: the current value in the array or matrix.
  index: the index of the current value expressed as an array of numbers.
  array: the array or matrix being iterated.


Below is the syntax for both functions:

map #

The map function applies a function to each element of an array and returns a new array with the results.

const parser = math.parser()

// Define a square function
parser.evaluate('square(x) = x ^ 2')

// Apply the square function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], square)')
// result: [1, 4, 9, 16]

// Apply an inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], f(x) = x ^ 2)')
// result: [1, 4, 9, 16]

// Apply a compiled inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], x ^ 2)')
// result: [1, 4, 9, 16]


forEach #
The forEach function applies a function to each element of an array or matrix but does not return a new array. It is useful for executing side effects.

// Define a function that prints each element
math.import({consoleLog: x => console.log(x)})
const parser = math.parser()

// Define a squareConsleLog function
parser.evaluate('squareConsoleLog(x) = consoleLog(x ^ 2)')

// Apply the squareConsleLog function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], squareConsleLog)')
// Prints: 1, 4, 9, 16

// Apply an inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], f(x) = consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16

// Apply a compiled inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16


These functions are useful for performing element-wise operations on arrays or matrices.

Constants and variables #

Math.js has a number of built-in constants such as pi and e.
All available constants are listed on he page
Constants.

// use constants
math.evaluate('pi')                 // 3.141592653589793
math.evaluate('e ^ 2')              // 7.3890560989306495
math.evaluate('log(e)')             // 1
math.evaluate('e ^ (pi * i) + 1')   // ~0 (Euler)


Variables can be defined using the assignment operator =, and can be used
like constants.

const parser = math.parser()

// define variables
parser.evaluate('a = 3.4')      // 3.4
parser.evaluate('b = 5 / 2')    // 2.5

// use variables
parser.evaluate('a * b')        // 8.5


Variable names must:


  Begin with an “alpha character”, which is:
    
      A latin letter (upper or lower case). Ascii: a-z, A-Z
      An underscore.                        Ascii: _
      A dollar sign.                        Ascii: $
      A latin letter with accents.          Unicode: \u00C0 - \u02AF
      A greek letter.                       Unicode: \u0370 - \u03FF
      A letter-like character.              Unicode: \u2100 - \u214F
      A mathematical alphanumeric symbol.   Unicode: \u{1D400} - \u{1D7FF} excluding invalid code points
    
  
  Contain only alpha characters (above) and digits 0-9
  Not be any of the following: mod, to, in, and, xor, or, not, end. It is possible to assign to some of these, but that’s not recommended.


It is possible to customize the allowed alpha characters, see Customize supported characters for more information.

Data types #

The expression parser supports booleans, numbers, complex numbers, units,
strings, matrices, and objects.

Booleans #

Booleans true and false can be used in expressions.

// use booleans
math.evaluate('true')               // true
math.evaluate('false')              // false
math.evaluate('(2 == 3) == false')  // true


Booleans can be converted to numbers and strings and vice versa using the
functions number and boolean, and string.

// convert booleans
math.evaluate('number(true)')       // 1
math.evaluate('string(false)')      // "false"
math.evaluate('boolean(1)')         // true
math.evaluate('boolean("false")')   // false


Numbers #

The most important and basic data type in math.js are numbers. Numbers use a
point as decimal mark. Numbers can be entered with exponential notation.
Examples:

// numbers in math.js
math.evaluate('2')        // 2
math.evaluate('3.14')     // 3.14
math.evaluate('1.4e3')    // 1400
math.evaluate('22e-3')    // 0.022


A number can be converted to a string and vice versa using the functions
number and string.

// convert a string into a number
math.evaluate('number("2.3")')    // 2.3
math.evaluate('string(2.3)')      // "2.3"


Math.js uses regular JavaScript numbers, which are floating points with a
limited precision and limited range. The limitations are described in detail
on the page Numbers.

math.evaluate('1e-325')   // 0
math.evaluate('1e309')    // Infinity
math.evaluate('-1e309')   // -Infinity


When doing calculations with floats, one can very easily get round-off errors:

// round-off error due to limited floating point precision
math.evaluate('0.1 + 0.2')  // 0.30000000000000004


When outputting results, the function math.format can be used to hide
these round-off errors when outputting results for the user:

const ans = math.evaluate('0.1 + 0.2')  //  0.30000000000000004
math.format(ans, {precision: 14})       // "0.3"


Numbers can be expressed as binary, octal, and hexadecimal literals:

math.evaluate('0b11')  //  3
math.evaluate('0o77')  //  63
math.evaluate('0xff')  //  255


A word size suffix can be used to change the behavior of non decimal literal evaluation:

math.evaluate('0xffi8')         // -1
math.evaluate('0xffffffffi32')  //  -1
math.evaluate('0xfffffffffi32') //  SyntaxError: String "0xfffffffff" is out of range


Non decimal numbers can include a radix point:
math.evaluate('0b1.1')         // 1.5
math.evaluate('0o1.4')         // 1.5
math.evaluate('0x1.8')         // 1.5


Numbers can be formatted as binary, octal, and hex strings using the notation option of the format function:

math.evaluate('format(3, {notation: "bin"})')    //  '0b11'
math.evaluate('format(63, {notation: "oct"})')   //  '0o77'
math.evaluate('format(255, {notation: "hex"})')  //  '0xff'
math.evaluate('format(-1, {notation: "hex"})')   //  '-0x1'
math.evaluate('format(2.3, {notation: "hex"})')  //  '0x2.4cccccccccccc'


The format function accepts a wordSize option to use in conjunction with the non binary notations:

math.evaluate('format(-1, {notation: "hex", wordSize: 8})')   //  '0xffi8'


The functions bin, oct, and hex are shorthand for the format function with notation set accordingly:

math.evaluate('bin(-1)')     // '-0b1'
math.evaluate('bin(-1, 8)')  // '0b11111111i8'


BigNumbers #

Math.js supports BigNumbers for calculations with an arbitrary precision.
The pros and cons of Number and BigNumber are explained in detail on the page
Numbers.

BigNumbers are slower but have a higher precision. Calculations with big
numbers are supported only by arithmetic functions.

BigNumbers can be created using the bignumber function:

math.evaluate('bignumber(0.1) + bignumber(0.2)') // BigNumber, 0.3


The default number type of the expression parser can be changed at instantiation
of math.js. The expression parser parses numbers as BigNumber by default:

// Configure the type of number: 'number' (default), 'BigNumber', or 'Fraction'
math.config({number: 'BigNumber'})

// all numbers are parsed as BigNumber
math.evaluate('0.1 + 0.2')  // BigNumber, 0.3


BigNumbers can be converted to numbers and vice versa using the functions
number and bignumber. When converting a BigNumber to a Number, the high
precision of the BigNumber will be lost. When a BigNumber is too large to be represented
as Number, it will be initialized as Infinity.

Complex numbers #

Complex numbers can be created using the imaginary unit i, which is defined
as i^2 = -1. Complex numbers have a real and complex part, which can be
retrieved using the functions re and im.

const parser = math.parser()

// create complex numbers
parser.evaluate('a = 2 + 3i')   // Complex, 2 + 3i
parser.evaluate('b = 4 - i')    // Complex, 4 - i

// get real and imaginary part of a complex number
parser.evaluate('re(a)')        // Number,  2
parser.evaluate('im(a)')        // Number,  3

// calculations with complex numbers
parser.evaluate('a + b')        // Complex, 6 + 2i
parser.evaluate('a * b')        // Complex, 11 + 10i
parser.evaluate('i * i')        // Number,  -1
parser.evaluate('sqrt(-4)')     // Complex, 2i


Units #

math.js supports units. Units can be used in the arithmetic operations
add, subtract, multiply, divide, and exponentiation.
Units can also be converted from one to another.
An overview of all available units can be found on the page
Units.

Units can be converted using the operator to or in.

// create a unit
math.evaluate('5.4 kg')                     // Unit, 5.4 kg

// convert a unit
math.evaluate('2 inch to cm')               // Unit, 5.08 cm
math.evaluate('20 celsius in fahrenheit')   // Unit, ~68 fahrenheit
math.evaluate('90 km/h to m/s')             // Unit, 25 m / s

// convert a unit to a number
// A second parameter with the unit for the exported number must be provided
math.evaluate('number(5 cm, mm)')           // Number, 50

// calculations with units
math.evaluate('0.5kg + 33g')                // Unit, 0.533 kg
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('12 seconds * 2')             // Unit, 24 seconds
math.evaluate('sin(45 deg)')                // Number, 0.7071067811865475
math.evaluate('9.81 m/s^2 * 5 s to mi/h')   // Unit, 109.72172512527 mi / h


Strings #

Strings are enclosed by double quotes “ or single quotes ‘. Strings can be concatenated using the
function concat (not by adding them using + like in JavaScript). Parts of
a string can be retrieved or replaced by using indexes. Strings can be converted
to a number using function number, and numbers can be converted to a string
using function string.

When setting the value of a character in a string, the character that has been
set is returned. Likewise, when a range of characters is set, that range of
characters is returned.

const parser = math.parser()

// create a string
parser.evaluate('"hello"')                        // String, "hello"

// string manipulation
parser.evaluate('a = concat("hello", " world")')  // String, "hello world"
parser.evaluate('size(a)')                        // Matrix [11]
parser.evaluate('a[1:5]')                         // String, "hello"
parser.evaluate('a[1] = "H"')                     // String, "H"
parser.evaluate('a[7:12] = "there!"')             // String, "there!"
parser.evaluate('a')                              // String, "Hello there!"

// string conversion
parser.evaluate('number("300")')                  // Number, 300
parser.evaluate('string(300)')                    // String, "300"


Strings can be used in the evaluate function, to parse expressions inside
the expression parser:

math.evaluate('evaluate("2 + 3")')  // 5


Matrices #

Matrices can be created by entering a series of values between square brackets,
elements are separated by a comma ,.
A matrix like [1, 2, 3] will create a vector, a 1-dimensional matrix with
size [3]. To create a multi-dimensional matrix, matrices can be nested into
each other. For easier creation of two-dimensional matrices, a semicolon ;
can be used to separate rows in a matrix.

// create a matrix
math.evaluate('[1, 2, 3]')                                // Matrix, size [3]
math.evaluate('[[1, 2, 3], [4, 5, 6]]')                   // Matrix, size [2, 3]
math.evaluate('[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]')     // Matrix, size [2, 2, 2]

// create a two dimensional matrix
math.evaluate('[1, 2, 3; 4, 5, 6]')                       // Matrix, size [2, 3]


Another way to create filled matrices is using the functions zeros, ones,
identity, and range.

// initialize a matrix with ones or zeros
math.evaluate('zeros(3, 2)')      // Matrix, [[0, 0], [0, 0], [0, 0]],  size [3, 2]
math.evaluate('ones(3)')          // Matrix, [1, 1, 1],                 size [3]
math.evaluate('5 * ones(2, 2)')   // Matrix, [[5, 5], [5, 5]],          size [2, 2]

// create an identity matrix
math.evaluate('identity(2)')      // Matrix, [[1, 0], [0, 1]],          size [2, 2]

// create a range
math.evaluate('1:4')              // Matrix, [1, 2, 3, 4],              size [4]
math.evaluate('0:2:10')           // Matrix, [0, 2, 4, 6, 8, 10],       size [6]


A subset can be retrieved from a matrix using indexes and a subset of a matrix
can be replaced by using indexes. Indexes are enclosed in square brackets, and
contain a number or a range for each of the matrix dimensions. A range can have
its start and/or end undefined. When the start is undefined, the range will start
at 1, when the end is undefined, the range will end at the end of the matrix.

There is a context variable end available as well to denote the end of the
matrix. This variable cannot be used in multiple nested indices. In that case,
end will be resolved as the end of the innermost matrix. To solve this, 
resolving of the nested index needs to be split in two separate operations.

IMPORTANT: matrix indexes and ranges work differently from the math.js indexes
in JavaScript: They are one-based with an included upper-bound, similar to most
math applications.

parser = math.parser()

// create matrices
parser.evaluate('a = [1, 2; 3, 4]')       // Matrix, [[1, 2], [3, 4]]
parser.evaluate('b = zeros(2, 2)')        // Matrix, [[0, 0], [0, 0]]
parser.evaluate('c = 5:9')                // Matrix, [5, 6, 7, 8, 9]

// replace a subset in a matrix
parser.evaluate('b[1, 1:2] = [5, 6]')     // Matrix, [[5, 6], [0, 0]]
parser.evaluate('b[2, :] = [7, 8]')       // Matrix, [[5, 6], [7, 8]]

// perform a matrix calculation
parser.evaluate('d = a * b')              // Matrix, [[19, 22], [43, 50]]

// retrieve a subset of a matrix
parser.evaluate('d[2, 1]')                // 43
parser.evaluate('d[2, 1:end]')            // Matrix, [[43, 50]]
parser.evaluate('c[end - 1 : -1 : 2]')    // Matrix, [8, 7, 6]


Objects #

Objects in math.js work the same as in languages like JavaScript and Python.
An object is enclosed by curly brackets {, }, and contains a set of
comma separated key/value pairs. Keys and values are separated by a colon :.
Keys can be a symbol like prop or a string like "prop".

math.evaluate('{a: 2 + 1, b: 4}')         // {a: 3, b: 4}
math.evaluate('{"a": 2 + 1, "b": 4}')     // {a: 3, b: 4}


Objects can contain objects:

math.evaluate('{a: 2, b: {c: 3, d: 4}}')  // {a: 2, b: {c: 3, d: 4}}


Object properties can be retrieved or replaced using dot notation or bracket
notation. Unlike JavaScript, when setting a property value, the whole object
is returned, not the property value

let scope = {
  obj: {
    prop: 42
  }
}

// retrieve properties
math.evaluate('obj.prop', scope)          // 42
math.evaluate('obj["prop"]', scope)       // 42

// set properties (returns the whole object, not the property value!)
math.evaluate('obj.prop = 43', scope)     // {prop: 43}
math.evaluate('obj["prop"] = 43', scope)  // {prop: 43}
scope.obj                                 // {prop: 43}


Multi-line expressions #

An expression can contain multiple lines, and expressions can be spread over
multiple lines. Lines can be separated by a newline character \n or by a
semicolon ;. Output of statements followed by a semicolon will be hidden from
the output, and empty lines are ignored. The output is returned as a ResultSet,
with an entry for every visible statement.

// a multi-line expression
math.evaluate('1 * 3 \n 2 * 3 \n 3 * 3')    // ResultSet, [3, 6, 9]

// semicolon statements are hidden from the output
math.evaluate('a=3; b=4; a + b \n a * b')   // ResultSet, [7, 12]

// single expression spread over multiple lines
math.evaluate('a = 2 +\n  3')               // 5
math.evaluate('[\n  1, 2;\n  3, 4\n]')      // Matrix, [[1, 2], [3, 4]]


The results can be read from a ResultSet via the property ResultSet.entries
which is an Array, or by calling ResultSet.valueOf(), which returns the
array with results.

Implicit multiplication #

Implicit multiplication means the multiplication of two symbols, numbers, or a grouped expression inside parentheses without using the * operator. This type of syntax allows a more natural way to enter expressions. For example:

math.evaluate('2 pi')         // 6.283185307179586
math.evaluate('(1+2)(3+4)')   // 21


Parentheses are parsed as a function call when there is a symbol or accessor on
the left hand side, like sqrt(4) or obj.method(4). In other cases the
parentheses are interpreted as an implicit multiplication.

Math.js will always evaluate implicit multiplication before explicit multiplication *, so that the expression x * y z is parsed as x * (y * z). Math.js also gives implicit multiplication higher precedence than division, except when the division matches the pattern [unaryPrefixOp]?[number] / [number] [symbol] or [unaryPrefixOp]?[number] / [number] [left paren]. In that special case, the division is evaluated first:

math.evaluate('20 kg / 4 kg')   // 5      Evaluated as (20 kg) / (4 kg)
math.evaluate('20 / 4 kg')      // 5 kg   Evaluated as (20 / 4) kg


The behavior of implicit multiplication can be summarized by these operator precedence rules, listed from highest to lowest precedence:


  Function calls: [symbol] [left paren]
  Explicit division / when the division matches this pattern: [+-~]?[number] / [+-~]?[number] [symbol] or [number] / [number] [left paren]
  Implicit multiplication
  All other division / and multiplication *


Implicit multiplication is tricky as there can appear to be ambiguity in how an expression will be evaluated. Experience has shown that the above rules most closely match user intent when entering expressions that could be interpreted different ways. It’s also possible that these rules could be tweaked in future major releases.  Use implicit multiplication carefully. If you don’t like the uncertainty introduced by implicit multiplication, use explicit * operators and parentheses to ensure your expression is evaluated the way you intend.

Here are some more examples using implicit multiplication:


  
    
      Expression
      Evaluated as
      Result
    
  
  
    
      (1 + 3) pi
      (1 + 3) * pi
      12.566370614359172
    
    
      (4 - 1) 2
      (4 - 1) * 2
      6
    
    
      3 / 4 mm
      (3 / 4) * mm
      0.75 mm
    
    
      2 + 3 i
      2 + (3 * i)
      2 + 3i
    
    
      (1 + 2) (4 - 2)
      (1 + 2) * (4 - 2)
      6
    
    
      sqrt(4) (1 + 2)
      sqrt(4) * (1 + 2)
      6
    
    
      8 pi / 2 pi
      (8 * pi) / (2 * pi)
      4
    
    
      pi / 2 pi
      pi / (2 * pi)
      0.5
    
    
      1 / 2i
      (1 / 2) * i
      0.5 i
    
    
      8.314 J / mol K
      8.314 J / (mol * K)
      8.314 J / (mol * K)
    
  


Comments #

Comments can be added to explain or describe calculations in the text. A comment
starts with a sharp sign character #, and ends at the end of the line. A line
can contain a comment only, or can contain an expression followed by a comment.

const parser = math.parser()

parser.evaluate('# define some variables')
parser.evaluate('width = 3')                              // 3
parser.evaluate('height = 4')                             // 4
parser.evaluate('width * height   # calculate the area')  // 12\n\n\n\nExpression syntax #

This page describes the syntax of expression parser of math.js. It describes
how to work with the available data types, functions, operators, variables,
and more.

Differences from JavaScript #

The expression parser of math.js is aimed at a mathematical audience,
not a programming audience. The syntax is similar to most calculators and
mathematical applications. This is close to JavaScript as well, though there
are a few important differences between the syntax of the expression parser and
the lower level syntax of math.js. Differences are:


  No need to prefix functions and constants with the math.* namespace,
you can just enter sin(pi / 4).
  Matrix indexes are one-based instead of zero-based.
  There are index and range operators which allow more conveniently getting
and setting matrix indexes, like A[2:4, 1].
  Both indexes and ranges and have the upper-bound included.
  There is a differing syntax for defining functions. Example: f(x) = x^2.
  There are custom operators like x + y instead of add(x, y).
  Some operators are different. For example  ^ is used for exponentiation,
not bitwise xor.
  Implicit multiplication, like 2 pi, is supported and has special rules.
  Relational operators (<, >, <=, >=, ==, and !=) are chained, so the expression 5 < x < 10 is equivalent to 5 < x and x < 10.
  Multi-expression constructs like a = 1; b = 2; a + b or
"a = 1;\n cos(a)\n sin(a)" (where \n denotes newline)
produce a collection (“ResultSet”) of values. Those expressions
terminated by ; are evaluated for side effect only and their values
are suppressed from the result.


Operators #

The expression parser has operators for all common arithmetic operations such
as addition and multiplication. The expression parser uses conventional infix
notation for operators: an operator is placed between its arguments.
Round parentheses can be used to override the default precedence of operators.

// use operators
math.evaluate('2 + 3')       // 5
math.evaluate('2 * 3')       // 6

// use parentheses to override the default precedence
math.evaluate('2 + 3 * 4')   // 14
math.evaluate('(2 + 3) * 4') // 20


The following operators are available. Note that almost every operator listed
also has a function form with identical meaning that can be used
interchangeably. For example, x+y will always evaluate identically to
add(x,y). For a full list of the equivalences, see the section on
Functions below.


  
    
      Operator
      Name
      Syntax
      Associativity
      Example
      Result
    
  
  
    
      (, )
      Grouping
      (x)
      None
      2 * (3 + 4)
      14
    
    
      [, ]
      Matrix, Index
      [...]
      None
      [[1,2],[3,4]]
      [[1,2],[3,4]]
    
    
      {, }
      Object
      {...}
      None
      {a: 1, b: 2}
      {a: 1, b: 2}
    
    
      ,
      Parameter separator
      x, y
      Left to right
      max(2, 1, 5)
      5
    
    
      .
      Property accessor
      obj.prop
      Left to right
      obj={a: 12}; obj.a
      12
    
    
      ;
      Statement separator
      x; y
      Left to right
      a=2; b=3; a*b
      [6]
    
    
      ;
      Row separator
      [x; y]
      Left to right
      [1,2;3,4]
      [[1,2],[3,4]]
    
    
      \n
      Statement separator
      x \n y
      Left to right
      a=2 \n b=3 \n a*b
      [2,3,6]
    
    
      +
      Add
      x + y
      Left to right
      4 + 5
      9
    
    
      +
      Unary plus
      +y
      Right to left
      +4
      4
    
    
      -
      Subtract
      x - y
      Left to right
      7 - 3
      4
    
    
      -
      Unary minus
      -y
      Right to left
      -4
      -4
    
    
      *
      Multiply
      x * y
      Left to right
      2 * 3
      6
    
    
      .*
      Element-wise multiply
      x .* y
      Left to right
      [1,2,3] .* [1,2,3]
      [1,4,9]
    
    
      /
      Divide
      x / y
      Left to right
      6 / 2
      3
    
    
      ./
      Element-wise divide
      x ./ y
      Left to right
      [9,6,4] ./ [3,2,2]
      [3,3,2]
    
    
      %
      Percentage
      x%
      None
      8%
      0.08
    
    
      %
      Addition with Percentage
      x + y%
      Left to right
      100 + 3%
      103
    
    
      %
      Subtraction with Percentage
      x - y%
      Left to right
      100 - 3%
      97
    
    
      % mod
      Modulus
      x % y
      Left to right
      8 % 3
      2
    
    
      ^
      Power
      x ^ y
      Right to left
      2 ^ 3
      8
    
    
      .^
      Element-wise power
      x .^ y
      Right to left
      [2,3] .^ [3,3]
      [8,27]
    
    
      '
      Transpose
      y'
      Left to right
      [[1,2],[3,4]]'
      [[1,3],[2,4]]
    
    
      !
      Factorial
      y!
      Left to right
      5!
      120
    
    
      &
      Bitwise and
      x & y
      Left to right
      5 & 3
      1
    
    
      ~
      Bitwise not
      ~x
      Right to left
      ~2
      -3
    
    
      |
      Bitwise or
      x | y
      Left to right
      5 | 3
      7
    
    
      ^|
      Bitwise xor
      x ^| y
      Left to right
      5 ^| 2
      7
    
    
      <<
      Left shift
      x << y
      Left to right
      4 << 1
      8
    
    
      >>
      Right arithmetic shift
      x >> y
      Left to right
      8 >> 1
      4
    
    
      >>>
      Right logical shift
      x >>> y
      Left to right
      -8 >>> 1
      2147483644
    
    
      and
      Logical and
      x and y
      Left to right
      true and false
      false
    
    
      not
      Logical not
      not y
      Right to left
      not true
      false
    
    
      or
      Logical or
      x or y
      Left to right
      true or false
      true
    
    
      xor
      Logical xor
      x xor y
      Left to right
      true xor true
      false
    
    
      =
      Assignment
      x = y
      Right to left
      a = 5
      5
    
    
      ? :
      Conditional expression
      x ? y : z
      Right to left
      15 > 100 ? 1 : -1
      -1
    
    
      :
      Range
      x : y
      Right to left
      1:4
      [1,2,3,4]
    
    
      to, in
      Unit conversion
      x to y
      Left to right
      2 inch to cm
      5.08 cm
    
    
      ==
      Equal
      x == y
      Left to right
      2 == 4 - 2
      true
    
    
      !=
      Unequal
      x != y
      Left to right
      2 != 3
      true
    
    
      <
      Smaller
      x < y
      Left to right
      2 < 3
      true
    
    
      >
      Larger
      x > y
      Left to right
      2 > 3
      false
    
    
      <=
      Smallereq
      x <= y
      Left to right
      4 <= 3
      false
    
    
      >=
      Largereq
      x >= y
      Left to right
      2 + 4 >= 6
      true
    
  


Precedence #

The operators have the following precedence, from highest to lowest:


  
    
      Operators
      Description
    
  
  
    
      (...)[...]{...}
      GroupingMatrixObject
    
    
      x(...)x[...]obj.prop:
      Function callMatrix indexProperty accessorKey/value separator
    
    
      '
      Matrix transpose
    
    
      !
      Factorial
    
    
      ^, .^
      Exponentiation
    
    
      +, -, ~, not
      Unary plus, unary minus, bitwise not, logical not
    
    
      See section below
      Implicit multiplication
    
    
      *, /, .*, ./,%, mod
      Multiply, divide , percentage, modulus
    
    
      +, -
      Add, subtract
    
    
      :
      Range
    
    
      to, in
      Unit conversion
    
    
      <<, >>, >>>
      Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift
    
    
      ==, !=, <, >, <=, >=
      Relational
    
    
      &
      Bitwise and (lazily evaluated)
    
    
      ^|
      Bitwise xor
    
    
      |
      Bitwise or (lazily evaluated)
    
    
      and
      Logical and (lazily evaluated)
    
    
      xor
      Logical xor
    
    
      or
      Logical or (lazily evaluated)
    
    
      ?, :
      Conditional expression
    
    
      =
      Assignment
    
    
      ,
      Parameter and column separator
    
    
      ;
      Row separator
    
    
      \n, ;
      Statement separators
    
  


Lazy evaluation is used where logically possible for bitwise and logical
operators. In the following example, the value of x will not even be 
evaluated because it cannot effect the final result:
math.evaluate('false and x')        // false, no matter what x equals


Functions #

Functions are called by entering their name, followed by zero or more
arguments enclosed by parentheses. All available functions are listed on the
page Functions.

math.evaluate('sqrt(25)')           // 5
math.evaluate('log(10000, 3 + 7)')  // 4
math.evaluate('sin(pi / 4)')        // 0.7071067811865475


New functions can be defined by “assigning” an expression to a function call
with one or more variables. Such function assignments are limited: they can
only be defined on a single line.

const parser = math.parser()

parser.evaluate('f(x) = x ^ 2 - 5')
parser.evaluate('f(2)')     // -1
parser.evaluate('f(3)')     // 4

parser.evaluate('g(x, y) = x ^ y')
parser.evaluate('g(2, 3)')  // 8


Note that these function assignments do not create closures; put another way,
all free variables in mathjs are dynamic:

const parser = math.parser()

parser.evaluate('x = 7')
parser.evaluate('h(y) = x + y')
parser.evaluate('h(3)')         // 10
parser.evaluate('x = 3')
parser.evaluate('h(3)')         // 6, *not* 10


It is however possible to pass functions as parameters:

const parser = math.parser()

parser.evaluate('twice(func, x) = func(func(x))')
parser.evaluate('twice(square, 2)')    // 16
parser.evaluate('f(x) = 3*x')
parser.evaluate('twice(f, 2)')         // 18

// a simplistic "numerical derivative":
parser.evaluate('eps = 1e-10')
parser.evaluate('nd(f, x) = (f(x+eps) - func(x-eps))/(2*eps)')
parser.evaluate('nd(square,2)')        // 4.000000330961484


Math.js itself heavily uses typed functions, which ensure correct inputs and
throws meaningful errors when the input arguments are invalid. One can create
a typed-function in the
expression parser like:

const parser = math.parser()

parser.evaluate('f = typed({"number": f(x) = x ^ 2 - 5})')


Finally, as mentioned above, there is a function form for nearly every one of
the mathematical operator symbols. Moreover, for some associative operators,
the corresponding function allows arbitrarily many arguments. The table below
gives the full correspondence.


  
    
      Operator Expression
      Equivalent Function Expression
    
  
  
    
      a or b
      or(a,b)
    
    
      a xor b
      xor(a,b)
    
    
      a and b
      and(a,b)
    
    
      a \| b
      bitOr(a,b)
    
    
      a ^\| b
      bitXor(a,b)
    
    
      a & b
      bitAnd(a,b)
    
    
      a == b
      equal(a,b)
    
    
      a != b
      unequal(a,b)
    
    
      a < b
      smaller(a,b)
    
    
      a > b
      larger(a,b)
    
    
      a <= b
      smallerEq(a,b)
    
    
      a << 3
      leftShift(a,3)
    
    
      a >> 3
      rightArithShift(a,3)
    
    
      a >>> 3
      rightLogShift(a,3)
    
    
      u to cm
      to(u, cm)
    
    
      a + b + c + ...
      add(a,b,c,...)
    
    
      a - b
      subtract(a,b)
    
    
      a * b * c * ...
      multiply(a,b,c,...)
    
    
      A .* B
      dotMultiply(A,B)
    
    
      A ./ B
      dotDivide(A,B)
    
    
      a mod b
      mod(a,b)
    
    
      +a
      unaryPlus(a)
    
    
      -a
      unaryMinus(a)
    
    
      ~a
      bitNot(a)
    
    
      not a
      not(a)
    
    
      a^b
      pow(a,b)
    
    
      A .^ B
      dotPow(A,B)
    
    
      a!
      factorial(a)
    
    
      A'
      ctranspose(A)
    
  


Note that math.js embodies a preference for the operator forms, in that calling
simplify (see Algebra) converts any instances of the function
form into the corresponding operator.

Map and forEach #

The map and forEach functions can be used to apply a callback function to each element of an array or matrix.

The callback functions can be functions, typed functions, inline functions (only in the parser) or compiled inline functions (only in the parser).

The callback can have the following inputs:

  value: the current value in the array or matrix.
  index: the index of the current value expressed as an array of numbers.
  array: the array or matrix being iterated.


Below is the syntax for both functions:

map #

The map function applies a function to each element of an array and returns a new array with the results.

const parser = math.parser()

// Define a square function
parser.evaluate('square(x) = x ^ 2')

// Apply the square function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], square)')
// result: [1, 4, 9, 16]

// Apply an inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], f(x) = x ^ 2)')
// result: [1, 4, 9, 16]

// Apply a compiled inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], x ^ 2)')
// result: [1, 4, 9, 16]


forEach #
The forEach function applies a function to each element of an array or matrix but does not return a new array. It is useful for executing side effects.

// Define a function that prints each element
math.import({consoleLog: x => console.log(x)})
const parser = math.parser()

// Define a squareConsleLog function
parser.evaluate('squareConsoleLog(x) = consoleLog(x ^ 2)')

// Apply the squareConsleLog function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], squareConsleLog)')
// Prints: 1, 4, 9, 16

// Apply an inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], f(x) = consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16

// Apply a compiled inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16


These functions are useful for performing element-wise operations on arrays or matrices.

Constants and variables #

Math.js has a number of built-in constants such as pi and e.
All available constants are listed on he page
Constants.

// use constants
math.evaluate('pi')                 // 3.141592653589793
math.evaluate('e ^ 2')              // 7.3890560989306495
math.evaluate('log(e)')             // 1
math.evaluate('e ^ (pi * i) + 1')   // ~0 (Euler)


Variables can be defined using the assignment operator =, and can be used
like constants.

const parser = math.parser()

// define variables
parser.evaluate('a = 3.4')      // 3.4
parser.evaluate('b = 5 / 2')    // 2.5

// use variables
parser.evaluate('a * b')        // 8.5


Variable names must:


  Begin with an “alpha character”, which is:
    
      A latin letter (upper or lower case). Ascii: a-z, A-Z
      An underscore.                        Ascii: _
      A dollar sign.                        Ascii: $
      A latin letter with accents.          Unicode: \u00C0 - \u02AF
      A greek letter.                       Unicode: \u0370 - \u03FF
      A letter-like character.              Unicode: \u2100 - \u214F
      A mathematical alphanumeric symbol.   Unicode: \u{1D400} - \u{1D7FF} excluding invalid code points
    
  
  Contain only alpha characters (above) and digits 0-9
  Not be any of the following: mod, to, in, and, xor, or, not, end. It is possible to assign to some of these, but that’s not recommended.


It is possible to customize the allowed alpha characters, see Customize supported characters for more information.

Data types #

The expression parser supports booleans, numbers, complex numbers, units,
strings, matrices, and objects.

Booleans #

Booleans true and false can be used in expressions.

// use booleans
math.evaluate('true')               // true
math.evaluate('false')              // false
math.evaluate('(2 == 3) == false')  // true


Booleans can be converted to numbers and strings and vice versa using the
functions number and boolean, and string.

// convert booleans
math.evaluate('number(true)')       // 1
math.evaluate('string(false)')      // "false"
math.evaluate('boolean(1)')         // true
math.evaluate('boolean("false")')   // false


Numbers #

The most important and basic data type in math.js are numbers. Numbers use a
point as decimal mark. Numbers can be entered with exponential notation.
Examples:

// numbers in math.js
math.evaluate('2')        // 2
math.evaluate('3.14')     // 3.14
math.evaluate('1.4e3')    // 1400
math.evaluate('22e-3')    // 0.022


A number can be converted to a string and vice versa using the functions
number and string.

// convert a string into a number
math.evaluate('number("2.3")')    // 2.3
math.evaluate('string(2.3)')      // "2.3"


Math.js uses regular JavaScript numbers, which are floating points with a
limited precision and limited range. The limitations are described in detail
on the page Numbers.

math.evaluate('1e-325')   // 0
math.evaluate('1e309')    // Infinity
math.evaluate('-1e309')   // -Infinity


When doing calculations with floats, one can very easily get round-off errors:

// round-off error due to limited floating point precision
math.evaluate('0.1 + 0.2')  // 0.30000000000000004


When outputting results, the function math.format can be used to hide
these round-off errors when outputting results for the user:

const ans = math.evaluate('0.1 + 0.2')  //  0.30000000000000004
math.format(ans, {precision: 14})       // "0.3"


Numbers can be expressed as binary, octal, and hexadecimal literals:

math.evaluate('0b11')  //  3
math.evaluate('0o77')  //  63
math.evaluate('0xff')  //  255


A word size suffix can be used to change the behavior of non decimal literal evaluation:

math.evaluate('0xffi8')         // -1
math.evaluate('0xffffffffi32')  //  -1
math.evaluate('0xfffffffffi32') //  SyntaxError: String "0xfffffffff" is out of range


Non decimal numbers can include a radix point:
math.evaluate('0b1.1')         // 1.5
math.evaluate('0o1.4')         // 1.5
math.evaluate('0x1.8')         // 1.5


Numbers can be formatted as binary, octal, and hex strings using the notation option of the format function:

math.evaluate('format(3, {notation: "bin"})')    //  '0b11'
math.evaluate('format(63, {notation: "oct"})')   //  '0o77'
math.evaluate('format(255, {notation: "hex"})')  //  '0xff'
math.evaluate('format(-1, {notation: "hex"})')   //  '-0x1'
math.evaluate('format(2.3, {notation: "hex"})')  //  '0x2.4cccccccccccc'


The format function accepts a wordSize option to use in conjunction with the non binary notations:

math.evaluate('format(-1, {notation: "hex", wordSize: 8})')   //  '0xffi8'


The functions bin, oct, and hex are shorthand for the format function with notation set accordingly:

math.evaluate('bin(-1)')     // '-0b1'
math.evaluate('bin(-1, 8)')  // '0b11111111i8'


BigNumbers #

Math.js supports BigNumbers for calculations with an arbitrary precision.
The pros and cons of Number and BigNumber are explained in detail on the page
Numbers.

BigNumbers are slower but have a higher precision. Calculations with big
numbers are supported only by arithmetic functions.

BigNumbers can be created using the bignumber function:

math.evaluate('bignumber(0.1) + bignumber(0.2)') // BigNumber, 0.3


The default number type of the expression parser can be changed at instantiation
of math.js. The expression parser parses numbers as BigNumber by default:

// Configure the type of number: 'number' (default), 'BigNumber', or 'Fraction'
math.config({number: 'BigNumber'})

// all numbers are parsed as BigNumber
math.evaluate('0.1 + 0.2')  // BigNumber, 0.3


BigNumbers can be converted to numbers and vice versa using the functions
number and bignumber. When converting a BigNumber to a Number, the high
precision of the BigNumber will be lost. When a BigNumber is too large to be represented
as Number, it will be initialized as Infinity.

Complex numbers #

Complex numbers can be created using the imaginary unit i, which is defined
as i^2 = -1. Complex numbers have a real and complex part, which can be
retrieved using the functions re and im.

const parser = math.parser()

// create complex numbers
parser.evaluate('a = 2 + 3i')   // Complex, 2 + 3i
parser.evaluate('b = 4 - i')    // Complex, 4 - i

// get real and imaginary part of a complex number
parser.evaluate('re(a)')        // Number,  2
parser.evaluate('im(a)')        // Number,  3

// calculations with complex numbers
parser.evaluate('a + b')        // Complex, 6 + 2i
parser.evaluate('a * b')        // Complex, 11 + 10i
parser.evaluate('i * i')        // Number,  -1
parser.evaluate('sqrt(-4)')     // Complex, 2i


Units #

math.js supports units. Units can be used in the arithmetic operations
add, subtract, multiply, divide, and exponentiation.
Units can also be converted from one to another.
An overview of all available units can be found on the page
Units.

Units can be converted using the operator to or in.

// create a unit
math.evaluate('5.4 kg')                     // Unit, 5.4 kg

// convert a unit
math.evaluate('2 inch to cm')               // Unit, 5.08 cm
math.evaluate('20 celsius in fahrenheit')   // Unit, ~68 fahrenheit
math.evaluate('90 km/h to m/s')             // Unit, 25 m / s

// convert a unit to a number
// A second parameter with the unit for the exported number must be provided
math.evaluate('number(5 cm, mm)')           // Number, 50

// calculations with units
math.evaluate('0.5kg + 33g')                // Unit, 0.533 kg
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('12 seconds * 2')             // Unit, 24 seconds
math.evaluate('sin(45 deg)')                // Number, 0.7071067811865475
math.evaluate('9.81 m/s^2 * 5 s to mi/h')   // Unit, 109.72172512527 mi / h


Strings #

Strings are enclosed by double quotes “ or single quotes ‘. Strings can be concatenated using the
function concat (not by adding them using + like in JavaScript). Parts of
a string can be retrieved or replaced by using indexes. Strings can be converted
to a number using function number, and numbers can be converted to a string
using function string.

When setting the value of a character in a string, the character that has been
set is returned. Likewise, when a range of characters is set, that range of
characters is returned.

const parser = math.parser()

// create a string
parser.evaluate('"hello"')                        // String, "hello"

// string manipulation
parser.evaluate('a = concat("hello", " world")')  // String, "hello world"
parser.evaluate('size(a)')                        // Matrix [11]
parser.evaluate('a[1:5]')                         // String, "hello"
parser.evaluate('a[1] = "H"')                     // String, "H"
parser.evaluate('a[7:12] = "there!"')             // String, "there!"
parser.evaluate('a')                              // String, "Hello there!"

// string conversion
parser.evaluate('number("300")')                  // Number, 300
parser.evaluate('string(300)')                    // String, "300"


Strings can be used in the evaluate function, to parse expressions inside
the expression parser:

math.evaluate('evaluate("2 + 3")')  // 5


Matrices #

Matrices can be created by entering a series of values between square brackets,
elements are separated by a comma ,.
A matrix like [1, 2, 3] will create a vector, a 1-dimensional matrix with
size [3]. To create a multi-dimensional matrix, matrices can be nested into
each other. For easier creation of two-dimensional matrices, a semicolon ;
can be used to separate rows in a matrix.

// create a matrix
math.evaluate('[1, 2, 3]')                                // Matrix, size [3]
math.evaluate('[[1, 2, 3], [4, 5, 6]]')                   // Matrix, size [2, 3]
math.evaluate('[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]')     // Matrix, size [2, 2, 2]

// create a two dimensional matrix
math.evaluate('[1, 2, 3; 4, 5, 6]')                       // Matrix, size [2, 3]


Another way to create filled matrices is using the functions zeros, ones,
identity, and range.

// initialize a matrix with ones or zeros
math.evaluate('zeros(3, 2)')      // Matrix, [[0, 0], [0, 0], [0, 0]],  size [3, 2]
math.evaluate('ones(3)')          // Matrix, [1, 1, 1],                 size [3]
math.evaluate('5 * ones(2, 2)')   // Matrix, [[5, 5], [5, 5]],          size [2, 2]

// create an identity matrix
math.evaluate('identity(2)')      // Matrix, [[1, 0], [0, 1]],          size [2, 2]

// create a range
math.evaluate('1:4')              // Matrix, [1, 2, 3, 4],              size [4]
math.evaluate('0:2:10')           // Matrix, [0, 2, 4, 6, 8, 10],       size [6]


A subset can be retrieved from a matrix using indexes and a subset of a matrix
can be replaced by using indexes. Indexes are enclosed in square brackets, and
contain a number or a range for each of the matrix dimensions. A range can have
its start and/or end undefined. When the start is undefined, the range will start
at 1, when the end is undefined, the range will end at the end of the matrix.

There is a context variable end available as well to denote the end of the
matrix. This variable cannot be used in multiple nested indices. In that case,
end will be resolved as the end of the innermost matrix. To solve this, 
resolving of the nested index needs to be split in two separate operations.

IMPORTANT: matrix indexes and ranges work differently from the math.js indexes
in JavaScript: They are one-based with an included upper-bound, similar to most
math applications.

parser = math.parser()

// create matrices
parser.evaluate('a = [1, 2; 3, 4]')       // Matrix, [[1, 2], [3, 4]]
parser.evaluate('b = zeros(2, 2)')        // Matrix, [[0, 0], [0, 0]]
parser.evaluate('c = 5:9')                // Matrix, [5, 6, 7, 8, 9]

// replace a subset in a matrix
parser.evaluate('b[1, 1:2] = [5, 6]')     // Matrix, [[5, 6], [0, 0]]
parser.evaluate('b[2, :] = [7, 8]')       // Matrix, [[5, 6], [7, 8]]

// perform a matrix calculation
parser.evaluate('d = a * b')              // Matrix, [[19, 22], [43, 50]]

// retrieve a subset of a matrix
parser.evaluate('d[2, 1]')                // 43
parser.evaluate('d[2, 1:end]')            // Matrix, [[43, 50]]
parser.evaluate('c[end - 1 : -1 : 2]')    // Matrix, [8, 7, 6]


Objects #

Objects in math.js work the same as in languages like JavaScript and Python.
An object is enclosed by curly brackets {, }, and contains a set of
comma separated key/value pairs. Keys and values are separated by a colon :.
Keys can be a symbol like prop or a string like "prop".

math.evaluate('{a: 2 + 1, b: 4}')         // {a: 3, b: 4}
math.evaluate('{"a": 2 + 1, "b": 4}')     // {a: 3, b: 4}


Objects can contain objects:

math.evaluate('{a: 2, b: {c: 3, d: 4}}')  // {a: 2, b: {c: 3, d: 4}}


Object properties can be retrieved or replaced using dot notation or bracket
notation. Unlike JavaScript, when setting a property value, the whole object
is returned, not the property value

let scope = {
  obj: {
    prop: 42
  }
}

// retrieve properties
math.evaluate('obj.prop', scope)          // 42
math.evaluate('obj["prop"]', scope)       // 42

// set properties (returns the whole object, not the property value!)
math.evaluate('obj.prop = 43', scope)     // {prop: 43}
math.evaluate('obj["prop"] = 43', scope)  // {prop: 43}
scope.obj                                 // {prop: 43}


Multi-line expressions #

An expression can contain multiple lines, and expressions can be spread over
multiple lines. Lines can be separated by a newline character \n or by a
semicolon ;. Output of statements followed by a semicolon will be hidden from
the output, and empty lines are ignored. The output is returned as a ResultSet,
with an entry for every visible statement.

// a multi-line expression
math.evaluate('1 * 3 \n 2 * 3 \n 3 * 3')    // ResultSet, [3, 6, 9]

// semicolon statements are hidden from the output
math.evaluate('a=3; b=4; a + b \n a * b')   // ResultSet, [7, 12]

// single expression spread over multiple lines
math.evaluate('a = 2 +\n  3')               // 5
math.evaluate('[\n  1, 2;\n  3, 4\n]')      // Matrix, [[1, 2], [3, 4]]


The results can be read from a ResultSet via the property ResultSet.entries
which is an Array, or by calling ResultSet.valueOf(), which returns the
array with results.

Implicit multiplication #

Implicit multiplication means the multiplication of two symbols, numbers, or a grouped expression inside parentheses without using the * operator. This type of syntax allows a more natural way to enter expressions. For example:

math.evaluate('2 pi')         // 6.283185307179586
math.evaluate('(1+2)(3+4)')   // 21


Parentheses are parsed as a function call when there is a symbol or accessor on
the left hand side, like sqrt(4) or obj.method(4). In other cases the
parentheses are interpreted as an implicit multiplication.

Math.js will always evaluate implicit multiplication before explicit multiplication *, so that the expression x * y z is parsed as x * (y * z). Math.js also gives implicit multiplication higher precedence than division, except when the division matches the pattern [unaryPrefixOp]?[number] / [number] [symbol] or [unaryPrefixOp]?[number] / [number] [left paren]. In that special case, the division is evaluated first:

math.evaluate('20 kg / 4 kg')   // 5      Evaluated as (20 kg) / (4 kg)
math.evaluate('20 / 4 kg')      // 5 kg   Evaluated as (20 / 4) kg


The behavior of implicit multiplication can be summarized by these operator precedence rules, listed from highest to lowest precedence:


  Function calls: [symbol] [left paren]
  Explicit division / when the division matches this pattern: [+-~]?[number] / [+-~]?[number] [symbol] or [number] / [number] [left paren]
  Implicit multiplication
  All other division / and multiplication *


Implicit multiplication is tricky as there can appear to be ambiguity in how an expression will be evaluated. Experience has shown that the above rules most closely match user intent when entering expressions that could be interpreted different ways. It’s also possible that these rules could be tweaked in future major releases.  Use implicit multiplication carefully. If you don’t like the uncertainty introduced by implicit multiplication, use explicit * operators and parentheses to ensure your expression is evaluated the way you intend.

Here are some more examples using implicit multiplication:


  
    
      Expression
      Evaluated as
      Result
    
  
  
    
      (1 + 3) pi
      (1 + 3) * pi
      12.566370614359172
    
    
      (4 - 1) 2
      (4 - 1) * 2
      6
    
    
      3 / 4 mm
      (3 / 4) * mm
      0.75 mm
    
    
      2 + 3 i
      2 + (3 * i)
      2 + 3i
    
    
      (1 + 2) (4 - 2)
      (1 + 2) * (4 - 2)
      6
    
    
      sqrt(4) (1 + 2)
      sqrt(4) * (1 + 2)
      6
    
    
      8 pi / 2 pi
      (8 * pi) / (2 * pi)
      4
    
    
      pi / 2 pi
      pi / (2 * pi)
      0.5
    
    
      1 / 2i
      (1 / 2) * i
      0.5 i
    
    
      8.314 J / mol K
      8.314 J / (mol * K)
      8.314 J / (mol * K)
    
  


Comments #

Comments can be added to explain or describe calculations in the text. A comment
starts with a sharp sign character #, and ends at the end of the line. A line
can contain a comment only, or can contain an expression followed by a comment.

const parser = math.parser()

parser.evaluate('# define some variables')
parser.evaluate('width = 3')                              // 3
parser.evaluate('height = 4')                             // 4
parser.evaluate('width * height   # calculate the area')  // 12\n\n\n\nExpression syntax #

This page describes the syntax of expression parser of math.js. It describes
how to work with the available data types, functions, operators, variables,
and more.

Differences from JavaScript #

The expression parser of math.js is aimed at a mathematical audience,
not a programming audience. The syntax is similar to most calculators and
mathematical applications. This is close to JavaScript as well, though there
are a few important differences between the syntax of the expression parser and
the lower level syntax of math.js. Differences are:


  No need to prefix functions and constants with the math.* namespace,
you can just enter sin(pi / 4).
  Matrix indexes are one-based instead of zero-based.
  There are index and range operators which allow more conveniently getting
and setting matrix indexes, like A[2:4, 1].
  Both indexes and ranges and have the upper-bound included.
  There is a differing syntax for defining functions. Example: f(x) = x^2.
  There are custom operators like x + y instead of add(x, y).
  Some operators are different. For example  ^ is used for exponentiation,
not bitwise xor.
  Implicit multiplication, like 2 pi, is supported and has special rules.
  Relational operators (<, >, <=, >=, ==, and !=) are chained, so the expression 5 < x < 10 is equivalent to 5 < x and x < 10.
  Multi-expression constructs like a = 1; b = 2; a + b or
"a = 1;\n cos(a)\n sin(a)" (where \n denotes newline)
produce a collection (“ResultSet”) of values. Those expressions
terminated by ; are evaluated for side effect only and their values
are suppressed from the result.


Operators #

The expression parser has operators for all common arithmetic operations such
as addition and multiplication. The expression parser uses conventional infix
notation for operators: an operator is placed between its arguments.
Round parentheses can be used to override the default precedence of operators.

// use operators
math.evaluate('2 + 3')       // 5
math.evaluate('2 * 3')       // 6

// use parentheses to override the default precedence
math.evaluate('2 + 3 * 4')   // 14
math.evaluate('(2 + 3) * 4') // 20


The following operators are available. Note that almost every operator listed
also has a function form with identical meaning that can be used
interchangeably. For example, x+y will always evaluate identically to
add(x,y). For a full list of the equivalences, see the section on
Functions below.


  
    
      Operator
      Name
      Syntax
      Associativity
      Example
      Result
    
  
  
    
      (, )
      Grouping
      (x)
      None
      2 * (3 + 4)
      14
    
    
      [, ]
      Matrix, Index
      [...]
      None
      [[1,2],[3,4]]
      [[1,2],[3,4]]
    
    
      {, }
      Object
      {...}
      None
      {a: 1, b: 2}
      {a: 1, b: 2}
    
    
      ,
      Parameter separator
      x, y
      Left to right
      max(2, 1, 5)
      5
    
    
      .
      Property accessor
      obj.prop
      Left to right
      obj={a: 12}; obj.a
      12
    
    
      ;
      Statement separator
      x; y
      Left to right
      a=2; b=3; a*b
      [6]
    
    
      ;
      Row separator
      [x; y]
      Left to right
      [1,2;3,4]
      [[1,2],[3,4]]
    
    
      \n
      Statement separator
      x \n y
      Left to right
      a=2 \n b=3 \n a*b
      [2,3,6]
    
    
      +
      Add
      x + y
      Left to right
      4 + 5
      9
    
    
      +
      Unary plus
      +y
      Right to left
      +4
      4
    
    
      -
      Subtract
      x - y
      Left to right
      7 - 3
      4
    
    
      -
      Unary minus
      -y
      Right to left
      -4
      -4
    
    
      *
      Multiply
      x * y
      Left to right
      2 * 3
      6
    
    
      .*
      Element-wise multiply
      x .* y
      Left to right
      [1,2,3] .* [1,2,3]
      [1,4,9]
    
    
      /
      Divide
      x / y
      Left to right
      6 / 2
      3
    
    
      ./
      Element-wise divide
      x ./ y
      Left to right
      [9,6,4] ./ [3,2,2]
      [3,3,2]
    
    
      %
      Percentage
      x%
      None
      8%
      0.08
    
    
      %
      Addition with Percentage
      x + y%
      Left to right
      100 + 3%
      103
    
    
      %
      Subtraction with Percentage
      x - y%
      Left to right
      100 - 3%
      97
    
    
      % mod
      Modulus
      x % y
      Left to right
      8 % 3
      2
    
    
      ^
      Power
      x ^ y
      Right to left
      2 ^ 3
      8
    
    
      .^
      Element-wise power
      x .^ y
      Right to left
      [2,3] .^ [3,3]
      [8,27]
    
    
      '
      Transpose
      y'
      Left to right
      [[1,2],[3,4]]'
      [[1,3],[2,4]]
    
    
      !
      Factorial
      y!
      Left to right
      5!
      120
    
    
      &
      Bitwise and
      x & y
      Left to right
      5 & 3
      1
    
    
      ~
      Bitwise not
      ~x
      Right to left
      ~2
      -3
    
    
      |
      Bitwise or
      x | y
      Left to right
      5 | 3
      7
    
    
      ^|
      Bitwise xor
      x ^| y
      Left to right
      5 ^| 2
      7
    
    
      <<
      Left shift
      x << y
      Left to right
      4 << 1
      8
    
    
      >>
      Right arithmetic shift
      x >> y
      Left to right
      8 >> 1
      4
    
    
      >>>
      Right logical shift
      x >>> y
      Left to right
      -8 >>> 1
      2147483644
    
    
      and
      Logical and
      x and y
      Left to right
      true and false
      false
    
    
      not
      Logical not
      not y
      Right to left
      not true
      false
    
    
      or
      Logical or
      x or y
      Left to right
      true or false
      true
    
    
      xor
      Logical xor
      x xor y
      Left to right
      true xor true
      false
    
    
      =
      Assignment
      x = y
      Right to left
      a = 5
      5
    
    
      ? :
      Conditional expression
      x ? y : z
      Right to left
      15 > 100 ? 1 : -1
      -1
    
    
      :
      Range
      x : y
      Right to left
      1:4
      [1,2,3,4]
    
    
      to, in
      Unit conversion
      x to y
      Left to right
      2 inch to cm
      5.08 cm
    
    
      ==
      Equal
      x == y
      Left to right
      2 == 4 - 2
      true
    
    
      !=
      Unequal
      x != y
      Left to right
      2 != 3
      true
    
    
      <
      Smaller
      x < y
      Left to right
      2 < 3
      true
    
    
      >
      Larger
      x > y
      Left to right
      2 > 3
      false
    
    
      <=
      Smallereq
      x <= y
      Left to right
      4 <= 3
      false
    
    
      >=
      Largereq
      x >= y
      Left to right
      2 + 4 >= 6
      true
    
  


Precedence #

The operators have the following precedence, from highest to lowest:


  
    
      Operators
      Description
    
  
  
    
      (...)[...]{...}
      GroupingMatrixObject
    
    
      x(...)x[...]obj.prop:
      Function callMatrix indexProperty accessorKey/value separator
    
    
      '
      Matrix transpose
    
    
      !
      Factorial
    
    
      ^, .^
      Exponentiation
    
    
      +, -, ~, not
      Unary plus, unary minus, bitwise not, logical not
    
    
      See section below
      Implicit multiplication
    
    
      *, /, .*, ./,%, mod
      Multiply, divide , percentage, modulus
    
    
      +, -
      Add, subtract
    
    
      :
      Range
    
    
      to, in
      Unit conversion
    
    
      <<, >>, >>>
      Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift
    
    
      ==, !=, <, >, <=, >=
      Relational
    
    
      &
      Bitwise and (lazily evaluated)
    
    
      ^|
      Bitwise xor
    
    
      |
      Bitwise or (lazily evaluated)
    
    
      and
      Logical and (lazily evaluated)
    
    
      xor
      Logical xor
    
    
      or
      Logical or (lazily evaluated)
    
    
      ?, :
      Conditional expression
    
    
      =
      Assignment
    
    
      ,
      Parameter and column separator
    
    
      ;
      Row separator
    
    
      \n, ;
      Statement separators
    
  


Lazy evaluation is used where logically possible for bitwise and logical
operators. In the following example, the value of x will not even be 
evaluated because it cannot effect the final result:
math.evaluate('false and x')        // false, no matter what x equals


Functions #

Functions are called by entering their name, followed by zero or more
arguments enclosed by parentheses. All available functions are listed on the
page Functions.

math.evaluate('sqrt(25)')           // 5
math.evaluate('log(10000, 3 + 7)')  // 4
math.evaluate('sin(pi / 4)')        // 0.7071067811865475


New functions can be defined by “assigning” an expression to a function call
with one or more variables. Such function assignments are limited: they can
only be defined on a single line.

const parser = math.parser()

parser.evaluate('f(x) = x ^ 2 - 5')
parser.evaluate('f(2)')     // -1
parser.evaluate('f(3)')     // 4

parser.evaluate('g(x, y) = x ^ y')
parser.evaluate('g(2, 3)')  // 8


Note that these function assignments do not create closures; put another way,
all free variables in mathjs are dynamic:

const parser = math.parser()

parser.evaluate('x = 7')
parser.evaluate('h(y) = x + y')
parser.evaluate('h(3)')         // 10
parser.evaluate('x = 3')
parser.evaluate('h(3)')         // 6, *not* 10


It is however possible to pass functions as parameters:

const parser = math.parser()

parser.evaluate('twice(func, x) = func(func(x))')
parser.evaluate('twice(square, 2)')    // 16
parser.evaluate('f(x) = 3*x')
parser.evaluate('twice(f, 2)')         // 18

// a simplistic "numerical derivative":
parser.evaluate('eps = 1e-10')
parser.evaluate('nd(f, x) = (f(x+eps) - func(x-eps))/(2*eps)')
parser.evaluate('nd(square,2)')        // 4.000000330961484


Math.js itself heavily uses typed functions, which ensure correct inputs and
throws meaningful errors when the input arguments are invalid. One can create
a typed-function in the
expression parser like:

const parser = math.parser()

parser.evaluate('f = typed({"number": f(x) = x ^ 2 - 5})')


Finally, as mentioned above, there is a function form for nearly every one of
the mathematical operator symbols. Moreover, for some associative operators,
the corresponding function allows arbitrarily many arguments. The table below
gives the full correspondence.


  
    
      Operator Expression
      Equivalent Function Expression
    
  
  
    
      a or b
      or(a,b)
    
    
      a xor b
      xor(a,b)
    
    
      a and b
      and(a,b)
    
    
      a \| b
      bitOr(a,b)
    
    
      a ^\| b
      bitXor(a,b)
    
    
      a & b
      bitAnd(a,b)
    
    
      a == b
      equal(a,b)
    
    
      a != b
      unequal(a,b)
    
    
      a < b
      smaller(a,b)
    
    
      a > b
      larger(a,b)
    
    
      a <= b
      smallerEq(a,b)
    
    
      a << 3
      leftShift(a,3)
    
    
      a >> 3
      rightArithShift(a,3)
    
    
      a >>> 3
      rightLogShift(a,3)
    
    
      u to cm
      to(u, cm)
    
    
      a + b + c + ...
      add(a,b,c,...)
    
    
      a - b
      subtract(a,b)
    
    
      a * b * c * ...
      multiply(a,b,c,...)
    
    
      A .* B
      dotMultiply(A,B)
    
    
      A ./ B
      dotDivide(A,B)
    
    
      a mod b
      mod(a,b)
    
    
      +a
      unaryPlus(a)
    
    
      -a
      unaryMinus(a)
    
    
      ~a
      bitNot(a)
    
    
      not a
      not(a)
    
    
      a^b
      pow(a,b)
    
    
      A .^ B
      dotPow(A,B)
    
    
      a!
      factorial(a)
    
    
      A'
      ctranspose(A)
    
  


Note that math.js embodies a preference for the operator forms, in that calling
simplify (see Algebra) converts any instances of the function
form into the corresponding operator.

Map and forEach #

The map and forEach functions can be used to apply a callback function to each element of an array or matrix.

The callback functions can be functions, typed functions, inline functions (only in the parser) or compiled inline functions (only in the parser).

The callback can have the following inputs:

  value: the current value in the array or matrix.
  index: the index of the current value expressed as an array of numbers.
  array: the array or matrix being iterated.


Below is the syntax for both functions:

map #

The map function applies a function to each element of an array and returns a new array with the results.

const parser = math.parser()

// Define a square function
parser.evaluate('square(x) = x ^ 2')

// Apply the square function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], square)')
// result: [1, 4, 9, 16]

// Apply an inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], f(x) = x ^ 2)')
// result: [1, 4, 9, 16]

// Apply a compiled inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], x ^ 2)')
// result: [1, 4, 9, 16]


forEach #
The forEach function applies a function to each element of an array or matrix but does not return a new array. It is useful for executing side effects.

// Define a function that prints each element
math.import({consoleLog: x => console.log(x)})
const parser = math.parser()

// Define a squareConsleLog function
parser.evaluate('squareConsoleLog(x) = consoleLog(x ^ 2)')

// Apply the squareConsleLog function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], squareConsleLog)')
// Prints: 1, 4, 9, 16

// Apply an inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], f(x) = consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16

// Apply a compiled inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16


These functions are useful for performing element-wise operations on arrays or matrices.

Constants and variables #

Math.js has a number of built-in constants such as pi and e.
All available constants are listed on he page
Constants.

// use constants
math.evaluate('pi')                 // 3.141592653589793
math.evaluate('e ^ 2')              // 7.3890560989306495
math.evaluate('log(e)')             // 1
math.evaluate('e ^ (pi * i) + 1')   // ~0 (Euler)


Variables can be defined using the assignment operator =, and can be used
like constants.

const parser = math.parser()

// define variables
parser.evaluate('a = 3.4')      // 3.4
parser.evaluate('b = 5 / 2')    // 2.5

// use variables
parser.evaluate('a * b')        // 8.5


Variable names must:


  Begin with an “alpha character”, which is:
    
      A latin letter (upper or lower case). Ascii: a-z, A-Z
      An underscore.                        Ascii: _
      A dollar sign.                        Ascii: $
      A latin letter with accents.          Unicode: \u00C0 - \u02AF
      A greek letter.                       Unicode: \u0370 - \u03FF
      A letter-like character.              Unicode: \u2100 - \u214F
      A mathematical alphanumeric symbol.   Unicode: \u{1D400} - \u{1D7FF} excluding invalid code points
    
  
  Contain only alpha characters (above) and digits 0-9
  Not be any of the following: mod, to, in, and, xor, or, not, end. It is possible to assign to some of these, but that’s not recommended.


It is possible to customize the allowed alpha characters, see Customize supported characters for more information.

Data types #

The expression parser supports booleans, numbers, complex numbers, units,
strings, matrices, and objects.

Booleans #

Booleans true and false can be used in expressions.

// use booleans
math.evaluate('true')               // true
math.evaluate('false')              // false
math.evaluate('(2 == 3) == false')  // true


Booleans can be converted to numbers and strings and vice versa using the
functions number and boolean, and string.

// convert booleans
math.evaluate('number(true)')       // 1
math.evaluate('string(false)')      // "false"
math.evaluate('boolean(1)')         // true
math.evaluate('boolean("false")')   // false


Numbers #

The most important and basic data type in math.js are numbers. Numbers use a
point as decimal mark. Numbers can be entered with exponential notation.
Examples:

// numbers in math.js
math.evaluate('2')        // 2
math.evaluate('3.14')     // 3.14
math.evaluate('1.4e3')    // 1400
math.evaluate('22e-3')    // 0.022


A number can be converted to a string and vice versa using the functions
number and string.

// convert a string into a number
math.evaluate('number("2.3")')    // 2.3
math.evaluate('string(2.3)')      // "2.3"


Math.js uses regular JavaScript numbers, which are floating points with a
limited precision and limited range. The limitations are described in detail
on the page Numbers.

math.evaluate('1e-325')   // 0
math.evaluate('1e309')    // Infinity
math.evaluate('-1e309')   // -Infinity


When doing calculations with floats, one can very easily get round-off errors:

// round-off error due to limited floating point precision
math.evaluate('0.1 + 0.2')  // 0.30000000000000004


When outputting results, the function math.format can be used to hide
these round-off errors when outputting results for the user:

const ans = math.evaluate('0.1 + 0.2')  //  0.30000000000000004
math.format(ans, {precision: 14})       // "0.3"


Numbers can be expressed as binary, octal, and hexadecimal literals:

math.evaluate('0b11')  //  3
math.evaluate('0o77')  //  63
math.evaluate('0xff')  //  255


A word size suffix can be used to change the behavior of non decimal literal evaluation:

math.evaluate('0xffi8')         // -1
math.evaluate('0xffffffffi32')  //  -1
math.evaluate('0xfffffffffi32') //  SyntaxError: String "0xfffffffff" is out of range


Non decimal numbers can include a radix point:
math.evaluate('0b1.1')         // 1.5
math.evaluate('0o1.4')         // 1.5
math.evaluate('0x1.8')         // 1.5


Numbers can be formatted as binary, octal, and hex strings using the notation option of the format function:

math.evaluate('format(3, {notation: "bin"})')    //  '0b11'
math.evaluate('format(63, {notation: "oct"})')   //  '0o77'
math.evaluate('format(255, {notation: "hex"})')  //  '0xff'
math.evaluate('format(-1, {notation: "hex"})')   //  '-0x1'
math.evaluate('format(2.3, {notation: "hex"})')  //  '0x2.4cccccccccccc'


The format function accepts a wordSize option to use in conjunction with the non binary notations:

math.evaluate('format(-1, {notation: "hex", wordSize: 8})')   //  '0xffi8'


The functions bin, oct, and hex are shorthand for the format function with notation set accordingly:

math.evaluate('bin(-1)')     // '-0b1'
math.evaluate('bin(-1, 8)')  // '0b11111111i8'


BigNumbers #

Math.js supports BigNumbers for calculations with an arbitrary precision.
The pros and cons of Number and BigNumber are explained in detail on the page
Numbers.

BigNumbers are slower but have a higher precision. Calculations with big
numbers are supported only by arithmetic functions.

BigNumbers can be created using the bignumber function:

math.evaluate('bignumber(0.1) + bignumber(0.2)') // BigNumber, 0.3


The default number type of the expression parser can be changed at instantiation
of math.js. The expression parser parses numbers as BigNumber by default:

// Configure the type of number: 'number' (default), 'BigNumber', or 'Fraction'
math.config({number: 'BigNumber'})

// all numbers are parsed as BigNumber
math.evaluate('0.1 + 0.2')  // BigNumber, 0.3


BigNumbers can be converted to numbers and vice versa using the functions
number and bignumber. When converting a BigNumber to a Number, the high
precision of the BigNumber will be lost. When a BigNumber is too large to be represented
as Number, it will be initialized as Infinity.

Complex numbers #

Complex numbers can be created using the imaginary unit i, which is defined
as i^2 = -1. Complex numbers have a real and complex part, which can be
retrieved using the functions re and im.

const parser = math.parser()

// create complex numbers
parser.evaluate('a = 2 + 3i')   // Complex, 2 + 3i
parser.evaluate('b = 4 - i')    // Complex, 4 - i

// get real and imaginary part of a complex number
parser.evaluate('re(a)')        // Number,  2
parser.evaluate('im(a)')        // Number,  3

// calculations with complex numbers
parser.evaluate('a + b')        // Complex, 6 + 2i
parser.evaluate('a * b')        // Complex, 11 + 10i
parser.evaluate('i * i')        // Number,  -1
parser.evaluate('sqrt(-4)')     // Complex, 2i


Units #

math.js supports units. Units can be used in the arithmetic operations
add, subtract, multiply, divide, and exponentiation.
Units can also be converted from one to another.
An overview of all available units can be found on the page
Units.

Units can be converted using the operator to or in.

// create a unit
math.evaluate('5.4 kg')                     // Unit, 5.4 kg

// convert a unit
math.evaluate('2 inch to cm')               // Unit, 5.08 cm
math.evaluate('20 celsius in fahrenheit')   // Unit, ~68 fahrenheit
math.evaluate('90 km/h to m/s')             // Unit, 25 m / s

// convert a unit to a number
// A second parameter with the unit for the exported number must be provided
math.evaluate('number(5 cm, mm)')           // Number, 50

// calculations with units
math.evaluate('0.5kg + 33g')                // Unit, 0.533 kg
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('12 seconds * 2')             // Unit, 24 seconds
math.evaluate('sin(45 deg)')                // Number, 0.7071067811865475
math.evaluate('9.81 m/s^2 * 5 s to mi/h')   // Unit, 109.72172512527 mi / h


Strings #

Strings are enclosed by double quotes “ or single quotes ‘. Strings can be concatenated using the
function concat (not by adding them using + like in JavaScript). Parts of
a string can be retrieved or replaced by using indexes. Strings can be converted
to a number using function number, and numbers can be converted to a string
using function string.

When setting the value of a character in a string, the character that has been
set is returned. Likewise, when a range of characters is set, that range of
characters is returned.

const parser = math.parser()

// create a string
parser.evaluate('"hello"')                        // String, "hello"

// string manipulation
parser.evaluate('a = concat("hello", " world")')  // String, "hello world"
parser.evaluate('size(a)')                        // Matrix [11]
parser.evaluate('a[1:5]')                         // String, "hello"
parser.evaluate('a[1] = "H"')                     // String, "H"
parser.evaluate('a[7:12] = "there!"')             // String, "there!"
parser.evaluate('a')                              // String, "Hello there!"

// string conversion
parser.evaluate('number("300")')                  // Number, 300
parser.evaluate('string(300)')                    // String, "300"


Strings can be used in the evaluate function, to parse expressions inside
the expression parser:

math.evaluate('evaluate("2 + 3")')  // 5


Matrices #

Matrices can be created by entering a series of values between square brackets,
elements are separated by a comma ,.
A matrix like [1, 2, 3] will create a vector, a 1-dimensional matrix with
size [3]. To create a multi-dimensional matrix, matrices can be nested into
each other. For easier creation of two-dimensional matrices, a semicolon ;
can be used to separate rows in a matrix.

// create a matrix
math.evaluate('[1, 2, 3]')                                // Matrix, size [3]
math.evaluate('[[1, 2, 3], [4, 5, 6]]')                   // Matrix, size [2, 3]
math.evaluate('[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]')     // Matrix, size [2, 2, 2]

// create a two dimensional matrix
math.evaluate('[1, 2, 3; 4, 5, 6]')                       // Matrix, size [2, 3]


Another way to create filled matrices is using the functions zeros, ones,
identity, and range.

// initialize a matrix with ones or zeros
math.evaluate('zeros(3, 2)')      // Matrix, [[0, 0], [0, 0], [0, 0]],  size [3, 2]
math.evaluate('ones(3)')          // Matrix, [1, 1, 1],                 size [3]
math.evaluate('5 * ones(2, 2)')   // Matrix, [[5, 5], [5, 5]],          size [2, 2]

// create an identity matrix
math.evaluate('identity(2)')      // Matrix, [[1, 0], [0, 1]],          size [2, 2]

// create a range
math.evaluate('1:4')              // Matrix, [1, 2, 3, 4],              size [4]
math.evaluate('0:2:10')           // Matrix, [0, 2, 4, 6, 8, 10],       size [6]


A subset can be retrieved from a matrix using indexes and a subset of a matrix
can be replaced by using indexes. Indexes are enclosed in square brackets, and
contain a number or a range for each of the matrix dimensions. A range can have
its start and/or end undefined. When the start is undefined, the range will start
at 1, when the end is undefined, the range will end at the end of the matrix.

There is a context variable end available as well to denote the end of the
matrix. This variable cannot be used in multiple nested indices. In that case,
end will be resolved as the end of the innermost matrix. To solve this, 
resolving of the nested index needs to be split in two separate operations.

IMPORTANT: matrix indexes and ranges work differently from the math.js indexes
in JavaScript: They are one-based with an included upper-bound, similar to most
math applications.

parser = math.parser()

// create matrices
parser.evaluate('a = [1, 2; 3, 4]')       // Matrix, [[1, 2], [3, 4]]
parser.evaluate('b = zeros(2, 2)')        // Matrix, [[0, 0], [0, 0]]
parser.evaluate('c = 5:9')                // Matrix, [5, 6, 7, 8, 9]

// replace a subset in a matrix
parser.evaluate('b[1, 1:2] = [5, 6]')     // Matrix, [[5, 6], [0, 0]]
parser.evaluate('b[2, :] = [7, 8]')       // Matrix, [[5, 6], [7, 8]]

// perform a matrix calculation
parser.evaluate('d = a * b')              // Matrix, [[19, 22], [43, 50]]

// retrieve a subset of a matrix
parser.evaluate('d[2, 1]')                // 43
parser.evaluate('d[2, 1:end]')            // Matrix, [[43, 50]]
parser.evaluate('c[end - 1 : -1 : 2]')    // Matrix, [8, 7, 6]


Objects #

Objects in math.js work the same as in languages like JavaScript and Python.
An object is enclosed by curly brackets {, }, and contains a set of
comma separated key/value pairs. Keys and values are separated by a colon :.
Keys can be a symbol like prop or a string like "prop".

math.evaluate('{a: 2 + 1, b: 4}')         // {a: 3, b: 4}
math.evaluate('{"a": 2 + 1, "b": 4}')     // {a: 3, b: 4}


Objects can contain objects:

math.evaluate('{a: 2, b: {c: 3, d: 4}}')  // {a: 2, b: {c: 3, d: 4}}


Object properties can be retrieved or replaced using dot notation or bracket
notation. Unlike JavaScript, when setting a property value, the whole object
is returned, not the property value

let scope = {
  obj: {
    prop: 42
  }
}

// retrieve properties
math.evaluate('obj.prop', scope)          // 42
math.evaluate('obj["prop"]', scope)       // 42

// set properties (returns the whole object, not the property value!)
math.evaluate('obj.prop = 43', scope)     // {prop: 43}
math.evaluate('obj["prop"] = 43', scope)  // {prop: 43}
scope.obj                                 // {prop: 43}


Multi-line expressions #

An expression can contain multiple lines, and expressions can be spread over
multiple lines. Lines can be separated by a newline character \n or by a
semicolon ;. Output of statements followed by a semicolon will be hidden from
the output, and empty lines are ignored. The output is returned as a ResultSet,
with an entry for every visible statement.

// a multi-line expression
math.evaluate('1 * 3 \n 2 * 3 \n 3 * 3')    // ResultSet, [3, 6, 9]

// semicolon statements are hidden from the output
math.evaluate('a=3; b=4; a + b \n a * b')   // ResultSet, [7, 12]

// single expression spread over multiple lines
math.evaluate('a = 2 +\n  3')               // 5
math.evaluate('[\n  1, 2;\n  3, 4\n]')      // Matrix, [[1, 2], [3, 4]]


The results can be read from a ResultSet via the property ResultSet.entries
which is an Array, or by calling ResultSet.valueOf(), which returns the
array with results.

Implicit multiplication #

Implicit multiplication means the multiplication of two symbols, numbers, or a grouped expression inside parentheses without using the * operator. This type of syntax allows a more natural way to enter expressions. For example:

math.evaluate('2 pi')         // 6.283185307179586
math.evaluate('(1+2)(3+4)')   // 21


Parentheses are parsed as a function call when there is a symbol or accessor on
the left hand side, like sqrt(4) or obj.method(4). In other cases the
parentheses are interpreted as an implicit multiplication.

Math.js will always evaluate implicit multiplication before explicit multiplication *, so that the expression x * y z is parsed as x * (y * z). Math.js also gives implicit multiplication higher precedence than division, except when the division matches the pattern [unaryPrefixOp]?[number] / [number] [symbol] or [unaryPrefixOp]?[number] / [number] [left paren]. In that special case, the division is evaluated first:

math.evaluate('20 kg / 4 kg')   // 5      Evaluated as (20 kg) / (4 kg)
math.evaluate('20 / 4 kg')      // 5 kg   Evaluated as (20 / 4) kg


The behavior of implicit multiplication can be summarized by these operator precedence rules, listed from highest to lowest precedence:


  Function calls: [symbol] [left paren]
  Explicit division / when the division matches this pattern: [+-~]?[number] / [+-~]?[number] [symbol] or [number] / [number] [left paren]
  Implicit multiplication
  All other division / and multiplication *


Implicit multiplication is tricky as there can appear to be ambiguity in how an expression will be evaluated. Experience has shown that the above rules most closely match user intent when entering expressions that could be interpreted different ways. It’s also possible that these rules could be tweaked in future major releases.  Use implicit multiplication carefully. If you don’t like the uncertainty introduced by implicit multiplication, use explicit * operators and parentheses to ensure your expression is evaluated the way you intend.

Here are some more examples using implicit multiplication:


  
    
      Expression
      Evaluated as
      Result
    
  
  
    
      (1 + 3) pi
      (1 + 3) * pi
      12.566370614359172
    
    
      (4 - 1) 2
      (4 - 1) * 2
      6
    
    
      3 / 4 mm
      (3 / 4) * mm
      0.75 mm
    
    
      2 + 3 i
      2 + (3 * i)
      2 + 3i
    
    
      (1 + 2) (4 - 2)
      (1 + 2) * (4 - 2)
      6
    
    
      sqrt(4) (1 + 2)
      sqrt(4) * (1 + 2)
      6
    
    
      8 pi / 2 pi
      (8 * pi) / (2 * pi)
      4
    
    
      pi / 2 pi
      pi / (2 * pi)
      0.5
    
    
      1 / 2i
      (1 / 2) * i
      0.5 i
    
    
      8.314 J / mol K
      8.314 J / (mol * K)
      8.314 J / (mol * K)
    
  


Comments #

Comments can be added to explain or describe calculations in the text. A comment
starts with a sharp sign character #, and ends at the end of the line. A line
can contain a comment only, or can contain an expression followed by a comment.

const parser = math.parser()

parser.evaluate('# define some variables')
parser.evaluate('width = 3')                              // 3
parser.evaluate('height = 4')                             // 4
parser.evaluate('width * height   # calculate the area')  // 12\n\n\n\nExpression syntax #

This page describes the syntax of expression parser of math.js. It describes
how to work with the available data types, functions, operators, variables,
and more.

Differences from JavaScript #

The expression parser of math.js is aimed at a mathematical audience,
not a programming audience. The syntax is similar to most calculators and
mathematical applications. This is close to JavaScript as well, though there
are a few important differences between the syntax of the expression parser and
the lower level syntax of math.js. Differences are:


  No need to prefix functions and constants with the math.* namespace,
you can just enter sin(pi / 4).
  Matrix indexes are one-based instead of zero-based.
  There are index and range operators which allow more conveniently getting
and setting matrix indexes, like A[2:4, 1].
  Both indexes and ranges and have the upper-bound included.
  There is a differing syntax for defining functions. Example: f(x) = x^2.
  There are custom operators like x + y instead of add(x, y).
  Some operators are different. For example  ^ is used for exponentiation,
not bitwise xor.
  Implicit multiplication, like 2 pi, is supported and has special rules.
  Relational operators (<, >, <=, >=, ==, and !=) are chained, so the expression 5 < x < 10 is equivalent to 5 < x and x < 10.
  Multi-expression constructs like a = 1; b = 2; a + b or
"a = 1;\n cos(a)\n sin(a)" (where \n denotes newline)
produce a collection (“ResultSet”) of values. Those expressions
terminated by ; are evaluated for side effect only and their values
are suppressed from the result.


Operators #

The expression parser has operators for all common arithmetic operations such
as addition and multiplication. The expression parser uses conventional infix
notation for operators: an operator is placed between its arguments.
Round parentheses can be used to override the default precedence of operators.

// use operators
math.evaluate('2 + 3')       // 5
math.evaluate('2 * 3')       // 6

// use parentheses to override the default precedence
math.evaluate('2 + 3 * 4')   // 14
math.evaluate('(2 + 3) * 4') // 20


The following operators are available. Note that almost every operator listed
also has a function form with identical meaning that can be used
interchangeably. For example, x+y will always evaluate identically to
add(x,y). For a full list of the equivalences, see the section on
Functions below.


  
    
      Operator
      Name
      Syntax
      Associativity
      Example
      Result
    
  
  
    
      (, )
      Grouping
      (x)
      None
      2 * (3 + 4)
      14
    
    
      [, ]
      Matrix, Index
      [...]
      None
      [[1,2],[3,4]]
      [[1,2],[3,4]]
    
    
      {, }
      Object
      {...}
      None
      {a: 1, b: 2}
      {a: 1, b: 2}
    
    
      ,
      Parameter separator
      x, y
      Left to right
      max(2, 1, 5)
      5
    
    
      .
      Property accessor
      obj.prop
      Left to right
      obj={a: 12}; obj.a
      12
    
    
      ;
      Statement separator
      x; y
      Left to right
      a=2; b=3; a*b
      [6]
    
    
      ;
      Row separator
      [x; y]
      Left to right
      [1,2;3,4]
      [[1,2],[3,4]]
    
    
      \n
      Statement separator
      x \n y
      Left to right
      a=2 \n b=3 \n a*b
      [2,3,6]
    
    
      +
      Add
      x + y
      Left to right
      4 + 5
      9
    
    
      +
      Unary plus
      +y
      Right to left
      +4
      4
    
    
      -
      Subtract
      x - y
      Left to right
      7 - 3
      4
    
    
      -
      Unary minus
      -y
      Right to left
      -4
      -4
    
    
      *
      Multiply
      x * y
      Left to right
      2 * 3
      6
    
    
      .*
      Element-wise multiply
      x .* y
      Left to right
      [1,2,3] .* [1,2,3]
      [1,4,9]
    
    
      /
      Divide
      x / y
      Left to right
      6 / 2
      3
    
    
      ./
      Element-wise divide
      x ./ y
      Left to right
      [9,6,4] ./ [3,2,2]
      [3,3,2]
    
    
      %
      Percentage
      x%
      None
      8%
      0.08
    
    
      %
      Addition with Percentage
      x + y%
      Left to right
      100 + 3%
      103
    
    
      %
      Subtraction with Percentage
      x - y%
      Left to right
      100 - 3%
      97
    
    
      % mod
      Modulus
      x % y
      Left to right
      8 % 3
      2
    
    
      ^
      Power
      x ^ y
      Right to left
      2 ^ 3
      8
    
    
      .^
      Element-wise power
      x .^ y
      Right to left
      [2,3] .^ [3,3]
      [8,27]
    
    
      '
      Transpose
      y'
      Left to right
      [[1,2],[3,4]]'
      [[1,3],[2,4]]
    
    
      !
      Factorial
      y!
      Left to right
      5!
      120
    
    
      &
      Bitwise and
      x & y
      Left to right
      5 & 3
      1
    
    
      ~
      Bitwise not
      ~x
      Right to left
      ~2
      -3
    
    
      |
      Bitwise or
      x | y
      Left to right
      5 | 3
      7
    
    
      ^|
      Bitwise xor
      x ^| y
      Left to right
      5 ^| 2
      7
    
    
      <<
      Left shift
      x << y
      Left to right
      4 << 1
      8
    
    
      >>
      Right arithmetic shift
      x >> y
      Left to right
      8 >> 1
      4
    
    
      >>>
      Right logical shift
      x >>> y
      Left to right
      -8 >>> 1
      2147483644
    
    
      and
      Logical and
      x and y
      Left to right
      true and false
      false
    
    
      not
      Logical not
      not y
      Right to left
      not true
      false
    
    
      or
      Logical or
      x or y
      Left to right
      true or false
      true
    
    
      xor
      Logical xor
      x xor y
      Left to right
      true xor true
      false
    
    
      =
      Assignment
      x = y
      Right to left
      a = 5
      5
    
    
      ? :
      Conditional expression
      x ? y : z
      Right to left
      15 > 100 ? 1 : -1
      -1
    
    
      :
      Range
      x : y
      Right to left
      1:4
      [1,2,3,4]
    
    
      to, in
      Unit conversion
      x to y
      Left to right
      2 inch to cm
      5.08 cm
    
    
      ==
      Equal
      x == y
      Left to right
      2 == 4 - 2
      true
    
    
      !=
      Unequal
      x != y
      Left to right
      2 != 3
      true
    
    
      <
      Smaller
      x < y
      Left to right
      2 < 3
      true
    
    
      >
      Larger
      x > y
      Left to right
      2 > 3
      false
    
    
      <=
      Smallereq
      x <= y
      Left to right
      4 <= 3
      false
    
    
      >=
      Largereq
      x >= y
      Left to right
      2 + 4 >= 6
      true
    
  


Precedence #

The operators have the following precedence, from highest to lowest:


  
    
      Operators
      Description
    
  
  
    
      (...)[...]{...}
      GroupingMatrixObject
    
    
      x(...)x[...]obj.prop:
      Function callMatrix indexProperty accessorKey/value separator
    
    
      '
      Matrix transpose
    
    
      !
      Factorial
    
    
      ^, .^
      Exponentiation
    
    
      +, -, ~, not
      Unary plus, unary minus, bitwise not, logical not
    
    
      See section below
      Implicit multiplication
    
    
      *, /, .*, ./,%, mod
      Multiply, divide , percentage, modulus
    
    
      +, -
      Add, subtract
    
    
      :
      Range
    
    
      to, in
      Unit conversion
    
    
      <<, >>, >>>
      Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift
    
    
      ==, !=, <, >, <=, >=
      Relational
    
    
      &
      Bitwise and (lazily evaluated)
    
    
      ^|
      Bitwise xor
    
    
      |
      Bitwise or (lazily evaluated)
    
    
      and
      Logical and (lazily evaluated)
    
    
      xor
      Logical xor
    
    
      or
      Logical or (lazily evaluated)
    
    
      ?, :
      Conditional expression
    
    
      =
      Assignment
    
    
      ,
      Parameter and column separator
    
    
      ;
      Row separator
    
    
      \n, ;
      Statement separators
    
  


Lazy evaluation is used where logically possible for bitwise and logical
operators. In the following example, the value of x will not even be 
evaluated because it cannot effect the final result:
math.evaluate('false and x')        // false, no matter what x equals


Functions #

Functions are called by entering their name, followed by zero or more
arguments enclosed by parentheses. All available functions are listed on the
page Functions.

math.evaluate('sqrt(25)')           // 5
math.evaluate('log(10000, 3 + 7)')  // 4
math.evaluate('sin(pi / 4)')        // 0.7071067811865475


New functions can be defined by “assigning” an expression to a function call
with one or more variables. Such function assignments are limited: they can
only be defined on a single line.

const parser = math.parser()

parser.evaluate('f(x) = x ^ 2 - 5')
parser.evaluate('f(2)')     // -1
parser.evaluate('f(3)')     // 4

parser.evaluate('g(x, y) = x ^ y')
parser.evaluate('g(2, 3)')  // 8


Note that these function assignments do not create closures; put another way,
all free variables in mathjs are dynamic:

const parser = math.parser()

parser.evaluate('x = 7')
parser.evaluate('h(y) = x + y')
parser.evaluate('h(3)')         // 10
parser.evaluate('x = 3')
parser.evaluate('h(3)')         // 6, *not* 10


It is however possible to pass functions as parameters:

const parser = math.parser()

parser.evaluate('twice(func, x) = func(func(x))')
parser.evaluate('twice(square, 2)')    // 16
parser.evaluate('f(x) = 3*x')
parser.evaluate('twice(f, 2)')         // 18

// a simplistic "numerical derivative":
parser.evaluate('eps = 1e-10')
parser.evaluate('nd(f, x) = (f(x+eps) - func(x-eps))/(2*eps)')
parser.evaluate('nd(square,2)')        // 4.000000330961484


Math.js itself heavily uses typed functions, which ensure correct inputs and
throws meaningful errors when the input arguments are invalid. One can create
a typed-function in the
expression parser like:

const parser = math.parser()

parser.evaluate('f = typed({"number": f(x) = x ^ 2 - 5})')


Finally, as mentioned above, there is a function form for nearly every one of
the mathematical operator symbols. Moreover, for some associative operators,
the corresponding function allows arbitrarily many arguments. The table below
gives the full correspondence.


  
    
      Operator Expression
      Equivalent Function Expression
    
  
  
    
      a or b
      or(a,b)
    
    
      a xor b
      xor(a,b)
    
    
      a and b
      and(a,b)
    
    
      a \| b
      bitOr(a,b)
    
    
      a ^\| b
      bitXor(a,b)
    
    
      a & b
      bitAnd(a,b)
    
    
      a == b
      equal(a,b)
    
    
      a != b
      unequal(a,b)
    
    
      a < b
      smaller(a,b)
    
    
      a > b
      larger(a,b)
    
    
      a <= b
      smallerEq(a,b)
    
    
      a << 3
      leftShift(a,3)
    
    
      a >> 3
      rightArithShift(a,3)
    
    
      a >>> 3
      rightLogShift(a,3)
    
    
      u to cm
      to(u, cm)
    
    
      a + b + c + ...
      add(a,b,c,...)
    
    
      a - b
      subtract(a,b)
    
    
      a * b * c * ...
      multiply(a,b,c,...)
    
    
      A .* B
      dotMultiply(A,B)
    
    
      A ./ B
      dotDivide(A,B)
    
    
      a mod b
      mod(a,b)
    
    
      +a
      unaryPlus(a)
    
    
      -a
      unaryMinus(a)
    
    
      ~a
      bitNot(a)
    
    
      not a
      not(a)
    
    
      a^b
      pow(a,b)
    
    
      A .^ B
      dotPow(A,B)
    
    
      a!
      factorial(a)
    
    
      A'
      ctranspose(A)
    
  


Note that math.js embodies a preference for the operator forms, in that calling
simplify (see Algebra) converts any instances of the function
form into the corresponding operator.

Map and forEach #

The map and forEach functions can be used to apply a callback function to each element of an array or matrix.

The callback functions can be functions, typed functions, inline functions (only in the parser) or compiled inline functions (only in the parser).

The callback can have the following inputs:

  value: the current value in the array or matrix.
  index: the index of the current value expressed as an array of numbers.
  array: the array or matrix being iterated.


Below is the syntax for both functions:

map #

The map function applies a function to each element of an array and returns a new array with the results.

const parser = math.parser()

// Define a square function
parser.evaluate('square(x) = x ^ 2')

// Apply the square function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], square)')
// result: [1, 4, 9, 16]

// Apply an inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], f(x) = x ^ 2)')
// result: [1, 4, 9, 16]

// Apply a compiled inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], x ^ 2)')
// result: [1, 4, 9, 16]


forEach #
The forEach function applies a function to each element of an array or matrix but does not return a new array. It is useful for executing side effects.

// Define a function that prints each element
math.import({consoleLog: x => console.log(x)})
const parser = math.parser()

// Define a squareConsleLog function
parser.evaluate('squareConsoleLog(x) = consoleLog(x ^ 2)')

// Apply the squareConsleLog function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], squareConsleLog)')
// Prints: 1, 4, 9, 16

// Apply an inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], f(x) = consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16

// Apply a compiled inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16


These functions are useful for performing element-wise operations on arrays or matrices.

Constants and variables #

Math.js has a number of built-in constants such as pi and e.
All available constants are listed on he page
Constants.

// use constants
math.evaluate('pi')                 // 3.141592653589793
math.evaluate('e ^ 2')              // 7.3890560989306495
math.evaluate('log(e)')             // 1
math.evaluate('e ^ (pi * i) + 1')   // ~0 (Euler)


Variables can be defined using the assignment operator =, and can be used
like constants.

const parser = math.parser()

// define variables
parser.evaluate('a = 3.4')      // 3.4
parser.evaluate('b = 5 / 2')    // 2.5

// use variables
parser.evaluate('a * b')        // 8.5


Variable names must:


  Begin with an “alpha character”, which is:
    
      A latin letter (upper or lower case). Ascii: a-z, A-Z
      An underscore.                        Ascii: _
      A dollar sign.                        Ascii: $
      A latin letter with accents.          Unicode: \u00C0 - \u02AF
      A greek letter.                       Unicode: \u0370 - \u03FF
      A letter-like character.              Unicode: \u2100 - \u214F
      A mathematical alphanumeric symbol.   Unicode: \u{1D400} - \u{1D7FF} excluding invalid code points
    
  
  Contain only alpha characters (above) and digits 0-9
  Not be any of the following: mod, to, in, and, xor, or, not, end. It is possible to assign to some of these, but that’s not recommended.


It is possible to customize the allowed alpha characters, see Customize supported characters for more information.

Data types #

The expression parser supports booleans, numbers, complex numbers, units,
strings, matrices, and objects.

Booleans #

Booleans true and false can be used in expressions.

// use booleans
math.evaluate('true')               // true
math.evaluate('false')              // false
math.evaluate('(2 == 3) == false')  // true


Booleans can be converted to numbers and strings and vice versa using the
functions number and boolean, and string.

// convert booleans
math.evaluate('number(true)')       // 1
math.evaluate('string(false)')      // "false"
math.evaluate('boolean(1)')         // true
math.evaluate('boolean("false")')   // false


Numbers #

The most important and basic data type in math.js are numbers. Numbers use a
point as decimal mark. Numbers can be entered with exponential notation.
Examples:

// numbers in math.js
math.evaluate('2')        // 2
math.evaluate('3.14')     // 3.14
math.evaluate('1.4e3')    // 1400
math.evaluate('22e-3')    // 0.022


A number can be converted to a string and vice versa using the functions
number and string.

// convert a string into a number
math.evaluate('number("2.3")')    // 2.3
math.evaluate('string(2.3)')      // "2.3"


Math.js uses regular JavaScript numbers, which are floating points with a
limited precision and limited range. The limitations are described in detail
on the page Numbers.

math.evaluate('1e-325')   // 0
math.evaluate('1e309')    // Infinity
math.evaluate('-1e309')   // -Infinity


When doing calculations with floats, one can very easily get round-off errors:

// round-off error due to limited floating point precision
math.evaluate('0.1 + 0.2')  // 0.30000000000000004


When outputting results, the function math.format can be used to hide
these round-off errors when outputting results for the user:

const ans = math.evaluate('0.1 + 0.2')  //  0.30000000000000004
math.format(ans, {precision: 14})       // "0.3"


Numbers can be expressed as binary, octal, and hexadecimal literals:

math.evaluate('0b11')  //  3
math.evaluate('0o77')  //  63
math.evaluate('0xff')  //  255


A word size suffix can be used to change the behavior of non decimal literal evaluation:

math.evaluate('0xffi8')         // -1
math.evaluate('0xffffffffi32')  //  -1
math.evaluate('0xfffffffffi32') //  SyntaxError: String "0xfffffffff" is out of range


Non decimal numbers can include a radix point:
math.evaluate('0b1.1')         // 1.5
math.evaluate('0o1.4')         // 1.5
math.evaluate('0x1.8')         // 1.5


Numbers can be formatted as binary, octal, and hex strings using the notation option of the format function:

math.evaluate('format(3, {notation: "bin"})')    //  '0b11'
math.evaluate('format(63, {notation: "oct"})')   //  '0o77'
math.evaluate('format(255, {notation: "hex"})')  //  '0xff'
math.evaluate('format(-1, {notation: "hex"})')   //  '-0x1'
math.evaluate('format(2.3, {notation: "hex"})')  //  '0x2.4cccccccccccc'


The format function accepts a wordSize option to use in conjunction with the non binary notations:

math.evaluate('format(-1, {notation: "hex", wordSize: 8})')   //  '0xffi8'


The functions bin, oct, and hex are shorthand for the format function with notation set accordingly:

math.evaluate('bin(-1)')     // '-0b1'
math.evaluate('bin(-1, 8)')  // '0b11111111i8'


BigNumbers #

Math.js supports BigNumbers for calculations with an arbitrary precision.
The pros and cons of Number and BigNumber are explained in detail on the page
Numbers.

BigNumbers are slower but have a higher precision. Calculations with big
numbers are supported only by arithmetic functions.

BigNumbers can be created using the bignumber function:

math.evaluate('bignumber(0.1) + bignumber(0.2)') // BigNumber, 0.3


The default number type of the expression parser can be changed at instantiation
of math.js. The expression parser parses numbers as BigNumber by default:

// Configure the type of number: 'number' (default), 'BigNumber', or 'Fraction'
math.config({number: 'BigNumber'})

// all numbers are parsed as BigNumber
math.evaluate('0.1 + 0.2')  // BigNumber, 0.3


BigNumbers can be converted to numbers and vice versa using the functions
number and bignumber. When converting a BigNumber to a Number, the high
precision of the BigNumber will be lost. When a BigNumber is too large to be represented
as Number, it will be initialized as Infinity.

Complex numbers #

Complex numbers can be created using the imaginary unit i, which is defined
as i^2 = -1. Complex numbers have a real and complex part, which can be
retrieved using the functions re and im.

const parser = math.parser()

// create complex numbers
parser.evaluate('a = 2 + 3i')   // Complex, 2 + 3i
parser.evaluate('b = 4 - i')    // Complex, 4 - i

// get real and imaginary part of a complex number
parser.evaluate('re(a)')        // Number,  2
parser.evaluate('im(a)')        // Number,  3

// calculations with complex numbers
parser.evaluate('a + b')        // Complex, 6 + 2i
parser.evaluate('a * b')        // Complex, 11 + 10i
parser.evaluate('i * i')        // Number,  -1
parser.evaluate('sqrt(-4)')     // Complex, 2i


Units #

math.js supports units. Units can be used in the arithmetic operations
add, subtract, multiply, divide, and exponentiation.
Units can also be converted from one to another.
An overview of all available units can be found on the page
Units.

Units can be converted using the operator to or in.

// create a unit
math.evaluate('5.4 kg')                     // Unit, 5.4 kg

// convert a unit
math.evaluate('2 inch to cm')               // Unit, 5.08 cm
math.evaluate('20 celsius in fahrenheit')   // Unit, ~68 fahrenheit
math.evaluate('90 km/h to m/s')             // Unit, 25 m / s

// convert a unit to a number
// A second parameter with the unit for the exported number must be provided
math.evaluate('number(5 cm, mm)')           // Number, 50

// calculations with units
math.evaluate('0.5kg + 33g')                // Unit, 0.533 kg
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('12 seconds * 2')             // Unit, 24 seconds
math.evaluate('sin(45 deg)')                // Number, 0.7071067811865475
math.evaluate('9.81 m/s^2 * 5 s to mi/h')   // Unit, 109.72172512527 mi / h


Strings #

Strings are enclosed by double quotes “ or single quotes ‘. Strings can be concatenated using the
function concat (not by adding them using + like in JavaScript). Parts of
a string can be retrieved or replaced by using indexes. Strings can be converted
to a number using function number, and numbers can be converted to a string
using function string.

When setting the value of a character in a string, the character that has been
set is returned. Likewise, when a range of characters is set, that range of
characters is returned.

const parser = math.parser()

// create a string
parser.evaluate('"hello"')                        // String, "hello"

// string manipulation
parser.evaluate('a = concat("hello", " world")')  // String, "hello world"
parser.evaluate('size(a)')                        // Matrix [11]
parser.evaluate('a[1:5]')                         // String, "hello"
parser.evaluate('a[1] = "H"')                     // String, "H"
parser.evaluate('a[7:12] = "there!"')             // String, "there!"
parser.evaluate('a')                              // String, "Hello there!"

// string conversion
parser.evaluate('number("300")')                  // Number, 300
parser.evaluate('string(300)')                    // String, "300"


Strings can be used in the evaluate function, to parse expressions inside
the expression parser:

math.evaluate('evaluate("2 + 3")')  // 5


Matrices #

Matrices can be created by entering a series of values between square brackets,
elements are separated by a comma ,.
A matrix like [1, 2, 3] will create a vector, a 1-dimensional matrix with
size [3]. To create a multi-dimensional matrix, matrices can be nested into
each other. For easier creation of two-dimensional matrices, a semicolon ;
can be used to separate rows in a matrix.

// create a matrix
math.evaluate('[1, 2, 3]')                                // Matrix, size [3]
math.evaluate('[[1, 2, 3], [4, 5, 6]]')                   // Matrix, size [2, 3]
math.evaluate('[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]')     // Matrix, size [2, 2, 2]

// create a two dimensional matrix
math.evaluate('[1, 2, 3; 4, 5, 6]')                       // Matrix, size [2, 3]


Another way to create filled matrices is using the functions zeros, ones,
identity, and range.

// initialize a matrix with ones or zeros
math.evaluate('zeros(3, 2)')      // Matrix, [[0, 0], [0, 0], [0, 0]],  size [3, 2]
math.evaluate('ones(3)')          // Matrix, [1, 1, 1],                 size [3]
math.evaluate('5 * ones(2, 2)')   // Matrix, [[5, 5], [5, 5]],          size [2, 2]

// create an identity matrix
math.evaluate('identity(2)')      // Matrix, [[1, 0], [0, 1]],          size [2, 2]

// create a range
math.evaluate('1:4')              // Matrix, [1, 2, 3, 4],              size [4]
math.evaluate('0:2:10')           // Matrix, [0, 2, 4, 6, 8, 10],       size [6]


A subset can be retrieved from a matrix using indexes and a subset of a matrix
can be replaced by using indexes. Indexes are enclosed in square brackets, and
contain a number or a range for each of the matrix dimensions. A range can have
its start and/or end undefined. When the start is undefined, the range will start
at 1, when the end is undefined, the range will end at the end of the matrix.

There is a context variable end available as well to denote the end of the
matrix. This variable cannot be used in multiple nested indices. In that case,
end will be resolved as the end of the innermost matrix. To solve this, 
resolving of the nested index needs to be split in two separate operations.

IMPORTANT: matrix indexes and ranges work differently from the math.js indexes
in JavaScript: They are one-based with an included upper-bound, similar to most
math applications.

parser = math.parser()

// create matrices
parser.evaluate('a = [1, 2; 3, 4]')       // Matrix, [[1, 2], [3, 4]]
parser.evaluate('b = zeros(2, 2)')        // Matrix, [[0, 0], [0, 0]]
parser.evaluate('c = 5:9')                // Matrix, [5, 6, 7, 8, 9]

// replace a subset in a matrix
parser.evaluate('b[1, 1:2] = [5, 6]')     // Matrix, [[5, 6], [0, 0]]
parser.evaluate('b[2, :] = [7, 8]')       // Matrix, [[5, 6], [7, 8]]

// perform a matrix calculation
parser.evaluate('d = a * b')              // Matrix, [[19, 22], [43, 50]]

// retrieve a subset of a matrix
parser.evaluate('d[2, 1]')                // 43
parser.evaluate('d[2, 1:end]')            // Matrix, [[43, 50]]
parser.evaluate('c[end - 1 : -1 : 2]')    // Matrix, [8, 7, 6]


Objects #

Objects in math.js work the same as in languages like JavaScript and Python.
An object is enclosed by curly brackets {, }, and contains a set of
comma separated key/value pairs. Keys and values are separated by a colon :.
Keys can be a symbol like prop or a string like "prop".

math.evaluate('{a: 2 + 1, b: 4}')         // {a: 3, b: 4}
math.evaluate('{"a": 2 + 1, "b": 4}')     // {a: 3, b: 4}


Objects can contain objects:

math.evaluate('{a: 2, b: {c: 3, d: 4}}')  // {a: 2, b: {c: 3, d: 4}}


Object properties can be retrieved or replaced using dot notation or bracket
notation. Unlike JavaScript, when setting a property value, the whole object
is returned, not the property value

let scope = {
  obj: {
    prop: 42
  }
}

// retrieve properties
math.evaluate('obj.prop', scope)          // 42
math.evaluate('obj["prop"]', scope)       // 42

// set properties (returns the whole object, not the property value!)
math.evaluate('obj.prop = 43', scope)     // {prop: 43}
math.evaluate('obj["prop"] = 43', scope)  // {prop: 43}
scope.obj                                 // {prop: 43}


Multi-line expressions #

An expression can contain multiple lines, and expressions can be spread over
multiple lines. Lines can be separated by a newline character \n or by a
semicolon ;. Output of statements followed by a semicolon will be hidden from
the output, and empty lines are ignored. The output is returned as a ResultSet,
with an entry for every visible statement.

// a multi-line expression
math.evaluate('1 * 3 \n 2 * 3 \n 3 * 3')    // ResultSet, [3, 6, 9]

// semicolon statements are hidden from the output
math.evaluate('a=3; b=4; a + b \n a * b')   // ResultSet, [7, 12]

// single expression spread over multiple lines
math.evaluate('a = 2 +\n  3')               // 5
math.evaluate('[\n  1, 2;\n  3, 4\n]')      // Matrix, [[1, 2], [3, 4]]


The results can be read from a ResultSet via the property ResultSet.entries
which is an Array, or by calling ResultSet.valueOf(), which returns the
array with results.

Implicit multiplication #

Implicit multiplication means the multiplication of two symbols, numbers, or a grouped expression inside parentheses without using the * operator. This type of syntax allows a more natural way to enter expressions. For example:

math.evaluate('2 pi')         // 6.283185307179586
math.evaluate('(1+2)(3+4)')   // 21


Parentheses are parsed as a function call when there is a symbol or accessor on
the left hand side, like sqrt(4) or obj.method(4). In other cases the
parentheses are interpreted as an implicit multiplication.

Math.js will always evaluate implicit multiplication before explicit multiplication *, so that the expression x * y z is parsed as x * (y * z). Math.js also gives implicit multiplication higher precedence than division, except when the division matches the pattern [unaryPrefixOp]?[number] / [number] [symbol] or [unaryPrefixOp]?[number] / [number] [left paren]. In that special case, the division is evaluated first:

math.evaluate('20 kg / 4 kg')   // 5      Evaluated as (20 kg) / (4 kg)
math.evaluate('20 / 4 kg')      // 5 kg   Evaluated as (20 / 4) kg


The behavior of implicit multiplication can be summarized by these operator precedence rules, listed from highest to lowest precedence:


  Function calls: [symbol] [left paren]
  Explicit division / when the division matches this pattern: [+-~]?[number] / [+-~]?[number] [symbol] or [number] / [number] [left paren]
  Implicit multiplication
  All other division / and multiplication *


Implicit multiplication is tricky as there can appear to be ambiguity in how an expression will be evaluated. Experience has shown that the above rules most closely match user intent when entering expressions that could be interpreted different ways. It’s also possible that these rules could be tweaked in future major releases.  Use implicit multiplication carefully. If you don’t like the uncertainty introduced by implicit multiplication, use explicit * operators and parentheses to ensure your expression is evaluated the way you intend.

Here are some more examples using implicit multiplication:


  
    
      Expression
      Evaluated as
      Result
    
  
  
    
      (1 + 3) pi
      (1 + 3) * pi
      12.566370614359172
    
    
      (4 - 1) 2
      (4 - 1) * 2
      6
    
    
      3 / 4 mm
      (3 / 4) * mm
      0.75 mm
    
    
      2 + 3 i
      2 + (3 * i)
      2 + 3i
    
    
      (1 + 2) (4 - 2)
      (1 + 2) * (4 - 2)
      6
    
    
      sqrt(4) (1 + 2)
      sqrt(4) * (1 + 2)
      6
    
    
      8 pi / 2 pi
      (8 * pi) / (2 * pi)
      4
    
    
      pi / 2 pi
      pi / (2 * pi)
      0.5
    
    
      1 / 2i
      (1 / 2) * i
      0.5 i
    
    
      8.314 J / mol K
      8.314 J / (mol * K)
      8.314 J / (mol * K)
    
  


Comments #

Comments can be added to explain or describe calculations in the text. A comment
starts with a sharp sign character #, and ends at the end of the line. A line
can contain a comment only, or can contain an expression followed by a comment.

const parser = math.parser()

parser.evaluate('# define some variables')
parser.evaluate('width = 3')                              // 3
parser.evaluate('height = 4')                             // 4
parser.evaluate('width * height   # calculate the area')  // 12\n\n\n\nExpression syntax #

This page describes the syntax of expression parser of math.js. It describes
how to work with the available data types, functions, operators, variables,
and more.

Differences from JavaScript #

The expression parser of math.js is aimed at a mathematical audience,
not a programming audience. The syntax is similar to most calculators and
mathematical applications. This is close to JavaScript as well, though there
are a few important differences between the syntax of the expression parser and
the lower level syntax of math.js. Differences are:


  No need to prefix functions and constants with the math.* namespace,
you can just enter sin(pi / 4).
  Matrix indexes are one-based instead of zero-based.
  There are index and range operators which allow more conveniently getting
and setting matrix indexes, like A[2:4, 1].
  Both indexes and ranges and have the upper-bound included.
  There is a differing syntax for defining functions. Example: f(x) = x^2.
  There are custom operators like x + y instead of add(x, y).
  Some operators are different. For example  ^ is used for exponentiation,
not bitwise xor.
  Implicit multiplication, like 2 pi, is supported and has special rules.
  Relational operators (<, >, <=, >=, ==, and !=) are chained, so the expression 5 < x < 10 is equivalent to 5 < x and x < 10.
  Multi-expression constructs like a = 1; b = 2; a + b or
"a = 1;\n cos(a)\n sin(a)" (where \n denotes newline)
produce a collection (“ResultSet”) of values. Those expressions
terminated by ; are evaluated for side effect only and their values
are suppressed from the result.


Operators #

The expression parser has operators for all common arithmetic operations such
as addition and multiplication. The expression parser uses conventional infix
notation for operators: an operator is placed between its arguments.
Round parentheses can be used to override the default precedence of operators.

// use operators
math.evaluate('2 + 3')       // 5
math.evaluate('2 * 3')       // 6

// use parentheses to override the default precedence
math.evaluate('2 + 3 * 4')   // 14
math.evaluate('(2 + 3) * 4') // 20


The following operators are available. Note that almost every operator listed
also has a function form with identical meaning that can be used
interchangeably. For example, x+y will always evaluate identically to
add(x,y). For a full list of the equivalences, see the section on
Functions below.


  
    
      Operator
      Name
      Syntax
      Associativity
      Example
      Result
    
  
  
    
      (, )
      Grouping
      (x)
      None
      2 * (3 + 4)
      14
    
    
      [, ]
      Matrix, Index
      [...]
      None
      [[1,2],[3,4]]
      [[1,2],[3,4]]
    
    
      {, }
      Object
      {...}
      None
      {a: 1, b: 2}
      {a: 1, b: 2}
    
    
      ,
      Parameter separator
      x, y
      Left to right
      max(2, 1, 5)
      5
    
    
      .
      Property accessor
      obj.prop
      Left to right
      obj={a: 12}; obj.a
      12
    
    
      ;
      Statement separator
      x; y
      Left to right
      a=2; b=3; a*b
      [6]
    
    
      ;
      Row separator
      [x; y]
      Left to right
      [1,2;3,4]
      [[1,2],[3,4]]
    
    
      \n
      Statement separator
      x \n y
      Left to right
      a=2 \n b=3 \n a*b
      [2,3,6]
    
    
      +
      Add
      x + y
      Left to right
      4 + 5
      9
    
    
      +
      Unary plus
      +y
      Right to left
      +4
      4
    
    
      -
      Subtract
      x - y
      Left to right
      7 - 3
      4
    
    
      -
      Unary minus
      -y
      Right to left
      -4
      -4
    
    
      *
      Multiply
      x * y
      Left to right
      2 * 3
      6
    
    
      .*
      Element-wise multiply
      x .* y
      Left to right
      [1,2,3] .* [1,2,3]
      [1,4,9]
    
    
      /
      Divide
      x / y
      Left to right
      6 / 2
      3
    
    
      ./
      Element-wise divide
      x ./ y
      Left to right
      [9,6,4] ./ [3,2,2]
      [3,3,2]
    
    
      %
      Percentage
      x%
      None
      8%
      0.08
    
    
      %
      Addition with Percentage
      x + y%
      Left to right
      100 + 3%
      103
    
    
      %
      Subtraction with Percentage
      x - y%
      Left to right
      100 - 3%
      97
    
    
      % mod
      Modulus
      x % y
      Left to right
      8 % 3
      2
    
    
      ^
      Power
      x ^ y
      Right to left
      2 ^ 3
      8
    
    
      .^
      Element-wise power
      x .^ y
      Right to left
      [2,3] .^ [3,3]
      [8,27]
    
    
      '
      Transpose
      y'
      Left to right
      [[1,2],[3,4]]'
      [[1,3],[2,4]]
    
    
      !
      Factorial
      y!
      Left to right
      5!
      120
    
    
      &
      Bitwise and
      x & y
      Left to right
      5 & 3
      1
    
    
      ~
      Bitwise not
      ~x
      Right to left
      ~2
      -3
    
    
      |
      Bitwise or
      x | y
      Left to right
      5 | 3
      7
    
    
      ^|
      Bitwise xor
      x ^| y
      Left to right
      5 ^| 2
      7
    
    
      <<
      Left shift
      x << y
      Left to right
      4 << 1
      8
    
    
      >>
      Right arithmetic shift
      x >> y
      Left to right
      8 >> 1
      4
    
    
      >>>
      Right logical shift
      x >>> y
      Left to right
      -8 >>> 1
      2147483644
    
    
      and
      Logical and
      x and y
      Left to right
      true and false
      false
    
    
      not
      Logical not
      not y
      Right to left
      not true
      false
    
    
      or
      Logical or
      x or y
      Left to right
      true or false
      true
    
    
      xor
      Logical xor
      x xor y
      Left to right
      true xor true
      false
    
    
      =
      Assignment
      x = y
      Right to left
      a = 5
      5
    
    
      ? :
      Conditional expression
      x ? y : z
      Right to left
      15 > 100 ? 1 : -1
      -1
    
    
      :
      Range
      x : y
      Right to left
      1:4
      [1,2,3,4]
    
    
      to, in
      Unit conversion
      x to y
      Left to right
      2 inch to cm
      5.08 cm
    
    
      ==
      Equal
      x == y
      Left to right
      2 == 4 - 2
      true
    
    
      !=
      Unequal
      x != y
      Left to right
      2 != 3
      true
    
    
      <
      Smaller
      x < y
      Left to right
      2 < 3
      true
    
    
      >
      Larger
      x > y
      Left to right
      2 > 3
      false
    
    
      <=
      Smallereq
      x <= y
      Left to right
      4 <= 3
      false
    
    
      >=
      Largereq
      x >= y
      Left to right
      2 + 4 >= 6
      true
    
  


Precedence #

The operators have the following precedence, from highest to lowest:


  
    
      Operators
      Description
    
  
  
    
      (...)[...]{...}
      GroupingMatrixObject
    
    
      x(...)x[...]obj.prop:
      Function callMatrix indexProperty accessorKey/value separator
    
    
      '
      Matrix transpose
    
    
      !
      Factorial
    
    
      ^, .^
      Exponentiation
    
    
      +, -, ~, not
      Unary plus, unary minus, bitwise not, logical not
    
    
      See section below
      Implicit multiplication
    
    
      *, /, .*, ./,%, mod
      Multiply, divide , percentage, modulus
    
    
      +, -
      Add, subtract
    
    
      :
      Range
    
    
      to, in
      Unit conversion
    
    
      <<, >>, >>>
      Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift
    
    
      ==, !=, <, >, <=, >=
      Relational
    
    
      &
      Bitwise and (lazily evaluated)
    
    
      ^|
      Bitwise xor
    
    
      |
      Bitwise or (lazily evaluated)
    
    
      and
      Logical and (lazily evaluated)
    
    
      xor
      Logical xor
    
    
      or
      Logical or (lazily evaluated)
    
    
      ?, :
      Conditional expression
    
    
      =
      Assignment
    
    
      ,
      Parameter and column separator
    
    
      ;
      Row separator
    
    
      \n, ;
      Statement separators
    
  


Lazy evaluation is used where logically possible for bitwise and logical
operators. In the following example, the value of x will not even be 
evaluated because it cannot effect the final result:
math.evaluate('false and x')        // false, no matter what x equals


Functions #

Functions are called by entering their name, followed by zero or more
arguments enclosed by parentheses. All available functions are listed on the
page Functions.

math.evaluate('sqrt(25)')           // 5
math.evaluate('log(10000, 3 + 7)')  // 4
math.evaluate('sin(pi / 4)')        // 0.7071067811865475


New functions can be defined by “assigning” an expression to a function call
with one or more variables. Such function assignments are limited: they can
only be defined on a single line.

const parser = math.parser()

parser.evaluate('f(x) = x ^ 2 - 5')
parser.evaluate('f(2)')     // -1
parser.evaluate('f(3)')     // 4

parser.evaluate('g(x, y) = x ^ y')
parser.evaluate('g(2, 3)')  // 8


Note that these function assignments do not create closures; put another way,
all free variables in mathjs are dynamic:

const parser = math.parser()

parser.evaluate('x = 7')
parser.evaluate('h(y) = x + y')
parser.evaluate('h(3)')         // 10
parser.evaluate('x = 3')
parser.evaluate('h(3)')         // 6, *not* 10


It is however possible to pass functions as parameters:

const parser = math.parser()

parser.evaluate('twice(func, x) = func(func(x))')
parser.evaluate('twice(square, 2)')    // 16
parser.evaluate('f(x) = 3*x')
parser.evaluate('twice(f, 2)')         // 18

// a simplistic "numerical derivative":
parser.evaluate('eps = 1e-10')
parser.evaluate('nd(f, x) = (f(x+eps) - func(x-eps))/(2*eps)')
parser.evaluate('nd(square,2)')        // 4.000000330961484


Math.js itself heavily uses typed functions, which ensure correct inputs and
throws meaningful errors when the input arguments are invalid. One can create
a typed-function in the
expression parser like:

const parser = math.parser()

parser.evaluate('f = typed({"number": f(x) = x ^ 2 - 5})')


Finally, as mentioned above, there is a function form for nearly every one of
the mathematical operator symbols. Moreover, for some associative operators,
the corresponding function allows arbitrarily many arguments. The table below
gives the full correspondence.


  
    
      Operator Expression
      Equivalent Function Expression
    
  
  
    
      a or b
      or(a,b)
    
    
      a xor b
      xor(a,b)
    
    
      a and b
      and(a,b)
    
    
      a \| b
      bitOr(a,b)
    
    
      a ^\| b
      bitXor(a,b)
    
    
      a & b
      bitAnd(a,b)
    
    
      a == b
      equal(a,b)
    
    
      a != b
      unequal(a,b)
    
    
      a < b
      smaller(a,b)
    
    
      a > b
      larger(a,b)
    
    
      a <= b
      smallerEq(a,b)
    
    
      a << 3
      leftShift(a,3)
    
    
      a >> 3
      rightArithShift(a,3)
    
    
      a >>> 3
      rightLogShift(a,3)
    
    
      u to cm
      to(u, cm)
    
    
      a + b + c + ...
      add(a,b,c,...)
    
    
      a - b
      subtract(a,b)
    
    
      a * b * c * ...
      multiply(a,b,c,...)
    
    
      A .* B
      dotMultiply(A,B)
    
    
      A ./ B
      dotDivide(A,B)
    
    
      a mod b
      mod(a,b)
    
    
      +a
      unaryPlus(a)
    
    
      -a
      unaryMinus(a)
    
    
      ~a
      bitNot(a)
    
    
      not a
      not(a)
    
    
      a^b
      pow(a,b)
    
    
      A .^ B
      dotPow(A,B)
    
    
      a!
      factorial(a)
    
    
      A'
      ctranspose(A)
    
  


Note that math.js embodies a preference for the operator forms, in that calling
simplify (see Algebra) converts any instances of the function
form into the corresponding operator.

Map and forEach #

The map and forEach functions can be used to apply a callback function to each element of an array or matrix.

The callback functions can be functions, typed functions, inline functions (only in the parser) or compiled inline functions (only in the parser).

The callback can have the following inputs:

  value: the current value in the array or matrix.
  index: the index of the current value expressed as an array of numbers.
  array: the array or matrix being iterated.


Below is the syntax for both functions:

map #

The map function applies a function to each element of an array and returns a new array with the results.

const parser = math.parser()

// Define a square function
parser.evaluate('square(x) = x ^ 2')

// Apply the square function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], square)')
// result: [1, 4, 9, 16]

// Apply an inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], f(x) = x ^ 2)')
// result: [1, 4, 9, 16]

// Apply a compiled inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], x ^ 2)')
// result: [1, 4, 9, 16]


forEach #
The forEach function applies a function to each element of an array or matrix but does not return a new array. It is useful for executing side effects.

// Define a function that prints each element
math.import({consoleLog: x => console.log(x)})
const parser = math.parser()

// Define a squareConsleLog function
parser.evaluate('squareConsoleLog(x) = consoleLog(x ^ 2)')

// Apply the squareConsleLog function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], squareConsleLog)')
// Prints: 1, 4, 9, 16

// Apply an inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], f(x) = consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16

// Apply a compiled inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16


These functions are useful for performing element-wise operations on arrays or matrices.

Constants and variables #

Math.js has a number of built-in constants such as pi and e.
All available constants are listed on he page
Constants.

// use constants
math.evaluate('pi')                 // 3.141592653589793
math.evaluate('e ^ 2')              // 7.3890560989306495
math.evaluate('log(e)')             // 1
math.evaluate('e ^ (pi * i) + 1')   // ~0 (Euler)


Variables can be defined using the assignment operator =, and can be used
like constants.

const parser = math.parser()

// define variables
parser.evaluate('a = 3.4')      // 3.4
parser.evaluate('b = 5 / 2')    // 2.5

// use variables
parser.evaluate('a * b')        // 8.5


Variable names must:


  Begin with an “alpha character”, which is:
    
      A latin letter (upper or lower case). Ascii: a-z, A-Z
      An underscore.                        Ascii: _
      A dollar sign.                        Ascii: $
      A latin letter with accents.          Unicode: \u00C0 - \u02AF
      A greek letter.                       Unicode: \u0370 - \u03FF
      A letter-like character.              Unicode: \u2100 - \u214F
      A mathematical alphanumeric symbol.   Unicode: \u{1D400} - \u{1D7FF} excluding invalid code points
    
  
  Contain only alpha characters (above) and digits 0-9
  Not be any of the following: mod, to, in, and, xor, or, not, end. It is possible to assign to some of these, but that’s not recommended.


It is possible to customize the allowed alpha characters, see Customize supported characters for more information.

Data types #

The expression parser supports booleans, numbers, complex numbers, units,
strings, matrices, and objects.

Booleans #

Booleans true and false can be used in expressions.

// use booleans
math.evaluate('true')               // true
math.evaluate('false')              // false
math.evaluate('(2 == 3) == false')  // true


Booleans can be converted to numbers and strings and vice versa using the
functions number and boolean, and string.

// convert booleans
math.evaluate('number(true)')       // 1
math.evaluate('string(false)')      // "false"
math.evaluate('boolean(1)')         // true
math.evaluate('boolean("false")')   // false


Numbers #

The most important and basic data type in math.js are numbers. Numbers use a
point as decimal mark. Numbers can be entered with exponential notation.
Examples:

// numbers in math.js
math.evaluate('2')        // 2
math.evaluate('3.14')     // 3.14
math.evaluate('1.4e3')    // 1400
math.evaluate('22e-3')    // 0.022


A number can be converted to a string and vice versa using the functions
number and string.

// convert a string into a number
math.evaluate('number("2.3")')    // 2.3
math.evaluate('string(2.3)')      // "2.3"


Math.js uses regular JavaScript numbers, which are floating points with a
limited precision and limited range. The limitations are described in detail
on the page Numbers.

math.evaluate('1e-325')   // 0
math.evaluate('1e309')    // Infinity
math.evaluate('-1e309')   // -Infinity


When doing calculations with floats, one can very easily get round-off errors:

// round-off error due to limited floating point precision
math.evaluate('0.1 + 0.2')  // 0.30000000000000004


When outputting results, the function math.format can be used to hide
these round-off errors when outputting results for the user:

const ans = math.evaluate('0.1 + 0.2')  //  0.30000000000000004
math.format(ans, {precision: 14})       // "0.3"


Numbers can be expressed as binary, octal, and hexadecimal literals:

math.evaluate('0b11')  //  3
math.evaluate('0o77')  //  63
math.evaluate('0xff')  //  255


A word size suffix can be used to change the behavior of non decimal literal evaluation:

math.evaluate('0xffi8')         // -1
math.evaluate('0xffffffffi32')  //  -1
math.evaluate('0xfffffffffi32') //  SyntaxError: String "0xfffffffff" is out of range


Non decimal numbers can include a radix point:
math.evaluate('0b1.1')         // 1.5
math.evaluate('0o1.4')         // 1.5
math.evaluate('0x1.8')         // 1.5


Numbers can be formatted as binary, octal, and hex strings using the notation option of the format function:

math.evaluate('format(3, {notation: "bin"})')    //  '0b11'
math.evaluate('format(63, {notation: "oct"})')   //  '0o77'
math.evaluate('format(255, {notation: "hex"})')  //  '0xff'
math.evaluate('format(-1, {notation: "hex"})')   //  '-0x1'
math.evaluate('format(2.3, {notation: "hex"})')  //  '0x2.4cccccccccccc'


The format function accepts a wordSize option to use in conjunction with the non binary notations:

math.evaluate('format(-1, {notation: "hex", wordSize: 8})')   //  '0xffi8'


The functions bin, oct, and hex are shorthand for the format function with notation set accordingly:

math.evaluate('bin(-1)')     // '-0b1'
math.evaluate('bin(-1, 8)')  // '0b11111111i8'


BigNumbers #

Math.js supports BigNumbers for calculations with an arbitrary precision.
The pros and cons of Number and BigNumber are explained in detail on the page
Numbers.

BigNumbers are slower but have a higher precision. Calculations with big
numbers are supported only by arithmetic functions.

BigNumbers can be created using the bignumber function:

math.evaluate('bignumber(0.1) + bignumber(0.2)') // BigNumber, 0.3


The default number type of the expression parser can be changed at instantiation
of math.js. The expression parser parses numbers as BigNumber by default:

// Configure the type of number: 'number' (default), 'BigNumber', or 'Fraction'
math.config({number: 'BigNumber'})

// all numbers are parsed as BigNumber
math.evaluate('0.1 + 0.2')  // BigNumber, 0.3


BigNumbers can be converted to numbers and vice versa using the functions
number and bignumber. When converting a BigNumber to a Number, the high
precision of the BigNumber will be lost. When a BigNumber is too large to be represented
as Number, it will be initialized as Infinity.

Complex numbers #

Complex numbers can be created using the imaginary unit i, which is defined
as i^2 = -1. Complex numbers have a real and complex part, which can be
retrieved using the functions re and im.

const parser = math.parser()

// create complex numbers
parser.evaluate('a = 2 + 3i')   // Complex, 2 + 3i
parser.evaluate('b = 4 - i')    // Complex, 4 - i

// get real and imaginary part of a complex number
parser.evaluate('re(a)')        // Number,  2
parser.evaluate('im(a)')        // Number,  3

// calculations with complex numbers
parser.evaluate('a + b')        // Complex, 6 + 2i
parser.evaluate('a * b')        // Complex, 11 + 10i
parser.evaluate('i * i')        // Number,  -1
parser.evaluate('sqrt(-4)')     // Complex, 2i


Units #

math.js supports units. Units can be used in the arithmetic operations
add, subtract, multiply, divide, and exponentiation.
Units can also be converted from one to another.
An overview of all available units can be found on the page
Units.

Units can be converted using the operator to or in.

// create a unit
math.evaluate('5.4 kg')                     // Unit, 5.4 kg

// convert a unit
math.evaluate('2 inch to cm')               // Unit, 5.08 cm
math.evaluate('20 celsius in fahrenheit')   // Unit, ~68 fahrenheit
math.evaluate('90 km/h to m/s')             // Unit, 25 m / s

// convert a unit to a number
// A second parameter with the unit for the exported number must be provided
math.evaluate('number(5 cm, mm)')           // Number, 50

// calculations with units
math.evaluate('0.5kg + 33g')                // Unit, 0.533 kg
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('12 seconds * 2')             // Unit, 24 seconds
math.evaluate('sin(45 deg)')                // Number, 0.7071067811865475
math.evaluate('9.81 m/s^2 * 5 s to mi/h')   // Unit, 109.72172512527 mi / h


Strings #

Strings are enclosed by double quotes “ or single quotes ‘. Strings can be concatenated using the
function concat (not by adding them using + like in JavaScript). Parts of
a string can be retrieved or replaced by using indexes. Strings can be converted
to a number using function number, and numbers can be converted to a string
using function string.

When setting the value of a character in a string, the character that has been
set is returned. Likewise, when a range of characters is set, that range of
characters is returned.

const parser = math.parser()

// create a string
parser.evaluate('"hello"')                        // String, "hello"

// string manipulation
parser.evaluate('a = concat("hello", " world")')  // String, "hello world"
parser.evaluate('size(a)')                        // Matrix [11]
parser.evaluate('a[1:5]')                         // String, "hello"
parser.evaluate('a[1] = "H"')                     // String, "H"
parser.evaluate('a[7:12] = "there!"')             // String, "there!"
parser.evaluate('a')                              // String, "Hello there!"

// string conversion
parser.evaluate('number("300")')                  // Number, 300
parser.evaluate('string(300)')                    // String, "300"


Strings can be used in the evaluate function, to parse expressions inside
the expression parser:

math.evaluate('evaluate("2 + 3")')  // 5


Matrices #

Matrices can be created by entering a series of values between square brackets,
elements are separated by a comma ,.
A matrix like [1, 2, 3] will create a vector, a 1-dimensional matrix with
size [3]. To create a multi-dimensional matrix, matrices can be nested into
each other. For easier creation of two-dimensional matrices, a semicolon ;
can be used to separate rows in a matrix.

// create a matrix
math.evaluate('[1, 2, 3]')                                // Matrix, size [3]
math.evaluate('[[1, 2, 3], [4, 5, 6]]')                   // Matrix, size [2, 3]
math.evaluate('[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]')     // Matrix, size [2, 2, 2]

// create a two dimensional matrix
math.evaluate('[1, 2, 3; 4, 5, 6]')                       // Matrix, size [2, 3]


Another way to create filled matrices is using the functions zeros, ones,
identity, and range.

// initialize a matrix with ones or zeros
math.evaluate('zeros(3, 2)')      // Matrix, [[0, 0], [0, 0], [0, 0]],  size [3, 2]
math.evaluate('ones(3)')          // Matrix, [1, 1, 1],                 size [3]
math.evaluate('5 * ones(2, 2)')   // Matrix, [[5, 5], [5, 5]],          size [2, 2]

// create an identity matrix
math.evaluate('identity(2)')      // Matrix, [[1, 0], [0, 1]],          size [2, 2]

// create a range
math.evaluate('1:4')              // Matrix, [1, 2, 3, 4],              size [4]
math.evaluate('0:2:10')           // Matrix, [0, 2, 4, 6, 8, 10],       size [6]


A subset can be retrieved from a matrix using indexes and a subset of a matrix
can be replaced by using indexes. Indexes are enclosed in square brackets, and
contain a number or a range for each of the matrix dimensions. A range can have
its start and/or end undefined. When the start is undefined, the range will start
at 1, when the end is undefined, the range will end at the end of the matrix.

There is a context variable end available as well to denote the end of the
matrix. This variable cannot be used in multiple nested indices. In that case,
end will be resolved as the end of the innermost matrix. To solve this, 
resolving of the nested index needs to be split in two separate operations.

IMPORTANT: matrix indexes and ranges work differently from the math.js indexes
in JavaScript: They are one-based with an included upper-bound, similar to most
math applications.

parser = math.parser()

// create matrices
parser.evaluate('a = [1, 2; 3, 4]')       // Matrix, [[1, 2], [3, 4]]
parser.evaluate('b = zeros(2, 2)')        // Matrix, [[0, 0], [0, 0]]
parser.evaluate('c = 5:9')                // Matrix, [5, 6, 7, 8, 9]

// replace a subset in a matrix
parser.evaluate('b[1, 1:2] = [5, 6]')     // Matrix, [[5, 6], [0, 0]]
parser.evaluate('b[2, :] = [7, 8]')       // Matrix, [[5, 6], [7, 8]]

// perform a matrix calculation
parser.evaluate('d = a * b')              // Matrix, [[19, 22], [43, 50]]

// retrieve a subset of a matrix
parser.evaluate('d[2, 1]')                // 43
parser.evaluate('d[2, 1:end]')            // Matrix, [[43, 50]]
parser.evaluate('c[end - 1 : -1 : 2]')    // Matrix, [8, 7, 6]


Objects #

Objects in math.js work the same as in languages like JavaScript and Python.
An object is enclosed by curly brackets {, }, and contains a set of
comma separated key/value pairs. Keys and values are separated by a colon :.
Keys can be a symbol like prop or a string like "prop".

math.evaluate('{a: 2 + 1, b: 4}')         // {a: 3, b: 4}
math.evaluate('{"a": 2 + 1, "b": 4}')     // {a: 3, b: 4}


Objects can contain objects:

math.evaluate('{a: 2, b: {c: 3, d: 4}}')  // {a: 2, b: {c: 3, d: 4}}


Object properties can be retrieved or replaced using dot notation or bracket
notation. Unlike JavaScript, when setting a property value, the whole object
is returned, not the property value

let scope = {
  obj: {
    prop: 42
  }
}

// retrieve properties
math.evaluate('obj.prop', scope)          // 42
math.evaluate('obj["prop"]', scope)       // 42

// set properties (returns the whole object, not the property value!)
math.evaluate('obj.prop = 43', scope)     // {prop: 43}
math.evaluate('obj["prop"] = 43', scope)  // {prop: 43}
scope.obj                                 // {prop: 43}


Multi-line expressions #

An expression can contain multiple lines, and expressions can be spread over
multiple lines. Lines can be separated by a newline character \n or by a
semicolon ;. Output of statements followed by a semicolon will be hidden from
the output, and empty lines are ignored. The output is returned as a ResultSet,
with an entry for every visible statement.

// a multi-line expression
math.evaluate('1 * 3 \n 2 * 3 \n 3 * 3')    // ResultSet, [3, 6, 9]

// semicolon statements are hidden from the output
math.evaluate('a=3; b=4; a + b \n a * b')   // ResultSet, [7, 12]

// single expression spread over multiple lines
math.evaluate('a = 2 +\n  3')               // 5
math.evaluate('[\n  1, 2;\n  3, 4\n]')      // Matrix, [[1, 2], [3, 4]]


The results can be read from a ResultSet via the property ResultSet.entries
which is an Array, or by calling ResultSet.valueOf(), which returns the
array with results.

Implicit multiplication #

Implicit multiplication means the multiplication of two symbols, numbers, or a grouped expression inside parentheses without using the * operator. This type of syntax allows a more natural way to enter expressions. For example:

math.evaluate('2 pi')         // 6.283185307179586
math.evaluate('(1+2)(3+4)')   // 21


Parentheses are parsed as a function call when there is a symbol or accessor on
the left hand side, like sqrt(4) or obj.method(4). In other cases the
parentheses are interpreted as an implicit multiplication.

Math.js will always evaluate implicit multiplication before explicit multiplication *, so that the expression x * y z is parsed as x * (y * z). Math.js also gives implicit multiplication higher precedence than division, except when the division matches the pattern [unaryPrefixOp]?[number] / [number] [symbol] or [unaryPrefixOp]?[number] / [number] [left paren]. In that special case, the division is evaluated first:

math.evaluate('20 kg / 4 kg')   // 5      Evaluated as (20 kg) / (4 kg)
math.evaluate('20 / 4 kg')      // 5 kg   Evaluated as (20 / 4) kg


The behavior of implicit multiplication can be summarized by these operator precedence rules, listed from highest to lowest precedence:


  Function calls: [symbol] [left paren]
  Explicit division / when the division matches this pattern: [+-~]?[number] / [+-~]?[number] [symbol] or [number] / [number] [left paren]
  Implicit multiplication
  All other division / and multiplication *


Implicit multiplication is tricky as there can appear to be ambiguity in how an expression will be evaluated. Experience has shown that the above rules most closely match user intent when entering expressions that could be interpreted different ways. It’s also possible that these rules could be tweaked in future major releases.  Use implicit multiplication carefully. If you don’t like the uncertainty introduced by implicit multiplication, use explicit * operators and parentheses to ensure your expression is evaluated the way you intend.

Here are some more examples using implicit multiplication:


  
    
      Expression
      Evaluated as
      Result
    
  
  
    
      (1 + 3) pi
      (1 + 3) * pi
      12.566370614359172
    
    
      (4 - 1) 2
      (4 - 1) * 2
      6
    
    
      3 / 4 mm
      (3 / 4) * mm
      0.75 mm
    
    
      2 + 3 i
      2 + (3 * i)
      2 + 3i
    
    
      (1 + 2) (4 - 2)
      (1 + 2) * (4 - 2)
      6
    
    
      sqrt(4) (1 + 2)
      sqrt(4) * (1 + 2)
      6
    
    
      8 pi / 2 pi
      (8 * pi) / (2 * pi)
      4
    
    
      pi / 2 pi
      pi / (2 * pi)
      0.5
    
    
      1 / 2i
      (1 / 2) * i
      0.5 i
    
    
      8.314 J / mol K
      8.314 J / (mol * K)
      8.314 J / (mol * K)
    
  


Comments #

Comments can be added to explain or describe calculations in the text. A comment
starts with a sharp sign character #, and ends at the end of the line. A line
can contain a comment only, or can contain an expression followed by a comment.

const parser = math.parser()

parser.evaluate('# define some variables')
parser.evaluate('width = 3')                              // 3
parser.evaluate('height = 4')                             // 4
parser.evaluate('width * height   # calculate the area')  // 12\n\n\n\nCustomization #

Besides parsing and evaluating expressions, the expression parser supports
a number of features to customize processing and evaluation of expressions
and outputting expressions.

On this page:


  Function transforms
  Custom argument parsing
  Custom LaTeX handlers
  Custom HTML, LaTeX and string output
  Customize supported characters


Function transforms #

It is possible to preprocess function arguments and post process a functions
return value by writing a transform for the function. A transform is a
function wrapping around a function to be transformed or completely replaces
a function.

For example, the functions for math.js use zero-based matrix indices (as is
common in programing languages), but the expression parser uses one-based
indices. To enable this, all functions dealing with indices have a transform,
which changes input from one-based to zero-based, and transforms output (and
error message) from zero-based to one-based.

// using plain JavaScript, indices are zero-based:
const a = [[1, 2], [3, 4]]       // a 2x2 matrix
math.subset(a, math.index(0, 1)) // returns 2

// using the expression parser, indices are transformed to one-based:
const a = [[1, 2], [3, 4]] // a 2x2 matrix
let scope = {
  a: a
}
math.evaluate('subset(a, index(1, 2))', scope) // returns 2


To create a transform for a function, the transform function must be attached
to the function as property transform:

import { create, all } from 'mathjs'
const math = create(all)

// create a function
function addIt(a, b) {
  return a + b
}

// attach a transform function to the function addIt
addIt.transform = function (a, b) {
  console.log('input: a=' + a + ', b=' + b)
  // we can manipulate input here before executing addIt

  const res = addIt(a, b)

  console.log('result: ' + res)
  // we can manipulate result here before returning

  return res
}

// import the function into math.js
math.import({
  addIt: addIt
})

// use the function via the expression parser
console.log('Using expression parser:')
console.log('2+4=' + math.evaluate('addIt(2, 4)'))
// This will output:
//
//     input: a=2, b=4
//     result: 6
//     2+4=6

// when used via plain JavaScript, the transform is not invoked
console.log('')
console.log('Using plain JavaScript:')
console.log('2+4=' + math.addIt(2, 4))
// This will output:
//
//     6


Functions with a transform must be imported in the math namespace, as they
need to be processed at compile time. They are not supported when passed via a
scope at evaluation time.

Custom argument parsing #

The expression parser of math.js has support for letting functions
parse and evaluate arguments themselves, instead of calling them with
evaluated arguments. This is useful for example when creating a function
like plot(f(x), x) or integrate(f(x), x, start, end), where some of the
arguments need to be processed in a special way. In these cases, the expression
f(x) will be evaluated repeatedly by the function, and x is not evaluated
but used to specify the variable looping over the function f(x).

Functions having a property rawArgs with value true are treated in a special
way by the expression parser: they will be invoked with unevaluated arguments,
allowing the function to process the arguments in a customized way. Raw
functions are called as:

rawFunction(args: Node[], math: Object, scope: Map)


Where :


  args is an Array with nodes of the parsed arguments.
  math is the math namespace against which the expression was compiled.
  scope is a Map 
interface containing the variables defined in the scope 
passed via evaluate(scope). The passed scope is always a Map interface,
and normally a PartitionedMap is used to separate local function variables
like x in a custom defined function f(x) = rawFunction(x) ^ 2 from the 
scope variables. Note that a PartitionedMap can recursively link to another
PartitionedMap.


Raw functions must be imported in the math namespace, as they need to be
processed at compile time. They are not supported when passed via a scope
at evaluation time.

A simple example:

function myFunction(args, math, scope) {
  // get string representation of the arguments
  const str = args.map(function (arg) {
    return arg.toString()
  })

  // evaluate the arguments
  const res = args.map(function (arg) {
    return arg.compile().evaluate(scope)
  })

  return 'arguments: ' + str.join(',') + ', evaluated: ' + res.join(',')
}

// mark the function as "rawArgs", so it will be called with unevaluated arguments
myFunction.rawArgs = true

// import the new function in the math namespace
math.import({
  myFunction: myFunction
})

// use the function
math.evaluate('myFunction(2 + 3, sqrt(4))')
// returns 'arguments: 2 + 3, sqrt(4), evaluated: 5, 2'


Custom LaTeX handlers #

You can attach a toTex property to your custom functions before importing them to define their LaTeX output. This
toTex property can be a handler in the format described in the next section ‘Custom LaTeX and String conversion’
or a template string similar to ES6 templates.

Template syntax #


  ${name}: Gets replaced by the name of the function
  ${args}: Gets replaced by a comma separated list of the arguments of the function.
  ${args[0]}: Gets replaced by the first argument of a function
  $$: Gets replaced by $


Example #

const customFunctions = {
  plus: function (a, b) {
    return a + b
  },
  minus: function (a, b) {
    return a - b
  },
  binom: function (n, k) {
    return 1
  }
}

customFunctions.plus.toTex = '${args[0]}+${args[1]}' //template string
customFunctions.binom.toTex = '\\mathrm{${name}}\\left(${args}\\right)' //template string
customFunctions.minus.toTex = function (node, options) { //handler function
  return node.args[0].toTex(options) + node.name + node.args[1].toTex(options)
}

math.import(customFunctions)

math.parse('plus(1,2)').toTex()    // '1+2'
math.parse('binom(1,2)').toTex()   // '\\mathrm{binom}\\left(1,2\\right)'
math.parse('minus(1,2)').toTex()   // '1minus2'


Custom HTML, LaTeX and string output #

All expression nodes have a method toTex and toString to output an expression respectively in HTML or LaTex format or as regular text .
The functions toHTML, toTex and toString accept an options argument to customise output. This object is of the following form:

{
  parenthesis: 'keep',    // parenthesis option
  handler: someHandler,   // handler to change the output
  implicit: 'hide'        // how to treat implicit multiplication
}


Parenthesis #

The parenthesis option changes the way parentheses are used in the output. There are three options available:


  keep Keep the parentheses from the input and display them as is. This is the default.
  auto Only display parentheses that are necessary. Mathjs tries to get rid of as much parentheses as possible.
  all Display all parentheses that are given by the structure of the node tree. This makes the output precedence unambiguous.


There’s two ways of passing callbacks:


  Pass an object that maps function names to callbacks. Those callbacks will be used for FunctionNodes with
functions of that name.
  Pass a function to toTex. This function will then be used for every node.


const expression = math.parse('(1+1+1)')

expression.toString()                      // (1 + 1 + 1)
expression.toString({parenthesis: 'keep'}) // (1 + 1 + 1)
expression.toString({parenthesis: 'auto'}) // 1 + 1 + 1
expression.toString({parenthesis: 'all'})  // (1 + 1) + 1


Handler #

You can provide the toTex and toString functions of an expression with your own custom handlers that override the internal behaviour. This is especially useful to provide LaTeX/string output for your own custom functions. This can be done in two ways:


  Pass an object that maps function names to callbacks. Those callbacks will be used for FunctionNodes that contain functions with that name.
  Pass a callback directly. This callback will run for every node, so you can replace the output of anything you like.


A callback function has the following form:

function callback (node, options) {
  ...
}

Where options is the object passed to toHTML/toTex/toString. Don’t forget to pass this on to the child nodes, and node is a reference to the current node.

If a callback returns nothing, the standard output will be used. If your callback returns a string, this string will be used.

Although the following examples use toTex, it works for toString and toHTML in the same way

Examples for option 1 #

const customFunctions = {
  binomial: function (n, k) {
    //calculate n choose k
    // (do some stuff)
    return result
  }
}

const customLaTeX = {
  'binomial': function (node, options) { //provide toTex for your own custom function
    return '\\binom{' + node.args[0].toTex(options) + '}{' + node.args[1].toTex(options) + '}'
  },
  'factorial': function (node, options) { //override toTex for builtin functions
  	return 'factorial\\left(' + node.args[0] + '\\right)'
  }
}


You can simply use your custom toTex functions by passing them to toTex:

math.import(customFunctions)
const expression = math.parse('binomial(factorial(2),1)')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains "\binom{factorial\\left(2\\right)}{1}"


Examples for option 2: #

function customLaTeX(node, options) {
  if ((node.type === 'OperatorNode') && (node.fn === 'add')) {
    //don't forget to pass the options to the toTex functions
    return node.args[0].toTex(options) + ' plus ' + node.args[1].toTex(options)
  }
  else if (node.type === 'ConstantNode') {
    if (node.value === 0) {
        return '\\mbox{zero}'
    }
    else if (node.value === 1) {
        return '\\mbox{one}'
    }
    else if (node.value === 2) {
        return '\\mbox{two}'
    }
    else {
        return node.value
    }
  }
}

const expression = math.parse('1+2')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains '\mbox{one} plus \mbox{two}'


Another example in conjunction with custom functions:

const customFunctions = {
  binomial: function (n, k) {
    //calculate n choose k
    // (do some stuff)
    return result
  }
}

function customLaTeX(node, options) {
  if ((node.type === 'FunctionNode') && (node.name === 'binomial')) {
      return '\\binom{' + node.args[0].toTex(options) + '}{' + node.args[1].toTex(options) + '}'
  }
}

math.import(customFunctions)
const expression = math.parse('binomial(2,1)')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains "\binom{2}{1}"


Implicit multiplication #

You can change the way that implicit multiplication is converted to a string or LaTeX. The two options are hide, to not show a multiplication operator for implicit multiplication and show to show it.

Example:

const node = math.parse('2a')

node.toString()                   // '2 a'
node.toString({implicit: 'hide'}) // '2 a'
node.toString({implicit: 'show'}) // '2 * a'

node.toTex()                      // '2~ a'
node.toTex({implicit: 'hide'})    // '2~ a'
node.toTex({implicit: 'show'})    // '2\\cdot a'


Customize supported characters #

It is possible to customize the characters allowed in symbols and digits.
The parse function exposes the following test functions:


  math.parse.isAlpha(c, cPrev, cNext)
  math.parse.isWhitespace(c, nestingLevel)
  math.parse.isDecimalMark(c, cNext)
  math.parse.isDigitDot(c)
  math.parse.isDigit(c)


The exact signature and implementation of these functions can be looked up in
the source code of the parser. The allowed alpha characters are described here: Constants and variables.

For example, the phone character ☎ is not supported by default. It can be enabled
by replacing the isAlpha function:

const isAlphaOriginal = math.parse.isAlpha
math.parse.isAlpha = function (c, cPrev, cNext) {
  return isAlphaOriginal(c, cPrev, cNext) || (c === '\u260E')
}

// now we can use the \u260E (phone) character in expressions
const result = math.evaluate('\u260Efoo', {'\u260Efoo': 42}) // returns 42
console.log(result)\n\n\n\nExpression syntax #

This page describes the syntax of expression parser of math.js. It describes
how to work with the available data types, functions, operators, variables,
and more.

Differences from JavaScript #

The expression parser of math.js is aimed at a mathematical audience,
not a programming audience. The syntax is similar to most calculators and
mathematical applications. This is close to JavaScript as well, though there
are a few important differences between the syntax of the expression parser and
the lower level syntax of math.js. Differences are:


  No need to prefix functions and constants with the math.* namespace,
you can just enter sin(pi / 4).
  Matrix indexes are one-based instead of zero-based.
  There are index and range operators which allow more conveniently getting
and setting matrix indexes, like A[2:4, 1].
  Both indexes and ranges and have the upper-bound included.
  There is a differing syntax for defining functions. Example: f(x) = x^2.
  There are custom operators like x + y instead of add(x, y).
  Some operators are different. For example  ^ is used for exponentiation,
not bitwise xor.
  Implicit multiplication, like 2 pi, is supported and has special rules.
  Relational operators (<, >, <=, >=, ==, and !=) are chained, so the expression 5 < x < 10 is equivalent to 5 < x and x < 10.
  Multi-expression constructs like a = 1; b = 2; a + b or
"a = 1;\n cos(a)\n sin(a)" (where \n denotes newline)
produce a collection (“ResultSet”) of values. Those expressions
terminated by ; are evaluated for side effect only and their values
are suppressed from the result.


Operators #

The expression parser has operators for all common arithmetic operations such
as addition and multiplication. The expression parser uses conventional infix
notation for operators: an operator is placed between its arguments.
Round parentheses can be used to override the default precedence of operators.

// use operators
math.evaluate('2 + 3')       // 5
math.evaluate('2 * 3')       // 6

// use parentheses to override the default precedence
math.evaluate('2 + 3 * 4')   // 14
math.evaluate('(2 + 3) * 4') // 20


The following operators are available. Note that almost every operator listed
also has a function form with identical meaning that can be used
interchangeably. For example, x+y will always evaluate identically to
add(x,y). For a full list of the equivalences, see the section on
Functions below.


  
    
      Operator
      Name
      Syntax
      Associativity
      Example
      Result
    
  
  
    
      (, )
      Grouping
      (x)
      None
      2 * (3 + 4)
      14
    
    
      [, ]
      Matrix, Index
      [...]
      None
      [[1,2],[3,4]]
      [[1,2],[3,4]]
    
    
      {, }
      Object
      {...}
      None
      {a: 1, b: 2}
      {a: 1, b: 2}
    
    
      ,
      Parameter separator
      x, y
      Left to right
      max(2, 1, 5)
      5
    
    
      .
      Property accessor
      obj.prop
      Left to right
      obj={a: 12}; obj.a
      12
    
    
      ;
      Statement separator
      x; y
      Left to right
      a=2; b=3; a*b
      [6]
    
    
      ;
      Row separator
      [x; y]
      Left to right
      [1,2;3,4]
      [[1,2],[3,4]]
    
    
      \n
      Statement separator
      x \n y
      Left to right
      a=2 \n b=3 \n a*b
      [2,3,6]
    
    
      +
      Add
      x + y
      Left to right
      4 + 5
      9
    
    
      +
      Unary plus
      +y
      Right to left
      +4
      4
    
    
      -
      Subtract
      x - y
      Left to right
      7 - 3
      4
    
    
      -
      Unary minus
      -y
      Right to left
      -4
      -4
    
    
      *
      Multiply
      x * y
      Left to right
      2 * 3
      6
    
    
      .*
      Element-wise multiply
      x .* y
      Left to right
      [1,2,3] .* [1,2,3]
      [1,4,9]
    
    
      /
      Divide
      x / y
      Left to right
      6 / 2
      3
    
    
      ./
      Element-wise divide
      x ./ y
      Left to right
      [9,6,4] ./ [3,2,2]
      [3,3,2]
    
    
      %
      Percentage
      x%
      None
      8%
      0.08
    
    
      %
      Addition with Percentage
      x + y%
      Left to right
      100 + 3%
      103
    
    
      %
      Subtraction with Percentage
      x - y%
      Left to right
      100 - 3%
      97
    
    
      % mod
      Modulus
      x % y
      Left to right
      8 % 3
      2
    
    
      ^
      Power
      x ^ y
      Right to left
      2 ^ 3
      8
    
    
      .^
      Element-wise power
      x .^ y
      Right to left
      [2,3] .^ [3,3]
      [8,27]
    
    
      '
      Transpose
      y'
      Left to right
      [[1,2],[3,4]]'
      [[1,3],[2,4]]
    
    
      !
      Factorial
      y!
      Left to right
      5!
      120
    
    
      &
      Bitwise and
      x & y
      Left to right
      5 & 3
      1
    
    
      ~
      Bitwise not
      ~x
      Right to left
      ~2
      -3
    
    
      |
      Bitwise or
      x | y
      Left to right
      5 | 3
      7
    
    
      ^|
      Bitwise xor
      x ^| y
      Left to right
      5 ^| 2
      7
    
    
      <<
      Left shift
      x << y
      Left to right
      4 << 1
      8
    
    
      >>
      Right arithmetic shift
      x >> y
      Left to right
      8 >> 1
      4
    
    
      >>>
      Right logical shift
      x >>> y
      Left to right
      -8 >>> 1
      2147483644
    
    
      and
      Logical and
      x and y
      Left to right
      true and false
      false
    
    
      not
      Logical not
      not y
      Right to left
      not true
      false
    
    
      or
      Logical or
      x or y
      Left to right
      true or false
      true
    
    
      xor
      Logical xor
      x xor y
      Left to right
      true xor true
      false
    
    
      =
      Assignment
      x = y
      Right to left
      a = 5
      5
    
    
      ? :
      Conditional expression
      x ? y : z
      Right to left
      15 > 100 ? 1 : -1
      -1
    
    
      :
      Range
      x : y
      Right to left
      1:4
      [1,2,3,4]
    
    
      to, in
      Unit conversion
      x to y
      Left to right
      2 inch to cm
      5.08 cm
    
    
      ==
      Equal
      x == y
      Left to right
      2 == 4 - 2
      true
    
    
      !=
      Unequal
      x != y
      Left to right
      2 != 3
      true
    
    
      <
      Smaller
      x < y
      Left to right
      2 < 3
      true
    
    
      >
      Larger
      x > y
      Left to right
      2 > 3
      false
    
    
      <=
      Smallereq
      x <= y
      Left to right
      4 <= 3
      false
    
    
      >=
      Largereq
      x >= y
      Left to right
      2 + 4 >= 6
      true
    
  


Precedence #

The operators have the following precedence, from highest to lowest:


  
    
      Operators
      Description
    
  
  
    
      (...)[...]{...}
      GroupingMatrixObject
    
    
      x(...)x[...]obj.prop:
      Function callMatrix indexProperty accessorKey/value separator
    
    
      '
      Matrix transpose
    
    
      !
      Factorial
    
    
      ^, .^
      Exponentiation
    
    
      +, -, ~, not
      Unary plus, unary minus, bitwise not, logical not
    
    
      See section below
      Implicit multiplication
    
    
      *, /, .*, ./,%, mod
      Multiply, divide , percentage, modulus
    
    
      +, -
      Add, subtract
    
    
      :
      Range
    
    
      to, in
      Unit conversion
    
    
      <<, >>, >>>
      Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift
    
    
      ==, !=, <, >, <=, >=
      Relational
    
    
      &
      Bitwise and (lazily evaluated)
    
    
      ^|
      Bitwise xor
    
    
      |
      Bitwise or (lazily evaluated)
    
    
      and
      Logical and (lazily evaluated)
    
    
      xor
      Logical xor
    
    
      or
      Logical or (lazily evaluated)
    
    
      ?, :
      Conditional expression
    
    
      =
      Assignment
    
    
      ,
      Parameter and column separator
    
    
      ;
      Row separator
    
    
      \n, ;
      Statement separators
    
  


Lazy evaluation is used where logically possible for bitwise and logical
operators. In the following example, the value of x will not even be 
evaluated because it cannot effect the final result:
math.evaluate('false and x')        // false, no matter what x equals


Functions #

Functions are called by entering their name, followed by zero or more
arguments enclosed by parentheses. All available functions are listed on the
page Functions.

math.evaluate('sqrt(25)')           // 5
math.evaluate('log(10000, 3 + 7)')  // 4
math.evaluate('sin(pi / 4)')        // 0.7071067811865475


New functions can be defined by “assigning” an expression to a function call
with one or more variables. Such function assignments are limited: they can
only be defined on a single line.

const parser = math.parser()

parser.evaluate('f(x) = x ^ 2 - 5')
parser.evaluate('f(2)')     // -1
parser.evaluate('f(3)')     // 4

parser.evaluate('g(x, y) = x ^ y')
parser.evaluate('g(2, 3)')  // 8


Note that these function assignments do not create closures; put another way,
all free variables in mathjs are dynamic:

const parser = math.parser()

parser.evaluate('x = 7')
parser.evaluate('h(y) = x + y')
parser.evaluate('h(3)')         // 10
parser.evaluate('x = 3')
parser.evaluate('h(3)')         // 6, *not* 10


It is however possible to pass functions as parameters:

const parser = math.parser()

parser.evaluate('twice(func, x) = func(func(x))')
parser.evaluate('twice(square, 2)')    // 16
parser.evaluate('f(x) = 3*x')
parser.evaluate('twice(f, 2)')         // 18

// a simplistic "numerical derivative":
parser.evaluate('eps = 1e-10')
parser.evaluate('nd(f, x) = (f(x+eps) - func(x-eps))/(2*eps)')
parser.evaluate('nd(square,2)')        // 4.000000330961484


Math.js itself heavily uses typed functions, which ensure correct inputs and
throws meaningful errors when the input arguments are invalid. One can create
a typed-function in the
expression parser like:

const parser = math.parser()

parser.evaluate('f = typed({"number": f(x) = x ^ 2 - 5})')


Finally, as mentioned above, there is a function form for nearly every one of
the mathematical operator symbols. Moreover, for some associative operators,
the corresponding function allows arbitrarily many arguments. The table below
gives the full correspondence.


  
    
      Operator Expression
      Equivalent Function Expression
    
  
  
    
      a or b
      or(a,b)
    
    
      a xor b
      xor(a,b)
    
    
      a and b
      and(a,b)
    
    
      a \| b
      bitOr(a,b)
    
    
      a ^\| b
      bitXor(a,b)
    
    
      a & b
      bitAnd(a,b)
    
    
      a == b
      equal(a,b)
    
    
      a != b
      unequal(a,b)
    
    
      a < b
      smaller(a,b)
    
    
      a > b
      larger(a,b)
    
    
      a <= b
      smallerEq(a,b)
    
    
      a << 3
      leftShift(a,3)
    
    
      a >> 3
      rightArithShift(a,3)
    
    
      a >>> 3
      rightLogShift(a,3)
    
    
      u to cm
      to(u, cm)
    
    
      a + b + c + ...
      add(a,b,c,...)
    
    
      a - b
      subtract(a,b)
    
    
      a * b * c * ...
      multiply(a,b,c,...)
    
    
      A .* B
      dotMultiply(A,B)
    
    
      A ./ B
      dotDivide(A,B)
    
    
      a mod b
      mod(a,b)
    
    
      +a
      unaryPlus(a)
    
    
      -a
      unaryMinus(a)
    
    
      ~a
      bitNot(a)
    
    
      not a
      not(a)
    
    
      a^b
      pow(a,b)
    
    
      A .^ B
      dotPow(A,B)
    
    
      a!
      factorial(a)
    
    
      A'
      ctranspose(A)
    
  


Note that math.js embodies a preference for the operator forms, in that calling
simplify (see Algebra) converts any instances of the function
form into the corresponding operator.

Map and forEach #

The map and forEach functions can be used to apply a callback function to each element of an array or matrix.

The callback functions can be functions, typed functions, inline functions (only in the parser) or compiled inline functions (only in the parser).

The callback can have the following inputs:

  value: the current value in the array or matrix.
  index: the index of the current value expressed as an array of numbers.
  array: the array or matrix being iterated.


Below is the syntax for both functions:

map #

The map function applies a function to each element of an array and returns a new array with the results.

const parser = math.parser()

// Define a square function
parser.evaluate('square(x) = x ^ 2')

// Apply the square function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], square)')
// result: [1, 4, 9, 16]

// Apply an inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], f(x) = x ^ 2)')
// result: [1, 4, 9, 16]

// Apply a compiled inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], x ^ 2)')
// result: [1, 4, 9, 16]


forEach #
The forEach function applies a function to each element of an array or matrix but does not return a new array. It is useful for executing side effects.

// Define a function that prints each element
math.import({consoleLog: x => console.log(x)})
const parser = math.parser()

// Define a squareConsleLog function
parser.evaluate('squareConsoleLog(x) = consoleLog(x ^ 2)')

// Apply the squareConsleLog function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], squareConsleLog)')
// Prints: 1, 4, 9, 16

// Apply an inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], f(x) = consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16

// Apply a compiled inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16


These functions are useful for performing element-wise operations on arrays or matrices.

Constants and variables #

Math.js has a number of built-in constants such as pi and e.
All available constants are listed on he page
Constants.

// use constants
math.evaluate('pi')                 // 3.141592653589793
math.evaluate('e ^ 2')              // 7.3890560989306495
math.evaluate('log(e)')             // 1
math.evaluate('e ^ (pi * i) + 1')   // ~0 (Euler)


Variables can be defined using the assignment operator =, and can be used
like constants.

const parser = math.parser()

// define variables
parser.evaluate('a = 3.4')      // 3.4
parser.evaluate('b = 5 / 2')    // 2.5

// use variables
parser.evaluate('a * b')        // 8.5


Variable names must:


  Begin with an “alpha character”, which is:
    
      A latin letter (upper or lower case). Ascii: a-z, A-Z
      An underscore.                        Ascii: _
      A dollar sign.                        Ascii: $
      A latin letter with accents.          Unicode: \u00C0 - \u02AF
      A greek letter.                       Unicode: \u0370 - \u03FF
      A letter-like character.              Unicode: \u2100 - \u214F
      A mathematical alphanumeric symbol.   Unicode: \u{1D400} - \u{1D7FF} excluding invalid code points
    
  
  Contain only alpha characters (above) and digits 0-9
  Not be any of the following: mod, to, in, and, xor, or, not, end. It is possible to assign to some of these, but that’s not recommended.


It is possible to customize the allowed alpha characters, see Customize supported characters for more information.

Data types #

The expression parser supports booleans, numbers, complex numbers, units,
strings, matrices, and objects.

Booleans #

Booleans true and false can be used in expressions.

// use booleans
math.evaluate('true')               // true
math.evaluate('false')              // false
math.evaluate('(2 == 3) == false')  // true


Booleans can be converted to numbers and strings and vice versa using the
functions number and boolean, and string.

// convert booleans
math.evaluate('number(true)')       // 1
math.evaluate('string(false)')      // "false"
math.evaluate('boolean(1)')         // true
math.evaluate('boolean("false")')   // false


Numbers #

The most important and basic data type in math.js are numbers. Numbers use a
point as decimal mark. Numbers can be entered with exponential notation.
Examples:

// numbers in math.js
math.evaluate('2')        // 2
math.evaluate('3.14')     // 3.14
math.evaluate('1.4e3')    // 1400
math.evaluate('22e-3')    // 0.022


A number can be converted to a string and vice versa using the functions
number and string.

// convert a string into a number
math.evaluate('number("2.3")')    // 2.3
math.evaluate('string(2.3)')      // "2.3"


Math.js uses regular JavaScript numbers, which are floating points with a
limited precision and limited range. The limitations are described in detail
on the page Numbers.

math.evaluate('1e-325')   // 0
math.evaluate('1e309')    // Infinity
math.evaluate('-1e309')   // -Infinity


When doing calculations with floats, one can very easily get round-off errors:

// round-off error due to limited floating point precision
math.evaluate('0.1 + 0.2')  // 0.30000000000000004


When outputting results, the function math.format can be used to hide
these round-off errors when outputting results for the user:

const ans = math.evaluate('0.1 + 0.2')  //  0.30000000000000004
math.format(ans, {precision: 14})       // "0.3"


Numbers can be expressed as binary, octal, and hexadecimal literals:

math.evaluate('0b11')  //  3
math.evaluate('0o77')  //  63
math.evaluate('0xff')  //  255


A word size suffix can be used to change the behavior of non decimal literal evaluation:

math.evaluate('0xffi8')         // -1
math.evaluate('0xffffffffi32')  //  -1
math.evaluate('0xfffffffffi32') //  SyntaxError: String "0xfffffffff" is out of range


Non decimal numbers can include a radix point:
math.evaluate('0b1.1')         // 1.5
math.evaluate('0o1.4')         // 1.5
math.evaluate('0x1.8')         // 1.5


Numbers can be formatted as binary, octal, and hex strings using the notation option of the format function:

math.evaluate('format(3, {notation: "bin"})')    //  '0b11'
math.evaluate('format(63, {notation: "oct"})')   //  '0o77'
math.evaluate('format(255, {notation: "hex"})')  //  '0xff'
math.evaluate('format(-1, {notation: "hex"})')   //  '-0x1'
math.evaluate('format(2.3, {notation: "hex"})')  //  '0x2.4cccccccccccc'


The format function accepts a wordSize option to use in conjunction with the non binary notations:

math.evaluate('format(-1, {notation: "hex", wordSize: 8})')   //  '0xffi8'


The functions bin, oct, and hex are shorthand for the format function with notation set accordingly:

math.evaluate('bin(-1)')     // '-0b1'
math.evaluate('bin(-1, 8)')  // '0b11111111i8'


BigNumbers #

Math.js supports BigNumbers for calculations with an arbitrary precision.
The pros and cons of Number and BigNumber are explained in detail on the page
Numbers.

BigNumbers are slower but have a higher precision. Calculations with big
numbers are supported only by arithmetic functions.

BigNumbers can be created using the bignumber function:

math.evaluate('bignumber(0.1) + bignumber(0.2)') // BigNumber, 0.3


The default number type of the expression parser can be changed at instantiation
of math.js. The expression parser parses numbers as BigNumber by default:

// Configure the type of number: 'number' (default), 'BigNumber', or 'Fraction'
math.config({number: 'BigNumber'})

// all numbers are parsed as BigNumber
math.evaluate('0.1 + 0.2')  // BigNumber, 0.3


BigNumbers can be converted to numbers and vice versa using the functions
number and bignumber. When converting a BigNumber to a Number, the high
precision of the BigNumber will be lost. When a BigNumber is too large to be represented
as Number, it will be initialized as Infinity.

Complex numbers #

Complex numbers can be created using the imaginary unit i, which is defined
as i^2 = -1. Complex numbers have a real and complex part, which can be
retrieved using the functions re and im.

const parser = math.parser()

// create complex numbers
parser.evaluate('a = 2 + 3i')   // Complex, 2 + 3i
parser.evaluate('b = 4 - i')    // Complex, 4 - i

// get real and imaginary part of a complex number
parser.evaluate('re(a)')        // Number,  2
parser.evaluate('im(a)')        // Number,  3

// calculations with complex numbers
parser.evaluate('a + b')        // Complex, 6 + 2i
parser.evaluate('a * b')        // Complex, 11 + 10i
parser.evaluate('i * i')        // Number,  -1
parser.evaluate('sqrt(-4)')     // Complex, 2i


Units #

math.js supports units. Units can be used in the arithmetic operations
add, subtract, multiply, divide, and exponentiation.
Units can also be converted from one to another.
An overview of all available units can be found on the page
Units.

Units can be converted using the operator to or in.

// create a unit
math.evaluate('5.4 kg')                     // Unit, 5.4 kg

// convert a unit
math.evaluate('2 inch to cm')               // Unit, 5.08 cm
math.evaluate('20 celsius in fahrenheit')   // Unit, ~68 fahrenheit
math.evaluate('90 km/h to m/s')             // Unit, 25 m / s

// convert a unit to a number
// A second parameter with the unit for the exported number must be provided
math.evaluate('number(5 cm, mm)')           // Number, 50

// calculations with units
math.evaluate('0.5kg + 33g')                // Unit, 0.533 kg
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('12 seconds * 2')             // Unit, 24 seconds
math.evaluate('sin(45 deg)')                // Number, 0.7071067811865475
math.evaluate('9.81 m/s^2 * 5 s to mi/h')   // Unit, 109.72172512527 mi / h


Strings #

Strings are enclosed by double quotes “ or single quotes ‘. Strings can be concatenated using the
function concat (not by adding them using + like in JavaScript). Parts of
a string can be retrieved or replaced by using indexes. Strings can be converted
to a number using function number, and numbers can be converted to a string
using function string.

When setting the value of a character in a string, the character that has been
set is returned. Likewise, when a range of characters is set, that range of
characters is returned.

const parser = math.parser()

// create a string
parser.evaluate('"hello"')                        // String, "hello"

// string manipulation
parser.evaluate('a = concat("hello", " world")')  // String, "hello world"
parser.evaluate('size(a)')                        // Matrix [11]
parser.evaluate('a[1:5]')                         // String, "hello"
parser.evaluate('a[1] = "H"')                     // String, "H"
parser.evaluate('a[7:12] = "there!"')             // String, "there!"
parser.evaluate('a')                              // String, "Hello there!"

// string conversion
parser.evaluate('number("300")')                  // Number, 300
parser.evaluate('string(300)')                    // String, "300"


Strings can be used in the evaluate function, to parse expressions inside
the expression parser:

math.evaluate('evaluate("2 + 3")')  // 5


Matrices #

Matrices can be created by entering a series of values between square brackets,
elements are separated by a comma ,.
A matrix like [1, 2, 3] will create a vector, a 1-dimensional matrix with
size [3]. To create a multi-dimensional matrix, matrices can be nested into
each other. For easier creation of two-dimensional matrices, a semicolon ;
can be used to separate rows in a matrix.

// create a matrix
math.evaluate('[1, 2, 3]')                                // Matrix, size [3]
math.evaluate('[[1, 2, 3], [4, 5, 6]]')                   // Matrix, size [2, 3]
math.evaluate('[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]')     // Matrix, size [2, 2, 2]

// create a two dimensional matrix
math.evaluate('[1, 2, 3; 4, 5, 6]')                       // Matrix, size [2, 3]


Another way to create filled matrices is using the functions zeros, ones,
identity, and range.

// initialize a matrix with ones or zeros
math.evaluate('zeros(3, 2)')      // Matrix, [[0, 0], [0, 0], [0, 0]],  size [3, 2]
math.evaluate('ones(3)')          // Matrix, [1, 1, 1],                 size [3]
math.evaluate('5 * ones(2, 2)')   // Matrix, [[5, 5], [5, 5]],          size [2, 2]

// create an identity matrix
math.evaluate('identity(2)')      // Matrix, [[1, 0], [0, 1]],          size [2, 2]

// create a range
math.evaluate('1:4')              // Matrix, [1, 2, 3, 4],              size [4]
math.evaluate('0:2:10')           // Matrix, [0, 2, 4, 6, 8, 10],       size [6]


A subset can be retrieved from a matrix using indexes and a subset of a matrix
can be replaced by using indexes. Indexes are enclosed in square brackets, and
contain a number or a range for each of the matrix dimensions. A range can have
its start and/or end undefined. When the start is undefined, the range will start
at 1, when the end is undefined, the range will end at the end of the matrix.

There is a context variable end available as well to denote the end of the
matrix. This variable cannot be used in multiple nested indices. In that case,
end will be resolved as the end of the innermost matrix. To solve this, 
resolving of the nested index needs to be split in two separate operations.

IMPORTANT: matrix indexes and ranges work differently from the math.js indexes
in JavaScript: They are one-based with an included upper-bound, similar to most
math applications.

parser = math.parser()

// create matrices
parser.evaluate('a = [1, 2; 3, 4]')       // Matrix, [[1, 2], [3, 4]]
parser.evaluate('b = zeros(2, 2)')        // Matrix, [[0, 0], [0, 0]]
parser.evaluate('c = 5:9')                // Matrix, [5, 6, 7, 8, 9]

// replace a subset in a matrix
parser.evaluate('b[1, 1:2] = [5, 6]')     // Matrix, [[5, 6], [0, 0]]
parser.evaluate('b[2, :] = [7, 8]')       // Matrix, [[5, 6], [7, 8]]

// perform a matrix calculation
parser.evaluate('d = a * b')              // Matrix, [[19, 22], [43, 50]]

// retrieve a subset of a matrix
parser.evaluate('d[2, 1]')                // 43
parser.evaluate('d[2, 1:end]')            // Matrix, [[43, 50]]
parser.evaluate('c[end - 1 : -1 : 2]')    // Matrix, [8, 7, 6]


Objects #

Objects in math.js work the same as in languages like JavaScript and Python.
An object is enclosed by curly brackets {, }, and contains a set of
comma separated key/value pairs. Keys and values are separated by a colon :.
Keys can be a symbol like prop or a string like "prop".

math.evaluate('{a: 2 + 1, b: 4}')         // {a: 3, b: 4}
math.evaluate('{"a": 2 + 1, "b": 4}')     // {a: 3, b: 4}


Objects can contain objects:

math.evaluate('{a: 2, b: {c: 3, d: 4}}')  // {a: 2, b: {c: 3, d: 4}}


Object properties can be retrieved or replaced using dot notation or bracket
notation. Unlike JavaScript, when setting a property value, the whole object
is returned, not the property value

let scope = {
  obj: {
    prop: 42
  }
}

// retrieve properties
math.evaluate('obj.prop', scope)          // 42
math.evaluate('obj["prop"]', scope)       // 42

// set properties (returns the whole object, not the property value!)
math.evaluate('obj.prop = 43', scope)     // {prop: 43}
math.evaluate('obj["prop"] = 43', scope)  // {prop: 43}
scope.obj                                 // {prop: 43}


Multi-line expressions #

An expression can contain multiple lines, and expressions can be spread over
multiple lines. Lines can be separated by a newline character \n or by a
semicolon ;. Output of statements followed by a semicolon will be hidden from
the output, and empty lines are ignored. The output is returned as a ResultSet,
with an entry for every visible statement.

// a multi-line expression
math.evaluate('1 * 3 \n 2 * 3 \n 3 * 3')    // ResultSet, [3, 6, 9]

// semicolon statements are hidden from the output
math.evaluate('a=3; b=4; a + b \n a * b')   // ResultSet, [7, 12]

// single expression spread over multiple lines
math.evaluate('a = 2 +\n  3')               // 5
math.evaluate('[\n  1, 2;\n  3, 4\n]')      // Matrix, [[1, 2], [3, 4]]


The results can be read from a ResultSet via the property ResultSet.entries
which is an Array, or by calling ResultSet.valueOf(), which returns the
array with results.

Implicit multiplication #

Implicit multiplication means the multiplication of two symbols, numbers, or a grouped expression inside parentheses without using the * operator. This type of syntax allows a more natural way to enter expressions. For example:

math.evaluate('2 pi')         // 6.283185307179586
math.evaluate('(1+2)(3+4)')   // 21


Parentheses are parsed as a function call when there is a symbol or accessor on
the left hand side, like sqrt(4) or obj.method(4). In other cases the
parentheses are interpreted as an implicit multiplication.

Math.js will always evaluate implicit multiplication before explicit multiplication *, so that the expression x * y z is parsed as x * (y * z). Math.js also gives implicit multiplication higher precedence than division, except when the division matches the pattern [unaryPrefixOp]?[number] / [number] [symbol] or [unaryPrefixOp]?[number] / [number] [left paren]. In that special case, the division is evaluated first:

math.evaluate('20 kg / 4 kg')   // 5      Evaluated as (20 kg) / (4 kg)
math.evaluate('20 / 4 kg')      // 5 kg   Evaluated as (20 / 4) kg


The behavior of implicit multiplication can be summarized by these operator precedence rules, listed from highest to lowest precedence:


  Function calls: [symbol] [left paren]
  Explicit division / when the division matches this pattern: [+-~]?[number] / [+-~]?[number] [symbol] or [number] / [number] [left paren]
  Implicit multiplication
  All other division / and multiplication *


Implicit multiplication is tricky as there can appear to be ambiguity in how an expression will be evaluated. Experience has shown that the above rules most closely match user intent when entering expressions that could be interpreted different ways. It’s also possible that these rules could be tweaked in future major releases.  Use implicit multiplication carefully. If you don’t like the uncertainty introduced by implicit multiplication, use explicit * operators and parentheses to ensure your expression is evaluated the way you intend.

Here are some more examples using implicit multiplication:


  
    
      Expression
      Evaluated as
      Result
    
  
  
    
      (1 + 3) pi
      (1 + 3) * pi
      12.566370614359172
    
    
      (4 - 1) 2
      (4 - 1) * 2
      6
    
    
      3 / 4 mm
      (3 / 4) * mm
      0.75 mm
    
    
      2 + 3 i
      2 + (3 * i)
      2 + 3i
    
    
      (1 + 2) (4 - 2)
      (1 + 2) * (4 - 2)
      6
    
    
      sqrt(4) (1 + 2)
      sqrt(4) * (1 + 2)
      6
    
    
      8 pi / 2 pi
      (8 * pi) / (2 * pi)
      4
    
    
      pi / 2 pi
      pi / (2 * pi)
      0.5
    
    
      1 / 2i
      (1 / 2) * i
      0.5 i
    
    
      8.314 J / mol K
      8.314 J / (mol * K)
      8.314 J / (mol * K)
    
  


Comments #

Comments can be added to explain or describe calculations in the text. A comment
starts with a sharp sign character #, and ends at the end of the line. A line
can contain a comment only, or can contain an expression followed by a comment.

const parser = math.parser()

parser.evaluate('# define some variables')
parser.evaluate('width = 3')                              // 3
parser.evaluate('height = 4')                             // 4
parser.evaluate('width * height   # calculate the area')  // 12\n\n\n\nExpression syntax #

This page describes the syntax of expression parser of math.js. It describes
how to work with the available data types, functions, operators, variables,
and more.

Differences from JavaScript #

The expression parser of math.js is aimed at a mathematical audience,
not a programming audience. The syntax is similar to most calculators and
mathematical applications. This is close to JavaScript as well, though there
are a few important differences between the syntax of the expression parser and
the lower level syntax of math.js. Differences are:


  No need to prefix functions and constants with the math.* namespace,
you can just enter sin(pi / 4).
  Matrix indexes are one-based instead of zero-based.
  There are index and range operators which allow more conveniently getting
and setting matrix indexes, like A[2:4, 1].
  Both indexes and ranges and have the upper-bound included.
  There is a differing syntax for defining functions. Example: f(x) = x^2.
  There are custom operators like x + y instead of add(x, y).
  Some operators are different. For example  ^ is used for exponentiation,
not bitwise xor.
  Implicit multiplication, like 2 pi, is supported and has special rules.
  Relational operators (<, >, <=, >=, ==, and !=) are chained, so the expression 5 < x < 10 is equivalent to 5 < x and x < 10.
  Multi-expression constructs like a = 1; b = 2; a + b or
"a = 1;\n cos(a)\n sin(a)" (where \n denotes newline)
produce a collection (“ResultSet”) of values. Those expressions
terminated by ; are evaluated for side effect only and their values
are suppressed from the result.


Operators #

The expression parser has operators for all common arithmetic operations such
as addition and multiplication. The expression parser uses conventional infix
notation for operators: an operator is placed between its arguments.
Round parentheses can be used to override the default precedence of operators.

// use operators
math.evaluate('2 + 3')       // 5
math.evaluate('2 * 3')       // 6

// use parentheses to override the default precedence
math.evaluate('2 + 3 * 4')   // 14
math.evaluate('(2 + 3) * 4') // 20


The following operators are available. Note that almost every operator listed
also has a function form with identical meaning that can be used
interchangeably. For example, x+y will always evaluate identically to
add(x,y). For a full list of the equivalences, see the section on
Functions below.


  
    
      Operator
      Name
      Syntax
      Associativity
      Example
      Result
    
  
  
    
      (, )
      Grouping
      (x)
      None
      2 * (3 + 4)
      14
    
    
      [, ]
      Matrix, Index
      [...]
      None
      [[1,2],[3,4]]
      [[1,2],[3,4]]
    
    
      {, }
      Object
      {...}
      None
      {a: 1, b: 2}
      {a: 1, b: 2}
    
    
      ,
      Parameter separator
      x, y
      Left to right
      max(2, 1, 5)
      5
    
    
      .
      Property accessor
      obj.prop
      Left to right
      obj={a: 12}; obj.a
      12
    
    
      ;
      Statement separator
      x; y
      Left to right
      a=2; b=3; a*b
      [6]
    
    
      ;
      Row separator
      [x; y]
      Left to right
      [1,2;3,4]
      [[1,2],[3,4]]
    
    
      \n
      Statement separator
      x \n y
      Left to right
      a=2 \n b=3 \n a*b
      [2,3,6]
    
    
      +
      Add
      x + y
      Left to right
      4 + 5
      9
    
    
      +
      Unary plus
      +y
      Right to left
      +4
      4
    
    
      -
      Subtract
      x - y
      Left to right
      7 - 3
      4
    
    
      -
      Unary minus
      -y
      Right to left
      -4
      -4
    
    
      *
      Multiply
      x * y
      Left to right
      2 * 3
      6
    
    
      .*
      Element-wise multiply
      x .* y
      Left to right
      [1,2,3] .* [1,2,3]
      [1,4,9]
    
    
      /
      Divide
      x / y
      Left to right
      6 / 2
      3
    
    
      ./
      Element-wise divide
      x ./ y
      Left to right
      [9,6,4] ./ [3,2,2]
      [3,3,2]
    
    
      %
      Percentage
      x%
      None
      8%
      0.08
    
    
      %
      Addition with Percentage
      x + y%
      Left to right
      100 + 3%
      103
    
    
      %
      Subtraction with Percentage
      x - y%
      Left to right
      100 - 3%
      97
    
    
      % mod
      Modulus
      x % y
      Left to right
      8 % 3
      2
    
    
      ^
      Power
      x ^ y
      Right to left
      2 ^ 3
      8
    
    
      .^
      Element-wise power
      x .^ y
      Right to left
      [2,3] .^ [3,3]
      [8,27]
    
    
      '
      Transpose
      y'
      Left to right
      [[1,2],[3,4]]'
      [[1,3],[2,4]]
    
    
      !
      Factorial
      y!
      Left to right
      5!
      120
    
    
      &
      Bitwise and
      x & y
      Left to right
      5 & 3
      1
    
    
      ~
      Bitwise not
      ~x
      Right to left
      ~2
      -3
    
    
      |
      Bitwise or
      x | y
      Left to right
      5 | 3
      7
    
    
      ^|
      Bitwise xor
      x ^| y
      Left to right
      5 ^| 2
      7
    
    
      <<
      Left shift
      x << y
      Left to right
      4 << 1
      8
    
    
      >>
      Right arithmetic shift
      x >> y
      Left to right
      8 >> 1
      4
    
    
      >>>
      Right logical shift
      x >>> y
      Left to right
      -8 >>> 1
      2147483644
    
    
      and
      Logical and
      x and y
      Left to right
      true and false
      false
    
    
      not
      Logical not
      not y
      Right to left
      not true
      false
    
    
      or
      Logical or
      x or y
      Left to right
      true or false
      true
    
    
      xor
      Logical xor
      x xor y
      Left to right
      true xor true
      false
    
    
      =
      Assignment
      x = y
      Right to left
      a = 5
      5
    
    
      ? :
      Conditional expression
      x ? y : z
      Right to left
      15 > 100 ? 1 : -1
      -1
    
    
      :
      Range
      x : y
      Right to left
      1:4
      [1,2,3,4]
    
    
      to, in
      Unit conversion
      x to y
      Left to right
      2 inch to cm
      5.08 cm
    
    
      ==
      Equal
      x == y
      Left to right
      2 == 4 - 2
      true
    
    
      !=
      Unequal
      x != y
      Left to right
      2 != 3
      true
    
    
      <
      Smaller
      x < y
      Left to right
      2 < 3
      true
    
    
      >
      Larger
      x > y
      Left to right
      2 > 3
      false
    
    
      <=
      Smallereq
      x <= y
      Left to right
      4 <= 3
      false
    
    
      >=
      Largereq
      x >= y
      Left to right
      2 + 4 >= 6
      true
    
  


Precedence #

The operators have the following precedence, from highest to lowest:


  
    
      Operators
      Description
    
  
  
    
      (...)[...]{...}
      GroupingMatrixObject
    
    
      x(...)x[...]obj.prop:
      Function callMatrix indexProperty accessorKey/value separator
    
    
      '
      Matrix transpose
    
    
      !
      Factorial
    
    
      ^, .^
      Exponentiation
    
    
      +, -, ~, not
      Unary plus, unary minus, bitwise not, logical not
    
    
      See section below
      Implicit multiplication
    
    
      *, /, .*, ./,%, mod
      Multiply, divide , percentage, modulus
    
    
      +, -
      Add, subtract
    
    
      :
      Range
    
    
      to, in
      Unit conversion
    
    
      <<, >>, >>>
      Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift
    
    
      ==, !=, <, >, <=, >=
      Relational
    
    
      &
      Bitwise and (lazily evaluated)
    
    
      ^|
      Bitwise xor
    
    
      |
      Bitwise or (lazily evaluated)
    
    
      and
      Logical and (lazily evaluated)
    
    
      xor
      Logical xor
    
    
      or
      Logical or (lazily evaluated)
    
    
      ?, :
      Conditional expression
    
    
      =
      Assignment
    
    
      ,
      Parameter and column separator
    
    
      ;
      Row separator
    
    
      \n, ;
      Statement separators
    
  


Lazy evaluation is used where logically possible for bitwise and logical
operators. In the following example, the value of x will not even be 
evaluated because it cannot effect the final result:
math.evaluate('false and x')        // false, no matter what x equals


Functions #

Functions are called by entering their name, followed by zero or more
arguments enclosed by parentheses. All available functions are listed on the
page Functions.

math.evaluate('sqrt(25)')           // 5
math.evaluate('log(10000, 3 + 7)')  // 4
math.evaluate('sin(pi / 4)')        // 0.7071067811865475


New functions can be defined by “assigning” an expression to a function call
with one or more variables. Such function assignments are limited: they can
only be defined on a single line.

const parser = math.parser()

parser.evaluate('f(x) = x ^ 2 - 5')
parser.evaluate('f(2)')     // -1
parser.evaluate('f(3)')     // 4

parser.evaluate('g(x, y) = x ^ y')
parser.evaluate('g(2, 3)')  // 8


Note that these function assignments do not create closures; put another way,
all free variables in mathjs are dynamic:

const parser = math.parser()

parser.evaluate('x = 7')
parser.evaluate('h(y) = x + y')
parser.evaluate('h(3)')         // 10
parser.evaluate('x = 3')
parser.evaluate('h(3)')         // 6, *not* 10


It is however possible to pass functions as parameters:

const parser = math.parser()

parser.evaluate('twice(func, x) = func(func(x))')
parser.evaluate('twice(square, 2)')    // 16
parser.evaluate('f(x) = 3*x')
parser.evaluate('twice(f, 2)')         // 18

// a simplistic "numerical derivative":
parser.evaluate('eps = 1e-10')
parser.evaluate('nd(f, x) = (f(x+eps) - func(x-eps))/(2*eps)')
parser.evaluate('nd(square,2)')        // 4.000000330961484


Math.js itself heavily uses typed functions, which ensure correct inputs and
throws meaningful errors when the input arguments are invalid. One can create
a typed-function in the
expression parser like:

const parser = math.parser()

parser.evaluate('f = typed({"number": f(x) = x ^ 2 - 5})')


Finally, as mentioned above, there is a function form for nearly every one of
the mathematical operator symbols. Moreover, for some associative operators,
the corresponding function allows arbitrarily many arguments. The table below
gives the full correspondence.


  
    
      Operator Expression
      Equivalent Function Expression
    
  
  
    
      a or b
      or(a,b)
    
    
      a xor b
      xor(a,b)
    
    
      a and b
      and(a,b)
    
    
      a \| b
      bitOr(a,b)
    
    
      a ^\| b
      bitXor(a,b)
    
    
      a & b
      bitAnd(a,b)
    
    
      a == b
      equal(a,b)
    
    
      a != b
      unequal(a,b)
    
    
      a < b
      smaller(a,b)
    
    
      a > b
      larger(a,b)
    
    
      a <= b
      smallerEq(a,b)
    
    
      a << 3
      leftShift(a,3)
    
    
      a >> 3
      rightArithShift(a,3)
    
    
      a >>> 3
      rightLogShift(a,3)
    
    
      u to cm
      to(u, cm)
    
    
      a + b + c + ...
      add(a,b,c,...)
    
    
      a - b
      subtract(a,b)
    
    
      a * b * c * ...
      multiply(a,b,c,...)
    
    
      A .* B
      dotMultiply(A,B)
    
    
      A ./ B
      dotDivide(A,B)
    
    
      a mod b
      mod(a,b)
    
    
      +a
      unaryPlus(a)
    
    
      -a
      unaryMinus(a)
    
    
      ~a
      bitNot(a)
    
    
      not a
      not(a)
    
    
      a^b
      pow(a,b)
    
    
      A .^ B
      dotPow(A,B)
    
    
      a!
      factorial(a)
    
    
      A'
      ctranspose(A)
    
  


Note that math.js embodies a preference for the operator forms, in that calling
simplify (see Algebra) converts any instances of the function
form into the corresponding operator.

Map and forEach #

The map and forEach functions can be used to apply a callback function to each element of an array or matrix.

The callback functions can be functions, typed functions, inline functions (only in the parser) or compiled inline functions (only in the parser).

The callback can have the following inputs:

  value: the current value in the array or matrix.
  index: the index of the current value expressed as an array of numbers.
  array: the array or matrix being iterated.


Below is the syntax for both functions:

map #

The map function applies a function to each element of an array and returns a new array with the results.

const parser = math.parser()

// Define a square function
parser.evaluate('square(x) = x ^ 2')

// Apply the square function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], square)')
// result: [1, 4, 9, 16]

// Apply an inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], f(x) = x ^ 2)')
// result: [1, 4, 9, 16]

// Apply a compiled inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], x ^ 2)')
// result: [1, 4, 9, 16]


forEach #
The forEach function applies a function to each element of an array or matrix but does not return a new array. It is useful for executing side effects.

// Define a function that prints each element
math.import({consoleLog: x => console.log(x)})
const parser = math.parser()

// Define a squareConsleLog function
parser.evaluate('squareConsoleLog(x) = consoleLog(x ^ 2)')

// Apply the squareConsleLog function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], squareConsleLog)')
// Prints: 1, 4, 9, 16

// Apply an inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], f(x) = consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16

// Apply a compiled inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16


These functions are useful for performing element-wise operations on arrays or matrices.

Constants and variables #

Math.js has a number of built-in constants such as pi and e.
All available constants are listed on he page
Constants.

// use constants
math.evaluate('pi')                 // 3.141592653589793
math.evaluate('e ^ 2')              // 7.3890560989306495
math.evaluate('log(e)')             // 1
math.evaluate('e ^ (pi * i) + 1')   // ~0 (Euler)


Variables can be defined using the assignment operator =, and can be used
like constants.

const parser = math.parser()

// define variables
parser.evaluate('a = 3.4')      // 3.4
parser.evaluate('b = 5 / 2')    // 2.5

// use variables
parser.evaluate('a * b')        // 8.5


Variable names must:


  Begin with an “alpha character”, which is:
    
      A latin letter (upper or lower case). Ascii: a-z, A-Z
      An underscore.                        Ascii: _
      A dollar sign.                        Ascii: $
      A latin letter with accents.          Unicode: \u00C0 - \u02AF
      A greek letter.                       Unicode: \u0370 - \u03FF
      A letter-like character.              Unicode: \u2100 - \u214F
      A mathematical alphanumeric symbol.   Unicode: \u{1D400} - \u{1D7FF} excluding invalid code points
    
  
  Contain only alpha characters (above) and digits 0-9
  Not be any of the following: mod, to, in, and, xor, or, not, end. It is possible to assign to some of these, but that’s not recommended.


It is possible to customize the allowed alpha characters, see Customize supported characters for more information.

Data types #

The expression parser supports booleans, numbers, complex numbers, units,
strings, matrices, and objects.

Booleans #

Booleans true and false can be used in expressions.

// use booleans
math.evaluate('true')               // true
math.evaluate('false')              // false
math.evaluate('(2 == 3) == false')  // true


Booleans can be converted to numbers and strings and vice versa using the
functions number and boolean, and string.

// convert booleans
math.evaluate('number(true)')       // 1
math.evaluate('string(false)')      // "false"
math.evaluate('boolean(1)')         // true
math.evaluate('boolean("false")')   // false


Numbers #

The most important and basic data type in math.js are numbers. Numbers use a
point as decimal mark. Numbers can be entered with exponential notation.
Examples:

// numbers in math.js
math.evaluate('2')        // 2
math.evaluate('3.14')     // 3.14
math.evaluate('1.4e3')    // 1400
math.evaluate('22e-3')    // 0.022


A number can be converted to a string and vice versa using the functions
number and string.

// convert a string into a number
math.evaluate('number("2.3")')    // 2.3
math.evaluate('string(2.3)')      // "2.3"


Math.js uses regular JavaScript numbers, which are floating points with a
limited precision and limited range. The limitations are described in detail
on the page Numbers.

math.evaluate('1e-325')   // 0
math.evaluate('1e309')    // Infinity
math.evaluate('-1e309')   // -Infinity


When doing calculations with floats, one can very easily get round-off errors:

// round-off error due to limited floating point precision
math.evaluate('0.1 + 0.2')  // 0.30000000000000004


When outputting results, the function math.format can be used to hide
these round-off errors when outputting results for the user:

const ans = math.evaluate('0.1 + 0.2')  //  0.30000000000000004
math.format(ans, {precision: 14})       // "0.3"


Numbers can be expressed as binary, octal, and hexadecimal literals:

math.evaluate('0b11')  //  3
math.evaluate('0o77')  //  63
math.evaluate('0xff')  //  255


A word size suffix can be used to change the behavior of non decimal literal evaluation:

math.evaluate('0xffi8')         // -1
math.evaluate('0xffffffffi32')  //  -1
math.evaluate('0xfffffffffi32') //  SyntaxError: String "0xfffffffff" is out of range


Non decimal numbers can include a radix point:
math.evaluate('0b1.1')         // 1.5
math.evaluate('0o1.4')         // 1.5
math.evaluate('0x1.8')         // 1.5


Numbers can be formatted as binary, octal, and hex strings using the notation option of the format function:

math.evaluate('format(3, {notation: "bin"})')    //  '0b11'
math.evaluate('format(63, {notation: "oct"})')   //  '0o77'
math.evaluate('format(255, {notation: "hex"})')  //  '0xff'
math.evaluate('format(-1, {notation: "hex"})')   //  '-0x1'
math.evaluate('format(2.3, {notation: "hex"})')  //  '0x2.4cccccccccccc'


The format function accepts a wordSize option to use in conjunction with the non binary notations:

math.evaluate('format(-1, {notation: "hex", wordSize: 8})')   //  '0xffi8'


The functions bin, oct, and hex are shorthand for the format function with notation set accordingly:

math.evaluate('bin(-1)')     // '-0b1'
math.evaluate('bin(-1, 8)')  // '0b11111111i8'


BigNumbers #

Math.js supports BigNumbers for calculations with an arbitrary precision.
The pros and cons of Number and BigNumber are explained in detail on the page
Numbers.

BigNumbers are slower but have a higher precision. Calculations with big
numbers are supported only by arithmetic functions.

BigNumbers can be created using the bignumber function:

math.evaluate('bignumber(0.1) + bignumber(0.2)') // BigNumber, 0.3


The default number type of the expression parser can be changed at instantiation
of math.js. The expression parser parses numbers as BigNumber by default:

// Configure the type of number: 'number' (default), 'BigNumber', or 'Fraction'
math.config({number: 'BigNumber'})

// all numbers are parsed as BigNumber
math.evaluate('0.1 + 0.2')  // BigNumber, 0.3


BigNumbers can be converted to numbers and vice versa using the functions
number and bignumber. When converting a BigNumber to a Number, the high
precision of the BigNumber will be lost. When a BigNumber is too large to be represented
as Number, it will be initialized as Infinity.

Complex numbers #

Complex numbers can be created using the imaginary unit i, which is defined
as i^2 = -1. Complex numbers have a real and complex part, which can be
retrieved using the functions re and im.

const parser = math.parser()

// create complex numbers
parser.evaluate('a = 2 + 3i')   // Complex, 2 + 3i
parser.evaluate('b = 4 - i')    // Complex, 4 - i

// get real and imaginary part of a complex number
parser.evaluate('re(a)')        // Number,  2
parser.evaluate('im(a)')        // Number,  3

// calculations with complex numbers
parser.evaluate('a + b')        // Complex, 6 + 2i
parser.evaluate('a * b')        // Complex, 11 + 10i
parser.evaluate('i * i')        // Number,  -1
parser.evaluate('sqrt(-4)')     // Complex, 2i


Units #

math.js supports units. Units can be used in the arithmetic operations
add, subtract, multiply, divide, and exponentiation.
Units can also be converted from one to another.
An overview of all available units can be found on the page
Units.

Units can be converted using the operator to or in.

// create a unit
math.evaluate('5.4 kg')                     // Unit, 5.4 kg

// convert a unit
math.evaluate('2 inch to cm')               // Unit, 5.08 cm
math.evaluate('20 celsius in fahrenheit')   // Unit, ~68 fahrenheit
math.evaluate('90 km/h to m/s')             // Unit, 25 m / s

// convert a unit to a number
// A second parameter with the unit for the exported number must be provided
math.evaluate('number(5 cm, mm)')           // Number, 50

// calculations with units
math.evaluate('0.5kg + 33g')                // Unit, 0.533 kg
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('12 seconds * 2')             // Unit, 24 seconds
math.evaluate('sin(45 deg)')                // Number, 0.7071067811865475
math.evaluate('9.81 m/s^2 * 5 s to mi/h')   // Unit, 109.72172512527 mi / h


Strings #

Strings are enclosed by double quotes “ or single quotes ‘. Strings can be concatenated using the
function concat (not by adding them using + like in JavaScript). Parts of
a string can be retrieved or replaced by using indexes. Strings can be converted
to a number using function number, and numbers can be converted to a string
using function string.

When setting the value of a character in a string, the character that has been
set is returned. Likewise, when a range of characters is set, that range of
characters is returned.

const parser = math.parser()

// create a string
parser.evaluate('"hello"')                        // String, "hello"

// string manipulation
parser.evaluate('a = concat("hello", " world")')  // String, "hello world"
parser.evaluate('size(a)')                        // Matrix [11]
parser.evaluate('a[1:5]')                         // String, "hello"
parser.evaluate('a[1] = "H"')                     // String, "H"
parser.evaluate('a[7:12] = "there!"')             // String, "there!"
parser.evaluate('a')                              // String, "Hello there!"

// string conversion
parser.evaluate('number("300")')                  // Number, 300
parser.evaluate('string(300)')                    // String, "300"


Strings can be used in the evaluate function, to parse expressions inside
the expression parser:

math.evaluate('evaluate("2 + 3")')  // 5


Matrices #

Matrices can be created by entering a series of values between square brackets,
elements are separated by a comma ,.
A matrix like [1, 2, 3] will create a vector, a 1-dimensional matrix with
size [3]. To create a multi-dimensional matrix, matrices can be nested into
each other. For easier creation of two-dimensional matrices, a semicolon ;
can be used to separate rows in a matrix.

// create a matrix
math.evaluate('[1, 2, 3]')                                // Matrix, size [3]
math.evaluate('[[1, 2, 3], [4, 5, 6]]')                   // Matrix, size [2, 3]
math.evaluate('[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]')     // Matrix, size [2, 2, 2]

// create a two dimensional matrix
math.evaluate('[1, 2, 3; 4, 5, 6]')                       // Matrix, size [2, 3]


Another way to create filled matrices is using the functions zeros, ones,
identity, and range.

// initialize a matrix with ones or zeros
math.evaluate('zeros(3, 2)')      // Matrix, [[0, 0], [0, 0], [0, 0]],  size [3, 2]
math.evaluate('ones(3)')          // Matrix, [1, 1, 1],                 size [3]
math.evaluate('5 * ones(2, 2)')   // Matrix, [[5, 5], [5, 5]],          size [2, 2]

// create an identity matrix
math.evaluate('identity(2)')      // Matrix, [[1, 0], [0, 1]],          size [2, 2]

// create a range
math.evaluate('1:4')              // Matrix, [1, 2, 3, 4],              size [4]
math.evaluate('0:2:10')           // Matrix, [0, 2, 4, 6, 8, 10],       size [6]


A subset can be retrieved from a matrix using indexes and a subset of a matrix
can be replaced by using indexes. Indexes are enclosed in square brackets, and
contain a number or a range for each of the matrix dimensions. A range can have
its start and/or end undefined. When the start is undefined, the range will start
at 1, when the end is undefined, the range will end at the end of the matrix.

There is a context variable end available as well to denote the end of the
matrix. This variable cannot be used in multiple nested indices. In that case,
end will be resolved as the end of the innermost matrix. To solve this, 
resolving of the nested index needs to be split in two separate operations.

IMPORTANT: matrix indexes and ranges work differently from the math.js indexes
in JavaScript: They are one-based with an included upper-bound, similar to most
math applications.

parser = math.parser()

// create matrices
parser.evaluate('a = [1, 2; 3, 4]')       // Matrix, [[1, 2], [3, 4]]
parser.evaluate('b = zeros(2, 2)')        // Matrix, [[0, 0], [0, 0]]
parser.evaluate('c = 5:9')                // Matrix, [5, 6, 7, 8, 9]

// replace a subset in a matrix
parser.evaluate('b[1, 1:2] = [5, 6]')     // Matrix, [[5, 6], [0, 0]]
parser.evaluate('b[2, :] = [7, 8]')       // Matrix, [[5, 6], [7, 8]]

// perform a matrix calculation
parser.evaluate('d = a * b')              // Matrix, [[19, 22], [43, 50]]

// retrieve a subset of a matrix
parser.evaluate('d[2, 1]')                // 43
parser.evaluate('d[2, 1:end]')            // Matrix, [[43, 50]]
parser.evaluate('c[end - 1 : -1 : 2]')    // Matrix, [8, 7, 6]


Objects #

Objects in math.js work the same as in languages like JavaScript and Python.
An object is enclosed by curly brackets {, }, and contains a set of
comma separated key/value pairs. Keys and values are separated by a colon :.
Keys can be a symbol like prop or a string like "prop".

math.evaluate('{a: 2 + 1, b: 4}')         // {a: 3, b: 4}
math.evaluate('{"a": 2 + 1, "b": 4}')     // {a: 3, b: 4}


Objects can contain objects:

math.evaluate('{a: 2, b: {c: 3, d: 4}}')  // {a: 2, b: {c: 3, d: 4}}


Object properties can be retrieved or replaced using dot notation or bracket
notation. Unlike JavaScript, when setting a property value, the whole object
is returned, not the property value

let scope = {
  obj: {
    prop: 42
  }
}

// retrieve properties
math.evaluate('obj.prop', scope)          // 42
math.evaluate('obj["prop"]', scope)       // 42

// set properties (returns the whole object, not the property value!)
math.evaluate('obj.prop = 43', scope)     // {prop: 43}
math.evaluate('obj["prop"] = 43', scope)  // {prop: 43}
scope.obj                                 // {prop: 43}


Multi-line expressions #

An expression can contain multiple lines, and expressions can be spread over
multiple lines. Lines can be separated by a newline character \n or by a
semicolon ;. Output of statements followed by a semicolon will be hidden from
the output, and empty lines are ignored. The output is returned as a ResultSet,
with an entry for every visible statement.

// a multi-line expression
math.evaluate('1 * 3 \n 2 * 3 \n 3 * 3')    // ResultSet, [3, 6, 9]

// semicolon statements are hidden from the output
math.evaluate('a=3; b=4; a + b \n a * b')   // ResultSet, [7, 12]

// single expression spread over multiple lines
math.evaluate('a = 2 +\n  3')               // 5
math.evaluate('[\n  1, 2;\n  3, 4\n]')      // Matrix, [[1, 2], [3, 4]]


The results can be read from a ResultSet via the property ResultSet.entries
which is an Array, or by calling ResultSet.valueOf(), which returns the
array with results.

Implicit multiplication #

Implicit multiplication means the multiplication of two symbols, numbers, or a grouped expression inside parentheses without using the * operator. This type of syntax allows a more natural way to enter expressions. For example:

math.evaluate('2 pi')         // 6.283185307179586
math.evaluate('(1+2)(3+4)')   // 21


Parentheses are parsed as a function call when there is a symbol or accessor on
the left hand side, like sqrt(4) or obj.method(4). In other cases the
parentheses are interpreted as an implicit multiplication.

Math.js will always evaluate implicit multiplication before explicit multiplication *, so that the expression x * y z is parsed as x * (y * z). Math.js also gives implicit multiplication higher precedence than division, except when the division matches the pattern [unaryPrefixOp]?[number] / [number] [symbol] or [unaryPrefixOp]?[number] / [number] [left paren]. In that special case, the division is evaluated first:

math.evaluate('20 kg / 4 kg')   // 5      Evaluated as (20 kg) / (4 kg)
math.evaluate('20 / 4 kg')      // 5 kg   Evaluated as (20 / 4) kg


The behavior of implicit multiplication can be summarized by these operator precedence rules, listed from highest to lowest precedence:


  Function calls: [symbol] [left paren]
  Explicit division / when the division matches this pattern: [+-~]?[number] / [+-~]?[number] [symbol] or [number] / [number] [left paren]
  Implicit multiplication
  All other division / and multiplication *


Implicit multiplication is tricky as there can appear to be ambiguity in how an expression will be evaluated. Experience has shown that the above rules most closely match user intent when entering expressions that could be interpreted different ways. It’s also possible that these rules could be tweaked in future major releases.  Use implicit multiplication carefully. If you don’t like the uncertainty introduced by implicit multiplication, use explicit * operators and parentheses to ensure your expression is evaluated the way you intend.

Here are some more examples using implicit multiplication:


  
    
      Expression
      Evaluated as
      Result
    
  
  
    
      (1 + 3) pi
      (1 + 3) * pi
      12.566370614359172
    
    
      (4 - 1) 2
      (4 - 1) * 2
      6
    
    
      3 / 4 mm
      (3 / 4) * mm
      0.75 mm
    
    
      2 + 3 i
      2 + (3 * i)
      2 + 3i
    
    
      (1 + 2) (4 - 2)
      (1 + 2) * (4 - 2)
      6
    
    
      sqrt(4) (1 + 2)
      sqrt(4) * (1 + 2)
      6
    
    
      8 pi / 2 pi
      (8 * pi) / (2 * pi)
      4
    
    
      pi / 2 pi
      pi / (2 * pi)
      0.5
    
    
      1 / 2i
      (1 / 2) * i
      0.5 i
    
    
      8.314 J / mol K
      8.314 J / (mol * K)
      8.314 J / (mol * K)
    
  


Comments #

Comments can be added to explain or describe calculations in the text. A comment
starts with a sharp sign character #, and ends at the end of the line. A line
can contain a comment only, or can contain an expression followed by a comment.

const parser = math.parser()

parser.evaluate('# define some variables')
parser.evaluate('width = 3')                              // 3
parser.evaluate('height = 4')                             // 4
parser.evaluate('width * height   # calculate the area')  // 12\n\n\n\nExpression syntax #

This page describes the syntax of expression parser of math.js. It describes
how to work with the available data types, functions, operators, variables,
and more.

Differences from JavaScript #

The expression parser of math.js is aimed at a mathematical audience,
not a programming audience. The syntax is similar to most calculators and
mathematical applications. This is close to JavaScript as well, though there
are a few important differences between the syntax of the expression parser and
the lower level syntax of math.js. Differences are:


  No need to prefix functions and constants with the math.* namespace,
you can just enter sin(pi / 4).
  Matrix indexes are one-based instead of zero-based.
  There are index and range operators which allow more conveniently getting
and setting matrix indexes, like A[2:4, 1].
  Both indexes and ranges and have the upper-bound included.
  There is a differing syntax for defining functions. Example: f(x) = x^2.
  There are custom operators like x + y instead of add(x, y).
  Some operators are different. For example  ^ is used for exponentiation,
not bitwise xor.
  Implicit multiplication, like 2 pi, is supported and has special rules.
  Relational operators (<, >, <=, >=, ==, and !=) are chained, so the expression 5 < x < 10 is equivalent to 5 < x and x < 10.
  Multi-expression constructs like a = 1; b = 2; a + b or
"a = 1;\n cos(a)\n sin(a)" (where \n denotes newline)
produce a collection (“ResultSet”) of values. Those expressions
terminated by ; are evaluated for side effect only and their values
are suppressed from the result.


Operators #

The expression parser has operators for all common arithmetic operations such
as addition and multiplication. The expression parser uses conventional infix
notation for operators: an operator is placed between its arguments.
Round parentheses can be used to override the default precedence of operators.

// use operators
math.evaluate('2 + 3')       // 5
math.evaluate('2 * 3')       // 6

// use parentheses to override the default precedence
math.evaluate('2 + 3 * 4')   // 14
math.evaluate('(2 + 3) * 4') // 20


The following operators are available. Note that almost every operator listed
also has a function form with identical meaning that can be used
interchangeably. For example, x+y will always evaluate identically to
add(x,y). For a full list of the equivalences, see the section on
Functions below.


  
    
      Operator
      Name
      Syntax
      Associativity
      Example
      Result
    
  
  
    
      (, )
      Grouping
      (x)
      None
      2 * (3 + 4)
      14
    
    
      [, ]
      Matrix, Index
      [...]
      None
      [[1,2],[3,4]]
      [[1,2],[3,4]]
    
    
      {, }
      Object
      {...}
      None
      {a: 1, b: 2}
      {a: 1, b: 2}
    
    
      ,
      Parameter separator
      x, y
      Left to right
      max(2, 1, 5)
      5
    
    
      .
      Property accessor
      obj.prop
      Left to right
      obj={a: 12}; obj.a
      12
    
    
      ;
      Statement separator
      x; y
      Left to right
      a=2; b=3; a*b
      [6]
    
    
      ;
      Row separator
      [x; y]
      Left to right
      [1,2;3,4]
      [[1,2],[3,4]]
    
    
      \n
      Statement separator
      x \n y
      Left to right
      a=2 \n b=3 \n a*b
      [2,3,6]
    
    
      +
      Add
      x + y
      Left to right
      4 + 5
      9
    
    
      +
      Unary plus
      +y
      Right to left
      +4
      4
    
    
      -
      Subtract
      x - y
      Left to right
      7 - 3
      4
    
    
      -
      Unary minus
      -y
      Right to left
      -4
      -4
    
    
      *
      Multiply
      x * y
      Left to right
      2 * 3
      6
    
    
      .*
      Element-wise multiply
      x .* y
      Left to right
      [1,2,3] .* [1,2,3]
      [1,4,9]
    
    
      /
      Divide
      x / y
      Left to right
      6 / 2
      3
    
    
      ./
      Element-wise divide
      x ./ y
      Left to right
      [9,6,4] ./ [3,2,2]
      [3,3,2]
    
    
      %
      Percentage
      x%
      None
      8%
      0.08
    
    
      %
      Addition with Percentage
      x + y%
      Left to right
      100 + 3%
      103
    
    
      %
      Subtraction with Percentage
      x - y%
      Left to right
      100 - 3%
      97
    
    
      % mod
      Modulus
      x % y
      Left to right
      8 % 3
      2
    
    
      ^
      Power
      x ^ y
      Right to left
      2 ^ 3
      8
    
    
      .^
      Element-wise power
      x .^ y
      Right to left
      [2,3] .^ [3,3]
      [8,27]
    
    
      '
      Transpose
      y'
      Left to right
      [[1,2],[3,4]]'
      [[1,3],[2,4]]
    
    
      !
      Factorial
      y!
      Left to right
      5!
      120
    
    
      &
      Bitwise and
      x & y
      Left to right
      5 & 3
      1
    
    
      ~
      Bitwise not
      ~x
      Right to left
      ~2
      -3
    
    
      |
      Bitwise or
      x | y
      Left to right
      5 | 3
      7
    
    
      ^|
      Bitwise xor
      x ^| y
      Left to right
      5 ^| 2
      7
    
    
      <<
      Left shift
      x << y
      Left to right
      4 << 1
      8
    
    
      >>
      Right arithmetic shift
      x >> y
      Left to right
      8 >> 1
      4
    
    
      >>>
      Right logical shift
      x >>> y
      Left to right
      -8 >>> 1
      2147483644
    
    
      and
      Logical and
      x and y
      Left to right
      true and false
      false
    
    
      not
      Logical not
      not y
      Right to left
      not true
      false
    
    
      or
      Logical or
      x or y
      Left to right
      true or false
      true
    
    
      xor
      Logical xor
      x xor y
      Left to right
      true xor true
      false
    
    
      =
      Assignment
      x = y
      Right to left
      a = 5
      5
    
    
      ? :
      Conditional expression
      x ? y : z
      Right to left
      15 > 100 ? 1 : -1
      -1
    
    
      :
      Range
      x : y
      Right to left
      1:4
      [1,2,3,4]
    
    
      to, in
      Unit conversion
      x to y
      Left to right
      2 inch to cm
      5.08 cm
    
    
      ==
      Equal
      x == y
      Left to right
      2 == 4 - 2
      true
    
    
      !=
      Unequal
      x != y
      Left to right
      2 != 3
      true
    
    
      <
      Smaller
      x < y
      Left to right
      2 < 3
      true
    
    
      >
      Larger
      x > y
      Left to right
      2 > 3
      false
    
    
      <=
      Smallereq
      x <= y
      Left to right
      4 <= 3
      false
    
    
      >=
      Largereq
      x >= y
      Left to right
      2 + 4 >= 6
      true
    
  


Precedence #

The operators have the following precedence, from highest to lowest:


  
    
      Operators
      Description
    
  
  
    
      (...)[...]{...}
      GroupingMatrixObject
    
    
      x(...)x[...]obj.prop:
      Function callMatrix indexProperty accessorKey/value separator
    
    
      '
      Matrix transpose
    
    
      !
      Factorial
    
    
      ^, .^
      Exponentiation
    
    
      +, -, ~, not
      Unary plus, unary minus, bitwise not, logical not
    
    
      See section below
      Implicit multiplication
    
    
      *, /, .*, ./,%, mod
      Multiply, divide , percentage, modulus
    
    
      +, -
      Add, subtract
    
    
      :
      Range
    
    
      to, in
      Unit conversion
    
    
      <<, >>, >>>
      Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift
    
    
      ==, !=, <, >, <=, >=
      Relational
    
    
      &
      Bitwise and (lazily evaluated)
    
    
      ^|
      Bitwise xor
    
    
      |
      Bitwise or (lazily evaluated)
    
    
      and
      Logical and (lazily evaluated)
    
    
      xor
      Logical xor
    
    
      or
      Logical or (lazily evaluated)
    
    
      ?, :
      Conditional expression
    
    
      =
      Assignment
    
    
      ,
      Parameter and column separator
    
    
      ;
      Row separator
    
    
      \n, ;
      Statement separators
    
  


Lazy evaluation is used where logically possible for bitwise and logical
operators. In the following example, the value of x will not even be 
evaluated because it cannot effect the final result:
math.evaluate('false and x')        // false, no matter what x equals


Functions #

Functions are called by entering their name, followed by zero or more
arguments enclosed by parentheses. All available functions are listed on the
page Functions.

math.evaluate('sqrt(25)')           // 5
math.evaluate('log(10000, 3 + 7)')  // 4
math.evaluate('sin(pi / 4)')        // 0.7071067811865475


New functions can be defined by “assigning” an expression to a function call
with one or more variables. Such function assignments are limited: they can
only be defined on a single line.

const parser = math.parser()

parser.evaluate('f(x) = x ^ 2 - 5')
parser.evaluate('f(2)')     // -1
parser.evaluate('f(3)')     // 4

parser.evaluate('g(x, y) = x ^ y')
parser.evaluate('g(2, 3)')  // 8


Note that these function assignments do not create closures; put another way,
all free variables in mathjs are dynamic:

const parser = math.parser()

parser.evaluate('x = 7')
parser.evaluate('h(y) = x + y')
parser.evaluate('h(3)')         // 10
parser.evaluate('x = 3')
parser.evaluate('h(3)')         // 6, *not* 10


It is however possible to pass functions as parameters:

const parser = math.parser()

parser.evaluate('twice(func, x) = func(func(x))')
parser.evaluate('twice(square, 2)')    // 16
parser.evaluate('f(x) = 3*x')
parser.evaluate('twice(f, 2)')         // 18

// a simplistic "numerical derivative":
parser.evaluate('eps = 1e-10')
parser.evaluate('nd(f, x) = (f(x+eps) - func(x-eps))/(2*eps)')
parser.evaluate('nd(square,2)')        // 4.000000330961484


Math.js itself heavily uses typed functions, which ensure correct inputs and
throws meaningful errors when the input arguments are invalid. One can create
a typed-function in the
expression parser like:

const parser = math.parser()

parser.evaluate('f = typed({"number": f(x) = x ^ 2 - 5})')


Finally, as mentioned above, there is a function form for nearly every one of
the mathematical operator symbols. Moreover, for some associative operators,
the corresponding function allows arbitrarily many arguments. The table below
gives the full correspondence.


  
    
      Operator Expression
      Equivalent Function Expression
    
  
  
    
      a or b
      or(a,b)
    
    
      a xor b
      xor(a,b)
    
    
      a and b
      and(a,b)
    
    
      a \| b
      bitOr(a,b)
    
    
      a ^\| b
      bitXor(a,b)
    
    
      a & b
      bitAnd(a,b)
    
    
      a == b
      equal(a,b)
    
    
      a != b
      unequal(a,b)
    
    
      a < b
      smaller(a,b)
    
    
      a > b
      larger(a,b)
    
    
      a <= b
      smallerEq(a,b)
    
    
      a << 3
      leftShift(a,3)
    
    
      a >> 3
      rightArithShift(a,3)
    
    
      a >>> 3
      rightLogShift(a,3)
    
    
      u to cm
      to(u, cm)
    
    
      a + b + c + ...
      add(a,b,c,...)
    
    
      a - b
      subtract(a,b)
    
    
      a * b * c * ...
      multiply(a,b,c,...)
    
    
      A .* B
      dotMultiply(A,B)
    
    
      A ./ B
      dotDivide(A,B)
    
    
      a mod b
      mod(a,b)
    
    
      +a
      unaryPlus(a)
    
    
      -a
      unaryMinus(a)
    
    
      ~a
      bitNot(a)
    
    
      not a
      not(a)
    
    
      a^b
      pow(a,b)
    
    
      A .^ B
      dotPow(A,B)
    
    
      a!
      factorial(a)
    
    
      A'
      ctranspose(A)
    
  


Note that math.js embodies a preference for the operator forms, in that calling
simplify (see Algebra) converts any instances of the function
form into the corresponding operator.

Map and forEach #

The map and forEach functions can be used to apply a callback function to each element of an array or matrix.

The callback functions can be functions, typed functions, inline functions (only in the parser) or compiled inline functions (only in the parser).

The callback can have the following inputs:

  value: the current value in the array or matrix.
  index: the index of the current value expressed as an array of numbers.
  array: the array or matrix being iterated.


Below is the syntax for both functions:

map #

The map function applies a function to each element of an array and returns a new array with the results.

const parser = math.parser()

// Define a square function
parser.evaluate('square(x) = x ^ 2')

// Apply the square function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], square)')
// result: [1, 4, 9, 16]

// Apply an inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], f(x) = x ^ 2)')
// result: [1, 4, 9, 16]

// Apply a compiled inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], x ^ 2)')
// result: [1, 4, 9, 16]


forEach #
The forEach function applies a function to each element of an array or matrix but does not return a new array. It is useful for executing side effects.

// Define a function that prints each element
math.import({consoleLog: x => console.log(x)})
const parser = math.parser()

// Define a squareConsleLog function
parser.evaluate('squareConsoleLog(x) = consoleLog(x ^ 2)')

// Apply the squareConsleLog function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], squareConsleLog)')
// Prints: 1, 4, 9, 16

// Apply an inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], f(x) = consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16

// Apply a compiled inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16


These functions are useful for performing element-wise operations on arrays or matrices.

Constants and variables #

Math.js has a number of built-in constants such as pi and e.
All available constants are listed on he page
Constants.

// use constants
math.evaluate('pi')                 // 3.141592653589793
math.evaluate('e ^ 2')              // 7.3890560989306495
math.evaluate('log(e)')             // 1
math.evaluate('e ^ (pi * i) + 1')   // ~0 (Euler)


Variables can be defined using the assignment operator =, and can be used
like constants.

const parser = math.parser()

// define variables
parser.evaluate('a = 3.4')      // 3.4
parser.evaluate('b = 5 / 2')    // 2.5

// use variables
parser.evaluate('a * b')        // 8.5


Variable names must:


  Begin with an “alpha character”, which is:
    
      A latin letter (upper or lower case). Ascii: a-z, A-Z
      An underscore.                        Ascii: _
      A dollar sign.                        Ascii: $
      A latin letter with accents.          Unicode: \u00C0 - \u02AF
      A greek letter.                       Unicode: \u0370 - \u03FF
      A letter-like character.              Unicode: \u2100 - \u214F
      A mathematical alphanumeric symbol.   Unicode: \u{1D400} - \u{1D7FF} excluding invalid code points
    
  
  Contain only alpha characters (above) and digits 0-9
  Not be any of the following: mod, to, in, and, xor, or, not, end. It is possible to assign to some of these, but that’s not recommended.


It is possible to customize the allowed alpha characters, see Customize supported characters for more information.

Data types #

The expression parser supports booleans, numbers, complex numbers, units,
strings, matrices, and objects.

Booleans #

Booleans true and false can be used in expressions.

// use booleans
math.evaluate('true')               // true
math.evaluate('false')              // false
math.evaluate('(2 == 3) == false')  // true


Booleans can be converted to numbers and strings and vice versa using the
functions number and boolean, and string.

// convert booleans
math.evaluate('number(true)')       // 1
math.evaluate('string(false)')      // "false"
math.evaluate('boolean(1)')         // true
math.evaluate('boolean("false")')   // false


Numbers #

The most important and basic data type in math.js are numbers. Numbers use a
point as decimal mark. Numbers can be entered with exponential notation.
Examples:

// numbers in math.js
math.evaluate('2')        // 2
math.evaluate('3.14')     // 3.14
math.evaluate('1.4e3')    // 1400
math.evaluate('22e-3')    // 0.022


A number can be converted to a string and vice versa using the functions
number and string.

// convert a string into a number
math.evaluate('number("2.3")')    // 2.3
math.evaluate('string(2.3)')      // "2.3"


Math.js uses regular JavaScript numbers, which are floating points with a
limited precision and limited range. The limitations are described in detail
on the page Numbers.

math.evaluate('1e-325')   // 0
math.evaluate('1e309')    // Infinity
math.evaluate('-1e309')   // -Infinity


When doing calculations with floats, one can very easily get round-off errors:

// round-off error due to limited floating point precision
math.evaluate('0.1 + 0.2')  // 0.30000000000000004


When outputting results, the function math.format can be used to hide
these round-off errors when outputting results for the user:

const ans = math.evaluate('0.1 + 0.2')  //  0.30000000000000004
math.format(ans, {precision: 14})       // "0.3"


Numbers can be expressed as binary, octal, and hexadecimal literals:

math.evaluate('0b11')  //  3
math.evaluate('0o77')  //  63
math.evaluate('0xff')  //  255


A word size suffix can be used to change the behavior of non decimal literal evaluation:

math.evaluate('0xffi8')         // -1
math.evaluate('0xffffffffi32')  //  -1
math.evaluate('0xfffffffffi32') //  SyntaxError: String "0xfffffffff" is out of range


Non decimal numbers can include a radix point:
math.evaluate('0b1.1')         // 1.5
math.evaluate('0o1.4')         // 1.5
math.evaluate('0x1.8')         // 1.5


Numbers can be formatted as binary, octal, and hex strings using the notation option of the format function:

math.evaluate('format(3, {notation: "bin"})')    //  '0b11'
math.evaluate('format(63, {notation: "oct"})')   //  '0o77'
math.evaluate('format(255, {notation: "hex"})')  //  '0xff'
math.evaluate('format(-1, {notation: "hex"})')   //  '-0x1'
math.evaluate('format(2.3, {notation: "hex"})')  //  '0x2.4cccccccccccc'


The format function accepts a wordSize option to use in conjunction with the non binary notations:

math.evaluate('format(-1, {notation: "hex", wordSize: 8})')   //  '0xffi8'


The functions bin, oct, and hex are shorthand for the format function with notation set accordingly:

math.evaluate('bin(-1)')     // '-0b1'
math.evaluate('bin(-1, 8)')  // '0b11111111i8'


BigNumbers #

Math.js supports BigNumbers for calculations with an arbitrary precision.
The pros and cons of Number and BigNumber are explained in detail on the page
Numbers.

BigNumbers are slower but have a higher precision. Calculations with big
numbers are supported only by arithmetic functions.

BigNumbers can be created using the bignumber function:

math.evaluate('bignumber(0.1) + bignumber(0.2)') // BigNumber, 0.3


The default number type of the expression parser can be changed at instantiation
of math.js. The expression parser parses numbers as BigNumber by default:

// Configure the type of number: 'number' (default), 'BigNumber', or 'Fraction'
math.config({number: 'BigNumber'})

// all numbers are parsed as BigNumber
math.evaluate('0.1 + 0.2')  // BigNumber, 0.3


BigNumbers can be converted to numbers and vice versa using the functions
number and bignumber. When converting a BigNumber to a Number, the high
precision of the BigNumber will be lost. When a BigNumber is too large to be represented
as Number, it will be initialized as Infinity.

Complex numbers #

Complex numbers can be created using the imaginary unit i, which is defined
as i^2 = -1. Complex numbers have a real and complex part, which can be
retrieved using the functions re and im.

const parser = math.parser()

// create complex numbers
parser.evaluate('a = 2 + 3i')   // Complex, 2 + 3i
parser.evaluate('b = 4 - i')    // Complex, 4 - i

// get real and imaginary part of a complex number
parser.evaluate('re(a)')        // Number,  2
parser.evaluate('im(a)')        // Number,  3

// calculations with complex numbers
parser.evaluate('a + b')        // Complex, 6 + 2i
parser.evaluate('a * b')        // Complex, 11 + 10i
parser.evaluate('i * i')        // Number,  -1
parser.evaluate('sqrt(-4)')     // Complex, 2i


Units #

math.js supports units. Units can be used in the arithmetic operations
add, subtract, multiply, divide, and exponentiation.
Units can also be converted from one to another.
An overview of all available units can be found on the page
Units.

Units can be converted using the operator to or in.

// create a unit
math.evaluate('5.4 kg')                     // Unit, 5.4 kg

// convert a unit
math.evaluate('2 inch to cm')               // Unit, 5.08 cm
math.evaluate('20 celsius in fahrenheit')   // Unit, ~68 fahrenheit
math.evaluate('90 km/h to m/s')             // Unit, 25 m / s

// convert a unit to a number
// A second parameter with the unit for the exported number must be provided
math.evaluate('number(5 cm, mm)')           // Number, 50

// calculations with units
math.evaluate('0.5kg + 33g')                // Unit, 0.533 kg
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('12 seconds * 2')             // Unit, 24 seconds
math.evaluate('sin(45 deg)')                // Number, 0.7071067811865475
math.evaluate('9.81 m/s^2 * 5 s to mi/h')   // Unit, 109.72172512527 mi / h


Strings #

Strings are enclosed by double quotes “ or single quotes ‘. Strings can be concatenated using the
function concat (not by adding them using + like in JavaScript). Parts of
a string can be retrieved or replaced by using indexes. Strings can be converted
to a number using function number, and numbers can be converted to a string
using function string.

When setting the value of a character in a string, the character that has been
set is returned. Likewise, when a range of characters is set, that range of
characters is returned.

const parser = math.parser()

// create a string
parser.evaluate('"hello"')                        // String, "hello"

// string manipulation
parser.evaluate('a = concat("hello", " world")')  // String, "hello world"
parser.evaluate('size(a)')                        // Matrix [11]
parser.evaluate('a[1:5]')                         // String, "hello"
parser.evaluate('a[1] = "H"')                     // String, "H"
parser.evaluate('a[7:12] = "there!"')             // String, "there!"
parser.evaluate('a')                              // String, "Hello there!"

// string conversion
parser.evaluate('number("300")')                  // Number, 300
parser.evaluate('string(300)')                    // String, "300"


Strings can be used in the evaluate function, to parse expressions inside
the expression parser:

math.evaluate('evaluate("2 + 3")')  // 5


Matrices #

Matrices can be created by entering a series of values between square brackets,
elements are separated by a comma ,.
A matrix like [1, 2, 3] will create a vector, a 1-dimensional matrix with
size [3]. To create a multi-dimensional matrix, matrices can be nested into
each other. For easier creation of two-dimensional matrices, a semicolon ;
can be used to separate rows in a matrix.

// create a matrix
math.evaluate('[1, 2, 3]')                                // Matrix, size [3]
math.evaluate('[[1, 2, 3], [4, 5, 6]]')                   // Matrix, size [2, 3]
math.evaluate('[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]')     // Matrix, size [2, 2, 2]

// create a two dimensional matrix
math.evaluate('[1, 2, 3; 4, 5, 6]')                       // Matrix, size [2, 3]


Another way to create filled matrices is using the functions zeros, ones,
identity, and range.

// initialize a matrix with ones or zeros
math.evaluate('zeros(3, 2)')      // Matrix, [[0, 0], [0, 0], [0, 0]],  size [3, 2]
math.evaluate('ones(3)')          // Matrix, [1, 1, 1],                 size [3]
math.evaluate('5 * ones(2, 2)')   // Matrix, [[5, 5], [5, 5]],          size [2, 2]

// create an identity matrix
math.evaluate('identity(2)')      // Matrix, [[1, 0], [0, 1]],          size [2, 2]

// create a range
math.evaluate('1:4')              // Matrix, [1, 2, 3, 4],              size [4]
math.evaluate('0:2:10')           // Matrix, [0, 2, 4, 6, 8, 10],       size [6]


A subset can be retrieved from a matrix using indexes and a subset of a matrix
can be replaced by using indexes. Indexes are enclosed in square brackets, and
contain a number or a range for each of the matrix dimensions. A range can have
its start and/or end undefined. When the start is undefined, the range will start
at 1, when the end is undefined, the range will end at the end of the matrix.

There is a context variable end available as well to denote the end of the
matrix. This variable cannot be used in multiple nested indices. In that case,
end will be resolved as the end of the innermost matrix. To solve this, 
resolving of the nested index needs to be split in two separate operations.

IMPORTANT: matrix indexes and ranges work differently from the math.js indexes
in JavaScript: They are one-based with an included upper-bound, similar to most
math applications.

parser = math.parser()

// create matrices
parser.evaluate('a = [1, 2; 3, 4]')       // Matrix, [[1, 2], [3, 4]]
parser.evaluate('b = zeros(2, 2)')        // Matrix, [[0, 0], [0, 0]]
parser.evaluate('c = 5:9')                // Matrix, [5, 6, 7, 8, 9]

// replace a subset in a matrix
parser.evaluate('b[1, 1:2] = [5, 6]')     // Matrix, [[5, 6], [0, 0]]
parser.evaluate('b[2, :] = [7, 8]')       // Matrix, [[5, 6], [7, 8]]

// perform a matrix calculation
parser.evaluate('d = a * b')              // Matrix, [[19, 22], [43, 50]]

// retrieve a subset of a matrix
parser.evaluate('d[2, 1]')                // 43
parser.evaluate('d[2, 1:end]')            // Matrix, [[43, 50]]
parser.evaluate('c[end - 1 : -1 : 2]')    // Matrix, [8, 7, 6]


Objects #

Objects in math.js work the same as in languages like JavaScript and Python.
An object is enclosed by curly brackets {, }, and contains a set of
comma separated key/value pairs. Keys and values are separated by a colon :.
Keys can be a symbol like prop or a string like "prop".

math.evaluate('{a: 2 + 1, b: 4}')         // {a: 3, b: 4}
math.evaluate('{"a": 2 + 1, "b": 4}')     // {a: 3, b: 4}


Objects can contain objects:

math.evaluate('{a: 2, b: {c: 3, d: 4}}')  // {a: 2, b: {c: 3, d: 4}}


Object properties can be retrieved or replaced using dot notation or bracket
notation. Unlike JavaScript, when setting a property value, the whole object
is returned, not the property value

let scope = {
  obj: {
    prop: 42
  }
}

// retrieve properties
math.evaluate('obj.prop', scope)          // 42
math.evaluate('obj["prop"]', scope)       // 42

// set properties (returns the whole object, not the property value!)
math.evaluate('obj.prop = 43', scope)     // {prop: 43}
math.evaluate('obj["prop"] = 43', scope)  // {prop: 43}
scope.obj                                 // {prop: 43}


Multi-line expressions #

An expression can contain multiple lines, and expressions can be spread over
multiple lines. Lines can be separated by a newline character \n or by a
semicolon ;. Output of statements followed by a semicolon will be hidden from
the output, and empty lines are ignored. The output is returned as a ResultSet,
with an entry for every visible statement.

// a multi-line expression
math.evaluate('1 * 3 \n 2 * 3 \n 3 * 3')    // ResultSet, [3, 6, 9]

// semicolon statements are hidden from the output
math.evaluate('a=3; b=4; a + b \n a * b')   // ResultSet, [7, 12]

// single expression spread over multiple lines
math.evaluate('a = 2 +\n  3')               // 5
math.evaluate('[\n  1, 2;\n  3, 4\n]')      // Matrix, [[1, 2], [3, 4]]


The results can be read from a ResultSet via the property ResultSet.entries
which is an Array, or by calling ResultSet.valueOf(), which returns the
array with results.

Implicit multiplication #

Implicit multiplication means the multiplication of two symbols, numbers, or a grouped expression inside parentheses without using the * operator. This type of syntax allows a more natural way to enter expressions. For example:

math.evaluate('2 pi')         // 6.283185307179586
math.evaluate('(1+2)(3+4)')   // 21


Parentheses are parsed as a function call when there is a symbol or accessor on
the left hand side, like sqrt(4) or obj.method(4). In other cases the
parentheses are interpreted as an implicit multiplication.

Math.js will always evaluate implicit multiplication before explicit multiplication *, so that the expression x * y z is parsed as x * (y * z). Math.js also gives implicit multiplication higher precedence than division, except when the division matches the pattern [unaryPrefixOp]?[number] / [number] [symbol] or [unaryPrefixOp]?[number] / [number] [left paren]. In that special case, the division is evaluated first:

math.evaluate('20 kg / 4 kg')   // 5      Evaluated as (20 kg) / (4 kg)
math.evaluate('20 / 4 kg')      // 5 kg   Evaluated as (20 / 4) kg


The behavior of implicit multiplication can be summarized by these operator precedence rules, listed from highest to lowest precedence:


  Function calls: [symbol] [left paren]
  Explicit division / when the division matches this pattern: [+-~]?[number] / [+-~]?[number] [symbol] or [number] / [number] [left paren]
  Implicit multiplication
  All other division / and multiplication *


Implicit multiplication is tricky as there can appear to be ambiguity in how an expression will be evaluated. Experience has shown that the above rules most closely match user intent when entering expressions that could be interpreted different ways. It’s also possible that these rules could be tweaked in future major releases.  Use implicit multiplication carefully. If you don’t like the uncertainty introduced by implicit multiplication, use explicit * operators and parentheses to ensure your expression is evaluated the way you intend.

Here are some more examples using implicit multiplication:


  
    
      Expression
      Evaluated as
      Result
    
  
  
    
      (1 + 3) pi
      (1 + 3) * pi
      12.566370614359172
    
    
      (4 - 1) 2
      (4 - 1) * 2
      6
    
    
      3 / 4 mm
      (3 / 4) * mm
      0.75 mm
    
    
      2 + 3 i
      2 + (3 * i)
      2 + 3i
    
    
      (1 + 2) (4 - 2)
      (1 + 2) * (4 - 2)
      6
    
    
      sqrt(4) (1 + 2)
      sqrt(4) * (1 + 2)
      6
    
    
      8 pi / 2 pi
      (8 * pi) / (2 * pi)
      4
    
    
      pi / 2 pi
      pi / (2 * pi)
      0.5
    
    
      1 / 2i
      (1 / 2) * i
      0.5 i
    
    
      8.314 J / mol K
      8.314 J / (mol * K)
      8.314 J / (mol * K)
    
  


Comments #

Comments can be added to explain or describe calculations in the text. A comment
starts with a sharp sign character #, and ends at the end of the line. A line
can contain a comment only, or can contain an expression followed by a comment.

const parser = math.parser()

parser.evaluate('# define some variables')
parser.evaluate('width = 3')                              // 3
parser.evaluate('height = 4')                             // 4
parser.evaluate('width * height   # calculate the area')  // 12\n\n\n\nExpression syntax #

This page describes the syntax of expression parser of math.js. It describes
how to work with the available data types, functions, operators, variables,
and more.

Differences from JavaScript #

The expression parser of math.js is aimed at a mathematical audience,
not a programming audience. The syntax is similar to most calculators and
mathematical applications. This is close to JavaScript as well, though there
are a few important differences between the syntax of the expression parser and
the lower level syntax of math.js. Differences are:


  No need to prefix functions and constants with the math.* namespace,
you can just enter sin(pi / 4).
  Matrix indexes are one-based instead of zero-based.
  There are index and range operators which allow more conveniently getting
and setting matrix indexes, like A[2:4, 1].
  Both indexes and ranges and have the upper-bound included.
  There is a differing syntax for defining functions. Example: f(x) = x^2.
  There are custom operators like x + y instead of add(x, y).
  Some operators are different. For example  ^ is used for exponentiation,
not bitwise xor.
  Implicit multiplication, like 2 pi, is supported and has special rules.
  Relational operators (<, >, <=, >=, ==, and !=) are chained, so the expression 5 < x < 10 is equivalent to 5 < x and x < 10.
  Multi-expression constructs like a = 1; b = 2; a + b or
"a = 1;\n cos(a)\n sin(a)" (where \n denotes newline)
produce a collection (“ResultSet”) of values. Those expressions
terminated by ; are evaluated for side effect only and their values
are suppressed from the result.


Operators #

The expression parser has operators for all common arithmetic operations such
as addition and multiplication. The expression parser uses conventional infix
notation for operators: an operator is placed between its arguments.
Round parentheses can be used to override the default precedence of operators.

// use operators
math.evaluate('2 + 3')       // 5
math.evaluate('2 * 3')       // 6

// use parentheses to override the default precedence
math.evaluate('2 + 3 * 4')   // 14
math.evaluate('(2 + 3) * 4') // 20


The following operators are available. Note that almost every operator listed
also has a function form with identical meaning that can be used
interchangeably. For example, x+y will always evaluate identically to
add(x,y). For a full list of the equivalences, see the section on
Functions below.


  
    
      Operator
      Name
      Syntax
      Associativity
      Example
      Result
    
  
  
    
      (, )
      Grouping
      (x)
      None
      2 * (3 + 4)
      14
    
    
      [, ]
      Matrix, Index
      [...]
      None
      [[1,2],[3,4]]
      [[1,2],[3,4]]
    
    
      {, }
      Object
      {...}
      None
      {a: 1, b: 2}
      {a: 1, b: 2}
    
    
      ,
      Parameter separator
      x, y
      Left to right
      max(2, 1, 5)
      5
    
    
      .
      Property accessor
      obj.prop
      Left to right
      obj={a: 12}; obj.a
      12
    
    
      ;
      Statement separator
      x; y
      Left to right
      a=2; b=3; a*b
      [6]
    
    
      ;
      Row separator
      [x; y]
      Left to right
      [1,2;3,4]
      [[1,2],[3,4]]
    
    
      \n
      Statement separator
      x \n y
      Left to right
      a=2 \n b=3 \n a*b
      [2,3,6]
    
    
      +
      Add
      x + y
      Left to right
      4 + 5
      9
    
    
      +
      Unary plus
      +y
      Right to left
      +4
      4
    
    
      -
      Subtract
      x - y
      Left to right
      7 - 3
      4
    
    
      -
      Unary minus
      -y
      Right to left
      -4
      -4
    
    
      *
      Multiply
      x * y
      Left to right
      2 * 3
      6
    
    
      .*
      Element-wise multiply
      x .* y
      Left to right
      [1,2,3] .* [1,2,3]
      [1,4,9]
    
    
      /
      Divide
      x / y
      Left to right
      6 / 2
      3
    
    
      ./
      Element-wise divide
      x ./ y
      Left to right
      [9,6,4] ./ [3,2,2]
      [3,3,2]
    
    
      %
      Percentage
      x%
      None
      8%
      0.08
    
    
      %
      Addition with Percentage
      x + y%
      Left to right
      100 + 3%
      103
    
    
      %
      Subtraction with Percentage
      x - y%
      Left to right
      100 - 3%
      97
    
    
      % mod
      Modulus
      x % y
      Left to right
      8 % 3
      2
    
    
      ^
      Power
      x ^ y
      Right to left
      2 ^ 3
      8
    
    
      .^
      Element-wise power
      x .^ y
      Right to left
      [2,3] .^ [3,3]
      [8,27]
    
    
      '
      Transpose
      y'
      Left to right
      [[1,2],[3,4]]'
      [[1,3],[2,4]]
    
    
      !
      Factorial
      y!
      Left to right
      5!
      120
    
    
      &
      Bitwise and
      x & y
      Left to right
      5 & 3
      1
    
    
      ~
      Bitwise not
      ~x
      Right to left
      ~2
      -3
    
    
      |
      Bitwise or
      x | y
      Left to right
      5 | 3
      7
    
    
      ^|
      Bitwise xor
      x ^| y
      Left to right
      5 ^| 2
      7
    
    
      <<
      Left shift
      x << y
      Left to right
      4 << 1
      8
    
    
      >>
      Right arithmetic shift
      x >> y
      Left to right
      8 >> 1
      4
    
    
      >>>
      Right logical shift
      x >>> y
      Left to right
      -8 >>> 1
      2147483644
    
    
      and
      Logical and
      x and y
      Left to right
      true and false
      false
    
    
      not
      Logical not
      not y
      Right to left
      not true
      false
    
    
      or
      Logical or
      x or y
      Left to right
      true or false
      true
    
    
      xor
      Logical xor
      x xor y
      Left to right
      true xor true
      false
    
    
      =
      Assignment
      x = y
      Right to left
      a = 5
      5
    
    
      ? :
      Conditional expression
      x ? y : z
      Right to left
      15 > 100 ? 1 : -1
      -1
    
    
      :
      Range
      x : y
      Right to left
      1:4
      [1,2,3,4]
    
    
      to, in
      Unit conversion
      x to y
      Left to right
      2 inch to cm
      5.08 cm
    
    
      ==
      Equal
      x == y
      Left to right
      2 == 4 - 2
      true
    
    
      !=
      Unequal
      x != y
      Left to right
      2 != 3
      true
    
    
      <
      Smaller
      x < y
      Left to right
      2 < 3
      true
    
    
      >
      Larger
      x > y
      Left to right
      2 > 3
      false
    
    
      <=
      Smallereq
      x <= y
      Left to right
      4 <= 3
      false
    
    
      >=
      Largereq
      x >= y
      Left to right
      2 + 4 >= 6
      true
    
  


Precedence #

The operators have the following precedence, from highest to lowest:


  
    
      Operators
      Description
    
  
  
    
      (...)[...]{...}
      GroupingMatrixObject
    
    
      x(...)x[...]obj.prop:
      Function callMatrix indexProperty accessorKey/value separator
    
    
      '
      Matrix transpose
    
    
      !
      Factorial
    
    
      ^, .^
      Exponentiation
    
    
      +, -, ~, not
      Unary plus, unary minus, bitwise not, logical not
    
    
      See section below
      Implicit multiplication
    
    
      *, /, .*, ./,%, mod
      Multiply, divide , percentage, modulus
    
    
      +, -
      Add, subtract
    
    
      :
      Range
    
    
      to, in
      Unit conversion
    
    
      <<, >>, >>>
      Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift
    
    
      ==, !=, <, >, <=, >=
      Relational
    
    
      &
      Bitwise and (lazily evaluated)
    
    
      ^|
      Bitwise xor
    
    
      |
      Bitwise or (lazily evaluated)
    
    
      and
      Logical and (lazily evaluated)
    
    
      xor
      Logical xor
    
    
      or
      Logical or (lazily evaluated)
    
    
      ?, :
      Conditional expression
    
    
      =
      Assignment
    
    
      ,
      Parameter and column separator
    
    
      ;
      Row separator
    
    
      \n, ;
      Statement separators
    
  


Lazy evaluation is used where logically possible for bitwise and logical
operators. In the following example, the value of x will not even be 
evaluated because it cannot effect the final result:
math.evaluate('false and x')        // false, no matter what x equals


Functions #

Functions are called by entering their name, followed by zero or more
arguments enclosed by parentheses. All available functions are listed on the
page Functions.

math.evaluate('sqrt(25)')           // 5
math.evaluate('log(10000, 3 + 7)')  // 4
math.evaluate('sin(pi / 4)')        // 0.7071067811865475


New functions can be defined by “assigning” an expression to a function call
with one or more variables. Such function assignments are limited: they can
only be defined on a single line.

const parser = math.parser()

parser.evaluate('f(x) = x ^ 2 - 5')
parser.evaluate('f(2)')     // -1
parser.evaluate('f(3)')     // 4

parser.evaluate('g(x, y) = x ^ y')
parser.evaluate('g(2, 3)')  // 8


Note that these function assignments do not create closures; put another way,
all free variables in mathjs are dynamic:

const parser = math.parser()

parser.evaluate('x = 7')
parser.evaluate('h(y) = x + y')
parser.evaluate('h(3)')         // 10
parser.evaluate('x = 3')
parser.evaluate('h(3)')         // 6, *not* 10


It is however possible to pass functions as parameters:

const parser = math.parser()

parser.evaluate('twice(func, x) = func(func(x))')
parser.evaluate('twice(square, 2)')    // 16
parser.evaluate('f(x) = 3*x')
parser.evaluate('twice(f, 2)')         // 18

// a simplistic "numerical derivative":
parser.evaluate('eps = 1e-10')
parser.evaluate('nd(f, x) = (f(x+eps) - func(x-eps))/(2*eps)')
parser.evaluate('nd(square,2)')        // 4.000000330961484


Math.js itself heavily uses typed functions, which ensure correct inputs and
throws meaningful errors when the input arguments are invalid. One can create
a typed-function in the
expression parser like:

const parser = math.parser()

parser.evaluate('f = typed({"number": f(x) = x ^ 2 - 5})')


Finally, as mentioned above, there is a function form for nearly every one of
the mathematical operator symbols. Moreover, for some associative operators,
the corresponding function allows arbitrarily many arguments. The table below
gives the full correspondence.


  
    
      Operator Expression
      Equivalent Function Expression
    
  
  
    
      a or b
      or(a,b)
    
    
      a xor b
      xor(a,b)
    
    
      a and b
      and(a,b)
    
    
      a \| b
      bitOr(a,b)
    
    
      a ^\| b
      bitXor(a,b)
    
    
      a & b
      bitAnd(a,b)
    
    
      a == b
      equal(a,b)
    
    
      a != b
      unequal(a,b)
    
    
      a < b
      smaller(a,b)
    
    
      a > b
      larger(a,b)
    
    
      a <= b
      smallerEq(a,b)
    
    
      a << 3
      leftShift(a,3)
    
    
      a >> 3
      rightArithShift(a,3)
    
    
      a >>> 3
      rightLogShift(a,3)
    
    
      u to cm
      to(u, cm)
    
    
      a + b + c + ...
      add(a,b,c,...)
    
    
      a - b
      subtract(a,b)
    
    
      a * b * c * ...
      multiply(a,b,c,...)
    
    
      A .* B
      dotMultiply(A,B)
    
    
      A ./ B
      dotDivide(A,B)
    
    
      a mod b
      mod(a,b)
    
    
      +a
      unaryPlus(a)
    
    
      -a
      unaryMinus(a)
    
    
      ~a
      bitNot(a)
    
    
      not a
      not(a)
    
    
      a^b
      pow(a,b)
    
    
      A .^ B
      dotPow(A,B)
    
    
      a!
      factorial(a)
    
    
      A'
      ctranspose(A)
    
  


Note that math.js embodies a preference for the operator forms, in that calling
simplify (see Algebra) converts any instances of the function
form into the corresponding operator.

Map and forEach #

The map and forEach functions can be used to apply a callback function to each element of an array or matrix.

The callback functions can be functions, typed functions, inline functions (only in the parser) or compiled inline functions (only in the parser).

The callback can have the following inputs:

  value: the current value in the array or matrix.
  index: the index of the current value expressed as an array of numbers.
  array: the array or matrix being iterated.


Below is the syntax for both functions:

map #

The map function applies a function to each element of an array and returns a new array with the results.

const parser = math.parser()

// Define a square function
parser.evaluate('square(x) = x ^ 2')

// Apply the square function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], square)')
// result: [1, 4, 9, 16]

// Apply an inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], f(x) = x ^ 2)')
// result: [1, 4, 9, 16]

// Apply a compiled inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], x ^ 2)')
// result: [1, 4, 9, 16]


forEach #
The forEach function applies a function to each element of an array or matrix but does not return a new array. It is useful for executing side effects.

// Define a function that prints each element
math.import({consoleLog: x => console.log(x)})
const parser = math.parser()

// Define a squareConsleLog function
parser.evaluate('squareConsoleLog(x) = consoleLog(x ^ 2)')

// Apply the squareConsleLog function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], squareConsleLog)')
// Prints: 1, 4, 9, 16

// Apply an inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], f(x) = consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16

// Apply a compiled inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16


These functions are useful for performing element-wise operations on arrays or matrices.

Constants and variables #

Math.js has a number of built-in constants such as pi and e.
All available constants are listed on he page
Constants.

// use constants
math.evaluate('pi')                 // 3.141592653589793
math.evaluate('e ^ 2')              // 7.3890560989306495
math.evaluate('log(e)')             // 1
math.evaluate('e ^ (pi * i) + 1')   // ~0 (Euler)


Variables can be defined using the assignment operator =, and can be used
like constants.

const parser = math.parser()

// define variables
parser.evaluate('a = 3.4')      // 3.4
parser.evaluate('b = 5 / 2')    // 2.5

// use variables
parser.evaluate('a * b')        // 8.5


Variable names must:


  Begin with an “alpha character”, which is:
    
      A latin letter (upper or lower case). Ascii: a-z, A-Z
      An underscore.                        Ascii: _
      A dollar sign.                        Ascii: $
      A latin letter with accents.          Unicode: \u00C0 - \u02AF
      A greek letter.                       Unicode: \u0370 - \u03FF
      A letter-like character.              Unicode: \u2100 - \u214F
      A mathematical alphanumeric symbol.   Unicode: \u{1D400} - \u{1D7FF} excluding invalid code points
    
  
  Contain only alpha characters (above) and digits 0-9
  Not be any of the following: mod, to, in, and, xor, or, not, end. It is possible to assign to some of these, but that’s not recommended.


It is possible to customize the allowed alpha characters, see Customize supported characters for more information.

Data types #

The expression parser supports booleans, numbers, complex numbers, units,
strings, matrices, and objects.

Booleans #

Booleans true and false can be used in expressions.

// use booleans
math.evaluate('true')               // true
math.evaluate('false')              // false
math.evaluate('(2 == 3) == false')  // true


Booleans can be converted to numbers and strings and vice versa using the
functions number and boolean, and string.

// convert booleans
math.evaluate('number(true)')       // 1
math.evaluate('string(false)')      // "false"
math.evaluate('boolean(1)')         // true
math.evaluate('boolean("false")')   // false


Numbers #

The most important and basic data type in math.js are numbers. Numbers use a
point as decimal mark. Numbers can be entered with exponential notation.
Examples:

// numbers in math.js
math.evaluate('2')        // 2
math.evaluate('3.14')     // 3.14
math.evaluate('1.4e3')    // 1400
math.evaluate('22e-3')    // 0.022


A number can be converted to a string and vice versa using the functions
number and string.

// convert a string into a number
math.evaluate('number("2.3")')    // 2.3
math.evaluate('string(2.3)')      // "2.3"


Math.js uses regular JavaScript numbers, which are floating points with a
limited precision and limited range. The limitations are described in detail
on the page Numbers.

math.evaluate('1e-325')   // 0
math.evaluate('1e309')    // Infinity
math.evaluate('-1e309')   // -Infinity


When doing calculations with floats, one can very easily get round-off errors:

// round-off error due to limited floating point precision
math.evaluate('0.1 + 0.2')  // 0.30000000000000004


When outputting results, the function math.format can be used to hide
these round-off errors when outputting results for the user:

const ans = math.evaluate('0.1 + 0.2')  //  0.30000000000000004
math.format(ans, {precision: 14})       // "0.3"


Numbers can be expressed as binary, octal, and hexadecimal literals:

math.evaluate('0b11')  //  3
math.evaluate('0o77')  //  63
math.evaluate('0xff')  //  255


A word size suffix can be used to change the behavior of non decimal literal evaluation:

math.evaluate('0xffi8')         // -1
math.evaluate('0xffffffffi32')  //  -1
math.evaluate('0xfffffffffi32') //  SyntaxError: String "0xfffffffff" is out of range


Non decimal numbers can include a radix point:
math.evaluate('0b1.1')         // 1.5
math.evaluate('0o1.4')         // 1.5
math.evaluate('0x1.8')         // 1.5


Numbers can be formatted as binary, octal, and hex strings using the notation option of the format function:

math.evaluate('format(3, {notation: "bin"})')    //  '0b11'
math.evaluate('format(63, {notation: "oct"})')   //  '0o77'
math.evaluate('format(255, {notation: "hex"})')  //  '0xff'
math.evaluate('format(-1, {notation: "hex"})')   //  '-0x1'
math.evaluate('format(2.3, {notation: "hex"})')  //  '0x2.4cccccccccccc'


The format function accepts a wordSize option to use in conjunction with the non binary notations:

math.evaluate('format(-1, {notation: "hex", wordSize: 8})')   //  '0xffi8'


The functions bin, oct, and hex are shorthand for the format function with notation set accordingly:

math.evaluate('bin(-1)')     // '-0b1'
math.evaluate('bin(-1, 8)')  // '0b11111111i8'


BigNumbers #

Math.js supports BigNumbers for calculations with an arbitrary precision.
The pros and cons of Number and BigNumber are explained in detail on the page
Numbers.

BigNumbers are slower but have a higher precision. Calculations with big
numbers are supported only by arithmetic functions.

BigNumbers can be created using the bignumber function:

math.evaluate('bignumber(0.1) + bignumber(0.2)') // BigNumber, 0.3


The default number type of the expression parser can be changed at instantiation
of math.js. The expression parser parses numbers as BigNumber by default:

// Configure the type of number: 'number' (default), 'BigNumber', or 'Fraction'
math.config({number: 'BigNumber'})

// all numbers are parsed as BigNumber
math.evaluate('0.1 + 0.2')  // BigNumber, 0.3


BigNumbers can be converted to numbers and vice versa using the functions
number and bignumber. When converting a BigNumber to a Number, the high
precision of the BigNumber will be lost. When a BigNumber is too large to be represented
as Number, it will be initialized as Infinity.

Complex numbers #

Complex numbers can be created using the imaginary unit i, which is defined
as i^2 = -1. Complex numbers have a real and complex part, which can be
retrieved using the functions re and im.

const parser = math.parser()

// create complex numbers
parser.evaluate('a = 2 + 3i')   // Complex, 2 + 3i
parser.evaluate('b = 4 - i')    // Complex, 4 - i

// get real and imaginary part of a complex number
parser.evaluate('re(a)')        // Number,  2
parser.evaluate('im(a)')        // Number,  3

// calculations with complex numbers
parser.evaluate('a + b')        // Complex, 6 + 2i
parser.evaluate('a * b')        // Complex, 11 + 10i
parser.evaluate('i * i')        // Number,  -1
parser.evaluate('sqrt(-4)')     // Complex, 2i


Units #

math.js supports units. Units can be used in the arithmetic operations
add, subtract, multiply, divide, and exponentiation.
Units can also be converted from one to another.
An overview of all available units can be found on the page
Units.

Units can be converted using the operator to or in.

// create a unit
math.evaluate('5.4 kg')                     // Unit, 5.4 kg

// convert a unit
math.evaluate('2 inch to cm')               // Unit, 5.08 cm
math.evaluate('20 celsius in fahrenheit')   // Unit, ~68 fahrenheit
math.evaluate('90 km/h to m/s')             // Unit, 25 m / s

// convert a unit to a number
// A second parameter with the unit for the exported number must be provided
math.evaluate('number(5 cm, mm)')           // Number, 50

// calculations with units
math.evaluate('0.5kg + 33g')                // Unit, 0.533 kg
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('12 seconds * 2')             // Unit, 24 seconds
math.evaluate('sin(45 deg)')                // Number, 0.7071067811865475
math.evaluate('9.81 m/s^2 * 5 s to mi/h')   // Unit, 109.72172512527 mi / h


Strings #

Strings are enclosed by double quotes “ or single quotes ‘. Strings can be concatenated using the
function concat (not by adding them using + like in JavaScript). Parts of
a string can be retrieved or replaced by using indexes. Strings can be converted
to a number using function number, and numbers can be converted to a string
using function string.

When setting the value of a character in a string, the character that has been
set is returned. Likewise, when a range of characters is set, that range of
characters is returned.

const parser = math.parser()

// create a string
parser.evaluate('"hello"')                        // String, "hello"

// string manipulation
parser.evaluate('a = concat("hello", " world")')  // String, "hello world"
parser.evaluate('size(a)')                        // Matrix [11]
parser.evaluate('a[1:5]')                         // String, "hello"
parser.evaluate('a[1] = "H"')                     // String, "H"
parser.evaluate('a[7:12] = "there!"')             // String, "there!"
parser.evaluate('a')                              // String, "Hello there!"

// string conversion
parser.evaluate('number("300")')                  // Number, 300
parser.evaluate('string(300)')                    // String, "300"


Strings can be used in the evaluate function, to parse expressions inside
the expression parser:

math.evaluate('evaluate("2 + 3")')  // 5


Matrices #

Matrices can be created by entering a series of values between square brackets,
elements are separated by a comma ,.
A matrix like [1, 2, 3] will create a vector, a 1-dimensional matrix with
size [3]. To create a multi-dimensional matrix, matrices can be nested into
each other. For easier creation of two-dimensional matrices, a semicolon ;
can be used to separate rows in a matrix.

// create a matrix
math.evaluate('[1, 2, 3]')                                // Matrix, size [3]
math.evaluate('[[1, 2, 3], [4, 5, 6]]')                   // Matrix, size [2, 3]
math.evaluate('[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]')     // Matrix, size [2, 2, 2]

// create a two dimensional matrix
math.evaluate('[1, 2, 3; 4, 5, 6]')                       // Matrix, size [2, 3]


Another way to create filled matrices is using the functions zeros, ones,
identity, and range.

// initialize a matrix with ones or zeros
math.evaluate('zeros(3, 2)')      // Matrix, [[0, 0], [0, 0], [0, 0]],  size [3, 2]
math.evaluate('ones(3)')          // Matrix, [1, 1, 1],                 size [3]
math.evaluate('5 * ones(2, 2)')   // Matrix, [[5, 5], [5, 5]],          size [2, 2]

// create an identity matrix
math.evaluate('identity(2)')      // Matrix, [[1, 0], [0, 1]],          size [2, 2]

// create a range
math.evaluate('1:4')              // Matrix, [1, 2, 3, 4],              size [4]
math.evaluate('0:2:10')           // Matrix, [0, 2, 4, 6, 8, 10],       size [6]


A subset can be retrieved from a matrix using indexes and a subset of a matrix
can be replaced by using indexes. Indexes are enclosed in square brackets, and
contain a number or a range for each of the matrix dimensions. A range can have
its start and/or end undefined. When the start is undefined, the range will start
at 1, when the end is undefined, the range will end at the end of the matrix.

There is a context variable end available as well to denote the end of the
matrix. This variable cannot be used in multiple nested indices. In that case,
end will be resolved as the end of the innermost matrix. To solve this, 
resolving of the nested index needs to be split in two separate operations.

IMPORTANT: matrix indexes and ranges work differently from the math.js indexes
in JavaScript: They are one-based with an included upper-bound, similar to most
math applications.

parser = math.parser()

// create matrices
parser.evaluate('a = [1, 2; 3, 4]')       // Matrix, [[1, 2], [3, 4]]
parser.evaluate('b = zeros(2, 2)')        // Matrix, [[0, 0], [0, 0]]
parser.evaluate('c = 5:9')                // Matrix, [5, 6, 7, 8, 9]

// replace a subset in a matrix
parser.evaluate('b[1, 1:2] = [5, 6]')     // Matrix, [[5, 6], [0, 0]]
parser.evaluate('b[2, :] = [7, 8]')       // Matrix, [[5, 6], [7, 8]]

// perform a matrix calculation
parser.evaluate('d = a * b')              // Matrix, [[19, 22], [43, 50]]

// retrieve a subset of a matrix
parser.evaluate('d[2, 1]')                // 43
parser.evaluate('d[2, 1:end]')            // Matrix, [[43, 50]]
parser.evaluate('c[end - 1 : -1 : 2]')    // Matrix, [8, 7, 6]


Objects #

Objects in math.js work the same as in languages like JavaScript and Python.
An object is enclosed by curly brackets {, }, and contains a set of
comma separated key/value pairs. Keys and values are separated by a colon :.
Keys can be a symbol like prop or a string like "prop".

math.evaluate('{a: 2 + 1, b: 4}')         // {a: 3, b: 4}
math.evaluate('{"a": 2 + 1, "b": 4}')     // {a: 3, b: 4}


Objects can contain objects:

math.evaluate('{a: 2, b: {c: 3, d: 4}}')  // {a: 2, b: {c: 3, d: 4}}


Object properties can be retrieved or replaced using dot notation or bracket
notation. Unlike JavaScript, when setting a property value, the whole object
is returned, not the property value

let scope = {
  obj: {
    prop: 42
  }
}

// retrieve properties
math.evaluate('obj.prop', scope)          // 42
math.evaluate('obj["prop"]', scope)       // 42

// set properties (returns the whole object, not the property value!)
math.evaluate('obj.prop = 43', scope)     // {prop: 43}
math.evaluate('obj["prop"] = 43', scope)  // {prop: 43}
scope.obj                                 // {prop: 43}


Multi-line expressions #

An expression can contain multiple lines, and expressions can be spread over
multiple lines. Lines can be separated by a newline character \n or by a
semicolon ;. Output of statements followed by a semicolon will be hidden from
the output, and empty lines are ignored. The output is returned as a ResultSet,
with an entry for every visible statement.

// a multi-line expression
math.evaluate('1 * 3 \n 2 * 3 \n 3 * 3')    // ResultSet, [3, 6, 9]

// semicolon statements are hidden from the output
math.evaluate('a=3; b=4; a + b \n a * b')   // ResultSet, [7, 12]

// single expression spread over multiple lines
math.evaluate('a = 2 +\n  3')               // 5
math.evaluate('[\n  1, 2;\n  3, 4\n]')      // Matrix, [[1, 2], [3, 4]]


The results can be read from a ResultSet via the property ResultSet.entries
which is an Array, or by calling ResultSet.valueOf(), which returns the
array with results.

Implicit multiplication #

Implicit multiplication means the multiplication of two symbols, numbers, or a grouped expression inside parentheses without using the * operator. This type of syntax allows a more natural way to enter expressions. For example:

math.evaluate('2 pi')         // 6.283185307179586
math.evaluate('(1+2)(3+4)')   // 21


Parentheses are parsed as a function call when there is a symbol or accessor on
the left hand side, like sqrt(4) or obj.method(4). In other cases the
parentheses are interpreted as an implicit multiplication.

Math.js will always evaluate implicit multiplication before explicit multiplication *, so that the expression x * y z is parsed as x * (y * z). Math.js also gives implicit multiplication higher precedence than division, except when the division matches the pattern [unaryPrefixOp]?[number] / [number] [symbol] or [unaryPrefixOp]?[number] / [number] [left paren]. In that special case, the division is evaluated first:

math.evaluate('20 kg / 4 kg')   // 5      Evaluated as (20 kg) / (4 kg)
math.evaluate('20 / 4 kg')      // 5 kg   Evaluated as (20 / 4) kg


The behavior of implicit multiplication can be summarized by these operator precedence rules, listed from highest to lowest precedence:


  Function calls: [symbol] [left paren]
  Explicit division / when the division matches this pattern: [+-~]?[number] / [+-~]?[number] [symbol] or [number] / [number] [left paren]
  Implicit multiplication
  All other division / and multiplication *


Implicit multiplication is tricky as there can appear to be ambiguity in how an expression will be evaluated. Experience has shown that the above rules most closely match user intent when entering expressions that could be interpreted different ways. It’s also possible that these rules could be tweaked in future major releases.  Use implicit multiplication carefully. If you don’t like the uncertainty introduced by implicit multiplication, use explicit * operators and parentheses to ensure your expression is evaluated the way you intend.

Here are some more examples using implicit multiplication:


  
    
      Expression
      Evaluated as
      Result
    
  
  
    
      (1 + 3) pi
      (1 + 3) * pi
      12.566370614359172
    
    
      (4 - 1) 2
      (4 - 1) * 2
      6
    
    
      3 / 4 mm
      (3 / 4) * mm
      0.75 mm
    
    
      2 + 3 i
      2 + (3 * i)
      2 + 3i
    
    
      (1 + 2) (4 - 2)
      (1 + 2) * (4 - 2)
      6
    
    
      sqrt(4) (1 + 2)
      sqrt(4) * (1 + 2)
      6
    
    
      8 pi / 2 pi
      (8 * pi) / (2 * pi)
      4
    
    
      pi / 2 pi
      pi / (2 * pi)
      0.5
    
    
      1 / 2i
      (1 / 2) * i
      0.5 i
    
    
      8.314 J / mol K
      8.314 J / (mol * K)
      8.314 J / (mol * K)
    
  


Comments #

Comments can be added to explain or describe calculations in the text. A comment
starts with a sharp sign character #, and ends at the end of the line. A line
can contain a comment only, or can contain an expression followed by a comment.

const parser = math.parser()

parser.evaluate('# define some variables')
parser.evaluate('width = 3')                              // 3
parser.evaluate('height = 4')                             // 4
parser.evaluate('width * height   # calculate the area')  // 12\n\n\n\nExpression syntax #

This page describes the syntax of expression parser of math.js. It describes
how to work with the available data types, functions, operators, variables,
and more.

Differences from JavaScript #

The expression parser of math.js is aimed at a mathematical audience,
not a programming audience. The syntax is similar to most calculators and
mathematical applications. This is close to JavaScript as well, though there
are a few important differences between the syntax of the expression parser and
the lower level syntax of math.js. Differences are:


  No need to prefix functions and constants with the math.* namespace,
you can just enter sin(pi / 4).
  Matrix indexes are one-based instead of zero-based.
  There are index and range operators which allow more conveniently getting
and setting matrix indexes, like A[2:4, 1].
  Both indexes and ranges and have the upper-bound included.
  There is a differing syntax for defining functions. Example: f(x) = x^2.
  There are custom operators like x + y instead of add(x, y).
  Some operators are different. For example  ^ is used for exponentiation,
not bitwise xor.
  Implicit multiplication, like 2 pi, is supported and has special rules.
  Relational operators (<, >, <=, >=, ==, and !=) are chained, so the expression 5 < x < 10 is equivalent to 5 < x and x < 10.
  Multi-expression constructs like a = 1; b = 2; a + b or
"a = 1;\n cos(a)\n sin(a)" (where \n denotes newline)
produce a collection (“ResultSet”) of values. Those expressions
terminated by ; are evaluated for side effect only and their values
are suppressed from the result.


Operators #

The expression parser has operators for all common arithmetic operations such
as addition and multiplication. The expression parser uses conventional infix
notation for operators: an operator is placed between its arguments.
Round parentheses can be used to override the default precedence of operators.

// use operators
math.evaluate('2 + 3')       // 5
math.evaluate('2 * 3')       // 6

// use parentheses to override the default precedence
math.evaluate('2 + 3 * 4')   // 14
math.evaluate('(2 + 3) * 4') // 20


The following operators are available. Note that almost every operator listed
also has a function form with identical meaning that can be used
interchangeably. For example, x+y will always evaluate identically to
add(x,y). For a full list of the equivalences, see the section on
Functions below.


  
    
      Operator
      Name
      Syntax
      Associativity
      Example
      Result
    
  
  
    
      (, )
      Grouping
      (x)
      None
      2 * (3 + 4)
      14
    
    
      [, ]
      Matrix, Index
      [...]
      None
      [[1,2],[3,4]]
      [[1,2],[3,4]]
    
    
      {, }
      Object
      {...}
      None
      {a: 1, b: 2}
      {a: 1, b: 2}
    
    
      ,
      Parameter separator
      x, y
      Left to right
      max(2, 1, 5)
      5
    
    
      .
      Property accessor
      obj.prop
      Left to right
      obj={a: 12}; obj.a
      12
    
    
      ;
      Statement separator
      x; y
      Left to right
      a=2; b=3; a*b
      [6]
    
    
      ;
      Row separator
      [x; y]
      Left to right
      [1,2;3,4]
      [[1,2],[3,4]]
    
    
      \n
      Statement separator
      x \n y
      Left to right
      a=2 \n b=3 \n a*b
      [2,3,6]
    
    
      +
      Add
      x + y
      Left to right
      4 + 5
      9
    
    
      +
      Unary plus
      +y
      Right to left
      +4
      4
    
    
      -
      Subtract
      x - y
      Left to right
      7 - 3
      4
    
    
      -
      Unary minus
      -y
      Right to left
      -4
      -4
    
    
      *
      Multiply
      x * y
      Left to right
      2 * 3
      6
    
    
      .*
      Element-wise multiply
      x .* y
      Left to right
      [1,2,3] .* [1,2,3]
      [1,4,9]
    
    
      /
      Divide
      x / y
      Left to right
      6 / 2
      3
    
    
      ./
      Element-wise divide
      x ./ y
      Left to right
      [9,6,4] ./ [3,2,2]
      [3,3,2]
    
    
      %
      Percentage
      x%
      None
      8%
      0.08
    
    
      %
      Addition with Percentage
      x + y%
      Left to right
      100 + 3%
      103
    
    
      %
      Subtraction with Percentage
      x - y%
      Left to right
      100 - 3%
      97
    
    
      % mod
      Modulus
      x % y
      Left to right
      8 % 3
      2
    
    
      ^
      Power
      x ^ y
      Right to left
      2 ^ 3
      8
    
    
      .^
      Element-wise power
      x .^ y
      Right to left
      [2,3] .^ [3,3]
      [8,27]
    
    
      '
      Transpose
      y'
      Left to right
      [[1,2],[3,4]]'
      [[1,3],[2,4]]
    
    
      !
      Factorial
      y!
      Left to right
      5!
      120
    
    
      &
      Bitwise and
      x & y
      Left to right
      5 & 3
      1
    
    
      ~
      Bitwise not
      ~x
      Right to left
      ~2
      -3
    
    
      |
      Bitwise or
      x | y
      Left to right
      5 | 3
      7
    
    
      ^|
      Bitwise xor
      x ^| y
      Left to right
      5 ^| 2
      7
    
    
      <<
      Left shift
      x << y
      Left to right
      4 << 1
      8
    
    
      >>
      Right arithmetic shift
      x >> y
      Left to right
      8 >> 1
      4
    
    
      >>>
      Right logical shift
      x >>> y
      Left to right
      -8 >>> 1
      2147483644
    
    
      and
      Logical and
      x and y
      Left to right
      true and false
      false
    
    
      not
      Logical not
      not y
      Right to left
      not true
      false
    
    
      or
      Logical or
      x or y
      Left to right
      true or false
      true
    
    
      xor
      Logical xor
      x xor y
      Left to right
      true xor true
      false
    
    
      =
      Assignment
      x = y
      Right to left
      a = 5
      5
    
    
      ? :
      Conditional expression
      x ? y : z
      Right to left
      15 > 100 ? 1 : -1
      -1
    
    
      :
      Range
      x : y
      Right to left
      1:4
      [1,2,3,4]
    
    
      to, in
      Unit conversion
      x to y
      Left to right
      2 inch to cm
      5.08 cm
    
    
      ==
      Equal
      x == y
      Left to right
      2 == 4 - 2
      true
    
    
      !=
      Unequal
      x != y
      Left to right
      2 != 3
      true
    
    
      <
      Smaller
      x < y
      Left to right
      2 < 3
      true
    
    
      >
      Larger
      x > y
      Left to right
      2 > 3
      false
    
    
      <=
      Smallereq
      x <= y
      Left to right
      4 <= 3
      false
    
    
      >=
      Largereq
      x >= y
      Left to right
      2 + 4 >= 6
      true
    
  


Precedence #

The operators have the following precedence, from highest to lowest:


  
    
      Operators
      Description
    
  
  
    
      (...)[...]{...}
      GroupingMatrixObject
    
    
      x(...)x[...]obj.prop:
      Function callMatrix indexProperty accessorKey/value separator
    
    
      '
      Matrix transpose
    
    
      !
      Factorial
    
    
      ^, .^
      Exponentiation
    
    
      +, -, ~, not
      Unary plus, unary minus, bitwise not, logical not
    
    
      See section below
      Implicit multiplication
    
    
      *, /, .*, ./,%, mod
      Multiply, divide , percentage, modulus
    
    
      +, -
      Add, subtract
    
    
      :
      Range
    
    
      to, in
      Unit conversion
    
    
      <<, >>, >>>
      Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift
    
    
      ==, !=, <, >, <=, >=
      Relational
    
    
      &
      Bitwise and (lazily evaluated)
    
    
      ^|
      Bitwise xor
    
    
      |
      Bitwise or (lazily evaluated)
    
    
      and
      Logical and (lazily evaluated)
    
    
      xor
      Logical xor
    
    
      or
      Logical or (lazily evaluated)
    
    
      ?, :
      Conditional expression
    
    
      =
      Assignment
    
    
      ,
      Parameter and column separator
    
    
      ;
      Row separator
    
    
      \n, ;
      Statement separators
    
  


Lazy evaluation is used where logically possible for bitwise and logical
operators. In the following example, the value of x will not even be 
evaluated because it cannot effect the final result:
math.evaluate('false and x')        // false, no matter what x equals


Functions #

Functions are called by entering their name, followed by zero or more
arguments enclosed by parentheses. All available functions are listed on the
page Functions.

math.evaluate('sqrt(25)')           // 5
math.evaluate('log(10000, 3 + 7)')  // 4
math.evaluate('sin(pi / 4)')        // 0.7071067811865475


New functions can be defined by “assigning” an expression to a function call
with one or more variables. Such function assignments are limited: they can
only be defined on a single line.

const parser = math.parser()

parser.evaluate('f(x) = x ^ 2 - 5')
parser.evaluate('f(2)')     // -1
parser.evaluate('f(3)')     // 4

parser.evaluate('g(x, y) = x ^ y')
parser.evaluate('g(2, 3)')  // 8


Note that these function assignments do not create closures; put another way,
all free variables in mathjs are dynamic:

const parser = math.parser()

parser.evaluate('x = 7')
parser.evaluate('h(y) = x + y')
parser.evaluate('h(3)')         // 10
parser.evaluate('x = 3')
parser.evaluate('h(3)')         // 6, *not* 10


It is however possible to pass functions as parameters:

const parser = math.parser()

parser.evaluate('twice(func, x) = func(func(x))')
parser.evaluate('twice(square, 2)')    // 16
parser.evaluate('f(x) = 3*x')
parser.evaluate('twice(f, 2)')         // 18

// a simplistic "numerical derivative":
parser.evaluate('eps = 1e-10')
parser.evaluate('nd(f, x) = (f(x+eps) - func(x-eps))/(2*eps)')
parser.evaluate('nd(square,2)')        // 4.000000330961484


Math.js itself heavily uses typed functions, which ensure correct inputs and
throws meaningful errors when the input arguments are invalid. One can create
a typed-function in the
expression parser like:

const parser = math.parser()

parser.evaluate('f = typed({"number": f(x) = x ^ 2 - 5})')


Finally, as mentioned above, there is a function form for nearly every one of
the mathematical operator symbols. Moreover, for some associative operators,
the corresponding function allows arbitrarily many arguments. The table below
gives the full correspondence.


  
    
      Operator Expression
      Equivalent Function Expression
    
  
  
    
      a or b
      or(a,b)
    
    
      a xor b
      xor(a,b)
    
    
      a and b
      and(a,b)
    
    
      a \| b
      bitOr(a,b)
    
    
      a ^\| b
      bitXor(a,b)
    
    
      a & b
      bitAnd(a,b)
    
    
      a == b
      equal(a,b)
    
    
      a != b
      unequal(a,b)
    
    
      a < b
      smaller(a,b)
    
    
      a > b
      larger(a,b)
    
    
      a <= b
      smallerEq(a,b)
    
    
      a << 3
      leftShift(a,3)
    
    
      a >> 3
      rightArithShift(a,3)
    
    
      a >>> 3
      rightLogShift(a,3)
    
    
      u to cm
      to(u, cm)
    
    
      a + b + c + ...
      add(a,b,c,...)
    
    
      a - b
      subtract(a,b)
    
    
      a * b * c * ...
      multiply(a,b,c,...)
    
    
      A .* B
      dotMultiply(A,B)
    
    
      A ./ B
      dotDivide(A,B)
    
    
      a mod b
      mod(a,b)
    
    
      +a
      unaryPlus(a)
    
    
      -a
      unaryMinus(a)
    
    
      ~a
      bitNot(a)
    
    
      not a
      not(a)
    
    
      a^b
      pow(a,b)
    
    
      A .^ B
      dotPow(A,B)
    
    
      a!
      factorial(a)
    
    
      A'
      ctranspose(A)
    
  


Note that math.js embodies a preference for the operator forms, in that calling
simplify (see Algebra) converts any instances of the function
form into the corresponding operator.

Map and forEach #

The map and forEach functions can be used to apply a callback function to each element of an array or matrix.

The callback functions can be functions, typed functions, inline functions (only in the parser) or compiled inline functions (only in the parser).

The callback can have the following inputs:

  value: the current value in the array or matrix.
  index: the index of the current value expressed as an array of numbers.
  array: the array or matrix being iterated.


Below is the syntax for both functions:

map #

The map function applies a function to each element of an array and returns a new array with the results.

const parser = math.parser()

// Define a square function
parser.evaluate('square(x) = x ^ 2')

// Apply the square function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], square)')
// result: [1, 4, 9, 16]

// Apply an inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], f(x) = x ^ 2)')
// result: [1, 4, 9, 16]

// Apply a compiled inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], x ^ 2)')
// result: [1, 4, 9, 16]


forEach #
The forEach function applies a function to each element of an array or matrix but does not return a new array. It is useful for executing side effects.

// Define a function that prints each element
math.import({consoleLog: x => console.log(x)})
const parser = math.parser()

// Define a squareConsleLog function
parser.evaluate('squareConsoleLog(x) = consoleLog(x ^ 2)')

// Apply the squareConsleLog function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], squareConsleLog)')
// Prints: 1, 4, 9, 16

// Apply an inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], f(x) = consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16

// Apply a compiled inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16


These functions are useful for performing element-wise operations on arrays or matrices.

Constants and variables #

Math.js has a number of built-in constants such as pi and e.
All available constants are listed on he page
Constants.

// use constants
math.evaluate('pi')                 // 3.141592653589793
math.evaluate('e ^ 2')              // 7.3890560989306495
math.evaluate('log(e)')             // 1
math.evaluate('e ^ (pi * i) + 1')   // ~0 (Euler)


Variables can be defined using the assignment operator =, and can be used
like constants.

const parser = math.parser()

// define variables
parser.evaluate('a = 3.4')      // 3.4
parser.evaluate('b = 5 / 2')    // 2.5

// use variables
parser.evaluate('a * b')        // 8.5


Variable names must:


  Begin with an “alpha character”, which is:
    
      A latin letter (upper or lower case). Ascii: a-z, A-Z
      An underscore.                        Ascii: _
      A dollar sign.                        Ascii: $
      A latin letter with accents.          Unicode: \u00C0 - \u02AF
      A greek letter.                       Unicode: \u0370 - \u03FF
      A letter-like character.              Unicode: \u2100 - \u214F
      A mathematical alphanumeric symbol.   Unicode: \u{1D400} - \u{1D7FF} excluding invalid code points
    
  
  Contain only alpha characters (above) and digits 0-9
  Not be any of the following: mod, to, in, and, xor, or, not, end. It is possible to assign to some of these, but that’s not recommended.


It is possible to customize the allowed alpha characters, see Customize supported characters for more information.

Data types #

The expression parser supports booleans, numbers, complex numbers, units,
strings, matrices, and objects.

Booleans #

Booleans true and false can be used in expressions.

// use booleans
math.evaluate('true')               // true
math.evaluate('false')              // false
math.evaluate('(2 == 3) == false')  // true


Booleans can be converted to numbers and strings and vice versa using the
functions number and boolean, and string.

// convert booleans
math.evaluate('number(true)')       // 1
math.evaluate('string(false)')      // "false"
math.evaluate('boolean(1)')         // true
math.evaluate('boolean("false")')   // false


Numbers #

The most important and basic data type in math.js are numbers. Numbers use a
point as decimal mark. Numbers can be entered with exponential notation.
Examples:

// numbers in math.js
math.evaluate('2')        // 2
math.evaluate('3.14')     // 3.14
math.evaluate('1.4e3')    // 1400
math.evaluate('22e-3')    // 0.022


A number can be converted to a string and vice versa using the functions
number and string.

// convert a string into a number
math.evaluate('number("2.3")')    // 2.3
math.evaluate('string(2.3)')      // "2.3"


Math.js uses regular JavaScript numbers, which are floating points with a
limited precision and limited range. The limitations are described in detail
on the page Numbers.

math.evaluate('1e-325')   // 0
math.evaluate('1e309')    // Infinity
math.evaluate('-1e309')   // -Infinity


When doing calculations with floats, one can very easily get round-off errors:

// round-off error due to limited floating point precision
math.evaluate('0.1 + 0.2')  // 0.30000000000000004


When outputting results, the function math.format can be used to hide
these round-off errors when outputting results for the user:

const ans = math.evaluate('0.1 + 0.2')  //  0.30000000000000004
math.format(ans, {precision: 14})       // "0.3"


Numbers can be expressed as binary, octal, and hexadecimal literals:

math.evaluate('0b11')  //  3
math.evaluate('0o77')  //  63
math.evaluate('0xff')  //  255


A word size suffix can be used to change the behavior of non decimal literal evaluation:

math.evaluate('0xffi8')         // -1
math.evaluate('0xffffffffi32')  //  -1
math.evaluate('0xfffffffffi32') //  SyntaxError: String "0xfffffffff" is out of range


Non decimal numbers can include a radix point:
math.evaluate('0b1.1')         // 1.5
math.evaluate('0o1.4')         // 1.5
math.evaluate('0x1.8')         // 1.5


Numbers can be formatted as binary, octal, and hex strings using the notation option of the format function:

math.evaluate('format(3, {notation: "bin"})')    //  '0b11'
math.evaluate('format(63, {notation: "oct"})')   //  '0o77'
math.evaluate('format(255, {notation: "hex"})')  //  '0xff'
math.evaluate('format(-1, {notation: "hex"})')   //  '-0x1'
math.evaluate('format(2.3, {notation: "hex"})')  //  '0x2.4cccccccccccc'


The format function accepts a wordSize option to use in conjunction with the non binary notations:

math.evaluate('format(-1, {notation: "hex", wordSize: 8})')   //  '0xffi8'


The functions bin, oct, and hex are shorthand for the format function with notation set accordingly:

math.evaluate('bin(-1)')     // '-0b1'
math.evaluate('bin(-1, 8)')  // '0b11111111i8'


BigNumbers #

Math.js supports BigNumbers for calculations with an arbitrary precision.
The pros and cons of Number and BigNumber are explained in detail on the page
Numbers.

BigNumbers are slower but have a higher precision. Calculations with big
numbers are supported only by arithmetic functions.

BigNumbers can be created using the bignumber function:

math.evaluate('bignumber(0.1) + bignumber(0.2)') // BigNumber, 0.3


The default number type of the expression parser can be changed at instantiation
of math.js. The expression parser parses numbers as BigNumber by default:

// Configure the type of number: 'number' (default), 'BigNumber', or 'Fraction'
math.config({number: 'BigNumber'})

// all numbers are parsed as BigNumber
math.evaluate('0.1 + 0.2')  // BigNumber, 0.3


BigNumbers can be converted to numbers and vice versa using the functions
number and bignumber. When converting a BigNumber to a Number, the high
precision of the BigNumber will be lost. When a BigNumber is too large to be represented
as Number, it will be initialized as Infinity.

Complex numbers #

Complex numbers can be created using the imaginary unit i, which is defined
as i^2 = -1. Complex numbers have a real and complex part, which can be
retrieved using the functions re and im.

const parser = math.parser()

// create complex numbers
parser.evaluate('a = 2 + 3i')   // Complex, 2 + 3i
parser.evaluate('b = 4 - i')    // Complex, 4 - i

// get real and imaginary part of a complex number
parser.evaluate('re(a)')        // Number,  2
parser.evaluate('im(a)')        // Number,  3

// calculations with complex numbers
parser.evaluate('a + b')        // Complex, 6 + 2i
parser.evaluate('a * b')        // Complex, 11 + 10i
parser.evaluate('i * i')        // Number,  -1
parser.evaluate('sqrt(-4)')     // Complex, 2i


Units #

math.js supports units. Units can be used in the arithmetic operations
add, subtract, multiply, divide, and exponentiation.
Units can also be converted from one to another.
An overview of all available units can be found on the page
Units.

Units can be converted using the operator to or in.

// create a unit
math.evaluate('5.4 kg')                     // Unit, 5.4 kg

// convert a unit
math.evaluate('2 inch to cm')               // Unit, 5.08 cm
math.evaluate('20 celsius in fahrenheit')   // Unit, ~68 fahrenheit
math.evaluate('90 km/h to m/s')             // Unit, 25 m / s

// convert a unit to a number
// A second parameter with the unit for the exported number must be provided
math.evaluate('number(5 cm, mm)')           // Number, 50

// calculations with units
math.evaluate('0.5kg + 33g')                // Unit, 0.533 kg
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('12 seconds * 2')             // Unit, 24 seconds
math.evaluate('sin(45 deg)')                // Number, 0.7071067811865475
math.evaluate('9.81 m/s^2 * 5 s to mi/h')   // Unit, 109.72172512527 mi / h


Strings #

Strings are enclosed by double quotes “ or single quotes ‘. Strings can be concatenated using the
function concat (not by adding them using + like in JavaScript). Parts of
a string can be retrieved or replaced by using indexes. Strings can be converted
to a number using function number, and numbers can be converted to a string
using function string.

When setting the value of a character in a string, the character that has been
set is returned. Likewise, when a range of characters is set, that range of
characters is returned.

const parser = math.parser()

// create a string
parser.evaluate('"hello"')                        // String, "hello"

// string manipulation
parser.evaluate('a = concat("hello", " world")')  // String, "hello world"
parser.evaluate('size(a)')                        // Matrix [11]
parser.evaluate('a[1:5]')                         // String, "hello"
parser.evaluate('a[1] = "H"')                     // String, "H"
parser.evaluate('a[7:12] = "there!"')             // String, "there!"
parser.evaluate('a')                              // String, "Hello there!"

// string conversion
parser.evaluate('number("300")')                  // Number, 300
parser.evaluate('string(300)')                    // String, "300"


Strings can be used in the evaluate function, to parse expressions inside
the expression parser:

math.evaluate('evaluate("2 + 3")')  // 5


Matrices #

Matrices can be created by entering a series of values between square brackets,
elements are separated by a comma ,.
A matrix like [1, 2, 3] will create a vector, a 1-dimensional matrix with
size [3]. To create a multi-dimensional matrix, matrices can be nested into
each other. For easier creation of two-dimensional matrices, a semicolon ;
can be used to separate rows in a matrix.

// create a matrix
math.evaluate('[1, 2, 3]')                                // Matrix, size [3]
math.evaluate('[[1, 2, 3], [4, 5, 6]]')                   // Matrix, size [2, 3]
math.evaluate('[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]')     // Matrix, size [2, 2, 2]

// create a two dimensional matrix
math.evaluate('[1, 2, 3; 4, 5, 6]')                       // Matrix, size [2, 3]


Another way to create filled matrices is using the functions zeros, ones,
identity, and range.

// initialize a matrix with ones or zeros
math.evaluate('zeros(3, 2)')      // Matrix, [[0, 0], [0, 0], [0, 0]],  size [3, 2]
math.evaluate('ones(3)')          // Matrix, [1, 1, 1],                 size [3]
math.evaluate('5 * ones(2, 2)')   // Matrix, [[5, 5], [5, 5]],          size [2, 2]

// create an identity matrix
math.evaluate('identity(2)')      // Matrix, [[1, 0], [0, 1]],          size [2, 2]

// create a range
math.evaluate('1:4')              // Matrix, [1, 2, 3, 4],              size [4]
math.evaluate('0:2:10')           // Matrix, [0, 2, 4, 6, 8, 10],       size [6]


A subset can be retrieved from a matrix using indexes and a subset of a matrix
can be replaced by using indexes. Indexes are enclosed in square brackets, and
contain a number or a range for each of the matrix dimensions. A range can have
its start and/or end undefined. When the start is undefined, the range will start
at 1, when the end is undefined, the range will end at the end of the matrix.

There is a context variable end available as well to denote the end of the
matrix. This variable cannot be used in multiple nested indices. In that case,
end will be resolved as the end of the innermost matrix. To solve this, 
resolving of the nested index needs to be split in two separate operations.

IMPORTANT: matrix indexes and ranges work differently from the math.js indexes
in JavaScript: They are one-based with an included upper-bound, similar to most
math applications.

parser = math.parser()

// create matrices
parser.evaluate('a = [1, 2; 3, 4]')       // Matrix, [[1, 2], [3, 4]]
parser.evaluate('b = zeros(2, 2)')        // Matrix, [[0, 0], [0, 0]]
parser.evaluate('c = 5:9')                // Matrix, [5, 6, 7, 8, 9]

// replace a subset in a matrix
parser.evaluate('b[1, 1:2] = [5, 6]')     // Matrix, [[5, 6], [0, 0]]
parser.evaluate('b[2, :] = [7, 8]')       // Matrix, [[5, 6], [7, 8]]

// perform a matrix calculation
parser.evaluate('d = a * b')              // Matrix, [[19, 22], [43, 50]]

// retrieve a subset of a matrix
parser.evaluate('d[2, 1]')                // 43
parser.evaluate('d[2, 1:end]')            // Matrix, [[43, 50]]
parser.evaluate('c[end - 1 : -1 : 2]')    // Matrix, [8, 7, 6]


Objects #

Objects in math.js work the same as in languages like JavaScript and Python.
An object is enclosed by curly brackets {, }, and contains a set of
comma separated key/value pairs. Keys and values are separated by a colon :.
Keys can be a symbol like prop or a string like "prop".

math.evaluate('{a: 2 + 1, b: 4}')         // {a: 3, b: 4}
math.evaluate('{"a": 2 + 1, "b": 4}')     // {a: 3, b: 4}


Objects can contain objects:

math.evaluate('{a: 2, b: {c: 3, d: 4}}')  // {a: 2, b: {c: 3, d: 4}}


Object properties can be retrieved or replaced using dot notation or bracket
notation. Unlike JavaScript, when setting a property value, the whole object
is returned, not the property value

let scope = {
  obj: {
    prop: 42
  }
}

// retrieve properties
math.evaluate('obj.prop', scope)          // 42
math.evaluate('obj["prop"]', scope)       // 42

// set properties (returns the whole object, not the property value!)
math.evaluate('obj.prop = 43', scope)     // {prop: 43}
math.evaluate('obj["prop"] = 43', scope)  // {prop: 43}
scope.obj                                 // {prop: 43}


Multi-line expressions #

An expression can contain multiple lines, and expressions can be spread over
multiple lines. Lines can be separated by a newline character \n or by a
semicolon ;. Output of statements followed by a semicolon will be hidden from
the output, and empty lines are ignored. The output is returned as a ResultSet,
with an entry for every visible statement.

// a multi-line expression
math.evaluate('1 * 3 \n 2 * 3 \n 3 * 3')    // ResultSet, [3, 6, 9]

// semicolon statements are hidden from the output
math.evaluate('a=3; b=4; a + b \n a * b')   // ResultSet, [7, 12]

// single expression spread over multiple lines
math.evaluate('a = 2 +\n  3')               // 5
math.evaluate('[\n  1, 2;\n  3, 4\n]')      // Matrix, [[1, 2], [3, 4]]


The results can be read from a ResultSet via the property ResultSet.entries
which is an Array, or by calling ResultSet.valueOf(), which returns the
array with results.

Implicit multiplication #

Implicit multiplication means the multiplication of two symbols, numbers, or a grouped expression inside parentheses without using the * operator. This type of syntax allows a more natural way to enter expressions. For example:

math.evaluate('2 pi')         // 6.283185307179586
math.evaluate('(1+2)(3+4)')   // 21


Parentheses are parsed as a function call when there is a symbol or accessor on
the left hand side, like sqrt(4) or obj.method(4). In other cases the
parentheses are interpreted as an implicit multiplication.

Math.js will always evaluate implicit multiplication before explicit multiplication *, so that the expression x * y z is parsed as x * (y * z). Math.js also gives implicit multiplication higher precedence than division, except when the division matches the pattern [unaryPrefixOp]?[number] / [number] [symbol] or [unaryPrefixOp]?[number] / [number] [left paren]. In that special case, the division is evaluated first:

math.evaluate('20 kg / 4 kg')   // 5      Evaluated as (20 kg) / (4 kg)
math.evaluate('20 / 4 kg')      // 5 kg   Evaluated as (20 / 4) kg


The behavior of implicit multiplication can be summarized by these operator precedence rules, listed from highest to lowest precedence:


  Function calls: [symbol] [left paren]
  Explicit division / when the division matches this pattern: [+-~]?[number] / [+-~]?[number] [symbol] or [number] / [number] [left paren]
  Implicit multiplication
  All other division / and multiplication *


Implicit multiplication is tricky as there can appear to be ambiguity in how an expression will be evaluated. Experience has shown that the above rules most closely match user intent when entering expressions that could be interpreted different ways. It’s also possible that these rules could be tweaked in future major releases.  Use implicit multiplication carefully. If you don’t like the uncertainty introduced by implicit multiplication, use explicit * operators and parentheses to ensure your expression is evaluated the way you intend.

Here are some more examples using implicit multiplication:


  
    
      Expression
      Evaluated as
      Result
    
  
  
    
      (1 + 3) pi
      (1 + 3) * pi
      12.566370614359172
    
    
      (4 - 1) 2
      (4 - 1) * 2
      6
    
    
      3 / 4 mm
      (3 / 4) * mm
      0.75 mm
    
    
      2 + 3 i
      2 + (3 * i)
      2 + 3i
    
    
      (1 + 2) (4 - 2)
      (1 + 2) * (4 - 2)
      6
    
    
      sqrt(4) (1 + 2)
      sqrt(4) * (1 + 2)
      6
    
    
      8 pi / 2 pi
      (8 * pi) / (2 * pi)
      4
    
    
      pi / 2 pi
      pi / (2 * pi)
      0.5
    
    
      1 / 2i
      (1 / 2) * i
      0.5 i
    
    
      8.314 J / mol K
      8.314 J / (mol * K)
      8.314 J / (mol * K)
    
  


Comments #

Comments can be added to explain or describe calculations in the text. A comment
starts with a sharp sign character #, and ends at the end of the line. A line
can contain a comment only, or can contain an expression followed by a comment.

const parser = math.parser()

parser.evaluate('# define some variables')
parser.evaluate('width = 3')                              // 3
parser.evaluate('height = 4')                             // 4
parser.evaluate('width * height   # calculate the area')  // 12\n\n\n\nExpression syntax #

This page describes the syntax of expression parser of math.js. It describes
how to work with the available data types, functions, operators, variables,
and more.

Differences from JavaScript #

The expression parser of math.js is aimed at a mathematical audience,
not a programming audience. The syntax is similar to most calculators and
mathematical applications. This is close to JavaScript as well, though there
are a few important differences between the syntax of the expression parser and
the lower level syntax of math.js. Differences are:


  No need to prefix functions and constants with the math.* namespace,
you can just enter sin(pi / 4).
  Matrix indexes are one-based instead of zero-based.
  There are index and range operators which allow more conveniently getting
and setting matrix indexes, like A[2:4, 1].
  Both indexes and ranges and have the upper-bound included.
  There is a differing syntax for defining functions. Example: f(x) = x^2.
  There are custom operators like x + y instead of add(x, y).
  Some operators are different. For example  ^ is used for exponentiation,
not bitwise xor.
  Implicit multiplication, like 2 pi, is supported and has special rules.
  Relational operators (<, >, <=, >=, ==, and !=) are chained, so the expression 5 < x < 10 is equivalent to 5 < x and x < 10.
  Multi-expression constructs like a = 1; b = 2; a + b or
"a = 1;\n cos(a)\n sin(a)" (where \n denotes newline)
produce a collection (“ResultSet”) of values. Those expressions
terminated by ; are evaluated for side effect only and their values
are suppressed from the result.


Operators #

The expression parser has operators for all common arithmetic operations such
as addition and multiplication. The expression parser uses conventional infix
notation for operators: an operator is placed between its arguments.
Round parentheses can be used to override the default precedence of operators.

// use operators
math.evaluate('2 + 3')       // 5
math.evaluate('2 * 3')       // 6

// use parentheses to override the default precedence
math.evaluate('2 + 3 * 4')   // 14
math.evaluate('(2 + 3) * 4') // 20


The following operators are available. Note that almost every operator listed
also has a function form with identical meaning that can be used
interchangeably. For example, x+y will always evaluate identically to
add(x,y). For a full list of the equivalences, see the section on
Functions below.


  
    
      Operator
      Name
      Syntax
      Associativity
      Example
      Result
    
  
  
    
      (, )
      Grouping
      (x)
      None
      2 * (3 + 4)
      14
    
    
      [, ]
      Matrix, Index
      [...]
      None
      [[1,2],[3,4]]
      [[1,2],[3,4]]
    
    
      {, }
      Object
      {...}
      None
      {a: 1, b: 2}
      {a: 1, b: 2}
    
    
      ,
      Parameter separator
      x, y
      Left to right
      max(2, 1, 5)
      5
    
    
      .
      Property accessor
      obj.prop
      Left to right
      obj={a: 12}; obj.a
      12
    
    
      ;
      Statement separator
      x; y
      Left to right
      a=2; b=3; a*b
      [6]
    
    
      ;
      Row separator
      [x; y]
      Left to right
      [1,2;3,4]
      [[1,2],[3,4]]
    
    
      \n
      Statement separator
      x \n y
      Left to right
      a=2 \n b=3 \n a*b
      [2,3,6]
    
    
      +
      Add
      x + y
      Left to right
      4 + 5
      9
    
    
      +
      Unary plus
      +y
      Right to left
      +4
      4
    
    
      -
      Subtract
      x - y
      Left to right
      7 - 3
      4
    
    
      -
      Unary minus
      -y
      Right to left
      -4
      -4
    
    
      *
      Multiply
      x * y
      Left to right
      2 * 3
      6
    
    
      .*
      Element-wise multiply
      x .* y
      Left to right
      [1,2,3] .* [1,2,3]
      [1,4,9]
    
    
      /
      Divide
      x / y
      Left to right
      6 / 2
      3
    
    
      ./
      Element-wise divide
      x ./ y
      Left to right
      [9,6,4] ./ [3,2,2]
      [3,3,2]
    
    
      %
      Percentage
      x%
      None
      8%
      0.08
    
    
      %
      Addition with Percentage
      x + y%
      Left to right
      100 + 3%
      103
    
    
      %
      Subtraction with Percentage
      x - y%
      Left to right
      100 - 3%
      97
    
    
      % mod
      Modulus
      x % y
      Left to right
      8 % 3
      2
    
    
      ^
      Power
      x ^ y
      Right to left
      2 ^ 3
      8
    
    
      .^
      Element-wise power
      x .^ y
      Right to left
      [2,3] .^ [3,3]
      [8,27]
    
    
      '
      Transpose
      y'
      Left to right
      [[1,2],[3,4]]'
      [[1,3],[2,4]]
    
    
      !
      Factorial
      y!
      Left to right
      5!
      120
    
    
      &
      Bitwise and
      x & y
      Left to right
      5 & 3
      1
    
    
      ~
      Bitwise not
      ~x
      Right to left
      ~2
      -3
    
    
      |
      Bitwise or
      x | y
      Left to right
      5 | 3
      7
    
    
      ^|
      Bitwise xor
      x ^| y
      Left to right
      5 ^| 2
      7
    
    
      <<
      Left shift
      x << y
      Left to right
      4 << 1
      8
    
    
      >>
      Right arithmetic shift
      x >> y
      Left to right
      8 >> 1
      4
    
    
      >>>
      Right logical shift
      x >>> y
      Left to right
      -8 >>> 1
      2147483644
    
    
      and
      Logical and
      x and y
      Left to right
      true and false
      false
    
    
      not
      Logical not
      not y
      Right to left
      not true
      false
    
    
      or
      Logical or
      x or y
      Left to right
      true or false
      true
    
    
      xor
      Logical xor
      x xor y
      Left to right
      true xor true
      false
    
    
      =
      Assignment
      x = y
      Right to left
      a = 5
      5
    
    
      ? :
      Conditional expression
      x ? y : z
      Right to left
      15 > 100 ? 1 : -1
      -1
    
    
      :
      Range
      x : y
      Right to left
      1:4
      [1,2,3,4]
    
    
      to, in
      Unit conversion
      x to y
      Left to right
      2 inch to cm
      5.08 cm
    
    
      ==
      Equal
      x == y
      Left to right
      2 == 4 - 2
      true
    
    
      !=
      Unequal
      x != y
      Left to right
      2 != 3
      true
    
    
      <
      Smaller
      x < y
      Left to right
      2 < 3
      true
    
    
      >
      Larger
      x > y
      Left to right
      2 > 3
      false
    
    
      <=
      Smallereq
      x <= y
      Left to right
      4 <= 3
      false
    
    
      >=
      Largereq
      x >= y
      Left to right
      2 + 4 >= 6
      true
    
  


Precedence #

The operators have the following precedence, from highest to lowest:


  
    
      Operators
      Description
    
  
  
    
      (...)[...]{...}
      GroupingMatrixObject
    
    
      x(...)x[...]obj.prop:
      Function callMatrix indexProperty accessorKey/value separator
    
    
      '
      Matrix transpose
    
    
      !
      Factorial
    
    
      ^, .^
      Exponentiation
    
    
      +, -, ~, not
      Unary plus, unary minus, bitwise not, logical not
    
    
      See section below
      Implicit multiplication
    
    
      *, /, .*, ./,%, mod
      Multiply, divide , percentage, modulus
    
    
      +, -
      Add, subtract
    
    
      :
      Range
    
    
      to, in
      Unit conversion
    
    
      <<, >>, >>>
      Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift
    
    
      ==, !=, <, >, <=, >=
      Relational
    
    
      &
      Bitwise and (lazily evaluated)
    
    
      ^|
      Bitwise xor
    
    
      |
      Bitwise or (lazily evaluated)
    
    
      and
      Logical and (lazily evaluated)
    
    
      xor
      Logical xor
    
    
      or
      Logical or (lazily evaluated)
    
    
      ?, :
      Conditional expression
    
    
      =
      Assignment
    
    
      ,
      Parameter and column separator
    
    
      ;
      Row separator
    
    
      \n, ;
      Statement separators
    
  


Lazy evaluation is used where logically possible for bitwise and logical
operators. In the following example, the value of x will not even be 
evaluated because it cannot effect the final result:
math.evaluate('false and x')        // false, no matter what x equals


Functions #

Functions are called by entering their name, followed by zero or more
arguments enclosed by parentheses. All available functions are listed on the
page Functions.

math.evaluate('sqrt(25)')           // 5
math.evaluate('log(10000, 3 + 7)')  // 4
math.evaluate('sin(pi / 4)')        // 0.7071067811865475


New functions can be defined by “assigning” an expression to a function call
with one or more variables. Such function assignments are limited: they can
only be defined on a single line.

const parser = math.parser()

parser.evaluate('f(x) = x ^ 2 - 5')
parser.evaluate('f(2)')     // -1
parser.evaluate('f(3)')     // 4

parser.evaluate('g(x, y) = x ^ y')
parser.evaluate('g(2, 3)')  // 8


Note that these function assignments do not create closures; put another way,
all free variables in mathjs are dynamic:

const parser = math.parser()

parser.evaluate('x = 7')
parser.evaluate('h(y) = x + y')
parser.evaluate('h(3)')         // 10
parser.evaluate('x = 3')
parser.evaluate('h(3)')         // 6, *not* 10


It is however possible to pass functions as parameters:

const parser = math.parser()

parser.evaluate('twice(func, x) = func(func(x))')
parser.evaluate('twice(square, 2)')    // 16
parser.evaluate('f(x) = 3*x')
parser.evaluate('twice(f, 2)')         // 18

// a simplistic "numerical derivative":
parser.evaluate('eps = 1e-10')
parser.evaluate('nd(f, x) = (f(x+eps) - func(x-eps))/(2*eps)')
parser.evaluate('nd(square,2)')        // 4.000000330961484


Math.js itself heavily uses typed functions, which ensure correct inputs and
throws meaningful errors when the input arguments are invalid. One can create
a typed-function in the
expression parser like:

const parser = math.parser()

parser.evaluate('f = typed({"number": f(x) = x ^ 2 - 5})')


Finally, as mentioned above, there is a function form for nearly every one of
the mathematical operator symbols. Moreover, for some associative operators,
the corresponding function allows arbitrarily many arguments. The table below
gives the full correspondence.


  
    
      Operator Expression
      Equivalent Function Expression
    
  
  
    
      a or b
      or(a,b)
    
    
      a xor b
      xor(a,b)
    
    
      a and b
      and(a,b)
    
    
      a \| b
      bitOr(a,b)
    
    
      a ^\| b
      bitXor(a,b)
    
    
      a & b
      bitAnd(a,b)
    
    
      a == b
      equal(a,b)
    
    
      a != b
      unequal(a,b)
    
    
      a < b
      smaller(a,b)
    
    
      a > b
      larger(a,b)
    
    
      a <= b
      smallerEq(a,b)
    
    
      a << 3
      leftShift(a,3)
    
    
      a >> 3
      rightArithShift(a,3)
    
    
      a >>> 3
      rightLogShift(a,3)
    
    
      u to cm
      to(u, cm)
    
    
      a + b + c + ...
      add(a,b,c,...)
    
    
      a - b
      subtract(a,b)
    
    
      a * b * c * ...
      multiply(a,b,c,...)
    
    
      A .* B
      dotMultiply(A,B)
    
    
      A ./ B
      dotDivide(A,B)
    
    
      a mod b
      mod(a,b)
    
    
      +a
      unaryPlus(a)
    
    
      -a
      unaryMinus(a)
    
    
      ~a
      bitNot(a)
    
    
      not a
      not(a)
    
    
      a^b
      pow(a,b)
    
    
      A .^ B
      dotPow(A,B)
    
    
      a!
      factorial(a)
    
    
      A'
      ctranspose(A)
    
  


Note that math.js embodies a preference for the operator forms, in that calling
simplify (see Algebra) converts any instances of the function
form into the corresponding operator.

Map and forEach #

The map and forEach functions can be used to apply a callback function to each element of an array or matrix.

The callback functions can be functions, typed functions, inline functions (only in the parser) or compiled inline functions (only in the parser).

The callback can have the following inputs:

  value: the current value in the array or matrix.
  index: the index of the current value expressed as an array of numbers.
  array: the array or matrix being iterated.


Below is the syntax for both functions:

map #

The map function applies a function to each element of an array and returns a new array with the results.

const parser = math.parser()

// Define a square function
parser.evaluate('square(x) = x ^ 2')

// Apply the square function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], square)')
// result: [1, 4, 9, 16]

// Apply an inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], f(x) = x ^ 2)')
// result: [1, 4, 9, 16]

// Apply a compiled inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], x ^ 2)')
// result: [1, 4, 9, 16]


forEach #
The forEach function applies a function to each element of an array or matrix but does not return a new array. It is useful for executing side effects.

// Define a function that prints each element
math.import({consoleLog: x => console.log(x)})
const parser = math.parser()

// Define a squareConsleLog function
parser.evaluate('squareConsoleLog(x) = consoleLog(x ^ 2)')

// Apply the squareConsleLog function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], squareConsleLog)')
// Prints: 1, 4, 9, 16

// Apply an inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], f(x) = consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16

// Apply a compiled inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16


These functions are useful for performing element-wise operations on arrays or matrices.

Constants and variables #

Math.js has a number of built-in constants such as pi and e.
All available constants are listed on he page
Constants.

// use constants
math.evaluate('pi')                 // 3.141592653589793
math.evaluate('e ^ 2')              // 7.3890560989306495
math.evaluate('log(e)')             // 1
math.evaluate('e ^ (pi * i) + 1')   // ~0 (Euler)


Variables can be defined using the assignment operator =, and can be used
like constants.

const parser = math.parser()

// define variables
parser.evaluate('a = 3.4')      // 3.4
parser.evaluate('b = 5 / 2')    // 2.5

// use variables
parser.evaluate('a * b')        // 8.5


Variable names must:


  Begin with an “alpha character”, which is:
    
      A latin letter (upper or lower case). Ascii: a-z, A-Z
      An underscore.                        Ascii: _
      A dollar sign.                        Ascii: $
      A latin letter with accents.          Unicode: \u00C0 - \u02AF
      A greek letter.                       Unicode: \u0370 - \u03FF
      A letter-like character.              Unicode: \u2100 - \u214F
      A mathematical alphanumeric symbol.   Unicode: \u{1D400} - \u{1D7FF} excluding invalid code points
    
  
  Contain only alpha characters (above) and digits 0-9
  Not be any of the following: mod, to, in, and, xor, or, not, end. It is possible to assign to some of these, but that’s not recommended.


It is possible to customize the allowed alpha characters, see Customize supported characters for more information.

Data types #

The expression parser supports booleans, numbers, complex numbers, units,
strings, matrices, and objects.

Booleans #

Booleans true and false can be used in expressions.

// use booleans
math.evaluate('true')               // true
math.evaluate('false')              // false
math.evaluate('(2 == 3) == false')  // true


Booleans can be converted to numbers and strings and vice versa using the
functions number and boolean, and string.

// convert booleans
math.evaluate('number(true)')       // 1
math.evaluate('string(false)')      // "false"
math.evaluate('boolean(1)')         // true
math.evaluate('boolean("false")')   // false


Numbers #

The most important and basic data type in math.js are numbers. Numbers use a
point as decimal mark. Numbers can be entered with exponential notation.
Examples:

// numbers in math.js
math.evaluate('2')        // 2
math.evaluate('3.14')     // 3.14
math.evaluate('1.4e3')    // 1400
math.evaluate('22e-3')    // 0.022


A number can be converted to a string and vice versa using the functions
number and string.

// convert a string into a number
math.evaluate('number("2.3")')    // 2.3
math.evaluate('string(2.3)')      // "2.3"


Math.js uses regular JavaScript numbers, which are floating points with a
limited precision and limited range. The limitations are described in detail
on the page Numbers.

math.evaluate('1e-325')   // 0
math.evaluate('1e309')    // Infinity
math.evaluate('-1e309')   // -Infinity


When doing calculations with floats, one can very easily get round-off errors:

// round-off error due to limited floating point precision
math.evaluate('0.1 + 0.2')  // 0.30000000000000004


When outputting results, the function math.format can be used to hide
these round-off errors when outputting results for the user:

const ans = math.evaluate('0.1 + 0.2')  //  0.30000000000000004
math.format(ans, {precision: 14})       // "0.3"


Numbers can be expressed as binary, octal, and hexadecimal literals:

math.evaluate('0b11')  //  3
math.evaluate('0o77')  //  63
math.evaluate('0xff')  //  255


A word size suffix can be used to change the behavior of non decimal literal evaluation:

math.evaluate('0xffi8')         // -1
math.evaluate('0xffffffffi32')  //  -1
math.evaluate('0xfffffffffi32') //  SyntaxError: String "0xfffffffff" is out of range


Non decimal numbers can include a radix point:
math.evaluate('0b1.1')         // 1.5
math.evaluate('0o1.4')         // 1.5
math.evaluate('0x1.8')         // 1.5


Numbers can be formatted as binary, octal, and hex strings using the notation option of the format function:

math.evaluate('format(3, {notation: "bin"})')    //  '0b11'
math.evaluate('format(63, {notation: "oct"})')   //  '0o77'
math.evaluate('format(255, {notation: "hex"})')  //  '0xff'
math.evaluate('format(-1, {notation: "hex"})')   //  '-0x1'
math.evaluate('format(2.3, {notation: "hex"})')  //  '0x2.4cccccccccccc'


The format function accepts a wordSize option to use in conjunction with the non binary notations:

math.evaluate('format(-1, {notation: "hex", wordSize: 8})')   //  '0xffi8'


The functions bin, oct, and hex are shorthand for the format function with notation set accordingly:

math.evaluate('bin(-1)')     // '-0b1'
math.evaluate('bin(-1, 8)')  // '0b11111111i8'


BigNumbers #

Math.js supports BigNumbers for calculations with an arbitrary precision.
The pros and cons of Number and BigNumber are explained in detail on the page
Numbers.

BigNumbers are slower but have a higher precision. Calculations with big
numbers are supported only by arithmetic functions.

BigNumbers can be created using the bignumber function:

math.evaluate('bignumber(0.1) + bignumber(0.2)') // BigNumber, 0.3


The default number type of the expression parser can be changed at instantiation
of math.js. The expression parser parses numbers as BigNumber by default:

// Configure the type of number: 'number' (default), 'BigNumber', or 'Fraction'
math.config({number: 'BigNumber'})

// all numbers are parsed as BigNumber
math.evaluate('0.1 + 0.2')  // BigNumber, 0.3


BigNumbers can be converted to numbers and vice versa using the functions
number and bignumber. When converting a BigNumber to a Number, the high
precision of the BigNumber will be lost. When a BigNumber is too large to be represented
as Number, it will be initialized as Infinity.

Complex numbers #

Complex numbers can be created using the imaginary unit i, which is defined
as i^2 = -1. Complex numbers have a real and complex part, which can be
retrieved using the functions re and im.

const parser = math.parser()

// create complex numbers
parser.evaluate('a = 2 + 3i')   // Complex, 2 + 3i
parser.evaluate('b = 4 - i')    // Complex, 4 - i

// get real and imaginary part of a complex number
parser.evaluate('re(a)')        // Number,  2
parser.evaluate('im(a)')        // Number,  3

// calculations with complex numbers
parser.evaluate('a + b')        // Complex, 6 + 2i
parser.evaluate('a * b')        // Complex, 11 + 10i
parser.evaluate('i * i')        // Number,  -1
parser.evaluate('sqrt(-4)')     // Complex, 2i


Units #

math.js supports units. Units can be used in the arithmetic operations
add, subtract, multiply, divide, and exponentiation.
Units can also be converted from one to another.
An overview of all available units can be found on the page
Units.

Units can be converted using the operator to or in.

// create a unit
math.evaluate('5.4 kg')                     // Unit, 5.4 kg

// convert a unit
math.evaluate('2 inch to cm')               // Unit, 5.08 cm
math.evaluate('20 celsius in fahrenheit')   // Unit, ~68 fahrenheit
math.evaluate('90 km/h to m/s')             // Unit, 25 m / s

// convert a unit to a number
// A second parameter with the unit for the exported number must be provided
math.evaluate('number(5 cm, mm)')           // Number, 50

// calculations with units
math.evaluate('0.5kg + 33g')                // Unit, 0.533 kg
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('12 seconds * 2')             // Unit, 24 seconds
math.evaluate('sin(45 deg)')                // Number, 0.7071067811865475
math.evaluate('9.81 m/s^2 * 5 s to mi/h')   // Unit, 109.72172512527 mi / h


Strings #

Strings are enclosed by double quotes “ or single quotes ‘. Strings can be concatenated using the
function concat (not by adding them using + like in JavaScript). Parts of
a string can be retrieved or replaced by using indexes. Strings can be converted
to a number using function number, and numbers can be converted to a string
using function string.

When setting the value of a character in a string, the character that has been
set is returned. Likewise, when a range of characters is set, that range of
characters is returned.

const parser = math.parser()

// create a string
parser.evaluate('"hello"')                        // String, "hello"

// string manipulation
parser.evaluate('a = concat("hello", " world")')  // String, "hello world"
parser.evaluate('size(a)')                        // Matrix [11]
parser.evaluate('a[1:5]')                         // String, "hello"
parser.evaluate('a[1] = "H"')                     // String, "H"
parser.evaluate('a[7:12] = "there!"')             // String, "there!"
parser.evaluate('a')                              // String, "Hello there!"

// string conversion
parser.evaluate('number("300")')                  // Number, 300
parser.evaluate('string(300)')                    // String, "300"


Strings can be used in the evaluate function, to parse expressions inside
the expression parser:

math.evaluate('evaluate("2 + 3")')  // 5


Matrices #

Matrices can be created by entering a series of values between square brackets,
elements are separated by a comma ,.
A matrix like [1, 2, 3] will create a vector, a 1-dimensional matrix with
size [3]. To create a multi-dimensional matrix, matrices can be nested into
each other. For easier creation of two-dimensional matrices, a semicolon ;
can be used to separate rows in a matrix.

// create a matrix
math.evaluate('[1, 2, 3]')                                // Matrix, size [3]
math.evaluate('[[1, 2, 3], [4, 5, 6]]')                   // Matrix, size [2, 3]
math.evaluate('[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]')     // Matrix, size [2, 2, 2]

// create a two dimensional matrix
math.evaluate('[1, 2, 3; 4, 5, 6]')                       // Matrix, size [2, 3]


Another way to create filled matrices is using the functions zeros, ones,
identity, and range.

// initialize a matrix with ones or zeros
math.evaluate('zeros(3, 2)')      // Matrix, [[0, 0], [0, 0], [0, 0]],  size [3, 2]
math.evaluate('ones(3)')          // Matrix, [1, 1, 1],                 size [3]
math.evaluate('5 * ones(2, 2)')   // Matrix, [[5, 5], [5, 5]],          size [2, 2]

// create an identity matrix
math.evaluate('identity(2)')      // Matrix, [[1, 0], [0, 1]],          size [2, 2]

// create a range
math.evaluate('1:4')              // Matrix, [1, 2, 3, 4],              size [4]
math.evaluate('0:2:10')           // Matrix, [0, 2, 4, 6, 8, 10],       size [6]


A subset can be retrieved from a matrix using indexes and a subset of a matrix
can be replaced by using indexes. Indexes are enclosed in square brackets, and
contain a number or a range for each of the matrix dimensions. A range can have
its start and/or end undefined. When the start is undefined, the range will start
at 1, when the end is undefined, the range will end at the end of the matrix.

There is a context variable end available as well to denote the end of the
matrix. This variable cannot be used in multiple nested indices. In that case,
end will be resolved as the end of the innermost matrix. To solve this, 
resolving of the nested index needs to be split in two separate operations.

IMPORTANT: matrix indexes and ranges work differently from the math.js indexes
in JavaScript: They are one-based with an included upper-bound, similar to most
math applications.

parser = math.parser()

// create matrices
parser.evaluate('a = [1, 2; 3, 4]')       // Matrix, [[1, 2], [3, 4]]
parser.evaluate('b = zeros(2, 2)')        // Matrix, [[0, 0], [0, 0]]
parser.evaluate('c = 5:9')                // Matrix, [5, 6, 7, 8, 9]

// replace a subset in a matrix
parser.evaluate('b[1, 1:2] = [5, 6]')     // Matrix, [[5, 6], [0, 0]]
parser.evaluate('b[2, :] = [7, 8]')       // Matrix, [[5, 6], [7, 8]]

// perform a matrix calculation
parser.evaluate('d = a * b')              // Matrix, [[19, 22], [43, 50]]

// retrieve a subset of a matrix
parser.evaluate('d[2, 1]')                // 43
parser.evaluate('d[2, 1:end]')            // Matrix, [[43, 50]]
parser.evaluate('c[end - 1 : -1 : 2]')    // Matrix, [8, 7, 6]


Objects #

Objects in math.js work the same as in languages like JavaScript and Python.
An object is enclosed by curly brackets {, }, and contains a set of
comma separated key/value pairs. Keys and values are separated by a colon :.
Keys can be a symbol like prop or a string like "prop".

math.evaluate('{a: 2 + 1, b: 4}')         // {a: 3, b: 4}
math.evaluate('{"a": 2 + 1, "b": 4}')     // {a: 3, b: 4}


Objects can contain objects:

math.evaluate('{a: 2, b: {c: 3, d: 4}}')  // {a: 2, b: {c: 3, d: 4}}


Object properties can be retrieved or replaced using dot notation or bracket
notation. Unlike JavaScript, when setting a property value, the whole object
is returned, not the property value

let scope = {
  obj: {
    prop: 42
  }
}

// retrieve properties
math.evaluate('obj.prop', scope)          // 42
math.evaluate('obj["prop"]', scope)       // 42

// set properties (returns the whole object, not the property value!)
math.evaluate('obj.prop = 43', scope)     // {prop: 43}
math.evaluate('obj["prop"] = 43', scope)  // {prop: 43}
scope.obj                                 // {prop: 43}


Multi-line expressions #

An expression can contain multiple lines, and expressions can be spread over
multiple lines. Lines can be separated by a newline character \n or by a
semicolon ;. Output of statements followed by a semicolon will be hidden from
the output, and empty lines are ignored. The output is returned as a ResultSet,
with an entry for every visible statement.

// a multi-line expression
math.evaluate('1 * 3 \n 2 * 3 \n 3 * 3')    // ResultSet, [3, 6, 9]

// semicolon statements are hidden from the output
math.evaluate('a=3; b=4; a + b \n a * b')   // ResultSet, [7, 12]

// single expression spread over multiple lines
math.evaluate('a = 2 +\n  3')               // 5
math.evaluate('[\n  1, 2;\n  3, 4\n]')      // Matrix, [[1, 2], [3, 4]]


The results can be read from a ResultSet via the property ResultSet.entries
which is an Array, or by calling ResultSet.valueOf(), which returns the
array with results.

Implicit multiplication #

Implicit multiplication means the multiplication of two symbols, numbers, or a grouped expression inside parentheses without using the * operator. This type of syntax allows a more natural way to enter expressions. For example:

math.evaluate('2 pi')         // 6.283185307179586
math.evaluate('(1+2)(3+4)')   // 21


Parentheses are parsed as a function call when there is a symbol or accessor on
the left hand side, like sqrt(4) or obj.method(4). In other cases the
parentheses are interpreted as an implicit multiplication.

Math.js will always evaluate implicit multiplication before explicit multiplication *, so that the expression x * y z is parsed as x * (y * z). Math.js also gives implicit multiplication higher precedence than division, except when the division matches the pattern [unaryPrefixOp]?[number] / [number] [symbol] or [unaryPrefixOp]?[number] / [number] [left paren]. In that special case, the division is evaluated first:

math.evaluate('20 kg / 4 kg')   // 5      Evaluated as (20 kg) / (4 kg)
math.evaluate('20 / 4 kg')      // 5 kg   Evaluated as (20 / 4) kg


The behavior of implicit multiplication can be summarized by these operator precedence rules, listed from highest to lowest precedence:


  Function calls: [symbol] [left paren]
  Explicit division / when the division matches this pattern: [+-~]?[number] / [+-~]?[number] [symbol] or [number] / [number] [left paren]
  Implicit multiplication
  All other division / and multiplication *


Implicit multiplication is tricky as there can appear to be ambiguity in how an expression will be evaluated. Experience has shown that the above rules most closely match user intent when entering expressions that could be interpreted different ways. It’s also possible that these rules could be tweaked in future major releases.  Use implicit multiplication carefully. If you don’t like the uncertainty introduced by implicit multiplication, use explicit * operators and parentheses to ensure your expression is evaluated the way you intend.

Here are some more examples using implicit multiplication:


  
    
      Expression
      Evaluated as
      Result
    
  
  
    
      (1 + 3) pi
      (1 + 3) * pi
      12.566370614359172
    
    
      (4 - 1) 2
      (4 - 1) * 2
      6
    
    
      3 / 4 mm
      (3 / 4) * mm
      0.75 mm
    
    
      2 + 3 i
      2 + (3 * i)
      2 + 3i
    
    
      (1 + 2) (4 - 2)
      (1 + 2) * (4 - 2)
      6
    
    
      sqrt(4) (1 + 2)
      sqrt(4) * (1 + 2)
      6
    
    
      8 pi / 2 pi
      (8 * pi) / (2 * pi)
      4
    
    
      pi / 2 pi
      pi / (2 * pi)
      0.5
    
    
      1 / 2i
      (1 / 2) * i
      0.5 i
    
    
      8.314 J / mol K
      8.314 J / (mol * K)
      8.314 J / (mol * K)
    
  


Comments #

Comments can be added to explain or describe calculations in the text. A comment
starts with a sharp sign character #, and ends at the end of the line. A line
can contain a comment only, or can contain an expression followed by a comment.

const parser = math.parser()

parser.evaluate('# define some variables')
parser.evaluate('width = 3')                              // 3
parser.evaluate('height = 4')                             // 4
parser.evaluate('width * height   # calculate the area')  // 12\n\n\n\nExpression syntax #

This page describes the syntax of expression parser of math.js. It describes
how to work with the available data types, functions, operators, variables,
and more.

Differences from JavaScript #

The expression parser of math.js is aimed at a mathematical audience,
not a programming audience. The syntax is similar to most calculators and
mathematical applications. This is close to JavaScript as well, though there
are a few important differences between the syntax of the expression parser and
the lower level syntax of math.js. Differences are:


  No need to prefix functions and constants with the math.* namespace,
you can just enter sin(pi / 4).
  Matrix indexes are one-based instead of zero-based.
  There are index and range operators which allow more conveniently getting
and setting matrix indexes, like A[2:4, 1].
  Both indexes and ranges and have the upper-bound included.
  There is a differing syntax for defining functions. Example: f(x) = x^2.
  There are custom operators like x + y instead of add(x, y).
  Some operators are different. For example  ^ is used for exponentiation,
not bitwise xor.
  Implicit multiplication, like 2 pi, is supported and has special rules.
  Relational operators (<, >, <=, >=, ==, and !=) are chained, so the expression 5 < x < 10 is equivalent to 5 < x and x < 10.
  Multi-expression constructs like a = 1; b = 2; a + b or
"a = 1;\n cos(a)\n sin(a)" (where \n denotes newline)
produce a collection (“ResultSet”) of values. Those expressions
terminated by ; are evaluated for side effect only and their values
are suppressed from the result.


Operators #

The expression parser has operators for all common arithmetic operations such
as addition and multiplication. The expression parser uses conventional infix
notation for operators: an operator is placed between its arguments.
Round parentheses can be used to override the default precedence of operators.

// use operators
math.evaluate('2 + 3')       // 5
math.evaluate('2 * 3')       // 6

// use parentheses to override the default precedence
math.evaluate('2 + 3 * 4')   // 14
math.evaluate('(2 + 3) * 4') // 20


The following operators are available. Note that almost every operator listed
also has a function form with identical meaning that can be used
interchangeably. For example, x+y will always evaluate identically to
add(x,y). For a full list of the equivalences, see the section on
Functions below.


  
    
      Operator
      Name
      Syntax
      Associativity
      Example
      Result
    
  
  
    
      (, )
      Grouping
      (x)
      None
      2 * (3 + 4)
      14
    
    
      [, ]
      Matrix, Index
      [...]
      None
      [[1,2],[3,4]]
      [[1,2],[3,4]]
    
    
      {, }
      Object
      {...}
      None
      {a: 1, b: 2}
      {a: 1, b: 2}
    
    
      ,
      Parameter separator
      x, y
      Left to right
      max(2, 1, 5)
      5
    
    
      .
      Property accessor
      obj.prop
      Left to right
      obj={a: 12}; obj.a
      12
    
    
      ;
      Statement separator
      x; y
      Left to right
      a=2; b=3; a*b
      [6]
    
    
      ;
      Row separator
      [x; y]
      Left to right
      [1,2;3,4]
      [[1,2],[3,4]]
    
    
      \n
      Statement separator
      x \n y
      Left to right
      a=2 \n b=3 \n a*b
      [2,3,6]
    
    
      +
      Add
      x + y
      Left to right
      4 + 5
      9
    
    
      +
      Unary plus
      +y
      Right to left
      +4
      4
    
    
      -
      Subtract
      x - y
      Left to right
      7 - 3
      4
    
    
      -
      Unary minus
      -y
      Right to left
      -4
      -4
    
    
      *
      Multiply
      x * y
      Left to right
      2 * 3
      6
    
    
      .*
      Element-wise multiply
      x .* y
      Left to right
      [1,2,3] .* [1,2,3]
      [1,4,9]
    
    
      /
      Divide
      x / y
      Left to right
      6 / 2
      3
    
    
      ./
      Element-wise divide
      x ./ y
      Left to right
      [9,6,4] ./ [3,2,2]
      [3,3,2]
    
    
      %
      Percentage
      x%
      None
      8%
      0.08
    
    
      %
      Addition with Percentage
      x + y%
      Left to right
      100 + 3%
      103
    
    
      %
      Subtraction with Percentage
      x - y%
      Left to right
      100 - 3%
      97
    
    
      % mod
      Modulus
      x % y
      Left to right
      8 % 3
      2
    
    
      ^
      Power
      x ^ y
      Right to left
      2 ^ 3
      8
    
    
      .^
      Element-wise power
      x .^ y
      Right to left
      [2,3] .^ [3,3]
      [8,27]
    
    
      '
      Transpose
      y'
      Left to right
      [[1,2],[3,4]]'
      [[1,3],[2,4]]
    
    
      !
      Factorial
      y!
      Left to right
      5!
      120
    
    
      &
      Bitwise and
      x & y
      Left to right
      5 & 3
      1
    
    
      ~
      Bitwise not
      ~x
      Right to left
      ~2
      -3
    
    
      |
      Bitwise or
      x | y
      Left to right
      5 | 3
      7
    
    
      ^|
      Bitwise xor
      x ^| y
      Left to right
      5 ^| 2
      7
    
    
      <<
      Left shift
      x << y
      Left to right
      4 << 1
      8
    
    
      >>
      Right arithmetic shift
      x >> y
      Left to right
      8 >> 1
      4
    
    
      >>>
      Right logical shift
      x >>> y
      Left to right
      -8 >>> 1
      2147483644
    
    
      and
      Logical and
      x and y
      Left to right
      true and false
      false
    
    
      not
      Logical not
      not y
      Right to left
      not true
      false
    
    
      or
      Logical or
      x or y
      Left to right
      true or false
      true
    
    
      xor
      Logical xor
      x xor y
      Left to right
      true xor true
      false
    
    
      =
      Assignment
      x = y
      Right to left
      a = 5
      5
    
    
      ? :
      Conditional expression
      x ? y : z
      Right to left
      15 > 100 ? 1 : -1
      -1
    
    
      :
      Range
      x : y
      Right to left
      1:4
      [1,2,3,4]
    
    
      to, in
      Unit conversion
      x to y
      Left to right
      2 inch to cm
      5.08 cm
    
    
      ==
      Equal
      x == y
      Left to right
      2 == 4 - 2
      true
    
    
      !=
      Unequal
      x != y
      Left to right
      2 != 3
      true
    
    
      <
      Smaller
      x < y
      Left to right
      2 < 3
      true
    
    
      >
      Larger
      x > y
      Left to right
      2 > 3
      false
    
    
      <=
      Smallereq
      x <= y
      Left to right
      4 <= 3
      false
    
    
      >=
      Largereq
      x >= y
      Left to right
      2 + 4 >= 6
      true
    
  


Precedence #

The operators have the following precedence, from highest to lowest:


  
    
      Operators
      Description
    
  
  
    
      (...)[...]{...}
      GroupingMatrixObject
    
    
      x(...)x[...]obj.prop:
      Function callMatrix indexProperty accessorKey/value separator
    
    
      '
      Matrix transpose
    
    
      !
      Factorial
    
    
      ^, .^
      Exponentiation
    
    
      +, -, ~, not
      Unary plus, unary minus, bitwise not, logical not
    
    
      See section below
      Implicit multiplication
    
    
      *, /, .*, ./,%, mod
      Multiply, divide , percentage, modulus
    
    
      +, -
      Add, subtract
    
    
      :
      Range
    
    
      to, in
      Unit conversion
    
    
      <<, >>, >>>
      Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift
    
    
      ==, !=, <, >, <=, >=
      Relational
    
    
      &
      Bitwise and (lazily evaluated)
    
    
      ^|
      Bitwise xor
    
    
      |
      Bitwise or (lazily evaluated)
    
    
      and
      Logical and (lazily evaluated)
    
    
      xor
      Logical xor
    
    
      or
      Logical or (lazily evaluated)
    
    
      ?, :
      Conditional expression
    
    
      =
      Assignment
    
    
      ,
      Parameter and column separator
    
    
      ;
      Row separator
    
    
      \n, ;
      Statement separators
    
  


Lazy evaluation is used where logically possible for bitwise and logical
operators. In the following example, the value of x will not even be 
evaluated because it cannot effect the final result:
math.evaluate('false and x')        // false, no matter what x equals


Functions #

Functions are called by entering their name, followed by zero or more
arguments enclosed by parentheses. All available functions are listed on the
page Functions.

math.evaluate('sqrt(25)')           // 5
math.evaluate('log(10000, 3 + 7)')  // 4
math.evaluate('sin(pi / 4)')        // 0.7071067811865475


New functions can be defined by “assigning” an expression to a function call
with one or more variables. Such function assignments are limited: they can
only be defined on a single line.

const parser = math.parser()

parser.evaluate('f(x) = x ^ 2 - 5')
parser.evaluate('f(2)')     // -1
parser.evaluate('f(3)')     // 4

parser.evaluate('g(x, y) = x ^ y')
parser.evaluate('g(2, 3)')  // 8


Note that these function assignments do not create closures; put another way,
all free variables in mathjs are dynamic:

const parser = math.parser()

parser.evaluate('x = 7')
parser.evaluate('h(y) = x + y')
parser.evaluate('h(3)')         // 10
parser.evaluate('x = 3')
parser.evaluate('h(3)')         // 6, *not* 10


It is however possible to pass functions as parameters:

const parser = math.parser()

parser.evaluate('twice(func, x) = func(func(x))')
parser.evaluate('twice(square, 2)')    // 16
parser.evaluate('f(x) = 3*x')
parser.evaluate('twice(f, 2)')         // 18

// a simplistic "numerical derivative":
parser.evaluate('eps = 1e-10')
parser.evaluate('nd(f, x) = (f(x+eps) - func(x-eps))/(2*eps)')
parser.evaluate('nd(square,2)')        // 4.000000330961484


Math.js itself heavily uses typed functions, which ensure correct inputs and
throws meaningful errors when the input arguments are invalid. One can create
a typed-function in the
expression parser like:

const parser = math.parser()

parser.evaluate('f = typed({"number": f(x) = x ^ 2 - 5})')


Finally, as mentioned above, there is a function form for nearly every one of
the mathematical operator symbols. Moreover, for some associative operators,
the corresponding function allows arbitrarily many arguments. The table below
gives the full correspondence.


  
    
      Operator Expression
      Equivalent Function Expression
    
  
  
    
      a or b
      or(a,b)
    
    
      a xor b
      xor(a,b)
    
    
      a and b
      and(a,b)
    
    
      a \| b
      bitOr(a,b)
    
    
      a ^\| b
      bitXor(a,b)
    
    
      a & b
      bitAnd(a,b)
    
    
      a == b
      equal(a,b)
    
    
      a != b
      unequal(a,b)
    
    
      a < b
      smaller(a,b)
    
    
      a > b
      larger(a,b)
    
    
      a <= b
      smallerEq(a,b)
    
    
      a << 3
      leftShift(a,3)
    
    
      a >> 3
      rightArithShift(a,3)
    
    
      a >>> 3
      rightLogShift(a,3)
    
    
      u to cm
      to(u, cm)
    
    
      a + b + c + ...
      add(a,b,c,...)
    
    
      a - b
      subtract(a,b)
    
    
      a * b * c * ...
      multiply(a,b,c,...)
    
    
      A .* B
      dotMultiply(A,B)
    
    
      A ./ B
      dotDivide(A,B)
    
    
      a mod b
      mod(a,b)
    
    
      +a
      unaryPlus(a)
    
    
      -a
      unaryMinus(a)
    
    
      ~a
      bitNot(a)
    
    
      not a
      not(a)
    
    
      a^b
      pow(a,b)
    
    
      A .^ B
      dotPow(A,B)
    
    
      a!
      factorial(a)
    
    
      A'
      ctranspose(A)
    
  


Note that math.js embodies a preference for the operator forms, in that calling
simplify (see Algebra) converts any instances of the function
form into the corresponding operator.

Map and forEach #

The map and forEach functions can be used to apply a callback function to each element of an array or matrix.

The callback functions can be functions, typed functions, inline functions (only in the parser) or compiled inline functions (only in the parser).

The callback can have the following inputs:

  value: the current value in the array or matrix.
  index: the index of the current value expressed as an array of numbers.
  array: the array or matrix being iterated.


Below is the syntax for both functions:

map #

The map function applies a function to each element of an array and returns a new array with the results.

const parser = math.parser()

// Define a square function
parser.evaluate('square(x) = x ^ 2')

// Apply the square function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], square)')
// result: [1, 4, 9, 16]

// Apply an inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], f(x) = x ^ 2)')
// result: [1, 4, 9, 16]

// Apply a compiled inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], x ^ 2)')
// result: [1, 4, 9, 16]


forEach #
The forEach function applies a function to each element of an array or matrix but does not return a new array. It is useful for executing side effects.

// Define a function that prints each element
math.import({consoleLog: x => console.log(x)})
const parser = math.parser()

// Define a squareConsleLog function
parser.evaluate('squareConsoleLog(x) = consoleLog(x ^ 2)')

// Apply the squareConsleLog function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], squareConsleLog)')
// Prints: 1, 4, 9, 16

// Apply an inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], f(x) = consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16

// Apply a compiled inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16


These functions are useful for performing element-wise operations on arrays or matrices.

Constants and variables #

Math.js has a number of built-in constants such as pi and e.
All available constants are listed on he page
Constants.

// use constants
math.evaluate('pi')                 // 3.141592653589793
math.evaluate('e ^ 2')              // 7.3890560989306495
math.evaluate('log(e)')             // 1
math.evaluate('e ^ (pi * i) + 1')   // ~0 (Euler)


Variables can be defined using the assignment operator =, and can be used
like constants.

const parser = math.parser()

// define variables
parser.evaluate('a = 3.4')      // 3.4
parser.evaluate('b = 5 / 2')    // 2.5

// use variables
parser.evaluate('a * b')        // 8.5


Variable names must:


  Begin with an “alpha character”, which is:
    
      A latin letter (upper or lower case). Ascii: a-z, A-Z
      An underscore.                        Ascii: _
      A dollar sign.                        Ascii: $
      A latin letter with accents.          Unicode: \u00C0 - \u02AF
      A greek letter.                       Unicode: \u0370 - \u03FF
      A letter-like character.              Unicode: \u2100 - \u214F
      A mathematical alphanumeric symbol.   Unicode: \u{1D400} - \u{1D7FF} excluding invalid code points
    
  
  Contain only alpha characters (above) and digits 0-9
  Not be any of the following: mod, to, in, and, xor, or, not, end. It is possible to assign to some of these, but that’s not recommended.


It is possible to customize the allowed alpha characters, see Customize supported characters for more information.

Data types #

The expression parser supports booleans, numbers, complex numbers, units,
strings, matrices, and objects.

Booleans #

Booleans true and false can be used in expressions.

// use booleans
math.evaluate('true')               // true
math.evaluate('false')              // false
math.evaluate('(2 == 3) == false')  // true


Booleans can be converted to numbers and strings and vice versa using the
functions number and boolean, and string.

// convert booleans
math.evaluate('number(true)')       // 1
math.evaluate('string(false)')      // "false"
math.evaluate('boolean(1)')         // true
math.evaluate('boolean("false")')   // false


Numbers #

The most important and basic data type in math.js are numbers. Numbers use a
point as decimal mark. Numbers can be entered with exponential notation.
Examples:

// numbers in math.js
math.evaluate('2')        // 2
math.evaluate('3.14')     // 3.14
math.evaluate('1.4e3')    // 1400
math.evaluate('22e-3')    // 0.022


A number can be converted to a string and vice versa using the functions
number and string.

// convert a string into a number
math.evaluate('number("2.3")')    // 2.3
math.evaluate('string(2.3)')      // "2.3"


Math.js uses regular JavaScript numbers, which are floating points with a
limited precision and limited range. The limitations are described in detail
on the page Numbers.

math.evaluate('1e-325')   // 0
math.evaluate('1e309')    // Infinity
math.evaluate('-1e309')   // -Infinity


When doing calculations with floats, one can very easily get round-off errors:

// round-off error due to limited floating point precision
math.evaluate('0.1 + 0.2')  // 0.30000000000000004


When outputting results, the function math.format can be used to hide
these round-off errors when outputting results for the user:

const ans = math.evaluate('0.1 + 0.2')  //  0.30000000000000004
math.format(ans, {precision: 14})       // "0.3"


Numbers can be expressed as binary, octal, and hexadecimal literals:

math.evaluate('0b11')  //  3
math.evaluate('0o77')  //  63
math.evaluate('0xff')  //  255


A word size suffix can be used to change the behavior of non decimal literal evaluation:

math.evaluate('0xffi8')         // -1
math.evaluate('0xffffffffi32')  //  -1
math.evaluate('0xfffffffffi32') //  SyntaxError: String "0xfffffffff" is out of range


Non decimal numbers can include a radix point:
math.evaluate('0b1.1')         // 1.5
math.evaluate('0o1.4')         // 1.5
math.evaluate('0x1.8')         // 1.5


Numbers can be formatted as binary, octal, and hex strings using the notation option of the format function:

math.evaluate('format(3, {notation: "bin"})')    //  '0b11'
math.evaluate('format(63, {notation: "oct"})')   //  '0o77'
math.evaluate('format(255, {notation: "hex"})')  //  '0xff'
math.evaluate('format(-1, {notation: "hex"})')   //  '-0x1'
math.evaluate('format(2.3, {notation: "hex"})')  //  '0x2.4cccccccccccc'


The format function accepts a wordSize option to use in conjunction with the non binary notations:

math.evaluate('format(-1, {notation: "hex", wordSize: 8})')   //  '0xffi8'


The functions bin, oct, and hex are shorthand for the format function with notation set accordingly:

math.evaluate('bin(-1)')     // '-0b1'
math.evaluate('bin(-1, 8)')  // '0b11111111i8'


BigNumbers #

Math.js supports BigNumbers for calculations with an arbitrary precision.
The pros and cons of Number and BigNumber are explained in detail on the page
Numbers.

BigNumbers are slower but have a higher precision. Calculations with big
numbers are supported only by arithmetic functions.

BigNumbers can be created using the bignumber function:

math.evaluate('bignumber(0.1) + bignumber(0.2)') // BigNumber, 0.3


The default number type of the expression parser can be changed at instantiation
of math.js. The expression parser parses numbers as BigNumber by default:

// Configure the type of number: 'number' (default), 'BigNumber', or 'Fraction'
math.config({number: 'BigNumber'})

// all numbers are parsed as BigNumber
math.evaluate('0.1 + 0.2')  // BigNumber, 0.3


BigNumbers can be converted to numbers and vice versa using the functions
number and bignumber. When converting a BigNumber to a Number, the high
precision of the BigNumber will be lost. When a BigNumber is too large to be represented
as Number, it will be initialized as Infinity.

Complex numbers #

Complex numbers can be created using the imaginary unit i, which is defined
as i^2 = -1. Complex numbers have a real and complex part, which can be
retrieved using the functions re and im.

const parser = math.parser()

// create complex numbers
parser.evaluate('a = 2 + 3i')   // Complex, 2 + 3i
parser.evaluate('b = 4 - i')    // Complex, 4 - i

// get real and imaginary part of a complex number
parser.evaluate('re(a)')        // Number,  2
parser.evaluate('im(a)')        // Number,  3

// calculations with complex numbers
parser.evaluate('a + b')        // Complex, 6 + 2i
parser.evaluate('a * b')        // Complex, 11 + 10i
parser.evaluate('i * i')        // Number,  -1
parser.evaluate('sqrt(-4)')     // Complex, 2i


Units #

math.js supports units. Units can be used in the arithmetic operations
add, subtract, multiply, divide, and exponentiation.
Units can also be converted from one to another.
An overview of all available units can be found on the page
Units.

Units can be converted using the operator to or in.

// create a unit
math.evaluate('5.4 kg')                     // Unit, 5.4 kg

// convert a unit
math.evaluate('2 inch to cm')               // Unit, 5.08 cm
math.evaluate('20 celsius in fahrenheit')   // Unit, ~68 fahrenheit
math.evaluate('90 km/h to m/s')             // Unit, 25 m / s

// convert a unit to a number
// A second parameter with the unit for the exported number must be provided
math.evaluate('number(5 cm, mm)')           // Number, 50

// calculations with units
math.evaluate('0.5kg + 33g')                // Unit, 0.533 kg
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('12 seconds * 2')             // Unit, 24 seconds
math.evaluate('sin(45 deg)')                // Number, 0.7071067811865475
math.evaluate('9.81 m/s^2 * 5 s to mi/h')   // Unit, 109.72172512527 mi / h


Strings #

Strings are enclosed by double quotes “ or single quotes ‘. Strings can be concatenated using the
function concat (not by adding them using + like in JavaScript). Parts of
a string can be retrieved or replaced by using indexes. Strings can be converted
to a number using function number, and numbers can be converted to a string
using function string.

When setting the value of a character in a string, the character that has been
set is returned. Likewise, when a range of characters is set, that range of
characters is returned.

const parser = math.parser()

// create a string
parser.evaluate('"hello"')                        // String, "hello"

// string manipulation
parser.evaluate('a = concat("hello", " world")')  // String, "hello world"
parser.evaluate('size(a)')                        // Matrix [11]
parser.evaluate('a[1:5]')                         // String, "hello"
parser.evaluate('a[1] = "H"')                     // String, "H"
parser.evaluate('a[7:12] = "there!"')             // String, "there!"
parser.evaluate('a')                              // String, "Hello there!"

// string conversion
parser.evaluate('number("300")')                  // Number, 300
parser.evaluate('string(300)')                    // String, "300"


Strings can be used in the evaluate function, to parse expressions inside
the expression parser:

math.evaluate('evaluate("2 + 3")')  // 5


Matrices #

Matrices can be created by entering a series of values between square brackets,
elements are separated by a comma ,.
A matrix like [1, 2, 3] will create a vector, a 1-dimensional matrix with
size [3]. To create a multi-dimensional matrix, matrices can be nested into
each other. For easier creation of two-dimensional matrices, a semicolon ;
can be used to separate rows in a matrix.

// create a matrix
math.evaluate('[1, 2, 3]')                                // Matrix, size [3]
math.evaluate('[[1, 2, 3], [4, 5, 6]]')                   // Matrix, size [2, 3]
math.evaluate('[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]')     // Matrix, size [2, 2, 2]

// create a two dimensional matrix
math.evaluate('[1, 2, 3; 4, 5, 6]')                       // Matrix, size [2, 3]


Another way to create filled matrices is using the functions zeros, ones,
identity, and range.

// initialize a matrix with ones or zeros
math.evaluate('zeros(3, 2)')      // Matrix, [[0, 0], [0, 0], [0, 0]],  size [3, 2]
math.evaluate('ones(3)')          // Matrix, [1, 1, 1],                 size [3]
math.evaluate('5 * ones(2, 2)')   // Matrix, [[5, 5], [5, 5]],          size [2, 2]

// create an identity matrix
math.evaluate('identity(2)')      // Matrix, [[1, 0], [0, 1]],          size [2, 2]

// create a range
math.evaluate('1:4')              // Matrix, [1, 2, 3, 4],              size [4]
math.evaluate('0:2:10')           // Matrix, [0, 2, 4, 6, 8, 10],       size [6]


A subset can be retrieved from a matrix using indexes and a subset of a matrix
can be replaced by using indexes. Indexes are enclosed in square brackets, and
contain a number or a range for each of the matrix dimensions. A range can have
its start and/or end undefined. When the start is undefined, the range will start
at 1, when the end is undefined, the range will end at the end of the matrix.

There is a context variable end available as well to denote the end of the
matrix. This variable cannot be used in multiple nested indices. In that case,
end will be resolved as the end of the innermost matrix. To solve this, 
resolving of the nested index needs to be split in two separate operations.

IMPORTANT: matrix indexes and ranges work differently from the math.js indexes
in JavaScript: They are one-based with an included upper-bound, similar to most
math applications.

parser = math.parser()

// create matrices
parser.evaluate('a = [1, 2; 3, 4]')       // Matrix, [[1, 2], [3, 4]]
parser.evaluate('b = zeros(2, 2)')        // Matrix, [[0, 0], [0, 0]]
parser.evaluate('c = 5:9')                // Matrix, [5, 6, 7, 8, 9]

// replace a subset in a matrix
parser.evaluate('b[1, 1:2] = [5, 6]')     // Matrix, [[5, 6], [0, 0]]
parser.evaluate('b[2, :] = [7, 8]')       // Matrix, [[5, 6], [7, 8]]

// perform a matrix calculation
parser.evaluate('d = a * b')              // Matrix, [[19, 22], [43, 50]]

// retrieve a subset of a matrix
parser.evaluate('d[2, 1]')                // 43
parser.evaluate('d[2, 1:end]')            // Matrix, [[43, 50]]
parser.evaluate('c[end - 1 : -1 : 2]')    // Matrix, [8, 7, 6]


Objects #

Objects in math.js work the same as in languages like JavaScript and Python.
An object is enclosed by curly brackets {, }, and contains a set of
comma separated key/value pairs. Keys and values are separated by a colon :.
Keys can be a symbol like prop or a string like "prop".

math.evaluate('{a: 2 + 1, b: 4}')         // {a: 3, b: 4}
math.evaluate('{"a": 2 + 1, "b": 4}')     // {a: 3, b: 4}


Objects can contain objects:

math.evaluate('{a: 2, b: {c: 3, d: 4}}')  // {a: 2, b: {c: 3, d: 4}}


Object properties can be retrieved or replaced using dot notation or bracket
notation. Unlike JavaScript, when setting a property value, the whole object
is returned, not the property value

let scope = {
  obj: {
    prop: 42
  }
}

// retrieve properties
math.evaluate('obj.prop', scope)          // 42
math.evaluate('obj["prop"]', scope)       // 42

// set properties (returns the whole object, not the property value!)
math.evaluate('obj.prop = 43', scope)     // {prop: 43}
math.evaluate('obj["prop"] = 43', scope)  // {prop: 43}
scope.obj                                 // {prop: 43}


Multi-line expressions #

An expression can contain multiple lines, and expressions can be spread over
multiple lines. Lines can be separated by a newline character \n or by a
semicolon ;. Output of statements followed by a semicolon will be hidden from
the output, and empty lines are ignored. The output is returned as a ResultSet,
with an entry for every visible statement.

// a multi-line expression
math.evaluate('1 * 3 \n 2 * 3 \n 3 * 3')    // ResultSet, [3, 6, 9]

// semicolon statements are hidden from the output
math.evaluate('a=3; b=4; a + b \n a * b')   // ResultSet, [7, 12]

// single expression spread over multiple lines
math.evaluate('a = 2 +\n  3')               // 5
math.evaluate('[\n  1, 2;\n  3, 4\n]')      // Matrix, [[1, 2], [3, 4]]


The results can be read from a ResultSet via the property ResultSet.entries
which is an Array, or by calling ResultSet.valueOf(), which returns the
array with results.

Implicit multiplication #

Implicit multiplication means the multiplication of two symbols, numbers, or a grouped expression inside parentheses without using the * operator. This type of syntax allows a more natural way to enter expressions. For example:

math.evaluate('2 pi')         // 6.283185307179586
math.evaluate('(1+2)(3+4)')   // 21


Parentheses are parsed as a function call when there is a symbol or accessor on
the left hand side, like sqrt(4) or obj.method(4). In other cases the
parentheses are interpreted as an implicit multiplication.

Math.js will always evaluate implicit multiplication before explicit multiplication *, so that the expression x * y z is parsed as x * (y * z). Math.js also gives implicit multiplication higher precedence than division, except when the division matches the pattern [unaryPrefixOp]?[number] / [number] [symbol] or [unaryPrefixOp]?[number] / [number] [left paren]. In that special case, the division is evaluated first:

math.evaluate('20 kg / 4 kg')   // 5      Evaluated as (20 kg) / (4 kg)
math.evaluate('20 / 4 kg')      // 5 kg   Evaluated as (20 / 4) kg


The behavior of implicit multiplication can be summarized by these operator precedence rules, listed from highest to lowest precedence:


  Function calls: [symbol] [left paren]
  Explicit division / when the division matches this pattern: [+-~]?[number] / [+-~]?[number] [symbol] or [number] / [number] [left paren]
  Implicit multiplication
  All other division / and multiplication *


Implicit multiplication is tricky as there can appear to be ambiguity in how an expression will be evaluated. Experience has shown that the above rules most closely match user intent when entering expressions that could be interpreted different ways. It’s also possible that these rules could be tweaked in future major releases.  Use implicit multiplication carefully. If you don’t like the uncertainty introduced by implicit multiplication, use explicit * operators and parentheses to ensure your expression is evaluated the way you intend.

Here are some more examples using implicit multiplication:


  
    
      Expression
      Evaluated as
      Result
    
  
  
    
      (1 + 3) pi
      (1 + 3) * pi
      12.566370614359172
    
    
      (4 - 1) 2
      (4 - 1) * 2
      6
    
    
      3 / 4 mm
      (3 / 4) * mm
      0.75 mm
    
    
      2 + 3 i
      2 + (3 * i)
      2 + 3i
    
    
      (1 + 2) (4 - 2)
      (1 + 2) * (4 - 2)
      6
    
    
      sqrt(4) (1 + 2)
      sqrt(4) * (1 + 2)
      6
    
    
      8 pi / 2 pi
      (8 * pi) / (2 * pi)
      4
    
    
      pi / 2 pi
      pi / (2 * pi)
      0.5
    
    
      1 / 2i
      (1 / 2) * i
      0.5 i
    
    
      8.314 J / mol K
      8.314 J / (mol * K)
      8.314 J / (mol * K)
    
  


Comments #

Comments can be added to explain or describe calculations in the text. A comment
starts with a sharp sign character #, and ends at the end of the line. A line
can contain a comment only, or can contain an expression followed by a comment.

const parser = math.parser()

parser.evaluate('# define some variables')
parser.evaluate('width = 3')                              // 3
parser.evaluate('height = 4')                             // 4
parser.evaluate('width * height   # calculate the area')  // 12\n\n\n\nExpression syntax #

This page describes the syntax of expression parser of math.js. It describes
how to work with the available data types, functions, operators, variables,
and more.

Differences from JavaScript #

The expression parser of math.js is aimed at a mathematical audience,
not a programming audience. The syntax is similar to most calculators and
mathematical applications. This is close to JavaScript as well, though there
are a few important differences between the syntax of the expression parser and
the lower level syntax of math.js. Differences are:


  No need to prefix functions and constants with the math.* namespace,
you can just enter sin(pi / 4).
  Matrix indexes are one-based instead of zero-based.
  There are index and range operators which allow more conveniently getting
and setting matrix indexes, like A[2:4, 1].
  Both indexes and ranges and have the upper-bound included.
  There is a differing syntax for defining functions. Example: f(x) = x^2.
  There are custom operators like x + y instead of add(x, y).
  Some operators are different. For example  ^ is used for exponentiation,
not bitwise xor.
  Implicit multiplication, like 2 pi, is supported and has special rules.
  Relational operators (<, >, <=, >=, ==, and !=) are chained, so the expression 5 < x < 10 is equivalent to 5 < x and x < 10.
  Multi-expression constructs like a = 1; b = 2; a + b or
"a = 1;\n cos(a)\n sin(a)" (where \n denotes newline)
produce a collection (“ResultSet”) of values. Those expressions
terminated by ; are evaluated for side effect only and their values
are suppressed from the result.


Operators #

The expression parser has operators for all common arithmetic operations such
as addition and multiplication. The expression parser uses conventional infix
notation for operators: an operator is placed between its arguments.
Round parentheses can be used to override the default precedence of operators.

// use operators
math.evaluate('2 + 3')       // 5
math.evaluate('2 * 3')       // 6

// use parentheses to override the default precedence
math.evaluate('2 + 3 * 4')   // 14
math.evaluate('(2 + 3) * 4') // 20


The following operators are available. Note that almost every operator listed
also has a function form with identical meaning that can be used
interchangeably. For example, x+y will always evaluate identically to
add(x,y). For a full list of the equivalences, see the section on
Functions below.


  
    
      Operator
      Name
      Syntax
      Associativity
      Example
      Result
    
  
  
    
      (, )
      Grouping
      (x)
      None
      2 * (3 + 4)
      14
    
    
      [, ]
      Matrix, Index
      [...]
      None
      [[1,2],[3,4]]
      [[1,2],[3,4]]
    
    
      {, }
      Object
      {...}
      None
      {a: 1, b: 2}
      {a: 1, b: 2}
    
    
      ,
      Parameter separator
      x, y
      Left to right
      max(2, 1, 5)
      5
    
    
      .
      Property accessor
      obj.prop
      Left to right
      obj={a: 12}; obj.a
      12
    
    
      ;
      Statement separator
      x; y
      Left to right
      a=2; b=3; a*b
      [6]
    
    
      ;
      Row separator
      [x; y]
      Left to right
      [1,2;3,4]
      [[1,2],[3,4]]
    
    
      \n
      Statement separator
      x \n y
      Left to right
      a=2 \n b=3 \n a*b
      [2,3,6]
    
    
      +
      Add
      x + y
      Left to right
      4 + 5
      9
    
    
      +
      Unary plus
      +y
      Right to left
      +4
      4
    
    
      -
      Subtract
      x - y
      Left to right
      7 - 3
      4
    
    
      -
      Unary minus
      -y
      Right to left
      -4
      -4
    
    
      *
      Multiply
      x * y
      Left to right
      2 * 3
      6
    
    
      .*
      Element-wise multiply
      x .* y
      Left to right
      [1,2,3] .* [1,2,3]
      [1,4,9]
    
    
      /
      Divide
      x / y
      Left to right
      6 / 2
      3
    
    
      ./
      Element-wise divide
      x ./ y
      Left to right
      [9,6,4] ./ [3,2,2]
      [3,3,2]
    
    
      %
      Percentage
      x%
      None
      8%
      0.08
    
    
      %
      Addition with Percentage
      x + y%
      Left to right
      100 + 3%
      103
    
    
      %
      Subtraction with Percentage
      x - y%
      Left to right
      100 - 3%
      97
    
    
      % mod
      Modulus
      x % y
      Left to right
      8 % 3
      2
    
    
      ^
      Power
      x ^ y
      Right to left
      2 ^ 3
      8
    
    
      .^
      Element-wise power
      x .^ y
      Right to left
      [2,3] .^ [3,3]
      [8,27]
    
    
      '
      Transpose
      y'
      Left to right
      [[1,2],[3,4]]'
      [[1,3],[2,4]]
    
    
      !
      Factorial
      y!
      Left to right
      5!
      120
    
    
      &
      Bitwise and
      x & y
      Left to right
      5 & 3
      1
    
    
      ~
      Bitwise not
      ~x
      Right to left
      ~2
      -3
    
    
      |
      Bitwise or
      x | y
      Left to right
      5 | 3
      7
    
    
      ^|
      Bitwise xor
      x ^| y
      Left to right
      5 ^| 2
      7
    
    
      <<
      Left shift
      x << y
      Left to right
      4 << 1
      8
    
    
      >>
      Right arithmetic shift
      x >> y
      Left to right
      8 >> 1
      4
    
    
      >>>
      Right logical shift
      x >>> y
      Left to right
      -8 >>> 1
      2147483644
    
    
      and
      Logical and
      x and y
      Left to right
      true and false
      false
    
    
      not
      Logical not
      not y
      Right to left
      not true
      false
    
    
      or
      Logical or
      x or y
      Left to right
      true or false
      true
    
    
      xor
      Logical xor
      x xor y
      Left to right
      true xor true
      false
    
    
      =
      Assignment
      x = y
      Right to left
      a = 5
      5
    
    
      ? :
      Conditional expression
      x ? y : z
      Right to left
      15 > 100 ? 1 : -1
      -1
    
    
      :
      Range
      x : y
      Right to left
      1:4
      [1,2,3,4]
    
    
      to, in
      Unit conversion
      x to y
      Left to right
      2 inch to cm
      5.08 cm
    
    
      ==
      Equal
      x == y
      Left to right
      2 == 4 - 2
      true
    
    
      !=
      Unequal
      x != y
      Left to right
      2 != 3
      true
    
    
      <
      Smaller
      x < y
      Left to right
      2 < 3
      true
    
    
      >
      Larger
      x > y
      Left to right
      2 > 3
      false
    
    
      <=
      Smallereq
      x <= y
      Left to right
      4 <= 3
      false
    
    
      >=
      Largereq
      x >= y
      Left to right
      2 + 4 >= 6
      true
    
  


Precedence #

The operators have the following precedence, from highest to lowest:


  
    
      Operators
      Description
    
  
  
    
      (...)[...]{...}
      GroupingMatrixObject
    
    
      x(...)x[...]obj.prop:
      Function callMatrix indexProperty accessorKey/value separator
    
    
      '
      Matrix transpose
    
    
      !
      Factorial
    
    
      ^, .^
      Exponentiation
    
    
      +, -, ~, not
      Unary plus, unary minus, bitwise not, logical not
    
    
      See section below
      Implicit multiplication
    
    
      *, /, .*, ./,%, mod
      Multiply, divide , percentage, modulus
    
    
      +, -
      Add, subtract
    
    
      :
      Range
    
    
      to, in
      Unit conversion
    
    
      <<, >>, >>>
      Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift
    
    
      ==, !=, <, >, <=, >=
      Relational
    
    
      &
      Bitwise and (lazily evaluated)
    
    
      ^|
      Bitwise xor
    
    
      |
      Bitwise or (lazily evaluated)
    
    
      and
      Logical and (lazily evaluated)
    
    
      xor
      Logical xor
    
    
      or
      Logical or (lazily evaluated)
    
    
      ?, :
      Conditional expression
    
    
      =
      Assignment
    
    
      ,
      Parameter and column separator
    
    
      ;
      Row separator
    
    
      \n, ;
      Statement separators
    
  


Lazy evaluation is used where logically possible for bitwise and logical
operators. In the following example, the value of x will not even be 
evaluated because it cannot effect the final result:
math.evaluate('false and x')        // false, no matter what x equals


Functions #

Functions are called by entering their name, followed by zero or more
arguments enclosed by parentheses. All available functions are listed on the
page Functions.

math.evaluate('sqrt(25)')           // 5
math.evaluate('log(10000, 3 + 7)')  // 4
math.evaluate('sin(pi / 4)')        // 0.7071067811865475


New functions can be defined by “assigning” an expression to a function call
with one or more variables. Such function assignments are limited: they can
only be defined on a single line.

const parser = math.parser()

parser.evaluate('f(x) = x ^ 2 - 5')
parser.evaluate('f(2)')     // -1
parser.evaluate('f(3)')     // 4

parser.evaluate('g(x, y) = x ^ y')
parser.evaluate('g(2, 3)')  // 8


Note that these function assignments do not create closures; put another way,
all free variables in mathjs are dynamic:

const parser = math.parser()

parser.evaluate('x = 7')
parser.evaluate('h(y) = x + y')
parser.evaluate('h(3)')         // 10
parser.evaluate('x = 3')
parser.evaluate('h(3)')         // 6, *not* 10


It is however possible to pass functions as parameters:

const parser = math.parser()

parser.evaluate('twice(func, x) = func(func(x))')
parser.evaluate('twice(square, 2)')    // 16
parser.evaluate('f(x) = 3*x')
parser.evaluate('twice(f, 2)')         // 18

// a simplistic "numerical derivative":
parser.evaluate('eps = 1e-10')
parser.evaluate('nd(f, x) = (f(x+eps) - func(x-eps))/(2*eps)')
parser.evaluate('nd(square,2)')        // 4.000000330961484


Math.js itself heavily uses typed functions, which ensure correct inputs and
throws meaningful errors when the input arguments are invalid. One can create
a typed-function in the
expression parser like:

const parser = math.parser()

parser.evaluate('f = typed({"number": f(x) = x ^ 2 - 5})')


Finally, as mentioned above, there is a function form for nearly every one of
the mathematical operator symbols. Moreover, for some associative operators,
the corresponding function allows arbitrarily many arguments. The table below
gives the full correspondence.


  
    
      Operator Expression
      Equivalent Function Expression
    
  
  
    
      a or b
      or(a,b)
    
    
      a xor b
      xor(a,b)
    
    
      a and b
      and(a,b)
    
    
      a \| b
      bitOr(a,b)
    
    
      a ^\| b
      bitXor(a,b)
    
    
      a & b
      bitAnd(a,b)
    
    
      a == b
      equal(a,b)
    
    
      a != b
      unequal(a,b)
    
    
      a < b
      smaller(a,b)
    
    
      a > b
      larger(a,b)
    
    
      a <= b
      smallerEq(a,b)
    
    
      a << 3
      leftShift(a,3)
    
    
      a >> 3
      rightArithShift(a,3)
    
    
      a >>> 3
      rightLogShift(a,3)
    
    
      u to cm
      to(u, cm)
    
    
      a + b + c + ...
      add(a,b,c,...)
    
    
      a - b
      subtract(a,b)
    
    
      a * b * c * ...
      multiply(a,b,c,...)
    
    
      A .* B
      dotMultiply(A,B)
    
    
      A ./ B
      dotDivide(A,B)
    
    
      a mod b
      mod(a,b)
    
    
      +a
      unaryPlus(a)
    
    
      -a
      unaryMinus(a)
    
    
      ~a
      bitNot(a)
    
    
      not a
      not(a)
    
    
      a^b
      pow(a,b)
    
    
      A .^ B
      dotPow(A,B)
    
    
      a!
      factorial(a)
    
    
      A'
      ctranspose(A)
    
  


Note that math.js embodies a preference for the operator forms, in that calling
simplify (see Algebra) converts any instances of the function
form into the corresponding operator.

Map and forEach #

The map and forEach functions can be used to apply a callback function to each element of an array or matrix.

The callback functions can be functions, typed functions, inline functions (only in the parser) or compiled inline functions (only in the parser).

The callback can have the following inputs:

  value: the current value in the array or matrix.
  index: the index of the current value expressed as an array of numbers.
  array: the array or matrix being iterated.


Below is the syntax for both functions:

map #

The map function applies a function to each element of an array and returns a new array with the results.

const parser = math.parser()

// Define a square function
parser.evaluate('square(x) = x ^ 2')

// Apply the square function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], square)')
// result: [1, 4, 9, 16]

// Apply an inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], f(x) = x ^ 2)')
// result: [1, 4, 9, 16]

// Apply a compiled inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], x ^ 2)')
// result: [1, 4, 9, 16]


forEach #
The forEach function applies a function to each element of an array or matrix but does not return a new array. It is useful for executing side effects.

// Define a function that prints each element
math.import({consoleLog: x => console.log(x)})
const parser = math.parser()

// Define a squareConsleLog function
parser.evaluate('squareConsoleLog(x) = consoleLog(x ^ 2)')

// Apply the squareConsleLog function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], squareConsleLog)')
// Prints: 1, 4, 9, 16

// Apply an inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], f(x) = consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16

// Apply a compiled inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16


These functions are useful for performing element-wise operations on arrays or matrices.

Constants and variables #

Math.js has a number of built-in constants such as pi and e.
All available constants are listed on he page
Constants.

// use constants
math.evaluate('pi')                 // 3.141592653589793
math.evaluate('e ^ 2')              // 7.3890560989306495
math.evaluate('log(e)')             // 1
math.evaluate('e ^ (pi * i) + 1')   // ~0 (Euler)


Variables can be defined using the assignment operator =, and can be used
like constants.

const parser = math.parser()

// define variables
parser.evaluate('a = 3.4')      // 3.4
parser.evaluate('b = 5 / 2')    // 2.5

// use variables
parser.evaluate('a * b')        // 8.5


Variable names must:


  Begin with an “alpha character”, which is:
    
      A latin letter (upper or lower case). Ascii: a-z, A-Z
      An underscore.                        Ascii: _
      A dollar sign.                        Ascii: $
      A latin letter with accents.          Unicode: \u00C0 - \u02AF
      A greek letter.                       Unicode: \u0370 - \u03FF
      A letter-like character.              Unicode: \u2100 - \u214F
      A mathematical alphanumeric symbol.   Unicode: \u{1D400} - \u{1D7FF} excluding invalid code points
    
  
  Contain only alpha characters (above) and digits 0-9
  Not be any of the following: mod, to, in, and, xor, or, not, end. It is possible to assign to some of these, but that’s not recommended.


It is possible to customize the allowed alpha characters, see Customize supported characters for more information.

Data types #

The expression parser supports booleans, numbers, complex numbers, units,
strings, matrices, and objects.

Booleans #

Booleans true and false can be used in expressions.

// use booleans
math.evaluate('true')               // true
math.evaluate('false')              // false
math.evaluate('(2 == 3) == false')  // true


Booleans can be converted to numbers and strings and vice versa using the
functions number and boolean, and string.

// convert booleans
math.evaluate('number(true)')       // 1
math.evaluate('string(false)')      // "false"
math.evaluate('boolean(1)')         // true
math.evaluate('boolean("false")')   // false


Numbers #

The most important and basic data type in math.js are numbers. Numbers use a
point as decimal mark. Numbers can be entered with exponential notation.
Examples:

// numbers in math.js
math.evaluate('2')        // 2
math.evaluate('3.14')     // 3.14
math.evaluate('1.4e3')    // 1400
math.evaluate('22e-3')    // 0.022


A number can be converted to a string and vice versa using the functions
number and string.

// convert a string into a number
math.evaluate('number("2.3")')    // 2.3
math.evaluate('string(2.3)')      // "2.3"


Math.js uses regular JavaScript numbers, which are floating points with a
limited precision and limited range. The limitations are described in detail
on the page Numbers.

math.evaluate('1e-325')   // 0
math.evaluate('1e309')    // Infinity
math.evaluate('-1e309')   // -Infinity


When doing calculations with floats, one can very easily get round-off errors:

// round-off error due to limited floating point precision
math.evaluate('0.1 + 0.2')  // 0.30000000000000004


When outputting results, the function math.format can be used to hide
these round-off errors when outputting results for the user:

const ans = math.evaluate('0.1 + 0.2')  //  0.30000000000000004
math.format(ans, {precision: 14})       // "0.3"


Numbers can be expressed as binary, octal, and hexadecimal literals:

math.evaluate('0b11')  //  3
math.evaluate('0o77')  //  63
math.evaluate('0xff')  //  255


A word size suffix can be used to change the behavior of non decimal literal evaluation:

math.evaluate('0xffi8')         // -1
math.evaluate('0xffffffffi32')  //  -1
math.evaluate('0xfffffffffi32') //  SyntaxError: String "0xfffffffff" is out of range


Non decimal numbers can include a radix point:
math.evaluate('0b1.1')         // 1.5
math.evaluate('0o1.4')         // 1.5
math.evaluate('0x1.8')         // 1.5


Numbers can be formatted as binary, octal, and hex strings using the notation option of the format function:

math.evaluate('format(3, {notation: "bin"})')    //  '0b11'
math.evaluate('format(63, {notation: "oct"})')   //  '0o77'
math.evaluate('format(255, {notation: "hex"})')  //  '0xff'
math.evaluate('format(-1, {notation: "hex"})')   //  '-0x1'
math.evaluate('format(2.3, {notation: "hex"})')  //  '0x2.4cccccccccccc'


The format function accepts a wordSize option to use in conjunction with the non binary notations:

math.evaluate('format(-1, {notation: "hex", wordSize: 8})')   //  '0xffi8'


The functions bin, oct, and hex are shorthand for the format function with notation set accordingly:

math.evaluate('bin(-1)')     // '-0b1'
math.evaluate('bin(-1, 8)')  // '0b11111111i8'


BigNumbers #

Math.js supports BigNumbers for calculations with an arbitrary precision.
The pros and cons of Number and BigNumber are explained in detail on the page
Numbers.

BigNumbers are slower but have a higher precision. Calculations with big
numbers are supported only by arithmetic functions.

BigNumbers can be created using the bignumber function:

math.evaluate('bignumber(0.1) + bignumber(0.2)') // BigNumber, 0.3


The default number type of the expression parser can be changed at instantiation
of math.js. The expression parser parses numbers as BigNumber by default:

// Configure the type of number: 'number' (default), 'BigNumber', or 'Fraction'
math.config({number: 'BigNumber'})

// all numbers are parsed as BigNumber
math.evaluate('0.1 + 0.2')  // BigNumber, 0.3


BigNumbers can be converted to numbers and vice versa using the functions
number and bignumber. When converting a BigNumber to a Number, the high
precision of the BigNumber will be lost. When a BigNumber is too large to be represented
as Number, it will be initialized as Infinity.

Complex numbers #

Complex numbers can be created using the imaginary unit i, which is defined
as i^2 = -1. Complex numbers have a real and complex part, which can be
retrieved using the functions re and im.

const parser = math.parser()

// create complex numbers
parser.evaluate('a = 2 + 3i')   // Complex, 2 + 3i
parser.evaluate('b = 4 - i')    // Complex, 4 - i

// get real and imaginary part of a complex number
parser.evaluate('re(a)')        // Number,  2
parser.evaluate('im(a)')        // Number,  3

// calculations with complex numbers
parser.evaluate('a + b')        // Complex, 6 + 2i
parser.evaluate('a * b')        // Complex, 11 + 10i
parser.evaluate('i * i')        // Number,  -1
parser.evaluate('sqrt(-4)')     // Complex, 2i


Units #

math.js supports units. Units can be used in the arithmetic operations
add, subtract, multiply, divide, and exponentiation.
Units can also be converted from one to another.
An overview of all available units can be found on the page
Units.

Units can be converted using the operator to or in.

// create a unit
math.evaluate('5.4 kg')                     // Unit, 5.4 kg

// convert a unit
math.evaluate('2 inch to cm')               // Unit, 5.08 cm
math.evaluate('20 celsius in fahrenheit')   // Unit, ~68 fahrenheit
math.evaluate('90 km/h to m/s')             // Unit, 25 m / s

// convert a unit to a number
// A second parameter with the unit for the exported number must be provided
math.evaluate('number(5 cm, mm)')           // Number, 50

// calculations with units
math.evaluate('0.5kg + 33g')                // Unit, 0.533 kg
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('12 seconds * 2')             // Unit, 24 seconds
math.evaluate('sin(45 deg)')                // Number, 0.7071067811865475
math.evaluate('9.81 m/s^2 * 5 s to mi/h')   // Unit, 109.72172512527 mi / h


Strings #

Strings are enclosed by double quotes “ or single quotes ‘. Strings can be concatenated using the
function concat (not by adding them using + like in JavaScript). Parts of
a string can be retrieved or replaced by using indexes. Strings can be converted
to a number using function number, and numbers can be converted to a string
using function string.

When setting the value of a character in a string, the character that has been
set is returned. Likewise, when a range of characters is set, that range of
characters is returned.

const parser = math.parser()

// create a string
parser.evaluate('"hello"')                        // String, "hello"

// string manipulation
parser.evaluate('a = concat("hello", " world")')  // String, "hello world"
parser.evaluate('size(a)')                        // Matrix [11]
parser.evaluate('a[1:5]')                         // String, "hello"
parser.evaluate('a[1] = "H"')                     // String, "H"
parser.evaluate('a[7:12] = "there!"')             // String, "there!"
parser.evaluate('a')                              // String, "Hello there!"

// string conversion
parser.evaluate('number("300")')                  // Number, 300
parser.evaluate('string(300)')                    // String, "300"


Strings can be used in the evaluate function, to parse expressions inside
the expression parser:

math.evaluate('evaluate("2 + 3")')  // 5


Matrices #

Matrices can be created by entering a series of values between square brackets,
elements are separated by a comma ,.
A matrix like [1, 2, 3] will create a vector, a 1-dimensional matrix with
size [3]. To create a multi-dimensional matrix, matrices can be nested into
each other. For easier creation of two-dimensional matrices, a semicolon ;
can be used to separate rows in a matrix.

// create a matrix
math.evaluate('[1, 2, 3]')                                // Matrix, size [3]
math.evaluate('[[1, 2, 3], [4, 5, 6]]')                   // Matrix, size [2, 3]
math.evaluate('[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]')     // Matrix, size [2, 2, 2]

// create a two dimensional matrix
math.evaluate('[1, 2, 3; 4, 5, 6]')                       // Matrix, size [2, 3]


Another way to create filled matrices is using the functions zeros, ones,
identity, and range.

// initialize a matrix with ones or zeros
math.evaluate('zeros(3, 2)')      // Matrix, [[0, 0], [0, 0], [0, 0]],  size [3, 2]
math.evaluate('ones(3)')          // Matrix, [1, 1, 1],                 size [3]
math.evaluate('5 * ones(2, 2)')   // Matrix, [[5, 5], [5, 5]],          size [2, 2]

// create an identity matrix
math.evaluate('identity(2)')      // Matrix, [[1, 0], [0, 1]],          size [2, 2]

// create a range
math.evaluate('1:4')              // Matrix, [1, 2, 3, 4],              size [4]
math.evaluate('0:2:10')           // Matrix, [0, 2, 4, 6, 8, 10],       size [6]


A subset can be retrieved from a matrix using indexes and a subset of a matrix
can be replaced by using indexes. Indexes are enclosed in square brackets, and
contain a number or a range for each of the matrix dimensions. A range can have
its start and/or end undefined. When the start is undefined, the range will start
at 1, when the end is undefined, the range will end at the end of the matrix.

There is a context variable end available as well to denote the end of the
matrix. This variable cannot be used in multiple nested indices. In that case,
end will be resolved as the end of the innermost matrix. To solve this, 
resolving of the nested index needs to be split in two separate operations.

IMPORTANT: matrix indexes and ranges work differently from the math.js indexes
in JavaScript: They are one-based with an included upper-bound, similar to most
math applications.

parser = math.parser()

// create matrices
parser.evaluate('a = [1, 2; 3, 4]')       // Matrix, [[1, 2], [3, 4]]
parser.evaluate('b = zeros(2, 2)')        // Matrix, [[0, 0], [0, 0]]
parser.evaluate('c = 5:9')                // Matrix, [5, 6, 7, 8, 9]

// replace a subset in a matrix
parser.evaluate('b[1, 1:2] = [5, 6]')     // Matrix, [[5, 6], [0, 0]]
parser.evaluate('b[2, :] = [7, 8]')       // Matrix, [[5, 6], [7, 8]]

// perform a matrix calculation
parser.evaluate('d = a * b')              // Matrix, [[19, 22], [43, 50]]

// retrieve a subset of a matrix
parser.evaluate('d[2, 1]')                // 43
parser.evaluate('d[2, 1:end]')            // Matrix, [[43, 50]]
parser.evaluate('c[end - 1 : -1 : 2]')    // Matrix, [8, 7, 6]


Objects #

Objects in math.js work the same as in languages like JavaScript and Python.
An object is enclosed by curly brackets {, }, and contains a set of
comma separated key/value pairs. Keys and values are separated by a colon :.
Keys can be a symbol like prop or a string like "prop".

math.evaluate('{a: 2 + 1, b: 4}')         // {a: 3, b: 4}
math.evaluate('{"a": 2 + 1, "b": 4}')     // {a: 3, b: 4}


Objects can contain objects:

math.evaluate('{a: 2, b: {c: 3, d: 4}}')  // {a: 2, b: {c: 3, d: 4}}


Object properties can be retrieved or replaced using dot notation or bracket
notation. Unlike JavaScript, when setting a property value, the whole object
is returned, not the property value

let scope = {
  obj: {
    prop: 42
  }
}

// retrieve properties
math.evaluate('obj.prop', scope)          // 42
math.evaluate('obj["prop"]', scope)       // 42

// set properties (returns the whole object, not the property value!)
math.evaluate('obj.prop = 43', scope)     // {prop: 43}
math.evaluate('obj["prop"] = 43', scope)  // {prop: 43}
scope.obj                                 // {prop: 43}


Multi-line expressions #

An expression can contain multiple lines, and expressions can be spread over
multiple lines. Lines can be separated by a newline character \n or by a
semicolon ;. Output of statements followed by a semicolon will be hidden from
the output, and empty lines are ignored. The output is returned as a ResultSet,
with an entry for every visible statement.

// a multi-line expression
math.evaluate('1 * 3 \n 2 * 3 \n 3 * 3')    // ResultSet, [3, 6, 9]

// semicolon statements are hidden from the output
math.evaluate('a=3; b=4; a + b \n a * b')   // ResultSet, [7, 12]

// single expression spread over multiple lines
math.evaluate('a = 2 +\n  3')               // 5
math.evaluate('[\n  1, 2;\n  3, 4\n]')      // Matrix, [[1, 2], [3, 4]]


The results can be read from a ResultSet via the property ResultSet.entries
which is an Array, or by calling ResultSet.valueOf(), which returns the
array with results.

Implicit multiplication #

Implicit multiplication means the multiplication of two symbols, numbers, or a grouped expression inside parentheses without using the * operator. This type of syntax allows a more natural way to enter expressions. For example:

math.evaluate('2 pi')         // 6.283185307179586
math.evaluate('(1+2)(3+4)')   // 21


Parentheses are parsed as a function call when there is a symbol or accessor on
the left hand side, like sqrt(4) or obj.method(4). In other cases the
parentheses are interpreted as an implicit multiplication.

Math.js will always evaluate implicit multiplication before explicit multiplication *, so that the expression x * y z is parsed as x * (y * z). Math.js also gives implicit multiplication higher precedence than division, except when the division matches the pattern [unaryPrefixOp]?[number] / [number] [symbol] or [unaryPrefixOp]?[number] / [number] [left paren]. In that special case, the division is evaluated first:

math.evaluate('20 kg / 4 kg')   // 5      Evaluated as (20 kg) / (4 kg)
math.evaluate('20 / 4 kg')      // 5 kg   Evaluated as (20 / 4) kg


The behavior of implicit multiplication can be summarized by these operator precedence rules, listed from highest to lowest precedence:


  Function calls: [symbol] [left paren]
  Explicit division / when the division matches this pattern: [+-~]?[number] / [+-~]?[number] [symbol] or [number] / [number] [left paren]
  Implicit multiplication
  All other division / and multiplication *


Implicit multiplication is tricky as there can appear to be ambiguity in how an expression will be evaluated. Experience has shown that the above rules most closely match user intent when entering expressions that could be interpreted different ways. It’s also possible that these rules could be tweaked in future major releases.  Use implicit multiplication carefully. If you don’t like the uncertainty introduced by implicit multiplication, use explicit * operators and parentheses to ensure your expression is evaluated the way you intend.

Here are some more examples using implicit multiplication:


  
    
      Expression
      Evaluated as
      Result
    
  
  
    
      (1 + 3) pi
      (1 + 3) * pi
      12.566370614359172
    
    
      (4 - 1) 2
      (4 - 1) * 2
      6
    
    
      3 / 4 mm
      (3 / 4) * mm
      0.75 mm
    
    
      2 + 3 i
      2 + (3 * i)
      2 + 3i
    
    
      (1 + 2) (4 - 2)
      (1 + 2) * (4 - 2)
      6
    
    
      sqrt(4) (1 + 2)
      sqrt(4) * (1 + 2)
      6
    
    
      8 pi / 2 pi
      (8 * pi) / (2 * pi)
      4
    
    
      pi / 2 pi
      pi / (2 * pi)
      0.5
    
    
      1 / 2i
      (1 / 2) * i
      0.5 i
    
    
      8.314 J / mol K
      8.314 J / (mol * K)
      8.314 J / (mol * K)
    
  


Comments #

Comments can be added to explain or describe calculations in the text. A comment
starts with a sharp sign character #, and ends at the end of the line. A line
can contain a comment only, or can contain an expression followed by a comment.

const parser = math.parser()

parser.evaluate('# define some variables')
parser.evaluate('width = 3')                              // 3
parser.evaluate('height = 4')                             // 4
parser.evaluate('width * height   # calculate the area')  // 12\n\n\n\nExpression syntax #

This page describes the syntax of expression parser of math.js. It describes
how to work with the available data types, functions, operators, variables,
and more.

Differences from JavaScript #

The expression parser of math.js is aimed at a mathematical audience,
not a programming audience. The syntax is similar to most calculators and
mathematical applications. This is close to JavaScript as well, though there
are a few important differences between the syntax of the expression parser and
the lower level syntax of math.js. Differences are:


  No need to prefix functions and constants with the math.* namespace,
you can just enter sin(pi / 4).
  Matrix indexes are one-based instead of zero-based.
  There are index and range operators which allow more conveniently getting
and setting matrix indexes, like A[2:4, 1].
  Both indexes and ranges and have the upper-bound included.
  There is a differing syntax for defining functions. Example: f(x) = x^2.
  There are custom operators like x + y instead of add(x, y).
  Some operators are different. For example  ^ is used for exponentiation,
not bitwise xor.
  Implicit multiplication, like 2 pi, is supported and has special rules.
  Relational operators (<, >, <=, >=, ==, and !=) are chained, so the expression 5 < x < 10 is equivalent to 5 < x and x < 10.
  Multi-expression constructs like a = 1; b = 2; a + b or
"a = 1;\n cos(a)\n sin(a)" (where \n denotes newline)
produce a collection (“ResultSet”) of values. Those expressions
terminated by ; are evaluated for side effect only and their values
are suppressed from the result.


Operators #

The expression parser has operators for all common arithmetic operations such
as addition and multiplication. The expression parser uses conventional infix
notation for operators: an operator is placed between its arguments.
Round parentheses can be used to override the default precedence of operators.

// use operators
math.evaluate('2 + 3')       // 5
math.evaluate('2 * 3')       // 6

// use parentheses to override the default precedence
math.evaluate('2 + 3 * 4')   // 14
math.evaluate('(2 + 3) * 4') // 20


The following operators are available. Note that almost every operator listed
also has a function form with identical meaning that can be used
interchangeably. For example, x+y will always evaluate identically to
add(x,y). For a full list of the equivalences, see the section on
Functions below.


  
    
      Operator
      Name
      Syntax
      Associativity
      Example
      Result
    
  
  
    
      (, )
      Grouping
      (x)
      None
      2 * (3 + 4)
      14
    
    
      [, ]
      Matrix, Index
      [...]
      None
      [[1,2],[3,4]]
      [[1,2],[3,4]]
    
    
      {, }
      Object
      {...}
      None
      {a: 1, b: 2}
      {a: 1, b: 2}
    
    
      ,
      Parameter separator
      x, y
      Left to right
      max(2, 1, 5)
      5
    
    
      .
      Property accessor
      obj.prop
      Left to right
      obj={a: 12}; obj.a
      12
    
    
      ;
      Statement separator
      x; y
      Left to right
      a=2; b=3; a*b
      [6]
    
    
      ;
      Row separator
      [x; y]
      Left to right
      [1,2;3,4]
      [[1,2],[3,4]]
    
    
      \n
      Statement separator
      x \n y
      Left to right
      a=2 \n b=3 \n a*b
      [2,3,6]
    
    
      +
      Add
      x + y
      Left to right
      4 + 5
      9
    
    
      +
      Unary plus
      +y
      Right to left
      +4
      4
    
    
      -
      Subtract
      x - y
      Left to right
      7 - 3
      4
    
    
      -
      Unary minus
      -y
      Right to left
      -4
      -4
    
    
      *
      Multiply
      x * y
      Left to right
      2 * 3
      6
    
    
      .*
      Element-wise multiply
      x .* y
      Left to right
      [1,2,3] .* [1,2,3]
      [1,4,9]
    
    
      /
      Divide
      x / y
      Left to right
      6 / 2
      3
    
    
      ./
      Element-wise divide
      x ./ y
      Left to right
      [9,6,4] ./ [3,2,2]
      [3,3,2]
    
    
      %
      Percentage
      x%
      None
      8%
      0.08
    
    
      %
      Addition with Percentage
      x + y%
      Left to right
      100 + 3%
      103
    
    
      %
      Subtraction with Percentage
      x - y%
      Left to right
      100 - 3%
      97
    
    
      % mod
      Modulus
      x % y
      Left to right
      8 % 3
      2
    
    
      ^
      Power
      x ^ y
      Right to left
      2 ^ 3
      8
    
    
      .^
      Element-wise power
      x .^ y
      Right to left
      [2,3] .^ [3,3]
      [8,27]
    
    
      '
      Transpose
      y'
      Left to right
      [[1,2],[3,4]]'
      [[1,3],[2,4]]
    
    
      !
      Factorial
      y!
      Left to right
      5!
      120
    
    
      &
      Bitwise and
      x & y
      Left to right
      5 & 3
      1
    
    
      ~
      Bitwise not
      ~x
      Right to left
      ~2
      -3
    
    
      |
      Bitwise or
      x | y
      Left to right
      5 | 3
      7
    
    
      ^|
      Bitwise xor
      x ^| y
      Left to right
      5 ^| 2
      7
    
    
      <<
      Left shift
      x << y
      Left to right
      4 << 1
      8
    
    
      >>
      Right arithmetic shift
      x >> y
      Left to right
      8 >> 1
      4
    
    
      >>>
      Right logical shift
      x >>> y
      Left to right
      -8 >>> 1
      2147483644
    
    
      and
      Logical and
      x and y
      Left to right
      true and false
      false
    
    
      not
      Logical not
      not y
      Right to left
      not true
      false
    
    
      or
      Logical or
      x or y
      Left to right
      true or false
      true
    
    
      xor
      Logical xor
      x xor y
      Left to right
      true xor true
      false
    
    
      =
      Assignment
      x = y
      Right to left
      a = 5
      5
    
    
      ? :
      Conditional expression
      x ? y : z
      Right to left
      15 > 100 ? 1 : -1
      -1
    
    
      :
      Range
      x : y
      Right to left
      1:4
      [1,2,3,4]
    
    
      to, in
      Unit conversion
      x to y
      Left to right
      2 inch to cm
      5.08 cm
    
    
      ==
      Equal
      x == y
      Left to right
      2 == 4 - 2
      true
    
    
      !=
      Unequal
      x != y
      Left to right
      2 != 3
      true
    
    
      <
      Smaller
      x < y
      Left to right
      2 < 3
      true
    
    
      >
      Larger
      x > y
      Left to right
      2 > 3
      false
    
    
      <=
      Smallereq
      x <= y
      Left to right
      4 <= 3
      false
    
    
      >=
      Largereq
      x >= y
      Left to right
      2 + 4 >= 6
      true
    
  


Precedence #

The operators have the following precedence, from highest to lowest:


  
    
      Operators
      Description
    
  
  
    
      (...)[...]{...}
      GroupingMatrixObject
    
    
      x(...)x[...]obj.prop:
      Function callMatrix indexProperty accessorKey/value separator
    
    
      '
      Matrix transpose
    
    
      !
      Factorial
    
    
      ^, .^
      Exponentiation
    
    
      +, -, ~, not
      Unary plus, unary minus, bitwise not, logical not
    
    
      See section below
      Implicit multiplication
    
    
      *, /, .*, ./,%, mod
      Multiply, divide , percentage, modulus
    
    
      +, -
      Add, subtract
    
    
      :
      Range
    
    
      to, in
      Unit conversion
    
    
      <<, >>, >>>
      Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift
    
    
      ==, !=, <, >, <=, >=
      Relational
    
    
      &
      Bitwise and (lazily evaluated)
    
    
      ^|
      Bitwise xor
    
    
      |
      Bitwise or (lazily evaluated)
    
    
      and
      Logical and (lazily evaluated)
    
    
      xor
      Logical xor
    
    
      or
      Logical or (lazily evaluated)
    
    
      ?, :
      Conditional expression
    
    
      =
      Assignment
    
    
      ,
      Parameter and column separator
    
    
      ;
      Row separator
    
    
      \n, ;
      Statement separators
    
  


Lazy evaluation is used where logically possible for bitwise and logical
operators. In the following example, the value of x will not even be 
evaluated because it cannot effect the final result:
math.evaluate('false and x')        // false, no matter what x equals


Functions #

Functions are called by entering their name, followed by zero or more
arguments enclosed by parentheses. All available functions are listed on the
page Functions.

math.evaluate('sqrt(25)')           // 5
math.evaluate('log(10000, 3 + 7)')  // 4
math.evaluate('sin(pi / 4)')        // 0.7071067811865475


New functions can be defined by “assigning” an expression to a function call
with one or more variables. Such function assignments are limited: they can
only be defined on a single line.

const parser = math.parser()

parser.evaluate('f(x) = x ^ 2 - 5')
parser.evaluate('f(2)')     // -1
parser.evaluate('f(3)')     // 4

parser.evaluate('g(x, y) = x ^ y')
parser.evaluate('g(2, 3)')  // 8


Note that these function assignments do not create closures; put another way,
all free variables in mathjs are dynamic:

const parser = math.parser()

parser.evaluate('x = 7')
parser.evaluate('h(y) = x + y')
parser.evaluate('h(3)')         // 10
parser.evaluate('x = 3')
parser.evaluate('h(3)')         // 6, *not* 10


It is however possible to pass functions as parameters:

const parser = math.parser()

parser.evaluate('twice(func, x) = func(func(x))')
parser.evaluate('twice(square, 2)')    // 16
parser.evaluate('f(x) = 3*x')
parser.evaluate('twice(f, 2)')         // 18

// a simplistic "numerical derivative":
parser.evaluate('eps = 1e-10')
parser.evaluate('nd(f, x) = (f(x+eps) - func(x-eps))/(2*eps)')
parser.evaluate('nd(square,2)')        // 4.000000330961484


Math.js itself heavily uses typed functions, which ensure correct inputs and
throws meaningful errors when the input arguments are invalid. One can create
a typed-function in the
expression parser like:

const parser = math.parser()

parser.evaluate('f = typed({"number": f(x) = x ^ 2 - 5})')


Finally, as mentioned above, there is a function form for nearly every one of
the mathematical operator symbols. Moreover, for some associative operators,
the corresponding function allows arbitrarily many arguments. The table below
gives the full correspondence.


  
    
      Operator Expression
      Equivalent Function Expression
    
  
  
    
      a or b
      or(a,b)
    
    
      a xor b
      xor(a,b)
    
    
      a and b
      and(a,b)
    
    
      a \| b
      bitOr(a,b)
    
    
      a ^\| b
      bitXor(a,b)
    
    
      a & b
      bitAnd(a,b)
    
    
      a == b
      equal(a,b)
    
    
      a != b
      unequal(a,b)
    
    
      a < b
      smaller(a,b)
    
    
      a > b
      larger(a,b)
    
    
      a <= b
      smallerEq(a,b)
    
    
      a << 3
      leftShift(a,3)
    
    
      a >> 3
      rightArithShift(a,3)
    
    
      a >>> 3
      rightLogShift(a,3)
    
    
      u to cm
      to(u, cm)
    
    
      a + b + c + ...
      add(a,b,c,...)
    
    
      a - b
      subtract(a,b)
    
    
      a * b * c * ...
      multiply(a,b,c,...)
    
    
      A .* B
      dotMultiply(A,B)
    
    
      A ./ B
      dotDivide(A,B)
    
    
      a mod b
      mod(a,b)
    
    
      +a
      unaryPlus(a)
    
    
      -a
      unaryMinus(a)
    
    
      ~a
      bitNot(a)
    
    
      not a
      not(a)
    
    
      a^b
      pow(a,b)
    
    
      A .^ B
      dotPow(A,B)
    
    
      a!
      factorial(a)
    
    
      A'
      ctranspose(A)
    
  


Note that math.js embodies a preference for the operator forms, in that calling
simplify (see Algebra) converts any instances of the function
form into the corresponding operator.

Map and forEach #

The map and forEach functions can be used to apply a callback function to each element of an array or matrix.

The callback functions can be functions, typed functions, inline functions (only in the parser) or compiled inline functions (only in the parser).

The callback can have the following inputs:

  value: the current value in the array or matrix.
  index: the index of the current value expressed as an array of numbers.
  array: the array or matrix being iterated.


Below is the syntax for both functions:

map #

The map function applies a function to each element of an array and returns a new array with the results.

const parser = math.parser()

// Define a square function
parser.evaluate('square(x) = x ^ 2')

// Apply the square function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], square)')
// result: [1, 4, 9, 16]

// Apply an inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], f(x) = x ^ 2)')
// result: [1, 4, 9, 16]

// Apply a compiled inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], x ^ 2)')
// result: [1, 4, 9, 16]


forEach #
The forEach function applies a function to each element of an array or matrix but does not return a new array. It is useful for executing side effects.

// Define a function that prints each element
math.import({consoleLog: x => console.log(x)})
const parser = math.parser()

// Define a squareConsleLog function
parser.evaluate('squareConsoleLog(x) = consoleLog(x ^ 2)')

// Apply the squareConsleLog function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], squareConsleLog)')
// Prints: 1, 4, 9, 16

// Apply an inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], f(x) = consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16

// Apply a compiled inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16


These functions are useful for performing element-wise operations on arrays or matrices.

Constants and variables #

Math.js has a number of built-in constants such as pi and e.
All available constants are listed on he page
Constants.

// use constants
math.evaluate('pi')                 // 3.141592653589793
math.evaluate('e ^ 2')              // 7.3890560989306495
math.evaluate('log(e)')             // 1
math.evaluate('e ^ (pi * i) + 1')   // ~0 (Euler)


Variables can be defined using the assignment operator =, and can be used
like constants.

const parser = math.parser()

// define variables
parser.evaluate('a = 3.4')      // 3.4
parser.evaluate('b = 5 / 2')    // 2.5

// use variables
parser.evaluate('a * b')        // 8.5


Variable names must:


  Begin with an “alpha character”, which is:
    
      A latin letter (upper or lower case). Ascii: a-z, A-Z
      An underscore.                        Ascii: _
      A dollar sign.                        Ascii: $
      A latin letter with accents.          Unicode: \u00C0 - \u02AF
      A greek letter.                       Unicode: \u0370 - \u03FF
      A letter-like character.              Unicode: \u2100 - \u214F
      A mathematical alphanumeric symbol.   Unicode: \u{1D400} - \u{1D7FF} excluding invalid code points
    
  
  Contain only alpha characters (above) and digits 0-9
  Not be any of the following: mod, to, in, and, xor, or, not, end. It is possible to assign to some of these, but that’s not recommended.


It is possible to customize the allowed alpha characters, see Customize supported characters for more information.

Data types #

The expression parser supports booleans, numbers, complex numbers, units,
strings, matrices, and objects.

Booleans #

Booleans true and false can be used in expressions.

// use booleans
math.evaluate('true')               // true
math.evaluate('false')              // false
math.evaluate('(2 == 3) == false')  // true


Booleans can be converted to numbers and strings and vice versa using the
functions number and boolean, and string.

// convert booleans
math.evaluate('number(true)')       // 1
math.evaluate('string(false)')      // "false"
math.evaluate('boolean(1)')         // true
math.evaluate('boolean("false")')   // false


Numbers #

The most important and basic data type in math.js are numbers. Numbers use a
point as decimal mark. Numbers can be entered with exponential notation.
Examples:

// numbers in math.js
math.evaluate('2')        // 2
math.evaluate('3.14')     // 3.14
math.evaluate('1.4e3')    // 1400
math.evaluate('22e-3')    // 0.022


A number can be converted to a string and vice versa using the functions
number and string.

// convert a string into a number
math.evaluate('number("2.3")')    // 2.3
math.evaluate('string(2.3)')      // "2.3"


Math.js uses regular JavaScript numbers, which are floating points with a
limited precision and limited range. The limitations are described in detail
on the page Numbers.

math.evaluate('1e-325')   // 0
math.evaluate('1e309')    // Infinity
math.evaluate('-1e309')   // -Infinity


When doing calculations with floats, one can very easily get round-off errors:

// round-off error due to limited floating point precision
math.evaluate('0.1 + 0.2')  // 0.30000000000000004


When outputting results, the function math.format can be used to hide
these round-off errors when outputting results for the user:

const ans = math.evaluate('0.1 + 0.2')  //  0.30000000000000004
math.format(ans, {precision: 14})       // "0.3"


Numbers can be expressed as binary, octal, and hexadecimal literals:

math.evaluate('0b11')  //  3
math.evaluate('0o77')  //  63
math.evaluate('0xff')  //  255


A word size suffix can be used to change the behavior of non decimal literal evaluation:

math.evaluate('0xffi8')         // -1
math.evaluate('0xffffffffi32')  //  -1
math.evaluate('0xfffffffffi32') //  SyntaxError: String "0xfffffffff" is out of range


Non decimal numbers can include a radix point:
math.evaluate('0b1.1')         // 1.5
math.evaluate('0o1.4')         // 1.5
math.evaluate('0x1.8')         // 1.5


Numbers can be formatted as binary, octal, and hex strings using the notation option of the format function:

math.evaluate('format(3, {notation: "bin"})')    //  '0b11'
math.evaluate('format(63, {notation: "oct"})')   //  '0o77'
math.evaluate('format(255, {notation: "hex"})')  //  '0xff'
math.evaluate('format(-1, {notation: "hex"})')   //  '-0x1'
math.evaluate('format(2.3, {notation: "hex"})')  //  '0x2.4cccccccccccc'


The format function accepts a wordSize option to use in conjunction with the non binary notations:

math.evaluate('format(-1, {notation: "hex", wordSize: 8})')   //  '0xffi8'


The functions bin, oct, and hex are shorthand for the format function with notation set accordingly:

math.evaluate('bin(-1)')     // '-0b1'
math.evaluate('bin(-1, 8)')  // '0b11111111i8'


BigNumbers #

Math.js supports BigNumbers for calculations with an arbitrary precision.
The pros and cons of Number and BigNumber are explained in detail on the page
Numbers.

BigNumbers are slower but have a higher precision. Calculations with big
numbers are supported only by arithmetic functions.

BigNumbers can be created using the bignumber function:

math.evaluate('bignumber(0.1) + bignumber(0.2)') // BigNumber, 0.3


The default number type of the expression parser can be changed at instantiation
of math.js. The expression parser parses numbers as BigNumber by default:

// Configure the type of number: 'number' (default), 'BigNumber', or 'Fraction'
math.config({number: 'BigNumber'})

// all numbers are parsed as BigNumber
math.evaluate('0.1 + 0.2')  // BigNumber, 0.3


BigNumbers can be converted to numbers and vice versa using the functions
number and bignumber. When converting a BigNumber to a Number, the high
precision of the BigNumber will be lost. When a BigNumber is too large to be represented
as Number, it will be initialized as Infinity.

Complex numbers #

Complex numbers can be created using the imaginary unit i, which is defined
as i^2 = -1. Complex numbers have a real and complex part, which can be
retrieved using the functions re and im.

const parser = math.parser()

// create complex numbers
parser.evaluate('a = 2 + 3i')   // Complex, 2 + 3i
parser.evaluate('b = 4 - i')    // Complex, 4 - i

// get real and imaginary part of a complex number
parser.evaluate('re(a)')        // Number,  2
parser.evaluate('im(a)')        // Number,  3

// calculations with complex numbers
parser.evaluate('a + b')        // Complex, 6 + 2i
parser.evaluate('a * b')        // Complex, 11 + 10i
parser.evaluate('i * i')        // Number,  -1
parser.evaluate('sqrt(-4)')     // Complex, 2i


Units #

math.js supports units. Units can be used in the arithmetic operations
add, subtract, multiply, divide, and exponentiation.
Units can also be converted from one to another.
An overview of all available units can be found on the page
Units.

Units can be converted using the operator to or in.

// create a unit
math.evaluate('5.4 kg')                     // Unit, 5.4 kg

// convert a unit
math.evaluate('2 inch to cm')               // Unit, 5.08 cm
math.evaluate('20 celsius in fahrenheit')   // Unit, ~68 fahrenheit
math.evaluate('90 km/h to m/s')             // Unit, 25 m / s

// convert a unit to a number
// A second parameter with the unit for the exported number must be provided
math.evaluate('number(5 cm, mm)')           // Number, 50

// calculations with units
math.evaluate('0.5kg + 33g')                // Unit, 0.533 kg
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('12 seconds * 2')             // Unit, 24 seconds
math.evaluate('sin(45 deg)')                // Number, 0.7071067811865475
math.evaluate('9.81 m/s^2 * 5 s to mi/h')   // Unit, 109.72172512527 mi / h


Strings #

Strings are enclosed by double quotes “ or single quotes ‘. Strings can be concatenated using the
function concat (not by adding them using + like in JavaScript). Parts of
a string can be retrieved or replaced by using indexes. Strings can be converted
to a number using function number, and numbers can be converted to a string
using function string.

When setting the value of a character in a string, the character that has been
set is returned. Likewise, when a range of characters is set, that range of
characters is returned.

const parser = math.parser()

// create a string
parser.evaluate('"hello"')                        // String, "hello"

// string manipulation
parser.evaluate('a = concat("hello", " world")')  // String, "hello world"
parser.evaluate('size(a)')                        // Matrix [11]
parser.evaluate('a[1:5]')                         // String, "hello"
parser.evaluate('a[1] = "H"')                     // String, "H"
parser.evaluate('a[7:12] = "there!"')             // String, "there!"
parser.evaluate('a')                              // String, "Hello there!"

// string conversion
parser.evaluate('number("300")')                  // Number, 300
parser.evaluate('string(300)')                    // String, "300"


Strings can be used in the evaluate function, to parse expressions inside
the expression parser:

math.evaluate('evaluate("2 + 3")')  // 5


Matrices #

Matrices can be created by entering a series of values between square brackets,
elements are separated by a comma ,.
A matrix like [1, 2, 3] will create a vector, a 1-dimensional matrix with
size [3]. To create a multi-dimensional matrix, matrices can be nested into
each other. For easier creation of two-dimensional matrices, a semicolon ;
can be used to separate rows in a matrix.

// create a matrix
math.evaluate('[1, 2, 3]')                                // Matrix, size [3]
math.evaluate('[[1, 2, 3], [4, 5, 6]]')                   // Matrix, size [2, 3]
math.evaluate('[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]')     // Matrix, size [2, 2, 2]

// create a two dimensional matrix
math.evaluate('[1, 2, 3; 4, 5, 6]')                       // Matrix, size [2, 3]


Another way to create filled matrices is using the functions zeros, ones,
identity, and range.

// initialize a matrix with ones or zeros
math.evaluate('zeros(3, 2)')      // Matrix, [[0, 0], [0, 0], [0, 0]],  size [3, 2]
math.evaluate('ones(3)')          // Matrix, [1, 1, 1],                 size [3]
math.evaluate('5 * ones(2, 2)')   // Matrix, [[5, 5], [5, 5]],          size [2, 2]

// create an identity matrix
math.evaluate('identity(2)')      // Matrix, [[1, 0], [0, 1]],          size [2, 2]

// create a range
math.evaluate('1:4')              // Matrix, [1, 2, 3, 4],              size [4]
math.evaluate('0:2:10')           // Matrix, [0, 2, 4, 6, 8, 10],       size [6]


A subset can be retrieved from a matrix using indexes and a subset of a matrix
can be replaced by using indexes. Indexes are enclosed in square brackets, and
contain a number or a range for each of the matrix dimensions. A range can have
its start and/or end undefined. When the start is undefined, the range will start
at 1, when the end is undefined, the range will end at the end of the matrix.

There is a context variable end available as well to denote the end of the
matrix. This variable cannot be used in multiple nested indices. In that case,
end will be resolved as the end of the innermost matrix. To solve this, 
resolving of the nested index needs to be split in two separate operations.

IMPORTANT: matrix indexes and ranges work differently from the math.js indexes
in JavaScript: They are one-based with an included upper-bound, similar to most
math applications.

parser = math.parser()

// create matrices
parser.evaluate('a = [1, 2; 3, 4]')       // Matrix, [[1, 2], [3, 4]]
parser.evaluate('b = zeros(2, 2)')        // Matrix, [[0, 0], [0, 0]]
parser.evaluate('c = 5:9')                // Matrix, [5, 6, 7, 8, 9]

// replace a subset in a matrix
parser.evaluate('b[1, 1:2] = [5, 6]')     // Matrix, [[5, 6], [0, 0]]
parser.evaluate('b[2, :] = [7, 8]')       // Matrix, [[5, 6], [7, 8]]

// perform a matrix calculation
parser.evaluate('d = a * b')              // Matrix, [[19, 22], [43, 50]]

// retrieve a subset of a matrix
parser.evaluate('d[2, 1]')                // 43
parser.evaluate('d[2, 1:end]')            // Matrix, [[43, 50]]
parser.evaluate('c[end - 1 : -1 : 2]')    // Matrix, [8, 7, 6]


Objects #

Objects in math.js work the same as in languages like JavaScript and Python.
An object is enclosed by curly brackets {, }, and contains a set of
comma separated key/value pairs. Keys and values are separated by a colon :.
Keys can be a symbol like prop or a string like "prop".

math.evaluate('{a: 2 + 1, b: 4}')         // {a: 3, b: 4}
math.evaluate('{"a": 2 + 1, "b": 4}')     // {a: 3, b: 4}


Objects can contain objects:

math.evaluate('{a: 2, b: {c: 3, d: 4}}')  // {a: 2, b: {c: 3, d: 4}}


Object properties can be retrieved or replaced using dot notation or bracket
notation. Unlike JavaScript, when setting a property value, the whole object
is returned, not the property value

let scope = {
  obj: {
    prop: 42
  }
}

// retrieve properties
math.evaluate('obj.prop', scope)          // 42
math.evaluate('obj["prop"]', scope)       // 42

// set properties (returns the whole object, not the property value!)
math.evaluate('obj.prop = 43', scope)     // {prop: 43}
math.evaluate('obj["prop"] = 43', scope)  // {prop: 43}
scope.obj                                 // {prop: 43}


Multi-line expressions #

An expression can contain multiple lines, and expressions can be spread over
multiple lines. Lines can be separated by a newline character \n or by a
semicolon ;. Output of statements followed by a semicolon will be hidden from
the output, and empty lines are ignored. The output is returned as a ResultSet,
with an entry for every visible statement.

// a multi-line expression
math.evaluate('1 * 3 \n 2 * 3 \n 3 * 3')    // ResultSet, [3, 6, 9]

// semicolon statements are hidden from the output
math.evaluate('a=3; b=4; a + b \n a * b')   // ResultSet, [7, 12]

// single expression spread over multiple lines
math.evaluate('a = 2 +\n  3')               // 5
math.evaluate('[\n  1, 2;\n  3, 4\n]')      // Matrix, [[1, 2], [3, 4]]


The results can be read from a ResultSet via the property ResultSet.entries
which is an Array, or by calling ResultSet.valueOf(), which returns the
array with results.

Implicit multiplication #

Implicit multiplication means the multiplication of two symbols, numbers, or a grouped expression inside parentheses without using the * operator. This type of syntax allows a more natural way to enter expressions. For example:

math.evaluate('2 pi')         // 6.283185307179586
math.evaluate('(1+2)(3+4)')   // 21


Parentheses are parsed as a function call when there is a symbol or accessor on
the left hand side, like sqrt(4) or obj.method(4). In other cases the
parentheses are interpreted as an implicit multiplication.

Math.js will always evaluate implicit multiplication before explicit multiplication *, so that the expression x * y z is parsed as x * (y * z). Math.js also gives implicit multiplication higher precedence than division, except when the division matches the pattern [unaryPrefixOp]?[number] / [number] [symbol] or [unaryPrefixOp]?[number] / [number] [left paren]. In that special case, the division is evaluated first:

math.evaluate('20 kg / 4 kg')   // 5      Evaluated as (20 kg) / (4 kg)
math.evaluate('20 / 4 kg')      // 5 kg   Evaluated as (20 / 4) kg


The behavior of implicit multiplication can be summarized by these operator precedence rules, listed from highest to lowest precedence:


  Function calls: [symbol] [left paren]
  Explicit division / when the division matches this pattern: [+-~]?[number] / [+-~]?[number] [symbol] or [number] / [number] [left paren]
  Implicit multiplication
  All other division / and multiplication *


Implicit multiplication is tricky as there can appear to be ambiguity in how an expression will be evaluated. Experience has shown that the above rules most closely match user intent when entering expressions that could be interpreted different ways. It’s also possible that these rules could be tweaked in future major releases.  Use implicit multiplication carefully. If you don’t like the uncertainty introduced by implicit multiplication, use explicit * operators and parentheses to ensure your expression is evaluated the way you intend.

Here are some more examples using implicit multiplication:


  
    
      Expression
      Evaluated as
      Result
    
  
  
    
      (1 + 3) pi
      (1 + 3) * pi
      12.566370614359172
    
    
      (4 - 1) 2
      (4 - 1) * 2
      6
    
    
      3 / 4 mm
      (3 / 4) * mm
      0.75 mm
    
    
      2 + 3 i
      2 + (3 * i)
      2 + 3i
    
    
      (1 + 2) (4 - 2)
      (1 + 2) * (4 - 2)
      6
    
    
      sqrt(4) (1 + 2)
      sqrt(4) * (1 + 2)
      6
    
    
      8 pi / 2 pi
      (8 * pi) / (2 * pi)
      4
    
    
      pi / 2 pi
      pi / (2 * pi)
      0.5
    
    
      1 / 2i
      (1 / 2) * i
      0.5 i
    
    
      8.314 J / mol K
      8.314 J / (mol * K)
      8.314 J / (mol * K)
    
  


Comments #

Comments can be added to explain or describe calculations in the text. A comment
starts with a sharp sign character #, and ends at the end of the line. A line
can contain a comment only, or can contain an expression followed by a comment.

const parser = math.parser()

parser.evaluate('# define some variables')
parser.evaluate('width = 3')                              // 3
parser.evaluate('height = 4')                             // 4
parser.evaluate('width * height   # calculate the area')  // 12\n\n\n\nExpression syntax #

This page describes the syntax of expression parser of math.js. It describes
how to work with the available data types, functions, operators, variables,
and more.

Differences from JavaScript #

The expression parser of math.js is aimed at a mathematical audience,
not a programming audience. The syntax is similar to most calculators and
mathematical applications. This is close to JavaScript as well, though there
are a few important differences between the syntax of the expression parser and
the lower level syntax of math.js. Differences are:


  No need to prefix functions and constants with the math.* namespace,
you can just enter sin(pi / 4).
  Matrix indexes are one-based instead of zero-based.
  There are index and range operators which allow more conveniently getting
and setting matrix indexes, like A[2:4, 1].
  Both indexes and ranges and have the upper-bound included.
  There is a differing syntax for defining functions. Example: f(x) = x^2.
  There are custom operators like x + y instead of add(x, y).
  Some operators are different. For example  ^ is used for exponentiation,
not bitwise xor.
  Implicit multiplication, like 2 pi, is supported and has special rules.
  Relational operators (<, >, <=, >=, ==, and !=) are chained, so the expression 5 < x < 10 is equivalent to 5 < x and x < 10.
  Multi-expression constructs like a = 1; b = 2; a + b or
"a = 1;\n cos(a)\n sin(a)" (where \n denotes newline)
produce a collection (“ResultSet”) of values. Those expressions
terminated by ; are evaluated for side effect only and their values
are suppressed from the result.


Operators #

The expression parser has operators for all common arithmetic operations such
as addition and multiplication. The expression parser uses conventional infix
notation for operators: an operator is placed between its arguments.
Round parentheses can be used to override the default precedence of operators.

// use operators
math.evaluate('2 + 3')       // 5
math.evaluate('2 * 3')       // 6

// use parentheses to override the default precedence
math.evaluate('2 + 3 * 4')   // 14
math.evaluate('(2 + 3) * 4') // 20


The following operators are available. Note that almost every operator listed
also has a function form with identical meaning that can be used
interchangeably. For example, x+y will always evaluate identically to
add(x,y). For a full list of the equivalences, see the section on
Functions below.


  
    
      Operator
      Name
      Syntax
      Associativity
      Example
      Result
    
  
  
    
      (, )
      Grouping
      (x)
      None
      2 * (3 + 4)
      14
    
    
      [, ]
      Matrix, Index
      [...]
      None
      [[1,2],[3,4]]
      [[1,2],[3,4]]
    
    
      {, }
      Object
      {...}
      None
      {a: 1, b: 2}
      {a: 1, b: 2}
    
    
      ,
      Parameter separator
      x, y
      Left to right
      max(2, 1, 5)
      5
    
    
      .
      Property accessor
      obj.prop
      Left to right
      obj={a: 12}; obj.a
      12
    
    
      ;
      Statement separator
      x; y
      Left to right
      a=2; b=3; a*b
      [6]
    
    
      ;
      Row separator
      [x; y]
      Left to right
      [1,2;3,4]
      [[1,2],[3,4]]
    
    
      \n
      Statement separator
      x \n y
      Left to right
      a=2 \n b=3 \n a*b
      [2,3,6]
    
    
      +
      Add
      x + y
      Left to right
      4 + 5
      9
    
    
      +
      Unary plus
      +y
      Right to left
      +4
      4
    
    
      -
      Subtract
      x - y
      Left to right
      7 - 3
      4
    
    
      -
      Unary minus
      -y
      Right to left
      -4
      -4
    
    
      *
      Multiply
      x * y
      Left to right
      2 * 3
      6
    
    
      .*
      Element-wise multiply
      x .* y
      Left to right
      [1,2,3] .* [1,2,3]
      [1,4,9]
    
    
      /
      Divide
      x / y
      Left to right
      6 / 2
      3
    
    
      ./
      Element-wise divide
      x ./ y
      Left to right
      [9,6,4] ./ [3,2,2]
      [3,3,2]
    
    
      %
      Percentage
      x%
      None
      8%
      0.08
    
    
      %
      Addition with Percentage
      x + y%
      Left to right
      100 + 3%
      103
    
    
      %
      Subtraction with Percentage
      x - y%
      Left to right
      100 - 3%
      97
    
    
      % mod
      Modulus
      x % y
      Left to right
      8 % 3
      2
    
    
      ^
      Power
      x ^ y
      Right to left
      2 ^ 3
      8
    
    
      .^
      Element-wise power
      x .^ y
      Right to left
      [2,3] .^ [3,3]
      [8,27]
    
    
      '
      Transpose
      y'
      Left to right
      [[1,2],[3,4]]'
      [[1,3],[2,4]]
    
    
      !
      Factorial
      y!
      Left to right
      5!
      120
    
    
      &
      Bitwise and
      x & y
      Left to right
      5 & 3
      1
    
    
      ~
      Bitwise not
      ~x
      Right to left
      ~2
      -3
    
    
      |
      Bitwise or
      x | y
      Left to right
      5 | 3
      7
    
    
      ^|
      Bitwise xor
      x ^| y
      Left to right
      5 ^| 2
      7
    
    
      <<
      Left shift
      x << y
      Left to right
      4 << 1
      8
    
    
      >>
      Right arithmetic shift
      x >> y
      Left to right
      8 >> 1
      4
    
    
      >>>
      Right logical shift
      x >>> y
      Left to right
      -8 >>> 1
      2147483644
    
    
      and
      Logical and
      x and y
      Left to right
      true and false
      false
    
    
      not
      Logical not
      not y
      Right to left
      not true
      false
    
    
      or
      Logical or
      x or y
      Left to right
      true or false
      true
    
    
      xor
      Logical xor
      x xor y
      Left to right
      true xor true
      false
    
    
      =
      Assignment
      x = y
      Right to left
      a = 5
      5
    
    
      ? :
      Conditional expression
      x ? y : z
      Right to left
      15 > 100 ? 1 : -1
      -1
    
    
      :
      Range
      x : y
      Right to left
      1:4
      [1,2,3,4]
    
    
      to, in
      Unit conversion
      x to y
      Left to right
      2 inch to cm
      5.08 cm
    
    
      ==
      Equal
      x == y
      Left to right
      2 == 4 - 2
      true
    
    
      !=
      Unequal
      x != y
      Left to right
      2 != 3
      true
    
    
      <
      Smaller
      x < y
      Left to right
      2 < 3
      true
    
    
      >
      Larger
      x > y
      Left to right
      2 > 3
      false
    
    
      <=
      Smallereq
      x <= y
      Left to right
      4 <= 3
      false
    
    
      >=
      Largereq
      x >= y
      Left to right
      2 + 4 >= 6
      true
    
  


Precedence #

The operators have the following precedence, from highest to lowest:


  
    
      Operators
      Description
    
  
  
    
      (...)[...]{...}
      GroupingMatrixObject
    
    
      x(...)x[...]obj.prop:
      Function callMatrix indexProperty accessorKey/value separator
    
    
      '
      Matrix transpose
    
    
      !
      Factorial
    
    
      ^, .^
      Exponentiation
    
    
      +, -, ~, not
      Unary plus, unary minus, bitwise not, logical not
    
    
      See section below
      Implicit multiplication
    
    
      *, /, .*, ./,%, mod
      Multiply, divide , percentage, modulus
    
    
      +, -
      Add, subtract
    
    
      :
      Range
    
    
      to, in
      Unit conversion
    
    
      <<, >>, >>>
      Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift
    
    
      ==, !=, <, >, <=, >=
      Relational
    
    
      &
      Bitwise and (lazily evaluated)
    
    
      ^|
      Bitwise xor
    
    
      |
      Bitwise or (lazily evaluated)
    
    
      and
      Logical and (lazily evaluated)
    
    
      xor
      Logical xor
    
    
      or
      Logical or (lazily evaluated)
    
    
      ?, :
      Conditional expression
    
    
      =
      Assignment
    
    
      ,
      Parameter and column separator
    
    
      ;
      Row separator
    
    
      \n, ;
      Statement separators
    
  


Lazy evaluation is used where logically possible for bitwise and logical
operators. In the following example, the value of x will not even be 
evaluated because it cannot effect the final result:
math.evaluate('false and x')        // false, no matter what x equals


Functions #

Functions are called by entering their name, followed by zero or more
arguments enclosed by parentheses. All available functions are listed on the
page Functions.

math.evaluate('sqrt(25)')           // 5
math.evaluate('log(10000, 3 + 7)')  // 4
math.evaluate('sin(pi / 4)')        // 0.7071067811865475


New functions can be defined by “assigning” an expression to a function call
with one or more variables. Such function assignments are limited: they can
only be defined on a single line.

const parser = math.parser()

parser.evaluate('f(x) = x ^ 2 - 5')
parser.evaluate('f(2)')     // -1
parser.evaluate('f(3)')     // 4

parser.evaluate('g(x, y) = x ^ y')
parser.evaluate('g(2, 3)')  // 8


Note that these function assignments do not create closures; put another way,
all free variables in mathjs are dynamic:

const parser = math.parser()

parser.evaluate('x = 7')
parser.evaluate('h(y) = x + y')
parser.evaluate('h(3)')         // 10
parser.evaluate('x = 3')
parser.evaluate('h(3)')         // 6, *not* 10


It is however possible to pass functions as parameters:

const parser = math.parser()

parser.evaluate('twice(func, x) = func(func(x))')
parser.evaluate('twice(square, 2)')    // 16
parser.evaluate('f(x) = 3*x')
parser.evaluate('twice(f, 2)')         // 18

// a simplistic "numerical derivative":
parser.evaluate('eps = 1e-10')
parser.evaluate('nd(f, x) = (f(x+eps) - func(x-eps))/(2*eps)')
parser.evaluate('nd(square,2)')        // 4.000000330961484


Math.js itself heavily uses typed functions, which ensure correct inputs and
throws meaningful errors when the input arguments are invalid. One can create
a typed-function in the
expression parser like:

const parser = math.parser()

parser.evaluate('f = typed({"number": f(x) = x ^ 2 - 5})')


Finally, as mentioned above, there is a function form for nearly every one of
the mathematical operator symbols. Moreover, for some associative operators,
the corresponding function allows arbitrarily many arguments. The table below
gives the full correspondence.


  
    
      Operator Expression
      Equivalent Function Expression
    
  
  
    
      a or b
      or(a,b)
    
    
      a xor b
      xor(a,b)
    
    
      a and b
      and(a,b)
    
    
      a \| b
      bitOr(a,b)
    
    
      a ^\| b
      bitXor(a,b)
    
    
      a & b
      bitAnd(a,b)
    
    
      a == b
      equal(a,b)
    
    
      a != b
      unequal(a,b)
    
    
      a < b
      smaller(a,b)
    
    
      a > b
      larger(a,b)
    
    
      a <= b
      smallerEq(a,b)
    
    
      a << 3
      leftShift(a,3)
    
    
      a >> 3
      rightArithShift(a,3)
    
    
      a >>> 3
      rightLogShift(a,3)
    
    
      u to cm
      to(u, cm)
    
    
      a + b + c + ...
      add(a,b,c,...)
    
    
      a - b
      subtract(a,b)
    
    
      a * b * c * ...
      multiply(a,b,c,...)
    
    
      A .* B
      dotMultiply(A,B)
    
    
      A ./ B
      dotDivide(A,B)
    
    
      a mod b
      mod(a,b)
    
    
      +a
      unaryPlus(a)
    
    
      -a
      unaryMinus(a)
    
    
      ~a
      bitNot(a)
    
    
      not a
      not(a)
    
    
      a^b
      pow(a,b)
    
    
      A .^ B
      dotPow(A,B)
    
    
      a!
      factorial(a)
    
    
      A'
      ctranspose(A)
    
  


Note that math.js embodies a preference for the operator forms, in that calling
simplify (see Algebra) converts any instances of the function
form into the corresponding operator.

Map and forEach #

The map and forEach functions can be used to apply a callback function to each element of an array or matrix.

The callback functions can be functions, typed functions, inline functions (only in the parser) or compiled inline functions (only in the parser).

The callback can have the following inputs:

  value: the current value in the array or matrix.
  index: the index of the current value expressed as an array of numbers.
  array: the array or matrix being iterated.


Below is the syntax for both functions:

map #

The map function applies a function to each element of an array and returns a new array with the results.

const parser = math.parser()

// Define a square function
parser.evaluate('square(x) = x ^ 2')

// Apply the square function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], square)')
// result: [1, 4, 9, 16]

// Apply an inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], f(x) = x ^ 2)')
// result: [1, 4, 9, 16]

// Apply a compiled inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], x ^ 2)')
// result: [1, 4, 9, 16]


forEach #
The forEach function applies a function to each element of an array or matrix but does not return a new array. It is useful for executing side effects.

// Define a function that prints each element
math.import({consoleLog: x => console.log(x)})
const parser = math.parser()

// Define a squareConsleLog function
parser.evaluate('squareConsoleLog(x) = consoleLog(x ^ 2)')

// Apply the squareConsleLog function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], squareConsleLog)')
// Prints: 1, 4, 9, 16

// Apply an inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], f(x) = consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16

// Apply a compiled inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16


These functions are useful for performing element-wise operations on arrays or matrices.

Constants and variables #

Math.js has a number of built-in constants such as pi and e.
All available constants are listed on he page
Constants.

// use constants
math.evaluate('pi')                 // 3.141592653589793
math.evaluate('e ^ 2')              // 7.3890560989306495
math.evaluate('log(e)')             // 1
math.evaluate('e ^ (pi * i) + 1')   // ~0 (Euler)


Variables can be defined using the assignment operator =, and can be used
like constants.

const parser = math.parser()

// define variables
parser.evaluate('a = 3.4')      // 3.4
parser.evaluate('b = 5 / 2')    // 2.5

// use variables
parser.evaluate('a * b')        // 8.5


Variable names must:


  Begin with an “alpha character”, which is:
    
      A latin letter (upper or lower case). Ascii: a-z, A-Z
      An underscore.                        Ascii: _
      A dollar sign.                        Ascii: $
      A latin letter with accents.          Unicode: \u00C0 - \u02AF
      A greek letter.                       Unicode: \u0370 - \u03FF
      A letter-like character.              Unicode: \u2100 - \u214F
      A mathematical alphanumeric symbol.   Unicode: \u{1D400} - \u{1D7FF} excluding invalid code points
    
  
  Contain only alpha characters (above) and digits 0-9
  Not be any of the following: mod, to, in, and, xor, or, not, end. It is possible to assign to some of these, but that’s not recommended.


It is possible to customize the allowed alpha characters, see Customize supported characters for more information.

Data types #

The expression parser supports booleans, numbers, complex numbers, units,
strings, matrices, and objects.

Booleans #

Booleans true and false can be used in expressions.

// use booleans
math.evaluate('true')               // true
math.evaluate('false')              // false
math.evaluate('(2 == 3) == false')  // true


Booleans can be converted to numbers and strings and vice versa using the
functions number and boolean, and string.

// convert booleans
math.evaluate('number(true)')       // 1
math.evaluate('string(false)')      // "false"
math.evaluate('boolean(1)')         // true
math.evaluate('boolean("false")')   // false


Numbers #

The most important and basic data type in math.js are numbers. Numbers use a
point as decimal mark. Numbers can be entered with exponential notation.
Examples:

// numbers in math.js
math.evaluate('2')        // 2
math.evaluate('3.14')     // 3.14
math.evaluate('1.4e3')    // 1400
math.evaluate('22e-3')    // 0.022


A number can be converted to a string and vice versa using the functions
number and string.

// convert a string into a number
math.evaluate('number("2.3")')    // 2.3
math.evaluate('string(2.3)')      // "2.3"


Math.js uses regular JavaScript numbers, which are floating points with a
limited precision and limited range. The limitations are described in detail
on the page Numbers.

math.evaluate('1e-325')   // 0
math.evaluate('1e309')    // Infinity
math.evaluate('-1e309')   // -Infinity


When doing calculations with floats, one can very easily get round-off errors:

// round-off error due to limited floating point precision
math.evaluate('0.1 + 0.2')  // 0.30000000000000004


When outputting results, the function math.format can be used to hide
these round-off errors when outputting results for the user:

const ans = math.evaluate('0.1 + 0.2')  //  0.30000000000000004
math.format(ans, {precision: 14})       // "0.3"


Numbers can be expressed as binary, octal, and hexadecimal literals:

math.evaluate('0b11')  //  3
math.evaluate('0o77')  //  63
math.evaluate('0xff')  //  255


A word size suffix can be used to change the behavior of non decimal literal evaluation:

math.evaluate('0xffi8')         // -1
math.evaluate('0xffffffffi32')  //  -1
math.evaluate('0xfffffffffi32') //  SyntaxError: String "0xfffffffff" is out of range


Non decimal numbers can include a radix point:
math.evaluate('0b1.1')         // 1.5
math.evaluate('0o1.4')         // 1.5
math.evaluate('0x1.8')         // 1.5


Numbers can be formatted as binary, octal, and hex strings using the notation option of the format function:

math.evaluate('format(3, {notation: "bin"})')    //  '0b11'
math.evaluate('format(63, {notation: "oct"})')   //  '0o77'
math.evaluate('format(255, {notation: "hex"})')  //  '0xff'
math.evaluate('format(-1, {notation: "hex"})')   //  '-0x1'
math.evaluate('format(2.3, {notation: "hex"})')  //  '0x2.4cccccccccccc'


The format function accepts a wordSize option to use in conjunction with the non binary notations:

math.evaluate('format(-1, {notation: "hex", wordSize: 8})')   //  '0xffi8'


The functions bin, oct, and hex are shorthand for the format function with notation set accordingly:

math.evaluate('bin(-1)')     // '-0b1'
math.evaluate('bin(-1, 8)')  // '0b11111111i8'


BigNumbers #

Math.js supports BigNumbers for calculations with an arbitrary precision.
The pros and cons of Number and BigNumber are explained in detail on the page
Numbers.

BigNumbers are slower but have a higher precision. Calculations with big
numbers are supported only by arithmetic functions.

BigNumbers can be created using the bignumber function:

math.evaluate('bignumber(0.1) + bignumber(0.2)') // BigNumber, 0.3


The default number type of the expression parser can be changed at instantiation
of math.js. The expression parser parses numbers as BigNumber by default:

// Configure the type of number: 'number' (default), 'BigNumber', or 'Fraction'
math.config({number: 'BigNumber'})

// all numbers are parsed as BigNumber
math.evaluate('0.1 + 0.2')  // BigNumber, 0.3


BigNumbers can be converted to numbers and vice versa using the functions
number and bignumber. When converting a BigNumber to a Number, the high
precision of the BigNumber will be lost. When a BigNumber is too large to be represented
as Number, it will be initialized as Infinity.

Complex numbers #

Complex numbers can be created using the imaginary unit i, which is defined
as i^2 = -1. Complex numbers have a real and complex part, which can be
retrieved using the functions re and im.

const parser = math.parser()

// create complex numbers
parser.evaluate('a = 2 + 3i')   // Complex, 2 + 3i
parser.evaluate('b = 4 - i')    // Complex, 4 - i

// get real and imaginary part of a complex number
parser.evaluate('re(a)')        // Number,  2
parser.evaluate('im(a)')        // Number,  3

// calculations with complex numbers
parser.evaluate('a + b')        // Complex, 6 + 2i
parser.evaluate('a * b')        // Complex, 11 + 10i
parser.evaluate('i * i')        // Number,  -1
parser.evaluate('sqrt(-4)')     // Complex, 2i


Units #

math.js supports units. Units can be used in the arithmetic operations
add, subtract, multiply, divide, and exponentiation.
Units can also be converted from one to another.
An overview of all available units can be found on the page
Units.

Units can be converted using the operator to or in.

// create a unit
math.evaluate('5.4 kg')                     // Unit, 5.4 kg

// convert a unit
math.evaluate('2 inch to cm')               // Unit, 5.08 cm
math.evaluate('20 celsius in fahrenheit')   // Unit, ~68 fahrenheit
math.evaluate('90 km/h to m/s')             // Unit, 25 m / s

// convert a unit to a number
// A second parameter with the unit for the exported number must be provided
math.evaluate('number(5 cm, mm)')           // Number, 50

// calculations with units
math.evaluate('0.5kg + 33g')                // Unit, 0.533 kg
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('12 seconds * 2')             // Unit, 24 seconds
math.evaluate('sin(45 deg)')                // Number, 0.7071067811865475
math.evaluate('9.81 m/s^2 * 5 s to mi/h')   // Unit, 109.72172512527 mi / h


Strings #

Strings are enclosed by double quotes “ or single quotes ‘. Strings can be concatenated using the
function concat (not by adding them using + like in JavaScript). Parts of
a string can be retrieved or replaced by using indexes. Strings can be converted
to a number using function number, and numbers can be converted to a string
using function string.

When setting the value of a character in a string, the character that has been
set is returned. Likewise, when a range of characters is set, that range of
characters is returned.

const parser = math.parser()

// create a string
parser.evaluate('"hello"')                        // String, "hello"

// string manipulation
parser.evaluate('a = concat("hello", " world")')  // String, "hello world"
parser.evaluate('size(a)')                        // Matrix [11]
parser.evaluate('a[1:5]')                         // String, "hello"
parser.evaluate('a[1] = "H"')                     // String, "H"
parser.evaluate('a[7:12] = "there!"')             // String, "there!"
parser.evaluate('a')                              // String, "Hello there!"

// string conversion
parser.evaluate('number("300")')                  // Number, 300
parser.evaluate('string(300)')                    // String, "300"


Strings can be used in the evaluate function, to parse expressions inside
the expression parser:

math.evaluate('evaluate("2 + 3")')  // 5


Matrices #

Matrices can be created by entering a series of values between square brackets,
elements are separated by a comma ,.
A matrix like [1, 2, 3] will create a vector, a 1-dimensional matrix with
size [3]. To create a multi-dimensional matrix, matrices can be nested into
each other. For easier creation of two-dimensional matrices, a semicolon ;
can be used to separate rows in a matrix.

// create a matrix
math.evaluate('[1, 2, 3]')                                // Matrix, size [3]
math.evaluate('[[1, 2, 3], [4, 5, 6]]')                   // Matrix, size [2, 3]
math.evaluate('[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]')     // Matrix, size [2, 2, 2]

// create a two dimensional matrix
math.evaluate('[1, 2, 3; 4, 5, 6]')                       // Matrix, size [2, 3]


Another way to create filled matrices is using the functions zeros, ones,
identity, and range.

// initialize a matrix with ones or zeros
math.evaluate('zeros(3, 2)')      // Matrix, [[0, 0], [0, 0], [0, 0]],  size [3, 2]
math.evaluate('ones(3)')          // Matrix, [1, 1, 1],                 size [3]
math.evaluate('5 * ones(2, 2)')   // Matrix, [[5, 5], [5, 5]],          size [2, 2]

// create an identity matrix
math.evaluate('identity(2)')      // Matrix, [[1, 0], [0, 1]],          size [2, 2]

// create a range
math.evaluate('1:4')              // Matrix, [1, 2, 3, 4],              size [4]
math.evaluate('0:2:10')           // Matrix, [0, 2, 4, 6, 8, 10],       size [6]


A subset can be retrieved from a matrix using indexes and a subset of a matrix
can be replaced by using indexes. Indexes are enclosed in square brackets, and
contain a number or a range for each of the matrix dimensions. A range can have
its start and/or end undefined. When the start is undefined, the range will start
at 1, when the end is undefined, the range will end at the end of the matrix.

There is a context variable end available as well to denote the end of the
matrix. This variable cannot be used in multiple nested indices. In that case,
end will be resolved as the end of the innermost matrix. To solve this, 
resolving of the nested index needs to be split in two separate operations.

IMPORTANT: matrix indexes and ranges work differently from the math.js indexes
in JavaScript: They are one-based with an included upper-bound, similar to most
math applications.

parser = math.parser()

// create matrices
parser.evaluate('a = [1, 2; 3, 4]')       // Matrix, [[1, 2], [3, 4]]
parser.evaluate('b = zeros(2, 2)')        // Matrix, [[0, 0], [0, 0]]
parser.evaluate('c = 5:9')                // Matrix, [5, 6, 7, 8, 9]

// replace a subset in a matrix
parser.evaluate('b[1, 1:2] = [5, 6]')     // Matrix, [[5, 6], [0, 0]]
parser.evaluate('b[2, :] = [7, 8]')       // Matrix, [[5, 6], [7, 8]]

// perform a matrix calculation
parser.evaluate('d = a * b')              // Matrix, [[19, 22], [43, 50]]

// retrieve a subset of a matrix
parser.evaluate('d[2, 1]')                // 43
parser.evaluate('d[2, 1:end]')            // Matrix, [[43, 50]]
parser.evaluate('c[end - 1 : -1 : 2]')    // Matrix, [8, 7, 6]


Objects #

Objects in math.js work the same as in languages like JavaScript and Python.
An object is enclosed by curly brackets {, }, and contains a set of
comma separated key/value pairs. Keys and values are separated by a colon :.
Keys can be a symbol like prop or a string like "prop".

math.evaluate('{a: 2 + 1, b: 4}')         // {a: 3, b: 4}
math.evaluate('{"a": 2 + 1, "b": 4}')     // {a: 3, b: 4}


Objects can contain objects:

math.evaluate('{a: 2, b: {c: 3, d: 4}}')  // {a: 2, b: {c: 3, d: 4}}


Object properties can be retrieved or replaced using dot notation or bracket
notation. Unlike JavaScript, when setting a property value, the whole object
is returned, not the property value

let scope = {
  obj: {
    prop: 42
  }
}

// retrieve properties
math.evaluate('obj.prop', scope)          // 42
math.evaluate('obj["prop"]', scope)       // 42

// set properties (returns the whole object, not the property value!)
math.evaluate('obj.prop = 43', scope)     // {prop: 43}
math.evaluate('obj["prop"] = 43', scope)  // {prop: 43}
scope.obj                                 // {prop: 43}


Multi-line expressions #

An expression can contain multiple lines, and expressions can be spread over
multiple lines. Lines can be separated by a newline character \n or by a
semicolon ;. Output of statements followed by a semicolon will be hidden from
the output, and empty lines are ignored. The output is returned as a ResultSet,
with an entry for every visible statement.

// a multi-line expression
math.evaluate('1 * 3 \n 2 * 3 \n 3 * 3')    // ResultSet, [3, 6, 9]

// semicolon statements are hidden from the output
math.evaluate('a=3; b=4; a + b \n a * b')   // ResultSet, [7, 12]

// single expression spread over multiple lines
math.evaluate('a = 2 +\n  3')               // 5
math.evaluate('[\n  1, 2;\n  3, 4\n]')      // Matrix, [[1, 2], [3, 4]]


The results can be read from a ResultSet via the property ResultSet.entries
which is an Array, or by calling ResultSet.valueOf(), which returns the
array with results.

Implicit multiplication #

Implicit multiplication means the multiplication of two symbols, numbers, or a grouped expression inside parentheses without using the * operator. This type of syntax allows a more natural way to enter expressions. For example:

math.evaluate('2 pi')         // 6.283185307179586
math.evaluate('(1+2)(3+4)')   // 21


Parentheses are parsed as a function call when there is a symbol or accessor on
the left hand side, like sqrt(4) or obj.method(4). In other cases the
parentheses are interpreted as an implicit multiplication.

Math.js will always evaluate implicit multiplication before explicit multiplication *, so that the expression x * y z is parsed as x * (y * z). Math.js also gives implicit multiplication higher precedence than division, except when the division matches the pattern [unaryPrefixOp]?[number] / [number] [symbol] or [unaryPrefixOp]?[number] / [number] [left paren]. In that special case, the division is evaluated first:

math.evaluate('20 kg / 4 kg')   // 5      Evaluated as (20 kg) / (4 kg)
math.evaluate('20 / 4 kg')      // 5 kg   Evaluated as (20 / 4) kg


The behavior of implicit multiplication can be summarized by these operator precedence rules, listed from highest to lowest precedence:


  Function calls: [symbol] [left paren]
  Explicit division / when the division matches this pattern: [+-~]?[number] / [+-~]?[number] [symbol] or [number] / [number] [left paren]
  Implicit multiplication
  All other division / and multiplication *


Implicit multiplication is tricky as there can appear to be ambiguity in how an expression will be evaluated. Experience has shown that the above rules most closely match user intent when entering expressions that could be interpreted different ways. It’s also possible that these rules could be tweaked in future major releases.  Use implicit multiplication carefully. If you don’t like the uncertainty introduced by implicit multiplication, use explicit * operators and parentheses to ensure your expression is evaluated the way you intend.

Here are some more examples using implicit multiplication:


  
    
      Expression
      Evaluated as
      Result
    
  
  
    
      (1 + 3) pi
      (1 + 3) * pi
      12.566370614359172
    
    
      (4 - 1) 2
      (4 - 1) * 2
      6
    
    
      3 / 4 mm
      (3 / 4) * mm
      0.75 mm
    
    
      2 + 3 i
      2 + (3 * i)
      2 + 3i
    
    
      (1 + 2) (4 - 2)
      (1 + 2) * (4 - 2)
      6
    
    
      sqrt(4) (1 + 2)
      sqrt(4) * (1 + 2)
      6
    
    
      8 pi / 2 pi
      (8 * pi) / (2 * pi)
      4
    
    
      pi / 2 pi
      pi / (2 * pi)
      0.5
    
    
      1 / 2i
      (1 / 2) * i
      0.5 i
    
    
      8.314 J / mol K
      8.314 J / (mol * K)
      8.314 J / (mol * K)
    
  


Comments #

Comments can be added to explain or describe calculations in the text. A comment
starts with a sharp sign character #, and ends at the end of the line. A line
can contain a comment only, or can contain an expression followed by a comment.

const parser = math.parser()

parser.evaluate('# define some variables')
parser.evaluate('width = 3')                              // 3
parser.evaluate('height = 4')                             // 4
parser.evaluate('width * height   # calculate the area')  // 12\n\n\n\nExpression syntax #

This page describes the syntax of expression parser of math.js. It describes
how to work with the available data types, functions, operators, variables,
and more.

Differences from JavaScript #

The expression parser of math.js is aimed at a mathematical audience,
not a programming audience. The syntax is similar to most calculators and
mathematical applications. This is close to JavaScript as well, though there
are a few important differences between the syntax of the expression parser and
the lower level syntax of math.js. Differences are:


  No need to prefix functions and constants with the math.* namespace,
you can just enter sin(pi / 4).
  Matrix indexes are one-based instead of zero-based.
  There are index and range operators which allow more conveniently getting
and setting matrix indexes, like A[2:4, 1].
  Both indexes and ranges and have the upper-bound included.
  There is a differing syntax for defining functions. Example: f(x) = x^2.
  There are custom operators like x + y instead of add(x, y).
  Some operators are different. For example  ^ is used for exponentiation,
not bitwise xor.
  Implicit multiplication, like 2 pi, is supported and has special rules.
  Relational operators (<, >, <=, >=, ==, and !=) are chained, so the expression 5 < x < 10 is equivalent to 5 < x and x < 10.
  Multi-expression constructs like a = 1; b = 2; a + b or
"a = 1;\n cos(a)\n sin(a)" (where \n denotes newline)
produce a collection (“ResultSet”) of values. Those expressions
terminated by ; are evaluated for side effect only and their values
are suppressed from the result.


Operators #

The expression parser has operators for all common arithmetic operations such
as addition and multiplication. The expression parser uses conventional infix
notation for operators: an operator is placed between its arguments.
Round parentheses can be used to override the default precedence of operators.

// use operators
math.evaluate('2 + 3')       // 5
math.evaluate('2 * 3')       // 6

// use parentheses to override the default precedence
math.evaluate('2 + 3 * 4')   // 14
math.evaluate('(2 + 3) * 4') // 20


The following operators are available. Note that almost every operator listed
also has a function form with identical meaning that can be used
interchangeably. For example, x+y will always evaluate identically to
add(x,y). For a full list of the equivalences, see the section on
Functions below.


  
    
      Operator
      Name
      Syntax
      Associativity
      Example
      Result
    
  
  
    
      (, )
      Grouping
      (x)
      None
      2 * (3 + 4)
      14
    
    
      [, ]
      Matrix, Index
      [...]
      None
      [[1,2],[3,4]]
      [[1,2],[3,4]]
    
    
      {, }
      Object
      {...}
      None
      {a: 1, b: 2}
      {a: 1, b: 2}
    
    
      ,
      Parameter separator
      x, y
      Left to right
      max(2, 1, 5)
      5
    
    
      .
      Property accessor
      obj.prop
      Left to right
      obj={a: 12}; obj.a
      12
    
    
      ;
      Statement separator
      x; y
      Left to right
      a=2; b=3; a*b
      [6]
    
    
      ;
      Row separator
      [x; y]
      Left to right
      [1,2;3,4]
      [[1,2],[3,4]]
    
    
      \n
      Statement separator
      x \n y
      Left to right
      a=2 \n b=3 \n a*b
      [2,3,6]
    
    
      +
      Add
      x + y
      Left to right
      4 + 5
      9
    
    
      +
      Unary plus
      +y
      Right to left
      +4
      4
    
    
      -
      Subtract
      x - y
      Left to right
      7 - 3
      4
    
    
      -
      Unary minus
      -y
      Right to left
      -4
      -4
    
    
      *
      Multiply
      x * y
      Left to right
      2 * 3
      6
    
    
      .*
      Element-wise multiply
      x .* y
      Left to right
      [1,2,3] .* [1,2,3]
      [1,4,9]
    
    
      /
      Divide
      x / y
      Left to right
      6 / 2
      3
    
    
      ./
      Element-wise divide
      x ./ y
      Left to right
      [9,6,4] ./ [3,2,2]
      [3,3,2]
    
    
      %
      Percentage
      x%
      None
      8%
      0.08
    
    
      %
      Addition with Percentage
      x + y%
      Left to right
      100 + 3%
      103
    
    
      %
      Subtraction with Percentage
      x - y%
      Left to right
      100 - 3%
      97
    
    
      % mod
      Modulus
      x % y
      Left to right
      8 % 3
      2
    
    
      ^
      Power
      x ^ y
      Right to left
      2 ^ 3
      8
    
    
      .^
      Element-wise power
      x .^ y
      Right to left
      [2,3] .^ [3,3]
      [8,27]
    
    
      '
      Transpose
      y'
      Left to right
      [[1,2],[3,4]]'
      [[1,3],[2,4]]
    
    
      !
      Factorial
      y!
      Left to right
      5!
      120
    
    
      &
      Bitwise and
      x & y
      Left to right
      5 & 3
      1
    
    
      ~
      Bitwise not
      ~x
      Right to left
      ~2
      -3
    
    
      |
      Bitwise or
      x | y
      Left to right
      5 | 3
      7
    
    
      ^|
      Bitwise xor
      x ^| y
      Left to right
      5 ^| 2
      7
    
    
      <<
      Left shift
      x << y
      Left to right
      4 << 1
      8
    
    
      >>
      Right arithmetic shift
      x >> y
      Left to right
      8 >> 1
      4
    
    
      >>>
      Right logical shift
      x >>> y
      Left to right
      -8 >>> 1
      2147483644
    
    
      and
      Logical and
      x and y
      Left to right
      true and false
      false
    
    
      not
      Logical not
      not y
      Right to left
      not true
      false
    
    
      or
      Logical or
      x or y
      Left to right
      true or false
      true
    
    
      xor
      Logical xor
      x xor y
      Left to right
      true xor true
      false
    
    
      =
      Assignment
      x = y
      Right to left
      a = 5
      5
    
    
      ? :
      Conditional expression
      x ? y : z
      Right to left
      15 > 100 ? 1 : -1
      -1
    
    
      :
      Range
      x : y
      Right to left
      1:4
      [1,2,3,4]
    
    
      to, in
      Unit conversion
      x to y
      Left to right
      2 inch to cm
      5.08 cm
    
    
      ==
      Equal
      x == y
      Left to right
      2 == 4 - 2
      true
    
    
      !=
      Unequal
      x != y
      Left to right
      2 != 3
      true
    
    
      <
      Smaller
      x < y
      Left to right
      2 < 3
      true
    
    
      >
      Larger
      x > y
      Left to right
      2 > 3
      false
    
    
      <=
      Smallereq
      x <= y
      Left to right
      4 <= 3
      false
    
    
      >=
      Largereq
      x >= y
      Left to right
      2 + 4 >= 6
      true
    
  


Precedence #

The operators have the following precedence, from highest to lowest:


  
    
      Operators
      Description
    
  
  
    
      (...)[...]{...}
      GroupingMatrixObject
    
    
      x(...)x[...]obj.prop:
      Function callMatrix indexProperty accessorKey/value separator
    
    
      '
      Matrix transpose
    
    
      !
      Factorial
    
    
      ^, .^
      Exponentiation
    
    
      +, -, ~, not
      Unary plus, unary minus, bitwise not, logical not
    
    
      See section below
      Implicit multiplication
    
    
      *, /, .*, ./,%, mod
      Multiply, divide , percentage, modulus
    
    
      +, -
      Add, subtract
    
    
      :
      Range
    
    
      to, in
      Unit conversion
    
    
      <<, >>, >>>
      Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift
    
    
      ==, !=, <, >, <=, >=
      Relational
    
    
      &
      Bitwise and (lazily evaluated)
    
    
      ^|
      Bitwise xor
    
    
      |
      Bitwise or (lazily evaluated)
    
    
      and
      Logical and (lazily evaluated)
    
    
      xor
      Logical xor
    
    
      or
      Logical or (lazily evaluated)
    
    
      ?, :
      Conditional expression
    
    
      =
      Assignment
    
    
      ,
      Parameter and column separator
    
    
      ;
      Row separator
    
    
      \n, ;
      Statement separators
    
  


Lazy evaluation is used where logically possible for bitwise and logical
operators. In the following example, the value of x will not even be 
evaluated because it cannot effect the final result:
math.evaluate('false and x')        // false, no matter what x equals


Functions #

Functions are called by entering their name, followed by zero or more
arguments enclosed by parentheses. All available functions are listed on the
page Functions.

math.evaluate('sqrt(25)')           // 5
math.evaluate('log(10000, 3 + 7)')  // 4
math.evaluate('sin(pi / 4)')        // 0.7071067811865475


New functions can be defined by “assigning” an expression to a function call
with one or more variables. Such function assignments are limited: they can
only be defined on a single line.

const parser = math.parser()

parser.evaluate('f(x) = x ^ 2 - 5')
parser.evaluate('f(2)')     // -1
parser.evaluate('f(3)')     // 4

parser.evaluate('g(x, y) = x ^ y')
parser.evaluate('g(2, 3)')  // 8


Note that these function assignments do not create closures; put another way,
all free variables in mathjs are dynamic:

const parser = math.parser()

parser.evaluate('x = 7')
parser.evaluate('h(y) = x + y')
parser.evaluate('h(3)')         // 10
parser.evaluate('x = 3')
parser.evaluate('h(3)')         // 6, *not* 10


It is however possible to pass functions as parameters:

const parser = math.parser()

parser.evaluate('twice(func, x) = func(func(x))')
parser.evaluate('twice(square, 2)')    // 16
parser.evaluate('f(x) = 3*x')
parser.evaluate('twice(f, 2)')         // 18

// a simplistic "numerical derivative":
parser.evaluate('eps = 1e-10')
parser.evaluate('nd(f, x) = (f(x+eps) - func(x-eps))/(2*eps)')
parser.evaluate('nd(square,2)')        // 4.000000330961484


Math.js itself heavily uses typed functions, which ensure correct inputs and
throws meaningful errors when the input arguments are invalid. One can create
a typed-function in the
expression parser like:

const parser = math.parser()

parser.evaluate('f = typed({"number": f(x) = x ^ 2 - 5})')


Finally, as mentioned above, there is a function form for nearly every one of
the mathematical operator symbols. Moreover, for some associative operators,
the corresponding function allows arbitrarily many arguments. The table below
gives the full correspondence.


  
    
      Operator Expression
      Equivalent Function Expression
    
  
  
    
      a or b
      or(a,b)
    
    
      a xor b
      xor(a,b)
    
    
      a and b
      and(a,b)
    
    
      a \| b
      bitOr(a,b)
    
    
      a ^\| b
      bitXor(a,b)
    
    
      a & b
      bitAnd(a,b)
    
    
      a == b
      equal(a,b)
    
    
      a != b
      unequal(a,b)
    
    
      a < b
      smaller(a,b)
    
    
      a > b
      larger(a,b)
    
    
      a <= b
      smallerEq(a,b)
    
    
      a << 3
      leftShift(a,3)
    
    
      a >> 3
      rightArithShift(a,3)
    
    
      a >>> 3
      rightLogShift(a,3)
    
    
      u to cm
      to(u, cm)
    
    
      a + b + c + ...
      add(a,b,c,...)
    
    
      a - b
      subtract(a,b)
    
    
      a * b * c * ...
      multiply(a,b,c,...)
    
    
      A .* B
      dotMultiply(A,B)
    
    
      A ./ B
      dotDivide(A,B)
    
    
      a mod b
      mod(a,b)
    
    
      +a
      unaryPlus(a)
    
    
      -a
      unaryMinus(a)
    
    
      ~a
      bitNot(a)
    
    
      not a
      not(a)
    
    
      a^b
      pow(a,b)
    
    
      A .^ B
      dotPow(A,B)
    
    
      a!
      factorial(a)
    
    
      A'
      ctranspose(A)
    
  


Note that math.js embodies a preference for the operator forms, in that calling
simplify (see Algebra) converts any instances of the function
form into the corresponding operator.

Map and forEach #

The map and forEach functions can be used to apply a callback function to each element of an array or matrix.

The callback functions can be functions, typed functions, inline functions (only in the parser) or compiled inline functions (only in the parser).

The callback can have the following inputs:

  value: the current value in the array or matrix.
  index: the index of the current value expressed as an array of numbers.
  array: the array or matrix being iterated.


Below is the syntax for both functions:

map #

The map function applies a function to each element of an array and returns a new array with the results.

const parser = math.parser()

// Define a square function
parser.evaluate('square(x) = x ^ 2')

// Apply the square function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], square)')
// result: [1, 4, 9, 16]

// Apply an inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], f(x) = x ^ 2)')
// result: [1, 4, 9, 16]

// Apply a compiled inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], x ^ 2)')
// result: [1, 4, 9, 16]


forEach #
The forEach function applies a function to each element of an array or matrix but does not return a new array. It is useful for executing side effects.

// Define a function that prints each element
math.import({consoleLog: x => console.log(x)})
const parser = math.parser()

// Define a squareConsleLog function
parser.evaluate('squareConsoleLog(x) = consoleLog(x ^ 2)')

// Apply the squareConsleLog function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], squareConsleLog)')
// Prints: 1, 4, 9, 16

// Apply an inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], f(x) = consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16

// Apply a compiled inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16


These functions are useful for performing element-wise operations on arrays or matrices.

Constants and variables #

Math.js has a number of built-in constants such as pi and e.
All available constants are listed on he page
Constants.

// use constants
math.evaluate('pi')                 // 3.141592653589793
math.evaluate('e ^ 2')              // 7.3890560989306495
math.evaluate('log(e)')             // 1
math.evaluate('e ^ (pi * i) + 1')   // ~0 (Euler)


Variables can be defined using the assignment operator =, and can be used
like constants.

const parser = math.parser()

// define variables
parser.evaluate('a = 3.4')      // 3.4
parser.evaluate('b = 5 / 2')    // 2.5

// use variables
parser.evaluate('a * b')        // 8.5


Variable names must:


  Begin with an “alpha character”, which is:
    
      A latin letter (upper or lower case). Ascii: a-z, A-Z
      An underscore.                        Ascii: _
      A dollar sign.                        Ascii: $
      A latin letter with accents.          Unicode: \u00C0 - \u02AF
      A greek letter.                       Unicode: \u0370 - \u03FF
      A letter-like character.              Unicode: \u2100 - \u214F
      A mathematical alphanumeric symbol.   Unicode: \u{1D400} - \u{1D7FF} excluding invalid code points
    
  
  Contain only alpha characters (above) and digits 0-9
  Not be any of the following: mod, to, in, and, xor, or, not, end. It is possible to assign to some of these, but that’s not recommended.


It is possible to customize the allowed alpha characters, see Customize supported characters for more information.

Data types #

The expression parser supports booleans, numbers, complex numbers, units,
strings, matrices, and objects.

Booleans #

Booleans true and false can be used in expressions.

// use booleans
math.evaluate('true')               // true
math.evaluate('false')              // false
math.evaluate('(2 == 3) == false')  // true


Booleans can be converted to numbers and strings and vice versa using the
functions number and boolean, and string.

// convert booleans
math.evaluate('number(true)')       // 1
math.evaluate('string(false)')      // "false"
math.evaluate('boolean(1)')         // true
math.evaluate('boolean("false")')   // false


Numbers #

The most important and basic data type in math.js are numbers. Numbers use a
point as decimal mark. Numbers can be entered with exponential notation.
Examples:

// numbers in math.js
math.evaluate('2')        // 2
math.evaluate('3.14')     // 3.14
math.evaluate('1.4e3')    // 1400
math.evaluate('22e-3')    // 0.022


A number can be converted to a string and vice versa using the functions
number and string.

// convert a string into a number
math.evaluate('number("2.3")')    // 2.3
math.evaluate('string(2.3)')      // "2.3"


Math.js uses regular JavaScript numbers, which are floating points with a
limited precision and limited range. The limitations are described in detail
on the page Numbers.

math.evaluate('1e-325')   // 0
math.evaluate('1e309')    // Infinity
math.evaluate('-1e309')   // -Infinity


When doing calculations with floats, one can very easily get round-off errors:

// round-off error due to limited floating point precision
math.evaluate('0.1 + 0.2')  // 0.30000000000000004


When outputting results, the function math.format can be used to hide
these round-off errors when outputting results for the user:

const ans = math.evaluate('0.1 + 0.2')  //  0.30000000000000004
math.format(ans, {precision: 14})       // "0.3"


Numbers can be expressed as binary, octal, and hexadecimal literals:

math.evaluate('0b11')  //  3
math.evaluate('0o77')  //  63
math.evaluate('0xff')  //  255


A word size suffix can be used to change the behavior of non decimal literal evaluation:

math.evaluate('0xffi8')         // -1
math.evaluate('0xffffffffi32')  //  -1
math.evaluate('0xfffffffffi32') //  SyntaxError: String "0xfffffffff" is out of range


Non decimal numbers can include a radix point:
math.evaluate('0b1.1')         // 1.5
math.evaluate('0o1.4')         // 1.5
math.evaluate('0x1.8')         // 1.5


Numbers can be formatted as binary, octal, and hex strings using the notation option of the format function:

math.evaluate('format(3, {notation: "bin"})')    //  '0b11'
math.evaluate('format(63, {notation: "oct"})')   //  '0o77'
math.evaluate('format(255, {notation: "hex"})')  //  '0xff'
math.evaluate('format(-1, {notation: "hex"})')   //  '-0x1'
math.evaluate('format(2.3, {notation: "hex"})')  //  '0x2.4cccccccccccc'


The format function accepts a wordSize option to use in conjunction with the non binary notations:

math.evaluate('format(-1, {notation: "hex", wordSize: 8})')   //  '0xffi8'


The functions bin, oct, and hex are shorthand for the format function with notation set accordingly:

math.evaluate('bin(-1)')     // '-0b1'
math.evaluate('bin(-1, 8)')  // '0b11111111i8'


BigNumbers #

Math.js supports BigNumbers for calculations with an arbitrary precision.
The pros and cons of Number and BigNumber are explained in detail on the page
Numbers.

BigNumbers are slower but have a higher precision. Calculations with big
numbers are supported only by arithmetic functions.

BigNumbers can be created using the bignumber function:

math.evaluate('bignumber(0.1) + bignumber(0.2)') // BigNumber, 0.3


The default number type of the expression parser can be changed at instantiation
of math.js. The expression parser parses numbers as BigNumber by default:

// Configure the type of number: 'number' (default), 'BigNumber', or 'Fraction'
math.config({number: 'BigNumber'})

// all numbers are parsed as BigNumber
math.evaluate('0.1 + 0.2')  // BigNumber, 0.3


BigNumbers can be converted to numbers and vice versa using the functions
number and bignumber. When converting a BigNumber to a Number, the high
precision of the BigNumber will be lost. When a BigNumber is too large to be represented
as Number, it will be initialized as Infinity.

Complex numbers #

Complex numbers can be created using the imaginary unit i, which is defined
as i^2 = -1. Complex numbers have a real and complex part, which can be
retrieved using the functions re and im.

const parser = math.parser()

// create complex numbers
parser.evaluate('a = 2 + 3i')   // Complex, 2 + 3i
parser.evaluate('b = 4 - i')    // Complex, 4 - i

// get real and imaginary part of a complex number
parser.evaluate('re(a)')        // Number,  2
parser.evaluate('im(a)')        // Number,  3

// calculations with complex numbers
parser.evaluate('a + b')        // Complex, 6 + 2i
parser.evaluate('a * b')        // Complex, 11 + 10i
parser.evaluate('i * i')        // Number,  -1
parser.evaluate('sqrt(-4)')     // Complex, 2i


Units #

math.js supports units. Units can be used in the arithmetic operations
add, subtract, multiply, divide, and exponentiation.
Units can also be converted from one to another.
An overview of all available units can be found on the page
Units.

Units can be converted using the operator to or in.

// create a unit
math.evaluate('5.4 kg')                     // Unit, 5.4 kg

// convert a unit
math.evaluate('2 inch to cm')               // Unit, 5.08 cm
math.evaluate('20 celsius in fahrenheit')   // Unit, ~68 fahrenheit
math.evaluate('90 km/h to m/s')             // Unit, 25 m / s

// convert a unit to a number
// A second parameter with the unit for the exported number must be provided
math.evaluate('number(5 cm, mm)')           // Number, 50

// calculations with units
math.evaluate('0.5kg + 33g')                // Unit, 0.533 kg
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('12 seconds * 2')             // Unit, 24 seconds
math.evaluate('sin(45 deg)')                // Number, 0.7071067811865475
math.evaluate('9.81 m/s^2 * 5 s to mi/h')   // Unit, 109.72172512527 mi / h


Strings #

Strings are enclosed by double quotes “ or single quotes ‘. Strings can be concatenated using the
function concat (not by adding them using + like in JavaScript). Parts of
a string can be retrieved or replaced by using indexes. Strings can be converted
to a number using function number, and numbers can be converted to a string
using function string.

When setting the value of a character in a string, the character that has been
set is returned. Likewise, when a range of characters is set, that range of
characters is returned.

const parser = math.parser()

// create a string
parser.evaluate('"hello"')                        // String, "hello"

// string manipulation
parser.evaluate('a = concat("hello", " world")')  // String, "hello world"
parser.evaluate('size(a)')                        // Matrix [11]
parser.evaluate('a[1:5]')                         // String, "hello"
parser.evaluate('a[1] = "H"')                     // String, "H"
parser.evaluate('a[7:12] = "there!"')             // String, "there!"
parser.evaluate('a')                              // String, "Hello there!"

// string conversion
parser.evaluate('number("300")')                  // Number, 300
parser.evaluate('string(300)')                    // String, "300"


Strings can be used in the evaluate function, to parse expressions inside
the expression parser:

math.evaluate('evaluate("2 + 3")')  // 5


Matrices #

Matrices can be created by entering a series of values between square brackets,
elements are separated by a comma ,.
A matrix like [1, 2, 3] will create a vector, a 1-dimensional matrix with
size [3]. To create a multi-dimensional matrix, matrices can be nested into
each other. For easier creation of two-dimensional matrices, a semicolon ;
can be used to separate rows in a matrix.

// create a matrix
math.evaluate('[1, 2, 3]')                                // Matrix, size [3]
math.evaluate('[[1, 2, 3], [4, 5, 6]]')                   // Matrix, size [2, 3]
math.evaluate('[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]')     // Matrix, size [2, 2, 2]

// create a two dimensional matrix
math.evaluate('[1, 2, 3; 4, 5, 6]')                       // Matrix, size [2, 3]


Another way to create filled matrices is using the functions zeros, ones,
identity, and range.

// initialize a matrix with ones or zeros
math.evaluate('zeros(3, 2)')      // Matrix, [[0, 0], [0, 0], [0, 0]],  size [3, 2]
math.evaluate('ones(3)')          // Matrix, [1, 1, 1],                 size [3]
math.evaluate('5 * ones(2, 2)')   // Matrix, [[5, 5], [5, 5]],          size [2, 2]

// create an identity matrix
math.evaluate('identity(2)')      // Matrix, [[1, 0], [0, 1]],          size [2, 2]

// create a range
math.evaluate('1:4')              // Matrix, [1, 2, 3, 4],              size [4]
math.evaluate('0:2:10')           // Matrix, [0, 2, 4, 6, 8, 10],       size [6]


A subset can be retrieved from a matrix using indexes and a subset of a matrix
can be replaced by using indexes. Indexes are enclosed in square brackets, and
contain a number or a range for each of the matrix dimensions. A range can have
its start and/or end undefined. When the start is undefined, the range will start
at 1, when the end is undefined, the range will end at the end of the matrix.

There is a context variable end available as well to denote the end of the
matrix. This variable cannot be used in multiple nested indices. In that case,
end will be resolved as the end of the innermost matrix. To solve this, 
resolving of the nested index needs to be split in two separate operations.

IMPORTANT: matrix indexes and ranges work differently from the math.js indexes
in JavaScript: They are one-based with an included upper-bound, similar to most
math applications.

parser = math.parser()

// create matrices
parser.evaluate('a = [1, 2; 3, 4]')       // Matrix, [[1, 2], [3, 4]]
parser.evaluate('b = zeros(2, 2)')        // Matrix, [[0, 0], [0, 0]]
parser.evaluate('c = 5:9')                // Matrix, [5, 6, 7, 8, 9]

// replace a subset in a matrix
parser.evaluate('b[1, 1:2] = [5, 6]')     // Matrix, [[5, 6], [0, 0]]
parser.evaluate('b[2, :] = [7, 8]')       // Matrix, [[5, 6], [7, 8]]

// perform a matrix calculation
parser.evaluate('d = a * b')              // Matrix, [[19, 22], [43, 50]]

// retrieve a subset of a matrix
parser.evaluate('d[2, 1]')                // 43
parser.evaluate('d[2, 1:end]')            // Matrix, [[43, 50]]
parser.evaluate('c[end - 1 : -1 : 2]')    // Matrix, [8, 7, 6]


Objects #

Objects in math.js work the same as in languages like JavaScript and Python.
An object is enclosed by curly brackets {, }, and contains a set of
comma separated key/value pairs. Keys and values are separated by a colon :.
Keys can be a symbol like prop or a string like "prop".

math.evaluate('{a: 2 + 1, b: 4}')         // {a: 3, b: 4}
math.evaluate('{"a": 2 + 1, "b": 4}')     // {a: 3, b: 4}


Objects can contain objects:

math.evaluate('{a: 2, b: {c: 3, d: 4}}')  // {a: 2, b: {c: 3, d: 4}}


Object properties can be retrieved or replaced using dot notation or bracket
notation. Unlike JavaScript, when setting a property value, the whole object
is returned, not the property value

let scope = {
  obj: {
    prop: 42
  }
}

// retrieve properties
math.evaluate('obj.prop', scope)          // 42
math.evaluate('obj["prop"]', scope)       // 42

// set properties (returns the whole object, not the property value!)
math.evaluate('obj.prop = 43', scope)     // {prop: 43}
math.evaluate('obj["prop"] = 43', scope)  // {prop: 43}
scope.obj                                 // {prop: 43}


Multi-line expressions #

An expression can contain multiple lines, and expressions can be spread over
multiple lines. Lines can be separated by a newline character \n or by a
semicolon ;. Output of statements followed by a semicolon will be hidden from
the output, and empty lines are ignored. The output is returned as a ResultSet,
with an entry for every visible statement.

// a multi-line expression
math.evaluate('1 * 3 \n 2 * 3 \n 3 * 3')    // ResultSet, [3, 6, 9]

// semicolon statements are hidden from the output
math.evaluate('a=3; b=4; a + b \n a * b')   // ResultSet, [7, 12]

// single expression spread over multiple lines
math.evaluate('a = 2 +\n  3')               // 5
math.evaluate('[\n  1, 2;\n  3, 4\n]')      // Matrix, [[1, 2], [3, 4]]


The results can be read from a ResultSet via the property ResultSet.entries
which is an Array, or by calling ResultSet.valueOf(), which returns the
array with results.

Implicit multiplication #

Implicit multiplication means the multiplication of two symbols, numbers, or a grouped expression inside parentheses without using the * operator. This type of syntax allows a more natural way to enter expressions. For example:

math.evaluate('2 pi')         // 6.283185307179586
math.evaluate('(1+2)(3+4)')   // 21


Parentheses are parsed as a function call when there is a symbol or accessor on
the left hand side, like sqrt(4) or obj.method(4). In other cases the
parentheses are interpreted as an implicit multiplication.

Math.js will always evaluate implicit multiplication before explicit multiplication *, so that the expression x * y z is parsed as x * (y * z). Math.js also gives implicit multiplication higher precedence than division, except when the division matches the pattern [unaryPrefixOp]?[number] / [number] [symbol] or [unaryPrefixOp]?[number] / [number] [left paren]. In that special case, the division is evaluated first:

math.evaluate('20 kg / 4 kg')   // 5      Evaluated as (20 kg) / (4 kg)
math.evaluate('20 / 4 kg')      // 5 kg   Evaluated as (20 / 4) kg


The behavior of implicit multiplication can be summarized by these operator precedence rules, listed from highest to lowest precedence:


  Function calls: [symbol] [left paren]
  Explicit division / when the division matches this pattern: [+-~]?[number] / [+-~]?[number] [symbol] or [number] / [number] [left paren]
  Implicit multiplication
  All other division / and multiplication *


Implicit multiplication is tricky as there can appear to be ambiguity in how an expression will be evaluated. Experience has shown that the above rules most closely match user intent when entering expressions that could be interpreted different ways. It’s also possible that these rules could be tweaked in future major releases.  Use implicit multiplication carefully. If you don’t like the uncertainty introduced by implicit multiplication, use explicit * operators and parentheses to ensure your expression is evaluated the way you intend.

Here are some more examples using implicit multiplication:


  
    
      Expression
      Evaluated as
      Result
    
  
  
    
      (1 + 3) pi
      (1 + 3) * pi
      12.566370614359172
    
    
      (4 - 1) 2
      (4 - 1) * 2
      6
    
    
      3 / 4 mm
      (3 / 4) * mm
      0.75 mm
    
    
      2 + 3 i
      2 + (3 * i)
      2 + 3i
    
    
      (1 + 2) (4 - 2)
      (1 + 2) * (4 - 2)
      6
    
    
      sqrt(4) (1 + 2)
      sqrt(4) * (1 + 2)
      6
    
    
      8 pi / 2 pi
      (8 * pi) / (2 * pi)
      4
    
    
      pi / 2 pi
      pi / (2 * pi)
      0.5
    
    
      1 / 2i
      (1 / 2) * i
      0.5 i
    
    
      8.314 J / mol K
      8.314 J / (mol * K)
      8.314 J / (mol * K)
    
  


Comments #

Comments can be added to explain or describe calculations in the text. A comment
starts with a sharp sign character #, and ends at the end of the line. A line
can contain a comment only, or can contain an expression followed by a comment.

const parser = math.parser()

parser.evaluate('# define some variables')
parser.evaluate('width = 3')                              // 3
parser.evaluate('height = 4')                             // 4
parser.evaluate('width * height   # calculate the area')  // 12\n\n\n\nExpression syntax #

This page describes the syntax of expression parser of math.js. It describes
how to work with the available data types, functions, operators, variables,
and more.

Differences from JavaScript #

The expression parser of math.js is aimed at a mathematical audience,
not a programming audience. The syntax is similar to most calculators and
mathematical applications. This is close to JavaScript as well, though there
are a few important differences between the syntax of the expression parser and
the lower level syntax of math.js. Differences are:


  No need to prefix functions and constants with the math.* namespace,
you can just enter sin(pi / 4).
  Matrix indexes are one-based instead of zero-based.
  There are index and range operators which allow more conveniently getting
and setting matrix indexes, like A[2:4, 1].
  Both indexes and ranges and have the upper-bound included.
  There is a differing syntax for defining functions. Example: f(x) = x^2.
  There are custom operators like x + y instead of add(x, y).
  Some operators are different. For example  ^ is used for exponentiation,
not bitwise xor.
  Implicit multiplication, like 2 pi, is supported and has special rules.
  Relational operators (<, >, <=, >=, ==, and !=) are chained, so the expression 5 < x < 10 is equivalent to 5 < x and x < 10.
  Multi-expression constructs like a = 1; b = 2; a + b or
"a = 1;\n cos(a)\n sin(a)" (where \n denotes newline)
produce a collection (“ResultSet”) of values. Those expressions
terminated by ; are evaluated for side effect only and their values
are suppressed from the result.


Operators #

The expression parser has operators for all common arithmetic operations such
as addition and multiplication. The expression parser uses conventional infix
notation for operators: an operator is placed between its arguments.
Round parentheses can be used to override the default precedence of operators.

// use operators
math.evaluate('2 + 3')       // 5
math.evaluate('2 * 3')       // 6

// use parentheses to override the default precedence
math.evaluate('2 + 3 * 4')   // 14
math.evaluate('(2 + 3) * 4') // 20


The following operators are available. Note that almost every operator listed
also has a function form with identical meaning that can be used
interchangeably. For example, x+y will always evaluate identically to
add(x,y). For a full list of the equivalences, see the section on
Functions below.


  
    
      Operator
      Name
      Syntax
      Associativity
      Example
      Result
    
  
  
    
      (, )
      Grouping
      (x)
      None
      2 * (3 + 4)
      14
    
    
      [, ]
      Matrix, Index
      [...]
      None
      [[1,2],[3,4]]
      [[1,2],[3,4]]
    
    
      {, }
      Object
      {...}
      None
      {a: 1, b: 2}
      {a: 1, b: 2}
    
    
      ,
      Parameter separator
      x, y
      Left to right
      max(2, 1, 5)
      5
    
    
      .
      Property accessor
      obj.prop
      Left to right
      obj={a: 12}; obj.a
      12
    
    
      ;
      Statement separator
      x; y
      Left to right
      a=2; b=3; a*b
      [6]
    
    
      ;
      Row separator
      [x; y]
      Left to right
      [1,2;3,4]
      [[1,2],[3,4]]
    
    
      \n
      Statement separator
      x \n y
      Left to right
      a=2 \n b=3 \n a*b
      [2,3,6]
    
    
      +
      Add
      x + y
      Left to right
      4 + 5
      9
    
    
      +
      Unary plus
      +y
      Right to left
      +4
      4
    
    
      -
      Subtract
      x - y
      Left to right
      7 - 3
      4
    
    
      -
      Unary minus
      -y
      Right to left
      -4
      -4
    
    
      *
      Multiply
      x * y
      Left to right
      2 * 3
      6
    
    
      .*
      Element-wise multiply
      x .* y
      Left to right
      [1,2,3] .* [1,2,3]
      [1,4,9]
    
    
      /
      Divide
      x / y
      Left to right
      6 / 2
      3
    
    
      ./
      Element-wise divide
      x ./ y
      Left to right
      [9,6,4] ./ [3,2,2]
      [3,3,2]
    
    
      %
      Percentage
      x%
      None
      8%
      0.08
    
    
      %
      Addition with Percentage
      x + y%
      Left to right
      100 + 3%
      103
    
    
      %
      Subtraction with Percentage
      x - y%
      Left to right
      100 - 3%
      97
    
    
      % mod
      Modulus
      x % y
      Left to right
      8 % 3
      2
    
    
      ^
      Power
      x ^ y
      Right to left
      2 ^ 3
      8
    
    
      .^
      Element-wise power
      x .^ y
      Right to left
      [2,3] .^ [3,3]
      [8,27]
    
    
      '
      Transpose
      y'
      Left to right
      [[1,2],[3,4]]'
      [[1,3],[2,4]]
    
    
      !
      Factorial
      y!
      Left to right
      5!
      120
    
    
      &
      Bitwise and
      x & y
      Left to right
      5 & 3
      1
    
    
      ~
      Bitwise not
      ~x
      Right to left
      ~2
      -3
    
    
      |
      Bitwise or
      x | y
      Left to right
      5 | 3
      7
    
    
      ^|
      Bitwise xor
      x ^| y
      Left to right
      5 ^| 2
      7
    
    
      <<
      Left shift
      x << y
      Left to right
      4 << 1
      8
    
    
      >>
      Right arithmetic shift
      x >> y
      Left to right
      8 >> 1
      4
    
    
      >>>
      Right logical shift
      x >>> y
      Left to right
      -8 >>> 1
      2147483644
    
    
      and
      Logical and
      x and y
      Left to right
      true and false
      false
    
    
      not
      Logical not
      not y
      Right to left
      not true
      false
    
    
      or
      Logical or
      x or y
      Left to right
      true or false
      true
    
    
      xor
      Logical xor
      x xor y
      Left to right
      true xor true
      false
    
    
      =
      Assignment
      x = y
      Right to left
      a = 5
      5
    
    
      ? :
      Conditional expression
      x ? y : z
      Right to left
      15 > 100 ? 1 : -1
      -1
    
    
      :
      Range
      x : y
      Right to left
      1:4
      [1,2,3,4]
    
    
      to, in
      Unit conversion
      x to y
      Left to right
      2 inch to cm
      5.08 cm
    
    
      ==
      Equal
      x == y
      Left to right
      2 == 4 - 2
      true
    
    
      !=
      Unequal
      x != y
      Left to right
      2 != 3
      true
    
    
      <
      Smaller
      x < y
      Left to right
      2 < 3
      true
    
    
      >
      Larger
      x > y
      Left to right
      2 > 3
      false
    
    
      <=
      Smallereq
      x <= y
      Left to right
      4 <= 3
      false
    
    
      >=
      Largereq
      x >= y
      Left to right
      2 + 4 >= 6
      true
    
  


Precedence #

The operators have the following precedence, from highest to lowest:


  
    
      Operators
      Description
    
  
  
    
      (...)[...]{...}
      GroupingMatrixObject
    
    
      x(...)x[...]obj.prop:
      Function callMatrix indexProperty accessorKey/value separator
    
    
      '
      Matrix transpose
    
    
      !
      Factorial
    
    
      ^, .^
      Exponentiation
    
    
      +, -, ~, not
      Unary plus, unary minus, bitwise not, logical not
    
    
      See section below
      Implicit multiplication
    
    
      *, /, .*, ./,%, mod
      Multiply, divide , percentage, modulus
    
    
      +, -
      Add, subtract
    
    
      :
      Range
    
    
      to, in
      Unit conversion
    
    
      <<, >>, >>>
      Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift
    
    
      ==, !=, <, >, <=, >=
      Relational
    
    
      &
      Bitwise and (lazily evaluated)
    
    
      ^|
      Bitwise xor
    
    
      |
      Bitwise or (lazily evaluated)
    
    
      and
      Logical and (lazily evaluated)
    
    
      xor
      Logical xor
    
    
      or
      Logical or (lazily evaluated)
    
    
      ?, :
      Conditional expression
    
    
      =
      Assignment
    
    
      ,
      Parameter and column separator
    
    
      ;
      Row separator
    
    
      \n, ;
      Statement separators
    
  


Lazy evaluation is used where logically possible for bitwise and logical
operators. In the following example, the value of x will not even be 
evaluated because it cannot effect the final result:
math.evaluate('false and x')        // false, no matter what x equals


Functions #

Functions are called by entering their name, followed by zero or more
arguments enclosed by parentheses. All available functions are listed on the
page Functions.

math.evaluate('sqrt(25)')           // 5
math.evaluate('log(10000, 3 + 7)')  // 4
math.evaluate('sin(pi / 4)')        // 0.7071067811865475


New functions can be defined by “assigning” an expression to a function call
with one or more variables. Such function assignments are limited: they can
only be defined on a single line.

const parser = math.parser()

parser.evaluate('f(x) = x ^ 2 - 5')
parser.evaluate('f(2)')     // -1
parser.evaluate('f(3)')     // 4

parser.evaluate('g(x, y) = x ^ y')
parser.evaluate('g(2, 3)')  // 8


Note that these function assignments do not create closures; put another way,
all free variables in mathjs are dynamic:

const parser = math.parser()

parser.evaluate('x = 7')
parser.evaluate('h(y) = x + y')
parser.evaluate('h(3)')         // 10
parser.evaluate('x = 3')
parser.evaluate('h(3)')         // 6, *not* 10


It is however possible to pass functions as parameters:

const parser = math.parser()

parser.evaluate('twice(func, x) = func(func(x))')
parser.evaluate('twice(square, 2)')    // 16
parser.evaluate('f(x) = 3*x')
parser.evaluate('twice(f, 2)')         // 18

// a simplistic "numerical derivative":
parser.evaluate('eps = 1e-10')
parser.evaluate('nd(f, x) = (f(x+eps) - func(x-eps))/(2*eps)')
parser.evaluate('nd(square,2)')        // 4.000000330961484


Math.js itself heavily uses typed functions, which ensure correct inputs and
throws meaningful errors when the input arguments are invalid. One can create
a typed-function in the
expression parser like:

const parser = math.parser()

parser.evaluate('f = typed({"number": f(x) = x ^ 2 - 5})')


Finally, as mentioned above, there is a function form for nearly every one of
the mathematical operator symbols. Moreover, for some associative operators,
the corresponding function allows arbitrarily many arguments. The table below
gives the full correspondence.


  
    
      Operator Expression
      Equivalent Function Expression
    
  
  
    
      a or b
      or(a,b)
    
    
      a xor b
      xor(a,b)
    
    
      a and b
      and(a,b)
    
    
      a \| b
      bitOr(a,b)
    
    
      a ^\| b
      bitXor(a,b)
    
    
      a & b
      bitAnd(a,b)
    
    
      a == b
      equal(a,b)
    
    
      a != b
      unequal(a,b)
    
    
      a < b
      smaller(a,b)
    
    
      a > b
      larger(a,b)
    
    
      a <= b
      smallerEq(a,b)
    
    
      a << 3
      leftShift(a,3)
    
    
      a >> 3
      rightArithShift(a,3)
    
    
      a >>> 3
      rightLogShift(a,3)
    
    
      u to cm
      to(u, cm)
    
    
      a + b + c + ...
      add(a,b,c,...)
    
    
      a - b
      subtract(a,b)
    
    
      a * b * c * ...
      multiply(a,b,c,...)
    
    
      A .* B
      dotMultiply(A,B)
    
    
      A ./ B
      dotDivide(A,B)
    
    
      a mod b
      mod(a,b)
    
    
      +a
      unaryPlus(a)
    
    
      -a
      unaryMinus(a)
    
    
      ~a
      bitNot(a)
    
    
      not a
      not(a)
    
    
      a^b
      pow(a,b)
    
    
      A .^ B
      dotPow(A,B)
    
    
      a!
      factorial(a)
    
    
      A'
      ctranspose(A)
    
  


Note that math.js embodies a preference for the operator forms, in that calling
simplify (see Algebra) converts any instances of the function
form into the corresponding operator.

Map and forEach #

The map and forEach functions can be used to apply a callback function to each element of an array or matrix.

The callback functions can be functions, typed functions, inline functions (only in the parser) or compiled inline functions (only in the parser).

The callback can have the following inputs:

  value: the current value in the array or matrix.
  index: the index of the current value expressed as an array of numbers.
  array: the array or matrix being iterated.


Below is the syntax for both functions:

map #

The map function applies a function to each element of an array and returns a new array with the results.

const parser = math.parser()

// Define a square function
parser.evaluate('square(x) = x ^ 2')

// Apply the square function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], square)')
// result: [1, 4, 9, 16]

// Apply an inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], f(x) = x ^ 2)')
// result: [1, 4, 9, 16]

// Apply a compiled inline function to each element of the array
parser.evaluate('result = map([1, 2, 3, 4], x ^ 2)')
// result: [1, 4, 9, 16]


forEach #
The forEach function applies a function to each element of an array or matrix but does not return a new array. It is useful for executing side effects.

// Define a function that prints each element
math.import({consoleLog: x => console.log(x)})
const parser = math.parser()

// Define a squareConsleLog function
parser.evaluate('squareConsoleLog(x) = consoleLog(x ^ 2)')

// Apply the squareConsleLog function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], squareConsleLog)')
// Prints: 1, 4, 9, 16

// Apply an inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], f(x) = consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16

// Apply a compiled inline function to each element of the array
parser.evaluate('forEach([1, 2, 3, 4], consoleLog(x ^ 2))')
// Prints: 1, 4, 9, 16


These functions are useful for performing element-wise operations on arrays or matrices.

Constants and variables #

Math.js has a number of built-in constants such as pi and e.
All available constants are listed on he page
Constants.

// use constants
math.evaluate('pi')                 // 3.141592653589793
math.evaluate('e ^ 2')              // 7.3890560989306495
math.evaluate('log(e)')             // 1
math.evaluate('e ^ (pi * i) + 1')   // ~0 (Euler)


Variables can be defined using the assignment operator =, and can be used
like constants.

const parser = math.parser()

// define variables
parser.evaluate('a = 3.4')      // 3.4
parser.evaluate('b = 5 / 2')    // 2.5

// use variables
parser.evaluate('a * b')        // 8.5


Variable names must:


  Begin with an “alpha character”, which is:
    
      A latin letter (upper or lower case). Ascii: a-z, A-Z
      An underscore.                        Ascii: _
      A dollar sign.                        Ascii: $
      A latin letter with accents.          Unicode: \u00C0 - \u02AF
      A greek letter.                       Unicode: \u0370 - \u03FF
      A letter-like character.              Unicode: \u2100 - \u214F
      A mathematical alphanumeric symbol.   Unicode: \u{1D400} - \u{1D7FF} excluding invalid code points
    
  
  Contain only alpha characters (above) and digits 0-9
  Not be any of the following: mod, to, in, and, xor, or, not, end. It is possible to assign to some of these, but that’s not recommended.


It is possible to customize the allowed alpha characters, see Customize supported characters for more information.

Data types #

The expression parser supports booleans, numbers, complex numbers, units,
strings, matrices, and objects.

Booleans #

Booleans true and false can be used in expressions.

// use booleans
math.evaluate('true')               // true
math.evaluate('false')              // false
math.evaluate('(2 == 3) == false')  // true


Booleans can be converted to numbers and strings and vice versa using the
functions number and boolean, and string.

// convert booleans
math.evaluate('number(true)')       // 1
math.evaluate('string(false)')      // "false"
math.evaluate('boolean(1)')         // true
math.evaluate('boolean("false")')   // false


Numbers #

The most important and basic data type in math.js are numbers. Numbers use a
point as decimal mark. Numbers can be entered with exponential notation.
Examples:

// numbers in math.js
math.evaluate('2')        // 2
math.evaluate('3.14')     // 3.14
math.evaluate('1.4e3')    // 1400
math.evaluate('22e-3')    // 0.022


A number can be converted to a string and vice versa using the functions
number and string.

// convert a string into a number
math.evaluate('number("2.3")')    // 2.3
math.evaluate('string(2.3)')      // "2.3"


Math.js uses regular JavaScript numbers, which are floating points with a
limited precision and limited range. The limitations are described in detail
on the page Numbers.

math.evaluate('1e-325')   // 0
math.evaluate('1e309')    // Infinity
math.evaluate('-1e309')   // -Infinity


When doing calculations with floats, one can very easily get round-off errors:

// round-off error due to limited floating point precision
math.evaluate('0.1 + 0.2')  // 0.30000000000000004


When outputting results, the function math.format can be used to hide
these round-off errors when outputting results for the user:

const ans = math.evaluate('0.1 + 0.2')  //  0.30000000000000004
math.format(ans, {precision: 14})       // "0.3"


Numbers can be expressed as binary, octal, and hexadecimal literals:

math.evaluate('0b11')  //  3
math.evaluate('0o77')  //  63
math.evaluate('0xff')  //  255


A word size suffix can be used to change the behavior of non decimal literal evaluation:

math.evaluate('0xffi8')         // -1
math.evaluate('0xffffffffi32')  //  -1
math.evaluate('0xfffffffffi32') //  SyntaxError: String "0xfffffffff" is out of range


Non decimal numbers can include a radix point:
math.evaluate('0b1.1')         // 1.5
math.evaluate('0o1.4')         // 1.5
math.evaluate('0x1.8')         // 1.5


Numbers can be formatted as binary, octal, and hex strings using the notation option of the format function:

math.evaluate('format(3, {notation: "bin"})')    //  '0b11'
math.evaluate('format(63, {notation: "oct"})')   //  '0o77'
math.evaluate('format(255, {notation: "hex"})')  //  '0xff'
math.evaluate('format(-1, {notation: "hex"})')   //  '-0x1'
math.evaluate('format(2.3, {notation: "hex"})')  //  '0x2.4cccccccccccc'


The format function accepts a wordSize option to use in conjunction with the non binary notations:

math.evaluate('format(-1, {notation: "hex", wordSize: 8})')   //  '0xffi8'


The functions bin, oct, and hex are shorthand for the format function with notation set accordingly:

math.evaluate('bin(-1)')     // '-0b1'
math.evaluate('bin(-1, 8)')  // '0b11111111i8'


BigNumbers #

Math.js supports BigNumbers for calculations with an arbitrary precision.
The pros and cons of Number and BigNumber are explained in detail on the page
Numbers.

BigNumbers are slower but have a higher precision. Calculations with big
numbers are supported only by arithmetic functions.

BigNumbers can be created using the bignumber function:

math.evaluate('bignumber(0.1) + bignumber(0.2)') // BigNumber, 0.3


The default number type of the expression parser can be changed at instantiation
of math.js. The expression parser parses numbers as BigNumber by default:

// Configure the type of number: 'number' (default), 'BigNumber', or 'Fraction'
math.config({number: 'BigNumber'})

// all numbers are parsed as BigNumber
math.evaluate('0.1 + 0.2')  // BigNumber, 0.3


BigNumbers can be converted to numbers and vice versa using the functions
number and bignumber. When converting a BigNumber to a Number, the high
precision of the BigNumber will be lost. When a BigNumber is too large to be represented
as Number, it will be initialized as Infinity.

Complex numbers #

Complex numbers can be created using the imaginary unit i, which is defined
as i^2 = -1. Complex numbers have a real and complex part, which can be
retrieved using the functions re and im.

const parser = math.parser()

// create complex numbers
parser.evaluate('a = 2 + 3i')   // Complex, 2 + 3i
parser.evaluate('b = 4 - i')    // Complex, 4 - i

// get real and imaginary part of a complex number
parser.evaluate('re(a)')        // Number,  2
parser.evaluate('im(a)')        // Number,  3

// calculations with complex numbers
parser.evaluate('a + b')        // Complex, 6 + 2i
parser.evaluate('a * b')        // Complex, 11 + 10i
parser.evaluate('i * i')        // Number,  -1
parser.evaluate('sqrt(-4)')     // Complex, 2i


Units #

math.js supports units. Units can be used in the arithmetic operations
add, subtract, multiply, divide, and exponentiation.
Units can also be converted from one to another.
An overview of all available units can be found on the page
Units.

Units can be converted using the operator to or in.

// create a unit
math.evaluate('5.4 kg')                     // Unit, 5.4 kg

// convert a unit
math.evaluate('2 inch to cm')               // Unit, 5.08 cm
math.evaluate('20 celsius in fahrenheit')   // Unit, ~68 fahrenheit
math.evaluate('90 km/h to m/s')             // Unit, 25 m / s

// convert a unit to a number
// A second parameter with the unit for the exported number must be provided
math.evaluate('number(5 cm, mm)')           // Number, 50

// calculations with units
math.evaluate('0.5kg + 33g')                // Unit, 0.533 kg
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('3 inch + 2 cm')              // Unit, 3.7874 inch
math.evaluate('12 seconds * 2')             // Unit, 24 seconds
math.evaluate('sin(45 deg)')                // Number, 0.7071067811865475
math.evaluate('9.81 m/s^2 * 5 s to mi/h')   // Unit, 109.72172512527 mi / h


Strings #

Strings are enclosed by double quotes “ or single quotes ‘. Strings can be concatenated using the
function concat (not by adding them using + like in JavaScript). Parts of
a string can be retrieved or replaced by using indexes. Strings can be converted
to a number using function number, and numbers can be converted to a string
using function string.

When setting the value of a character in a string, the character that has been
set is returned. Likewise, when a range of characters is set, that range of
characters is returned.

const parser = math.parser()

// create a string
parser.evaluate('"hello"')                        // String, "hello"

// string manipulation
parser.evaluate('a = concat("hello", " world")')  // String, "hello world"
parser.evaluate('size(a)')                        // Matrix [11]
parser.evaluate('a[1:5]')                         // String, "hello"
parser.evaluate('a[1] = "H"')                     // String, "H"
parser.evaluate('a[7:12] = "there!"')             // String, "there!"
parser.evaluate('a')                              // String, "Hello there!"

// string conversion
parser.evaluate('number("300")')                  // Number, 300
parser.evaluate('string(300)')                    // String, "300"


Strings can be used in the evaluate function, to parse expressions inside
the expression parser:

math.evaluate('evaluate("2 + 3")')  // 5


Matrices #

Matrices can be created by entering a series of values between square brackets,
elements are separated by a comma ,.
A matrix like [1, 2, 3] will create a vector, a 1-dimensional matrix with
size [3]. To create a multi-dimensional matrix, matrices can be nested into
each other. For easier creation of two-dimensional matrices, a semicolon ;
can be used to separate rows in a matrix.

// create a matrix
math.evaluate('[1, 2, 3]')                                // Matrix, size [3]
math.evaluate('[[1, 2, 3], [4, 5, 6]]')                   // Matrix, size [2, 3]
math.evaluate('[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]')     // Matrix, size [2, 2, 2]

// create a two dimensional matrix
math.evaluate('[1, 2, 3; 4, 5, 6]')                       // Matrix, size [2, 3]


Another way to create filled matrices is using the functions zeros, ones,
identity, and range.

// initialize a matrix with ones or zeros
math.evaluate('zeros(3, 2)')      // Matrix, [[0, 0], [0, 0], [0, 0]],  size [3, 2]
math.evaluate('ones(3)')          // Matrix, [1, 1, 1],                 size [3]
math.evaluate('5 * ones(2, 2)')   // Matrix, [[5, 5], [5, 5]],          size [2, 2]

// create an identity matrix
math.evaluate('identity(2)')      // Matrix, [[1, 0], [0, 1]],          size [2, 2]

// create a range
math.evaluate('1:4')              // Matrix, [1, 2, 3, 4],              size [4]
math.evaluate('0:2:10')           // Matrix, [0, 2, 4, 6, 8, 10],       size [6]


A subset can be retrieved from a matrix using indexes and a subset of a matrix
can be replaced by using indexes. Indexes are enclosed in square brackets, and
contain a number or a range for each of the matrix dimensions. A range can have
its start and/or end undefined. When the start is undefined, the range will start
at 1, when the end is undefined, the range will end at the end of the matrix.

There is a context variable end available as well to denote the end of the
matrix. This variable cannot be used in multiple nested indices. In that case,
end will be resolved as the end of the innermost matrix. To solve this, 
resolving of the nested index needs to be split in two separate operations.

IMPORTANT: matrix indexes and ranges work differently from the math.js indexes
in JavaScript: They are one-based with an included upper-bound, similar to most
math applications.

parser = math.parser()

// create matrices
parser.evaluate('a = [1, 2; 3, 4]')       // Matrix, [[1, 2], [3, 4]]
parser.evaluate('b = zeros(2, 2)')        // Matrix, [[0, 0], [0, 0]]
parser.evaluate('c = 5:9')                // Matrix, [5, 6, 7, 8, 9]

// replace a subset in a matrix
parser.evaluate('b[1, 1:2] = [5, 6]')     // Matrix, [[5, 6], [0, 0]]
parser.evaluate('b[2, :] = [7, 8]')       // Matrix, [[5, 6], [7, 8]]

// perform a matrix calculation
parser.evaluate('d = a * b')              // Matrix, [[19, 22], [43, 50]]

// retrieve a subset of a matrix
parser.evaluate('d[2, 1]')                // 43
parser.evaluate('d[2, 1:end]')            // Matrix, [[43, 50]]
parser.evaluate('c[end - 1 : -1 : 2]')    // Matrix, [8, 7, 6]


Objects #

Objects in math.js work the same as in languages like JavaScript and Python.
An object is enclosed by curly brackets {, }, and contains a set of
comma separated key/value pairs. Keys and values are separated by a colon :.
Keys can be a symbol like prop or a string like "prop".

math.evaluate('{a: 2 + 1, b: 4}')         // {a: 3, b: 4}
math.evaluate('{"a": 2 + 1, "b": 4}')     // {a: 3, b: 4}


Objects can contain objects:

math.evaluate('{a: 2, b: {c: 3, d: 4}}')  // {a: 2, b: {c: 3, d: 4}}


Object properties can be retrieved or replaced using dot notation or bracket
notation. Unlike JavaScript, when setting a property value, the whole object
is returned, not the property value

let scope = {
  obj: {
    prop: 42
  }
}

// retrieve properties
math.evaluate('obj.prop', scope)          // 42
math.evaluate('obj["prop"]', scope)       // 42

// set properties (returns the whole object, not the property value!)
math.evaluate('obj.prop = 43', scope)     // {prop: 43}
math.evaluate('obj["prop"] = 43', scope)  // {prop: 43}
scope.obj                                 // {prop: 43}


Multi-line expressions #

An expression can contain multiple lines, and expressions can be spread over
multiple lines. Lines can be separated by a newline character \n or by a
semicolon ;. Output of statements followed by a semicolon will be hidden from
the output, and empty lines are ignored. The output is returned as a ResultSet,
with an entry for every visible statement.

// a multi-line expression
math.evaluate('1 * 3 \n 2 * 3 \n 3 * 3')    // ResultSet, [3, 6, 9]

// semicolon statements are hidden from the output
math.evaluate('a=3; b=4; a + b \n a * b')   // ResultSet, [7, 12]

// single expression spread over multiple lines
math.evaluate('a = 2 +\n  3')               // 5
math.evaluate('[\n  1, 2;\n  3, 4\n]')      // Matrix, [[1, 2], [3, 4]]


The results can be read from a ResultSet via the property ResultSet.entries
which is an Array, or by calling ResultSet.valueOf(), which returns the
array with results.

Implicit multiplication #

Implicit multiplication means the multiplication of two symbols, numbers, or a grouped expression inside parentheses without using the * operator. This type of syntax allows a more natural way to enter expressions. For example:

math.evaluate('2 pi')         // 6.283185307179586
math.evaluate('(1+2)(3+4)')   // 21


Parentheses are parsed as a function call when there is a symbol or accessor on
the left hand side, like sqrt(4) or obj.method(4). In other cases the
parentheses are interpreted as an implicit multiplication.

Math.js will always evaluate implicit multiplication before explicit multiplication *, so that the expression x * y z is parsed as x * (y * z). Math.js also gives implicit multiplication higher precedence than division, except when the division matches the pattern [unaryPrefixOp]?[number] / [number] [symbol] or [unaryPrefixOp]?[number] / [number] [left paren]. In that special case, the division is evaluated first:

math.evaluate('20 kg / 4 kg')   // 5      Evaluated as (20 kg) / (4 kg)
math.evaluate('20 / 4 kg')      // 5 kg   Evaluated as (20 / 4) kg


The behavior of implicit multiplication can be summarized by these operator precedence rules, listed from highest to lowest precedence:


  Function calls: [symbol] [left paren]
  Explicit division / when the division matches this pattern: [+-~]?[number] / [+-~]?[number] [symbol] or [number] / [number] [left paren]
  Implicit multiplication
  All other division / and multiplication *


Implicit multiplication is tricky as there can appear to be ambiguity in how an expression will be evaluated. Experience has shown that the above rules most closely match user intent when entering expressions that could be interpreted different ways. It’s also possible that these rules could be tweaked in future major releases.  Use implicit multiplication carefully. If you don’t like the uncertainty introduced by implicit multiplication, use explicit * operators and parentheses to ensure your expression is evaluated the way you intend.

Here are some more examples using implicit multiplication:


  
    
      Expression
      Evaluated as
      Result
    
  
  
    
      (1 + 3) pi
      (1 + 3) * pi
      12.566370614359172
    
    
      (4 - 1) 2
      (4 - 1) * 2
      6
    
    
      3 / 4 mm
      (3 / 4) * mm
      0.75 mm
    
    
      2 + 3 i
      2 + (3 * i)
      2 + 3i
    
    
      (1 + 2) (4 - 2)
      (1 + 2) * (4 - 2)
      6
    
    
      sqrt(4) (1 + 2)
      sqrt(4) * (1 + 2)
      6
    
    
      8 pi / 2 pi
      (8 * pi) / (2 * pi)
      4
    
    
      pi / 2 pi
      pi / (2 * pi)
      0.5
    
    
      1 / 2i
      (1 / 2) * i
      0.5 i
    
    
      8.314 J / mol K
      8.314 J / (mol * K)
      8.314 J / (mol * K)
    
  


Comments #

Comments can be added to explain or describe calculations in the text. A comment
starts with a sharp sign character #, and ends at the end of the line. A line
can contain a comment only, or can contain an expression followed by a comment.

const parser = math.parser()

parser.evaluate('# define some variables')
parser.evaluate('width = 3')                              // 3
parser.evaluate('height = 4')                             // 4
parser.evaluate('width * height   # calculate the area')  // 12\n\n\n\nExpression trees #

When parsing an expression via math.parse(expr), math.js generates an
expression tree and returns the root node of the tree. An expression tree can
be used to analyze, manipulate, and evaluate expressions.

Example:

const node = math.parse('sqrt(2 + x)')


In this case, the expression sqrt(2 + x) is parsed as:

  FunctionNode    sqrt
                   |
  OperatorNode     +
                  / \
  ConstantNode   2   x   SymbolNode


Alternatively, this expression tree can be built by manually creating nodes:

const node1 = new math.ConstantNode(2)
const node2 = new math.SymbolNode('x')
const node3 = new math.OperatorNode('+', 'add', [node1, node2])
const node4 = new math.FunctionNode('sqrt', [node3])


The resulting expression tree with root node node4 is equal to the expression
tree generated by math.parse('sqrt(2 + x)').

API #

Methods #

All nodes have the following methods:


  
    clone() : Node

    Create a shallow clone of the node.
The node itself is cloned, its childs are not cloned.
  
  
    cloneDeep() : Node

    Create a deep clone of the node.
Both the node as well as all its childs are cloned recursively.
  
  
    compile() : Object

    Compile an expression into optimized JavaScript code. compile returns an
object with a function evaluate([scope]) to evaluate. Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const code = node.compile()        // returns {evaluate: function (scope) {...}}
const evaluate = code.evaluate({x: 3}) // returns 5
    
  
  
    evaluate([scope]) : Object

    Compile and evaluate an expression, this is the equivalent of doing
node.compile().evaluate(scope). Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const evaluate = node.evaluate({x: 3}) // returns 5
    
  
  
    equals(other: Node) : boolean

    Test whether this node equals an other node. Does a deep comparison of the
values of both nodes.
  
  
    filter(callback: function) : Node[]

    Recursively filter nodes in an expression tree. The callback function is
called as callback(node: Node, path: string, parent: Node) : boolean for
every node in the tree, and must return a boolean. The function filter
returns an array with nodes for which the test returned true.
Parameter path is a string containing a relative JSON Path.

    Example:

    const node = math.parse('x^2 + x/4 + 3*y')
const filtered = node.filter(function (node) {
  return node.isSymbolNode && node.name === 'x'
})
// returns an array with two entries: two SymbolNodes 'x'
    
  
  
    forEach(callback: function) : void

    Execute a callback for each of the child nodes of this node. The callback
function is called as callback(child: Node, path: string, parent: Node): void.
Parameter path is a string containing a relative JSON Path.

    See also traverse, which is a recursive version of forEach.

    Example:

    const node = math.parse('3 * x + 2')
node.forEach(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode *
//   ConstantNode 2
    
  
  
    map(callback: function) : Node[]

    Transform a node. Creates a new Node having it’s childs be the results of
calling the provided callback function for each of the childs of the original
node. The callback function is called as callback(child: Node, path: string,
parent: Node) and must return a Node. Parameter path is a string containing
a relative JSON Path.

    See also transform, which is a recursive version of map.
  
  
    toHTML(options: object): string

    Get a HTML representation of the parsed expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toHTML()
// returns
// <span class="math-function">sqrt</span>
// <span class="math-paranthesis math-round-parenthesis">(</span>
// <span class="math-number">2</span>
// <span class="math-operator math-binary-operator math-explicit-binary-operator">/</span>
// <span class="math-number">3</span>
// <span class="math-paranthesis math-round-parenthesis">)</span>
    

    Information about the available HTML classes in HTML Classes.
Information about the options in Customization.
  
  
    toString(options: object) : string

    Get a string representation of the parsed expression. This is not exactly
the same as the original input. Example:

    const node = math.parse('3+4*2')
node.toString()  // returns '3 + (4 * 2)'
    

    Information about the options in Customization.
  
  
    toTex(options: object): string

    Get a LaTeX representation of the
expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toTex() // returns ' qrt{\frac{2}{3}}'
    

    Information about the options in Customization.
  
  
    transform(callback: function)

    Recursively transform an expression tree via a transform function. Similar
to Array.map, but recursively executed on all nodes in the expression tree.
The callback function is a mapping function accepting a node, and returning
a replacement for the node or the original node. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree, and must return a Node. Parameter path is a string containing
a relative JSON Path.

    The transform function will stop iterating when a node is replaced by the
callback function, it will not iterate over replaced nodes.

    For example, to replace all nodes of type SymbolNode having name ‘x’ with a
ConstantNode with value 3:

    const node = math.parse('x^2 + 5*x')
const transformed = node.transform(function (node, path, parent) {
  if (node.isSymbolNode && node.name === 'x') {
    return new math.ConstantNode(3)
  }
  else {
    return node
  }
})
transformed.toString() // returns '3 ^ 2 + 5 * 3'
    
  
  
    traverse(callback: function): void

    Recursively traverse all nodes in a node tree. Executes given callback for
this node and each of its child nodes. Similar to Array.forEach, except
recursive.
The callback function is a mapping function accepting a node, and returning
nothing. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree. Parameter path is a string containing a relative JSON Path.
Example:

    const node = math.parse('3 * x + 2')
node.traverse(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode +
//   OperatorNode *
//   ConstantNode 3
//   SymbolNode x
//   ConstantNode 2
    
  


Properties #

Each Node has the following properties:


  
    comment: string

    A string holding a comment if there was any in the expression, or else the
string will be empty string. A comment can be attached to the root node of
an expression or to each of the childs nodes of a BlockNode.
  
  
    isNode: true

    Is defined with value true on Nodes. Additionally, each type of node
adds it’s own flag, for example a SymbolNode as has a property
isSymbolNode: true.
  
  
    type: string

    The type of the node, for example 'SymbolNode' in case of a SymbolNode.
  


Nodes #

math.js has the following types of nodes. All nodes are available at the
namespace math.

AccessorNode #

Construction:

new AccessorNode(object: Node, index: IndexNode)


Properties:


  object: Node
  index: IndexNode
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a[3]')

const object = new math.SymbolNode('a')
const constant3 = new math.ConstantNode(3)
const index = new math.IndexNode([constant3])
const node2 = new math.AccessorNode(object, index)


ArrayNode #

Construction:

new ArrayNode(items: Node[])


Properties:


  items: Node[]


Examples:

const node1 = math.parse('[1, 2, 3]')

const one    = new math.ConstantNode(1)
const two    = new math.ConstantNode(2)
const three  = new math.ConstantNode(3)
const node2  = new math.ArrayNode([one, two, three])


AssignmentNode #

Construction:

new AssignmentNode(object: SymbolNode, value: Node)
new AssignmentNode(object: SymbolNode | AccessorNode, index: IndexNode, value: Node)


Properties:


  object: SymbolNode | AccessorNode
  index: IndexNode | null
  value: Node
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a = 3')

const object = new math.SymbolNode('a')
const value = new math.ConstantNode(3)
const node2 = new math.AssignmentNode(object, value)


BlockNode #

A BlockNode is created when parsing a multi line expression like a=2;b=3 or
a=2\nb=3. Evaluating a BlockNode returns a ResultSet. The results can be
retrieved via ResultSet.entries or ResultSet.valueOf(), which contains
an Array with the results of the visible lines (i.e. lines not ending with
a semicolon).

Construction:

block = new BlockNode(Array.<{node: Node} | {node: Node, visible: boolean}>)


Properties:


  blocks: Array.<{node: Node, visible: boolean}>


Examples:

const block1 = math.parse('a=1; b=2; c=3')

const a = new math.SymbolNode('a')
const one = new math.ConstantNode(1)
const ass1 = new math.AssignmentNode(a, one)

const b = new math.SymbolNode('b')
const two = new math.ConstantNode(2)
const ass2 = new math.AssignmentNode(b, two)

const c = new math.SymbolNode('c')
const three = new math.ConstantNode(3)
const ass3 = new math.AssignmentNode(c, three)

const block2 = new BlockNode([
  {node: ass1, visible: false},
  {node: ass2, visible: false},
  {node: ass3, visible: true}
])


ConditionalNode #

Construction:

new ConditionalNode(condition: Node, trueExpr: Node, falseExpr: Node)


Properties:


  condition: Node
  trueExpr: Node
  falseExpr: Node


Examples:

const node1 = math.parse('a > 0 ? a : -a')

const a         = new math.SymbolNode('a')
const zero      = new math.ConstantNode(0)
const condition = new math.OperatorNode('>', 'larger', [a, zero])
const trueExpr  = a
const falseExpr = new math.OperatorNode('-', 'unaryMinus', [a])
const node2     = new math.ConditionalNode(condition, trueExpr, falseExpr)


ConstantNode #

Construction:

new ConstantNode(value: *)


Properties:


  value: *


Examples:

const node1 = math.parse('2.4')

const node2 = new math.ConstantNode(2.4)
const node3 = new math.ConstantNode('foo')


FunctionAssignmentNode #

Construction:

new FunctionAssignmentNode(name: string, params: string[], expr: Node)


Properties:


  name: string
  params: string[]
  expr: Node


Examples:

const node1 = math.parse('f(x) = x^2')

const x      = new math.SymbolNode('x')
const two    = new math.ConstantNode(2)
const expr   = new math.OperatorNode('^', 'pow', [x, 2])
const node2  = new math.FunctionAssignmentNode('f', ['x'], expr)


FunctionNode #

Construction:

new FunctionNode(fn: Node | string, args: Node[])


Properties:


  fn: Node | string (read-only) The object or function name which to invoke.
  args: Node[]


Static functions:


  FunctionNode.onUndefinedFunction(name: string). This function is invoked when an undefined function is evaluated. By default, the function throws an exception “Undefined function x”. The function can be overwritten to customize this behavior. See also SymbolNode.onUndefinedSymbol.


Examples:

const node1 = math.parse('sqrt(4)')

const four  = new math.ConstantNode(4)
const node3 = new math.FunctionNode(new SymbolNode('sqrt'), [four])


IndexNode #

Construction:

new IndexNode(dimensions: Node[])
new IndexNode(dimensions: Node[], dotNotation: boolean)


Each dimension can be a single value, a range, or a property. The values of
indices are one-based, including range end.

An optional property dotNotation can be provided describing whether this index
was written using dot notation like a.b, or using bracket notation
like a["b"]. Default value is false. This information is used when
stringifying the IndexNode.

Properties:


  dimensions: Node[]
  dotNotation: boolean


Examples:

const node1 = math.parse('A[1:3, 2]')

const A     = new math.SymbolNode('A')
const one   = new math.ConstantNode(1)
const two   = new math.ConstantNode(2)
const three = new math.ConstantNode(3)

const range = new math.RangeNode(one, three)
const index = new math.IndexNode([range, two])
const node2 = new math.AccessorNode(A, index)


ObjectNode #

Construction:

new ObjectNode(properties: Object.<string, Node>)


Properties:


  properties: Object.<string, Node>


Examples:

const node1 = math.parse('{a: 1, b: 2, c: 3}')

const a = new math.ConstantNode(1)
const b = new math.ConstantNode(2)
const c = new math.ConstantNode(3)
const node2 = new math.ObjectNode({a: a, b: b, c: c})


OperatorNode #

Construction:

new OperatorNode(op: string, fn: string, args: Node[], implicit: boolean = false)


Additional methods:


  
    isUnary() : boolean

    Returns true when the OperatorNode contains exactly one argument,
like with a unary minus:

    const a = new math.ConstantNode(2)
const b = new math.OperatorNode('-', 'unaryMinus', [a])
b.isUnary() // true
    
  
  
    isBinary() : boolean

    Returns true when the OperatorNode contains exactly two arguments,
like with most regular operators:

    const a = new math.ConstantNode(2)
const b = new math.ConstantNode(3)
const c = new math.OperatorNode('+', 'add', [a, b])
c.isBinary() // true
    
  


Properties:


  op: string
  fn: string
  args: Node[]
  implicit: boolean True in case of an implicit multiplication, false otherwise


Examples:

const node1 = math.parse('2.3 + 5')

const a     = new math.ConstantNode(2.3)
const b     = new math.ConstantNode(5)
const node2 = new math.OperatorNode('+', 'add', [a, b])


ParenthesisNode #

Construction:

new ParenthesisNode(content: Node)


Properties:


  content: Node


Examples:

const node1 = math.parse('(1)')

const a     = new math.ConstantNode(1)
const node2 = new math.ParenthesisNode(a)


RangeNode #

Construction:

new RangeNode(start: Node, end: Node [, step: Node])


Properties:


  start: Node
  end: Node
  step: Node | null


Examples:

const node1 = math.parse('1:10')
const node2 = math.parse('0:2:10')

const zero = new math.ConstantNode(0)
const one = new math.ConstantNode(1)
const two = new math.ConstantNode(2)
const ten = new math.ConstantNode(10)

const node3 = new math.RangeNode(one, ten)
const node4 = new math.RangeNode(zero, ten, two)


RelationalNode #

Construction:

new RelationalNode(conditionals: string[], params: Node[])


conditionals is an array of strings, each of which may be ‘smaller’, ‘larger’, ‘smallerEq’, ‘largerEq’, ‘equal’, or ‘unequal’. The conditionals array must contain exactly one fewer item than params.

Properties:


  conditionals: string[]
  params: Node[]


A RelationalNode efficiently represents a chained conditional expression with two or more comparison operators, such as 10 < x <= 50. The expression is equivalent to 10 < x and x <= 50, except that x is evaluated only once, and evaluation stops (is “short-circuited”) once any condition tests false. Operators that are subject to chaining are <, >, <=, >=, ==, and !=. For backward compatibility, math.parse will return an OperatorNode if only a single conditional is present (such as x > 2).

Examples:


const ten = new math.ConstantNode(10)
const x = new math.SymbolNode('x')
const fifty = new math.ConstantNode(50)

const node1 = new math.RelationalNode(['smaller', 'smallerEq'], [ten, x, fifty])
const node2 = math.parse('10 < x <= 50')


SymbolNode #

Construction:

new SymbolNode(name: string)


Properties:


  name: string


Static functions:


  SymbolNode.onUndefinedSymbol(name: string). This function is invoked when an undefined symbol is evaluated. By default, the function throws an exception “Undefined symbol x”. The function can be overwritten to customize this behavior. See also FunctionNode.onUndefinedFunction.


Examples:

const node = math.parse('x')

const x = new math.SymbolNode('x')\n\n\n\nExpression trees #

When parsing an expression via math.parse(expr), math.js generates an
expression tree and returns the root node of the tree. An expression tree can
be used to analyze, manipulate, and evaluate expressions.

Example:

const node = math.parse('sqrt(2 + x)')


In this case, the expression sqrt(2 + x) is parsed as:

  FunctionNode    sqrt
                   |
  OperatorNode     +
                  / \
  ConstantNode   2   x   SymbolNode


Alternatively, this expression tree can be built by manually creating nodes:

const node1 = new math.ConstantNode(2)
const node2 = new math.SymbolNode('x')
const node3 = new math.OperatorNode('+', 'add', [node1, node2])
const node4 = new math.FunctionNode('sqrt', [node3])


The resulting expression tree with root node node4 is equal to the expression
tree generated by math.parse('sqrt(2 + x)').

API #

Methods #

All nodes have the following methods:


  
    clone() : Node

    Create a shallow clone of the node.
The node itself is cloned, its childs are not cloned.
  
  
    cloneDeep() : Node

    Create a deep clone of the node.
Both the node as well as all its childs are cloned recursively.
  
  
    compile() : Object

    Compile an expression into optimized JavaScript code. compile returns an
object with a function evaluate([scope]) to evaluate. Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const code = node.compile()        // returns {evaluate: function (scope) {...}}
const evaluate = code.evaluate({x: 3}) // returns 5
    
  
  
    evaluate([scope]) : Object

    Compile and evaluate an expression, this is the equivalent of doing
node.compile().evaluate(scope). Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const evaluate = node.evaluate({x: 3}) // returns 5
    
  
  
    equals(other: Node) : boolean

    Test whether this node equals an other node. Does a deep comparison of the
values of both nodes.
  
  
    filter(callback: function) : Node[]

    Recursively filter nodes in an expression tree. The callback function is
called as callback(node: Node, path: string, parent: Node) : boolean for
every node in the tree, and must return a boolean. The function filter
returns an array with nodes for which the test returned true.
Parameter path is a string containing a relative JSON Path.

    Example:

    const node = math.parse('x^2 + x/4 + 3*y')
const filtered = node.filter(function (node) {
  return node.isSymbolNode && node.name === 'x'
})
// returns an array with two entries: two SymbolNodes 'x'
    
  
  
    forEach(callback: function) : void

    Execute a callback for each of the child nodes of this node. The callback
function is called as callback(child: Node, path: string, parent: Node): void.
Parameter path is a string containing a relative JSON Path.

    See also traverse, which is a recursive version of forEach.

    Example:

    const node = math.parse('3 * x + 2')
node.forEach(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode *
//   ConstantNode 2
    
  
  
    map(callback: function) : Node[]

    Transform a node. Creates a new Node having it’s childs be the results of
calling the provided callback function for each of the childs of the original
node. The callback function is called as callback(child: Node, path: string,
parent: Node) and must return a Node. Parameter path is a string containing
a relative JSON Path.

    See also transform, which is a recursive version of map.
  
  
    toHTML(options: object): string

    Get a HTML representation of the parsed expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toHTML()
// returns
// <span class="math-function">sqrt</span>
// <span class="math-paranthesis math-round-parenthesis">(</span>
// <span class="math-number">2</span>
// <span class="math-operator math-binary-operator math-explicit-binary-operator">/</span>
// <span class="math-number">3</span>
// <span class="math-paranthesis math-round-parenthesis">)</span>
    

    Information about the available HTML classes in HTML Classes.
Information about the options in Customization.
  
  
    toString(options: object) : string

    Get a string representation of the parsed expression. This is not exactly
the same as the original input. Example:

    const node = math.parse('3+4*2')
node.toString()  // returns '3 + (4 * 2)'
    

    Information about the options in Customization.
  
  
    toTex(options: object): string

    Get a LaTeX representation of the
expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toTex() // returns ' qrt{\frac{2}{3}}'
    

    Information about the options in Customization.
  
  
    transform(callback: function)

    Recursively transform an expression tree via a transform function. Similar
to Array.map, but recursively executed on all nodes in the expression tree.
The callback function is a mapping function accepting a node, and returning
a replacement for the node or the original node. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree, and must return a Node. Parameter path is a string containing
a relative JSON Path.

    The transform function will stop iterating when a node is replaced by the
callback function, it will not iterate over replaced nodes.

    For example, to replace all nodes of type SymbolNode having name ‘x’ with a
ConstantNode with value 3:

    const node = math.parse('x^2 + 5*x')
const transformed = node.transform(function (node, path, parent) {
  if (node.isSymbolNode && node.name === 'x') {
    return new math.ConstantNode(3)
  }
  else {
    return node
  }
})
transformed.toString() // returns '3 ^ 2 + 5 * 3'
    
  
  
    traverse(callback: function): void

    Recursively traverse all nodes in a node tree. Executes given callback for
this node and each of its child nodes. Similar to Array.forEach, except
recursive.
The callback function is a mapping function accepting a node, and returning
nothing. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree. Parameter path is a string containing a relative JSON Path.
Example:

    const node = math.parse('3 * x + 2')
node.traverse(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode +
//   OperatorNode *
//   ConstantNode 3
//   SymbolNode x
//   ConstantNode 2
    
  


Properties #

Each Node has the following properties:


  
    comment: string

    A string holding a comment if there was any in the expression, or else the
string will be empty string. A comment can be attached to the root node of
an expression or to each of the childs nodes of a BlockNode.
  
  
    isNode: true

    Is defined with value true on Nodes. Additionally, each type of node
adds it’s own flag, for example a SymbolNode as has a property
isSymbolNode: true.
  
  
    type: string

    The type of the node, for example 'SymbolNode' in case of a SymbolNode.
  


Nodes #

math.js has the following types of nodes. All nodes are available at the
namespace math.

AccessorNode #

Construction:

new AccessorNode(object: Node, index: IndexNode)


Properties:


  object: Node
  index: IndexNode
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a[3]')

const object = new math.SymbolNode('a')
const constant3 = new math.ConstantNode(3)
const index = new math.IndexNode([constant3])
const node2 = new math.AccessorNode(object, index)


ArrayNode #

Construction:

new ArrayNode(items: Node[])


Properties:


  items: Node[]


Examples:

const node1 = math.parse('[1, 2, 3]')

const one    = new math.ConstantNode(1)
const two    = new math.ConstantNode(2)
const three  = new math.ConstantNode(3)
const node2  = new math.ArrayNode([one, two, three])


AssignmentNode #

Construction:

new AssignmentNode(object: SymbolNode, value: Node)
new AssignmentNode(object: SymbolNode | AccessorNode, index: IndexNode, value: Node)


Properties:


  object: SymbolNode | AccessorNode
  index: IndexNode | null
  value: Node
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a = 3')

const object = new math.SymbolNode('a')
const value = new math.ConstantNode(3)
const node2 = new math.AssignmentNode(object, value)


BlockNode #

A BlockNode is created when parsing a multi line expression like a=2;b=3 or
a=2\nb=3. Evaluating a BlockNode returns a ResultSet. The results can be
retrieved via ResultSet.entries or ResultSet.valueOf(), which contains
an Array with the results of the visible lines (i.e. lines not ending with
a semicolon).

Construction:

block = new BlockNode(Array.<{node: Node} | {node: Node, visible: boolean}>)


Properties:


  blocks: Array.<{node: Node, visible: boolean}>


Examples:

const block1 = math.parse('a=1; b=2; c=3')

const a = new math.SymbolNode('a')
const one = new math.ConstantNode(1)
const ass1 = new math.AssignmentNode(a, one)

const b = new math.SymbolNode('b')
const two = new math.ConstantNode(2)
const ass2 = new math.AssignmentNode(b, two)

const c = new math.SymbolNode('c')
const three = new math.ConstantNode(3)
const ass3 = new math.AssignmentNode(c, three)

const block2 = new BlockNode([
  {node: ass1, visible: false},
  {node: ass2, visible: false},
  {node: ass3, visible: true}
])


ConditionalNode #

Construction:

new ConditionalNode(condition: Node, trueExpr: Node, falseExpr: Node)


Properties:


  condition: Node
  trueExpr: Node
  falseExpr: Node


Examples:

const node1 = math.parse('a > 0 ? a : -a')

const a         = new math.SymbolNode('a')
const zero      = new math.ConstantNode(0)
const condition = new math.OperatorNode('>', 'larger', [a, zero])
const trueExpr  = a
const falseExpr = new math.OperatorNode('-', 'unaryMinus', [a])
const node2     = new math.ConditionalNode(condition, trueExpr, falseExpr)


ConstantNode #

Construction:

new ConstantNode(value: *)


Properties:


  value: *


Examples:

const node1 = math.parse('2.4')

const node2 = new math.ConstantNode(2.4)
const node3 = new math.ConstantNode('foo')


FunctionAssignmentNode #

Construction:

new FunctionAssignmentNode(name: string, params: string[], expr: Node)


Properties:


  name: string
  params: string[]
  expr: Node


Examples:

const node1 = math.parse('f(x) = x^2')

const x      = new math.SymbolNode('x')
const two    = new math.ConstantNode(2)
const expr   = new math.OperatorNode('^', 'pow', [x, 2])
const node2  = new math.FunctionAssignmentNode('f', ['x'], expr)


FunctionNode #

Construction:

new FunctionNode(fn: Node | string, args: Node[])


Properties:


  fn: Node | string (read-only) The object or function name which to invoke.
  args: Node[]


Static functions:


  FunctionNode.onUndefinedFunction(name: string). This function is invoked when an undefined function is evaluated. By default, the function throws an exception “Undefined function x”. The function can be overwritten to customize this behavior. See also SymbolNode.onUndefinedSymbol.


Examples:

const node1 = math.parse('sqrt(4)')

const four  = new math.ConstantNode(4)
const node3 = new math.FunctionNode(new SymbolNode('sqrt'), [four])


IndexNode #

Construction:

new IndexNode(dimensions: Node[])
new IndexNode(dimensions: Node[], dotNotation: boolean)


Each dimension can be a single value, a range, or a property. The values of
indices are one-based, including range end.

An optional property dotNotation can be provided describing whether this index
was written using dot notation like a.b, or using bracket notation
like a["b"]. Default value is false. This information is used when
stringifying the IndexNode.

Properties:


  dimensions: Node[]
  dotNotation: boolean


Examples:

const node1 = math.parse('A[1:3, 2]')

const A     = new math.SymbolNode('A')
const one   = new math.ConstantNode(1)
const two   = new math.ConstantNode(2)
const three = new math.ConstantNode(3)

const range = new math.RangeNode(one, three)
const index = new math.IndexNode([range, two])
const node2 = new math.AccessorNode(A, index)


ObjectNode #

Construction:

new ObjectNode(properties: Object.<string, Node>)


Properties:


  properties: Object.<string, Node>


Examples:

const node1 = math.parse('{a: 1, b: 2, c: 3}')

const a = new math.ConstantNode(1)
const b = new math.ConstantNode(2)
const c = new math.ConstantNode(3)
const node2 = new math.ObjectNode({a: a, b: b, c: c})


OperatorNode #

Construction:

new OperatorNode(op: string, fn: string, args: Node[], implicit: boolean = false)


Additional methods:


  
    isUnary() : boolean

    Returns true when the OperatorNode contains exactly one argument,
like with a unary minus:

    const a = new math.ConstantNode(2)
const b = new math.OperatorNode('-', 'unaryMinus', [a])
b.isUnary() // true
    
  
  
    isBinary() : boolean

    Returns true when the OperatorNode contains exactly two arguments,
like with most regular operators:

    const a = new math.ConstantNode(2)
const b = new math.ConstantNode(3)
const c = new math.OperatorNode('+', 'add', [a, b])
c.isBinary() // true
    
  


Properties:


  op: string
  fn: string
  args: Node[]
  implicit: boolean True in case of an implicit multiplication, false otherwise


Examples:

const node1 = math.parse('2.3 + 5')

const a     = new math.ConstantNode(2.3)
const b     = new math.ConstantNode(5)
const node2 = new math.OperatorNode('+', 'add', [a, b])


ParenthesisNode #

Construction:

new ParenthesisNode(content: Node)


Properties:


  content: Node


Examples:

const node1 = math.parse('(1)')

const a     = new math.ConstantNode(1)
const node2 = new math.ParenthesisNode(a)


RangeNode #

Construction:

new RangeNode(start: Node, end: Node [, step: Node])


Properties:


  start: Node
  end: Node
  step: Node | null


Examples:

const node1 = math.parse('1:10')
const node2 = math.parse('0:2:10')

const zero = new math.ConstantNode(0)
const one = new math.ConstantNode(1)
const two = new math.ConstantNode(2)
const ten = new math.ConstantNode(10)

const node3 = new math.RangeNode(one, ten)
const node4 = new math.RangeNode(zero, ten, two)


RelationalNode #

Construction:

new RelationalNode(conditionals: string[], params: Node[])


conditionals is an array of strings, each of which may be ‘smaller’, ‘larger’, ‘smallerEq’, ‘largerEq’, ‘equal’, or ‘unequal’. The conditionals array must contain exactly one fewer item than params.

Properties:


  conditionals: string[]
  params: Node[]


A RelationalNode efficiently represents a chained conditional expression with two or more comparison operators, such as 10 < x <= 50. The expression is equivalent to 10 < x and x <= 50, except that x is evaluated only once, and evaluation stops (is “short-circuited”) once any condition tests false. Operators that are subject to chaining are <, >, <=, >=, ==, and !=. For backward compatibility, math.parse will return an OperatorNode if only a single conditional is present (such as x > 2).

Examples:


const ten = new math.ConstantNode(10)
const x = new math.SymbolNode('x')
const fifty = new math.ConstantNode(50)

const node1 = new math.RelationalNode(['smaller', 'smallerEq'], [ten, x, fifty])
const node2 = math.parse('10 < x <= 50')


SymbolNode #

Construction:

new SymbolNode(name: string)


Properties:


  name: string


Static functions:


  SymbolNode.onUndefinedSymbol(name: string). This function is invoked when an undefined symbol is evaluated. By default, the function throws an exception “Undefined symbol x”. The function can be overwritten to customize this behavior. See also FunctionNode.onUndefinedFunction.


Examples:

const node = math.parse('x')

const x = new math.SymbolNode('x')\n\n\n\nExpression trees #

When parsing an expression via math.parse(expr), math.js generates an
expression tree and returns the root node of the tree. An expression tree can
be used to analyze, manipulate, and evaluate expressions.

Example:

const node = math.parse('sqrt(2 + x)')


In this case, the expression sqrt(2 + x) is parsed as:

  FunctionNode    sqrt
                   |
  OperatorNode     +
                  / \
  ConstantNode   2   x   SymbolNode


Alternatively, this expression tree can be built by manually creating nodes:

const node1 = new math.ConstantNode(2)
const node2 = new math.SymbolNode('x')
const node3 = new math.OperatorNode('+', 'add', [node1, node2])
const node4 = new math.FunctionNode('sqrt', [node3])


The resulting expression tree with root node node4 is equal to the expression
tree generated by math.parse('sqrt(2 + x)').

API #

Methods #

All nodes have the following methods:


  
    clone() : Node

    Create a shallow clone of the node.
The node itself is cloned, its childs are not cloned.
  
  
    cloneDeep() : Node

    Create a deep clone of the node.
Both the node as well as all its childs are cloned recursively.
  
  
    compile() : Object

    Compile an expression into optimized JavaScript code. compile returns an
object with a function evaluate([scope]) to evaluate. Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const code = node.compile()        // returns {evaluate: function (scope) {...}}
const evaluate = code.evaluate({x: 3}) // returns 5
    
  
  
    evaluate([scope]) : Object

    Compile and evaluate an expression, this is the equivalent of doing
node.compile().evaluate(scope). Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const evaluate = node.evaluate({x: 3}) // returns 5
    
  
  
    equals(other: Node) : boolean

    Test whether this node equals an other node. Does a deep comparison of the
values of both nodes.
  
  
    filter(callback: function) : Node[]

    Recursively filter nodes in an expression tree. The callback function is
called as callback(node: Node, path: string, parent: Node) : boolean for
every node in the tree, and must return a boolean. The function filter
returns an array with nodes for which the test returned true.
Parameter path is a string containing a relative JSON Path.

    Example:

    const node = math.parse('x^2 + x/4 + 3*y')
const filtered = node.filter(function (node) {
  return node.isSymbolNode && node.name === 'x'
})
// returns an array with two entries: two SymbolNodes 'x'
    
  
  
    forEach(callback: function) : void

    Execute a callback for each of the child nodes of this node. The callback
function is called as callback(child: Node, path: string, parent: Node): void.
Parameter path is a string containing a relative JSON Path.

    See also traverse, which is a recursive version of forEach.

    Example:

    const node = math.parse('3 * x + 2')
node.forEach(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode *
//   ConstantNode 2
    
  
  
    map(callback: function) : Node[]

    Transform a node. Creates a new Node having it’s childs be the results of
calling the provided callback function for each of the childs of the original
node. The callback function is called as callback(child: Node, path: string,
parent: Node) and must return a Node. Parameter path is a string containing
a relative JSON Path.

    See also transform, which is a recursive version of map.
  
  
    toHTML(options: object): string

    Get a HTML representation of the parsed expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toHTML()
// returns
// <span class="math-function">sqrt</span>
// <span class="math-paranthesis math-round-parenthesis">(</span>
// <span class="math-number">2</span>
// <span class="math-operator math-binary-operator math-explicit-binary-operator">/</span>
// <span class="math-number">3</span>
// <span class="math-paranthesis math-round-parenthesis">)</span>
    

    Information about the available HTML classes in HTML Classes.
Information about the options in Customization.
  
  
    toString(options: object) : string

    Get a string representation of the parsed expression. This is not exactly
the same as the original input. Example:

    const node = math.parse('3+4*2')
node.toString()  // returns '3 + (4 * 2)'
    

    Information about the options in Customization.
  
  
    toTex(options: object): string

    Get a LaTeX representation of the
expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toTex() // returns ' qrt{\frac{2}{3}}'
    

    Information about the options in Customization.
  
  
    transform(callback: function)

    Recursively transform an expression tree via a transform function. Similar
to Array.map, but recursively executed on all nodes in the expression tree.
The callback function is a mapping function accepting a node, and returning
a replacement for the node or the original node. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree, and must return a Node. Parameter path is a string containing
a relative JSON Path.

    The transform function will stop iterating when a node is replaced by the
callback function, it will not iterate over replaced nodes.

    For example, to replace all nodes of type SymbolNode having name ‘x’ with a
ConstantNode with value 3:

    const node = math.parse('x^2 + 5*x')
const transformed = node.transform(function (node, path, parent) {
  if (node.isSymbolNode && node.name === 'x') {
    return new math.ConstantNode(3)
  }
  else {
    return node
  }
})
transformed.toString() // returns '3 ^ 2 + 5 * 3'
    
  
  
    traverse(callback: function): void

    Recursively traverse all nodes in a node tree. Executes given callback for
this node and each of its child nodes. Similar to Array.forEach, except
recursive.
The callback function is a mapping function accepting a node, and returning
nothing. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree. Parameter path is a string containing a relative JSON Path.
Example:

    const node = math.parse('3 * x + 2')
node.traverse(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode +
//   OperatorNode *
//   ConstantNode 3
//   SymbolNode x
//   ConstantNode 2
    
  


Properties #

Each Node has the following properties:


  
    comment: string

    A string holding a comment if there was any in the expression, or else the
string will be empty string. A comment can be attached to the root node of
an expression or to each of the childs nodes of a BlockNode.
  
  
    isNode: true

    Is defined with value true on Nodes. Additionally, each type of node
adds it’s own flag, for example a SymbolNode as has a property
isSymbolNode: true.
  
  
    type: string

    The type of the node, for example 'SymbolNode' in case of a SymbolNode.
  


Nodes #

math.js has the following types of nodes. All nodes are available at the
namespace math.

AccessorNode #

Construction:

new AccessorNode(object: Node, index: IndexNode)


Properties:


  object: Node
  index: IndexNode
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a[3]')

const object = new math.SymbolNode('a')
const constant3 = new math.ConstantNode(3)
const index = new math.IndexNode([constant3])
const node2 = new math.AccessorNode(object, index)


ArrayNode #

Construction:

new ArrayNode(items: Node[])


Properties:


  items: Node[]


Examples:

const node1 = math.parse('[1, 2, 3]')

const one    = new math.ConstantNode(1)
const two    = new math.ConstantNode(2)
const three  = new math.ConstantNode(3)
const node2  = new math.ArrayNode([one, two, three])


AssignmentNode #

Construction:

new AssignmentNode(object: SymbolNode, value: Node)
new AssignmentNode(object: SymbolNode | AccessorNode, index: IndexNode, value: Node)


Properties:


  object: SymbolNode | AccessorNode
  index: IndexNode | null
  value: Node
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a = 3')

const object = new math.SymbolNode('a')
const value = new math.ConstantNode(3)
const node2 = new math.AssignmentNode(object, value)


BlockNode #

A BlockNode is created when parsing a multi line expression like a=2;b=3 or
a=2\nb=3. Evaluating a BlockNode returns a ResultSet. The results can be
retrieved via ResultSet.entries or ResultSet.valueOf(), which contains
an Array with the results of the visible lines (i.e. lines not ending with
a semicolon).

Construction:

block = new BlockNode(Array.<{node: Node} | {node: Node, visible: boolean}>)


Properties:


  blocks: Array.<{node: Node, visible: boolean}>


Examples:

const block1 = math.parse('a=1; b=2; c=3')

const a = new math.SymbolNode('a')
const one = new math.ConstantNode(1)
const ass1 = new math.AssignmentNode(a, one)

const b = new math.SymbolNode('b')
const two = new math.ConstantNode(2)
const ass2 = new math.AssignmentNode(b, two)

const c = new math.SymbolNode('c')
const three = new math.ConstantNode(3)
const ass3 = new math.AssignmentNode(c, three)

const block2 = new BlockNode([
  {node: ass1, visible: false},
  {node: ass2, visible: false},
  {node: ass3, visible: true}
])


ConditionalNode #

Construction:

new ConditionalNode(condition: Node, trueExpr: Node, falseExpr: Node)


Properties:


  condition: Node
  trueExpr: Node
  falseExpr: Node


Examples:

const node1 = math.parse('a > 0 ? a : -a')

const a         = new math.SymbolNode('a')
const zero      = new math.ConstantNode(0)
const condition = new math.OperatorNode('>', 'larger', [a, zero])
const trueExpr  = a
const falseExpr = new math.OperatorNode('-', 'unaryMinus', [a])
const node2     = new math.ConditionalNode(condition, trueExpr, falseExpr)


ConstantNode #

Construction:

new ConstantNode(value: *)


Properties:


  value: *


Examples:

const node1 = math.parse('2.4')

const node2 = new math.ConstantNode(2.4)
const node3 = new math.ConstantNode('foo')


FunctionAssignmentNode #

Construction:

new FunctionAssignmentNode(name: string, params: string[], expr: Node)


Properties:


  name: string
  params: string[]
  expr: Node


Examples:

const node1 = math.parse('f(x) = x^2')

const x      = new math.SymbolNode('x')
const two    = new math.ConstantNode(2)
const expr   = new math.OperatorNode('^', 'pow', [x, 2])
const node2  = new math.FunctionAssignmentNode('f', ['x'], expr)


FunctionNode #

Construction:

new FunctionNode(fn: Node | string, args: Node[])


Properties:


  fn: Node | string (read-only) The object or function name which to invoke.
  args: Node[]


Static functions:


  FunctionNode.onUndefinedFunction(name: string). This function is invoked when an undefined function is evaluated. By default, the function throws an exception “Undefined function x”. The function can be overwritten to customize this behavior. See also SymbolNode.onUndefinedSymbol.


Examples:

const node1 = math.parse('sqrt(4)')

const four  = new math.ConstantNode(4)
const node3 = new math.FunctionNode(new SymbolNode('sqrt'), [four])


IndexNode #

Construction:

new IndexNode(dimensions: Node[])
new IndexNode(dimensions: Node[], dotNotation: boolean)


Each dimension can be a single value, a range, or a property. The values of
indices are one-based, including range end.

An optional property dotNotation can be provided describing whether this index
was written using dot notation like a.b, or using bracket notation
like a["b"]. Default value is false. This information is used when
stringifying the IndexNode.

Properties:


  dimensions: Node[]
  dotNotation: boolean


Examples:

const node1 = math.parse('A[1:3, 2]')

const A     = new math.SymbolNode('A')
const one   = new math.ConstantNode(1)
const two   = new math.ConstantNode(2)
const three = new math.ConstantNode(3)

const range = new math.RangeNode(one, three)
const index = new math.IndexNode([range, two])
const node2 = new math.AccessorNode(A, index)


ObjectNode #

Construction:

new ObjectNode(properties: Object.<string, Node>)


Properties:


  properties: Object.<string, Node>


Examples:

const node1 = math.parse('{a: 1, b: 2, c: 3}')

const a = new math.ConstantNode(1)
const b = new math.ConstantNode(2)
const c = new math.ConstantNode(3)
const node2 = new math.ObjectNode({a: a, b: b, c: c})


OperatorNode #

Construction:

new OperatorNode(op: string, fn: string, args: Node[], implicit: boolean = false)


Additional methods:


  
    isUnary() : boolean

    Returns true when the OperatorNode contains exactly one argument,
like with a unary minus:

    const a = new math.ConstantNode(2)
const b = new math.OperatorNode('-', 'unaryMinus', [a])
b.isUnary() // true
    
  
  
    isBinary() : boolean

    Returns true when the OperatorNode contains exactly two arguments,
like with most regular operators:

    const a = new math.ConstantNode(2)
const b = new math.ConstantNode(3)
const c = new math.OperatorNode('+', 'add', [a, b])
c.isBinary() // true
    
  


Properties:


  op: string
  fn: string
  args: Node[]
  implicit: boolean True in case of an implicit multiplication, false otherwise


Examples:

const node1 = math.parse('2.3 + 5')

const a     = new math.ConstantNode(2.3)
const b     = new math.ConstantNode(5)
const node2 = new math.OperatorNode('+', 'add', [a, b])


ParenthesisNode #

Construction:

new ParenthesisNode(content: Node)


Properties:


  content: Node


Examples:

const node1 = math.parse('(1)')

const a     = new math.ConstantNode(1)
const node2 = new math.ParenthesisNode(a)


RangeNode #

Construction:

new RangeNode(start: Node, end: Node [, step: Node])


Properties:


  start: Node
  end: Node
  step: Node | null


Examples:

const node1 = math.parse('1:10')
const node2 = math.parse('0:2:10')

const zero = new math.ConstantNode(0)
const one = new math.ConstantNode(1)
const two = new math.ConstantNode(2)
const ten = new math.ConstantNode(10)

const node3 = new math.RangeNode(one, ten)
const node4 = new math.RangeNode(zero, ten, two)


RelationalNode #

Construction:

new RelationalNode(conditionals: string[], params: Node[])


conditionals is an array of strings, each of which may be ‘smaller’, ‘larger’, ‘smallerEq’, ‘largerEq’, ‘equal’, or ‘unequal’. The conditionals array must contain exactly one fewer item than params.

Properties:


  conditionals: string[]
  params: Node[]


A RelationalNode efficiently represents a chained conditional expression with two or more comparison operators, such as 10 < x <= 50. The expression is equivalent to 10 < x and x <= 50, except that x is evaluated only once, and evaluation stops (is “short-circuited”) once any condition tests false. Operators that are subject to chaining are <, >, <=, >=, ==, and !=. For backward compatibility, math.parse will return an OperatorNode if only a single conditional is present (such as x > 2).

Examples:


const ten = new math.ConstantNode(10)
const x = new math.SymbolNode('x')
const fifty = new math.ConstantNode(50)

const node1 = new math.RelationalNode(['smaller', 'smallerEq'], [ten, x, fifty])
const node2 = math.parse('10 < x <= 50')


SymbolNode #

Construction:

new SymbolNode(name: string)


Properties:


  name: string


Static functions:


  SymbolNode.onUndefinedSymbol(name: string). This function is invoked when an undefined symbol is evaluated. By default, the function throws an exception “Undefined symbol x”. The function can be overwritten to customize this behavior. See also FunctionNode.onUndefinedFunction.


Examples:

const node = math.parse('x')

const x = new math.SymbolNode('x')\n\n\n\nHTML output #

The expression parser can output a HTML string, where every Node is
transformed into a <span> element with semantic class names. Each class
name begins with the math- prefix. These class names can be used in CSS to
highlight the syntax or change the default layout (e.g. spaces around operators).

Available class names #


  math-number
  math-string
  math-boolean (true and false)
  math-undefined
  math-function (function names)
  math-parameter (function parameters)
  math-property (object members)
  math-symbol (variables, units and built-in constants)
    
      math-null-symbol (null)
      math-nan-symbol (NaN)
      math-infinity-symbol (Infinity)
      math-imaginary-symbol (i)
    
  
  math-operator
    
      math-unary-operator
        
          math-lefthand-unary-operator
          math-righthand-unary-operator
        
      
      math-binary-operator
        
          math-explicit-binary-operator
          math-implicit-binary-operator (empty element)
        
      
      math-assignment-operator
        
          math-variable-assignment-operator (=)
          math-property-assignment-operator (: in objects)
        
      
      math-accessor-operator (. in objects)
      math-range-operator (: in ranges)
    
  
  math-parenthesis
-math-round-parenthesis (( and ))
-math-square-parenthesis ([ and ])
-math-curly-parenthesis ({ and })
  math-separator (�,, ;` and <br />)\n\n\n\nCustomization #

Besides parsing and evaluating expressions, the expression parser supports
a number of features to customize processing and evaluation of expressions
and outputting expressions.

On this page:


  Function transforms
  Custom argument parsing
  Custom LaTeX handlers
  Custom HTML, LaTeX and string output
  Customize supported characters


Function transforms #

It is possible to preprocess function arguments and post process a functions
return value by writing a transform for the function. A transform is a
function wrapping around a function to be transformed or completely replaces
a function.

For example, the functions for math.js use zero-based matrix indices (as is
common in programing languages), but the expression parser uses one-based
indices. To enable this, all functions dealing with indices have a transform,
which changes input from one-based to zero-based, and transforms output (and
error message) from zero-based to one-based.

// using plain JavaScript, indices are zero-based:
const a = [[1, 2], [3, 4]]       // a 2x2 matrix
math.subset(a, math.index(0, 1)) // returns 2

// using the expression parser, indices are transformed to one-based:
const a = [[1, 2], [3, 4]] // a 2x2 matrix
let scope = {
  a: a
}
math.evaluate('subset(a, index(1, 2))', scope) // returns 2


To create a transform for a function, the transform function must be attached
to the function as property transform:

import { create, all } from 'mathjs'
const math = create(all)

// create a function
function addIt(a, b) {
  return a + b
}

// attach a transform function to the function addIt
addIt.transform = function (a, b) {
  console.log('input: a=' + a + ', b=' + b)
  // we can manipulate input here before executing addIt

  const res = addIt(a, b)

  console.log('result: ' + res)
  // we can manipulate result here before returning

  return res
}

// import the function into math.js
math.import({
  addIt: addIt
})

// use the function via the expression parser
console.log('Using expression parser:')
console.log('2+4=' + math.evaluate('addIt(2, 4)'))
// This will output:
//
//     input: a=2, b=4
//     result: 6
//     2+4=6

// when used via plain JavaScript, the transform is not invoked
console.log('')
console.log('Using plain JavaScript:')
console.log('2+4=' + math.addIt(2, 4))
// This will output:
//
//     6


Functions with a transform must be imported in the math namespace, as they
need to be processed at compile time. They are not supported when passed via a
scope at evaluation time.

Custom argument parsing #

The expression parser of math.js has support for letting functions
parse and evaluate arguments themselves, instead of calling them with
evaluated arguments. This is useful for example when creating a function
like plot(f(x), x) or integrate(f(x), x, start, end), where some of the
arguments need to be processed in a special way. In these cases, the expression
f(x) will be evaluated repeatedly by the function, and x is not evaluated
but used to specify the variable looping over the function f(x).

Functions having a property rawArgs with value true are treated in a special
way by the expression parser: they will be invoked with unevaluated arguments,
allowing the function to process the arguments in a customized way. Raw
functions are called as:

rawFunction(args: Node[], math: Object, scope: Map)


Where :


  args is an Array with nodes of the parsed arguments.
  math is the math namespace against which the expression was compiled.
  scope is a Map 
interface containing the variables defined in the scope 
passed via evaluate(scope). The passed scope is always a Map interface,
and normally a PartitionedMap is used to separate local function variables
like x in a custom defined function f(x) = rawFunction(x) ^ 2 from the 
scope variables. Note that a PartitionedMap can recursively link to another
PartitionedMap.


Raw functions must be imported in the math namespace, as they need to be
processed at compile time. They are not supported when passed via a scope
at evaluation time.

A simple example:

function myFunction(args, math, scope) {
  // get string representation of the arguments
  const str = args.map(function (arg) {
    return arg.toString()
  })

  // evaluate the arguments
  const res = args.map(function (arg) {
    return arg.compile().evaluate(scope)
  })

  return 'arguments: ' + str.join(',') + ', evaluated: ' + res.join(',')
}

// mark the function as "rawArgs", so it will be called with unevaluated arguments
myFunction.rawArgs = true

// import the new function in the math namespace
math.import({
  myFunction: myFunction
})

// use the function
math.evaluate('myFunction(2 + 3, sqrt(4))')
// returns 'arguments: 2 + 3, sqrt(4), evaluated: 5, 2'


Custom LaTeX handlers #

You can attach a toTex property to your custom functions before importing them to define their LaTeX output. This
toTex property can be a handler in the format described in the next section ‘Custom LaTeX and String conversion’
or a template string similar to ES6 templates.

Template syntax #


  ${name}: Gets replaced by the name of the function
  ${args}: Gets replaced by a comma separated list of the arguments of the function.
  ${args[0]}: Gets replaced by the first argument of a function
  $$: Gets replaced by $


Example #

const customFunctions = {
  plus: function (a, b) {
    return a + b
  },
  minus: function (a, b) {
    return a - b
  },
  binom: function (n, k) {
    return 1
  }
}

customFunctions.plus.toTex = '${args[0]}+${args[1]}' //template string
customFunctions.binom.toTex = '\\mathrm{${name}}\\left(${args}\\right)' //template string
customFunctions.minus.toTex = function (node, options) { //handler function
  return node.args[0].toTex(options) + node.name + node.args[1].toTex(options)
}

math.import(customFunctions)

math.parse('plus(1,2)').toTex()    // '1+2'
math.parse('binom(1,2)').toTex()   // '\\mathrm{binom}\\left(1,2\\right)'
math.parse('minus(1,2)').toTex()   // '1minus2'


Custom HTML, LaTeX and string output #

All expression nodes have a method toTex and toString to output an expression respectively in HTML or LaTex format or as regular text .
The functions toHTML, toTex and toString accept an options argument to customise output. This object is of the following form:

{
  parenthesis: 'keep',    // parenthesis option
  handler: someHandler,   // handler to change the output
  implicit: 'hide'        // how to treat implicit multiplication
}


Parenthesis #

The parenthesis option changes the way parentheses are used in the output. There are three options available:


  keep Keep the parentheses from the input and display them as is. This is the default.
  auto Only display parentheses that are necessary. Mathjs tries to get rid of as much parentheses as possible.
  all Display all parentheses that are given by the structure of the node tree. This makes the output precedence unambiguous.


There’s two ways of passing callbacks:


  Pass an object that maps function names to callbacks. Those callbacks will be used for FunctionNodes with
functions of that name.
  Pass a function to toTex. This function will then be used for every node.


const expression = math.parse('(1+1+1)')

expression.toString()                      // (1 + 1 + 1)
expression.toString({parenthesis: 'keep'}) // (1 + 1 + 1)
expression.toString({parenthesis: 'auto'}) // 1 + 1 + 1
expression.toString({parenthesis: 'all'})  // (1 + 1) + 1


Handler #

You can provide the toTex and toString functions of an expression with your own custom handlers that override the internal behaviour. This is especially useful to provide LaTeX/string output for your own custom functions. This can be done in two ways:


  Pass an object that maps function names to callbacks. Those callbacks will be used for FunctionNodes that contain functions with that name.
  Pass a callback directly. This callback will run for every node, so you can replace the output of anything you like.


A callback function has the following form:

function callback (node, options) {
  ...
}

Where options is the object passed to toHTML/toTex/toString. Don’t forget to pass this on to the child nodes, and node is a reference to the current node.

If a callback returns nothing, the standard output will be used. If your callback returns a string, this string will be used.

Although the following examples use toTex, it works for toString and toHTML in the same way

Examples for option 1 #

const customFunctions = {
  binomial: function (n, k) {
    //calculate n choose k
    // (do some stuff)
    return result
  }
}

const customLaTeX = {
  'binomial': function (node, options) { //provide toTex for your own custom function
    return '\\binom{' + node.args[0].toTex(options) + '}{' + node.args[1].toTex(options) + '}'
  },
  'factorial': function (node, options) { //override toTex for builtin functions
  	return 'factorial\\left(' + node.args[0] + '\\right)'
  }
}


You can simply use your custom toTex functions by passing them to toTex:

math.import(customFunctions)
const expression = math.parse('binomial(factorial(2),1)')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains "\binom{factorial\\left(2\\right)}{1}"


Examples for option 2: #

function customLaTeX(node, options) {
  if ((node.type === 'OperatorNode') && (node.fn === 'add')) {
    //don't forget to pass the options to the toTex functions
    return node.args[0].toTex(options) + ' plus ' + node.args[1].toTex(options)
  }
  else if (node.type === 'ConstantNode') {
    if (node.value === 0) {
        return '\\mbox{zero}'
    }
    else if (node.value === 1) {
        return '\\mbox{one}'
    }
    else if (node.value === 2) {
        return '\\mbox{two}'
    }
    else {
        return node.value
    }
  }
}

const expression = math.parse('1+2')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains '\mbox{one} plus \mbox{two}'


Another example in conjunction with custom functions:

const customFunctions = {
  binomial: function (n, k) {
    //calculate n choose k
    // (do some stuff)
    return result
  }
}

function customLaTeX(node, options) {
  if ((node.type === 'FunctionNode') && (node.name === 'binomial')) {
      return '\\binom{' + node.args[0].toTex(options) + '}{' + node.args[1].toTex(options) + '}'
  }
}

math.import(customFunctions)
const expression = math.parse('binomial(2,1)')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains "\binom{2}{1}"


Implicit multiplication #

You can change the way that implicit multiplication is converted to a string or LaTeX. The two options are hide, to not show a multiplication operator for implicit multiplication and show to show it.

Example:

const node = math.parse('2a')

node.toString()                   // '2 a'
node.toString({implicit: 'hide'}) // '2 a'
node.toString({implicit: 'show'}) // '2 * a'

node.toTex()                      // '2~ a'
node.toTex({implicit: 'hide'})    // '2~ a'
node.toTex({implicit: 'show'})    // '2\\cdot a'


Customize supported characters #

It is possible to customize the characters allowed in symbols and digits.
The parse function exposes the following test functions:


  math.parse.isAlpha(c, cPrev, cNext)
  math.parse.isWhitespace(c, nestingLevel)
  math.parse.isDecimalMark(c, cNext)
  math.parse.isDigitDot(c)
  math.parse.isDigit(c)


The exact signature and implementation of these functions can be looked up in
the source code of the parser. The allowed alpha characters are described here: Constants and variables.

For example, the phone character ☎ is not supported by default. It can be enabled
by replacing the isAlpha function:

const isAlphaOriginal = math.parse.isAlpha
math.parse.isAlpha = function (c, cPrev, cNext) {
  return isAlphaOriginal(c, cPrev, cNext) || (c === '\u260E')
}

// now we can use the \u260E (phone) character in expressions
const result = math.evaluate('\u260Efoo', {'\u260Efoo': 42}) // returns 42
console.log(result)\n\n\n\nExpression trees #

When parsing an expression via math.parse(expr), math.js generates an
expression tree and returns the root node of the tree. An expression tree can
be used to analyze, manipulate, and evaluate expressions.

Example:

const node = math.parse('sqrt(2 + x)')


In this case, the expression sqrt(2 + x) is parsed as:

  FunctionNode    sqrt
                   |
  OperatorNode     +
                  / \
  ConstantNode   2   x   SymbolNode


Alternatively, this expression tree can be built by manually creating nodes:

const node1 = new math.ConstantNode(2)
const node2 = new math.SymbolNode('x')
const node3 = new math.OperatorNode('+', 'add', [node1, node2])
const node4 = new math.FunctionNode('sqrt', [node3])


The resulting expression tree with root node node4 is equal to the expression
tree generated by math.parse('sqrt(2 + x)').

API #

Methods #

All nodes have the following methods:


  
    clone() : Node

    Create a shallow clone of the node.
The node itself is cloned, its childs are not cloned.
  
  
    cloneDeep() : Node

    Create a deep clone of the node.
Both the node as well as all its childs are cloned recursively.
  
  
    compile() : Object

    Compile an expression into optimized JavaScript code. compile returns an
object with a function evaluate([scope]) to evaluate. Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const code = node.compile()        // returns {evaluate: function (scope) {...}}
const evaluate = code.evaluate({x: 3}) // returns 5
    
  
  
    evaluate([scope]) : Object

    Compile and evaluate an expression, this is the equivalent of doing
node.compile().evaluate(scope). Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const evaluate = node.evaluate({x: 3}) // returns 5
    
  
  
    equals(other: Node) : boolean

    Test whether this node equals an other node. Does a deep comparison of the
values of both nodes.
  
  
    filter(callback: function) : Node[]

    Recursively filter nodes in an expression tree. The callback function is
called as callback(node: Node, path: string, parent: Node) : boolean for
every node in the tree, and must return a boolean. The function filter
returns an array with nodes for which the test returned true.
Parameter path is a string containing a relative JSON Path.

    Example:

    const node = math.parse('x^2 + x/4 + 3*y')
const filtered = node.filter(function (node) {
  return node.isSymbolNode && node.name === 'x'
})
// returns an array with two entries: two SymbolNodes 'x'
    
  
  
    forEach(callback: function) : void

    Execute a callback for each of the child nodes of this node. The callback
function is called as callback(child: Node, path: string, parent: Node): void.
Parameter path is a string containing a relative JSON Path.

    See also traverse, which is a recursive version of forEach.

    Example:

    const node = math.parse('3 * x + 2')
node.forEach(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode *
//   ConstantNode 2
    
  
  
    map(callback: function) : Node[]

    Transform a node. Creates a new Node having it’s childs be the results of
calling the provided callback function for each of the childs of the original
node. The callback function is called as callback(child: Node, path: string,
parent: Node) and must return a Node. Parameter path is a string containing
a relative JSON Path.

    See also transform, which is a recursive version of map.
  
  
    toHTML(options: object): string

    Get a HTML representation of the parsed expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toHTML()
// returns
// <span class="math-function">sqrt</span>
// <span class="math-paranthesis math-round-parenthesis">(</span>
// <span class="math-number">2</span>
// <span class="math-operator math-binary-operator math-explicit-binary-operator">/</span>
// <span class="math-number">3</span>
// <span class="math-paranthesis math-round-parenthesis">)</span>
    

    Information about the available HTML classes in HTML Classes.
Information about the options in Customization.
  
  
    toString(options: object) : string

    Get a string representation of the parsed expression. This is not exactly
the same as the original input. Example:

    const node = math.parse('3+4*2')
node.toString()  // returns '3 + (4 * 2)'
    

    Information about the options in Customization.
  
  
    toTex(options: object): string

    Get a LaTeX representation of the
expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toTex() // returns ' qrt{\frac{2}{3}}'
    

    Information about the options in Customization.
  
  
    transform(callback: function)

    Recursively transform an expression tree via a transform function. Similar
to Array.map, but recursively executed on all nodes in the expression tree.
The callback function is a mapping function accepting a node, and returning
a replacement for the node or the original node. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree, and must return a Node. Parameter path is a string containing
a relative JSON Path.

    The transform function will stop iterating when a node is replaced by the
callback function, it will not iterate over replaced nodes.

    For example, to replace all nodes of type SymbolNode having name ‘x’ with a
ConstantNode with value 3:

    const node = math.parse('x^2 + 5*x')
const transformed = node.transform(function (node, path, parent) {
  if (node.isSymbolNode && node.name === 'x') {
    return new math.ConstantNode(3)
  }
  else {
    return node
  }
})
transformed.toString() // returns '3 ^ 2 + 5 * 3'
    
  
  
    traverse(callback: function): void

    Recursively traverse all nodes in a node tree. Executes given callback for
this node and each of its child nodes. Similar to Array.forEach, except
recursive.
The callback function is a mapping function accepting a node, and returning
nothing. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree. Parameter path is a string containing a relative JSON Path.
Example:

    const node = math.parse('3 * x + 2')
node.traverse(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode +
//   OperatorNode *
//   ConstantNode 3
//   SymbolNode x
//   ConstantNode 2
    
  


Properties #

Each Node has the following properties:


  
    comment: string

    A string holding a comment if there was any in the expression, or else the
string will be empty string. A comment can be attached to the root node of
an expression or to each of the childs nodes of a BlockNode.
  
  
    isNode: true

    Is defined with value true on Nodes. Additionally, each type of node
adds it’s own flag, for example a SymbolNode as has a property
isSymbolNode: true.
  
  
    type: string

    The type of the node, for example 'SymbolNode' in case of a SymbolNode.
  


Nodes #

math.js has the following types of nodes. All nodes are available at the
namespace math.

AccessorNode #

Construction:

new AccessorNode(object: Node, index: IndexNode)


Properties:


  object: Node
  index: IndexNode
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a[3]')

const object = new math.SymbolNode('a')
const constant3 = new math.ConstantNode(3)
const index = new math.IndexNode([constant3])
const node2 = new math.AccessorNode(object, index)


ArrayNode #

Construction:

new ArrayNode(items: Node[])


Properties:


  items: Node[]


Examples:

const node1 = math.parse('[1, 2, 3]')

const one    = new math.ConstantNode(1)
const two    = new math.ConstantNode(2)
const three  = new math.ConstantNode(3)
const node2  = new math.ArrayNode([one, two, three])


AssignmentNode #

Construction:

new AssignmentNode(object: SymbolNode, value: Node)
new AssignmentNode(object: SymbolNode | AccessorNode, index: IndexNode, value: Node)


Properties:


  object: SymbolNode | AccessorNode
  index: IndexNode | null
  value: Node
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a = 3')

const object = new math.SymbolNode('a')
const value = new math.ConstantNode(3)
const node2 = new math.AssignmentNode(object, value)


BlockNode #

A BlockNode is created when parsing a multi line expression like a=2;b=3 or
a=2\nb=3. Evaluating a BlockNode returns a ResultSet. The results can be
retrieved via ResultSet.entries or ResultSet.valueOf(), which contains
an Array with the results of the visible lines (i.e. lines not ending with
a semicolon).

Construction:

block = new BlockNode(Array.<{node: Node} | {node: Node, visible: boolean}>)


Properties:


  blocks: Array.<{node: Node, visible: boolean}>


Examples:

const block1 = math.parse('a=1; b=2; c=3')

const a = new math.SymbolNode('a')
const one = new math.ConstantNode(1)
const ass1 = new math.AssignmentNode(a, one)

const b = new math.SymbolNode('b')
const two = new math.ConstantNode(2)
const ass2 = new math.AssignmentNode(b, two)

const c = new math.SymbolNode('c')
const three = new math.ConstantNode(3)
const ass3 = new math.AssignmentNode(c, three)

const block2 = new BlockNode([
  {node: ass1, visible: false},
  {node: ass2, visible: false},
  {node: ass3, visible: true}
])


ConditionalNode #

Construction:

new ConditionalNode(condition: Node, trueExpr: Node, falseExpr: Node)


Properties:


  condition: Node
  trueExpr: Node
  falseExpr: Node


Examples:

const node1 = math.parse('a > 0 ? a : -a')

const a         = new math.SymbolNode('a')
const zero      = new math.ConstantNode(0)
const condition = new math.OperatorNode('>', 'larger', [a, zero])
const trueExpr  = a
const falseExpr = new math.OperatorNode('-', 'unaryMinus', [a])
const node2     = new math.ConditionalNode(condition, trueExpr, falseExpr)


ConstantNode #

Construction:

new ConstantNode(value: *)


Properties:


  value: *


Examples:

const node1 = math.parse('2.4')

const node2 = new math.ConstantNode(2.4)
const node3 = new math.ConstantNode('foo')


FunctionAssignmentNode #

Construction:

new FunctionAssignmentNode(name: string, params: string[], expr: Node)


Properties:


  name: string
  params: string[]
  expr: Node


Examples:

const node1 = math.parse('f(x) = x^2')

const x      = new math.SymbolNode('x')
const two    = new math.ConstantNode(2)
const expr   = new math.OperatorNode('^', 'pow', [x, 2])
const node2  = new math.FunctionAssignmentNode('f', ['x'], expr)


FunctionNode #

Construction:

new FunctionNode(fn: Node | string, args: Node[])


Properties:


  fn: Node | string (read-only) The object or function name which to invoke.
  args: Node[]


Static functions:


  FunctionNode.onUndefinedFunction(name: string). This function is invoked when an undefined function is evaluated. By default, the function throws an exception “Undefined function x”. The function can be overwritten to customize this behavior. See also SymbolNode.onUndefinedSymbol.


Examples:

const node1 = math.parse('sqrt(4)')

const four  = new math.ConstantNode(4)
const node3 = new math.FunctionNode(new SymbolNode('sqrt'), [four])


IndexNode #

Construction:

new IndexNode(dimensions: Node[])
new IndexNode(dimensions: Node[], dotNotation: boolean)


Each dimension can be a single value, a range, or a property. The values of
indices are one-based, including range end.

An optional property dotNotation can be provided describing whether this index
was written using dot notation like a.b, or using bracket notation
like a["b"]. Default value is false. This information is used when
stringifying the IndexNode.

Properties:


  dimensions: Node[]
  dotNotation: boolean


Examples:

const node1 = math.parse('A[1:3, 2]')

const A     = new math.SymbolNode('A')
const one   = new math.ConstantNode(1)
const two   = new math.ConstantNode(2)
const three = new math.ConstantNode(3)

const range = new math.RangeNode(one, three)
const index = new math.IndexNode([range, two])
const node2 = new math.AccessorNode(A, index)


ObjectNode #

Construction:

new ObjectNode(properties: Object.<string, Node>)


Properties:


  properties: Object.<string, Node>


Examples:

const node1 = math.parse('{a: 1, b: 2, c: 3}')

const a = new math.ConstantNode(1)
const b = new math.ConstantNode(2)
const c = new math.ConstantNode(3)
const node2 = new math.ObjectNode({a: a, b: b, c: c})


OperatorNode #

Construction:

new OperatorNode(op: string, fn: string, args: Node[], implicit: boolean = false)


Additional methods:


  
    isUnary() : boolean

    Returns true when the OperatorNode contains exactly one argument,
like with a unary minus:

    const a = new math.ConstantNode(2)
const b = new math.OperatorNode('-', 'unaryMinus', [a])
b.isUnary() // true
    
  
  
    isBinary() : boolean

    Returns true when the OperatorNode contains exactly two arguments,
like with most regular operators:

    const a = new math.ConstantNode(2)
const b = new math.ConstantNode(3)
const c = new math.OperatorNode('+', 'add', [a, b])
c.isBinary() // true
    
  


Properties:


  op: string
  fn: string
  args: Node[]
  implicit: boolean True in case of an implicit multiplication, false otherwise


Examples:

const node1 = math.parse('2.3 + 5')

const a     = new math.ConstantNode(2.3)
const b     = new math.ConstantNode(5)
const node2 = new math.OperatorNode('+', 'add', [a, b])


ParenthesisNode #

Construction:

new ParenthesisNode(content: Node)


Properties:


  content: Node


Examples:

const node1 = math.parse('(1)')

const a     = new math.ConstantNode(1)
const node2 = new math.ParenthesisNode(a)


RangeNode #

Construction:

new RangeNode(start: Node, end: Node [, step: Node])


Properties:


  start: Node
  end: Node
  step: Node | null


Examples:

const node1 = math.parse('1:10')
const node2 = math.parse('0:2:10')

const zero = new math.ConstantNode(0)
const one = new math.ConstantNode(1)
const two = new math.ConstantNode(2)
const ten = new math.ConstantNode(10)

const node3 = new math.RangeNode(one, ten)
const node4 = new math.RangeNode(zero, ten, two)


RelationalNode #

Construction:

new RelationalNode(conditionals: string[], params: Node[])


conditionals is an array of strings, each of which may be ‘smaller’, ‘larger’, ‘smallerEq’, ‘largerEq’, ‘equal’, or ‘unequal’. The conditionals array must contain exactly one fewer item than params.

Properties:


  conditionals: string[]
  params: Node[]


A RelationalNode efficiently represents a chained conditional expression with two or more comparison operators, such as 10 < x <= 50. The expression is equivalent to 10 < x and x <= 50, except that x is evaluated only once, and evaluation stops (is “short-circuited”) once any condition tests false. Operators that are subject to chaining are <, >, <=, >=, ==, and !=. For backward compatibility, math.parse will return an OperatorNode if only a single conditional is present (such as x > 2).

Examples:


const ten = new math.ConstantNode(10)
const x = new math.SymbolNode('x')
const fifty = new math.ConstantNode(50)

const node1 = new math.RelationalNode(['smaller', 'smallerEq'], [ten, x, fifty])
const node2 = math.parse('10 < x <= 50')


SymbolNode #

Construction:

new SymbolNode(name: string)


Properties:


  name: string


Static functions:


  SymbolNode.onUndefinedSymbol(name: string). This function is invoked when an undefined symbol is evaluated. By default, the function throws an exception “Undefined symbol x”. The function can be overwritten to customize this behavior. See also FunctionNode.onUndefinedFunction.


Examples:

const node = math.parse('x')

const x = new math.SymbolNode('x')\n\n\n\nExpression trees #

When parsing an expression via math.parse(expr), math.js generates an
expression tree and returns the root node of the tree. An expression tree can
be used to analyze, manipulate, and evaluate expressions.

Example:

const node = math.parse('sqrt(2 + x)')


In this case, the expression sqrt(2 + x) is parsed as:

  FunctionNode    sqrt
                   |
  OperatorNode     +
                  / \
  ConstantNode   2   x   SymbolNode


Alternatively, this expression tree can be built by manually creating nodes:

const node1 = new math.ConstantNode(2)
const node2 = new math.SymbolNode('x')
const node3 = new math.OperatorNode('+', 'add', [node1, node2])
const node4 = new math.FunctionNode('sqrt', [node3])


The resulting expression tree with root node node4 is equal to the expression
tree generated by math.parse('sqrt(2 + x)').

API #

Methods #

All nodes have the following methods:


  
    clone() : Node

    Create a shallow clone of the node.
The node itself is cloned, its childs are not cloned.
  
  
    cloneDeep() : Node

    Create a deep clone of the node.
Both the node as well as all its childs are cloned recursively.
  
  
    compile() : Object

    Compile an expression into optimized JavaScript code. compile returns an
object with a function evaluate([scope]) to evaluate. Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const code = node.compile()        // returns {evaluate: function (scope) {...}}
const evaluate = code.evaluate({x: 3}) // returns 5
    
  
  
    evaluate([scope]) : Object

    Compile and evaluate an expression, this is the equivalent of doing
node.compile().evaluate(scope). Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const evaluate = node.evaluate({x: 3}) // returns 5
    
  
  
    equals(other: Node) : boolean

    Test whether this node equals an other node. Does a deep comparison of the
values of both nodes.
  
  
    filter(callback: function) : Node[]

    Recursively filter nodes in an expression tree. The callback function is
called as callback(node: Node, path: string, parent: Node) : boolean for
every node in the tree, and must return a boolean. The function filter
returns an array with nodes for which the test returned true.
Parameter path is a string containing a relative JSON Path.

    Example:

    const node = math.parse('x^2 + x/4 + 3*y')
const filtered = node.filter(function (node) {
  return node.isSymbolNode && node.name === 'x'
})
// returns an array with two entries: two SymbolNodes 'x'
    
  
  
    forEach(callback: function) : void

    Execute a callback for each of the child nodes of this node. The callback
function is called as callback(child: Node, path: string, parent: Node): void.
Parameter path is a string containing a relative JSON Path.

    See also traverse, which is a recursive version of forEach.

    Example:

    const node = math.parse('3 * x + 2')
node.forEach(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode *
//   ConstantNode 2
    
  
  
    map(callback: function) : Node[]

    Transform a node. Creates a new Node having it’s childs be the results of
calling the provided callback function for each of the childs of the original
node. The callback function is called as callback(child: Node, path: string,
parent: Node) and must return a Node. Parameter path is a string containing
a relative JSON Path.

    See also transform, which is a recursive version of map.
  
  
    toHTML(options: object): string

    Get a HTML representation of the parsed expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toHTML()
// returns
// <span class="math-function">sqrt</span>
// <span class="math-paranthesis math-round-parenthesis">(</span>
// <span class="math-number">2</span>
// <span class="math-operator math-binary-operator math-explicit-binary-operator">/</span>
// <span class="math-number">3</span>
// <span class="math-paranthesis math-round-parenthesis">)</span>
    

    Information about the available HTML classes in HTML Classes.
Information about the options in Customization.
  
  
    toString(options: object) : string

    Get a string representation of the parsed expression. This is not exactly
the same as the original input. Example:

    const node = math.parse('3+4*2')
node.toString()  // returns '3 + (4 * 2)'
    

    Information about the options in Customization.
  
  
    toTex(options: object): string

    Get a LaTeX representation of the
expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toTex() // returns ' qrt{\frac{2}{3}}'
    

    Information about the options in Customization.
  
  
    transform(callback: function)

    Recursively transform an expression tree via a transform function. Similar
to Array.map, but recursively executed on all nodes in the expression tree.
The callback function is a mapping function accepting a node, and returning
a replacement for the node or the original node. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree, and must return a Node. Parameter path is a string containing
a relative JSON Path.

    The transform function will stop iterating when a node is replaced by the
callback function, it will not iterate over replaced nodes.

    For example, to replace all nodes of type SymbolNode having name ‘x’ with a
ConstantNode with value 3:

    const node = math.parse('x^2 + 5*x')
const transformed = node.transform(function (node, path, parent) {
  if (node.isSymbolNode && node.name === 'x') {
    return new math.ConstantNode(3)
  }
  else {
    return node
  }
})
transformed.toString() // returns '3 ^ 2 + 5 * 3'
    
  
  
    traverse(callback: function): void

    Recursively traverse all nodes in a node tree. Executes given callback for
this node and each of its child nodes. Similar to Array.forEach, except
recursive.
The callback function is a mapping function accepting a node, and returning
nothing. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree. Parameter path is a string containing a relative JSON Path.
Example:

    const node = math.parse('3 * x + 2')
node.traverse(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode +
//   OperatorNode *
//   ConstantNode 3
//   SymbolNode x
//   ConstantNode 2
    
  


Properties #

Each Node has the following properties:


  
    comment: string

    A string holding a comment if there was any in the expression, or else the
string will be empty string. A comment can be attached to the root node of
an expression or to each of the childs nodes of a BlockNode.
  
  
    isNode: true

    Is defined with value true on Nodes. Additionally, each type of node
adds it’s own flag, for example a SymbolNode as has a property
isSymbolNode: true.
  
  
    type: string

    The type of the node, for example 'SymbolNode' in case of a SymbolNode.
  


Nodes #

math.js has the following types of nodes. All nodes are available at the
namespace math.

AccessorNode #

Construction:

new AccessorNode(object: Node, index: IndexNode)


Properties:


  object: Node
  index: IndexNode
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a[3]')

const object = new math.SymbolNode('a')
const constant3 = new math.ConstantNode(3)
const index = new math.IndexNode([constant3])
const node2 = new math.AccessorNode(object, index)


ArrayNode #

Construction:

new ArrayNode(items: Node[])


Properties:


  items: Node[]


Examples:

const node1 = math.parse('[1, 2, 3]')

const one    = new math.ConstantNode(1)
const two    = new math.ConstantNode(2)
const three  = new math.ConstantNode(3)
const node2  = new math.ArrayNode([one, two, three])


AssignmentNode #

Construction:

new AssignmentNode(object: SymbolNode, value: Node)
new AssignmentNode(object: SymbolNode | AccessorNode, index: IndexNode, value: Node)


Properties:


  object: SymbolNode | AccessorNode
  index: IndexNode | null
  value: Node
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a = 3')

const object = new math.SymbolNode('a')
const value = new math.ConstantNode(3)
const node2 = new math.AssignmentNode(object, value)


BlockNode #

A BlockNode is created when parsing a multi line expression like a=2;b=3 or
a=2\nb=3. Evaluating a BlockNode returns a ResultSet. The results can be
retrieved via ResultSet.entries or ResultSet.valueOf(), which contains
an Array with the results of the visible lines (i.e. lines not ending with
a semicolon).

Construction:

block = new BlockNode(Array.<{node: Node} | {node: Node, visible: boolean}>)


Properties:


  blocks: Array.<{node: Node, visible: boolean}>


Examples:

const block1 = math.parse('a=1; b=2; c=3')

const a = new math.SymbolNode('a')
const one = new math.ConstantNode(1)
const ass1 = new math.AssignmentNode(a, one)

const b = new math.SymbolNode('b')
const two = new math.ConstantNode(2)
const ass2 = new math.AssignmentNode(b, two)

const c = new math.SymbolNode('c')
const three = new math.ConstantNode(3)
const ass3 = new math.AssignmentNode(c, three)

const block2 = new BlockNode([
  {node: ass1, visible: false},
  {node: ass2, visible: false},
  {node: ass3, visible: true}
])


ConditionalNode #

Construction:

new ConditionalNode(condition: Node, trueExpr: Node, falseExpr: Node)


Properties:


  condition: Node
  trueExpr: Node
  falseExpr: Node


Examples:

const node1 = math.parse('a > 0 ? a : -a')

const a         = new math.SymbolNode('a')
const zero      = new math.ConstantNode(0)
const condition = new math.OperatorNode('>', 'larger', [a, zero])
const trueExpr  = a
const falseExpr = new math.OperatorNode('-', 'unaryMinus', [a])
const node2     = new math.ConditionalNode(condition, trueExpr, falseExpr)


ConstantNode #

Construction:

new ConstantNode(value: *)


Properties:


  value: *


Examples:

const node1 = math.parse('2.4')

const node2 = new math.ConstantNode(2.4)
const node3 = new math.ConstantNode('foo')


FunctionAssignmentNode #

Construction:

new FunctionAssignmentNode(name: string, params: string[], expr: Node)


Properties:


  name: string
  params: string[]
  expr: Node


Examples:

const node1 = math.parse('f(x) = x^2')

const x      = new math.SymbolNode('x')
const two    = new math.ConstantNode(2)
const expr   = new math.OperatorNode('^', 'pow', [x, 2])
const node2  = new math.FunctionAssignmentNode('f', ['x'], expr)


FunctionNode #

Construction:

new FunctionNode(fn: Node | string, args: Node[])


Properties:


  fn: Node | string (read-only) The object or function name which to invoke.
  args: Node[]


Static functions:


  FunctionNode.onUndefinedFunction(name: string). This function is invoked when an undefined function is evaluated. By default, the function throws an exception “Undefined function x”. The function can be overwritten to customize this behavior. See also SymbolNode.onUndefinedSymbol.


Examples:

const node1 = math.parse('sqrt(4)')

const four  = new math.ConstantNode(4)
const node3 = new math.FunctionNode(new SymbolNode('sqrt'), [four])


IndexNode #

Construction:

new IndexNode(dimensions: Node[])
new IndexNode(dimensions: Node[], dotNotation: boolean)


Each dimension can be a single value, a range, or a property. The values of
indices are one-based, including range end.

An optional property dotNotation can be provided describing whether this index
was written using dot notation like a.b, or using bracket notation
like a["b"]. Default value is false. This information is used when
stringifying the IndexNode.

Properties:


  dimensions: Node[]
  dotNotation: boolean


Examples:

const node1 = math.parse('A[1:3, 2]')

const A     = new math.SymbolNode('A')
const one   = new math.ConstantNode(1)
const two   = new math.ConstantNode(2)
const three = new math.ConstantNode(3)

const range = new math.RangeNode(one, three)
const index = new math.IndexNode([range, two])
const node2 = new math.AccessorNode(A, index)


ObjectNode #

Construction:

new ObjectNode(properties: Object.<string, Node>)


Properties:


  properties: Object.<string, Node>


Examples:

const node1 = math.parse('{a: 1, b: 2, c: 3}')

const a = new math.ConstantNode(1)
const b = new math.ConstantNode(2)
const c = new math.ConstantNode(3)
const node2 = new math.ObjectNode({a: a, b: b, c: c})


OperatorNode #

Construction:

new OperatorNode(op: string, fn: string, args: Node[], implicit: boolean = false)


Additional methods:


  
    isUnary() : boolean

    Returns true when the OperatorNode contains exactly one argument,
like with a unary minus:

    const a = new math.ConstantNode(2)
const b = new math.OperatorNode('-', 'unaryMinus', [a])
b.isUnary() // true
    
  
  
    isBinary() : boolean

    Returns true when the OperatorNode contains exactly two arguments,
like with most regular operators:

    const a = new math.ConstantNode(2)
const b = new math.ConstantNode(3)
const c = new math.OperatorNode('+', 'add', [a, b])
c.isBinary() // true
    
  


Properties:


  op: string
  fn: string
  args: Node[]
  implicit: boolean True in case of an implicit multiplication, false otherwise


Examples:

const node1 = math.parse('2.3 + 5')

const a     = new math.ConstantNode(2.3)
const b     = new math.ConstantNode(5)
const node2 = new math.OperatorNode('+', 'add', [a, b])


ParenthesisNode #

Construction:

new ParenthesisNode(content: Node)


Properties:


  content: Node


Examples:

const node1 = math.parse('(1)')

const a     = new math.ConstantNode(1)
const node2 = new math.ParenthesisNode(a)


RangeNode #

Construction:

new RangeNode(start: Node, end: Node [, step: Node])


Properties:


  start: Node
  end: Node
  step: Node | null


Examples:

const node1 = math.parse('1:10')
const node2 = math.parse('0:2:10')

const zero = new math.ConstantNode(0)
const one = new math.ConstantNode(1)
const two = new math.ConstantNode(2)
const ten = new math.ConstantNode(10)

const node3 = new math.RangeNode(one, ten)
const node4 = new math.RangeNode(zero, ten, two)


RelationalNode #

Construction:

new RelationalNode(conditionals: string[], params: Node[])


conditionals is an array of strings, each of which may be ‘smaller’, ‘larger’, ‘smallerEq’, ‘largerEq’, ‘equal’, or ‘unequal’. The conditionals array must contain exactly one fewer item than params.

Properties:


  conditionals: string[]
  params: Node[]


A RelationalNode efficiently represents a chained conditional expression with two or more comparison operators, such as 10 < x <= 50. The expression is equivalent to 10 < x and x <= 50, except that x is evaluated only once, and evaluation stops (is “short-circuited”) once any condition tests false. Operators that are subject to chaining are <, >, <=, >=, ==, and !=. For backward compatibility, math.parse will return an OperatorNode if only a single conditional is present (such as x > 2).

Examples:


const ten = new math.ConstantNode(10)
const x = new math.SymbolNode('x')
const fifty = new math.ConstantNode(50)

const node1 = new math.RelationalNode(['smaller', 'smallerEq'], [ten, x, fifty])
const node2 = math.parse('10 < x <= 50')


SymbolNode #

Construction:

new SymbolNode(name: string)


Properties:


  name: string


Static functions:


  SymbolNode.onUndefinedSymbol(name: string). This function is invoked when an undefined symbol is evaluated. By default, the function throws an exception “Undefined symbol x”. The function can be overwritten to customize this behavior. See also FunctionNode.onUndefinedFunction.


Examples:

const node = math.parse('x')

const x = new math.SymbolNode('x')\n\n\n\nExpression trees #

When parsing an expression via math.parse(expr), math.js generates an
expression tree and returns the root node of the tree. An expression tree can
be used to analyze, manipulate, and evaluate expressions.

Example:

const node = math.parse('sqrt(2 + x)')


In this case, the expression sqrt(2 + x) is parsed as:

  FunctionNode    sqrt
                   |
  OperatorNode     +
                  / \
  ConstantNode   2   x   SymbolNode


Alternatively, this expression tree can be built by manually creating nodes:

const node1 = new math.ConstantNode(2)
const node2 = new math.SymbolNode('x')
const node3 = new math.OperatorNode('+', 'add', [node1, node2])
const node4 = new math.FunctionNode('sqrt', [node3])


The resulting expression tree with root node node4 is equal to the expression
tree generated by math.parse('sqrt(2 + x)').

API #

Methods #

All nodes have the following methods:


  
    clone() : Node

    Create a shallow clone of the node.
The node itself is cloned, its childs are not cloned.
  
  
    cloneDeep() : Node

    Create a deep clone of the node.
Both the node as well as all its childs are cloned recursively.
  
  
    compile() : Object

    Compile an expression into optimized JavaScript code. compile returns an
object with a function evaluate([scope]) to evaluate. Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const code = node.compile()        // returns {evaluate: function (scope) {...}}
const evaluate = code.evaluate({x: 3}) // returns 5
    
  
  
    evaluate([scope]) : Object

    Compile and evaluate an expression, this is the equivalent of doing
node.compile().evaluate(scope). Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const evaluate = node.evaluate({x: 3}) // returns 5
    
  
  
    equals(other: Node) : boolean

    Test whether this node equals an other node. Does a deep comparison of the
values of both nodes.
  
  
    filter(callback: function) : Node[]

    Recursively filter nodes in an expression tree. The callback function is
called as callback(node: Node, path: string, parent: Node) : boolean for
every node in the tree, and must return a boolean. The function filter
returns an array with nodes for which the test returned true.
Parameter path is a string containing a relative JSON Path.

    Example:

    const node = math.parse('x^2 + x/4 + 3*y')
const filtered = node.filter(function (node) {
  return node.isSymbolNode && node.name === 'x'
})
// returns an array with two entries: two SymbolNodes 'x'
    
  
  
    forEach(callback: function) : void

    Execute a callback for each of the child nodes of this node. The callback
function is called as callback(child: Node, path: string, parent: Node): void.
Parameter path is a string containing a relative JSON Path.

    See also traverse, which is a recursive version of forEach.

    Example:

    const node = math.parse('3 * x + 2')
node.forEach(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode *
//   ConstantNode 2
    
  
  
    map(callback: function) : Node[]

    Transform a node. Creates a new Node having it’s childs be the results of
calling the provided callback function for each of the childs of the original
node. The callback function is called as callback(child: Node, path: string,
parent: Node) and must return a Node. Parameter path is a string containing
a relative JSON Path.

    See also transform, which is a recursive version of map.
  
  
    toHTML(options: object): string

    Get a HTML representation of the parsed expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toHTML()
// returns
// <span class="math-function">sqrt</span>
// <span class="math-paranthesis math-round-parenthesis">(</span>
// <span class="math-number">2</span>
// <span class="math-operator math-binary-operator math-explicit-binary-operator">/</span>
// <span class="math-number">3</span>
// <span class="math-paranthesis math-round-parenthesis">)</span>
    

    Information about the available HTML classes in HTML Classes.
Information about the options in Customization.
  
  
    toString(options: object) : string

    Get a string representation of the parsed expression. This is not exactly
the same as the original input. Example:

    const node = math.parse('3+4*2')
node.toString()  // returns '3 + (4 * 2)'
    

    Information about the options in Customization.
  
  
    toTex(options: object): string

    Get a LaTeX representation of the
expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toTex() // returns ' qrt{\frac{2}{3}}'
    

    Information about the options in Customization.
  
  
    transform(callback: function)

    Recursively transform an expression tree via a transform function. Similar
to Array.map, but recursively executed on all nodes in the expression tree.
The callback function is a mapping function accepting a node, and returning
a replacement for the node or the original node. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree, and must return a Node. Parameter path is a string containing
a relative JSON Path.

    The transform function will stop iterating when a node is replaced by the
callback function, it will not iterate over replaced nodes.

    For example, to replace all nodes of type SymbolNode having name ‘x’ with a
ConstantNode with value 3:

    const node = math.parse('x^2 + 5*x')
const transformed = node.transform(function (node, path, parent) {
  if (node.isSymbolNode && node.name === 'x') {
    return new math.ConstantNode(3)
  }
  else {
    return node
  }
})
transformed.toString() // returns '3 ^ 2 + 5 * 3'
    
  
  
    traverse(callback: function): void

    Recursively traverse all nodes in a node tree. Executes given callback for
this node and each of its child nodes. Similar to Array.forEach, except
recursive.
The callback function is a mapping function accepting a node, and returning
nothing. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree. Parameter path is a string containing a relative JSON Path.
Example:

    const node = math.parse('3 * x + 2')
node.traverse(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode +
//   OperatorNode *
//   ConstantNode 3
//   SymbolNode x
//   ConstantNode 2
    
  


Properties #

Each Node has the following properties:


  
    comment: string

    A string holding a comment if there was any in the expression, or else the
string will be empty string. A comment can be attached to the root node of
an expression or to each of the childs nodes of a BlockNode.
  
  
    isNode: true

    Is defined with value true on Nodes. Additionally, each type of node
adds it’s own flag, for example a SymbolNode as has a property
isSymbolNode: true.
  
  
    type: string

    The type of the node, for example 'SymbolNode' in case of a SymbolNode.
  


Nodes #

math.js has the following types of nodes. All nodes are available at the
namespace math.

AccessorNode #

Construction:

new AccessorNode(object: Node, index: IndexNode)


Properties:


  object: Node
  index: IndexNode
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a[3]')

const object = new math.SymbolNode('a')
const constant3 = new math.ConstantNode(3)
const index = new math.IndexNode([constant3])
const node2 = new math.AccessorNode(object, index)


ArrayNode #

Construction:

new ArrayNode(items: Node[])


Properties:


  items: Node[]


Examples:

const node1 = math.parse('[1, 2, 3]')

const one    = new math.ConstantNode(1)
const two    = new math.ConstantNode(2)
const three  = new math.ConstantNode(3)
const node2  = new math.ArrayNode([one, two, three])


AssignmentNode #

Construction:

new AssignmentNode(object: SymbolNode, value: Node)
new AssignmentNode(object: SymbolNode | AccessorNode, index: IndexNode, value: Node)


Properties:


  object: SymbolNode | AccessorNode
  index: IndexNode | null
  value: Node
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a = 3')

const object = new math.SymbolNode('a')
const value = new math.ConstantNode(3)
const node2 = new math.AssignmentNode(object, value)


BlockNode #

A BlockNode is created when parsing a multi line expression like a=2;b=3 or
a=2\nb=3. Evaluating a BlockNode returns a ResultSet. The results can be
retrieved via ResultSet.entries or ResultSet.valueOf(), which contains
an Array with the results of the visible lines (i.e. lines not ending with
a semicolon).

Construction:

block = new BlockNode(Array.<{node: Node} | {node: Node, visible: boolean}>)


Properties:


  blocks: Array.<{node: Node, visible: boolean}>


Examples:

const block1 = math.parse('a=1; b=2; c=3')

const a = new math.SymbolNode('a')
const one = new math.ConstantNode(1)
const ass1 = new math.AssignmentNode(a, one)

const b = new math.SymbolNode('b')
const two = new math.ConstantNode(2)
const ass2 = new math.AssignmentNode(b, two)

const c = new math.SymbolNode('c')
const three = new math.ConstantNode(3)
const ass3 = new math.AssignmentNode(c, three)

const block2 = new BlockNode([
  {node: ass1, visible: false},
  {node: ass2, visible: false},
  {node: ass3, visible: true}
])


ConditionalNode #

Construction:

new ConditionalNode(condition: Node, trueExpr: Node, falseExpr: Node)


Properties:


  condition: Node
  trueExpr: Node
  falseExpr: Node


Examples:

const node1 = math.parse('a > 0 ? a : -a')

const a         = new math.SymbolNode('a')
const zero      = new math.ConstantNode(0)
const condition = new math.OperatorNode('>', 'larger', [a, zero])
const trueExpr  = a
const falseExpr = new math.OperatorNode('-', 'unaryMinus', [a])
const node2     = new math.ConditionalNode(condition, trueExpr, falseExpr)


ConstantNode #

Construction:

new ConstantNode(value: *)


Properties:


  value: *


Examples:

const node1 = math.parse('2.4')

const node2 = new math.ConstantNode(2.4)
const node3 = new math.ConstantNode('foo')


FunctionAssignmentNode #

Construction:

new FunctionAssignmentNode(name: string, params: string[], expr: Node)


Properties:


  name: string
  params: string[]
  expr: Node


Examples:

const node1 = math.parse('f(x) = x^2')

const x      = new math.SymbolNode('x')
const two    = new math.ConstantNode(2)
const expr   = new math.OperatorNode('^', 'pow', [x, 2])
const node2  = new math.FunctionAssignmentNode('f', ['x'], expr)


FunctionNode #

Construction:

new FunctionNode(fn: Node | string, args: Node[])


Properties:


  fn: Node | string (read-only) The object or function name which to invoke.
  args: Node[]


Static functions:


  FunctionNode.onUndefinedFunction(name: string). This function is invoked when an undefined function is evaluated. By default, the function throws an exception “Undefined function x”. The function can be overwritten to customize this behavior. See also SymbolNode.onUndefinedSymbol.


Examples:

const node1 = math.parse('sqrt(4)')

const four  = new math.ConstantNode(4)
const node3 = new math.FunctionNode(new SymbolNode('sqrt'), [four])


IndexNode #

Construction:

new IndexNode(dimensions: Node[])
new IndexNode(dimensions: Node[], dotNotation: boolean)


Each dimension can be a single value, a range, or a property. The values of
indices are one-based, including range end.

An optional property dotNotation can be provided describing whether this index
was written using dot notation like a.b, or using bracket notation
like a["b"]. Default value is false. This information is used when
stringifying the IndexNode.

Properties:


  dimensions: Node[]
  dotNotation: boolean


Examples:

const node1 = math.parse('A[1:3, 2]')

const A     = new math.SymbolNode('A')
const one   = new math.ConstantNode(1)
const two   = new math.ConstantNode(2)
const three = new math.ConstantNode(3)

const range = new math.RangeNode(one, three)
const index = new math.IndexNode([range, two])
const node2 = new math.AccessorNode(A, index)


ObjectNode #

Construction:

new ObjectNode(properties: Object.<string, Node>)


Properties:


  properties: Object.<string, Node>


Examples:

const node1 = math.parse('{a: 1, b: 2, c: 3}')

const a = new math.ConstantNode(1)
const b = new math.ConstantNode(2)
const c = new math.ConstantNode(3)
const node2 = new math.ObjectNode({a: a, b: b, c: c})


OperatorNode #

Construction:

new OperatorNode(op: string, fn: string, args: Node[], implicit: boolean = false)


Additional methods:


  
    isUnary() : boolean

    Returns true when the OperatorNode contains exactly one argument,
like with a unary minus:

    const a = new math.ConstantNode(2)
const b = new math.OperatorNode('-', 'unaryMinus', [a])
b.isUnary() // true
    
  
  
    isBinary() : boolean

    Returns true when the OperatorNode contains exactly two arguments,
like with most regular operators:

    const a = new math.ConstantNode(2)
const b = new math.ConstantNode(3)
const c = new math.OperatorNode('+', 'add', [a, b])
c.isBinary() // true
    
  


Properties:


  op: string
  fn: string
  args: Node[]
  implicit: boolean True in case of an implicit multiplication, false otherwise


Examples:

const node1 = math.parse('2.3 + 5')

const a     = new math.ConstantNode(2.3)
const b     = new math.ConstantNode(5)
const node2 = new math.OperatorNode('+', 'add', [a, b])


ParenthesisNode #

Construction:

new ParenthesisNode(content: Node)


Properties:


  content: Node


Examples:

const node1 = math.parse('(1)')

const a     = new math.ConstantNode(1)
const node2 = new math.ParenthesisNode(a)


RangeNode #

Construction:

new RangeNode(start: Node, end: Node [, step: Node])


Properties:


  start: Node
  end: Node
  step: Node | null


Examples:

const node1 = math.parse('1:10')
const node2 = math.parse('0:2:10')

const zero = new math.ConstantNode(0)
const one = new math.ConstantNode(1)
const two = new math.ConstantNode(2)
const ten = new math.ConstantNode(10)

const node3 = new math.RangeNode(one, ten)
const node4 = new math.RangeNode(zero, ten, two)


RelationalNode #

Construction:

new RelationalNode(conditionals: string[], params: Node[])


conditionals is an array of strings, each of which may be ‘smaller’, ‘larger’, ‘smallerEq’, ‘largerEq’, ‘equal’, or ‘unequal’. The conditionals array must contain exactly one fewer item than params.

Properties:


  conditionals: string[]
  params: Node[]


A RelationalNode efficiently represents a chained conditional expression with two or more comparison operators, such as 10 < x <= 50. The expression is equivalent to 10 < x and x <= 50, except that x is evaluated only once, and evaluation stops (is “short-circuited”) once any condition tests false. Operators that are subject to chaining are <, >, <=, >=, ==, and !=. For backward compatibility, math.parse will return an OperatorNode if only a single conditional is present (such as x > 2).

Examples:


const ten = new math.ConstantNode(10)
const x = new math.SymbolNode('x')
const fifty = new math.ConstantNode(50)

const node1 = new math.RelationalNode(['smaller', 'smallerEq'], [ten, x, fifty])
const node2 = math.parse('10 < x <= 50')


SymbolNode #

Construction:

new SymbolNode(name: string)


Properties:


  name: string


Static functions:


  SymbolNode.onUndefinedSymbol(name: string). This function is invoked when an undefined symbol is evaluated. By default, the function throws an exception “Undefined symbol x”. The function can be overwritten to customize this behavior. See also FunctionNode.onUndefinedFunction.


Examples:

const node = math.parse('x')

const x = new math.SymbolNode('x')\n\n\n\nExpression trees #

When parsing an expression via math.parse(expr), math.js generates an
expression tree and returns the root node of the tree. An expression tree can
be used to analyze, manipulate, and evaluate expressions.

Example:

const node = math.parse('sqrt(2 + x)')


In this case, the expression sqrt(2 + x) is parsed as:

  FunctionNode    sqrt
                   |
  OperatorNode     +
                  / \
  ConstantNode   2   x   SymbolNode


Alternatively, this expression tree can be built by manually creating nodes:

const node1 = new math.ConstantNode(2)
const node2 = new math.SymbolNode('x')
const node3 = new math.OperatorNode('+', 'add', [node1, node2])
const node4 = new math.FunctionNode('sqrt', [node3])


The resulting expression tree with root node node4 is equal to the expression
tree generated by math.parse('sqrt(2 + x)').

API #

Methods #

All nodes have the following methods:


  
    clone() : Node

    Create a shallow clone of the node.
The node itself is cloned, its childs are not cloned.
  
  
    cloneDeep() : Node

    Create a deep clone of the node.
Both the node as well as all its childs are cloned recursively.
  
  
    compile() : Object

    Compile an expression into optimized JavaScript code. compile returns an
object with a function evaluate([scope]) to evaluate. Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const code = node.compile()        // returns {evaluate: function (scope) {...}}
const evaluate = code.evaluate({x: 3}) // returns 5
    
  
  
    evaluate([scope]) : Object

    Compile and evaluate an expression, this is the equivalent of doing
node.compile().evaluate(scope). Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const evaluate = node.evaluate({x: 3}) // returns 5
    
  
  
    equals(other: Node) : boolean

    Test whether this node equals an other node. Does a deep comparison of the
values of both nodes.
  
  
    filter(callback: function) : Node[]

    Recursively filter nodes in an expression tree. The callback function is
called as callback(node: Node, path: string, parent: Node) : boolean for
every node in the tree, and must return a boolean. The function filter
returns an array with nodes for which the test returned true.
Parameter path is a string containing a relative JSON Path.

    Example:

    const node = math.parse('x^2 + x/4 + 3*y')
const filtered = node.filter(function (node) {
  return node.isSymbolNode && node.name === 'x'
})
// returns an array with two entries: two SymbolNodes 'x'
    
  
  
    forEach(callback: function) : void

    Execute a callback for each of the child nodes of this node. The callback
function is called as callback(child: Node, path: string, parent: Node): void.
Parameter path is a string containing a relative JSON Path.

    See also traverse, which is a recursive version of forEach.

    Example:

    const node = math.parse('3 * x + 2')
node.forEach(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode *
//   ConstantNode 2
    
  
  
    map(callback: function) : Node[]

    Transform a node. Creates a new Node having it’s childs be the results of
calling the provided callback function for each of the childs of the original
node. The callback function is called as callback(child: Node, path: string,
parent: Node) and must return a Node. Parameter path is a string containing
a relative JSON Path.

    See also transform, which is a recursive version of map.
  
  
    toHTML(options: object): string

    Get a HTML representation of the parsed expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toHTML()
// returns
// <span class="math-function">sqrt</span>
// <span class="math-paranthesis math-round-parenthesis">(</span>
// <span class="math-number">2</span>
// <span class="math-operator math-binary-operator math-explicit-binary-operator">/</span>
// <span class="math-number">3</span>
// <span class="math-paranthesis math-round-parenthesis">)</span>
    

    Information about the available HTML classes in HTML Classes.
Information about the options in Customization.
  
  
    toString(options: object) : string

    Get a string representation of the parsed expression. This is not exactly
the same as the original input. Example:

    const node = math.parse('3+4*2')
node.toString()  // returns '3 + (4 * 2)'
    

    Information about the options in Customization.
  
  
    toTex(options: object): string

    Get a LaTeX representation of the
expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toTex() // returns ' qrt{\frac{2}{3}}'
    

    Information about the options in Customization.
  
  
    transform(callback: function)

    Recursively transform an expression tree via a transform function. Similar
to Array.map, but recursively executed on all nodes in the expression tree.
The callback function is a mapping function accepting a node, and returning
a replacement for the node or the original node. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree, and must return a Node. Parameter path is a string containing
a relative JSON Path.

    The transform function will stop iterating when a node is replaced by the
callback function, it will not iterate over replaced nodes.

    For example, to replace all nodes of type SymbolNode having name ‘x’ with a
ConstantNode with value 3:

    const node = math.parse('x^2 + 5*x')
const transformed = node.transform(function (node, path, parent) {
  if (node.isSymbolNode && node.name === 'x') {
    return new math.ConstantNode(3)
  }
  else {
    return node
  }
})
transformed.toString() // returns '3 ^ 2 + 5 * 3'
    
  
  
    traverse(callback: function): void

    Recursively traverse all nodes in a node tree. Executes given callback for
this node and each of its child nodes. Similar to Array.forEach, except
recursive.
The callback function is a mapping function accepting a node, and returning
nothing. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree. Parameter path is a string containing a relative JSON Path.
Example:

    const node = math.parse('3 * x + 2')
node.traverse(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode +
//   OperatorNode *
//   ConstantNode 3
//   SymbolNode x
//   ConstantNode 2
    
  


Properties #

Each Node has the following properties:


  
    comment: string

    A string holding a comment if there was any in the expression, or else the
string will be empty string. A comment can be attached to the root node of
an expression or to each of the childs nodes of a BlockNode.
  
  
    isNode: true

    Is defined with value true on Nodes. Additionally, each type of node
adds it’s own flag, for example a SymbolNode as has a property
isSymbolNode: true.
  
  
    type: string

    The type of the node, for example 'SymbolNode' in case of a SymbolNode.
  


Nodes #

math.js has the following types of nodes. All nodes are available at the
namespace math.

AccessorNode #

Construction:

new AccessorNode(object: Node, index: IndexNode)


Properties:


  object: Node
  index: IndexNode
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a[3]')

const object = new math.SymbolNode('a')
const constant3 = new math.ConstantNode(3)
const index = new math.IndexNode([constant3])
const node2 = new math.AccessorNode(object, index)


ArrayNode #

Construction:

new ArrayNode(items: Node[])


Properties:


  items: Node[]


Examples:

const node1 = math.parse('[1, 2, 3]')

const one    = new math.ConstantNode(1)
const two    = new math.ConstantNode(2)
const three  = new math.ConstantNode(3)
const node2  = new math.ArrayNode([one, two, three])


AssignmentNode #

Construction:

new AssignmentNode(object: SymbolNode, value: Node)
new AssignmentNode(object: SymbolNode | AccessorNode, index: IndexNode, value: Node)


Properties:


  object: SymbolNode | AccessorNode
  index: IndexNode | null
  value: Node
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a = 3')

const object = new math.SymbolNode('a')
const value = new math.ConstantNode(3)
const node2 = new math.AssignmentNode(object, value)


BlockNode #

A BlockNode is created when parsing a multi line expression like a=2;b=3 or
a=2\nb=3. Evaluating a BlockNode returns a ResultSet. The results can be
retrieved via ResultSet.entries or ResultSet.valueOf(), which contains
an Array with the results of the visible lines (i.e. lines not ending with
a semicolon).

Construction:

block = new BlockNode(Array.<{node: Node} | {node: Node, visible: boolean}>)


Properties:


  blocks: Array.<{node: Node, visible: boolean}>


Examples:

const block1 = math.parse('a=1; b=2; c=3')

const a = new math.SymbolNode('a')
const one = new math.ConstantNode(1)
const ass1 = new math.AssignmentNode(a, one)

const b = new math.SymbolNode('b')
const two = new math.ConstantNode(2)
const ass2 = new math.AssignmentNode(b, two)

const c = new math.SymbolNode('c')
const three = new math.ConstantNode(3)
const ass3 = new math.AssignmentNode(c, three)

const block2 = new BlockNode([
  {node: ass1, visible: false},
  {node: ass2, visible: false},
  {node: ass3, visible: true}
])


ConditionalNode #

Construction:

new ConditionalNode(condition: Node, trueExpr: Node, falseExpr: Node)


Properties:


  condition: Node
  trueExpr: Node
  falseExpr: Node


Examples:

const node1 = math.parse('a > 0 ? a : -a')

const a         = new math.SymbolNode('a')
const zero      = new math.ConstantNode(0)
const condition = new math.OperatorNode('>', 'larger', [a, zero])
const trueExpr  = a
const falseExpr = new math.OperatorNode('-', 'unaryMinus', [a])
const node2     = new math.ConditionalNode(condition, trueExpr, falseExpr)


ConstantNode #

Construction:

new ConstantNode(value: *)


Properties:


  value: *


Examples:

const node1 = math.parse('2.4')

const node2 = new math.ConstantNode(2.4)
const node3 = new math.ConstantNode('foo')


FunctionAssignmentNode #

Construction:

new FunctionAssignmentNode(name: string, params: string[], expr: Node)


Properties:


  name: string
  params: string[]
  expr: Node


Examples:

const node1 = math.parse('f(x) = x^2')

const x      = new math.SymbolNode('x')
const two    = new math.ConstantNode(2)
const expr   = new math.OperatorNode('^', 'pow', [x, 2])
const node2  = new math.FunctionAssignmentNode('f', ['x'], expr)


FunctionNode #

Construction:

new FunctionNode(fn: Node | string, args: Node[])


Properties:


  fn: Node | string (read-only) The object or function name which to invoke.
  args: Node[]


Static functions:


  FunctionNode.onUndefinedFunction(name: string). This function is invoked when an undefined function is evaluated. By default, the function throws an exception “Undefined function x”. The function can be overwritten to customize this behavior. See also SymbolNode.onUndefinedSymbol.


Examples:

const node1 = math.parse('sqrt(4)')

const four  = new math.ConstantNode(4)
const node3 = new math.FunctionNode(new SymbolNode('sqrt'), [four])


IndexNode #

Construction:

new IndexNode(dimensions: Node[])
new IndexNode(dimensions: Node[], dotNotation: boolean)


Each dimension can be a single value, a range, or a property. The values of
indices are one-based, including range end.

An optional property dotNotation can be provided describing whether this index
was written using dot notation like a.b, or using bracket notation
like a["b"]. Default value is false. This information is used when
stringifying the IndexNode.

Properties:


  dimensions: Node[]
  dotNotation: boolean


Examples:

const node1 = math.parse('A[1:3, 2]')

const A     = new math.SymbolNode('A')
const one   = new math.ConstantNode(1)
const two   = new math.ConstantNode(2)
const three = new math.ConstantNode(3)

const range = new math.RangeNode(one, three)
const index = new math.IndexNode([range, two])
const node2 = new math.AccessorNode(A, index)


ObjectNode #

Construction:

new ObjectNode(properties: Object.<string, Node>)


Properties:


  properties: Object.<string, Node>


Examples:

const node1 = math.parse('{a: 1, b: 2, c: 3}')

const a = new math.ConstantNode(1)
const b = new math.ConstantNode(2)
const c = new math.ConstantNode(3)
const node2 = new math.ObjectNode({a: a, b: b, c: c})


OperatorNode #

Construction:

new OperatorNode(op: string, fn: string, args: Node[], implicit: boolean = false)


Additional methods:


  
    isUnary() : boolean

    Returns true when the OperatorNode contains exactly one argument,
like with a unary minus:

    const a = new math.ConstantNode(2)
const b = new math.OperatorNode('-', 'unaryMinus', [a])
b.isUnary() // true
    
  
  
    isBinary() : boolean

    Returns true when the OperatorNode contains exactly two arguments,
like with most regular operators:

    const a = new math.ConstantNode(2)
const b = new math.ConstantNode(3)
const c = new math.OperatorNode('+', 'add', [a, b])
c.isBinary() // true
    
  


Properties:


  op: string
  fn: string
  args: Node[]
  implicit: boolean True in case of an implicit multiplication, false otherwise


Examples:

const node1 = math.parse('2.3 + 5')

const a     = new math.ConstantNode(2.3)
const b     = new math.ConstantNode(5)
const node2 = new math.OperatorNode('+', 'add', [a, b])


ParenthesisNode #

Construction:

new ParenthesisNode(content: Node)


Properties:


  content: Node


Examples:

const node1 = math.parse('(1)')

const a     = new math.ConstantNode(1)
const node2 = new math.ParenthesisNode(a)


RangeNode #

Construction:

new RangeNode(start: Node, end: Node [, step: Node])


Properties:


  start: Node
  end: Node
  step: Node | null


Examples:

const node1 = math.parse('1:10')
const node2 = math.parse('0:2:10')

const zero = new math.ConstantNode(0)
const one = new math.ConstantNode(1)
const two = new math.ConstantNode(2)
const ten = new math.ConstantNode(10)

const node3 = new math.RangeNode(one, ten)
const node4 = new math.RangeNode(zero, ten, two)


RelationalNode #

Construction:

new RelationalNode(conditionals: string[], params: Node[])


conditionals is an array of strings, each of which may be ‘smaller’, ‘larger’, ‘smallerEq’, ‘largerEq’, ‘equal’, or ‘unequal’. The conditionals array must contain exactly one fewer item than params.

Properties:


  conditionals: string[]
  params: Node[]


A RelationalNode efficiently represents a chained conditional expression with two or more comparison operators, such as 10 < x <= 50. The expression is equivalent to 10 < x and x <= 50, except that x is evaluated only once, and evaluation stops (is “short-circuited”) once any condition tests false. Operators that are subject to chaining are <, >, <=, >=, ==, and !=. For backward compatibility, math.parse will return an OperatorNode if only a single conditional is present (such as x > 2).

Examples:


const ten = new math.ConstantNode(10)
const x = new math.SymbolNode('x')
const fifty = new math.ConstantNode(50)

const node1 = new math.RelationalNode(['smaller', 'smallerEq'], [ten, x, fifty])
const node2 = math.parse('10 < x <= 50')


SymbolNode #

Construction:

new SymbolNode(name: string)


Properties:


  name: string


Static functions:


  SymbolNode.onUndefinedSymbol(name: string). This function is invoked when an undefined symbol is evaluated. By default, the function throws an exception “Undefined symbol x”. The function can be overwritten to customize this behavior. See also FunctionNode.onUndefinedFunction.


Examples:

const node = math.parse('x')

const x = new math.SymbolNode('x')\n\n\n\nExpression trees #

When parsing an expression via math.parse(expr), math.js generates an
expression tree and returns the root node of the tree. An expression tree can
be used to analyze, manipulate, and evaluate expressions.

Example:

const node = math.parse('sqrt(2 + x)')


In this case, the expression sqrt(2 + x) is parsed as:

  FunctionNode    sqrt
                   |
  OperatorNode     +
                  / \
  ConstantNode   2   x   SymbolNode


Alternatively, this expression tree can be built by manually creating nodes:

const node1 = new math.ConstantNode(2)
const node2 = new math.SymbolNode('x')
const node3 = new math.OperatorNode('+', 'add', [node1, node2])
const node4 = new math.FunctionNode('sqrt', [node3])


The resulting expression tree with root node node4 is equal to the expression
tree generated by math.parse('sqrt(2 + x)').

API #

Methods #

All nodes have the following methods:


  
    clone() : Node

    Create a shallow clone of the node.
The node itself is cloned, its childs are not cloned.
  
  
    cloneDeep() : Node

    Create a deep clone of the node.
Both the node as well as all its childs are cloned recursively.
  
  
    compile() : Object

    Compile an expression into optimized JavaScript code. compile returns an
object with a function evaluate([scope]) to evaluate. Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const code = node.compile()        // returns {evaluate: function (scope) {...}}
const evaluate = code.evaluate({x: 3}) // returns 5
    
  
  
    evaluate([scope]) : Object

    Compile and evaluate an expression, this is the equivalent of doing
node.compile().evaluate(scope). Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const evaluate = node.evaluate({x: 3}) // returns 5
    
  
  
    equals(other: Node) : boolean

    Test whether this node equals an other node. Does a deep comparison of the
values of both nodes.
  
  
    filter(callback: function) : Node[]

    Recursively filter nodes in an expression tree. The callback function is
called as callback(node: Node, path: string, parent: Node) : boolean for
every node in the tree, and must return a boolean. The function filter
returns an array with nodes for which the test returned true.
Parameter path is a string containing a relative JSON Path.

    Example:

    const node = math.parse('x^2 + x/4 + 3*y')
const filtered = node.filter(function (node) {
  return node.isSymbolNode && node.name === 'x'
})
// returns an array with two entries: two SymbolNodes 'x'
    
  
  
    forEach(callback: function) : void

    Execute a callback for each of the child nodes of this node. The callback
function is called as callback(child: Node, path: string, parent: Node): void.
Parameter path is a string containing a relative JSON Path.

    See also traverse, which is a recursive version of forEach.

    Example:

    const node = math.parse('3 * x + 2')
node.forEach(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode *
//   ConstantNode 2
    
  
  
    map(callback: function) : Node[]

    Transform a node. Creates a new Node having it’s childs be the results of
calling the provided callback function for each of the childs of the original
node. The callback function is called as callback(child: Node, path: string,
parent: Node) and must return a Node. Parameter path is a string containing
a relative JSON Path.

    See also transform, which is a recursive version of map.
  
  
    toHTML(options: object): string

    Get a HTML representation of the parsed expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toHTML()
// returns
// <span class="math-function">sqrt</span>
// <span class="math-paranthesis math-round-parenthesis">(</span>
// <span class="math-number">2</span>
// <span class="math-operator math-binary-operator math-explicit-binary-operator">/</span>
// <span class="math-number">3</span>
// <span class="math-paranthesis math-round-parenthesis">)</span>
    

    Information about the available HTML classes in HTML Classes.
Information about the options in Customization.
  
  
    toString(options: object) : string

    Get a string representation of the parsed expression. This is not exactly
the same as the original input. Example:

    const node = math.parse('3+4*2')
node.toString()  // returns '3 + (4 * 2)'
    

    Information about the options in Customization.
  
  
    toTex(options: object): string

    Get a LaTeX representation of the
expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toTex() // returns ' qrt{\frac{2}{3}}'
    

    Information about the options in Customization.
  
  
    transform(callback: function)

    Recursively transform an expression tree via a transform function. Similar
to Array.map, but recursively executed on all nodes in the expression tree.
The callback function is a mapping function accepting a node, and returning
a replacement for the node or the original node. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree, and must return a Node. Parameter path is a string containing
a relative JSON Path.

    The transform function will stop iterating when a node is replaced by the
callback function, it will not iterate over replaced nodes.

    For example, to replace all nodes of type SymbolNode having name ‘x’ with a
ConstantNode with value 3:

    const node = math.parse('x^2 + 5*x')
const transformed = node.transform(function (node, path, parent) {
  if (node.isSymbolNode && node.name === 'x') {
    return new math.ConstantNode(3)
  }
  else {
    return node
  }
})
transformed.toString() // returns '3 ^ 2 + 5 * 3'
    
  
  
    traverse(callback: function): void

    Recursively traverse all nodes in a node tree. Executes given callback for
this node and each of its child nodes. Similar to Array.forEach, except
recursive.
The callback function is a mapping function accepting a node, and returning
nothing. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree. Parameter path is a string containing a relative JSON Path.
Example:

    const node = math.parse('3 * x + 2')
node.traverse(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode +
//   OperatorNode *
//   ConstantNode 3
//   SymbolNode x
//   ConstantNode 2
    
  


Properties #

Each Node has the following properties:


  
    comment: string

    A string holding a comment if there was any in the expression, or else the
string will be empty string. A comment can be attached to the root node of
an expression or to each of the childs nodes of a BlockNode.
  
  
    isNode: true

    Is defined with value true on Nodes. Additionally, each type of node
adds it’s own flag, for example a SymbolNode as has a property
isSymbolNode: true.
  
  
    type: string

    The type of the node, for example 'SymbolNode' in case of a SymbolNode.
  


Nodes #

math.js has the following types of nodes. All nodes are available at the
namespace math.

AccessorNode #

Construction:

new AccessorNode(object: Node, index: IndexNode)


Properties:


  object: Node
  index: IndexNode
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a[3]')

const object = new math.SymbolNode('a')
const constant3 = new math.ConstantNode(3)
const index = new math.IndexNode([constant3])
const node2 = new math.AccessorNode(object, index)


ArrayNode #

Construction:

new ArrayNode(items: Node[])


Properties:


  items: Node[]


Examples:

const node1 = math.parse('[1, 2, 3]')

const one    = new math.ConstantNode(1)
const two    = new math.ConstantNode(2)
const three  = new math.ConstantNode(3)
const node2  = new math.ArrayNode([one, two, three])


AssignmentNode #

Construction:

new AssignmentNode(object: SymbolNode, value: Node)
new AssignmentNode(object: SymbolNode | AccessorNode, index: IndexNode, value: Node)


Properties:


  object: SymbolNode | AccessorNode
  index: IndexNode | null
  value: Node
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a = 3')

const object = new math.SymbolNode('a')
const value = new math.ConstantNode(3)
const node2 = new math.AssignmentNode(object, value)


BlockNode #

A BlockNode is created when parsing a multi line expression like a=2;b=3 or
a=2\nb=3. Evaluating a BlockNode returns a ResultSet. The results can be
retrieved via ResultSet.entries or ResultSet.valueOf(), which contains
an Array with the results of the visible lines (i.e. lines not ending with
a semicolon).

Construction:

block = new BlockNode(Array.<{node: Node} | {node: Node, visible: boolean}>)


Properties:


  blocks: Array.<{node: Node, visible: boolean}>


Examples:

const block1 = math.parse('a=1; b=2; c=3')

const a = new math.SymbolNode('a')
const one = new math.ConstantNode(1)
const ass1 = new math.AssignmentNode(a, one)

const b = new math.SymbolNode('b')
const two = new math.ConstantNode(2)
const ass2 = new math.AssignmentNode(b, two)

const c = new math.SymbolNode('c')
const three = new math.ConstantNode(3)
const ass3 = new math.AssignmentNode(c, three)

const block2 = new BlockNode([
  {node: ass1, visible: false},
  {node: ass2, visible: false},
  {node: ass3, visible: true}
])


ConditionalNode #

Construction:

new ConditionalNode(condition: Node, trueExpr: Node, falseExpr: Node)


Properties:


  condition: Node
  trueExpr: Node
  falseExpr: Node


Examples:

const node1 = math.parse('a > 0 ? a : -a')

const a         = new math.SymbolNode('a')
const zero      = new math.ConstantNode(0)
const condition = new math.OperatorNode('>', 'larger', [a, zero])
const trueExpr  = a
const falseExpr = new math.OperatorNode('-', 'unaryMinus', [a])
const node2     = new math.ConditionalNode(condition, trueExpr, falseExpr)


ConstantNode #

Construction:

new ConstantNode(value: *)


Properties:


  value: *


Examples:

const node1 = math.parse('2.4')

const node2 = new math.ConstantNode(2.4)
const node3 = new math.ConstantNode('foo')


FunctionAssignmentNode #

Construction:

new FunctionAssignmentNode(name: string, params: string[], expr: Node)


Properties:


  name: string
  params: string[]
  expr: Node


Examples:

const node1 = math.parse('f(x) = x^2')

const x      = new math.SymbolNode('x')
const two    = new math.ConstantNode(2)
const expr   = new math.OperatorNode('^', 'pow', [x, 2])
const node2  = new math.FunctionAssignmentNode('f', ['x'], expr)


FunctionNode #

Construction:

new FunctionNode(fn: Node | string, args: Node[])


Properties:


  fn: Node | string (read-only) The object or function name which to invoke.
  args: Node[]


Static functions:


  FunctionNode.onUndefinedFunction(name: string). This function is invoked when an undefined function is evaluated. By default, the function throws an exception “Undefined function x”. The function can be overwritten to customize this behavior. See also SymbolNode.onUndefinedSymbol.


Examples:

const node1 = math.parse('sqrt(4)')

const four  = new math.ConstantNode(4)
const node3 = new math.FunctionNode(new SymbolNode('sqrt'), [four])


IndexNode #

Construction:

new IndexNode(dimensions: Node[])
new IndexNode(dimensions: Node[], dotNotation: boolean)


Each dimension can be a single value, a range, or a property. The values of
indices are one-based, including range end.

An optional property dotNotation can be provided describing whether this index
was written using dot notation like a.b, or using bracket notation
like a["b"]. Default value is false. This information is used when
stringifying the IndexNode.

Properties:


  dimensions: Node[]
  dotNotation: boolean


Examples:

const node1 = math.parse('A[1:3, 2]')

const A     = new math.SymbolNode('A')
const one   = new math.ConstantNode(1)
const two   = new math.ConstantNode(2)
const three = new math.ConstantNode(3)

const range = new math.RangeNode(one, three)
const index = new math.IndexNode([range, two])
const node2 = new math.AccessorNode(A, index)


ObjectNode #

Construction:

new ObjectNode(properties: Object.<string, Node>)


Properties:


  properties: Object.<string, Node>


Examples:

const node1 = math.parse('{a: 1, b: 2, c: 3}')

const a = new math.ConstantNode(1)
const b = new math.ConstantNode(2)
const c = new math.ConstantNode(3)
const node2 = new math.ObjectNode({a: a, b: b, c: c})


OperatorNode #

Construction:

new OperatorNode(op: string, fn: string, args: Node[], implicit: boolean = false)


Additional methods:


  
    isUnary() : boolean

    Returns true when the OperatorNode contains exactly one argument,
like with a unary minus:

    const a = new math.ConstantNode(2)
const b = new math.OperatorNode('-', 'unaryMinus', [a])
b.isUnary() // true
    
  
  
    isBinary() : boolean

    Returns true when the OperatorNode contains exactly two arguments,
like with most regular operators:

    const a = new math.ConstantNode(2)
const b = new math.ConstantNode(3)
const c = new math.OperatorNode('+', 'add', [a, b])
c.isBinary() // true
    
  


Properties:


  op: string
  fn: string
  args: Node[]
  implicit: boolean True in case of an implicit multiplication, false otherwise


Examples:

const node1 = math.parse('2.3 + 5')

const a     = new math.ConstantNode(2.3)
const b     = new math.ConstantNode(5)
const node2 = new math.OperatorNode('+', 'add', [a, b])


ParenthesisNode #

Construction:

new ParenthesisNode(content: Node)


Properties:


  content: Node


Examples:

const node1 = math.parse('(1)')

const a     = new math.ConstantNode(1)
const node2 = new math.ParenthesisNode(a)


RangeNode #

Construction:

new RangeNode(start: Node, end: Node [, step: Node])


Properties:


  start: Node
  end: Node
  step: Node | null


Examples:

const node1 = math.parse('1:10')
const node2 = math.parse('0:2:10')

const zero = new math.ConstantNode(0)
const one = new math.ConstantNode(1)
const two = new math.ConstantNode(2)
const ten = new math.ConstantNode(10)

const node3 = new math.RangeNode(one, ten)
const node4 = new math.RangeNode(zero, ten, two)


RelationalNode #

Construction:

new RelationalNode(conditionals: string[], params: Node[])


conditionals is an array of strings, each of which may be ‘smaller’, ‘larger’, ‘smallerEq’, ‘largerEq’, ‘equal’, or ‘unequal’. The conditionals array must contain exactly one fewer item than params.

Properties:


  conditionals: string[]
  params: Node[]


A RelationalNode efficiently represents a chained conditional expression with two or more comparison operators, such as 10 < x <= 50. The expression is equivalent to 10 < x and x <= 50, except that x is evaluated only once, and evaluation stops (is “short-circuited”) once any condition tests false. Operators that are subject to chaining are <, >, <=, >=, ==, and !=. For backward compatibility, math.parse will return an OperatorNode if only a single conditional is present (such as x > 2).

Examples:


const ten = new math.ConstantNode(10)
const x = new math.SymbolNode('x')
const fifty = new math.ConstantNode(50)

const node1 = new math.RelationalNode(['smaller', 'smallerEq'], [ten, x, fifty])
const node2 = math.parse('10 < x <= 50')


SymbolNode #

Construction:

new SymbolNode(name: string)


Properties:


  name: string


Static functions:


  SymbolNode.onUndefinedSymbol(name: string). This function is invoked when an undefined symbol is evaluated. By default, the function throws an exception “Undefined symbol x”. The function can be overwritten to customize this behavior. See also FunctionNode.onUndefinedFunction.


Examples:

const node = math.parse('x')

const x = new math.SymbolNode('x')\n\n\n\nExpression trees #

When parsing an expression via math.parse(expr), math.js generates an
expression tree and returns the root node of the tree. An expression tree can
be used to analyze, manipulate, and evaluate expressions.

Example:

const node = math.parse('sqrt(2 + x)')


In this case, the expression sqrt(2 + x) is parsed as:

  FunctionNode    sqrt
                   |
  OperatorNode     +
                  / \
  ConstantNode   2   x   SymbolNode


Alternatively, this expression tree can be built by manually creating nodes:

const node1 = new math.ConstantNode(2)
const node2 = new math.SymbolNode('x')
const node3 = new math.OperatorNode('+', 'add', [node1, node2])
const node4 = new math.FunctionNode('sqrt', [node3])


The resulting expression tree with root node node4 is equal to the expression
tree generated by math.parse('sqrt(2 + x)').

API #

Methods #

All nodes have the following methods:


  
    clone() : Node

    Create a shallow clone of the node.
The node itself is cloned, its childs are not cloned.
  
  
    cloneDeep() : Node

    Create a deep clone of the node.
Both the node as well as all its childs are cloned recursively.
  
  
    compile() : Object

    Compile an expression into optimized JavaScript code. compile returns an
object with a function evaluate([scope]) to evaluate. Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const code = node.compile()        // returns {evaluate: function (scope) {...}}
const evaluate = code.evaluate({x: 3}) // returns 5
    
  
  
    evaluate([scope]) : Object

    Compile and evaluate an expression, this is the equivalent of doing
node.compile().evaluate(scope). Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const evaluate = node.evaluate({x: 3}) // returns 5
    
  
  
    equals(other: Node) : boolean

    Test whether this node equals an other node. Does a deep comparison of the
values of both nodes.
  
  
    filter(callback: function) : Node[]

    Recursively filter nodes in an expression tree. The callback function is
called as callback(node: Node, path: string, parent: Node) : boolean for
every node in the tree, and must return a boolean. The function filter
returns an array with nodes for which the test returned true.
Parameter path is a string containing a relative JSON Path.

    Example:

    const node = math.parse('x^2 + x/4 + 3*y')
const filtered = node.filter(function (node) {
  return node.isSymbolNode && node.name === 'x'
})
// returns an array with two entries: two SymbolNodes 'x'
    
  
  
    forEach(callback: function) : void

    Execute a callback for each of the child nodes of this node. The callback
function is called as callback(child: Node, path: string, parent: Node): void.
Parameter path is a string containing a relative JSON Path.

    See also traverse, which is a recursive version of forEach.

    Example:

    const node = math.parse('3 * x + 2')
node.forEach(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode *
//   ConstantNode 2
    
  
  
    map(callback: function) : Node[]

    Transform a node. Creates a new Node having it’s childs be the results of
calling the provided callback function for each of the childs of the original
node. The callback function is called as callback(child: Node, path: string,
parent: Node) and must return a Node. Parameter path is a string containing
a relative JSON Path.

    See also transform, which is a recursive version of map.
  
  
    toHTML(options: object): string

    Get a HTML representation of the parsed expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toHTML()
// returns
// <span class="math-function">sqrt</span>
// <span class="math-paranthesis math-round-parenthesis">(</span>
// <span class="math-number">2</span>
// <span class="math-operator math-binary-operator math-explicit-binary-operator">/</span>
// <span class="math-number">3</span>
// <span class="math-paranthesis math-round-parenthesis">)</span>
    

    Information about the available HTML classes in HTML Classes.
Information about the options in Customization.
  
  
    toString(options: object) : string

    Get a string representation of the parsed expression. This is not exactly
the same as the original input. Example:

    const node = math.parse('3+4*2')
node.toString()  // returns '3 + (4 * 2)'
    

    Information about the options in Customization.
  
  
    toTex(options: object): string

    Get a LaTeX representation of the
expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toTex() // returns ' qrt{\frac{2}{3}}'
    

    Information about the options in Customization.
  
  
    transform(callback: function)

    Recursively transform an expression tree via a transform function. Similar
to Array.map, but recursively executed on all nodes in the expression tree.
The callback function is a mapping function accepting a node, and returning
a replacement for the node or the original node. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree, and must return a Node. Parameter path is a string containing
a relative JSON Path.

    The transform function will stop iterating when a node is replaced by the
callback function, it will not iterate over replaced nodes.

    For example, to replace all nodes of type SymbolNode having name ‘x’ with a
ConstantNode with value 3:

    const node = math.parse('x^2 + 5*x')
const transformed = node.transform(function (node, path, parent) {
  if (node.isSymbolNode && node.name === 'x') {
    return new math.ConstantNode(3)
  }
  else {
    return node
  }
})
transformed.toString() // returns '3 ^ 2 + 5 * 3'
    
  
  
    traverse(callback: function): void

    Recursively traverse all nodes in a node tree. Executes given callback for
this node and each of its child nodes. Similar to Array.forEach, except
recursive.
The callback function is a mapping function accepting a node, and returning
nothing. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree. Parameter path is a string containing a relative JSON Path.
Example:

    const node = math.parse('3 * x + 2')
node.traverse(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode +
//   OperatorNode *
//   ConstantNode 3
//   SymbolNode x
//   ConstantNode 2
    
  


Properties #

Each Node has the following properties:


  
    comment: string

    A string holding a comment if there was any in the expression, or else the
string will be empty string. A comment can be attached to the root node of
an expression or to each of the childs nodes of a BlockNode.
  
  
    isNode: true

    Is defined with value true on Nodes. Additionally, each type of node
adds it’s own flag, for example a SymbolNode as has a property
isSymbolNode: true.
  
  
    type: string

    The type of the node, for example 'SymbolNode' in case of a SymbolNode.
  


Nodes #

math.js has the following types of nodes. All nodes are available at the
namespace math.

AccessorNode #

Construction:

new AccessorNode(object: Node, index: IndexNode)


Properties:


  object: Node
  index: IndexNode
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a[3]')

const object = new math.SymbolNode('a')
const constant3 = new math.ConstantNode(3)
const index = new math.IndexNode([constant3])
const node2 = new math.AccessorNode(object, index)


ArrayNode #

Construction:

new ArrayNode(items: Node[])


Properties:


  items: Node[]


Examples:

const node1 = math.parse('[1, 2, 3]')

const one    = new math.ConstantNode(1)
const two    = new math.ConstantNode(2)
const three  = new math.ConstantNode(3)
const node2  = new math.ArrayNode([one, two, three])


AssignmentNode #

Construction:

new AssignmentNode(object: SymbolNode, value: Node)
new AssignmentNode(object: SymbolNode | AccessorNode, index: IndexNode, value: Node)


Properties:


  object: SymbolNode | AccessorNode
  index: IndexNode | null
  value: Node
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a = 3')

const object = new math.SymbolNode('a')
const value = new math.ConstantNode(3)
const node2 = new math.AssignmentNode(object, value)


BlockNode #

A BlockNode is created when parsing a multi line expression like a=2;b=3 or
a=2\nb=3. Evaluating a BlockNode returns a ResultSet. The results can be
retrieved via ResultSet.entries or ResultSet.valueOf(), which contains
an Array with the results of the visible lines (i.e. lines not ending with
a semicolon).

Construction:

block = new BlockNode(Array.<{node: Node} | {node: Node, visible: boolean}>)


Properties:


  blocks: Array.<{node: Node, visible: boolean}>


Examples:

const block1 = math.parse('a=1; b=2; c=3')

const a = new math.SymbolNode('a')
const one = new math.ConstantNode(1)
const ass1 = new math.AssignmentNode(a, one)

const b = new math.SymbolNode('b')
const two = new math.ConstantNode(2)
const ass2 = new math.AssignmentNode(b, two)

const c = new math.SymbolNode('c')
const three = new math.ConstantNode(3)
const ass3 = new math.AssignmentNode(c, three)

const block2 = new BlockNode([
  {node: ass1, visible: false},
  {node: ass2, visible: false},
  {node: ass3, visible: true}
])


ConditionalNode #

Construction:

new ConditionalNode(condition: Node, trueExpr: Node, falseExpr: Node)


Properties:


  condition: Node
  trueExpr: Node
  falseExpr: Node


Examples:

const node1 = math.parse('a > 0 ? a : -a')

const a         = new math.SymbolNode('a')
const zero      = new math.ConstantNode(0)
const condition = new math.OperatorNode('>', 'larger', [a, zero])
const trueExpr  = a
const falseExpr = new math.OperatorNode('-', 'unaryMinus', [a])
const node2     = new math.ConditionalNode(condition, trueExpr, falseExpr)


ConstantNode #

Construction:

new ConstantNode(value: *)


Properties:


  value: *


Examples:

const node1 = math.parse('2.4')

const node2 = new math.ConstantNode(2.4)
const node3 = new math.ConstantNode('foo')


FunctionAssignmentNode #

Construction:

new FunctionAssignmentNode(name: string, params: string[], expr: Node)


Properties:


  name: string
  params: string[]
  expr: Node


Examples:

const node1 = math.parse('f(x) = x^2')

const x      = new math.SymbolNode('x')
const two    = new math.ConstantNode(2)
const expr   = new math.OperatorNode('^', 'pow', [x, 2])
const node2  = new math.FunctionAssignmentNode('f', ['x'], expr)


FunctionNode #

Construction:

new FunctionNode(fn: Node | string, args: Node[])


Properties:


  fn: Node | string (read-only) The object or function name which to invoke.
  args: Node[]


Static functions:


  FunctionNode.onUndefinedFunction(name: string). This function is invoked when an undefined function is evaluated. By default, the function throws an exception “Undefined function x”. The function can be overwritten to customize this behavior. See also SymbolNode.onUndefinedSymbol.


Examples:

const node1 = math.parse('sqrt(4)')

const four  = new math.ConstantNode(4)
const node3 = new math.FunctionNode(new SymbolNode('sqrt'), [four])


IndexNode #

Construction:

new IndexNode(dimensions: Node[])
new IndexNode(dimensions: Node[], dotNotation: boolean)


Each dimension can be a single value, a range, or a property. The values of
indices are one-based, including range end.

An optional property dotNotation can be provided describing whether this index
was written using dot notation like a.b, or using bracket notation
like a["b"]. Default value is false. This information is used when
stringifying the IndexNode.

Properties:


  dimensions: Node[]
  dotNotation: boolean


Examples:

const node1 = math.parse('A[1:3, 2]')

const A     = new math.SymbolNode('A')
const one   = new math.ConstantNode(1)
const two   = new math.ConstantNode(2)
const three = new math.ConstantNode(3)

const range = new math.RangeNode(one, three)
const index = new math.IndexNode([range, two])
const node2 = new math.AccessorNode(A, index)


ObjectNode #

Construction:

new ObjectNode(properties: Object.<string, Node>)


Properties:


  properties: Object.<string, Node>


Examples:

const node1 = math.parse('{a: 1, b: 2, c: 3}')

const a = new math.ConstantNode(1)
const b = new math.ConstantNode(2)
const c = new math.ConstantNode(3)
const node2 = new math.ObjectNode({a: a, b: b, c: c})


OperatorNode #

Construction:

new OperatorNode(op: string, fn: string, args: Node[], implicit: boolean = false)


Additional methods:


  
    isUnary() : boolean

    Returns true when the OperatorNode contains exactly one argument,
like with a unary minus:

    const a = new math.ConstantNode(2)
const b = new math.OperatorNode('-', 'unaryMinus', [a])
b.isUnary() // true
    
  
  
    isBinary() : boolean

    Returns true when the OperatorNode contains exactly two arguments,
like with most regular operators:

    const a = new math.ConstantNode(2)
const b = new math.ConstantNode(3)
const c = new math.OperatorNode('+', 'add', [a, b])
c.isBinary() // true
    
  


Properties:


  op: string
  fn: string
  args: Node[]
  implicit: boolean True in case of an implicit multiplication, false otherwise


Examples:

const node1 = math.parse('2.3 + 5')

const a     = new math.ConstantNode(2.3)
const b     = new math.ConstantNode(5)
const node2 = new math.OperatorNode('+', 'add', [a, b])


ParenthesisNode #

Construction:

new ParenthesisNode(content: Node)


Properties:


  content: Node


Examples:

const node1 = math.parse('(1)')

const a     = new math.ConstantNode(1)
const node2 = new math.ParenthesisNode(a)


RangeNode #

Construction:

new RangeNode(start: Node, end: Node [, step: Node])


Properties:


  start: Node
  end: Node
  step: Node | null


Examples:

const node1 = math.parse('1:10')
const node2 = math.parse('0:2:10')

const zero = new math.ConstantNode(0)
const one = new math.ConstantNode(1)
const two = new math.ConstantNode(2)
const ten = new math.ConstantNode(10)

const node3 = new math.RangeNode(one, ten)
const node4 = new math.RangeNode(zero, ten, two)


RelationalNode #

Construction:

new RelationalNode(conditionals: string[], params: Node[])


conditionals is an array of strings, each of which may be ‘smaller’, ‘larger’, ‘smallerEq’, ‘largerEq’, ‘equal’, or ‘unequal’. The conditionals array must contain exactly one fewer item than params.

Properties:


  conditionals: string[]
  params: Node[]


A RelationalNode efficiently represents a chained conditional expression with two or more comparison operators, such as 10 < x <= 50. The expression is equivalent to 10 < x and x <= 50, except that x is evaluated only once, and evaluation stops (is “short-circuited”) once any condition tests false. Operators that are subject to chaining are <, >, <=, >=, ==, and !=. For backward compatibility, math.parse will return an OperatorNode if only a single conditional is present (such as x > 2).

Examples:


const ten = new math.ConstantNode(10)
const x = new math.SymbolNode('x')
const fifty = new math.ConstantNode(50)

const node1 = new math.RelationalNode(['smaller', 'smallerEq'], [ten, x, fifty])
const node2 = math.parse('10 < x <= 50')


SymbolNode #

Construction:

new SymbolNode(name: string)


Properties:


  name: string


Static functions:


  SymbolNode.onUndefinedSymbol(name: string). This function is invoked when an undefined symbol is evaluated. By default, the function throws an exception “Undefined symbol x”. The function can be overwritten to customize this behavior. See also FunctionNode.onUndefinedFunction.


Examples:

const node = math.parse('x')

const x = new math.SymbolNode('x')\n\n\n\nExpression trees #

When parsing an expression via math.parse(expr), math.js generates an
expression tree and returns the root node of the tree. An expression tree can
be used to analyze, manipulate, and evaluate expressions.

Example:

const node = math.parse('sqrt(2 + x)')


In this case, the expression sqrt(2 + x) is parsed as:

  FunctionNode    sqrt
                   |
  OperatorNode     +
                  / \
  ConstantNode   2   x   SymbolNode


Alternatively, this expression tree can be built by manually creating nodes:

const node1 = new math.ConstantNode(2)
const node2 = new math.SymbolNode('x')
const node3 = new math.OperatorNode('+', 'add', [node1, node2])
const node4 = new math.FunctionNode('sqrt', [node3])


The resulting expression tree with root node node4 is equal to the expression
tree generated by math.parse('sqrt(2 + x)').

API #

Methods #

All nodes have the following methods:


  
    clone() : Node

    Create a shallow clone of the node.
The node itself is cloned, its childs are not cloned.
  
  
    cloneDeep() : Node

    Create a deep clone of the node.
Both the node as well as all its childs are cloned recursively.
  
  
    compile() : Object

    Compile an expression into optimized JavaScript code. compile returns an
object with a function evaluate([scope]) to evaluate. Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const code = node.compile()        // returns {evaluate: function (scope) {...}}
const evaluate = code.evaluate({x: 3}) // returns 5
    
  
  
    evaluate([scope]) : Object

    Compile and evaluate an expression, this is the equivalent of doing
node.compile().evaluate(scope). Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const evaluate = node.evaluate({x: 3}) // returns 5
    
  
  
    equals(other: Node) : boolean

    Test whether this node equals an other node. Does a deep comparison of the
values of both nodes.
  
  
    filter(callback: function) : Node[]

    Recursively filter nodes in an expression tree. The callback function is
called as callback(node: Node, path: string, parent: Node) : boolean for
every node in the tree, and must return a boolean. The function filter
returns an array with nodes for which the test returned true.
Parameter path is a string containing a relative JSON Path.

    Example:

    const node = math.parse('x^2 + x/4 + 3*y')
const filtered = node.filter(function (node) {
  return node.isSymbolNode && node.name === 'x'
})
// returns an array with two entries: two SymbolNodes 'x'
    
  
  
    forEach(callback: function) : void

    Execute a callback for each of the child nodes of this node. The callback
function is called as callback(child: Node, path: string, parent: Node): void.
Parameter path is a string containing a relative JSON Path.

    See also traverse, which is a recursive version of forEach.

    Example:

    const node = math.parse('3 * x + 2')
node.forEach(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode *
//   ConstantNode 2
    
  
  
    map(callback: function) : Node[]

    Transform a node. Creates a new Node having it’s childs be the results of
calling the provided callback function for each of the childs of the original
node. The callback function is called as callback(child: Node, path: string,
parent: Node) and must return a Node. Parameter path is a string containing
a relative JSON Path.

    See also transform, which is a recursive version of map.
  
  
    toHTML(options: object): string

    Get a HTML representation of the parsed expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toHTML()
// returns
// <span class="math-function">sqrt</span>
// <span class="math-paranthesis math-round-parenthesis">(</span>
// <span class="math-number">2</span>
// <span class="math-operator math-binary-operator math-explicit-binary-operator">/</span>
// <span class="math-number">3</span>
// <span class="math-paranthesis math-round-parenthesis">)</span>
    

    Information about the available HTML classes in HTML Classes.
Information about the options in Customization.
  
  
    toString(options: object) : string

    Get a string representation of the parsed expression. This is not exactly
the same as the original input. Example:

    const node = math.parse('3+4*2')
node.toString()  // returns '3 + (4 * 2)'
    

    Information about the options in Customization.
  
  
    toTex(options: object): string

    Get a LaTeX representation of the
expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toTex() // returns ' qrt{\frac{2}{3}}'
    

    Information about the options in Customization.
  
  
    transform(callback: function)

    Recursively transform an expression tree via a transform function. Similar
to Array.map, but recursively executed on all nodes in the expression tree.
The callback function is a mapping function accepting a node, and returning
a replacement for the node or the original node. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree, and must return a Node. Parameter path is a string containing
a relative JSON Path.

    The transform function will stop iterating when a node is replaced by the
callback function, it will not iterate over replaced nodes.

    For example, to replace all nodes of type SymbolNode having name ‘x’ with a
ConstantNode with value 3:

    const node = math.parse('x^2 + 5*x')
const transformed = node.transform(function (node, path, parent) {
  if (node.isSymbolNode && node.name === 'x') {
    return new math.ConstantNode(3)
  }
  else {
    return node
  }
})
transformed.toString() // returns '3 ^ 2 + 5 * 3'
    
  
  
    traverse(callback: function): void

    Recursively traverse all nodes in a node tree. Executes given callback for
this node and each of its child nodes. Similar to Array.forEach, except
recursive.
The callback function is a mapping function accepting a node, and returning
nothing. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree. Parameter path is a string containing a relative JSON Path.
Example:

    const node = math.parse('3 * x + 2')
node.traverse(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode +
//   OperatorNode *
//   ConstantNode 3
//   SymbolNode x
//   ConstantNode 2
    
  


Properties #

Each Node has the following properties:


  
    comment: string

    A string holding a comment if there was any in the expression, or else the
string will be empty string. A comment can be attached to the root node of
an expression or to each of the childs nodes of a BlockNode.
  
  
    isNode: true

    Is defined with value true on Nodes. Additionally, each type of node
adds it’s own flag, for example a SymbolNode as has a property
isSymbolNode: true.
  
  
    type: string

    The type of the node, for example 'SymbolNode' in case of a SymbolNode.
  


Nodes #

math.js has the following types of nodes. All nodes are available at the
namespace math.

AccessorNode #

Construction:

new AccessorNode(object: Node, index: IndexNode)


Properties:


  object: Node
  index: IndexNode
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a[3]')

const object = new math.SymbolNode('a')
const constant3 = new math.ConstantNode(3)
const index = new math.IndexNode([constant3])
const node2 = new math.AccessorNode(object, index)


ArrayNode #

Construction:

new ArrayNode(items: Node[])


Properties:


  items: Node[]


Examples:

const node1 = math.parse('[1, 2, 3]')

const one    = new math.ConstantNode(1)
const two    = new math.ConstantNode(2)
const three  = new math.ConstantNode(3)
const node2  = new math.ArrayNode([one, two, three])


AssignmentNode #

Construction:

new AssignmentNode(object: SymbolNode, value: Node)
new AssignmentNode(object: SymbolNode | AccessorNode, index: IndexNode, value: Node)


Properties:


  object: SymbolNode | AccessorNode
  index: IndexNode | null
  value: Node
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a = 3')

const object = new math.SymbolNode('a')
const value = new math.ConstantNode(3)
const node2 = new math.AssignmentNode(object, value)


BlockNode #

A BlockNode is created when parsing a multi line expression like a=2;b=3 or
a=2\nb=3. Evaluating a BlockNode returns a ResultSet. The results can be
retrieved via ResultSet.entries or ResultSet.valueOf(), which contains
an Array with the results of the visible lines (i.e. lines not ending with
a semicolon).

Construction:

block = new BlockNode(Array.<{node: Node} | {node: Node, visible: boolean}>)


Properties:


  blocks: Array.<{node: Node, visible: boolean}>


Examples:

const block1 = math.parse('a=1; b=2; c=3')

const a = new math.SymbolNode('a')
const one = new math.ConstantNode(1)
const ass1 = new math.AssignmentNode(a, one)

const b = new math.SymbolNode('b')
const two = new math.ConstantNode(2)
const ass2 = new math.AssignmentNode(b, two)

const c = new math.SymbolNode('c')
const three = new math.ConstantNode(3)
const ass3 = new math.AssignmentNode(c, three)

const block2 = new BlockNode([
  {node: ass1, visible: false},
  {node: ass2, visible: false},
  {node: ass3, visible: true}
])


ConditionalNode #

Construction:

new ConditionalNode(condition: Node, trueExpr: Node, falseExpr: Node)


Properties:


  condition: Node
  trueExpr: Node
  falseExpr: Node


Examples:

const node1 = math.parse('a > 0 ? a : -a')

const a         = new math.SymbolNode('a')
const zero      = new math.ConstantNode(0)
const condition = new math.OperatorNode('>', 'larger', [a, zero])
const trueExpr  = a
const falseExpr = new math.OperatorNode('-', 'unaryMinus', [a])
const node2     = new math.ConditionalNode(condition, trueExpr, falseExpr)


ConstantNode #

Construction:

new ConstantNode(value: *)


Properties:


  value: *


Examples:

const node1 = math.parse('2.4')

const node2 = new math.ConstantNode(2.4)
const node3 = new math.ConstantNode('foo')


FunctionAssignmentNode #

Construction:

new FunctionAssignmentNode(name: string, params: string[], expr: Node)


Properties:


  name: string
  params: string[]
  expr: Node


Examples:

const node1 = math.parse('f(x) = x^2')

const x      = new math.SymbolNode('x')
const two    = new math.ConstantNode(2)
const expr   = new math.OperatorNode('^', 'pow', [x, 2])
const node2  = new math.FunctionAssignmentNode('f', ['x'], expr)


FunctionNode #

Construction:

new FunctionNode(fn: Node | string, args: Node[])


Properties:


  fn: Node | string (read-only) The object or function name which to invoke.
  args: Node[]


Static functions:


  FunctionNode.onUndefinedFunction(name: string). This function is invoked when an undefined function is evaluated. By default, the function throws an exception “Undefined function x”. The function can be overwritten to customize this behavior. See also SymbolNode.onUndefinedSymbol.


Examples:

const node1 = math.parse('sqrt(4)')

const four  = new math.ConstantNode(4)
const node3 = new math.FunctionNode(new SymbolNode('sqrt'), [four])


IndexNode #

Construction:

new IndexNode(dimensions: Node[])
new IndexNode(dimensions: Node[], dotNotation: boolean)


Each dimension can be a single value, a range, or a property. The values of
indices are one-based, including range end.

An optional property dotNotation can be provided describing whether this index
was written using dot notation like a.b, or using bracket notation
like a["b"]. Default value is false. This information is used when
stringifying the IndexNode.

Properties:


  dimensions: Node[]
  dotNotation: boolean


Examples:

const node1 = math.parse('A[1:3, 2]')

const A     = new math.SymbolNode('A')
const one   = new math.ConstantNode(1)
const two   = new math.ConstantNode(2)
const three = new math.ConstantNode(3)

const range = new math.RangeNode(one, three)
const index = new math.IndexNode([range, two])
const node2 = new math.AccessorNode(A, index)


ObjectNode #

Construction:

new ObjectNode(properties: Object.<string, Node>)


Properties:


  properties: Object.<string, Node>


Examples:

const node1 = math.parse('{a: 1, b: 2, c: 3}')

const a = new math.ConstantNode(1)
const b = new math.ConstantNode(2)
const c = new math.ConstantNode(3)
const node2 = new math.ObjectNode({a: a, b: b, c: c})


OperatorNode #

Construction:

new OperatorNode(op: string, fn: string, args: Node[], implicit: boolean = false)


Additional methods:


  
    isUnary() : boolean

    Returns true when the OperatorNode contains exactly one argument,
like with a unary minus:

    const a = new math.ConstantNode(2)
const b = new math.OperatorNode('-', 'unaryMinus', [a])
b.isUnary() // true
    
  
  
    isBinary() : boolean

    Returns true when the OperatorNode contains exactly two arguments,
like with most regular operators:

    const a = new math.ConstantNode(2)
const b = new math.ConstantNode(3)
const c = new math.OperatorNode('+', 'add', [a, b])
c.isBinary() // true
    
  


Properties:


  op: string
  fn: string
  args: Node[]
  implicit: boolean True in case of an implicit multiplication, false otherwise


Examples:

const node1 = math.parse('2.3 + 5')

const a     = new math.ConstantNode(2.3)
const b     = new math.ConstantNode(5)
const node2 = new math.OperatorNode('+', 'add', [a, b])


ParenthesisNode #

Construction:

new ParenthesisNode(content: Node)


Properties:


  content: Node


Examples:

const node1 = math.parse('(1)')

const a     = new math.ConstantNode(1)
const node2 = new math.ParenthesisNode(a)


RangeNode #

Construction:

new RangeNode(start: Node, end: Node [, step: Node])


Properties:


  start: Node
  end: Node
  step: Node | null


Examples:

const node1 = math.parse('1:10')
const node2 = math.parse('0:2:10')

const zero = new math.ConstantNode(0)
const one = new math.ConstantNode(1)
const two = new math.ConstantNode(2)
const ten = new math.ConstantNode(10)

const node3 = new math.RangeNode(one, ten)
const node4 = new math.RangeNode(zero, ten, two)


RelationalNode #

Construction:

new RelationalNode(conditionals: string[], params: Node[])


conditionals is an array of strings, each of which may be ‘smaller’, ‘larger’, ‘smallerEq’, ‘largerEq’, ‘equal’, or ‘unequal’. The conditionals array must contain exactly one fewer item than params.

Properties:


  conditionals: string[]
  params: Node[]


A RelationalNode efficiently represents a chained conditional expression with two or more comparison operators, such as 10 < x <= 50. The expression is equivalent to 10 < x and x <= 50, except that x is evaluated only once, and evaluation stops (is “short-circuited”) once any condition tests false. Operators that are subject to chaining are <, >, <=, >=, ==, and !=. For backward compatibility, math.parse will return an OperatorNode if only a single conditional is present (such as x > 2).

Examples:


const ten = new math.ConstantNode(10)
const x = new math.SymbolNode('x')
const fifty = new math.ConstantNode(50)

const node1 = new math.RelationalNode(['smaller', 'smallerEq'], [ten, x, fifty])
const node2 = math.parse('10 < x <= 50')


SymbolNode #

Construction:

new SymbolNode(name: string)


Properties:


  name: string


Static functions:


  SymbolNode.onUndefinedSymbol(name: string). This function is invoked when an undefined symbol is evaluated. By default, the function throws an exception “Undefined symbol x”. The function can be overwritten to customize this behavior. See also FunctionNode.onUndefinedFunction.


Examples:

const node = math.parse('x')

const x = new math.SymbolNode('x')\n\n\n\nExpression trees #

When parsing an expression via math.parse(expr), math.js generates an
expression tree and returns the root node of the tree. An expression tree can
be used to analyze, manipulate, and evaluate expressions.

Example:

const node = math.parse('sqrt(2 + x)')


In this case, the expression sqrt(2 + x) is parsed as:

  FunctionNode    sqrt
                   |
  OperatorNode     +
                  / \
  ConstantNode   2   x   SymbolNode


Alternatively, this expression tree can be built by manually creating nodes:

const node1 = new math.ConstantNode(2)
const node2 = new math.SymbolNode('x')
const node3 = new math.OperatorNode('+', 'add', [node1, node2])
const node4 = new math.FunctionNode('sqrt', [node3])


The resulting expression tree with root node node4 is equal to the expression
tree generated by math.parse('sqrt(2 + x)').

API #

Methods #

All nodes have the following methods:


  
    clone() : Node

    Create a shallow clone of the node.
The node itself is cloned, its childs are not cloned.
  
  
    cloneDeep() : Node

    Create a deep clone of the node.
Both the node as well as all its childs are cloned recursively.
  
  
    compile() : Object

    Compile an expression into optimized JavaScript code. compile returns an
object with a function evaluate([scope]) to evaluate. Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const code = node.compile()        // returns {evaluate: function (scope) {...}}
const evaluate = code.evaluate({x: 3}) // returns 5
    
  
  
    evaluate([scope]) : Object

    Compile and evaluate an expression, this is the equivalent of doing
node.compile().evaluate(scope). Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const evaluate = node.evaluate({x: 3}) // returns 5
    
  
  
    equals(other: Node) : boolean

    Test whether this node equals an other node. Does a deep comparison of the
values of both nodes.
  
  
    filter(callback: function) : Node[]

    Recursively filter nodes in an expression tree. The callback function is
called as callback(node: Node, path: string, parent: Node) : boolean for
every node in the tree, and must return a boolean. The function filter
returns an array with nodes for which the test returned true.
Parameter path is a string containing a relative JSON Path.

    Example:

    const node = math.parse('x^2 + x/4 + 3*y')
const filtered = node.filter(function (node) {
  return node.isSymbolNode && node.name === 'x'
})
// returns an array with two entries: two SymbolNodes 'x'
    
  
  
    forEach(callback: function) : void

    Execute a callback for each of the child nodes of this node. The callback
function is called as callback(child: Node, path: string, parent: Node): void.
Parameter path is a string containing a relative JSON Path.

    See also traverse, which is a recursive version of forEach.

    Example:

    const node = math.parse('3 * x + 2')
node.forEach(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode *
//   ConstantNode 2
    
  
  
    map(callback: function) : Node[]

    Transform a node. Creates a new Node having it’s childs be the results of
calling the provided callback function for each of the childs of the original
node. The callback function is called as callback(child: Node, path: string,
parent: Node) and must return a Node. Parameter path is a string containing
a relative JSON Path.

    See also transform, which is a recursive version of map.
  
  
    toHTML(options: object): string

    Get a HTML representation of the parsed expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toHTML()
// returns
// <span class="math-function">sqrt</span>
// <span class="math-paranthesis math-round-parenthesis">(</span>
// <span class="math-number">2</span>
// <span class="math-operator math-binary-operator math-explicit-binary-operator">/</span>
// <span class="math-number">3</span>
// <span class="math-paranthesis math-round-parenthesis">)</span>
    

    Information about the available HTML classes in HTML Classes.
Information about the options in Customization.
  
  
    toString(options: object) : string

    Get a string representation of the parsed expression. This is not exactly
the same as the original input. Example:

    const node = math.parse('3+4*2')
node.toString()  // returns '3 + (4 * 2)'
    

    Information about the options in Customization.
  
  
    toTex(options: object): string

    Get a LaTeX representation of the
expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toTex() // returns ' qrt{\frac{2}{3}}'
    

    Information about the options in Customization.
  
  
    transform(callback: function)

    Recursively transform an expression tree via a transform function. Similar
to Array.map, but recursively executed on all nodes in the expression tree.
The callback function is a mapping function accepting a node, and returning
a replacement for the node or the original node. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree, and must return a Node. Parameter path is a string containing
a relative JSON Path.

    The transform function will stop iterating when a node is replaced by the
callback function, it will not iterate over replaced nodes.

    For example, to replace all nodes of type SymbolNode having name ‘x’ with a
ConstantNode with value 3:

    const node = math.parse('x^2 + 5*x')
const transformed = node.transform(function (node, path, parent) {
  if (node.isSymbolNode && node.name === 'x') {
    return new math.ConstantNode(3)
  }
  else {
    return node
  }
})
transformed.toString() // returns '3 ^ 2 + 5 * 3'
    
  
  
    traverse(callback: function): void

    Recursively traverse all nodes in a node tree. Executes given callback for
this node and each of its child nodes. Similar to Array.forEach, except
recursive.
The callback function is a mapping function accepting a node, and returning
nothing. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree. Parameter path is a string containing a relative JSON Path.
Example:

    const node = math.parse('3 * x + 2')
node.traverse(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode +
//   OperatorNode *
//   ConstantNode 3
//   SymbolNode x
//   ConstantNode 2
    
  


Properties #

Each Node has the following properties:


  
    comment: string

    A string holding a comment if there was any in the expression, or else the
string will be empty string. A comment can be attached to the root node of
an expression or to each of the childs nodes of a BlockNode.
  
  
    isNode: true

    Is defined with value true on Nodes. Additionally, each type of node
adds it’s own flag, for example a SymbolNode as has a property
isSymbolNode: true.
  
  
    type: string

    The type of the node, for example 'SymbolNode' in case of a SymbolNode.
  


Nodes #

math.js has the following types of nodes. All nodes are available at the
namespace math.

AccessorNode #

Construction:

new AccessorNode(object: Node, index: IndexNode)


Properties:


  object: Node
  index: IndexNode
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a[3]')

const object = new math.SymbolNode('a')
const constant3 = new math.ConstantNode(3)
const index = new math.IndexNode([constant3])
const node2 = new math.AccessorNode(object, index)


ArrayNode #

Construction:

new ArrayNode(items: Node[])


Properties:


  items: Node[]


Examples:

const node1 = math.parse('[1, 2, 3]')

const one    = new math.ConstantNode(1)
const two    = new math.ConstantNode(2)
const three  = new math.ConstantNode(3)
const node2  = new math.ArrayNode([one, two, three])


AssignmentNode #

Construction:

new AssignmentNode(object: SymbolNode, value: Node)
new AssignmentNode(object: SymbolNode | AccessorNode, index: IndexNode, value: Node)


Properties:


  object: SymbolNode | AccessorNode
  index: IndexNode | null
  value: Node
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a = 3')

const object = new math.SymbolNode('a')
const value = new math.ConstantNode(3)
const node2 = new math.AssignmentNode(object, value)


BlockNode #

A BlockNode is created when parsing a multi line expression like a=2;b=3 or
a=2\nb=3. Evaluating a BlockNode returns a ResultSet. The results can be
retrieved via ResultSet.entries or ResultSet.valueOf(), which contains
an Array with the results of the visible lines (i.e. lines not ending with
a semicolon).

Construction:

block = new BlockNode(Array.<{node: Node} | {node: Node, visible: boolean}>)


Properties:


  blocks: Array.<{node: Node, visible: boolean}>


Examples:

const block1 = math.parse('a=1; b=2; c=3')

const a = new math.SymbolNode('a')
const one = new math.ConstantNode(1)
const ass1 = new math.AssignmentNode(a, one)

const b = new math.SymbolNode('b')
const two = new math.ConstantNode(2)
const ass2 = new math.AssignmentNode(b, two)

const c = new math.SymbolNode('c')
const three = new math.ConstantNode(3)
const ass3 = new math.AssignmentNode(c, three)

const block2 = new BlockNode([
  {node: ass1, visible: false},
  {node: ass2, visible: false},
  {node: ass3, visible: true}
])


ConditionalNode #

Construction:

new ConditionalNode(condition: Node, trueExpr: Node, falseExpr: Node)


Properties:


  condition: Node
  trueExpr: Node
  falseExpr: Node


Examples:

const node1 = math.parse('a > 0 ? a : -a')

const a         = new math.SymbolNode('a')
const zero      = new math.ConstantNode(0)
const condition = new math.OperatorNode('>', 'larger', [a, zero])
const trueExpr  = a
const falseExpr = new math.OperatorNode('-', 'unaryMinus', [a])
const node2     = new math.ConditionalNode(condition, trueExpr, falseExpr)


ConstantNode #

Construction:

new ConstantNode(value: *)


Properties:


  value: *


Examples:

const node1 = math.parse('2.4')

const node2 = new math.ConstantNode(2.4)
const node3 = new math.ConstantNode('foo')


FunctionAssignmentNode #

Construction:

new FunctionAssignmentNode(name: string, params: string[], expr: Node)


Properties:


  name: string
  params: string[]
  expr: Node


Examples:

const node1 = math.parse('f(x) = x^2')

const x      = new math.SymbolNode('x')
const two    = new math.ConstantNode(2)
const expr   = new math.OperatorNode('^', 'pow', [x, 2])
const node2  = new math.FunctionAssignmentNode('f', ['x'], expr)


FunctionNode #

Construction:

new FunctionNode(fn: Node | string, args: Node[])


Properties:


  fn: Node | string (read-only) The object or function name which to invoke.
  args: Node[]


Static functions:


  FunctionNode.onUndefinedFunction(name: string). This function is invoked when an undefined function is evaluated. By default, the function throws an exception “Undefined function x”. The function can be overwritten to customize this behavior. See also SymbolNode.onUndefinedSymbol.


Examples:

const node1 = math.parse('sqrt(4)')

const four  = new math.ConstantNode(4)
const node3 = new math.FunctionNode(new SymbolNode('sqrt'), [four])


IndexNode #

Construction:

new IndexNode(dimensions: Node[])
new IndexNode(dimensions: Node[], dotNotation: boolean)


Each dimension can be a single value, a range, or a property. The values of
indices are one-based, including range end.

An optional property dotNotation can be provided describing whether this index
was written using dot notation like a.b, or using bracket notation
like a["b"]. Default value is false. This information is used when
stringifying the IndexNode.

Properties:


  dimensions: Node[]
  dotNotation: boolean


Examples:

const node1 = math.parse('A[1:3, 2]')

const A     = new math.SymbolNode('A')
const one   = new math.ConstantNode(1)
const two   = new math.ConstantNode(2)
const three = new math.ConstantNode(3)

const range = new math.RangeNode(one, three)
const index = new math.IndexNode([range, two])
const node2 = new math.AccessorNode(A, index)


ObjectNode #

Construction:

new ObjectNode(properties: Object.<string, Node>)


Properties:


  properties: Object.<string, Node>


Examples:

const node1 = math.parse('{a: 1, b: 2, c: 3}')

const a = new math.ConstantNode(1)
const b = new math.ConstantNode(2)
const c = new math.ConstantNode(3)
const node2 = new math.ObjectNode({a: a, b: b, c: c})


OperatorNode #

Construction:

new OperatorNode(op: string, fn: string, args: Node[], implicit: boolean = false)


Additional methods:


  
    isUnary() : boolean

    Returns true when the OperatorNode contains exactly one argument,
like with a unary minus:

    const a = new math.ConstantNode(2)
const b = new math.OperatorNode('-', 'unaryMinus', [a])
b.isUnary() // true
    
  
  
    isBinary() : boolean

    Returns true when the OperatorNode contains exactly two arguments,
like with most regular operators:

    const a = new math.ConstantNode(2)
const b = new math.ConstantNode(3)
const c = new math.OperatorNode('+', 'add', [a, b])
c.isBinary() // true
    
  


Properties:


  op: string
  fn: string
  args: Node[]
  implicit: boolean True in case of an implicit multiplication, false otherwise


Examples:

const node1 = math.parse('2.3 + 5')

const a     = new math.ConstantNode(2.3)
const b     = new math.ConstantNode(5)
const node2 = new math.OperatorNode('+', 'add', [a, b])


ParenthesisNode #

Construction:

new ParenthesisNode(content: Node)


Properties:


  content: Node


Examples:

const node1 = math.parse('(1)')

const a     = new math.ConstantNode(1)
const node2 = new math.ParenthesisNode(a)


RangeNode #

Construction:

new RangeNode(start: Node, end: Node [, step: Node])


Properties:


  start: Node
  end: Node
  step: Node | null


Examples:

const node1 = math.parse('1:10')
const node2 = math.parse('0:2:10')

const zero = new math.ConstantNode(0)
const one = new math.ConstantNode(1)
const two = new math.ConstantNode(2)
const ten = new math.ConstantNode(10)

const node3 = new math.RangeNode(one, ten)
const node4 = new math.RangeNode(zero, ten, two)


RelationalNode #

Construction:

new RelationalNode(conditionals: string[], params: Node[])


conditionals is an array of strings, each of which may be ‘smaller’, ‘larger’, ‘smallerEq’, ‘largerEq’, ‘equal’, or ‘unequal’. The conditionals array must contain exactly one fewer item than params.

Properties:


  conditionals: string[]
  params: Node[]


A RelationalNode efficiently represents a chained conditional expression with two or more comparison operators, such as 10 < x <= 50. The expression is equivalent to 10 < x and x <= 50, except that x is evaluated only once, and evaluation stops (is “short-circuited”) once any condition tests false. Operators that are subject to chaining are <, >, <=, >=, ==, and !=. For backward compatibility, math.parse will return an OperatorNode if only a single conditional is present (such as x > 2).

Examples:


const ten = new math.ConstantNode(10)
const x = new math.SymbolNode('x')
const fifty = new math.ConstantNode(50)

const node1 = new math.RelationalNode(['smaller', 'smallerEq'], [ten, x, fifty])
const node2 = math.parse('10 < x <= 50')


SymbolNode #

Construction:

new SymbolNode(name: string)


Properties:


  name: string


Static functions:


  SymbolNode.onUndefinedSymbol(name: string). This function is invoked when an undefined symbol is evaluated. By default, the function throws an exception “Undefined symbol x”. The function can be overwritten to customize this behavior. See also FunctionNode.onUndefinedFunction.


Examples:

const node = math.parse('x')

const x = new math.SymbolNode('x')\n\n\n\nExpression trees #

When parsing an expression via math.parse(expr), math.js generates an
expression tree and returns the root node of the tree. An expression tree can
be used to analyze, manipulate, and evaluate expressions.

Example:

const node = math.parse('sqrt(2 + x)')


In this case, the expression sqrt(2 + x) is parsed as:

  FunctionNode    sqrt
                   |
  OperatorNode     +
                  / \
  ConstantNode   2   x   SymbolNode


Alternatively, this expression tree can be built by manually creating nodes:

const node1 = new math.ConstantNode(2)
const node2 = new math.SymbolNode('x')
const node3 = new math.OperatorNode('+', 'add', [node1, node2])
const node4 = new math.FunctionNode('sqrt', [node3])


The resulting expression tree with root node node4 is equal to the expression
tree generated by math.parse('sqrt(2 + x)').

API #

Methods #

All nodes have the following methods:


  
    clone() : Node

    Create a shallow clone of the node.
The node itself is cloned, its childs are not cloned.
  
  
    cloneDeep() : Node

    Create a deep clone of the node.
Both the node as well as all its childs are cloned recursively.
  
  
    compile() : Object

    Compile an expression into optimized JavaScript code. compile returns an
object with a function evaluate([scope]) to evaluate. Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const code = node.compile()        // returns {evaluate: function (scope) {...}}
const evaluate = code.evaluate({x: 3}) // returns 5
    
  
  
    evaluate([scope]) : Object

    Compile and evaluate an expression, this is the equivalent of doing
node.compile().evaluate(scope). Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const evaluate = node.evaluate({x: 3}) // returns 5
    
  
  
    equals(other: Node) : boolean

    Test whether this node equals an other node. Does a deep comparison of the
values of both nodes.
  
  
    filter(callback: function) : Node[]

    Recursively filter nodes in an expression tree. The callback function is
called as callback(node: Node, path: string, parent: Node) : boolean for
every node in the tree, and must return a boolean. The function filter
returns an array with nodes for which the test returned true.
Parameter path is a string containing a relative JSON Path.

    Example:

    const node = math.parse('x^2 + x/4 + 3*y')
const filtered = node.filter(function (node) {
  return node.isSymbolNode && node.name === 'x'
})
// returns an array with two entries: two SymbolNodes 'x'
    
  
  
    forEach(callback: function) : void

    Execute a callback for each of the child nodes of this node. The callback
function is called as callback(child: Node, path: string, parent: Node): void.
Parameter path is a string containing a relative JSON Path.

    See also traverse, which is a recursive version of forEach.

    Example:

    const node = math.parse('3 * x + 2')
node.forEach(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode *
//   ConstantNode 2
    
  
  
    map(callback: function) : Node[]

    Transform a node. Creates a new Node having it’s childs be the results of
calling the provided callback function for each of the childs of the original
node. The callback function is called as callback(child: Node, path: string,
parent: Node) and must return a Node. Parameter path is a string containing
a relative JSON Path.

    See also transform, which is a recursive version of map.
  
  
    toHTML(options: object): string

    Get a HTML representation of the parsed expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toHTML()
// returns
// <span class="math-function">sqrt</span>
// <span class="math-paranthesis math-round-parenthesis">(</span>
// <span class="math-number">2</span>
// <span class="math-operator math-binary-operator math-explicit-binary-operator">/</span>
// <span class="math-number">3</span>
// <span class="math-paranthesis math-round-parenthesis">)</span>
    

    Information about the available HTML classes in HTML Classes.
Information about the options in Customization.
  
  
    toString(options: object) : string

    Get a string representation of the parsed expression. This is not exactly
the same as the original input. Example:

    const node = math.parse('3+4*2')
node.toString()  // returns '3 + (4 * 2)'
    

    Information about the options in Customization.
  
  
    toTex(options: object): string

    Get a LaTeX representation of the
expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toTex() // returns ' qrt{\frac{2}{3}}'
    

    Information about the options in Customization.
  
  
    transform(callback: function)

    Recursively transform an expression tree via a transform function. Similar
to Array.map, but recursively executed on all nodes in the expression tree.
The callback function is a mapping function accepting a node, and returning
a replacement for the node or the original node. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree, and must return a Node. Parameter path is a string containing
a relative JSON Path.

    The transform function will stop iterating when a node is replaced by the
callback function, it will not iterate over replaced nodes.

    For example, to replace all nodes of type SymbolNode having name ‘x’ with a
ConstantNode with value 3:

    const node = math.parse('x^2 + 5*x')
const transformed = node.transform(function (node, path, parent) {
  if (node.isSymbolNode && node.name === 'x') {
    return new math.ConstantNode(3)
  }
  else {
    return node
  }
})
transformed.toString() // returns '3 ^ 2 + 5 * 3'
    
  
  
    traverse(callback: function): void

    Recursively traverse all nodes in a node tree. Executes given callback for
this node and each of its child nodes. Similar to Array.forEach, except
recursive.
The callback function is a mapping function accepting a node, and returning
nothing. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree. Parameter path is a string containing a relative JSON Path.
Example:

    const node = math.parse('3 * x + 2')
node.traverse(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode +
//   OperatorNode *
//   ConstantNode 3
//   SymbolNode x
//   ConstantNode 2
    
  


Properties #

Each Node has the following properties:


  
    comment: string

    A string holding a comment if there was any in the expression, or else the
string will be empty string. A comment can be attached to the root node of
an expression or to each of the childs nodes of a BlockNode.
  
  
    isNode: true

    Is defined with value true on Nodes. Additionally, each type of node
adds it’s own flag, for example a SymbolNode as has a property
isSymbolNode: true.
  
  
    type: string

    The type of the node, for example 'SymbolNode' in case of a SymbolNode.
  


Nodes #

math.js has the following types of nodes. All nodes are available at the
namespace math.

AccessorNode #

Construction:

new AccessorNode(object: Node, index: IndexNode)


Properties:


  object: Node
  index: IndexNode
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a[3]')

const object = new math.SymbolNode('a')
const constant3 = new math.ConstantNode(3)
const index = new math.IndexNode([constant3])
const node2 = new math.AccessorNode(object, index)


ArrayNode #

Construction:

new ArrayNode(items: Node[])


Properties:


  items: Node[]


Examples:

const node1 = math.parse('[1, 2, 3]')

const one    = new math.ConstantNode(1)
const two    = new math.ConstantNode(2)
const three  = new math.ConstantNode(3)
const node2  = new math.ArrayNode([one, two, three])


AssignmentNode #

Construction:

new AssignmentNode(object: SymbolNode, value: Node)
new AssignmentNode(object: SymbolNode | AccessorNode, index: IndexNode, value: Node)


Properties:


  object: SymbolNode | AccessorNode
  index: IndexNode | null
  value: Node
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a = 3')

const object = new math.SymbolNode('a')
const value = new math.ConstantNode(3)
const node2 = new math.AssignmentNode(object, value)


BlockNode #

A BlockNode is created when parsing a multi line expression like a=2;b=3 or
a=2\nb=3. Evaluating a BlockNode returns a ResultSet. The results can be
retrieved via ResultSet.entries or ResultSet.valueOf(), which contains
an Array with the results of the visible lines (i.e. lines not ending with
a semicolon).

Construction:

block = new BlockNode(Array.<{node: Node} | {node: Node, visible: boolean}>)


Properties:


  blocks: Array.<{node: Node, visible: boolean}>


Examples:

const block1 = math.parse('a=1; b=2; c=3')

const a = new math.SymbolNode('a')
const one = new math.ConstantNode(1)
const ass1 = new math.AssignmentNode(a, one)

const b = new math.SymbolNode('b')
const two = new math.ConstantNode(2)
const ass2 = new math.AssignmentNode(b, two)

const c = new math.SymbolNode('c')
const three = new math.ConstantNode(3)
const ass3 = new math.AssignmentNode(c, three)

const block2 = new BlockNode([
  {node: ass1, visible: false},
  {node: ass2, visible: false},
  {node: ass3, visible: true}
])


ConditionalNode #

Construction:

new ConditionalNode(condition: Node, trueExpr: Node, falseExpr: Node)


Properties:


  condition: Node
  trueExpr: Node
  falseExpr: Node


Examples:

const node1 = math.parse('a > 0 ? a : -a')

const a         = new math.SymbolNode('a')
const zero      = new math.ConstantNode(0)
const condition = new math.OperatorNode('>', 'larger', [a, zero])
const trueExpr  = a
const falseExpr = new math.OperatorNode('-', 'unaryMinus', [a])
const node2     = new math.ConditionalNode(condition, trueExpr, falseExpr)


ConstantNode #

Construction:

new ConstantNode(value: *)


Properties:


  value: *


Examples:

const node1 = math.parse('2.4')

const node2 = new math.ConstantNode(2.4)
const node3 = new math.ConstantNode('foo')


FunctionAssignmentNode #

Construction:

new FunctionAssignmentNode(name: string, params: string[], expr: Node)


Properties:


  name: string
  params: string[]
  expr: Node


Examples:

const node1 = math.parse('f(x) = x^2')

const x      = new math.SymbolNode('x')
const two    = new math.ConstantNode(2)
const expr   = new math.OperatorNode('^', 'pow', [x, 2])
const node2  = new math.FunctionAssignmentNode('f', ['x'], expr)


FunctionNode #

Construction:

new FunctionNode(fn: Node | string, args: Node[])


Properties:


  fn: Node | string (read-only) The object or function name which to invoke.
  args: Node[]


Static functions:


  FunctionNode.onUndefinedFunction(name: string). This function is invoked when an undefined function is evaluated. By default, the function throws an exception “Undefined function x”. The function can be overwritten to customize this behavior. See also SymbolNode.onUndefinedSymbol.


Examples:

const node1 = math.parse('sqrt(4)')

const four  = new math.ConstantNode(4)
const node3 = new math.FunctionNode(new SymbolNode('sqrt'), [four])


IndexNode #

Construction:

new IndexNode(dimensions: Node[])
new IndexNode(dimensions: Node[], dotNotation: boolean)


Each dimension can be a single value, a range, or a property. The values of
indices are one-based, including range end.

An optional property dotNotation can be provided describing whether this index
was written using dot notation like a.b, or using bracket notation
like a["b"]. Default value is false. This information is used when
stringifying the IndexNode.

Properties:


  dimensions: Node[]
  dotNotation: boolean


Examples:

const node1 = math.parse('A[1:3, 2]')

const A     = new math.SymbolNode('A')
const one   = new math.ConstantNode(1)
const two   = new math.ConstantNode(2)
const three = new math.ConstantNode(3)

const range = new math.RangeNode(one, three)
const index = new math.IndexNode([range, two])
const node2 = new math.AccessorNode(A, index)


ObjectNode #

Construction:

new ObjectNode(properties: Object.<string, Node>)


Properties:


  properties: Object.<string, Node>


Examples:

const node1 = math.parse('{a: 1, b: 2, c: 3}')

const a = new math.ConstantNode(1)
const b = new math.ConstantNode(2)
const c = new math.ConstantNode(3)
const node2 = new math.ObjectNode({a: a, b: b, c: c})


OperatorNode #

Construction:

new OperatorNode(op: string, fn: string, args: Node[], implicit: boolean = false)


Additional methods:


  
    isUnary() : boolean

    Returns true when the OperatorNode contains exactly one argument,
like with a unary minus:

    const a = new math.ConstantNode(2)
const b = new math.OperatorNode('-', 'unaryMinus', [a])
b.isUnary() // true
    
  
  
    isBinary() : boolean

    Returns true when the OperatorNode contains exactly two arguments,
like with most regular operators:

    const a = new math.ConstantNode(2)
const b = new math.ConstantNode(3)
const c = new math.OperatorNode('+', 'add', [a, b])
c.isBinary() // true
    
  


Properties:


  op: string
  fn: string
  args: Node[]
  implicit: boolean True in case of an implicit multiplication, false otherwise


Examples:

const node1 = math.parse('2.3 + 5')

const a     = new math.ConstantNode(2.3)
const b     = new math.ConstantNode(5)
const node2 = new math.OperatorNode('+', 'add', [a, b])


ParenthesisNode #

Construction:

new ParenthesisNode(content: Node)


Properties:


  content: Node


Examples:

const node1 = math.parse('(1)')

const a     = new math.ConstantNode(1)
const node2 = new math.ParenthesisNode(a)


RangeNode #

Construction:

new RangeNode(start: Node, end: Node [, step: Node])


Properties:


  start: Node
  end: Node
  step: Node | null


Examples:

const node1 = math.parse('1:10')
const node2 = math.parse('0:2:10')

const zero = new math.ConstantNode(0)
const one = new math.ConstantNode(1)
const two = new math.ConstantNode(2)
const ten = new math.ConstantNode(10)

const node3 = new math.RangeNode(one, ten)
const node4 = new math.RangeNode(zero, ten, two)


RelationalNode #

Construction:

new RelationalNode(conditionals: string[], params: Node[])


conditionals is an array of strings, each of which may be ‘smaller’, ‘larger’, ‘smallerEq’, ‘largerEq’, ‘equal’, or ‘unequal’. The conditionals array must contain exactly one fewer item than params.

Properties:


  conditionals: string[]
  params: Node[]


A RelationalNode efficiently represents a chained conditional expression with two or more comparison operators, such as 10 < x <= 50. The expression is equivalent to 10 < x and x <= 50, except that x is evaluated only once, and evaluation stops (is “short-circuited”) once any condition tests false. Operators that are subject to chaining are <, >, <=, >=, ==, and !=. For backward compatibility, math.parse will return an OperatorNode if only a single conditional is present (such as x > 2).

Examples:


const ten = new math.ConstantNode(10)
const x = new math.SymbolNode('x')
const fifty = new math.ConstantNode(50)

const node1 = new math.RelationalNode(['smaller', 'smallerEq'], [ten, x, fifty])
const node2 = math.parse('10 < x <= 50')


SymbolNode #

Construction:

new SymbolNode(name: string)


Properties:


  name: string


Static functions:


  SymbolNode.onUndefinedSymbol(name: string). This function is invoked when an undefined symbol is evaluated. By default, the function throws an exception “Undefined symbol x”. The function can be overwritten to customize this behavior. See also FunctionNode.onUndefinedFunction.


Examples:

const node = math.parse('x')

const x = new math.SymbolNode('x')\n\n\n\nExpression trees #

When parsing an expression via math.parse(expr), math.js generates an
expression tree and returns the root node of the tree. An expression tree can
be used to analyze, manipulate, and evaluate expressions.

Example:

const node = math.parse('sqrt(2 + x)')


In this case, the expression sqrt(2 + x) is parsed as:

  FunctionNode    sqrt
                   |
  OperatorNode     +
                  / \
  ConstantNode   2   x   SymbolNode


Alternatively, this expression tree can be built by manually creating nodes:

const node1 = new math.ConstantNode(2)
const node2 = new math.SymbolNode('x')
const node3 = new math.OperatorNode('+', 'add', [node1, node2])
const node4 = new math.FunctionNode('sqrt', [node3])


The resulting expression tree with root node node4 is equal to the expression
tree generated by math.parse('sqrt(2 + x)').

API #

Methods #

All nodes have the following methods:


  
    clone() : Node

    Create a shallow clone of the node.
The node itself is cloned, its childs are not cloned.
  
  
    cloneDeep() : Node

    Create a deep clone of the node.
Both the node as well as all its childs are cloned recursively.
  
  
    compile() : Object

    Compile an expression into optimized JavaScript code. compile returns an
object with a function evaluate([scope]) to evaluate. Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const code = node.compile()        // returns {evaluate: function (scope) {...}}
const evaluate = code.evaluate({x: 3}) // returns 5
    
  
  
    evaluate([scope]) : Object

    Compile and evaluate an expression, this is the equivalent of doing
node.compile().evaluate(scope). Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const evaluate = node.evaluate({x: 3}) // returns 5
    
  
  
    equals(other: Node) : boolean

    Test whether this node equals an other node. Does a deep comparison of the
values of both nodes.
  
  
    filter(callback: function) : Node[]

    Recursively filter nodes in an expression tree. The callback function is
called as callback(node: Node, path: string, parent: Node) : boolean for
every node in the tree, and must return a boolean. The function filter
returns an array with nodes for which the test returned true.
Parameter path is a string containing a relative JSON Path.

    Example:

    const node = math.parse('x^2 + x/4 + 3*y')
const filtered = node.filter(function (node) {
  return node.isSymbolNode && node.name === 'x'
})
// returns an array with two entries: two SymbolNodes 'x'
    
  
  
    forEach(callback: function) : void

    Execute a callback for each of the child nodes of this node. The callback
function is called as callback(child: Node, path: string, parent: Node): void.
Parameter path is a string containing a relative JSON Path.

    See also traverse, which is a recursive version of forEach.

    Example:

    const node = math.parse('3 * x + 2')
node.forEach(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode *
//   ConstantNode 2
    
  
  
    map(callback: function) : Node[]

    Transform a node. Creates a new Node having it’s childs be the results of
calling the provided callback function for each of the childs of the original
node. The callback function is called as callback(child: Node, path: string,
parent: Node) and must return a Node. Parameter path is a string containing
a relative JSON Path.

    See also transform, which is a recursive version of map.
  
  
    toHTML(options: object): string

    Get a HTML representation of the parsed expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toHTML()
// returns
// <span class="math-function">sqrt</span>
// <span class="math-paranthesis math-round-parenthesis">(</span>
// <span class="math-number">2</span>
// <span class="math-operator math-binary-operator math-explicit-binary-operator">/</span>
// <span class="math-number">3</span>
// <span class="math-paranthesis math-round-parenthesis">)</span>
    

    Information about the available HTML classes in HTML Classes.
Information about the options in Customization.
  
  
    toString(options: object) : string

    Get a string representation of the parsed expression. This is not exactly
the same as the original input. Example:

    const node = math.parse('3+4*2')
node.toString()  // returns '3 + (4 * 2)'
    

    Information about the options in Customization.
  
  
    toTex(options: object): string

    Get a LaTeX representation of the
expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toTex() // returns ' qrt{\frac{2}{3}}'
    

    Information about the options in Customization.
  
  
    transform(callback: function)

    Recursively transform an expression tree via a transform function. Similar
to Array.map, but recursively executed on all nodes in the expression tree.
The callback function is a mapping function accepting a node, and returning
a replacement for the node or the original node. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree, and must return a Node. Parameter path is a string containing
a relative JSON Path.

    The transform function will stop iterating when a node is replaced by the
callback function, it will not iterate over replaced nodes.

    For example, to replace all nodes of type SymbolNode having name ‘x’ with a
ConstantNode with value 3:

    const node = math.parse('x^2 + 5*x')
const transformed = node.transform(function (node, path, parent) {
  if (node.isSymbolNode && node.name === 'x') {
    return new math.ConstantNode(3)
  }
  else {
    return node
  }
})
transformed.toString() // returns '3 ^ 2 + 5 * 3'
    
  
  
    traverse(callback: function): void

    Recursively traverse all nodes in a node tree. Executes given callback for
this node and each of its child nodes. Similar to Array.forEach, except
recursive.
The callback function is a mapping function accepting a node, and returning
nothing. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree. Parameter path is a string containing a relative JSON Path.
Example:

    const node = math.parse('3 * x + 2')
node.traverse(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode +
//   OperatorNode *
//   ConstantNode 3
//   SymbolNode x
//   ConstantNode 2
    
  


Properties #

Each Node has the following properties:


  
    comment: string

    A string holding a comment if there was any in the expression, or else the
string will be empty string. A comment can be attached to the root node of
an expression or to each of the childs nodes of a BlockNode.
  
  
    isNode: true

    Is defined with value true on Nodes. Additionally, each type of node
adds it’s own flag, for example a SymbolNode as has a property
isSymbolNode: true.
  
  
    type: string

    The type of the node, for example 'SymbolNode' in case of a SymbolNode.
  


Nodes #

math.js has the following types of nodes. All nodes are available at the
namespace math.

AccessorNode #

Construction:

new AccessorNode(object: Node, index: IndexNode)


Properties:


  object: Node
  index: IndexNode
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a[3]')

const object = new math.SymbolNode('a')
const constant3 = new math.ConstantNode(3)
const index = new math.IndexNode([constant3])
const node2 = new math.AccessorNode(object, index)


ArrayNode #

Construction:

new ArrayNode(items: Node[])


Properties:


  items: Node[]


Examples:

const node1 = math.parse('[1, 2, 3]')

const one    = new math.ConstantNode(1)
const two    = new math.ConstantNode(2)
const three  = new math.ConstantNode(3)
const node2  = new math.ArrayNode([one, two, three])


AssignmentNode #

Construction:

new AssignmentNode(object: SymbolNode, value: Node)
new AssignmentNode(object: SymbolNode | AccessorNode, index: IndexNode, value: Node)


Properties:


  object: SymbolNode | AccessorNode
  index: IndexNode | null
  value: Node
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a = 3')

const object = new math.SymbolNode('a')
const value = new math.ConstantNode(3)
const node2 = new math.AssignmentNode(object, value)


BlockNode #

A BlockNode is created when parsing a multi line expression like a=2;b=3 or
a=2\nb=3. Evaluating a BlockNode returns a ResultSet. The results can be
retrieved via ResultSet.entries or ResultSet.valueOf(), which contains
an Array with the results of the visible lines (i.e. lines not ending with
a semicolon).

Construction:

block = new BlockNode(Array.<{node: Node} | {node: Node, visible: boolean}>)


Properties:


  blocks: Array.<{node: Node, visible: boolean}>


Examples:

const block1 = math.parse('a=1; b=2; c=3')

const a = new math.SymbolNode('a')
const one = new math.ConstantNode(1)
const ass1 = new math.AssignmentNode(a, one)

const b = new math.SymbolNode('b')
const two = new math.ConstantNode(2)
const ass2 = new math.AssignmentNode(b, two)

const c = new math.SymbolNode('c')
const three = new math.ConstantNode(3)
const ass3 = new math.AssignmentNode(c, three)

const block2 = new BlockNode([
  {node: ass1, visible: false},
  {node: ass2, visible: false},
  {node: ass3, visible: true}
])


ConditionalNode #

Construction:

new ConditionalNode(condition: Node, trueExpr: Node, falseExpr: Node)


Properties:


  condition: Node
  trueExpr: Node
  falseExpr: Node


Examples:

const node1 = math.parse('a > 0 ? a : -a')

const a         = new math.SymbolNode('a')
const zero      = new math.ConstantNode(0)
const condition = new math.OperatorNode('>', 'larger', [a, zero])
const trueExpr  = a
const falseExpr = new math.OperatorNode('-', 'unaryMinus', [a])
const node2     = new math.ConditionalNode(condition, trueExpr, falseExpr)


ConstantNode #

Construction:

new ConstantNode(value: *)


Properties:


  value: *


Examples:

const node1 = math.parse('2.4')

const node2 = new math.ConstantNode(2.4)
const node3 = new math.ConstantNode('foo')


FunctionAssignmentNode #

Construction:

new FunctionAssignmentNode(name: string, params: string[], expr: Node)


Properties:


  name: string
  params: string[]
  expr: Node


Examples:

const node1 = math.parse('f(x) = x^2')

const x      = new math.SymbolNode('x')
const two    = new math.ConstantNode(2)
const expr   = new math.OperatorNode('^', 'pow', [x, 2])
const node2  = new math.FunctionAssignmentNode('f', ['x'], expr)


FunctionNode #

Construction:

new FunctionNode(fn: Node | string, args: Node[])


Properties:


  fn: Node | string (read-only) The object or function name which to invoke.
  args: Node[]


Static functions:


  FunctionNode.onUndefinedFunction(name: string). This function is invoked when an undefined function is evaluated. By default, the function throws an exception “Undefined function x”. The function can be overwritten to customize this behavior. See also SymbolNode.onUndefinedSymbol.


Examples:

const node1 = math.parse('sqrt(4)')

const four  = new math.ConstantNode(4)
const node3 = new math.FunctionNode(new SymbolNode('sqrt'), [four])


IndexNode #

Construction:

new IndexNode(dimensions: Node[])
new IndexNode(dimensions: Node[], dotNotation: boolean)


Each dimension can be a single value, a range, or a property. The values of
indices are one-based, including range end.

An optional property dotNotation can be provided describing whether this index
was written using dot notation like a.b, or using bracket notation
like a["b"]. Default value is false. This information is used when
stringifying the IndexNode.

Properties:


  dimensions: Node[]
  dotNotation: boolean


Examples:

const node1 = math.parse('A[1:3, 2]')

const A     = new math.SymbolNode('A')
const one   = new math.ConstantNode(1)
const two   = new math.ConstantNode(2)
const three = new math.ConstantNode(3)

const range = new math.RangeNode(one, three)
const index = new math.IndexNode([range, two])
const node2 = new math.AccessorNode(A, index)


ObjectNode #

Construction:

new ObjectNode(properties: Object.<string, Node>)


Properties:


  properties: Object.<string, Node>


Examples:

const node1 = math.parse('{a: 1, b: 2, c: 3}')

const a = new math.ConstantNode(1)
const b = new math.ConstantNode(2)
const c = new math.ConstantNode(3)
const node2 = new math.ObjectNode({a: a, b: b, c: c})


OperatorNode #

Construction:

new OperatorNode(op: string, fn: string, args: Node[], implicit: boolean = false)


Additional methods:


  
    isUnary() : boolean

    Returns true when the OperatorNode contains exactly one argument,
like with a unary minus:

    const a = new math.ConstantNode(2)
const b = new math.OperatorNode('-', 'unaryMinus', [a])
b.isUnary() // true
    
  
  
    isBinary() : boolean

    Returns true when the OperatorNode contains exactly two arguments,
like with most regular operators:

    const a = new math.ConstantNode(2)
const b = new math.ConstantNode(3)
const c = new math.OperatorNode('+', 'add', [a, b])
c.isBinary() // true
    
  


Properties:


  op: string
  fn: string
  args: Node[]
  implicit: boolean True in case of an implicit multiplication, false otherwise


Examples:

const node1 = math.parse('2.3 + 5')

const a     = new math.ConstantNode(2.3)
const b     = new math.ConstantNode(5)
const node2 = new math.OperatorNode('+', 'add', [a, b])


ParenthesisNode #

Construction:

new ParenthesisNode(content: Node)


Properties:


  content: Node


Examples:

const node1 = math.parse('(1)')

const a     = new math.ConstantNode(1)
const node2 = new math.ParenthesisNode(a)


RangeNode #

Construction:

new RangeNode(start: Node, end: Node [, step: Node])


Properties:


  start: Node
  end: Node
  step: Node | null


Examples:

const node1 = math.parse('1:10')
const node2 = math.parse('0:2:10')

const zero = new math.ConstantNode(0)
const one = new math.ConstantNode(1)
const two = new math.ConstantNode(2)
const ten = new math.ConstantNode(10)

const node3 = new math.RangeNode(one, ten)
const node4 = new math.RangeNode(zero, ten, two)


RelationalNode #

Construction:

new RelationalNode(conditionals: string[], params: Node[])


conditionals is an array of strings, each of which may be ‘smaller’, ‘larger’, ‘smallerEq’, ‘largerEq’, ‘equal’, or ‘unequal’. The conditionals array must contain exactly one fewer item than params.

Properties:


  conditionals: string[]
  params: Node[]


A RelationalNode efficiently represents a chained conditional expression with two or more comparison operators, such as 10 < x <= 50. The expression is equivalent to 10 < x and x <= 50, except that x is evaluated only once, and evaluation stops (is “short-circuited”) once any condition tests false. Operators that are subject to chaining are <, >, <=, >=, ==, and !=. For backward compatibility, math.parse will return an OperatorNode if only a single conditional is present (such as x > 2).

Examples:


const ten = new math.ConstantNode(10)
const x = new math.SymbolNode('x')
const fifty = new math.ConstantNode(50)

const node1 = new math.RelationalNode(['smaller', 'smallerEq'], [ten, x, fifty])
const node2 = math.parse('10 < x <= 50')


SymbolNode #

Construction:

new SymbolNode(name: string)


Properties:


  name: string


Static functions:


  SymbolNode.onUndefinedSymbol(name: string). This function is invoked when an undefined symbol is evaluated. By default, the function throws an exception “Undefined symbol x”. The function can be overwritten to customize this behavior. See also FunctionNode.onUndefinedFunction.


Examples:

const node = math.parse('x')

const x = new math.SymbolNode('x')\n\n\n\nExpression trees #

When parsing an expression via math.parse(expr), math.js generates an
expression tree and returns the root node of the tree. An expression tree can
be used to analyze, manipulate, and evaluate expressions.

Example:

const node = math.parse('sqrt(2 + x)')


In this case, the expression sqrt(2 + x) is parsed as:

  FunctionNode    sqrt
                   |
  OperatorNode     +
                  / \
  ConstantNode   2   x   SymbolNode


Alternatively, this expression tree can be built by manually creating nodes:

const node1 = new math.ConstantNode(2)
const node2 = new math.SymbolNode('x')
const node3 = new math.OperatorNode('+', 'add', [node1, node2])
const node4 = new math.FunctionNode('sqrt', [node3])


The resulting expression tree with root node node4 is equal to the expression
tree generated by math.parse('sqrt(2 + x)').

API #

Methods #

All nodes have the following methods:


  
    clone() : Node

    Create a shallow clone of the node.
The node itself is cloned, its childs are not cloned.
  
  
    cloneDeep() : Node

    Create a deep clone of the node.
Both the node as well as all its childs are cloned recursively.
  
  
    compile() : Object

    Compile an expression into optimized JavaScript code. compile returns an
object with a function evaluate([scope]) to evaluate. Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const code = node.compile()        // returns {evaluate: function (scope) {...}}
const evaluate = code.evaluate({x: 3}) // returns 5
    
  
  
    evaluate([scope]) : Object

    Compile and evaluate an expression, this is the equivalent of doing
node.compile().evaluate(scope). Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const evaluate = node.evaluate({x: 3}) // returns 5
    
  
  
    equals(other: Node) : boolean

    Test whether this node equals an other node. Does a deep comparison of the
values of both nodes.
  
  
    filter(callback: function) : Node[]

    Recursively filter nodes in an expression tree. The callback function is
called as callback(node: Node, path: string, parent: Node) : boolean for
every node in the tree, and must return a boolean. The function filter
returns an array with nodes for which the test returned true.
Parameter path is a string containing a relative JSON Path.

    Example:

    const node = math.parse('x^2 + x/4 + 3*y')
const filtered = node.filter(function (node) {
  return node.isSymbolNode && node.name === 'x'
})
// returns an array with two entries: two SymbolNodes 'x'
    
  
  
    forEach(callback: function) : void

    Execute a callback for each of the child nodes of this node. The callback
function is called as callback(child: Node, path: string, parent: Node): void.
Parameter path is a string containing a relative JSON Path.

    See also traverse, which is a recursive version of forEach.

    Example:

    const node = math.parse('3 * x + 2')
node.forEach(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode *
//   ConstantNode 2
    
  
  
    map(callback: function) : Node[]

    Transform a node. Creates a new Node having it’s childs be the results of
calling the provided callback function for each of the childs of the original
node. The callback function is called as callback(child: Node, path: string,
parent: Node) and must return a Node. Parameter path is a string containing
a relative JSON Path.

    See also transform, which is a recursive version of map.
  
  
    toHTML(options: object): string

    Get a HTML representation of the parsed expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toHTML()
// returns
// <span class="math-function">sqrt</span>
// <span class="math-paranthesis math-round-parenthesis">(</span>
// <span class="math-number">2</span>
// <span class="math-operator math-binary-operator math-explicit-binary-operator">/</span>
// <span class="math-number">3</span>
// <span class="math-paranthesis math-round-parenthesis">)</span>
    

    Information about the available HTML classes in HTML Classes.
Information about the options in Customization.
  
  
    toString(options: object) : string

    Get a string representation of the parsed expression. This is not exactly
the same as the original input. Example:

    const node = math.parse('3+4*2')
node.toString()  // returns '3 + (4 * 2)'
    

    Information about the options in Customization.
  
  
    toTex(options: object): string

    Get a LaTeX representation of the
expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toTex() // returns ' qrt{\frac{2}{3}}'
    

    Information about the options in Customization.
  
  
    transform(callback: function)

    Recursively transform an expression tree via a transform function. Similar
to Array.map, but recursively executed on all nodes in the expression tree.
The callback function is a mapping function accepting a node, and returning
a replacement for the node or the original node. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree, and must return a Node. Parameter path is a string containing
a relative JSON Path.

    The transform function will stop iterating when a node is replaced by the
callback function, it will not iterate over replaced nodes.

    For example, to replace all nodes of type SymbolNode having name ‘x’ with a
ConstantNode with value 3:

    const node = math.parse('x^2 + 5*x')
const transformed = node.transform(function (node, path, parent) {
  if (node.isSymbolNode && node.name === 'x') {
    return new math.ConstantNode(3)
  }
  else {
    return node
  }
})
transformed.toString() // returns '3 ^ 2 + 5 * 3'
    
  
  
    traverse(callback: function): void

    Recursively traverse all nodes in a node tree. Executes given callback for
this node and each of its child nodes. Similar to Array.forEach, except
recursive.
The callback function is a mapping function accepting a node, and returning
nothing. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree. Parameter path is a string containing a relative JSON Path.
Example:

    const node = math.parse('3 * x + 2')
node.traverse(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode +
//   OperatorNode *
//   ConstantNode 3
//   SymbolNode x
//   ConstantNode 2
    
  


Properties #

Each Node has the following properties:


  
    comment: string

    A string holding a comment if there was any in the expression, or else the
string will be empty string. A comment can be attached to the root node of
an expression or to each of the childs nodes of a BlockNode.
  
  
    isNode: true

    Is defined with value true on Nodes. Additionally, each type of node
adds it’s own flag, for example a SymbolNode as has a property
isSymbolNode: true.
  
  
    type: string

    The type of the node, for example 'SymbolNode' in case of a SymbolNode.
  


Nodes #

math.js has the following types of nodes. All nodes are available at the
namespace math.

AccessorNode #

Construction:

new AccessorNode(object: Node, index: IndexNode)


Properties:


  object: Node
  index: IndexNode
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a[3]')

const object = new math.SymbolNode('a')
const constant3 = new math.ConstantNode(3)
const index = new math.IndexNode([constant3])
const node2 = new math.AccessorNode(object, index)


ArrayNode #

Construction:

new ArrayNode(items: Node[])


Properties:


  items: Node[]


Examples:

const node1 = math.parse('[1, 2, 3]')

const one    = new math.ConstantNode(1)
const two    = new math.ConstantNode(2)
const three  = new math.ConstantNode(3)
const node2  = new math.ArrayNode([one, two, three])


AssignmentNode #

Construction:

new AssignmentNode(object: SymbolNode, value: Node)
new AssignmentNode(object: SymbolNode | AccessorNode, index: IndexNode, value: Node)


Properties:


  object: SymbolNode | AccessorNode
  index: IndexNode | null
  value: Node
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a = 3')

const object = new math.SymbolNode('a')
const value = new math.ConstantNode(3)
const node2 = new math.AssignmentNode(object, value)


BlockNode #

A BlockNode is created when parsing a multi line expression like a=2;b=3 or
a=2\nb=3. Evaluating a BlockNode returns a ResultSet. The results can be
retrieved via ResultSet.entries or ResultSet.valueOf(), which contains
an Array with the results of the visible lines (i.e. lines not ending with
a semicolon).

Construction:

block = new BlockNode(Array.<{node: Node} | {node: Node, visible: boolean}>)


Properties:


  blocks: Array.<{node: Node, visible: boolean}>


Examples:

const block1 = math.parse('a=1; b=2; c=3')

const a = new math.SymbolNode('a')
const one = new math.ConstantNode(1)
const ass1 = new math.AssignmentNode(a, one)

const b = new math.SymbolNode('b')
const two = new math.ConstantNode(2)
const ass2 = new math.AssignmentNode(b, two)

const c = new math.SymbolNode('c')
const three = new math.ConstantNode(3)
const ass3 = new math.AssignmentNode(c, three)

const block2 = new BlockNode([
  {node: ass1, visible: false},
  {node: ass2, visible: false},
  {node: ass3, visible: true}
])


ConditionalNode #

Construction:

new ConditionalNode(condition: Node, trueExpr: Node, falseExpr: Node)


Properties:


  condition: Node
  trueExpr: Node
  falseExpr: Node


Examples:

const node1 = math.parse('a > 0 ? a : -a')

const a         = new math.SymbolNode('a')
const zero      = new math.ConstantNode(0)
const condition = new math.OperatorNode('>', 'larger', [a, zero])
const trueExpr  = a
const falseExpr = new math.OperatorNode('-', 'unaryMinus', [a])
const node2     = new math.ConditionalNode(condition, trueExpr, falseExpr)


ConstantNode #

Construction:

new ConstantNode(value: *)


Properties:


  value: *


Examples:

const node1 = math.parse('2.4')

const node2 = new math.ConstantNode(2.4)
const node3 = new math.ConstantNode('foo')


FunctionAssignmentNode #

Construction:

new FunctionAssignmentNode(name: string, params: string[], expr: Node)


Properties:


  name: string
  params: string[]
  expr: Node


Examples:

const node1 = math.parse('f(x) = x^2')

const x      = new math.SymbolNode('x')
const two    = new math.ConstantNode(2)
const expr   = new math.OperatorNode('^', 'pow', [x, 2])
const node2  = new math.FunctionAssignmentNode('f', ['x'], expr)


FunctionNode #

Construction:

new FunctionNode(fn: Node | string, args: Node[])


Properties:


  fn: Node | string (read-only) The object or function name which to invoke.
  args: Node[]


Static functions:


  FunctionNode.onUndefinedFunction(name: string). This function is invoked when an undefined function is evaluated. By default, the function throws an exception “Undefined function x”. The function can be overwritten to customize this behavior. See also SymbolNode.onUndefinedSymbol.


Examples:

const node1 = math.parse('sqrt(4)')

const four  = new math.ConstantNode(4)
const node3 = new math.FunctionNode(new SymbolNode('sqrt'), [four])


IndexNode #

Construction:

new IndexNode(dimensions: Node[])
new IndexNode(dimensions: Node[], dotNotation: boolean)


Each dimension can be a single value, a range, or a property. The values of
indices are one-based, including range end.

An optional property dotNotation can be provided describing whether this index
was written using dot notation like a.b, or using bracket notation
like a["b"]. Default value is false. This information is used when
stringifying the IndexNode.

Properties:


  dimensions: Node[]
  dotNotation: boolean


Examples:

const node1 = math.parse('A[1:3, 2]')

const A     = new math.SymbolNode('A')
const one   = new math.ConstantNode(1)
const two   = new math.ConstantNode(2)
const three = new math.ConstantNode(3)

const range = new math.RangeNode(one, three)
const index = new math.IndexNode([range, two])
const node2 = new math.AccessorNode(A, index)


ObjectNode #

Construction:

new ObjectNode(properties: Object.<string, Node>)


Properties:


  properties: Object.<string, Node>


Examples:

const node1 = math.parse('{a: 1, b: 2, c: 3}')

const a = new math.ConstantNode(1)
const b = new math.ConstantNode(2)
const c = new math.ConstantNode(3)
const node2 = new math.ObjectNode({a: a, b: b, c: c})


OperatorNode #

Construction:

new OperatorNode(op: string, fn: string, args: Node[], implicit: boolean = false)


Additional methods:


  
    isUnary() : boolean

    Returns true when the OperatorNode contains exactly one argument,
like with a unary minus:

    const a = new math.ConstantNode(2)
const b = new math.OperatorNode('-', 'unaryMinus', [a])
b.isUnary() // true
    
  
  
    isBinary() : boolean

    Returns true when the OperatorNode contains exactly two arguments,
like with most regular operators:

    const a = new math.ConstantNode(2)
const b = new math.ConstantNode(3)
const c = new math.OperatorNode('+', 'add', [a, b])
c.isBinary() // true
    
  


Properties:


  op: string
  fn: string
  args: Node[]
  implicit: boolean True in case of an implicit multiplication, false otherwise


Examples:

const node1 = math.parse('2.3 + 5')

const a     = new math.ConstantNode(2.3)
const b     = new math.ConstantNode(5)
const node2 = new math.OperatorNode('+', 'add', [a, b])


ParenthesisNode #

Construction:

new ParenthesisNode(content: Node)


Properties:


  content: Node


Examples:

const node1 = math.parse('(1)')

const a     = new math.ConstantNode(1)
const node2 = new math.ParenthesisNode(a)


RangeNode #

Construction:

new RangeNode(start: Node, end: Node [, step: Node])


Properties:


  start: Node
  end: Node
  step: Node | null


Examples:

const node1 = math.parse('1:10')
const node2 = math.parse('0:2:10')

const zero = new math.ConstantNode(0)
const one = new math.ConstantNode(1)
const two = new math.ConstantNode(2)
const ten = new math.ConstantNode(10)

const node3 = new math.RangeNode(one, ten)
const node4 = new math.RangeNode(zero, ten, two)


RelationalNode #

Construction:

new RelationalNode(conditionals: string[], params: Node[])


conditionals is an array of strings, each of which may be ‘smaller’, ‘larger’, ‘smallerEq’, ‘largerEq’, ‘equal’, or ‘unequal’. The conditionals array must contain exactly one fewer item than params.

Properties:


  conditionals: string[]
  params: Node[]


A RelationalNode efficiently represents a chained conditional expression with two or more comparison operators, such as 10 < x <= 50. The expression is equivalent to 10 < x and x <= 50, except that x is evaluated only once, and evaluation stops (is “short-circuited”) once any condition tests false. Operators that are subject to chaining are <, >, <=, >=, ==, and !=. For backward compatibility, math.parse will return an OperatorNode if only a single conditional is present (such as x > 2).

Examples:


const ten = new math.ConstantNode(10)
const x = new math.SymbolNode('x')
const fifty = new math.ConstantNode(50)

const node1 = new math.RelationalNode(['smaller', 'smallerEq'], [ten, x, fifty])
const node2 = math.parse('10 < x <= 50')


SymbolNode #

Construction:

new SymbolNode(name: string)


Properties:


  name: string


Static functions:


  SymbolNode.onUndefinedSymbol(name: string). This function is invoked when an undefined symbol is evaluated. By default, the function throws an exception “Undefined symbol x”. The function can be overwritten to customize this behavior. See also FunctionNode.onUndefinedFunction.


Examples:

const node = math.parse('x')

const x = new math.SymbolNode('x')\n\n\n\nExpression trees #

When parsing an expression via math.parse(expr), math.js generates an
expression tree and returns the root node of the tree. An expression tree can
be used to analyze, manipulate, and evaluate expressions.

Example:

const node = math.parse('sqrt(2 + x)')


In this case, the expression sqrt(2 + x) is parsed as:

  FunctionNode    sqrt
                   |
  OperatorNode     +
                  / \
  ConstantNode   2   x   SymbolNode


Alternatively, this expression tree can be built by manually creating nodes:

const node1 = new math.ConstantNode(2)
const node2 = new math.SymbolNode('x')
const node3 = new math.OperatorNode('+', 'add', [node1, node2])
const node4 = new math.FunctionNode('sqrt', [node3])


The resulting expression tree with root node node4 is equal to the expression
tree generated by math.parse('sqrt(2 + x)').

API #

Methods #

All nodes have the following methods:


  
    clone() : Node

    Create a shallow clone of the node.
The node itself is cloned, its childs are not cloned.
  
  
    cloneDeep() : Node

    Create a deep clone of the node.
Both the node as well as all its childs are cloned recursively.
  
  
    compile() : Object

    Compile an expression into optimized JavaScript code. compile returns an
object with a function evaluate([scope]) to evaluate. Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const code = node.compile()        // returns {evaluate: function (scope) {...}}
const evaluate = code.evaluate({x: 3}) // returns 5
    
  
  
    evaluate([scope]) : Object

    Compile and evaluate an expression, this is the equivalent of doing
node.compile().evaluate(scope). Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const evaluate = node.evaluate({x: 3}) // returns 5
    
  
  
    equals(other: Node) : boolean

    Test whether this node equals an other node. Does a deep comparison of the
values of both nodes.
  
  
    filter(callback: function) : Node[]

    Recursively filter nodes in an expression tree. The callback function is
called as callback(node: Node, path: string, parent: Node) : boolean for
every node in the tree, and must return a boolean. The function filter
returns an array with nodes for which the test returned true.
Parameter path is a string containing a relative JSON Path.

    Example:

    const node = math.parse('x^2 + x/4 + 3*y')
const filtered = node.filter(function (node) {
  return node.isSymbolNode && node.name === 'x'
})
// returns an array with two entries: two SymbolNodes 'x'
    
  
  
    forEach(callback: function) : void

    Execute a callback for each of the child nodes of this node. The callback
function is called as callback(child: Node, path: string, parent: Node): void.
Parameter path is a string containing a relative JSON Path.

    See also traverse, which is a recursive version of forEach.

    Example:

    const node = math.parse('3 * x + 2')
node.forEach(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode *
//   ConstantNode 2
    
  
  
    map(callback: function) : Node[]

    Transform a node. Creates a new Node having it’s childs be the results of
calling the provided callback function for each of the childs of the original
node. The callback function is called as callback(child: Node, path: string,
parent: Node) and must return a Node. Parameter path is a string containing
a relative JSON Path.

    See also transform, which is a recursive version of map.
  
  
    toHTML(options: object): string

    Get a HTML representation of the parsed expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toHTML()
// returns
// <span class="math-function">sqrt</span>
// <span class="math-paranthesis math-round-parenthesis">(</span>
// <span class="math-number">2</span>
// <span class="math-operator math-binary-operator math-explicit-binary-operator">/</span>
// <span class="math-number">3</span>
// <span class="math-paranthesis math-round-parenthesis">)</span>
    

    Information about the available HTML classes in HTML Classes.
Information about the options in Customization.
  
  
    toString(options: object) : string

    Get a string representation of the parsed expression. This is not exactly
the same as the original input. Example:

    const node = math.parse('3+4*2')
node.toString()  // returns '3 + (4 * 2)'
    

    Information about the options in Customization.
  
  
    toTex(options: object): string

    Get a LaTeX representation of the
expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toTex() // returns ' qrt{\frac{2}{3}}'
    

    Information about the options in Customization.
  
  
    transform(callback: function)

    Recursively transform an expression tree via a transform function. Similar
to Array.map, but recursively executed on all nodes in the expression tree.
The callback function is a mapping function accepting a node, and returning
a replacement for the node or the original node. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree, and must return a Node. Parameter path is a string containing
a relative JSON Path.

    The transform function will stop iterating when a node is replaced by the
callback function, it will not iterate over replaced nodes.

    For example, to replace all nodes of type SymbolNode having name ‘x’ with a
ConstantNode with value 3:

    const node = math.parse('x^2 + 5*x')
const transformed = node.transform(function (node, path, parent) {
  if (node.isSymbolNode && node.name === 'x') {
    return new math.ConstantNode(3)
  }
  else {
    return node
  }
})
transformed.toString() // returns '3 ^ 2 + 5 * 3'
    
  
  
    traverse(callback: function): void

    Recursively traverse all nodes in a node tree. Executes given callback for
this node and each of its child nodes. Similar to Array.forEach, except
recursive.
The callback function is a mapping function accepting a node, and returning
nothing. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree. Parameter path is a string containing a relative JSON Path.
Example:

    const node = math.parse('3 * x + 2')
node.traverse(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode +
//   OperatorNode *
//   ConstantNode 3
//   SymbolNode x
//   ConstantNode 2
    
  


Properties #

Each Node has the following properties:


  
    comment: string

    A string holding a comment if there was any in the expression, or else the
string will be empty string. A comment can be attached to the root node of
an expression or to each of the childs nodes of a BlockNode.
  
  
    isNode: true

    Is defined with value true on Nodes. Additionally, each type of node
adds it’s own flag, for example a SymbolNode as has a property
isSymbolNode: true.
  
  
    type: string

    The type of the node, for example 'SymbolNode' in case of a SymbolNode.
  


Nodes #

math.js has the following types of nodes. All nodes are available at the
namespace math.

AccessorNode #

Construction:

new AccessorNode(object: Node, index: IndexNode)


Properties:


  object: Node
  index: IndexNode
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a[3]')

const object = new math.SymbolNode('a')
const constant3 = new math.ConstantNode(3)
const index = new math.IndexNode([constant3])
const node2 = new math.AccessorNode(object, index)


ArrayNode #

Construction:

new ArrayNode(items: Node[])


Properties:


  items: Node[]


Examples:

const node1 = math.parse('[1, 2, 3]')

const one    = new math.ConstantNode(1)
const two    = new math.ConstantNode(2)
const three  = new math.ConstantNode(3)
const node2  = new math.ArrayNode([one, two, three])


AssignmentNode #

Construction:

new AssignmentNode(object: SymbolNode, value: Node)
new AssignmentNode(object: SymbolNode | AccessorNode, index: IndexNode, value: Node)


Properties:


  object: SymbolNode | AccessorNode
  index: IndexNode | null
  value: Node
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a = 3')

const object = new math.SymbolNode('a')
const value = new math.ConstantNode(3)
const node2 = new math.AssignmentNode(object, value)


BlockNode #

A BlockNode is created when parsing a multi line expression like a=2;b=3 or
a=2\nb=3. Evaluating a BlockNode returns a ResultSet. The results can be
retrieved via ResultSet.entries or ResultSet.valueOf(), which contains
an Array with the results of the visible lines (i.e. lines not ending with
a semicolon).

Construction:

block = new BlockNode(Array.<{node: Node} | {node: Node, visible: boolean}>)


Properties:


  blocks: Array.<{node: Node, visible: boolean}>


Examples:

const block1 = math.parse('a=1; b=2; c=3')

const a = new math.SymbolNode('a')
const one = new math.ConstantNode(1)
const ass1 = new math.AssignmentNode(a, one)

const b = new math.SymbolNode('b')
const two = new math.ConstantNode(2)
const ass2 = new math.AssignmentNode(b, two)

const c = new math.SymbolNode('c')
const three = new math.ConstantNode(3)
const ass3 = new math.AssignmentNode(c, three)

const block2 = new BlockNode([
  {node: ass1, visible: false},
  {node: ass2, visible: false},
  {node: ass3, visible: true}
])


ConditionalNode #

Construction:

new ConditionalNode(condition: Node, trueExpr: Node, falseExpr: Node)


Properties:


  condition: Node
  trueExpr: Node
  falseExpr: Node


Examples:

const node1 = math.parse('a > 0 ? a : -a')

const a         = new math.SymbolNode('a')
const zero      = new math.ConstantNode(0)
const condition = new math.OperatorNode('>', 'larger', [a, zero])
const trueExpr  = a
const falseExpr = new math.OperatorNode('-', 'unaryMinus', [a])
const node2     = new math.ConditionalNode(condition, trueExpr, falseExpr)


ConstantNode #

Construction:

new ConstantNode(value: *)


Properties:


  value: *


Examples:

const node1 = math.parse('2.4')

const node2 = new math.ConstantNode(2.4)
const node3 = new math.ConstantNode('foo')


FunctionAssignmentNode #

Construction:

new FunctionAssignmentNode(name: string, params: string[], expr: Node)


Properties:


  name: string
  params: string[]
  expr: Node


Examples:

const node1 = math.parse('f(x) = x^2')

const x      = new math.SymbolNode('x')
const two    = new math.ConstantNode(2)
const expr   = new math.OperatorNode('^', 'pow', [x, 2])
const node2  = new math.FunctionAssignmentNode('f', ['x'], expr)


FunctionNode #

Construction:

new FunctionNode(fn: Node | string, args: Node[])


Properties:


  fn: Node | string (read-only) The object or function name which to invoke.
  args: Node[]


Static functions:


  FunctionNode.onUndefinedFunction(name: string). This function is invoked when an undefined function is evaluated. By default, the function throws an exception “Undefined function x”. The function can be overwritten to customize this behavior. See also SymbolNode.onUndefinedSymbol.


Examples:

const node1 = math.parse('sqrt(4)')

const four  = new math.ConstantNode(4)
const node3 = new math.FunctionNode(new SymbolNode('sqrt'), [four])


IndexNode #

Construction:

new IndexNode(dimensions: Node[])
new IndexNode(dimensions: Node[], dotNotation: boolean)


Each dimension can be a single value, a range, or a property. The values of
indices are one-based, including range end.

An optional property dotNotation can be provided describing whether this index
was written using dot notation like a.b, or using bracket notation
like a["b"]. Default value is false. This information is used when
stringifying the IndexNode.

Properties:


  dimensions: Node[]
  dotNotation: boolean


Examples:

const node1 = math.parse('A[1:3, 2]')

const A     = new math.SymbolNode('A')
const one   = new math.ConstantNode(1)
const two   = new math.ConstantNode(2)
const three = new math.ConstantNode(3)

const range = new math.RangeNode(one, three)
const index = new math.IndexNode([range, two])
const node2 = new math.AccessorNode(A, index)


ObjectNode #

Construction:

new ObjectNode(properties: Object.<string, Node>)


Properties:


  properties: Object.<string, Node>


Examples:

const node1 = math.parse('{a: 1, b: 2, c: 3}')

const a = new math.ConstantNode(1)
const b = new math.ConstantNode(2)
const c = new math.ConstantNode(3)
const node2 = new math.ObjectNode({a: a, b: b, c: c})


OperatorNode #

Construction:

new OperatorNode(op: string, fn: string, args: Node[], implicit: boolean = false)


Additional methods:


  
    isUnary() : boolean

    Returns true when the OperatorNode contains exactly one argument,
like with a unary minus:

    const a = new math.ConstantNode(2)
const b = new math.OperatorNode('-', 'unaryMinus', [a])
b.isUnary() // true
    
  
  
    isBinary() : boolean

    Returns true when the OperatorNode contains exactly two arguments,
like with most regular operators:

    const a = new math.ConstantNode(2)
const b = new math.ConstantNode(3)
const c = new math.OperatorNode('+', 'add', [a, b])
c.isBinary() // true
    
  


Properties:


  op: string
  fn: string
  args: Node[]
  implicit: boolean True in case of an implicit multiplication, false otherwise


Examples:

const node1 = math.parse('2.3 + 5')

const a     = new math.ConstantNode(2.3)
const b     = new math.ConstantNode(5)
const node2 = new math.OperatorNode('+', 'add', [a, b])


ParenthesisNode #

Construction:

new ParenthesisNode(content: Node)


Properties:


  content: Node


Examples:

const node1 = math.parse('(1)')

const a     = new math.ConstantNode(1)
const node2 = new math.ParenthesisNode(a)


RangeNode #

Construction:

new RangeNode(start: Node, end: Node [, step: Node])


Properties:


  start: Node
  end: Node
  step: Node | null


Examples:

const node1 = math.parse('1:10')
const node2 = math.parse('0:2:10')

const zero = new math.ConstantNode(0)
const one = new math.ConstantNode(1)
const two = new math.ConstantNode(2)
const ten = new math.ConstantNode(10)

const node3 = new math.RangeNode(one, ten)
const node4 = new math.RangeNode(zero, ten, two)


RelationalNode #

Construction:

new RelationalNode(conditionals: string[], params: Node[])


conditionals is an array of strings, each of which may be ‘smaller’, ‘larger’, ‘smallerEq’, ‘largerEq’, ‘equal’, or ‘unequal’. The conditionals array must contain exactly one fewer item than params.

Properties:


  conditionals: string[]
  params: Node[]


A RelationalNode efficiently represents a chained conditional expression with two or more comparison operators, such as 10 < x <= 50. The expression is equivalent to 10 < x and x <= 50, except that x is evaluated only once, and evaluation stops (is “short-circuited”) once any condition tests false. Operators that are subject to chaining are <, >, <=, >=, ==, and !=. For backward compatibility, math.parse will return an OperatorNode if only a single conditional is present (such as x > 2).

Examples:


const ten = new math.ConstantNode(10)
const x = new math.SymbolNode('x')
const fifty = new math.ConstantNode(50)

const node1 = new math.RelationalNode(['smaller', 'smallerEq'], [ten, x, fifty])
const node2 = math.parse('10 < x <= 50')


SymbolNode #

Construction:

new SymbolNode(name: string)


Properties:


  name: string


Static functions:


  SymbolNode.onUndefinedSymbol(name: string). This function is invoked when an undefined symbol is evaluated. By default, the function throws an exception “Undefined symbol x”. The function can be overwritten to customize this behavior. See also FunctionNode.onUndefinedFunction.


Examples:

const node = math.parse('x')

const x = new math.SymbolNode('x')\n\n\n\nExpression trees #

When parsing an expression via math.parse(expr), math.js generates an
expression tree and returns the root node of the tree. An expression tree can
be used to analyze, manipulate, and evaluate expressions.

Example:

const node = math.parse('sqrt(2 + x)')


In this case, the expression sqrt(2 + x) is parsed as:

  FunctionNode    sqrt
                   |
  OperatorNode     +
                  / \
  ConstantNode   2   x   SymbolNode


Alternatively, this expression tree can be built by manually creating nodes:

const node1 = new math.ConstantNode(2)
const node2 = new math.SymbolNode('x')
const node3 = new math.OperatorNode('+', 'add', [node1, node2])
const node4 = new math.FunctionNode('sqrt', [node3])


The resulting expression tree with root node node4 is equal to the expression
tree generated by math.parse('sqrt(2 + x)').

API #

Methods #

All nodes have the following methods:


  
    clone() : Node

    Create a shallow clone of the node.
The node itself is cloned, its childs are not cloned.
  
  
    cloneDeep() : Node

    Create a deep clone of the node.
Both the node as well as all its childs are cloned recursively.
  
  
    compile() : Object

    Compile an expression into optimized JavaScript code. compile returns an
object with a function evaluate([scope]) to evaluate. Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const code = node.compile()        // returns {evaluate: function (scope) {...}}
const evaluate = code.evaluate({x: 3}) // returns 5
    
  
  
    evaluate([scope]) : Object

    Compile and evaluate an expression, this is the equivalent of doing
node.compile().evaluate(scope). Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const evaluate = node.evaluate({x: 3}) // returns 5
    
  
  
    equals(other: Node) : boolean

    Test whether this node equals an other node. Does a deep comparison of the
values of both nodes.
  
  
    filter(callback: function) : Node[]

    Recursively filter nodes in an expression tree. The callback function is
called as callback(node: Node, path: string, parent: Node) : boolean for
every node in the tree, and must return a boolean. The function filter
returns an array with nodes for which the test returned true.
Parameter path is a string containing a relative JSON Path.

    Example:

    const node = math.parse('x^2 + x/4 + 3*y')
const filtered = node.filter(function (node) {
  return node.isSymbolNode && node.name === 'x'
})
// returns an array with two entries: two SymbolNodes 'x'
    
  
  
    forEach(callback: function) : void

    Execute a callback for each of the child nodes of this node. The callback
function is called as callback(child: Node, path: string, parent: Node): void.
Parameter path is a string containing a relative JSON Path.

    See also traverse, which is a recursive version of forEach.

    Example:

    const node = math.parse('3 * x + 2')
node.forEach(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode *
//   ConstantNode 2
    
  
  
    map(callback: function) : Node[]

    Transform a node. Creates a new Node having it’s childs be the results of
calling the provided callback function for each of the childs of the original
node. The callback function is called as callback(child: Node, path: string,
parent: Node) and must return a Node. Parameter path is a string containing
a relative JSON Path.

    See also transform, which is a recursive version of map.
  
  
    toHTML(options: object): string

    Get a HTML representation of the parsed expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toHTML()
// returns
// <span class="math-function">sqrt</span>
// <span class="math-paranthesis math-round-parenthesis">(</span>
// <span class="math-number">2</span>
// <span class="math-operator math-binary-operator math-explicit-binary-operator">/</span>
// <span class="math-number">3</span>
// <span class="math-paranthesis math-round-parenthesis">)</span>
    

    Information about the available HTML classes in HTML Classes.
Information about the options in Customization.
  
  
    toString(options: object) : string

    Get a string representation of the parsed expression. This is not exactly
the same as the original input. Example:

    const node = math.parse('3+4*2')
node.toString()  // returns '3 + (4 * 2)'
    

    Information about the options in Customization.
  
  
    toTex(options: object): string

    Get a LaTeX representation of the
expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toTex() // returns ' qrt{\frac{2}{3}}'
    

    Information about the options in Customization.
  
  
    transform(callback: function)

    Recursively transform an expression tree via a transform function. Similar
to Array.map, but recursively executed on all nodes in the expression tree.
The callback function is a mapping function accepting a node, and returning
a replacement for the node or the original node. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree, and must return a Node. Parameter path is a string containing
a relative JSON Path.

    The transform function will stop iterating when a node is replaced by the
callback function, it will not iterate over replaced nodes.

    For example, to replace all nodes of type SymbolNode having name ‘x’ with a
ConstantNode with value 3:

    const node = math.parse('x^2 + 5*x')
const transformed = node.transform(function (node, path, parent) {
  if (node.isSymbolNode && node.name === 'x') {
    return new math.ConstantNode(3)
  }
  else {
    return node
  }
})
transformed.toString() // returns '3 ^ 2 + 5 * 3'
    
  
  
    traverse(callback: function): void

    Recursively traverse all nodes in a node tree. Executes given callback for
this node and each of its child nodes. Similar to Array.forEach, except
recursive.
The callback function is a mapping function accepting a node, and returning
nothing. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree. Parameter path is a string containing a relative JSON Path.
Example:

    const node = math.parse('3 * x + 2')
node.traverse(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode +
//   OperatorNode *
//   ConstantNode 3
//   SymbolNode x
//   ConstantNode 2
    
  


Properties #

Each Node has the following properties:


  
    comment: string

    A string holding a comment if there was any in the expression, or else the
string will be empty string. A comment can be attached to the root node of
an expression or to each of the childs nodes of a BlockNode.
  
  
    isNode: true

    Is defined with value true on Nodes. Additionally, each type of node
adds it’s own flag, for example a SymbolNode as has a property
isSymbolNode: true.
  
  
    type: string

    The type of the node, for example 'SymbolNode' in case of a SymbolNode.
  


Nodes #

math.js has the following types of nodes. All nodes are available at the
namespace math.

AccessorNode #

Construction:

new AccessorNode(object: Node, index: IndexNode)


Properties:


  object: Node
  index: IndexNode
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a[3]')

const object = new math.SymbolNode('a')
const constant3 = new math.ConstantNode(3)
const index = new math.IndexNode([constant3])
const node2 = new math.AccessorNode(object, index)


ArrayNode #

Construction:

new ArrayNode(items: Node[])


Properties:


  items: Node[]


Examples:

const node1 = math.parse('[1, 2, 3]')

const one    = new math.ConstantNode(1)
const two    = new math.ConstantNode(2)
const three  = new math.ConstantNode(3)
const node2  = new math.ArrayNode([one, two, three])


AssignmentNode #

Construction:

new AssignmentNode(object: SymbolNode, value: Node)
new AssignmentNode(object: SymbolNode | AccessorNode, index: IndexNode, value: Node)


Properties:


  object: SymbolNode | AccessorNode
  index: IndexNode | null
  value: Node
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a = 3')

const object = new math.SymbolNode('a')
const value = new math.ConstantNode(3)
const node2 = new math.AssignmentNode(object, value)


BlockNode #

A BlockNode is created when parsing a multi line expression like a=2;b=3 or
a=2\nb=3. Evaluating a BlockNode returns a ResultSet. The results can be
retrieved via ResultSet.entries or ResultSet.valueOf(), which contains
an Array with the results of the visible lines (i.e. lines not ending with
a semicolon).

Construction:

block = new BlockNode(Array.<{node: Node} | {node: Node, visible: boolean}>)


Properties:


  blocks: Array.<{node: Node, visible: boolean}>


Examples:

const block1 = math.parse('a=1; b=2; c=3')

const a = new math.SymbolNode('a')
const one = new math.ConstantNode(1)
const ass1 = new math.AssignmentNode(a, one)

const b = new math.SymbolNode('b')
const two = new math.ConstantNode(2)
const ass2 = new math.AssignmentNode(b, two)

const c = new math.SymbolNode('c')
const three = new math.ConstantNode(3)
const ass3 = new math.AssignmentNode(c, three)

const block2 = new BlockNode([
  {node: ass1, visible: false},
  {node: ass2, visible: false},
  {node: ass3, visible: true}
])


ConditionalNode #

Construction:

new ConditionalNode(condition: Node, trueExpr: Node, falseExpr: Node)


Properties:


  condition: Node
  trueExpr: Node
  falseExpr: Node


Examples:

const node1 = math.parse('a > 0 ? a : -a')

const a         = new math.SymbolNode('a')
const zero      = new math.ConstantNode(0)
const condition = new math.OperatorNode('>', 'larger', [a, zero])
const trueExpr  = a
const falseExpr = new math.OperatorNode('-', 'unaryMinus', [a])
const node2     = new math.ConditionalNode(condition, trueExpr, falseExpr)


ConstantNode #

Construction:

new ConstantNode(value: *)


Properties:


  value: *


Examples:

const node1 = math.parse('2.4')

const node2 = new math.ConstantNode(2.4)
const node3 = new math.ConstantNode('foo')


FunctionAssignmentNode #

Construction:

new FunctionAssignmentNode(name: string, params: string[], expr: Node)


Properties:


  name: string
  params: string[]
  expr: Node


Examples:

const node1 = math.parse('f(x) = x^2')

const x      = new math.SymbolNode('x')
const two    = new math.ConstantNode(2)
const expr   = new math.OperatorNode('^', 'pow', [x, 2])
const node2  = new math.FunctionAssignmentNode('f', ['x'], expr)


FunctionNode #

Construction:

new FunctionNode(fn: Node | string, args: Node[])


Properties:


  fn: Node | string (read-only) The object or function name which to invoke.
  args: Node[]


Static functions:


  FunctionNode.onUndefinedFunction(name: string). This function is invoked when an undefined function is evaluated. By default, the function throws an exception “Undefined function x”. The function can be overwritten to customize this behavior. See also SymbolNode.onUndefinedSymbol.


Examples:

const node1 = math.parse('sqrt(4)')

const four  = new math.ConstantNode(4)
const node3 = new math.FunctionNode(new SymbolNode('sqrt'), [four])


IndexNode #

Construction:

new IndexNode(dimensions: Node[])
new IndexNode(dimensions: Node[], dotNotation: boolean)


Each dimension can be a single value, a range, or a property. The values of
indices are one-based, including range end.

An optional property dotNotation can be provided describing whether this index
was written using dot notation like a.b, or using bracket notation
like a["b"]. Default value is false. This information is used when
stringifying the IndexNode.

Properties:


  dimensions: Node[]
  dotNotation: boolean


Examples:

const node1 = math.parse('A[1:3, 2]')

const A     = new math.SymbolNode('A')
const one   = new math.ConstantNode(1)
const two   = new math.ConstantNode(2)
const three = new math.ConstantNode(3)

const range = new math.RangeNode(one, three)
const index = new math.IndexNode([range, two])
const node2 = new math.AccessorNode(A, index)


ObjectNode #

Construction:

new ObjectNode(properties: Object.<string, Node>)


Properties:


  properties: Object.<string, Node>


Examples:

const node1 = math.parse('{a: 1, b: 2, c: 3}')

const a = new math.ConstantNode(1)
const b = new math.ConstantNode(2)
const c = new math.ConstantNode(3)
const node2 = new math.ObjectNode({a: a, b: b, c: c})


OperatorNode #

Construction:

new OperatorNode(op: string, fn: string, args: Node[], implicit: boolean = false)


Additional methods:


  
    isUnary() : boolean

    Returns true when the OperatorNode contains exactly one argument,
like with a unary minus:

    const a = new math.ConstantNode(2)
const b = new math.OperatorNode('-', 'unaryMinus', [a])
b.isUnary() // true
    
  
  
    isBinary() : boolean

    Returns true when the OperatorNode contains exactly two arguments,
like with most regular operators:

    const a = new math.ConstantNode(2)
const b = new math.ConstantNode(3)
const c = new math.OperatorNode('+', 'add', [a, b])
c.isBinary() // true
    
  


Properties:


  op: string
  fn: string
  args: Node[]
  implicit: boolean True in case of an implicit multiplication, false otherwise


Examples:

const node1 = math.parse('2.3 + 5')

const a     = new math.ConstantNode(2.3)
const b     = new math.ConstantNode(5)
const node2 = new math.OperatorNode('+', 'add', [a, b])


ParenthesisNode #

Construction:

new ParenthesisNode(content: Node)


Properties:


  content: Node


Examples:

const node1 = math.parse('(1)')

const a     = new math.ConstantNode(1)
const node2 = new math.ParenthesisNode(a)


RangeNode #

Construction:

new RangeNode(start: Node, end: Node [, step: Node])


Properties:


  start: Node
  end: Node
  step: Node | null


Examples:

const node1 = math.parse('1:10')
const node2 = math.parse('0:2:10')

const zero = new math.ConstantNode(0)
const one = new math.ConstantNode(1)
const two = new math.ConstantNode(2)
const ten = new math.ConstantNode(10)

const node3 = new math.RangeNode(one, ten)
const node4 = new math.RangeNode(zero, ten, two)


RelationalNode #

Construction:

new RelationalNode(conditionals: string[], params: Node[])


conditionals is an array of strings, each of which may be ‘smaller’, ‘larger’, ‘smallerEq’, ‘largerEq’, ‘equal’, or ‘unequal’. The conditionals array must contain exactly one fewer item than params.

Properties:


  conditionals: string[]
  params: Node[]


A RelationalNode efficiently represents a chained conditional expression with two or more comparison operators, such as 10 < x <= 50. The expression is equivalent to 10 < x and x <= 50, except that x is evaluated only once, and evaluation stops (is “short-circuited”) once any condition tests false. Operators that are subject to chaining are <, >, <=, >=, ==, and !=. For backward compatibility, math.parse will return an OperatorNode if only a single conditional is present (such as x > 2).

Examples:


const ten = new math.ConstantNode(10)
const x = new math.SymbolNode('x')
const fifty = new math.ConstantNode(50)

const node1 = new math.RelationalNode(['smaller', 'smallerEq'], [ten, x, fifty])
const node2 = math.parse('10 < x <= 50')


SymbolNode #

Construction:

new SymbolNode(name: string)


Properties:


  name: string


Static functions:


  SymbolNode.onUndefinedSymbol(name: string). This function is invoked when an undefined symbol is evaluated. By default, the function throws an exception “Undefined symbol x”. The function can be overwritten to customize this behavior. See also FunctionNode.onUndefinedFunction.


Examples:

const node = math.parse('x')

const x = new math.SymbolNode('x')\n\n\n\nExpression trees #

When parsing an expression via math.parse(expr), math.js generates an
expression tree and returns the root node of the tree. An expression tree can
be used to analyze, manipulate, and evaluate expressions.

Example:

const node = math.parse('sqrt(2 + x)')


In this case, the expression sqrt(2 + x) is parsed as:

  FunctionNode    sqrt
                   |
  OperatorNode     +
                  / \
  ConstantNode   2   x   SymbolNode


Alternatively, this expression tree can be built by manually creating nodes:

const node1 = new math.ConstantNode(2)
const node2 = new math.SymbolNode('x')
const node3 = new math.OperatorNode('+', 'add', [node1, node2])
const node4 = new math.FunctionNode('sqrt', [node3])


The resulting expression tree with root node node4 is equal to the expression
tree generated by math.parse('sqrt(2 + x)').

API #

Methods #

All nodes have the following methods:


  
    clone() : Node

    Create a shallow clone of the node.
The node itself is cloned, its childs are not cloned.
  
  
    cloneDeep() : Node

    Create a deep clone of the node.
Both the node as well as all its childs are cloned recursively.
  
  
    compile() : Object

    Compile an expression into optimized JavaScript code. compile returns an
object with a function evaluate([scope]) to evaluate. Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const code = node.compile()        // returns {evaluate: function (scope) {...}}
const evaluate = code.evaluate({x: 3}) // returns 5
    
  
  
    evaluate([scope]) : Object

    Compile and evaluate an expression, this is the equivalent of doing
node.compile().evaluate(scope). Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const evaluate = node.evaluate({x: 3}) // returns 5
    
  
  
    equals(other: Node) : boolean

    Test whether this node equals an other node. Does a deep comparison of the
values of both nodes.
  
  
    filter(callback: function) : Node[]

    Recursively filter nodes in an expression tree. The callback function is
called as callback(node: Node, path: string, parent: Node) : boolean for
every node in the tree, and must return a boolean. The function filter
returns an array with nodes for which the test returned true.
Parameter path is a string containing a relative JSON Path.

    Example:

    const node = math.parse('x^2 + x/4 + 3*y')
const filtered = node.filter(function (node) {
  return node.isSymbolNode && node.name === 'x'
})
// returns an array with two entries: two SymbolNodes 'x'
    
  
  
    forEach(callback: function) : void

    Execute a callback for each of the child nodes of this node. The callback
function is called as callback(child: Node, path: string, parent: Node): void.
Parameter path is a string containing a relative JSON Path.

    See also traverse, which is a recursive version of forEach.

    Example:

    const node = math.parse('3 * x + 2')
node.forEach(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode *
//   ConstantNode 2
    
  
  
    map(callback: function) : Node[]

    Transform a node. Creates a new Node having it’s childs be the results of
calling the provided callback function for each of the childs of the original
node. The callback function is called as callback(child: Node, path: string,
parent: Node) and must return a Node. Parameter path is a string containing
a relative JSON Path.

    See also transform, which is a recursive version of map.
  
  
    toHTML(options: object): string

    Get a HTML representation of the parsed expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toHTML()
// returns
// <span class="math-function">sqrt</span>
// <span class="math-paranthesis math-round-parenthesis">(</span>
// <span class="math-number">2</span>
// <span class="math-operator math-binary-operator math-explicit-binary-operator">/</span>
// <span class="math-number">3</span>
// <span class="math-paranthesis math-round-parenthesis">)</span>
    

    Information about the available HTML classes in HTML Classes.
Information about the options in Customization.
  
  
    toString(options: object) : string

    Get a string representation of the parsed expression. This is not exactly
the same as the original input. Example:

    const node = math.parse('3+4*2')
node.toString()  // returns '3 + (4 * 2)'
    

    Information about the options in Customization.
  
  
    toTex(options: object): string

    Get a LaTeX representation of the
expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toTex() // returns ' qrt{\frac{2}{3}}'
    

    Information about the options in Customization.
  
  
    transform(callback: function)

    Recursively transform an expression tree via a transform function. Similar
to Array.map, but recursively executed on all nodes in the expression tree.
The callback function is a mapping function accepting a node, and returning
a replacement for the node or the original node. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree, and must return a Node. Parameter path is a string containing
a relative JSON Path.

    The transform function will stop iterating when a node is replaced by the
callback function, it will not iterate over replaced nodes.

    For example, to replace all nodes of type SymbolNode having name ‘x’ with a
ConstantNode with value 3:

    const node = math.parse('x^2 + 5*x')
const transformed = node.transform(function (node, path, parent) {
  if (node.isSymbolNode && node.name === 'x') {
    return new math.ConstantNode(3)
  }
  else {
    return node
  }
})
transformed.toString() // returns '3 ^ 2 + 5 * 3'
    
  
  
    traverse(callback: function): void

    Recursively traverse all nodes in a node tree. Executes given callback for
this node and each of its child nodes. Similar to Array.forEach, except
recursive.
The callback function is a mapping function accepting a node, and returning
nothing. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree. Parameter path is a string containing a relative JSON Path.
Example:

    const node = math.parse('3 * x + 2')
node.traverse(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode +
//   OperatorNode *
//   ConstantNode 3
//   SymbolNode x
//   ConstantNode 2
    
  


Properties #

Each Node has the following properties:


  
    comment: string

    A string holding a comment if there was any in the expression, or else the
string will be empty string. A comment can be attached to the root node of
an expression or to each of the childs nodes of a BlockNode.
  
  
    isNode: true

    Is defined with value true on Nodes. Additionally, each type of node
adds it’s own flag, for example a SymbolNode as has a property
isSymbolNode: true.
  
  
    type: string

    The type of the node, for example 'SymbolNode' in case of a SymbolNode.
  


Nodes #

math.js has the following types of nodes. All nodes are available at the
namespace math.

AccessorNode #

Construction:

new AccessorNode(object: Node, index: IndexNode)


Properties:


  object: Node
  index: IndexNode
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a[3]')

const object = new math.SymbolNode('a')
const constant3 = new math.ConstantNode(3)
const index = new math.IndexNode([constant3])
const node2 = new math.AccessorNode(object, index)


ArrayNode #

Construction:

new ArrayNode(items: Node[])


Properties:


  items: Node[]


Examples:

const node1 = math.parse('[1, 2, 3]')

const one    = new math.ConstantNode(1)
const two    = new math.ConstantNode(2)
const three  = new math.ConstantNode(3)
const node2  = new math.ArrayNode([one, two, three])


AssignmentNode #

Construction:

new AssignmentNode(object: SymbolNode, value: Node)
new AssignmentNode(object: SymbolNode | AccessorNode, index: IndexNode, value: Node)


Properties:


  object: SymbolNode | AccessorNode
  index: IndexNode | null
  value: Node
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a = 3')

const object = new math.SymbolNode('a')
const value = new math.ConstantNode(3)
const node2 = new math.AssignmentNode(object, value)


BlockNode #

A BlockNode is created when parsing a multi line expression like a=2;b=3 or
a=2\nb=3. Evaluating a BlockNode returns a ResultSet. The results can be
retrieved via ResultSet.entries or ResultSet.valueOf(), which contains
an Array with the results of the visible lines (i.e. lines not ending with
a semicolon).

Construction:

block = new BlockNode(Array.<{node: Node} | {node: Node, visible: boolean}>)


Properties:


  blocks: Array.<{node: Node, visible: boolean}>


Examples:

const block1 = math.parse('a=1; b=2; c=3')

const a = new math.SymbolNode('a')
const one = new math.ConstantNode(1)
const ass1 = new math.AssignmentNode(a, one)

const b = new math.SymbolNode('b')
const two = new math.ConstantNode(2)
const ass2 = new math.AssignmentNode(b, two)

const c = new math.SymbolNode('c')
const three = new math.ConstantNode(3)
const ass3 = new math.AssignmentNode(c, three)

const block2 = new BlockNode([
  {node: ass1, visible: false},
  {node: ass2, visible: false},
  {node: ass3, visible: true}
])


ConditionalNode #

Construction:

new ConditionalNode(condition: Node, trueExpr: Node, falseExpr: Node)


Properties:


  condition: Node
  trueExpr: Node
  falseExpr: Node


Examples:

const node1 = math.parse('a > 0 ? a : -a')

const a         = new math.SymbolNode('a')
const zero      = new math.ConstantNode(0)
const condition = new math.OperatorNode('>', 'larger', [a, zero])
const trueExpr  = a
const falseExpr = new math.OperatorNode('-', 'unaryMinus', [a])
const node2     = new math.ConditionalNode(condition, trueExpr, falseExpr)


ConstantNode #

Construction:

new ConstantNode(value: *)


Properties:


  value: *


Examples:

const node1 = math.parse('2.4')

const node2 = new math.ConstantNode(2.4)
const node3 = new math.ConstantNode('foo')


FunctionAssignmentNode #

Construction:

new FunctionAssignmentNode(name: string, params: string[], expr: Node)


Properties:


  name: string
  params: string[]
  expr: Node


Examples:

const node1 = math.parse('f(x) = x^2')

const x      = new math.SymbolNode('x')
const two    = new math.ConstantNode(2)
const expr   = new math.OperatorNode('^', 'pow', [x, 2])
const node2  = new math.FunctionAssignmentNode('f', ['x'], expr)


FunctionNode #

Construction:

new FunctionNode(fn: Node | string, args: Node[])


Properties:


  fn: Node | string (read-only) The object or function name which to invoke.
  args: Node[]


Static functions:


  FunctionNode.onUndefinedFunction(name: string). This function is invoked when an undefined function is evaluated. By default, the function throws an exception “Undefined function x”. The function can be overwritten to customize this behavior. See also SymbolNode.onUndefinedSymbol.


Examples:

const node1 = math.parse('sqrt(4)')

const four  = new math.ConstantNode(4)
const node3 = new math.FunctionNode(new SymbolNode('sqrt'), [four])


IndexNode #

Construction:

new IndexNode(dimensions: Node[])
new IndexNode(dimensions: Node[], dotNotation: boolean)


Each dimension can be a single value, a range, or a property. The values of
indices are one-based, including range end.

An optional property dotNotation can be provided describing whether this index
was written using dot notation like a.b, or using bracket notation
like a["b"]. Default value is false. This information is used when
stringifying the IndexNode.

Properties:


  dimensions: Node[]
  dotNotation: boolean


Examples:

const node1 = math.parse('A[1:3, 2]')

const A     = new math.SymbolNode('A')
const one   = new math.ConstantNode(1)
const two   = new math.ConstantNode(2)
const three = new math.ConstantNode(3)

const range = new math.RangeNode(one, three)
const index = new math.IndexNode([range, two])
const node2 = new math.AccessorNode(A, index)


ObjectNode #

Construction:

new ObjectNode(properties: Object.<string, Node>)


Properties:


  properties: Object.<string, Node>


Examples:

const node1 = math.parse('{a: 1, b: 2, c: 3}')

const a = new math.ConstantNode(1)
const b = new math.ConstantNode(2)
const c = new math.ConstantNode(3)
const node2 = new math.ObjectNode({a: a, b: b, c: c})


OperatorNode #

Construction:

new OperatorNode(op: string, fn: string, args: Node[], implicit: boolean = false)


Additional methods:


  
    isUnary() : boolean

    Returns true when the OperatorNode contains exactly one argument,
like with a unary minus:

    const a = new math.ConstantNode(2)
const b = new math.OperatorNode('-', 'unaryMinus', [a])
b.isUnary() // true
    
  
  
    isBinary() : boolean

    Returns true when the OperatorNode contains exactly two arguments,
like with most regular operators:

    const a = new math.ConstantNode(2)
const b = new math.ConstantNode(3)
const c = new math.OperatorNode('+', 'add', [a, b])
c.isBinary() // true
    
  


Properties:


  op: string
  fn: string
  args: Node[]
  implicit: boolean True in case of an implicit multiplication, false otherwise


Examples:

const node1 = math.parse('2.3 + 5')

const a     = new math.ConstantNode(2.3)
const b     = new math.ConstantNode(5)
const node2 = new math.OperatorNode('+', 'add', [a, b])


ParenthesisNode #

Construction:

new ParenthesisNode(content: Node)


Properties:


  content: Node


Examples:

const node1 = math.parse('(1)')

const a     = new math.ConstantNode(1)
const node2 = new math.ParenthesisNode(a)


RangeNode #

Construction:

new RangeNode(start: Node, end: Node [, step: Node])


Properties:


  start: Node
  end: Node
  step: Node | null


Examples:

const node1 = math.parse('1:10')
const node2 = math.parse('0:2:10')

const zero = new math.ConstantNode(0)
const one = new math.ConstantNode(1)
const two = new math.ConstantNode(2)
const ten = new math.ConstantNode(10)

const node3 = new math.RangeNode(one, ten)
const node4 = new math.RangeNode(zero, ten, two)


RelationalNode #

Construction:

new RelationalNode(conditionals: string[], params: Node[])


conditionals is an array of strings, each of which may be ‘smaller’, ‘larger’, ‘smallerEq’, ‘largerEq’, ‘equal’, or ‘unequal’. The conditionals array must contain exactly one fewer item than params.

Properties:


  conditionals: string[]
  params: Node[]


A RelationalNode efficiently represents a chained conditional expression with two or more comparison operators, such as 10 < x <= 50. The expression is equivalent to 10 < x and x <= 50, except that x is evaluated only once, and evaluation stops (is “short-circuited”) once any condition tests false. Operators that are subject to chaining are <, >, <=, >=, ==, and !=. For backward compatibility, math.parse will return an OperatorNode if only a single conditional is present (such as x > 2).

Examples:


const ten = new math.ConstantNode(10)
const x = new math.SymbolNode('x')
const fifty = new math.ConstantNode(50)

const node1 = new math.RelationalNode(['smaller', 'smallerEq'], [ten, x, fifty])
const node2 = math.parse('10 < x <= 50')


SymbolNode #

Construction:

new SymbolNode(name: string)


Properties:


  name: string


Static functions:


  SymbolNode.onUndefinedSymbol(name: string). This function is invoked when an undefined symbol is evaluated. By default, the function throws an exception “Undefined symbol x”. The function can be overwritten to customize this behavior. See also FunctionNode.onUndefinedFunction.


Examples:

const node = math.parse('x')

const x = new math.SymbolNode('x')\n\n\n\nExpression trees #

When parsing an expression via math.parse(expr), math.js generates an
expression tree and returns the root node of the tree. An expression tree can
be used to analyze, manipulate, and evaluate expressions.

Example:

const node = math.parse('sqrt(2 + x)')


In this case, the expression sqrt(2 + x) is parsed as:

  FunctionNode    sqrt
                   |
  OperatorNode     +
                  / \
  ConstantNode   2   x   SymbolNode


Alternatively, this expression tree can be built by manually creating nodes:

const node1 = new math.ConstantNode(2)
const node2 = new math.SymbolNode('x')
const node3 = new math.OperatorNode('+', 'add', [node1, node2])
const node4 = new math.FunctionNode('sqrt', [node3])


The resulting expression tree with root node node4 is equal to the expression
tree generated by math.parse('sqrt(2 + x)').

API #

Methods #

All nodes have the following methods:


  
    clone() : Node

    Create a shallow clone of the node.
The node itself is cloned, its childs are not cloned.
  
  
    cloneDeep() : Node

    Create a deep clone of the node.
Both the node as well as all its childs are cloned recursively.
  
  
    compile() : Object

    Compile an expression into optimized JavaScript code. compile returns an
object with a function evaluate([scope]) to evaluate. Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const code = node.compile()        // returns {evaluate: function (scope) {...}}
const evaluate = code.evaluate({x: 3}) // returns 5
    
  
  
    evaluate([scope]) : Object

    Compile and evaluate an expression, this is the equivalent of doing
node.compile().evaluate(scope). Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const evaluate = node.evaluate({x: 3}) // returns 5
    
  
  
    equals(other: Node) : boolean

    Test whether this node equals an other node. Does a deep comparison of the
values of both nodes.
  
  
    filter(callback: function) : Node[]

    Recursively filter nodes in an expression tree. The callback function is
called as callback(node: Node, path: string, parent: Node) : boolean for
every node in the tree, and must return a boolean. The function filter
returns an array with nodes for which the test returned true.
Parameter path is a string containing a relative JSON Path.

    Example:

    const node = math.parse('x^2 + x/4 + 3*y')
const filtered = node.filter(function (node) {
  return node.isSymbolNode && node.name === 'x'
})
// returns an array with two entries: two SymbolNodes 'x'
    
  
  
    forEach(callback: function) : void

    Execute a callback for each of the child nodes of this node. The callback
function is called as callback(child: Node, path: string, parent: Node): void.
Parameter path is a string containing a relative JSON Path.

    See also traverse, which is a recursive version of forEach.

    Example:

    const node = math.parse('3 * x + 2')
node.forEach(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode *
//   ConstantNode 2
    
  
  
    map(callback: function) : Node[]

    Transform a node. Creates a new Node having it’s childs be the results of
calling the provided callback function for each of the childs of the original
node. The callback function is called as callback(child: Node, path: string,
parent: Node) and must return a Node. Parameter path is a string containing
a relative JSON Path.

    See also transform, which is a recursive version of map.
  
  
    toHTML(options: object): string

    Get a HTML representation of the parsed expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toHTML()
// returns
// <span class="math-function">sqrt</span>
// <span class="math-paranthesis math-round-parenthesis">(</span>
// <span class="math-number">2</span>
// <span class="math-operator math-binary-operator math-explicit-binary-operator">/</span>
// <span class="math-number">3</span>
// <span class="math-paranthesis math-round-parenthesis">)</span>
    

    Information about the available HTML classes in HTML Classes.
Information about the options in Customization.
  
  
    toString(options: object) : string

    Get a string representation of the parsed expression. This is not exactly
the same as the original input. Example:

    const node = math.parse('3+4*2')
node.toString()  // returns '3 + (4 * 2)'
    

    Information about the options in Customization.
  
  
    toTex(options: object): string

    Get a LaTeX representation of the
expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toTex() // returns ' qrt{\frac{2}{3}}'
    

    Information about the options in Customization.
  
  
    transform(callback: function)

    Recursively transform an expression tree via a transform function. Similar
to Array.map, but recursively executed on all nodes in the expression tree.
The callback function is a mapping function accepting a node, and returning
a replacement for the node or the original node. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree, and must return a Node. Parameter path is a string containing
a relative JSON Path.

    The transform function will stop iterating when a node is replaced by the
callback function, it will not iterate over replaced nodes.

    For example, to replace all nodes of type SymbolNode having name ‘x’ with a
ConstantNode with value 3:

    const node = math.parse('x^2 + 5*x')
const transformed = node.transform(function (node, path, parent) {
  if (node.isSymbolNode && node.name === 'x') {
    return new math.ConstantNode(3)
  }
  else {
    return node
  }
})
transformed.toString() // returns '3 ^ 2 + 5 * 3'
    
  
  
    traverse(callback: function): void

    Recursively traverse all nodes in a node tree. Executes given callback for
this node and each of its child nodes. Similar to Array.forEach, except
recursive.
The callback function is a mapping function accepting a node, and returning
nothing. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree. Parameter path is a string containing a relative JSON Path.
Example:

    const node = math.parse('3 * x + 2')
node.traverse(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode +
//   OperatorNode *
//   ConstantNode 3
//   SymbolNode x
//   ConstantNode 2
    
  


Properties #

Each Node has the following properties:


  
    comment: string

    A string holding a comment if there was any in the expression, or else the
string will be empty string. A comment can be attached to the root node of
an expression or to each of the childs nodes of a BlockNode.
  
  
    isNode: true

    Is defined with value true on Nodes. Additionally, each type of node
adds it’s own flag, for example a SymbolNode as has a property
isSymbolNode: true.
  
  
    type: string

    The type of the node, for example 'SymbolNode' in case of a SymbolNode.
  


Nodes #

math.js has the following types of nodes. All nodes are available at the
namespace math.

AccessorNode #

Construction:

new AccessorNode(object: Node, index: IndexNode)


Properties:


  object: Node
  index: IndexNode
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a[3]')

const object = new math.SymbolNode('a')
const constant3 = new math.ConstantNode(3)
const index = new math.IndexNode([constant3])
const node2 = new math.AccessorNode(object, index)


ArrayNode #

Construction:

new ArrayNode(items: Node[])


Properties:


  items: Node[]


Examples:

const node1 = math.parse('[1, 2, 3]')

const one    = new math.ConstantNode(1)
const two    = new math.ConstantNode(2)
const three  = new math.ConstantNode(3)
const node2  = new math.ArrayNode([one, two, three])


AssignmentNode #

Construction:

new AssignmentNode(object: SymbolNode, value: Node)
new AssignmentNode(object: SymbolNode | AccessorNode, index: IndexNode, value: Node)


Properties:


  object: SymbolNode | AccessorNode
  index: IndexNode | null
  value: Node
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a = 3')

const object = new math.SymbolNode('a')
const value = new math.ConstantNode(3)
const node2 = new math.AssignmentNode(object, value)


BlockNode #

A BlockNode is created when parsing a multi line expression like a=2;b=3 or
a=2\nb=3. Evaluating a BlockNode returns a ResultSet. The results can be
retrieved via ResultSet.entries or ResultSet.valueOf(), which contains
an Array with the results of the visible lines (i.e. lines not ending with
a semicolon).

Construction:

block = new BlockNode(Array.<{node: Node} | {node: Node, visible: boolean}>)


Properties:


  blocks: Array.<{node: Node, visible: boolean}>


Examples:

const block1 = math.parse('a=1; b=2; c=3')

const a = new math.SymbolNode('a')
const one = new math.ConstantNode(1)
const ass1 = new math.AssignmentNode(a, one)

const b = new math.SymbolNode('b')
const two = new math.ConstantNode(2)
const ass2 = new math.AssignmentNode(b, two)

const c = new math.SymbolNode('c')
const three = new math.ConstantNode(3)
const ass3 = new math.AssignmentNode(c, three)

const block2 = new BlockNode([
  {node: ass1, visible: false},
  {node: ass2, visible: false},
  {node: ass3, visible: true}
])


ConditionalNode #

Construction:

new ConditionalNode(condition: Node, trueExpr: Node, falseExpr: Node)


Properties:


  condition: Node
  trueExpr: Node
  falseExpr: Node


Examples:

const node1 = math.parse('a > 0 ? a : -a')

const a         = new math.SymbolNode('a')
const zero      = new math.ConstantNode(0)
const condition = new math.OperatorNode('>', 'larger', [a, zero])
const trueExpr  = a
const falseExpr = new math.OperatorNode('-', 'unaryMinus', [a])
const node2     = new math.ConditionalNode(condition, trueExpr, falseExpr)


ConstantNode #

Construction:

new ConstantNode(value: *)


Properties:


  value: *


Examples:

const node1 = math.parse('2.4')

const node2 = new math.ConstantNode(2.4)
const node3 = new math.ConstantNode('foo')


FunctionAssignmentNode #

Construction:

new FunctionAssignmentNode(name: string, params: string[], expr: Node)


Properties:


  name: string
  params: string[]
  expr: Node


Examples:

const node1 = math.parse('f(x) = x^2')

const x      = new math.SymbolNode('x')
const two    = new math.ConstantNode(2)
const expr   = new math.OperatorNode('^', 'pow', [x, 2])
const node2  = new math.FunctionAssignmentNode('f', ['x'], expr)


FunctionNode #

Construction:

new FunctionNode(fn: Node | string, args: Node[])


Properties:


  fn: Node | string (read-only) The object or function name which to invoke.
  args: Node[]


Static functions:


  FunctionNode.onUndefinedFunction(name: string). This function is invoked when an undefined function is evaluated. By default, the function throws an exception “Undefined function x”. The function can be overwritten to customize this behavior. See also SymbolNode.onUndefinedSymbol.


Examples:

const node1 = math.parse('sqrt(4)')

const four  = new math.ConstantNode(4)
const node3 = new math.FunctionNode(new SymbolNode('sqrt'), [four])


IndexNode #

Construction:

new IndexNode(dimensions: Node[])
new IndexNode(dimensions: Node[], dotNotation: boolean)


Each dimension can be a single value, a range, or a property. The values of
indices are one-based, including range end.

An optional property dotNotation can be provided describing whether this index
was written using dot notation like a.b, or using bracket notation
like a["b"]. Default value is false. This information is used when
stringifying the IndexNode.

Properties:


  dimensions: Node[]
  dotNotation: boolean


Examples:

const node1 = math.parse('A[1:3, 2]')

const A     = new math.SymbolNode('A')
const one   = new math.ConstantNode(1)
const two   = new math.ConstantNode(2)
const three = new math.ConstantNode(3)

const range = new math.RangeNode(one, three)
const index = new math.IndexNode([range, two])
const node2 = new math.AccessorNode(A, index)


ObjectNode #

Construction:

new ObjectNode(properties: Object.<string, Node>)


Properties:


  properties: Object.<string, Node>


Examples:

const node1 = math.parse('{a: 1, b: 2, c: 3}')

const a = new math.ConstantNode(1)
const b = new math.ConstantNode(2)
const c = new math.ConstantNode(3)
const node2 = new math.ObjectNode({a: a, b: b, c: c})


OperatorNode #

Construction:

new OperatorNode(op: string, fn: string, args: Node[], implicit: boolean = false)


Additional methods:


  
    isUnary() : boolean

    Returns true when the OperatorNode contains exactly one argument,
like with a unary minus:

    const a = new math.ConstantNode(2)
const b = new math.OperatorNode('-', 'unaryMinus', [a])
b.isUnary() // true
    
  
  
    isBinary() : boolean

    Returns true when the OperatorNode contains exactly two arguments,
like with most regular operators:

    const a = new math.ConstantNode(2)
const b = new math.ConstantNode(3)
const c = new math.OperatorNode('+', 'add', [a, b])
c.isBinary() // true
    
  


Properties:


  op: string
  fn: string
  args: Node[]
  implicit: boolean True in case of an implicit multiplication, false otherwise


Examples:

const node1 = math.parse('2.3 + 5')

const a     = new math.ConstantNode(2.3)
const b     = new math.ConstantNode(5)
const node2 = new math.OperatorNode('+', 'add', [a, b])


ParenthesisNode #

Construction:

new ParenthesisNode(content: Node)


Properties:


  content: Node


Examples:

const node1 = math.parse('(1)')

const a     = new math.ConstantNode(1)
const node2 = new math.ParenthesisNode(a)


RangeNode #

Construction:

new RangeNode(start: Node, end: Node [, step: Node])


Properties:


  start: Node
  end: Node
  step: Node | null


Examples:

const node1 = math.parse('1:10')
const node2 = math.parse('0:2:10')

const zero = new math.ConstantNode(0)
const one = new math.ConstantNode(1)
const two = new math.ConstantNode(2)
const ten = new math.ConstantNode(10)

const node3 = new math.RangeNode(one, ten)
const node4 = new math.RangeNode(zero, ten, two)


RelationalNode #

Construction:

new RelationalNode(conditionals: string[], params: Node[])


conditionals is an array of strings, each of which may be ‘smaller’, ‘larger’, ‘smallerEq’, ‘largerEq’, ‘equal’, or ‘unequal’. The conditionals array must contain exactly one fewer item than params.

Properties:


  conditionals: string[]
  params: Node[]


A RelationalNode efficiently represents a chained conditional expression with two or more comparison operators, such as 10 < x <= 50. The expression is equivalent to 10 < x and x <= 50, except that x is evaluated only once, and evaluation stops (is “short-circuited”) once any condition tests false. Operators that are subject to chaining are <, >, <=, >=, ==, and !=. For backward compatibility, math.parse will return an OperatorNode if only a single conditional is present (such as x > 2).

Examples:


const ten = new math.ConstantNode(10)
const x = new math.SymbolNode('x')
const fifty = new math.ConstantNode(50)

const node1 = new math.RelationalNode(['smaller', 'smallerEq'], [ten, x, fifty])
const node2 = math.parse('10 < x <= 50')


SymbolNode #

Construction:

new SymbolNode(name: string)


Properties:


  name: string


Static functions:


  SymbolNode.onUndefinedSymbol(name: string). This function is invoked when an undefined symbol is evaluated. By default, the function throws an exception “Undefined symbol x”. The function can be overwritten to customize this behavior. See also FunctionNode.onUndefinedFunction.


Examples:

const node = math.parse('x')

const x = new math.SymbolNode('x')\n\n\n\nExpression trees #

When parsing an expression via math.parse(expr), math.js generates an
expression tree and returns the root node of the tree. An expression tree can
be used to analyze, manipulate, and evaluate expressions.

Example:

const node = math.parse('sqrt(2 + x)')


In this case, the expression sqrt(2 + x) is parsed as:

  FunctionNode    sqrt
                   |
  OperatorNode     +
                  / \
  ConstantNode   2   x   SymbolNode


Alternatively, this expression tree can be built by manually creating nodes:

const node1 = new math.ConstantNode(2)
const node2 = new math.SymbolNode('x')
const node3 = new math.OperatorNode('+', 'add', [node1, node2])
const node4 = new math.FunctionNode('sqrt', [node3])


The resulting expression tree with root node node4 is equal to the expression
tree generated by math.parse('sqrt(2 + x)').

API #

Methods #

All nodes have the following methods:


  
    clone() : Node

    Create a shallow clone of the node.
The node itself is cloned, its childs are not cloned.
  
  
    cloneDeep() : Node

    Create a deep clone of the node.
Both the node as well as all its childs are cloned recursively.
  
  
    compile() : Object

    Compile an expression into optimized JavaScript code. compile returns an
object with a function evaluate([scope]) to evaluate. Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const code = node.compile()        // returns {evaluate: function (scope) {...}}
const evaluate = code.evaluate({x: 3}) // returns 5
    
  
  
    evaluate([scope]) : Object

    Compile and evaluate an expression, this is the equivalent of doing
node.compile().evaluate(scope). Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const evaluate = node.evaluate({x: 3}) // returns 5
    
  
  
    equals(other: Node) : boolean

    Test whether this node equals an other node. Does a deep comparison of the
values of both nodes.
  
  
    filter(callback: function) : Node[]

    Recursively filter nodes in an expression tree. The callback function is
called as callback(node: Node, path: string, parent: Node) : boolean for
every node in the tree, and must return a boolean. The function filter
returns an array with nodes for which the test returned true.
Parameter path is a string containing a relative JSON Path.

    Example:

    const node = math.parse('x^2 + x/4 + 3*y')
const filtered = node.filter(function (node) {
  return node.isSymbolNode && node.name === 'x'
})
// returns an array with two entries: two SymbolNodes 'x'
    
  
  
    forEach(callback: function) : void

    Execute a callback for each of the child nodes of this node. The callback
function is called as callback(child: Node, path: string, parent: Node): void.
Parameter path is a string containing a relative JSON Path.

    See also traverse, which is a recursive version of forEach.

    Example:

    const node = math.parse('3 * x + 2')
node.forEach(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode *
//   ConstantNode 2
    
  
  
    map(callback: function) : Node[]

    Transform a node. Creates a new Node having it’s childs be the results of
calling the provided callback function for each of the childs of the original
node. The callback function is called as callback(child: Node, path: string,
parent: Node) and must return a Node. Parameter path is a string containing
a relative JSON Path.

    See also transform, which is a recursive version of map.
  
  
    toHTML(options: object): string

    Get a HTML representation of the parsed expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toHTML()
// returns
// <span class="math-function">sqrt</span>
// <span class="math-paranthesis math-round-parenthesis">(</span>
// <span class="math-number">2</span>
// <span class="math-operator math-binary-operator math-explicit-binary-operator">/</span>
// <span class="math-number">3</span>
// <span class="math-paranthesis math-round-parenthesis">)</span>
    

    Information about the available HTML classes in HTML Classes.
Information about the options in Customization.
  
  
    toString(options: object) : string

    Get a string representation of the parsed expression. This is not exactly
the same as the original input. Example:

    const node = math.parse('3+4*2')
node.toString()  // returns '3 + (4 * 2)'
    

    Information about the options in Customization.
  
  
    toTex(options: object): string

    Get a LaTeX representation of the
expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toTex() // returns ' qrt{\frac{2}{3}}'
    

    Information about the options in Customization.
  
  
    transform(callback: function)

    Recursively transform an expression tree via a transform function. Similar
to Array.map, but recursively executed on all nodes in the expression tree.
The callback function is a mapping function accepting a node, and returning
a replacement for the node or the original node. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree, and must return a Node. Parameter path is a string containing
a relative JSON Path.

    The transform function will stop iterating when a node is replaced by the
callback function, it will not iterate over replaced nodes.

    For example, to replace all nodes of type SymbolNode having name ‘x’ with a
ConstantNode with value 3:

    const node = math.parse('x^2 + 5*x')
const transformed = node.transform(function (node, path, parent) {
  if (node.isSymbolNode && node.name === 'x') {
    return new math.ConstantNode(3)
  }
  else {
    return node
  }
})
transformed.toString() // returns '3 ^ 2 + 5 * 3'
    
  
  
    traverse(callback: function): void

    Recursively traverse all nodes in a node tree. Executes given callback for
this node and each of its child nodes. Similar to Array.forEach, except
recursive.
The callback function is a mapping function accepting a node, and returning
nothing. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree. Parameter path is a string containing a relative JSON Path.
Example:

    const node = math.parse('3 * x + 2')
node.traverse(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode +
//   OperatorNode *
//   ConstantNode 3
//   SymbolNode x
//   ConstantNode 2
    
  


Properties #

Each Node has the following properties:


  
    comment: string

    A string holding a comment if there was any in the expression, or else the
string will be empty string. A comment can be attached to the root node of
an expression or to each of the childs nodes of a BlockNode.
  
  
    isNode: true

    Is defined with value true on Nodes. Additionally, each type of node
adds it’s own flag, for example a SymbolNode as has a property
isSymbolNode: true.
  
  
    type: string

    The type of the node, for example 'SymbolNode' in case of a SymbolNode.
  


Nodes #

math.js has the following types of nodes. All nodes are available at the
namespace math.

AccessorNode #

Construction:

new AccessorNode(object: Node, index: IndexNode)


Properties:


  object: Node
  index: IndexNode
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a[3]')

const object = new math.SymbolNode('a')
const constant3 = new math.ConstantNode(3)
const index = new math.IndexNode([constant3])
const node2 = new math.AccessorNode(object, index)


ArrayNode #

Construction:

new ArrayNode(items: Node[])


Properties:


  items: Node[]


Examples:

const node1 = math.parse('[1, 2, 3]')

const one    = new math.ConstantNode(1)
const two    = new math.ConstantNode(2)
const three  = new math.ConstantNode(3)
const node2  = new math.ArrayNode([one, two, three])


AssignmentNode #

Construction:

new AssignmentNode(object: SymbolNode, value: Node)
new AssignmentNode(object: SymbolNode | AccessorNode, index: IndexNode, value: Node)


Properties:


  object: SymbolNode | AccessorNode
  index: IndexNode | null
  value: Node
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a = 3')

const object = new math.SymbolNode('a')
const value = new math.ConstantNode(3)
const node2 = new math.AssignmentNode(object, value)


BlockNode #

A BlockNode is created when parsing a multi line expression like a=2;b=3 or
a=2\nb=3. Evaluating a BlockNode returns a ResultSet. The results can be
retrieved via ResultSet.entries or ResultSet.valueOf(), which contains
an Array with the results of the visible lines (i.e. lines not ending with
a semicolon).

Construction:

block = new BlockNode(Array.<{node: Node} | {node: Node, visible: boolean}>)


Properties:


  blocks: Array.<{node: Node, visible: boolean}>


Examples:

const block1 = math.parse('a=1; b=2; c=3')

const a = new math.SymbolNode('a')
const one = new math.ConstantNode(1)
const ass1 = new math.AssignmentNode(a, one)

const b = new math.SymbolNode('b')
const two = new math.ConstantNode(2)
const ass2 = new math.AssignmentNode(b, two)

const c = new math.SymbolNode('c')
const three = new math.ConstantNode(3)
const ass3 = new math.AssignmentNode(c, three)

const block2 = new BlockNode([
  {node: ass1, visible: false},
  {node: ass2, visible: false},
  {node: ass3, visible: true}
])


ConditionalNode #

Construction:

new ConditionalNode(condition: Node, trueExpr: Node, falseExpr: Node)


Properties:


  condition: Node
  trueExpr: Node
  falseExpr: Node


Examples:

const node1 = math.parse('a > 0 ? a : -a')

const a         = new math.SymbolNode('a')
const zero      = new math.ConstantNode(0)
const condition = new math.OperatorNode('>', 'larger', [a, zero])
const trueExpr  = a
const falseExpr = new math.OperatorNode('-', 'unaryMinus', [a])
const node2     = new math.ConditionalNode(condition, trueExpr, falseExpr)


ConstantNode #

Construction:

new ConstantNode(value: *)


Properties:


  value: *


Examples:

const node1 = math.parse('2.4')

const node2 = new math.ConstantNode(2.4)
const node3 = new math.ConstantNode('foo')


FunctionAssignmentNode #

Construction:

new FunctionAssignmentNode(name: string, params: string[], expr: Node)


Properties:


  name: string
  params: string[]
  expr: Node


Examples:

const node1 = math.parse('f(x) = x^2')

const x      = new math.SymbolNode('x')
const two    = new math.ConstantNode(2)
const expr   = new math.OperatorNode('^', 'pow', [x, 2])
const node2  = new math.FunctionAssignmentNode('f', ['x'], expr)


FunctionNode #

Construction:

new FunctionNode(fn: Node | string, args: Node[])


Properties:


  fn: Node | string (read-only) The object or function name which to invoke.
  args: Node[]


Static functions:


  FunctionNode.onUndefinedFunction(name: string). This function is invoked when an undefined function is evaluated. By default, the function throws an exception “Undefined function x”. The function can be overwritten to customize this behavior. See also SymbolNode.onUndefinedSymbol.


Examples:

const node1 = math.parse('sqrt(4)')

const four  = new math.ConstantNode(4)
const node3 = new math.FunctionNode(new SymbolNode('sqrt'), [four])


IndexNode #

Construction:

new IndexNode(dimensions: Node[])
new IndexNode(dimensions: Node[], dotNotation: boolean)


Each dimension can be a single value, a range, or a property. The values of
indices are one-based, including range end.

An optional property dotNotation can be provided describing whether this index
was written using dot notation like a.b, or using bracket notation
like a["b"]. Default value is false. This information is used when
stringifying the IndexNode.

Properties:


  dimensions: Node[]
  dotNotation: boolean


Examples:

const node1 = math.parse('A[1:3, 2]')

const A     = new math.SymbolNode('A')
const one   = new math.ConstantNode(1)
const two   = new math.ConstantNode(2)
const three = new math.ConstantNode(3)

const range = new math.RangeNode(one, three)
const index = new math.IndexNode([range, two])
const node2 = new math.AccessorNode(A, index)


ObjectNode #

Construction:

new ObjectNode(properties: Object.<string, Node>)


Properties:


  properties: Object.<string, Node>


Examples:

const node1 = math.parse('{a: 1, b: 2, c: 3}')

const a = new math.ConstantNode(1)
const b = new math.ConstantNode(2)
const c = new math.ConstantNode(3)
const node2 = new math.ObjectNode({a: a, b: b, c: c})


OperatorNode #

Construction:

new OperatorNode(op: string, fn: string, args: Node[], implicit: boolean = false)


Additional methods:


  
    isUnary() : boolean

    Returns true when the OperatorNode contains exactly one argument,
like with a unary minus:

    const a = new math.ConstantNode(2)
const b = new math.OperatorNode('-', 'unaryMinus', [a])
b.isUnary() // true
    
  
  
    isBinary() : boolean

    Returns true when the OperatorNode contains exactly two arguments,
like with most regular operators:

    const a = new math.ConstantNode(2)
const b = new math.ConstantNode(3)
const c = new math.OperatorNode('+', 'add', [a, b])
c.isBinary() // true
    
  


Properties:


  op: string
  fn: string
  args: Node[]
  implicit: boolean True in case of an implicit multiplication, false otherwise


Examples:

const node1 = math.parse('2.3 + 5')

const a     = new math.ConstantNode(2.3)
const b     = new math.ConstantNode(5)
const node2 = new math.OperatorNode('+', 'add', [a, b])


ParenthesisNode #

Construction:

new ParenthesisNode(content: Node)


Properties:


  content: Node


Examples:

const node1 = math.parse('(1)')

const a     = new math.ConstantNode(1)
const node2 = new math.ParenthesisNode(a)


RangeNode #

Construction:

new RangeNode(start: Node, end: Node [, step: Node])


Properties:


  start: Node
  end: Node
  step: Node | null


Examples:

const node1 = math.parse('1:10')
const node2 = math.parse('0:2:10')

const zero = new math.ConstantNode(0)
const one = new math.ConstantNode(1)
const two = new math.ConstantNode(2)
const ten = new math.ConstantNode(10)

const node3 = new math.RangeNode(one, ten)
const node4 = new math.RangeNode(zero, ten, two)


RelationalNode #

Construction:

new RelationalNode(conditionals: string[], params: Node[])


conditionals is an array of strings, each of which may be ‘smaller’, ‘larger’, ‘smallerEq’, ‘largerEq’, ‘equal’, or ‘unequal’. The conditionals array must contain exactly one fewer item than params.

Properties:


  conditionals: string[]
  params: Node[]


A RelationalNode efficiently represents a chained conditional expression with two or more comparison operators, such as 10 < x <= 50. The expression is equivalent to 10 < x and x <= 50, except that x is evaluated only once, and evaluation stops (is “short-circuited”) once any condition tests false. Operators that are subject to chaining are <, >, <=, >=, ==, and !=. For backward compatibility, math.parse will return an OperatorNode if only a single conditional is present (such as x > 2).

Examples:


const ten = new math.ConstantNode(10)
const x = new math.SymbolNode('x')
const fifty = new math.ConstantNode(50)

const node1 = new math.RelationalNode(['smaller', 'smallerEq'], [ten, x, fifty])
const node2 = math.parse('10 < x <= 50')


SymbolNode #

Construction:

new SymbolNode(name: string)


Properties:


  name: string


Static functions:


  SymbolNode.onUndefinedSymbol(name: string). This function is invoked when an undefined symbol is evaluated. By default, the function throws an exception “Undefined symbol x”. The function can be overwritten to customize this behavior. See also FunctionNode.onUndefinedFunction.


Examples:

const node = math.parse('x')

const x = new math.SymbolNode('x')\n\n\n\nExpression trees #

When parsing an expression via math.parse(expr), math.js generates an
expression tree and returns the root node of the tree. An expression tree can
be used to analyze, manipulate, and evaluate expressions.

Example:

const node = math.parse('sqrt(2 + x)')


In this case, the expression sqrt(2 + x) is parsed as:

  FunctionNode    sqrt
                   |
  OperatorNode     +
                  / \
  ConstantNode   2   x   SymbolNode


Alternatively, this expression tree can be built by manually creating nodes:

const node1 = new math.ConstantNode(2)
const node2 = new math.SymbolNode('x')
const node3 = new math.OperatorNode('+', 'add', [node1, node2])
const node4 = new math.FunctionNode('sqrt', [node3])


The resulting expression tree with root node node4 is equal to the expression
tree generated by math.parse('sqrt(2 + x)').

API #

Methods #

All nodes have the following methods:


  
    clone() : Node

    Create a shallow clone of the node.
The node itself is cloned, its childs are not cloned.
  
  
    cloneDeep() : Node

    Create a deep clone of the node.
Both the node as well as all its childs are cloned recursively.
  
  
    compile() : Object

    Compile an expression into optimized JavaScript code. compile returns an
object with a function evaluate([scope]) to evaluate. Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const code = node.compile()        // returns {evaluate: function (scope) {...}}
const evaluate = code.evaluate({x: 3}) // returns 5
    
  
  
    evaluate([scope]) : Object

    Compile and evaluate an expression, this is the equivalent of doing
node.compile().evaluate(scope). Example:

    const node = math.parse('2 + x')   // returns the root Node of an expression tree
const evaluate = node.evaluate({x: 3}) // returns 5
    
  
  
    equals(other: Node) : boolean

    Test whether this node equals an other node. Does a deep comparison of the
values of both nodes.
  
  
    filter(callback: function) : Node[]

    Recursively filter nodes in an expression tree. The callback function is
called as callback(node: Node, path: string, parent: Node) : boolean for
every node in the tree, and must return a boolean. The function filter
returns an array with nodes for which the test returned true.
Parameter path is a string containing a relative JSON Path.

    Example:

    const node = math.parse('x^2 + x/4 + 3*y')
const filtered = node.filter(function (node) {
  return node.isSymbolNode && node.name === 'x'
})
// returns an array with two entries: two SymbolNodes 'x'
    
  
  
    forEach(callback: function) : void

    Execute a callback for each of the child nodes of this node. The callback
function is called as callback(child: Node, path: string, parent: Node): void.
Parameter path is a string containing a relative JSON Path.

    See also traverse, which is a recursive version of forEach.

    Example:

    const node = math.parse('3 * x + 2')
node.forEach(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode *
//   ConstantNode 2
    
  
  
    map(callback: function) : Node[]

    Transform a node. Creates a new Node having it’s childs be the results of
calling the provided callback function for each of the childs of the original
node. The callback function is called as callback(child: Node, path: string,
parent: Node) and must return a Node. Parameter path is a string containing
a relative JSON Path.

    See also transform, which is a recursive version of map.
  
  
    toHTML(options: object): string

    Get a HTML representation of the parsed expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toHTML()
// returns
// <span class="math-function">sqrt</span>
// <span class="math-paranthesis math-round-parenthesis">(</span>
// <span class="math-number">2</span>
// <span class="math-operator math-binary-operator math-explicit-binary-operator">/</span>
// <span class="math-number">3</span>
// <span class="math-paranthesis math-round-parenthesis">)</span>
    

    Information about the available HTML classes in HTML Classes.
Information about the options in Customization.
  
  
    toString(options: object) : string

    Get a string representation of the parsed expression. This is not exactly
the same as the original input. Example:

    const node = math.parse('3+4*2')
node.toString()  // returns '3 + (4 * 2)'
    

    Information about the options in Customization.
  
  
    toTex(options: object): string

    Get a LaTeX representation of the
expression. Example:

    const node = math.parse('sqrt(2/3)')
node.toTex() // returns ' qrt{\frac{2}{3}}'
    

    Information about the options in Customization.
  
  
    transform(callback: function)

    Recursively transform an expression tree via a transform function. Similar
to Array.map, but recursively executed on all nodes in the expression tree.
The callback function is a mapping function accepting a node, and returning
a replacement for the node or the original node. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree, and must return a Node. Parameter path is a string containing
a relative JSON Path.

    The transform function will stop iterating when a node is replaced by the
callback function, it will not iterate over replaced nodes.

    For example, to replace all nodes of type SymbolNode having name ‘x’ with a
ConstantNode with value 3:

    const node = math.parse('x^2 + 5*x')
const transformed = node.transform(function (node, path, parent) {
  if (node.isSymbolNode && node.name === 'x') {
    return new math.ConstantNode(3)
  }
  else {
    return node
  }
})
transformed.toString() // returns '3 ^ 2 + 5 * 3'
    
  
  
    traverse(callback: function): void

    Recursively traverse all nodes in a node tree. Executes given callback for
this node and each of its child nodes. Similar to Array.forEach, except
recursive.
The callback function is a mapping function accepting a node, and returning
nothing. Function callback is
called as callback(node: Node, path: string, parent: Node) for every node
in the tree. Parameter path is a string containing a relative JSON Path.
Example:

    const node = math.parse('3 * x + 2')
node.traverse(function (node, path, parent) {
  switch (node.type) {
    case 'OperatorNode':
      console.log(node.type, node.op)
      break
    case 'ConstantNode':
      console.log(node.type, node.value)
      break
    case 'SymbolNode':
      console.log(node.type, node.name)
      break
    default:
      console.log(node.type)
  }
})
// outputs:
//   OperatorNode +
//   OperatorNode *
//   ConstantNode 3
//   SymbolNode x
//   ConstantNode 2
    
  


Properties #

Each Node has the following properties:


  
    comment: string

    A string holding a comment if there was any in the expression, or else the
string will be empty string. A comment can be attached to the root node of
an expression or to each of the childs nodes of a BlockNode.
  
  
    isNode: true

    Is defined with value true on Nodes. Additionally, each type of node
adds it’s own flag, for example a SymbolNode as has a property
isSymbolNode: true.
  
  
    type: string

    The type of the node, for example 'SymbolNode' in case of a SymbolNode.
  


Nodes #

math.js has the following types of nodes. All nodes are available at the
namespace math.

AccessorNode #

Construction:

new AccessorNode(object: Node, index: IndexNode)


Properties:


  object: Node
  index: IndexNode
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a[3]')

const object = new math.SymbolNode('a')
const constant3 = new math.ConstantNode(3)
const index = new math.IndexNode([constant3])
const node2 = new math.AccessorNode(object, index)


ArrayNode #

Construction:

new ArrayNode(items: Node[])


Properties:


  items: Node[]


Examples:

const node1 = math.parse('[1, 2, 3]')

const one    = new math.ConstantNode(1)
const two    = new math.ConstantNode(2)
const three  = new math.ConstantNode(3)
const node2  = new math.ArrayNode([one, two, three])


AssignmentNode #

Construction:

new AssignmentNode(object: SymbolNode, value: Node)
new AssignmentNode(object: SymbolNode | AccessorNode, index: IndexNode, value: Node)


Properties:


  object: SymbolNode | AccessorNode
  index: IndexNode | null
  value: Node
  name: string (read-only) The function or method name. Returns an empty string when undefined.


Examples:

const node1 = math.parse('a = 3')

const object = new math.SymbolNode('a')
const value = new math.ConstantNode(3)
const node2 = new math.AssignmentNode(object, value)


BlockNode #

A BlockNode is created when parsing a multi line expression like a=2;b=3 or
a=2\nb=3. Evaluating a BlockNode returns a ResultSet. The results can be
retrieved via ResultSet.entries or ResultSet.valueOf(), which contains
an Array with the results of the visible lines (i.e. lines not ending with
a semicolon).

Construction:

block = new BlockNode(Array.<{node: Node} | {node: Node, visible: boolean}>)


Properties:


  blocks: Array.<{node: Node, visible: boolean}>


Examples:

const block1 = math.parse('a=1; b=2; c=3')

const a = new math.SymbolNode('a')
const one = new math.ConstantNode(1)
const ass1 = new math.AssignmentNode(a, one)

const b = new math.SymbolNode('b')
const two = new math.ConstantNode(2)
const ass2 = new math.AssignmentNode(b, two)

const c = new math.SymbolNode('c')
const three = new math.ConstantNode(3)
const ass3 = new math.AssignmentNode(c, three)

const block2 = new BlockNode([
  {node: ass1, visible: false},
  {node: ass2, visible: false},
  {node: ass3, visible: true}
])


ConditionalNode #

Construction:

new ConditionalNode(condition: Node, trueExpr: Node, falseExpr: Node)


Properties:


  condition: Node
  trueExpr: Node
  falseExpr: Node


Examples:

const node1 = math.parse('a > 0 ? a : -a')

const a         = new math.SymbolNode('a')
const zero      = new math.ConstantNode(0)
const condition = new math.OperatorNode('>', 'larger', [a, zero])
const trueExpr  = a
const falseExpr = new math.OperatorNode('-', 'unaryMinus', [a])
const node2     = new math.ConditionalNode(condition, trueExpr, falseExpr)


ConstantNode #

Construction:

new ConstantNode(value: *)


Properties:


  value: *


Examples:

const node1 = math.parse('2.4')

const node2 = new math.ConstantNode(2.4)
const node3 = new math.ConstantNode('foo')


FunctionAssignmentNode #

Construction:

new FunctionAssignmentNode(name: string, params: string[], expr: Node)


Properties:


  name: string
  params: string[]
  expr: Node


Examples:

const node1 = math.parse('f(x) = x^2')

const x      = new math.SymbolNode('x')
const two    = new math.ConstantNode(2)
const expr   = new math.OperatorNode('^', 'pow', [x, 2])
const node2  = new math.FunctionAssignmentNode('f', ['x'], expr)


FunctionNode #

Construction:

new FunctionNode(fn: Node | string, args: Node[])


Properties:


  fn: Node | string (read-only) The object or function name which to invoke.
  args: Node[]


Static functions:


  FunctionNode.onUndefinedFunction(name: string). This function is invoked when an undefined function is evaluated. By default, the function throws an exception “Undefined function x”. The function can be overwritten to customize this behavior. See also SymbolNode.onUndefinedSymbol.


Examples:

const node1 = math.parse('sqrt(4)')

const four  = new math.ConstantNode(4)
const node3 = new math.FunctionNode(new SymbolNode('sqrt'), [four])


IndexNode #

Construction:

new IndexNode(dimensions: Node[])
new IndexNode(dimensions: Node[], dotNotation: boolean)


Each dimension can be a single value, a range, or a property. The values of
indices are one-based, including range end.

An optional property dotNotation can be provided describing whether this index
was written using dot notation like a.b, or using bracket notation
like a["b"]. Default value is false. This information is used when
stringifying the IndexNode.

Properties:


  dimensions: Node[]
  dotNotation: boolean


Examples:

const node1 = math.parse('A[1:3, 2]')

const A     = new math.SymbolNode('A')
const one   = new math.ConstantNode(1)
const two   = new math.ConstantNode(2)
const three = new math.ConstantNode(3)

const range = new math.RangeNode(one, three)
const index = new math.IndexNode([range, two])
const node2 = new math.AccessorNode(A, index)


ObjectNode #

Construction:

new ObjectNode(properties: Object.<string, Node>)


Properties:


  properties: Object.<string, Node>


Examples:

const node1 = math.parse('{a: 1, b: 2, c: 3}')

const a = new math.ConstantNode(1)
const b = new math.ConstantNode(2)
const c = new math.ConstantNode(3)
const node2 = new math.ObjectNode({a: a, b: b, c: c})


OperatorNode #

Construction:

new OperatorNode(op: string, fn: string, args: Node[], implicit: boolean = false)


Additional methods:


  
    isUnary() : boolean

    Returns true when the OperatorNode contains exactly one argument,
like with a unary minus:

    const a = new math.ConstantNode(2)
const b = new math.OperatorNode('-', 'unaryMinus', [a])
b.isUnary() // true
    
  
  
    isBinary() : boolean

    Returns true when the OperatorNode contains exactly two arguments,
like with most regular operators:

    const a = new math.ConstantNode(2)
const b = new math.ConstantNode(3)
const c = new math.OperatorNode('+', 'add', [a, b])
c.isBinary() // true
    
  


Properties:


  op: string
  fn: string
  args: Node[]
  implicit: boolean True in case of an implicit multiplication, false otherwise


Examples:

const node1 = math.parse('2.3 + 5')

const a     = new math.ConstantNode(2.3)
const b     = new math.ConstantNode(5)
const node2 = new math.OperatorNode('+', 'add', [a, b])


ParenthesisNode #

Construction:

new ParenthesisNode(content: Node)


Properties:


  content: Node


Examples:

const node1 = math.parse('(1)')

const a     = new math.ConstantNode(1)
const node2 = new math.ParenthesisNode(a)


RangeNode #

Construction:

new RangeNode(start: Node, end: Node [, step: Node])


Properties:


  start: Node
  end: Node
  step: Node | null


Examples:

const node1 = math.parse('1:10')
const node2 = math.parse('0:2:10')

const zero = new math.ConstantNode(0)
const one = new math.ConstantNode(1)
const two = new math.ConstantNode(2)
const ten = new math.ConstantNode(10)

const node3 = new math.RangeNode(one, ten)
const node4 = new math.RangeNode(zero, ten, two)


RelationalNode #

Construction:

new RelationalNode(conditionals: string[], params: Node[])


conditionals is an array of strings, each of which may be ‘smaller’, ‘larger’, ‘smallerEq’, ‘largerEq’, ‘equal’, or ‘unequal’. The conditionals array must contain exactly one fewer item than params.

Properties:


  conditionals: string[]
  params: Node[]


A RelationalNode efficiently represents a chained conditional expression with two or more comparison operators, such as 10 < x <= 50. The expression is equivalent to 10 < x and x <= 50, except that x is evaluated only once, and evaluation stops (is “short-circuited”) once any condition tests false. Operators that are subject to chaining are <, >, <=, >=, ==, and !=. For backward compatibility, math.parse will return an OperatorNode if only a single conditional is present (such as x > 2).

Examples:


const ten = new math.ConstantNode(10)
const x = new math.SymbolNode('x')
const fifty = new math.ConstantNode(50)

const node1 = new math.RelationalNode(['smaller', 'smallerEq'], [ten, x, fifty])
const node2 = math.parse('10 < x <= 50')


SymbolNode #

Construction:

new SymbolNode(name: string)


Properties:


  name: string


Static functions:


  SymbolNode.onUndefinedSymbol(name: string). This function is invoked when an undefined symbol is evaluated. By default, the function throws an exception “Undefined symbol x”. The function can be overwritten to customize this behavior. See also FunctionNode.onUndefinedFunction.


Examples:

const node = math.parse('x')

const x = new math.SymbolNode('x')\n\n\n\nAlgebra (symbolic computation) #

math.js has built-in support for symbolic computation (CAS). It can parse expressions into an expression tree and do algebraic operations like simplification and derivation on the tree.


  It’s worth mentioning an excellent extension on math.js here: mathsteps, a step-by-step math solver library that is focused on pedagogy (how best to teach). The math problems it focuses on are pre-algebra and algebra problems involving simplifying expressions.


Simplify #

The function math.simplify simplifies an expression tree:

// simplify an expression
console.log(math.simplify('3 + 2 / 4').toString())              // '7 / 2'
console.log(math.simplify('2x + 3x').toString())                // '5 * x'
console.log(math.simplify('x^2 + x + 3 + x^2').toString())      // '2 * x ^ 2 + x + 3'
console.log(math.simplify('x * y * -x / (x ^ 2)').toString())   // '-y'


The function accepts either a string or an expression tree (Node) as input, and outputs a simplified expression tree (Node). This node tree can be transformed and evaluated as described in detail on the page Expression trees.

// work with an expression tree, evaluate results
const f = math.parse('2x + x')
const simplified = math.simplify(f)
console.log(simplified.toString())       // '3 * x'
console.log(simplified.evaluate({x: 4})) // 12


Among its other actions, calling simplify() on an expression will convert
any functions that have operator equivalents to their operator form:
console.log(math.simplify('multiply(x,3)').toString)  // '3 * x'


Note that simplify has an optional argument scope that allows the definitions of variables in the expression (as numeric values, or as further expressions) to be specified and used in the simplification, e.g. continuing the previous example,

console.log(math.simplify(f, {x: 4}).toString()) // 12
console.log(math.simplify(f, {x: math.parse('y+z')}).toString()) // '3*(y+z)'


In general, simplification is an inherently dfficult problem; in fact, for certain classes of expressions and algebraic equivalences, it is undecidable whether a given expression is equivalent to zero. Moreover, simplification generally depends on the properties of the operations involved; since multiplication (for example) may have different properties (e.g., it might or might not be commutative) depending on the domain under consideration, different simplifications might be appropriate.

As a result, simplify() has an additional optional argument, options, which controls its behavior. This argument is an object specifying any of various properties concerning the simplification process. See the detailed documentation for a complete list, but currently the two most important properties are as follows. Note that the options argument may only be specified if the scope is as well.


  exactFractions - a boolean which specifies whether non-integer numerical constants should be simplified to rational numbers when possible (true), or always converted to decimal notation (false).
  context - an object whose keys are the names of operations (‘add’, ‘multiply’, etc.) and whose values specify algebraic properties of the corresponding operation (currently any of ‘total’, ‘trivial’, ‘commutative’, and ‘associative’). Simplifications will only be performed if the properties they rely on are true in the given context. For example,
    const expr = math.parse('x*y-y*x')
console.log(math.simplify(expr).toString())  // 0; * is commutative by default
console.log(math.simplify(expr, {}, {context: {multiply: {commutative: false}}}))
// 'x*y-y*x'; the order of the right multiplication can't be reversed.
    
  


Note that the default context is very permissive (allows a lot of simplifications) but that there is also a math.simplify.realContext that only allows simplifications that are guaranteed to preserve the value of the expression on all real numbers:
const rational = math.parse('(x-1)*x/(x-1)')
console.log(math.simplify(expr, {}, {context: math.simplify.realContext})
  // '(x-1)*x/(x-1)'; canceling the 'x-1' makes the expression defined at 1


For more details on the theory of expression simplification, see:


  Strategies for simplifying math expressions (Stackoverflow)
  Symbolic computation - Simplification (Wikipedia)


Derivative #

The function math.derivative finds the symbolic derivative of an expression:

// calculate a derivative
console.log(math.derivative('2x^2 + 3x + 4', 'x').toString())   // '4 * x + 3'
console.log(math.derivative('sin(2x)', 'x').toString())         // '2 * cos(2 * x)'


Similar to the function math.simplify, math.derivative accepts either a string or an expression tree (Node) as input, and outputs a simplified expression tree (Node).

// work with an expression tree, evaluate results
const h = math.parse('x^2 + x')
const x = math.parse('x')
const dh = math.derivative(h, x)
console.log(dh.toString())        // '2 * x + 1'
console.log(dh.evaluate({x: 3}))  // '7'


The rules used by math.derivative can be found on Wikipedia:


  Differentiation rules (Wikipedia)


Rationalize #

The function math.rationalize transforms a rationalizable expression in a rational fraction.
If rational fraction is one variable polynomial then converts the numerator and denominator in canonical form, with decreasing exponents, returning the coefficients of numerator.


math.rationalize('2x/y - y/(x+1)')
              // (2*x^2-y^2+2*x)/(x*y+y)
math.rationalize('(2x+1)^6')
              // 64*x^6+192*x^5+240*x^4+160*x^3+60*x^2+12*x+1
math.rationalize('2x/( (2x-1) / (3x+2) ) - 5x/ ( (3x+4) / (2x^2-5) ) + 3')
              // -20*x^4+28*x^3+104*x^2+6*x-12)/(6*x^2+5*x-4)

math.rationalize('x+x+x+y',{y:1}) // 3*x+1
math.rationalize('x+x+x+y',{})    // 3*x+y

const ret = math.rationalize('x+x+x+y',{},true)
              // ret.expression=3*x+y, ret.variables = ["x","y"]
const ret = math.rationalize('-2+5x^2',{},true)
              // ret.expression=5*x^2-2, ret.variables = ["x"], ret.coefficients=[-2,0,5]\n\n\n\nAlgebra (symbolic computation) #

math.js has built-in support for symbolic computation (CAS). It can parse expressions into an expression tree and do algebraic operations like simplification and derivation on the tree.


  It’s worth mentioning an excellent extension on math.js here: mathsteps, a step-by-step math solver library that is focused on pedagogy (how best to teach). The math problems it focuses on are pre-algebra and algebra problems involving simplifying expressions.


Simplify #

The function math.simplify simplifies an expression tree:

// simplify an expression
console.log(math.simplify('3 + 2 / 4').toString())              // '7 / 2'
console.log(math.simplify('2x + 3x').toString())                // '5 * x'
console.log(math.simplify('x^2 + x + 3 + x^2').toString())      // '2 * x ^ 2 + x + 3'
console.log(math.simplify('x * y * -x / (x ^ 2)').toString())   // '-y'


The function accepts either a string or an expression tree (Node) as input, and outputs a simplified expression tree (Node). This node tree can be transformed and evaluated as described in detail on the page Expression trees.

// work with an expression tree, evaluate results
const f = math.parse('2x + x')
const simplified = math.simplify(f)
console.log(simplified.toString())       // '3 * x'
console.log(simplified.evaluate({x: 4})) // 12


Among its other actions, calling simplify() on an expression will convert
any functions that have operator equivalents to their operator form:
console.log(math.simplify('multiply(x,3)').toString)  // '3 * x'


Note that simplify has an optional argument scope that allows the definitions of variables in the expression (as numeric values, or as further expressions) to be specified and used in the simplification, e.g. continuing the previous example,

console.log(math.simplify(f, {x: 4}).toString()) // 12
console.log(math.simplify(f, {x: math.parse('y+z')}).toString()) // '3*(y+z)'


In general, simplification is an inherently dfficult problem; in fact, for certain classes of expressions and algebraic equivalences, it is undecidable whether a given expression is equivalent to zero. Moreover, simplification generally depends on the properties of the operations involved; since multiplication (for example) may have different properties (e.g., it might or might not be commutative) depending on the domain under consideration, different simplifications might be appropriate.

As a result, simplify() has an additional optional argument, options, which controls its behavior. This argument is an object specifying any of various properties concerning the simplification process. See the detailed documentation for a complete list, but currently the two most important properties are as follows. Note that the options argument may only be specified if the scope is as well.


  exactFractions - a boolean which specifies whether non-integer numerical constants should be simplified to rational numbers when possible (true), or always converted to decimal notation (false).
  context - an object whose keys are the names of operations (‘add’, ‘multiply’, etc.) and whose values specify algebraic properties of the corresponding operation (currently any of ‘total’, ‘trivial’, ‘commutative’, and ‘associative’). Simplifications will only be performed if the properties they rely on are true in the given context. For example,
    const expr = math.parse('x*y-y*x')
console.log(math.simplify(expr).toString())  // 0; * is commutative by default
console.log(math.simplify(expr, {}, {context: {multiply: {commutative: false}}}))
// 'x*y-y*x'; the order of the right multiplication can't be reversed.
    
  


Note that the default context is very permissive (allows a lot of simplifications) but that there is also a math.simplify.realContext that only allows simplifications that are guaranteed to preserve the value of the expression on all real numbers:
const rational = math.parse('(x-1)*x/(x-1)')
console.log(math.simplify(expr, {}, {context: math.simplify.realContext})
  // '(x-1)*x/(x-1)'; canceling the 'x-1' makes the expression defined at 1


For more details on the theory of expression simplification, see:


  Strategies for simplifying math expressions (Stackoverflow)
  Symbolic computation - Simplification (Wikipedia)


Derivative #

The function math.derivative finds the symbolic derivative of an expression:

// calculate a derivative
console.log(math.derivative('2x^2 + 3x + 4', 'x').toString())   // '4 * x + 3'
console.log(math.derivative('sin(2x)', 'x').toString())         // '2 * cos(2 * x)'


Similar to the function math.simplify, math.derivative accepts either a string or an expression tree (Node) as input, and outputs a simplified expression tree (Node).

// work with an expression tree, evaluate results
const h = math.parse('x^2 + x')
const x = math.parse('x')
const dh = math.derivative(h, x)
console.log(dh.toString())        // '2 * x + 1'
console.log(dh.evaluate({x: 3}))  // '7'


The rules used by math.derivative can be found on Wikipedia:


  Differentiation rules (Wikipedia)


Rationalize #

The function math.rationalize transforms a rationalizable expression in a rational fraction.
If rational fraction is one variable polynomial then converts the numerator and denominator in canonical form, with decreasing exponents, returning the coefficients of numerator.


math.rationalize('2x/y - y/(x+1)')
              // (2*x^2-y^2+2*x)/(x*y+y)
math.rationalize('(2x+1)^6')
              // 64*x^6+192*x^5+240*x^4+160*x^3+60*x^2+12*x+1
math.rationalize('2x/( (2x-1) / (3x+2) ) - 5x/ ( (3x+4) / (2x^2-5) ) + 3')
              // -20*x^4+28*x^3+104*x^2+6*x-12)/(6*x^2+5*x-4)

math.rationalize('x+x+x+y',{y:1}) // 3*x+1
math.rationalize('x+x+x+y',{})    // 3*x+y

const ret = math.rationalize('x+x+x+y',{},true)
              // ret.expression=3*x+y, ret.variables = ["x","y"]
const ret = math.rationalize('-2+5x^2',{},true)
              // ret.expression=5*x^2-2, ret.variables = ["x"], ret.coefficients=[-2,0,5]\n\n\n\nFunction simplify #

Simplify an expression tree.

A list of rules are applied to an expression, repeating over the list until
no further changes are made.
It’s possible to pass a custom set of rules to the function as second
argument. A rule can be specified as an object, string, or function:

const rules = [
  { l: 'n1*n3 + n2*n3', r: '(n1+n2)*n3' },
  'n1*n3 + n2*n3 -> (n1+n2)*n3',
  function (node) {
    // ... return a new node or return the node unchanged
    return node
  }
]


String and object rules consist of a left and right pattern. The left is
used to match against the expression and the right determines what matches
are replaced with. The main difference between a pattern and a normal
expression is that variables starting with the following characters are
interpreted as wildcards:


  ‘n’ - Matches any node [Node]
  ‘c’ - Matches a constant literal (5 or 3.2) [ConstantNode]
  ‘cl’ - Matches a constant literal; same as c [ConstantNode]
  ‘cd’ - Matches a decimal literal (5 or -3.2) [ConstantNode or unaryMinus wrapping a ConstantNode]
  ‘ce’ - Matches a constant expression (-5 or √3) [Expressions consisting of only ConstantNodes, functions, and operators]
  ‘v’ - Matches a variable; anything not matched by c (-5 or x) [Node that is not a ConstantNode]
  ‘vl’ - Matches a variable literal (x or y) [SymbolNode]
  ‘vd’ - Matches a non-decimal expression; anything not matched by cd (x or √3) [Node that is not a ConstantNode or unaryMinus that is wrapping a ConstantNode]
  ‘ve’ - Matches a variable expression; anything not matched by ce (x or 2x) [Expressions that contain a SymbolNode or other non-constant term]


The default list of rules is exposed on the function as simplify.rules
and can be used as a basis to built a set of custom rules. Note that since
the simplifyCore function is in the default list of rules, by default
simplify will convert any function calls in the expression that have
operator equivalents to their operator forms.

To specify a rule as a string, separate the left and right pattern by ‘->’
When specifying a rule as an object, the following keys are meaningful:

  l - the left pattern
  r - the right pattern
  s - in lieu of l and r, the string form that is broken at -> to give them
  repeat - whether to repeat this rule until the expression stabilizes
  assuming - gives a context object, as in the ‘context’ option to
  simplify. Every property in the context object must match the current
  context in order, or else the rule will not be applied.
  imposeContext - gives a context object, as in the ‘context’ option to
  simplify. Any settings specified will override the incoming context
  for all matches of this rule.


For more details on the theory, see:


  Strategies for simplifying math expressions (Stackoverflow)
  Symbolic computation - Simplification (Wikipedia)


An optional options argument can be passed as last argument of simplify.
 Currently available options (defaults in parentheses):

  consoleDebug (false): whether to write the expression being simplified
and any changes to it, along with the rule responsible, to console
  context (simplify.defaultContext): an object giving properties of
each operator, which determine what simplifications are allowed. The
currently meaningful properties are commutative, associative,
total (whether the operation is defined for all arguments), and
trivial (whether the operation applied to a single argument leaves
that argument unchanged). The default context is very permissive and
allows almost all simplifications. Only properties differing from
the default need to be specified; the default context is used as a
fallback. Additional contexts simplify.realContext and
simplify.positiveContext are supplied to cause simplify to perform
just simplifications guaranteed to preserve all values of the expression
assuming all variables and subexpressions are real numbers or
positive real numbers, respectively. (Note that these are in some cases
more restrictive than the default context; for example, the default
context will allow x/x to simplify to 1, whereas
simplify.realContext will not, as 0/0 is not equal to 1.)
  exactFractions (true): whether to try to convert all constants to
exact rational numbers.
  fractionsLimit (10000): when exactFractions is true, constants will
be expressed as fractions only when both numerator and denominator
are smaller than fractionsLimit.


Syntax #

math.simplify(expr)
math.simplify(expr, rules)
math.simplify(expr, rules)
math.simplify(expr, rules, scope)
math.simplify(expr, rules, scope, options)
math.simplify(expr, scope)
math.simplify(expr, scope, options)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      expr
      Node | string
      The expression to be simplified
    
    
      rules
      SimplifyRule[]
      Optional list with custom rules
    
    
      scope
      Object
      Optional scope with variables
    
    
      options
      SimplifyOptions
      Optional configuration settings
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      Node
      Returns the simplified form of expr
    
  


Throws #

Type | Description
—- | ———–

Examples #

math.simplify('2 * 1 * x ^ (2 - 1)')      // Node "2 * x"
math.simplify('2 * 3 * x', {x: 4})        // Node "24"
const f = math.parse('2 * 1 * x ^ (2 - 1)')
math.simplify(f)                          // Node "2 * x"
math.simplify('0.4 * x', {}, {exactFractions: true})  // Node "x * 2 / 5"
math.simplify('0.4 * x', {}, {exactFractions: false}) // Node "0.4 * x"


See also #

simplifyCore,
derivative,
evaluate,
parse,
rationalize,
resolve\n\n\n\nAlgebra (symbolic computation) #

math.js has built-in support for symbolic computation (CAS). It can parse expressions into an expression tree and do algebraic operations like simplification and derivation on the tree.


  It’s worth mentioning an excellent extension on math.js here: mathsteps, a step-by-step math solver library that is focused on pedagogy (how best to teach). The math problems it focuses on are pre-algebra and algebra problems involving simplifying expressions.


Simplify #

The function math.simplify simplifies an expression tree:

// simplify an expression
console.log(math.simplify('3 + 2 / 4').toString())              // '7 / 2'
console.log(math.simplify('2x + 3x').toString())                // '5 * x'
console.log(math.simplify('x^2 + x + 3 + x^2').toString())      // '2 * x ^ 2 + x + 3'
console.log(math.simplify('x * y * -x / (x ^ 2)').toString())   // '-y'


The function accepts either a string or an expression tree (Node) as input, and outputs a simplified expression tree (Node). This node tree can be transformed and evaluated as described in detail on the page Expression trees.

// work with an expression tree, evaluate results
const f = math.parse('2x + x')
const simplified = math.simplify(f)
console.log(simplified.toString())       // '3 * x'
console.log(simplified.evaluate({x: 4})) // 12


Among its other actions, calling simplify() on an expression will convert
any functions that have operator equivalents to their operator form:
console.log(math.simplify('multiply(x,3)').toString)  // '3 * x'


Note that simplify has an optional argument scope that allows the definitions of variables in the expression (as numeric values, or as further expressions) to be specified and used in the simplification, e.g. continuing the previous example,

console.log(math.simplify(f, {x: 4}).toString()) // 12
console.log(math.simplify(f, {x: math.parse('y+z')}).toString()) // '3*(y+z)'


In general, simplification is an inherently dfficult problem; in fact, for certain classes of expressions and algebraic equivalences, it is undecidable whether a given expression is equivalent to zero. Moreover, simplification generally depends on the properties of the operations involved; since multiplication (for example) may have different properties (e.g., it might or might not be commutative) depending on the domain under consideration, different simplifications might be appropriate.

As a result, simplify() has an additional optional argument, options, which controls its behavior. This argument is an object specifying any of various properties concerning the simplification process. See the detailed documentation for a complete list, but currently the two most important properties are as follows. Note that the options argument may only be specified if the scope is as well.


  exactFractions - a boolean which specifies whether non-integer numerical constants should be simplified to rational numbers when possible (true), or always converted to decimal notation (false).
  context - an object whose keys are the names of operations (‘add’, ‘multiply’, etc.) and whose values specify algebraic properties of the corresponding operation (currently any of ‘total’, ‘trivial’, ‘commutative’, and ‘associative’). Simplifications will only be performed if the properties they rely on are true in the given context. For example,
    const expr = math.parse('x*y-y*x')
console.log(math.simplify(expr).toString())  // 0; * is commutative by default
console.log(math.simplify(expr, {}, {context: {multiply: {commutative: false}}}))
// 'x*y-y*x'; the order of the right multiplication can't be reversed.
    
  


Note that the default context is very permissive (allows a lot of simplifications) but that there is also a math.simplify.realContext that only allows simplifications that are guaranteed to preserve the value of the expression on all real numbers:
const rational = math.parse('(x-1)*x/(x-1)')
console.log(math.simplify(expr, {}, {context: math.simplify.realContext})
  // '(x-1)*x/(x-1)'; canceling the 'x-1' makes the expression defined at 1


For more details on the theory of expression simplification, see:


  Strategies for simplifying math expressions (Stackoverflow)
  Symbolic computation - Simplification (Wikipedia)


Derivative #

The function math.derivative finds the symbolic derivative of an expression:

// calculate a derivative
console.log(math.derivative('2x^2 + 3x + 4', 'x').toString())   // '4 * x + 3'
console.log(math.derivative('sin(2x)', 'x').toString())         // '2 * cos(2 * x)'


Similar to the function math.simplify, math.derivative accepts either a string or an expression tree (Node) as input, and outputs a simplified expression tree (Node).

// work with an expression tree, evaluate results
const h = math.parse('x^2 + x')
const x = math.parse('x')
const dh = math.derivative(h, x)
console.log(dh.toString())        // '2 * x + 1'
console.log(dh.evaluate({x: 3}))  // '7'


The rules used by math.derivative can be found on Wikipedia:


  Differentiation rules (Wikipedia)


Rationalize #

The function math.rationalize transforms a rationalizable expression in a rational fraction.
If rational fraction is one variable polynomial then converts the numerator and denominator in canonical form, with decreasing exponents, returning the coefficients of numerator.


math.rationalize('2x/y - y/(x+1)')
              // (2*x^2-y^2+2*x)/(x*y+y)
math.rationalize('(2x+1)^6')
              // 64*x^6+192*x^5+240*x^4+160*x^3+60*x^2+12*x+1
math.rationalize('2x/( (2x-1) / (3x+2) ) - 5x/ ( (3x+4) / (2x^2-5) ) + 3')
              // -20*x^4+28*x^3+104*x^2+6*x-12)/(6*x^2+5*x-4)

math.rationalize('x+x+x+y',{y:1}) // 3*x+1
math.rationalize('x+x+x+y',{})    // 3*x+y

const ret = math.rationalize('x+x+x+y',{},true)
              // ret.expression=3*x+y, ret.variables = ["x","y"]
const ret = math.rationalize('-2+5x^2',{},true)
              // ret.expression=5*x^2-2, ret.variables = ["x"], ret.coefficients=[-2,0,5]\n\n\n\nFunction derivative #

Takes the derivative of an expression expressed in parser Nodes.
The derivative will be taken over the supplied variable in the
second parameter. If there are multiple variables in the expression,
it will return a partial derivative.

This uses rules of differentiation which can be found here:


  Differentiation rules (Wikipedia)


Syntax #

math.derivative(expr, variable)
math.derivative(expr, variable, options)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      expr
      Node | string
      The expression to differentiate
    
    
      variable
      SymbolNode | string
      The variable over which to differentiate
    
    
      options
      {simplify: boolean}
      There is one option available, simplify, which is true by default. When false, output will not be simplified.
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode
      The derivative of expr
    
  


Throws #

Type | Description
—- | ———–

Examples #

math.derivative('x^2', 'x')                     // Node '2 * x'
math.derivative('x^2', 'x', {simplify: false})  // Node '2 * 1 * x ^ (2 - 1)'
math.derivative('sin(2x)', 'x'))                // Node '2 * cos(2 * x)'
math.derivative('2*x', 'x').evaluate()          // number 2
math.derivative('x^2', 'x').evaluate({x: 4})    // number 8
const f = math.parse('x^2')
const x = math.parse('x')
math.derivative(f, x)                           // Node {2 * x}


See also #

simplify,
parse,
evaluate\n\n\n\nAlgebra (symbolic computation) #

math.js has built-in support for symbolic computation (CAS). It can parse expressions into an expression tree and do algebraic operations like simplification and derivation on the tree.


  It’s worth mentioning an excellent extension on math.js here: mathsteps, a step-by-step math solver library that is focused on pedagogy (how best to teach). The math problems it focuses on are pre-algebra and algebra problems involving simplifying expressions.


Simplify #

The function math.simplify simplifies an expression tree:

// simplify an expression
console.log(math.simplify('3 + 2 / 4').toString())              // '7 / 2'
console.log(math.simplify('2x + 3x').toString())                // '5 * x'
console.log(math.simplify('x^2 + x + 3 + x^2').toString())      // '2 * x ^ 2 + x + 3'
console.log(math.simplify('x * y * -x / (x ^ 2)').toString())   // '-y'


The function accepts either a string or an expression tree (Node) as input, and outputs a simplified expression tree (Node). This node tree can be transformed and evaluated as described in detail on the page Expression trees.

// work with an expression tree, evaluate results
const f = math.parse('2x + x')
const simplified = math.simplify(f)
console.log(simplified.toString())       // '3 * x'
console.log(simplified.evaluate({x: 4})) // 12


Among its other actions, calling simplify() on an expression will convert
any functions that have operator equivalents to their operator form:
console.log(math.simplify('multiply(x,3)').toString)  // '3 * x'


Note that simplify has an optional argument scope that allows the definitions of variables in the expression (as numeric values, or as further expressions) to be specified and used in the simplification, e.g. continuing the previous example,

console.log(math.simplify(f, {x: 4}).toString()) // 12
console.log(math.simplify(f, {x: math.parse('y+z')}).toString()) // '3*(y+z)'


In general, simplification is an inherently dfficult problem; in fact, for certain classes of expressions and algebraic equivalences, it is undecidable whether a given expression is equivalent to zero. Moreover, simplification generally depends on the properties of the operations involved; since multiplication (for example) may have different properties (e.g., it might or might not be commutative) depending on the domain under consideration, different simplifications might be appropriate.

As a result, simplify() has an additional optional argument, options, which controls its behavior. This argument is an object specifying any of various properties concerning the simplification process. See the detailed documentation for a complete list, but currently the two most important properties are as follows. Note that the options argument may only be specified if the scope is as well.


  exactFractions - a boolean which specifies whether non-integer numerical constants should be simplified to rational numbers when possible (true), or always converted to decimal notation (false).
  context - an object whose keys are the names of operations (‘add’, ‘multiply’, etc.) and whose values specify algebraic properties of the corresponding operation (currently any of ‘total’, ‘trivial’, ‘commutative’, and ‘associative’). Simplifications will only be performed if the properties they rely on are true in the given context. For example,
    const expr = math.parse('x*y-y*x')
console.log(math.simplify(expr).toString())  // 0; * is commutative by default
console.log(math.simplify(expr, {}, {context: {multiply: {commutative: false}}}))
// 'x*y-y*x'; the order of the right multiplication can't be reversed.
    
  


Note that the default context is very permissive (allows a lot of simplifications) but that there is also a math.simplify.realContext that only allows simplifications that are guaranteed to preserve the value of the expression on all real numbers:
const rational = math.parse('(x-1)*x/(x-1)')
console.log(math.simplify(expr, {}, {context: math.simplify.realContext})
  // '(x-1)*x/(x-1)'; canceling the 'x-1' makes the expression defined at 1


For more details on the theory of expression simplification, see:


  Strategies for simplifying math expressions (Stackoverflow)
  Symbolic computation - Simplification (Wikipedia)


Derivative #

The function math.derivative finds the symbolic derivative of an expression:

// calculate a derivative
console.log(math.derivative('2x^2 + 3x + 4', 'x').toString())   // '4 * x + 3'
console.log(math.derivative('sin(2x)', 'x').toString())         // '2 * cos(2 * x)'


Similar to the function math.simplify, math.derivative accepts either a string or an expression tree (Node) as input, and outputs a simplified expression tree (Node).

// work with an expression tree, evaluate results
const h = math.parse('x^2 + x')
const x = math.parse('x')
const dh = math.derivative(h, x)
console.log(dh.toString())        // '2 * x + 1'
console.log(dh.evaluate({x: 3}))  // '7'


The rules used by math.derivative can be found on Wikipedia:


  Differentiation rules (Wikipedia)


Rationalize #

The function math.rationalize transforms a rationalizable expression in a rational fraction.
If rational fraction is one variable polynomial then converts the numerator and denominator in canonical form, with decreasing exponents, returning the coefficients of numerator.


math.rationalize('2x/y - y/(x+1)')
              // (2*x^2-y^2+2*x)/(x*y+y)
math.rationalize('(2x+1)^6')
              // 64*x^6+192*x^5+240*x^4+160*x^3+60*x^2+12*x+1
math.rationalize('2x/( (2x-1) / (3x+2) ) - 5x/ ( (3x+4) / (2x^2-5) ) + 3')
              // -20*x^4+28*x^3+104*x^2+6*x-12)/(6*x^2+5*x-4)

math.rationalize('x+x+x+y',{y:1}) // 3*x+1
math.rationalize('x+x+x+y',{})    // 3*x+y

const ret = math.rationalize('x+x+x+y',{},true)
              // ret.expression=3*x+y, ret.variables = ["x","y"]
const ret = math.rationalize('-2+5x^2',{},true)
              // ret.expression=5*x^2-2, ret.variables = ["x"], ret.coefficients=[-2,0,5]\n\n\n\nFunction rationalize #

Transform a rationalizable expression in a rational fraction.
If rational fraction is one variable polynomial then converts
the numerator and denominator in canonical form, with decreasing
exponents, returning the coefficients of numerator.

Syntax #

math.rationalize(expr)
math.rationalize(expr, detailed)
math.rationalize(expr, scope)
math.rationalize(expr, scope, detailed)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      expr
      Node | string
      The expression to check if is a polynomial expression
    
    
      optional
      Object | boolean
      scope of expression or true for already evaluated rational expression at input
    
    
      detailed
      Boolean
      optional True if return an object, false if return expression node (default)
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      Object | Node
      The rational polynomial of expr or an object {expression, numerator, denominator, variables, coefficients}, where expression is a Node with the node simplified expression, numerator is a Node with the simplified numerator of expression, denominator is a Node or boolean with the simplified denominator or false (if there is no denominator), variables is an array with variable names, and coefficients is an array with coefficients of numerator sorted by increased exponent {Expression Node}  node simplified expression
    
  


Throws #

Type | Description
—- | ———–

Examples #

math.rationalize('sin(x)+y')
              //  Error: There is an unsolved function call
math.rationalize('2x/y - y/(x+1)')
              // (2*x^2-y^2+2*x)/(x*y+y)
math.rationalize('(2x+1)^6')
              // 64*x^6+192*x^5+240*x^4+160*x^3+60*x^2+12*x+1
math.rationalize('2x/( (2x-1) / (3x+2) ) - 5x/ ( (3x+4) / (2x^2-5) ) + 3')
              // -20*x^4+28*x^3+104*x^2+6*x-12)/(6*x^2+5*x-4)
math.rationalize('x/(1-x)/(x-2)/(x-3)/(x-4) + 2x/ ( (1-2x)/(2-3x) )/ ((3-4x)/(4-5x) )') =
              // (-30*x^7+344*x^6-1506*x^5+3200*x^4-3472*x^3+1846*x^2-381*x)/
              //     (-8*x^6+90*x^5-383*x^4+780*x^3-797*x^2+390*x-72)

math.rationalize('x+x+x+y',{y:1}) // 3*x+1
math.rationalize('x+x+x+y',{})    // 3*x+y

const ret = math.rationalize('x+x+x+y',{},true)
              // ret.expression=3*x+y, ret.variables = ["x","y"]
const ret = math.rationalize('-2+5x^2',{},true)
              // ret.expression=5*x^2-2, ret.variables = ["x"], ret.coefficients=[-2,0,5]


See also #

simplify\n\n\n\nCustomization #

Besides parsing and evaluating expressions, the expression parser supports
a number of features to customize processing and evaluation of expressions
and outputting expressions.

On this page:


  Function transforms
  Custom argument parsing
  Custom LaTeX handlers
  Custom HTML, LaTeX and string output
  Customize supported characters


Function transforms #

It is possible to preprocess function arguments and post process a functions
return value by writing a transform for the function. A transform is a
function wrapping around a function to be transformed or completely replaces
a function.

For example, the functions for math.js use zero-based matrix indices (as is
common in programing languages), but the expression parser uses one-based
indices. To enable this, all functions dealing with indices have a transform,
which changes input from one-based to zero-based, and transforms output (and
error message) from zero-based to one-based.

// using plain JavaScript, indices are zero-based:
const a = [[1, 2], [3, 4]]       // a 2x2 matrix
math.subset(a, math.index(0, 1)) // returns 2

// using the expression parser, indices are transformed to one-based:
const a = [[1, 2], [3, 4]] // a 2x2 matrix
let scope = {
  a: a
}
math.evaluate('subset(a, index(1, 2))', scope) // returns 2


To create a transform for a function, the transform function must be attached
to the function as property transform:

import { create, all } from 'mathjs'
const math = create(all)

// create a function
function addIt(a, b) {
  return a + b
}

// attach a transform function to the function addIt
addIt.transform = function (a, b) {
  console.log('input: a=' + a + ', b=' + b)
  // we can manipulate input here before executing addIt

  const res = addIt(a, b)

  console.log('result: ' + res)
  // we can manipulate result here before returning

  return res
}

// import the function into math.js
math.import({
  addIt: addIt
})

// use the function via the expression parser
console.log('Using expression parser:')
console.log('2+4=' + math.evaluate('addIt(2, 4)'))
// This will output:
//
//     input: a=2, b=4
//     result: 6
//     2+4=6

// when used via plain JavaScript, the transform is not invoked
console.log('')
console.log('Using plain JavaScript:')
console.log('2+4=' + math.addIt(2, 4))
// This will output:
//
//     6


Functions with a transform must be imported in the math namespace, as they
need to be processed at compile time. They are not supported when passed via a
scope at evaluation time.

Custom argument parsing #

The expression parser of math.js has support for letting functions
parse and evaluate arguments themselves, instead of calling them with
evaluated arguments. This is useful for example when creating a function
like plot(f(x), x) or integrate(f(x), x, start, end), where some of the
arguments need to be processed in a special way. In these cases, the expression
f(x) will be evaluated repeatedly by the function, and x is not evaluated
but used to specify the variable looping over the function f(x).

Functions having a property rawArgs with value true are treated in a special
way by the expression parser: they will be invoked with unevaluated arguments,
allowing the function to process the arguments in a customized way. Raw
functions are called as:

rawFunction(args: Node[], math: Object, scope: Map)


Where :


  args is an Array with nodes of the parsed arguments.
  math is the math namespace against which the expression was compiled.
  scope is a Map 
interface containing the variables defined in the scope 
passed via evaluate(scope). The passed scope is always a Map interface,
and normally a PartitionedMap is used to separate local function variables
like x in a custom defined function f(x) = rawFunction(x) ^ 2 from the 
scope variables. Note that a PartitionedMap can recursively link to another
PartitionedMap.


Raw functions must be imported in the math namespace, as they need to be
processed at compile time. They are not supported when passed via a scope
at evaluation time.

A simple example:

function myFunction(args, math, scope) {
  // get string representation of the arguments
  const str = args.map(function (arg) {
    return arg.toString()
  })

  // evaluate the arguments
  const res = args.map(function (arg) {
    return arg.compile().evaluate(scope)
  })

  return 'arguments: ' + str.join(',') + ', evaluated: ' + res.join(',')
}

// mark the function as "rawArgs", so it will be called with unevaluated arguments
myFunction.rawArgs = true

// import the new function in the math namespace
math.import({
  myFunction: myFunction
})

// use the function
math.evaluate('myFunction(2 + 3, sqrt(4))')
// returns 'arguments: 2 + 3, sqrt(4), evaluated: 5, 2'


Custom LaTeX handlers #

You can attach a toTex property to your custom functions before importing them to define their LaTeX output. This
toTex property can be a handler in the format described in the next section ‘Custom LaTeX and String conversion’
or a template string similar to ES6 templates.

Template syntax #


  ${name}: Gets replaced by the name of the function
  ${args}: Gets replaced by a comma separated list of the arguments of the function.
  ${args[0]}: Gets replaced by the first argument of a function
  $$: Gets replaced by $


Example #

const customFunctions = {
  plus: function (a, b) {
    return a + b
  },
  minus: function (a, b) {
    return a - b
  },
  binom: function (n, k) {
    return 1
  }
}

customFunctions.plus.toTex = '${args[0]}+${args[1]}' //template string
customFunctions.binom.toTex = '\\mathrm{${name}}\\left(${args}\\right)' //template string
customFunctions.minus.toTex = function (node, options) { //handler function
  return node.args[0].toTex(options) + node.name + node.args[1].toTex(options)
}

math.import(customFunctions)

math.parse('plus(1,2)').toTex()    // '1+2'
math.parse('binom(1,2)').toTex()   // '\\mathrm{binom}\\left(1,2\\right)'
math.parse('minus(1,2)').toTex()   // '1minus2'


Custom HTML, LaTeX and string output #

All expression nodes have a method toTex and toString to output an expression respectively in HTML or LaTex format or as regular text .
The functions toHTML, toTex and toString accept an options argument to customise output. This object is of the following form:

{
  parenthesis: 'keep',    // parenthesis option
  handler: someHandler,   // handler to change the output
  implicit: 'hide'        // how to treat implicit multiplication
}


Parenthesis #

The parenthesis option changes the way parentheses are used in the output. There are three options available:


  keep Keep the parentheses from the input and display them as is. This is the default.
  auto Only display parentheses that are necessary. Mathjs tries to get rid of as much parentheses as possible.
  all Display all parentheses that are given by the structure of the node tree. This makes the output precedence unambiguous.


There’s two ways of passing callbacks:


  Pass an object that maps function names to callbacks. Those callbacks will be used for FunctionNodes with
functions of that name.
  Pass a function to toTex. This function will then be used for every node.


const expression = math.parse('(1+1+1)')

expression.toString()                      // (1 + 1 + 1)
expression.toString({parenthesis: 'keep'}) // (1 + 1 + 1)
expression.toString({parenthesis: 'auto'}) // 1 + 1 + 1
expression.toString({parenthesis: 'all'})  // (1 + 1) + 1


Handler #

You can provide the toTex and toString functions of an expression with your own custom handlers that override the internal behaviour. This is especially useful to provide LaTeX/string output for your own custom functions. This can be done in two ways:


  Pass an object that maps function names to callbacks. Those callbacks will be used for FunctionNodes that contain functions with that name.
  Pass a callback directly. This callback will run for every node, so you can replace the output of anything you like.


A callback function has the following form:

function callback (node, options) {
  ...
}

Where options is the object passed to toHTML/toTex/toString. Don’t forget to pass this on to the child nodes, and node is a reference to the current node.

If a callback returns nothing, the standard output will be used. If your callback returns a string, this string will be used.

Although the following examples use toTex, it works for toString and toHTML in the same way

Examples for option 1 #

const customFunctions = {
  binomial: function (n, k) {
    //calculate n choose k
    // (do some stuff)
    return result
  }
}

const customLaTeX = {
  'binomial': function (node, options) { //provide toTex for your own custom function
    return '\\binom{' + node.args[0].toTex(options) + '}{' + node.args[1].toTex(options) + '}'
  },
  'factorial': function (node, options) { //override toTex for builtin functions
  	return 'factorial\\left(' + node.args[0] + '\\right)'
  }
}


You can simply use your custom toTex functions by passing them to toTex:

math.import(customFunctions)
const expression = math.parse('binomial(factorial(2),1)')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains "\binom{factorial\\left(2\\right)}{1}"


Examples for option 2: #

function customLaTeX(node, options) {
  if ((node.type === 'OperatorNode') && (node.fn === 'add')) {
    //don't forget to pass the options to the toTex functions
    return node.args[0].toTex(options) + ' plus ' + node.args[1].toTex(options)
  }
  else if (node.type === 'ConstantNode') {
    if (node.value === 0) {
        return '\\mbox{zero}'
    }
    else if (node.value === 1) {
        return '\\mbox{one}'
    }
    else if (node.value === 2) {
        return '\\mbox{two}'
    }
    else {
        return node.value
    }
  }
}

const expression = math.parse('1+2')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains '\mbox{one} plus \mbox{two}'


Another example in conjunction with custom functions:

const customFunctions = {
  binomial: function (n, k) {
    //calculate n choose k
    // (do some stuff)
    return result
  }
}

function customLaTeX(node, options) {
  if ((node.type === 'FunctionNode') && (node.name === 'binomial')) {
      return '\\binom{' + node.args[0].toTex(options) + '}{' + node.args[1].toTex(options) + '}'
  }
}

math.import(customFunctions)
const expression = math.parse('binomial(2,1)')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains "\binom{2}{1}"


Implicit multiplication #

You can change the way that implicit multiplication is converted to a string or LaTeX. The two options are hide, to not show a multiplication operator for implicit multiplication and show to show it.

Example:

const node = math.parse('2a')

node.toString()                   // '2 a'
node.toString({implicit: 'hide'}) // '2 a'
node.toString({implicit: 'show'}) // '2 * a'

node.toTex()                      // '2~ a'
node.toTex({implicit: 'hide'})    // '2~ a'
node.toTex({implicit: 'show'})    // '2\\cdot a'


Customize supported characters #

It is possible to customize the characters allowed in symbols and digits.
The parse function exposes the following test functions:


  math.parse.isAlpha(c, cPrev, cNext)
  math.parse.isWhitespace(c, nestingLevel)
  math.parse.isDecimalMark(c, cNext)
  math.parse.isDigitDot(c)
  math.parse.isDigit(c)


The exact signature and implementation of these functions can be looked up in
the source code of the parser. The allowed alpha characters are described here: Constants and variables.

For example, the phone character ☎ is not supported by default. It can be enabled
by replacing the isAlpha function:

const isAlphaOriginal = math.parse.isAlpha
math.parse.isAlpha = function (c, cPrev, cNext) {
  return isAlphaOriginal(c, cPrev, cNext) || (c === '\u260E')
}

// now we can use the \u260E (phone) character in expressions
const result = math.evaluate('\u260Efoo', {'\u260Efoo': 42}) // returns 42
console.log(result)\n\n\n\nCustomization #

Besides parsing and evaluating expressions, the expression parser supports
a number of features to customize processing and evaluation of expressions
and outputting expressions.

On this page:


  Function transforms
  Custom argument parsing
  Custom LaTeX handlers
  Custom HTML, LaTeX and string output
  Customize supported characters


Function transforms #

It is possible to preprocess function arguments and post process a functions
return value by writing a transform for the function. A transform is a
function wrapping around a function to be transformed or completely replaces
a function.

For example, the functions for math.js use zero-based matrix indices (as is
common in programing languages), but the expression parser uses one-based
indices. To enable this, all functions dealing with indices have a transform,
which changes input from one-based to zero-based, and transforms output (and
error message) from zero-based to one-based.

// using plain JavaScript, indices are zero-based:
const a = [[1, 2], [3, 4]]       // a 2x2 matrix
math.subset(a, math.index(0, 1)) // returns 2

// using the expression parser, indices are transformed to one-based:
const a = [[1, 2], [3, 4]] // a 2x2 matrix
let scope = {
  a: a
}
math.evaluate('subset(a, index(1, 2))', scope) // returns 2


To create a transform for a function, the transform function must be attached
to the function as property transform:

import { create, all } from 'mathjs'
const math = create(all)

// create a function
function addIt(a, b) {
  return a + b
}

// attach a transform function to the function addIt
addIt.transform = function (a, b) {
  console.log('input: a=' + a + ', b=' + b)
  // we can manipulate input here before executing addIt

  const res = addIt(a, b)

  console.log('result: ' + res)
  // we can manipulate result here before returning

  return res
}

// import the function into math.js
math.import({
  addIt: addIt
})

// use the function via the expression parser
console.log('Using expression parser:')
console.log('2+4=' + math.evaluate('addIt(2, 4)'))
// This will output:
//
//     input: a=2, b=4
//     result: 6
//     2+4=6

// when used via plain JavaScript, the transform is not invoked
console.log('')
console.log('Using plain JavaScript:')
console.log('2+4=' + math.addIt(2, 4))
// This will output:
//
//     6


Functions with a transform must be imported in the math namespace, as they
need to be processed at compile time. They are not supported when passed via a
scope at evaluation time.

Custom argument parsing #

The expression parser of math.js has support for letting functions
parse and evaluate arguments themselves, instead of calling them with
evaluated arguments. This is useful for example when creating a function
like plot(f(x), x) or integrate(f(x), x, start, end), where some of the
arguments need to be processed in a special way. In these cases, the expression
f(x) will be evaluated repeatedly by the function, and x is not evaluated
but used to specify the variable looping over the function f(x).

Functions having a property rawArgs with value true are treated in a special
way by the expression parser: they will be invoked with unevaluated arguments,
allowing the function to process the arguments in a customized way. Raw
functions are called as:

rawFunction(args: Node[], math: Object, scope: Map)


Where :


  args is an Array with nodes of the parsed arguments.
  math is the math namespace against which the expression was compiled.
  scope is a Map 
interface containing the variables defined in the scope 
passed via evaluate(scope). The passed scope is always a Map interface,
and normally a PartitionedMap is used to separate local function variables
like x in a custom defined function f(x) = rawFunction(x) ^ 2 from the 
scope variables. Note that a PartitionedMap can recursively link to another
PartitionedMap.


Raw functions must be imported in the math namespace, as they need to be
processed at compile time. They are not supported when passed via a scope
at evaluation time.

A simple example:

function myFunction(args, math, scope) {
  // get string representation of the arguments
  const str = args.map(function (arg) {
    return arg.toString()
  })

  // evaluate the arguments
  const res = args.map(function (arg) {
    return arg.compile().evaluate(scope)
  })

  return 'arguments: ' + str.join(',') + ', evaluated: ' + res.join(',')
}

// mark the function as "rawArgs", so it will be called with unevaluated arguments
myFunction.rawArgs = true

// import the new function in the math namespace
math.import({
  myFunction: myFunction
})

// use the function
math.evaluate('myFunction(2 + 3, sqrt(4))')
// returns 'arguments: 2 + 3, sqrt(4), evaluated: 5, 2'


Custom LaTeX handlers #

You can attach a toTex property to your custom functions before importing them to define their LaTeX output. This
toTex property can be a handler in the format described in the next section ‘Custom LaTeX and String conversion’
or a template string similar to ES6 templates.

Template syntax #


  ${name}: Gets replaced by the name of the function
  ${args}: Gets replaced by a comma separated list of the arguments of the function.
  ${args[0]}: Gets replaced by the first argument of a function
  $$: Gets replaced by $


Example #

const customFunctions = {
  plus: function (a, b) {
    return a + b
  },
  minus: function (a, b) {
    return a - b
  },
  binom: function (n, k) {
    return 1
  }
}

customFunctions.plus.toTex = '${args[0]}+${args[1]}' //template string
customFunctions.binom.toTex = '\\mathrm{${name}}\\left(${args}\\right)' //template string
customFunctions.minus.toTex = function (node, options) { //handler function
  return node.args[0].toTex(options) + node.name + node.args[1].toTex(options)
}

math.import(customFunctions)

math.parse('plus(1,2)').toTex()    // '1+2'
math.parse('binom(1,2)').toTex()   // '\\mathrm{binom}\\left(1,2\\right)'
math.parse('minus(1,2)').toTex()   // '1minus2'


Custom HTML, LaTeX and string output #

All expression nodes have a method toTex and toString to output an expression respectively in HTML or LaTex format or as regular text .
The functions toHTML, toTex and toString accept an options argument to customise output. This object is of the following form:

{
  parenthesis: 'keep',    // parenthesis option
  handler: someHandler,   // handler to change the output
  implicit: 'hide'        // how to treat implicit multiplication
}


Parenthesis #

The parenthesis option changes the way parentheses are used in the output. There are three options available:


  keep Keep the parentheses from the input and display them as is. This is the default.
  auto Only display parentheses that are necessary. Mathjs tries to get rid of as much parentheses as possible.
  all Display all parentheses that are given by the structure of the node tree. This makes the output precedence unambiguous.


There’s two ways of passing callbacks:


  Pass an object that maps function names to callbacks. Those callbacks will be used for FunctionNodes with
functions of that name.
  Pass a function to toTex. This function will then be used for every node.


const expression = math.parse('(1+1+1)')

expression.toString()                      // (1 + 1 + 1)
expression.toString({parenthesis: 'keep'}) // (1 + 1 + 1)
expression.toString({parenthesis: 'auto'}) // 1 + 1 + 1
expression.toString({parenthesis: 'all'})  // (1 + 1) + 1


Handler #

You can provide the toTex and toString functions of an expression with your own custom handlers that override the internal behaviour. This is especially useful to provide LaTeX/string output for your own custom functions. This can be done in two ways:


  Pass an object that maps function names to callbacks. Those callbacks will be used for FunctionNodes that contain functions with that name.
  Pass a callback directly. This callback will run for every node, so you can replace the output of anything you like.


A callback function has the following form:

function callback (node, options) {
  ...
}

Where options is the object passed to toHTML/toTex/toString. Don’t forget to pass this on to the child nodes, and node is a reference to the current node.

If a callback returns nothing, the standard output will be used. If your callback returns a string, this string will be used.

Although the following examples use toTex, it works for toString and toHTML in the same way

Examples for option 1 #

const customFunctions = {
  binomial: function (n, k) {
    //calculate n choose k
    // (do some stuff)
    return result
  }
}

const customLaTeX = {
  'binomial': function (node, options) { //provide toTex for your own custom function
    return '\\binom{' + node.args[0].toTex(options) + '}{' + node.args[1].toTex(options) + '}'
  },
  'factorial': function (node, options) { //override toTex for builtin functions
  	return 'factorial\\left(' + node.args[0] + '\\right)'
  }
}


You can simply use your custom toTex functions by passing them to toTex:

math.import(customFunctions)
const expression = math.parse('binomial(factorial(2),1)')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains "\binom{factorial\\left(2\\right)}{1}"


Examples for option 2: #

function customLaTeX(node, options) {
  if ((node.type === 'OperatorNode') && (node.fn === 'add')) {
    //don't forget to pass the options to the toTex functions
    return node.args[0].toTex(options) + ' plus ' + node.args[1].toTex(options)
  }
  else if (node.type === 'ConstantNode') {
    if (node.value === 0) {
        return '\\mbox{zero}'
    }
    else if (node.value === 1) {
        return '\\mbox{one}'
    }
    else if (node.value === 2) {
        return '\\mbox{two}'
    }
    else {
        return node.value
    }
  }
}

const expression = math.parse('1+2')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains '\mbox{one} plus \mbox{two}'


Another example in conjunction with custom functions:

const customFunctions = {
  binomial: function (n, k) {
    //calculate n choose k
    // (do some stuff)
    return result
  }
}

function customLaTeX(node, options) {
  if ((node.type === 'FunctionNode') && (node.name === 'binomial')) {
      return '\\binom{' + node.args[0].toTex(options) + '}{' + node.args[1].toTex(options) + '}'
  }
}

math.import(customFunctions)
const expression = math.parse('binomial(2,1)')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains "\binom{2}{1}"


Implicit multiplication #

You can change the way that implicit multiplication is converted to a string or LaTeX. The two options are hide, to not show a multiplication operator for implicit multiplication and show to show it.

Example:

const node = math.parse('2a')

node.toString()                   // '2 a'
node.toString({implicit: 'hide'}) // '2 a'
node.toString({implicit: 'show'}) // '2 * a'

node.toTex()                      // '2~ a'
node.toTex({implicit: 'hide'})    // '2~ a'
node.toTex({implicit: 'show'})    // '2\\cdot a'


Customize supported characters #

It is possible to customize the characters allowed in symbols and digits.
The parse function exposes the following test functions:


  math.parse.isAlpha(c, cPrev, cNext)
  math.parse.isWhitespace(c, nestingLevel)
  math.parse.isDecimalMark(c, cNext)
  math.parse.isDigitDot(c)
  math.parse.isDigit(c)


The exact signature and implementation of these functions can be looked up in
the source code of the parser. The allowed alpha characters are described here: Constants and variables.

For example, the phone character ☎ is not supported by default. It can be enabled
by replacing the isAlpha function:

const isAlphaOriginal = math.parse.isAlpha
math.parse.isAlpha = function (c, cPrev, cNext) {
  return isAlphaOriginal(c, cPrev, cNext) || (c === '\u260E')
}

// now we can use the \u260E (phone) character in expressions
const result = math.evaluate('\u260Efoo', {'\u260Efoo': 42}) // returns 42
console.log(result)\n\n\n\nCustomization #

Besides parsing and evaluating expressions, the expression parser supports
a number of features to customize processing and evaluation of expressions
and outputting expressions.

On this page:


  Function transforms
  Custom argument parsing
  Custom LaTeX handlers
  Custom HTML, LaTeX and string output
  Customize supported characters


Function transforms #

It is possible to preprocess function arguments and post process a functions
return value by writing a transform for the function. A transform is a
function wrapping around a function to be transformed or completely replaces
a function.

For example, the functions for math.js use zero-based matrix indices (as is
common in programing languages), but the expression parser uses one-based
indices. To enable this, all functions dealing with indices have a transform,
which changes input from one-based to zero-based, and transforms output (and
error message) from zero-based to one-based.

// using plain JavaScript, indices are zero-based:
const a = [[1, 2], [3, 4]]       // a 2x2 matrix
math.subset(a, math.index(0, 1)) // returns 2

// using the expression parser, indices are transformed to one-based:
const a = [[1, 2], [3, 4]] // a 2x2 matrix
let scope = {
  a: a
}
math.evaluate('subset(a, index(1, 2))', scope) // returns 2


To create a transform for a function, the transform function must be attached
to the function as property transform:

import { create, all } from 'mathjs'
const math = create(all)

// create a function
function addIt(a, b) {
  return a + b
}

// attach a transform function to the function addIt
addIt.transform = function (a, b) {
  console.log('input: a=' + a + ', b=' + b)
  // we can manipulate input here before executing addIt

  const res = addIt(a, b)

  console.log('result: ' + res)
  // we can manipulate result here before returning

  return res
}

// import the function into math.js
math.import({
  addIt: addIt
})

// use the function via the expression parser
console.log('Using expression parser:')
console.log('2+4=' + math.evaluate('addIt(2, 4)'))
// This will output:
//
//     input: a=2, b=4
//     result: 6
//     2+4=6

// when used via plain JavaScript, the transform is not invoked
console.log('')
console.log('Using plain JavaScript:')
console.log('2+4=' + math.addIt(2, 4))
// This will output:
//
//     6


Functions with a transform must be imported in the math namespace, as they
need to be processed at compile time. They are not supported when passed via a
scope at evaluation time.

Custom argument parsing #

The expression parser of math.js has support for letting functions
parse and evaluate arguments themselves, instead of calling them with
evaluated arguments. This is useful for example when creating a function
like plot(f(x), x) or integrate(f(x), x, start, end), where some of the
arguments need to be processed in a special way. In these cases, the expression
f(x) will be evaluated repeatedly by the function, and x is not evaluated
but used to specify the variable looping over the function f(x).

Functions having a property rawArgs with value true are treated in a special
way by the expression parser: they will be invoked with unevaluated arguments,
allowing the function to process the arguments in a customized way. Raw
functions are called as:

rawFunction(args: Node[], math: Object, scope: Map)


Where :


  args is an Array with nodes of the parsed arguments.
  math is the math namespace against which the expression was compiled.
  scope is a Map 
interface containing the variables defined in the scope 
passed via evaluate(scope). The passed scope is always a Map interface,
and normally a PartitionedMap is used to separate local function variables
like x in a custom defined function f(x) = rawFunction(x) ^ 2 from the 
scope variables. Note that a PartitionedMap can recursively link to another
PartitionedMap.


Raw functions must be imported in the math namespace, as they need to be
processed at compile time. They are not supported when passed via a scope
at evaluation time.

A simple example:

function myFunction(args, math, scope) {
  // get string representation of the arguments
  const str = args.map(function (arg) {
    return arg.toString()
  })

  // evaluate the arguments
  const res = args.map(function (arg) {
    return arg.compile().evaluate(scope)
  })

  return 'arguments: ' + str.join(',') + ', evaluated: ' + res.join(',')
}

// mark the function as "rawArgs", so it will be called with unevaluated arguments
myFunction.rawArgs = true

// import the new function in the math namespace
math.import({
  myFunction: myFunction
})

// use the function
math.evaluate('myFunction(2 + 3, sqrt(4))')
// returns 'arguments: 2 + 3, sqrt(4), evaluated: 5, 2'


Custom LaTeX handlers #

You can attach a toTex property to your custom functions before importing them to define their LaTeX output. This
toTex property can be a handler in the format described in the next section ‘Custom LaTeX and String conversion’
or a template string similar to ES6 templates.

Template syntax #


  ${name}: Gets replaced by the name of the function
  ${args}: Gets replaced by a comma separated list of the arguments of the function.
  ${args[0]}: Gets replaced by the first argument of a function
  $$: Gets replaced by $


Example #

const customFunctions = {
  plus: function (a, b) {
    return a + b
  },
  minus: function (a, b) {
    return a - b
  },
  binom: function (n, k) {
    return 1
  }
}

customFunctions.plus.toTex = '${args[0]}+${args[1]}' //template string
customFunctions.binom.toTex = '\\mathrm{${name}}\\left(${args}\\right)' //template string
customFunctions.minus.toTex = function (node, options) { //handler function
  return node.args[0].toTex(options) + node.name + node.args[1].toTex(options)
}

math.import(customFunctions)

math.parse('plus(1,2)').toTex()    // '1+2'
math.parse('binom(1,2)').toTex()   // '\\mathrm{binom}\\left(1,2\\right)'
math.parse('minus(1,2)').toTex()   // '1minus2'


Custom HTML, LaTeX and string output #

All expression nodes have a method toTex and toString to output an expression respectively in HTML or LaTex format or as regular text .
The functions toHTML, toTex and toString accept an options argument to customise output. This object is of the following form:

{
  parenthesis: 'keep',    // parenthesis option
  handler: someHandler,   // handler to change the output
  implicit: 'hide'        // how to treat implicit multiplication
}


Parenthesis #

The parenthesis option changes the way parentheses are used in the output. There are three options available:


  keep Keep the parentheses from the input and display them as is. This is the default.
  auto Only display parentheses that are necessary. Mathjs tries to get rid of as much parentheses as possible.
  all Display all parentheses that are given by the structure of the node tree. This makes the output precedence unambiguous.


There’s two ways of passing callbacks:


  Pass an object that maps function names to callbacks. Those callbacks will be used for FunctionNodes with
functions of that name.
  Pass a function to toTex. This function will then be used for every node.


const expression = math.parse('(1+1+1)')

expression.toString()                      // (1 + 1 + 1)
expression.toString({parenthesis: 'keep'}) // (1 + 1 + 1)
expression.toString({parenthesis: 'auto'}) // 1 + 1 + 1
expression.toString({parenthesis: 'all'})  // (1 + 1) + 1


Handler #

You can provide the toTex and toString functions of an expression with your own custom handlers that override the internal behaviour. This is especially useful to provide LaTeX/string output for your own custom functions. This can be done in two ways:


  Pass an object that maps function names to callbacks. Those callbacks will be used for FunctionNodes that contain functions with that name.
  Pass a callback directly. This callback will run for every node, so you can replace the output of anything you like.


A callback function has the following form:

function callback (node, options) {
  ...
}

Where options is the object passed to toHTML/toTex/toString. Don’t forget to pass this on to the child nodes, and node is a reference to the current node.

If a callback returns nothing, the standard output will be used. If your callback returns a string, this string will be used.

Although the following examples use toTex, it works for toString and toHTML in the same way

Examples for option 1 #

const customFunctions = {
  binomial: function (n, k) {
    //calculate n choose k
    // (do some stuff)
    return result
  }
}

const customLaTeX = {
  'binomial': function (node, options) { //provide toTex for your own custom function
    return '\\binom{' + node.args[0].toTex(options) + '}{' + node.args[1].toTex(options) + '}'
  },
  'factorial': function (node, options) { //override toTex for builtin functions
  	return 'factorial\\left(' + node.args[0] + '\\right)'
  }
}


You can simply use your custom toTex functions by passing them to toTex:

math.import(customFunctions)
const expression = math.parse('binomial(factorial(2),1)')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains "\binom{factorial\\left(2\\right)}{1}"


Examples for option 2: #

function customLaTeX(node, options) {
  if ((node.type === 'OperatorNode') && (node.fn === 'add')) {
    //don't forget to pass the options to the toTex functions
    return node.args[0].toTex(options) + ' plus ' + node.args[1].toTex(options)
  }
  else if (node.type === 'ConstantNode') {
    if (node.value === 0) {
        return '\\mbox{zero}'
    }
    else if (node.value === 1) {
        return '\\mbox{one}'
    }
    else if (node.value === 2) {
        return '\\mbox{two}'
    }
    else {
        return node.value
    }
  }
}

const expression = math.parse('1+2')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains '\mbox{one} plus \mbox{two}'


Another example in conjunction with custom functions:

const customFunctions = {
  binomial: function (n, k) {
    //calculate n choose k
    // (do some stuff)
    return result
  }
}

function customLaTeX(node, options) {
  if ((node.type === 'FunctionNode') && (node.name === 'binomial')) {
      return '\\binom{' + node.args[0].toTex(options) + '}{' + node.args[1].toTex(options) + '}'
  }
}

math.import(customFunctions)
const expression = math.parse('binomial(2,1)')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains "\binom{2}{1}"


Implicit multiplication #

You can change the way that implicit multiplication is converted to a string or LaTeX. The two options are hide, to not show a multiplication operator for implicit multiplication and show to show it.

Example:

const node = math.parse('2a')

node.toString()                   // '2 a'
node.toString({implicit: 'hide'}) // '2 a'
node.toString({implicit: 'show'}) // '2 * a'

node.toTex()                      // '2~ a'
node.toTex({implicit: 'hide'})    // '2~ a'
node.toTex({implicit: 'show'})    // '2\\cdot a'


Customize supported characters #

It is possible to customize the characters allowed in symbols and digits.
The parse function exposes the following test functions:


  math.parse.isAlpha(c, cPrev, cNext)
  math.parse.isWhitespace(c, nestingLevel)
  math.parse.isDecimalMark(c, cNext)
  math.parse.isDigitDot(c)
  math.parse.isDigit(c)


The exact signature and implementation of these functions can be looked up in
the source code of the parser. The allowed alpha characters are described here: Constants and variables.

For example, the phone character ☎ is not supported by default. It can be enabled
by replacing the isAlpha function:

const isAlphaOriginal = math.parse.isAlpha
math.parse.isAlpha = function (c, cPrev, cNext) {
  return isAlphaOriginal(c, cPrev, cNext) || (c === '\u260E')
}

// now we can use the \u260E (phone) character in expressions
const result = math.evaluate('\u260Efoo', {'\u260Efoo': 42}) // returns 42
console.log(result)\n\n\n\nCustomization #

Besides parsing and evaluating expressions, the expression parser supports
a number of features to customize processing and evaluation of expressions
and outputting expressions.

On this page:


  Function transforms
  Custom argument parsing
  Custom LaTeX handlers
  Custom HTML, LaTeX and string output
  Customize supported characters


Function transforms #

It is possible to preprocess function arguments and post process a functions
return value by writing a transform for the function. A transform is a
function wrapping around a function to be transformed or completely replaces
a function.

For example, the functions for math.js use zero-based matrix indices (as is
common in programing languages), but the expression parser uses one-based
indices. To enable this, all functions dealing with indices have a transform,
which changes input from one-based to zero-based, and transforms output (and
error message) from zero-based to one-based.

// using plain JavaScript, indices are zero-based:
const a = [[1, 2], [3, 4]]       // a 2x2 matrix
math.subset(a, math.index(0, 1)) // returns 2

// using the expression parser, indices are transformed to one-based:
const a = [[1, 2], [3, 4]] // a 2x2 matrix
let scope = {
  a: a
}
math.evaluate('subset(a, index(1, 2))', scope) // returns 2


To create a transform for a function, the transform function must be attached
to the function as property transform:

import { create, all } from 'mathjs'
const math = create(all)

// create a function
function addIt(a, b) {
  return a + b
}

// attach a transform function to the function addIt
addIt.transform = function (a, b) {
  console.log('input: a=' + a + ', b=' + b)
  // we can manipulate input here before executing addIt

  const res = addIt(a, b)

  console.log('result: ' + res)
  // we can manipulate result here before returning

  return res
}

// import the function into math.js
math.import({
  addIt: addIt
})

// use the function via the expression parser
console.log('Using expression parser:')
console.log('2+4=' + math.evaluate('addIt(2, 4)'))
// This will output:
//
//     input: a=2, b=4
//     result: 6
//     2+4=6

// when used via plain JavaScript, the transform is not invoked
console.log('')
console.log('Using plain JavaScript:')
console.log('2+4=' + math.addIt(2, 4))
// This will output:
//
//     6


Functions with a transform must be imported in the math namespace, as they
need to be processed at compile time. They are not supported when passed via a
scope at evaluation time.

Custom argument parsing #

The expression parser of math.js has support for letting functions
parse and evaluate arguments themselves, instead of calling them with
evaluated arguments. This is useful for example when creating a function
like plot(f(x), x) or integrate(f(x), x, start, end), where some of the
arguments need to be processed in a special way. In these cases, the expression
f(x) will be evaluated repeatedly by the function, and x is not evaluated
but used to specify the variable looping over the function f(x).

Functions having a property rawArgs with value true are treated in a special
way by the expression parser: they will be invoked with unevaluated arguments,
allowing the function to process the arguments in a customized way. Raw
functions are called as:

rawFunction(args: Node[], math: Object, scope: Map)


Where :


  args is an Array with nodes of the parsed arguments.
  math is the math namespace against which the expression was compiled.
  scope is a Map 
interface containing the variables defined in the scope 
passed via evaluate(scope). The passed scope is always a Map interface,
and normally a PartitionedMap is used to separate local function variables
like x in a custom defined function f(x) = rawFunction(x) ^ 2 from the 
scope variables. Note that a PartitionedMap can recursively link to another
PartitionedMap.


Raw functions must be imported in the math namespace, as they need to be
processed at compile time. They are not supported when passed via a scope
at evaluation time.

A simple example:

function myFunction(args, math, scope) {
  // get string representation of the arguments
  const str = args.map(function (arg) {
    return arg.toString()
  })

  // evaluate the arguments
  const res = args.map(function (arg) {
    return arg.compile().evaluate(scope)
  })

  return 'arguments: ' + str.join(',') + ', evaluated: ' + res.join(',')
}

// mark the function as "rawArgs", so it will be called with unevaluated arguments
myFunction.rawArgs = true

// import the new function in the math namespace
math.import({
  myFunction: myFunction
})

// use the function
math.evaluate('myFunction(2 + 3, sqrt(4))')
// returns 'arguments: 2 + 3, sqrt(4), evaluated: 5, 2'


Custom LaTeX handlers #

You can attach a toTex property to your custom functions before importing them to define their LaTeX output. This
toTex property can be a handler in the format described in the next section ‘Custom LaTeX and String conversion’
or a template string similar to ES6 templates.

Template syntax #


  ${name}: Gets replaced by the name of the function
  ${args}: Gets replaced by a comma separated list of the arguments of the function.
  ${args[0]}: Gets replaced by the first argument of a function
  $$: Gets replaced by $


Example #

const customFunctions = {
  plus: function (a, b) {
    return a + b
  },
  minus: function (a, b) {
    return a - b
  },
  binom: function (n, k) {
    return 1
  }
}

customFunctions.plus.toTex = '${args[0]}+${args[1]}' //template string
customFunctions.binom.toTex = '\\mathrm{${name}}\\left(${args}\\right)' //template string
customFunctions.minus.toTex = function (node, options) { //handler function
  return node.args[0].toTex(options) + node.name + node.args[1].toTex(options)
}

math.import(customFunctions)

math.parse('plus(1,2)').toTex()    // '1+2'
math.parse('binom(1,2)').toTex()   // '\\mathrm{binom}\\left(1,2\\right)'
math.parse('minus(1,2)').toTex()   // '1minus2'


Custom HTML, LaTeX and string output #

All expression nodes have a method toTex and toString to output an expression respectively in HTML or LaTex format or as regular text .
The functions toHTML, toTex and toString accept an options argument to customise output. This object is of the following form:

{
  parenthesis: 'keep',    // parenthesis option
  handler: someHandler,   // handler to change the output
  implicit: 'hide'        // how to treat implicit multiplication
}


Parenthesis #

The parenthesis option changes the way parentheses are used in the output. There are three options available:


  keep Keep the parentheses from the input and display them as is. This is the default.
  auto Only display parentheses that are necessary. Mathjs tries to get rid of as much parentheses as possible.
  all Display all parentheses that are given by the structure of the node tree. This makes the output precedence unambiguous.


There’s two ways of passing callbacks:


  Pass an object that maps function names to callbacks. Those callbacks will be used for FunctionNodes with
functions of that name.
  Pass a function to toTex. This function will then be used for every node.


const expression = math.parse('(1+1+1)')

expression.toString()                      // (1 + 1 + 1)
expression.toString({parenthesis: 'keep'}) // (1 + 1 + 1)
expression.toString({parenthesis: 'auto'}) // 1 + 1 + 1
expression.toString({parenthesis: 'all'})  // (1 + 1) + 1


Handler #

You can provide the toTex and toString functions of an expression with your own custom handlers that override the internal behaviour. This is especially useful to provide LaTeX/string output for your own custom functions. This can be done in two ways:


  Pass an object that maps function names to callbacks. Those callbacks will be used for FunctionNodes that contain functions with that name.
  Pass a callback directly. This callback will run for every node, so you can replace the output of anything you like.


A callback function has the following form:

function callback (node, options) {
  ...
}

Where options is the object passed to toHTML/toTex/toString. Don’t forget to pass this on to the child nodes, and node is a reference to the current node.

If a callback returns nothing, the standard output will be used. If your callback returns a string, this string will be used.

Although the following examples use toTex, it works for toString and toHTML in the same way

Examples for option 1 #

const customFunctions = {
  binomial: function (n, k) {
    //calculate n choose k
    // (do some stuff)
    return result
  }
}

const customLaTeX = {
  'binomial': function (node, options) { //provide toTex for your own custom function
    return '\\binom{' + node.args[0].toTex(options) + '}{' + node.args[1].toTex(options) + '}'
  },
  'factorial': function (node, options) { //override toTex for builtin functions
  	return 'factorial\\left(' + node.args[0] + '\\right)'
  }
}


You can simply use your custom toTex functions by passing them to toTex:

math.import(customFunctions)
const expression = math.parse('binomial(factorial(2),1)')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains "\binom{factorial\\left(2\\right)}{1}"


Examples for option 2: #

function customLaTeX(node, options) {
  if ((node.type === 'OperatorNode') && (node.fn === 'add')) {
    //don't forget to pass the options to the toTex functions
    return node.args[0].toTex(options) + ' plus ' + node.args[1].toTex(options)
  }
  else if (node.type === 'ConstantNode') {
    if (node.value === 0) {
        return '\\mbox{zero}'
    }
    else if (node.value === 1) {
        return '\\mbox{one}'
    }
    else if (node.value === 2) {
        return '\\mbox{two}'
    }
    else {
        return node.value
    }
  }
}

const expression = math.parse('1+2')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains '\mbox{one} plus \mbox{two}'


Another example in conjunction with custom functions:

const customFunctions = {
  binomial: function (n, k) {
    //calculate n choose k
    // (do some stuff)
    return result
  }
}

function customLaTeX(node, options) {
  if ((node.type === 'FunctionNode') && (node.name === 'binomial')) {
      return '\\binom{' + node.args[0].toTex(options) + '}{' + node.args[1].toTex(options) + '}'
  }
}

math.import(customFunctions)
const expression = math.parse('binomial(2,1)')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains "\binom{2}{1}"


Implicit multiplication #

You can change the way that implicit multiplication is converted to a string or LaTeX. The two options are hide, to not show a multiplication operator for implicit multiplication and show to show it.

Example:

const node = math.parse('2a')

node.toString()                   // '2 a'
node.toString({implicit: 'hide'}) // '2 a'
node.toString({implicit: 'show'}) // '2 * a'

node.toTex()                      // '2~ a'
node.toTex({implicit: 'hide'})    // '2~ a'
node.toTex({implicit: 'show'})    // '2\\cdot a'


Customize supported characters #

It is possible to customize the characters allowed in symbols and digits.
The parse function exposes the following test functions:


  math.parse.isAlpha(c, cPrev, cNext)
  math.parse.isWhitespace(c, nestingLevel)
  math.parse.isDecimalMark(c, cNext)
  math.parse.isDigitDot(c)
  math.parse.isDigit(c)


The exact signature and implementation of these functions can be looked up in
the source code of the parser. The allowed alpha characters are described here: Constants and variables.

For example, the phone character ☎ is not supported by default. It can be enabled
by replacing the isAlpha function:

const isAlphaOriginal = math.parse.isAlpha
math.parse.isAlpha = function (c, cPrev, cNext) {
  return isAlphaOriginal(c, cPrev, cNext) || (c === '\u260E')
}

// now we can use the \u260E (phone) character in expressions
const result = math.evaluate('\u260Efoo', {'\u260Efoo': 42}) // returns 42
console.log(result)\n\n\n\nCustomization #

Besides parsing and evaluating expressions, the expression parser supports
a number of features to customize processing and evaluation of expressions
and outputting expressions.

On this page:


  Function transforms
  Custom argument parsing
  Custom LaTeX handlers
  Custom HTML, LaTeX and string output
  Customize supported characters


Function transforms #

It is possible to preprocess function arguments and post process a functions
return value by writing a transform for the function. A transform is a
function wrapping around a function to be transformed or completely replaces
a function.

For example, the functions for math.js use zero-based matrix indices (as is
common in programing languages), but the expression parser uses one-based
indices. To enable this, all functions dealing with indices have a transform,
which changes input from one-based to zero-based, and transforms output (and
error message) from zero-based to one-based.

// using plain JavaScript, indices are zero-based:
const a = [[1, 2], [3, 4]]       // a 2x2 matrix
math.subset(a, math.index(0, 1)) // returns 2

// using the expression parser, indices are transformed to one-based:
const a = [[1, 2], [3, 4]] // a 2x2 matrix
let scope = {
  a: a
}
math.evaluate('subset(a, index(1, 2))', scope) // returns 2


To create a transform for a function, the transform function must be attached
to the function as property transform:

import { create, all } from 'mathjs'
const math = create(all)

// create a function
function addIt(a, b) {
  return a + b
}

// attach a transform function to the function addIt
addIt.transform = function (a, b) {
  console.log('input: a=' + a + ', b=' + b)
  // we can manipulate input here before executing addIt

  const res = addIt(a, b)

  console.log('result: ' + res)
  // we can manipulate result here before returning

  return res
}

// import the function into math.js
math.import({
  addIt: addIt
})

// use the function via the expression parser
console.log('Using expression parser:')
console.log('2+4=' + math.evaluate('addIt(2, 4)'))
// This will output:
//
//     input: a=2, b=4
//     result: 6
//     2+4=6

// when used via plain JavaScript, the transform is not invoked
console.log('')
console.log('Using plain JavaScript:')
console.log('2+4=' + math.addIt(2, 4))
// This will output:
//
//     6


Functions with a transform must be imported in the math namespace, as they
need to be processed at compile time. They are not supported when passed via a
scope at evaluation time.

Custom argument parsing #

The expression parser of math.js has support for letting functions
parse and evaluate arguments themselves, instead of calling them with
evaluated arguments. This is useful for example when creating a function
like plot(f(x), x) or integrate(f(x), x, start, end), where some of the
arguments need to be processed in a special way. In these cases, the expression
f(x) will be evaluated repeatedly by the function, and x is not evaluated
but used to specify the variable looping over the function f(x).

Functions having a property rawArgs with value true are treated in a special
way by the expression parser: they will be invoked with unevaluated arguments,
allowing the function to process the arguments in a customized way. Raw
functions are called as:

rawFunction(args: Node[], math: Object, scope: Map)


Where :


  args is an Array with nodes of the parsed arguments.
  math is the math namespace against which the expression was compiled.
  scope is a Map 
interface containing the variables defined in the scope 
passed via evaluate(scope). The passed scope is always a Map interface,
and normally a PartitionedMap is used to separate local function variables
like x in a custom defined function f(x) = rawFunction(x) ^ 2 from the 
scope variables. Note that a PartitionedMap can recursively link to another
PartitionedMap.


Raw functions must be imported in the math namespace, as they need to be
processed at compile time. They are not supported when passed via a scope
at evaluation time.

A simple example:

function myFunction(args, math, scope) {
  // get string representation of the arguments
  const str = args.map(function (arg) {
    return arg.toString()
  })

  // evaluate the arguments
  const res = args.map(function (arg) {
    return arg.compile().evaluate(scope)
  })

  return 'arguments: ' + str.join(',') + ', evaluated: ' + res.join(',')
}

// mark the function as "rawArgs", so it will be called with unevaluated arguments
myFunction.rawArgs = true

// import the new function in the math namespace
math.import({
  myFunction: myFunction
})

// use the function
math.evaluate('myFunction(2 + 3, sqrt(4))')
// returns 'arguments: 2 + 3, sqrt(4), evaluated: 5, 2'


Custom LaTeX handlers #

You can attach a toTex property to your custom functions before importing them to define their LaTeX output. This
toTex property can be a handler in the format described in the next section ‘Custom LaTeX and String conversion’
or a template string similar to ES6 templates.

Template syntax #


  ${name}: Gets replaced by the name of the function
  ${args}: Gets replaced by a comma separated list of the arguments of the function.
  ${args[0]}: Gets replaced by the first argument of a function
  $$: Gets replaced by $


Example #

const customFunctions = {
  plus: function (a, b) {
    return a + b
  },
  minus: function (a, b) {
    return a - b
  },
  binom: function (n, k) {
    return 1
  }
}

customFunctions.plus.toTex = '${args[0]}+${args[1]}' //template string
customFunctions.binom.toTex = '\\mathrm{${name}}\\left(${args}\\right)' //template string
customFunctions.minus.toTex = function (node, options) { //handler function
  return node.args[0].toTex(options) + node.name + node.args[1].toTex(options)
}

math.import(customFunctions)

math.parse('plus(1,2)').toTex()    // '1+2'
math.parse('binom(1,2)').toTex()   // '\\mathrm{binom}\\left(1,2\\right)'
math.parse('minus(1,2)').toTex()   // '1minus2'


Custom HTML, LaTeX and string output #

All expression nodes have a method toTex and toString to output an expression respectively in HTML or LaTex format or as regular text .
The functions toHTML, toTex and toString accept an options argument to customise output. This object is of the following form:

{
  parenthesis: 'keep',    // parenthesis option
  handler: someHandler,   // handler to change the output
  implicit: 'hide'        // how to treat implicit multiplication
}


Parenthesis #

The parenthesis option changes the way parentheses are used in the output. There are three options available:


  keep Keep the parentheses from the input and display them as is. This is the default.
  auto Only display parentheses that are necessary. Mathjs tries to get rid of as much parentheses as possible.
  all Display all parentheses that are given by the structure of the node tree. This makes the output precedence unambiguous.


There’s two ways of passing callbacks:


  Pass an object that maps function names to callbacks. Those callbacks will be used for FunctionNodes with
functions of that name.
  Pass a function to toTex. This function will then be used for every node.


const expression = math.parse('(1+1+1)')

expression.toString()                      // (1 + 1 + 1)
expression.toString({parenthesis: 'keep'}) // (1 + 1 + 1)
expression.toString({parenthesis: 'auto'}) // 1 + 1 + 1
expression.toString({parenthesis: 'all'})  // (1 + 1) + 1


Handler #

You can provide the toTex and toString functions of an expression with your own custom handlers that override the internal behaviour. This is especially useful to provide LaTeX/string output for your own custom functions. This can be done in two ways:


  Pass an object that maps function names to callbacks. Those callbacks will be used for FunctionNodes that contain functions with that name.
  Pass a callback directly. This callback will run for every node, so you can replace the output of anything you like.


A callback function has the following form:

function callback (node, options) {
  ...
}

Where options is the object passed to toHTML/toTex/toString. Don’t forget to pass this on to the child nodes, and node is a reference to the current node.

If a callback returns nothing, the standard output will be used. If your callback returns a string, this string will be used.

Although the following examples use toTex, it works for toString and toHTML in the same way

Examples for option 1 #

const customFunctions = {
  binomial: function (n, k) {
    //calculate n choose k
    // (do some stuff)
    return result
  }
}

const customLaTeX = {
  'binomial': function (node, options) { //provide toTex for your own custom function
    return '\\binom{' + node.args[0].toTex(options) + '}{' + node.args[1].toTex(options) + '}'
  },
  'factorial': function (node, options) { //override toTex for builtin functions
  	return 'factorial\\left(' + node.args[0] + '\\right)'
  }
}


You can simply use your custom toTex functions by passing them to toTex:

math.import(customFunctions)
const expression = math.parse('binomial(factorial(2),1)')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains "\binom{factorial\\left(2\\right)}{1}"


Examples for option 2: #

function customLaTeX(node, options) {
  if ((node.type === 'OperatorNode') && (node.fn === 'add')) {
    //don't forget to pass the options to the toTex functions
    return node.args[0].toTex(options) + ' plus ' + node.args[1].toTex(options)
  }
  else if (node.type === 'ConstantNode') {
    if (node.value === 0) {
        return '\\mbox{zero}'
    }
    else if (node.value === 1) {
        return '\\mbox{one}'
    }
    else if (node.value === 2) {
        return '\\mbox{two}'
    }
    else {
        return node.value
    }
  }
}

const expression = math.parse('1+2')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains '\mbox{one} plus \mbox{two}'


Another example in conjunction with custom functions:

const customFunctions = {
  binomial: function (n, k) {
    //calculate n choose k
    // (do some stuff)
    return result
  }
}

function customLaTeX(node, options) {
  if ((node.type === 'FunctionNode') && (node.name === 'binomial')) {
      return '\\binom{' + node.args[0].toTex(options) + '}{' + node.args[1].toTex(options) + '}'
  }
}

math.import(customFunctions)
const expression = math.parse('binomial(2,1)')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains "\binom{2}{1}"


Implicit multiplication #

You can change the way that implicit multiplication is converted to a string or LaTeX. The two options are hide, to not show a multiplication operator for implicit multiplication and show to show it.

Example:

const node = math.parse('2a')

node.toString()                   // '2 a'
node.toString({implicit: 'hide'}) // '2 a'
node.toString({implicit: 'show'}) // '2 * a'

node.toTex()                      // '2~ a'
node.toTex({implicit: 'hide'})    // '2~ a'
node.toTex({implicit: 'show'})    // '2\\cdot a'


Customize supported characters #

It is possible to customize the characters allowed in symbols and digits.
The parse function exposes the following test functions:


  math.parse.isAlpha(c, cPrev, cNext)
  math.parse.isWhitespace(c, nestingLevel)
  math.parse.isDecimalMark(c, cNext)
  math.parse.isDigitDot(c)
  math.parse.isDigit(c)


The exact signature and implementation of these functions can be looked up in
the source code of the parser. The allowed alpha characters are described here: Constants and variables.

For example, the phone character ☎ is not supported by default. It can be enabled
by replacing the isAlpha function:

const isAlphaOriginal = math.parse.isAlpha
math.parse.isAlpha = function (c, cPrev, cNext) {
  return isAlphaOriginal(c, cPrev, cNext) || (c === '\u260E')
}

// now we can use the \u260E (phone) character in expressions
const result = math.evaluate('\u260Efoo', {'\u260Efoo': 42}) // returns 42
console.log(result)\n\n\n\nCustomization #

Besides parsing and evaluating expressions, the expression parser supports
a number of features to customize processing and evaluation of expressions
and outputting expressions.

On this page:


  Function transforms
  Custom argument parsing
  Custom LaTeX handlers
  Custom HTML, LaTeX and string output
  Customize supported characters


Function transforms #

It is possible to preprocess function arguments and post process a functions
return value by writing a transform for the function. A transform is a
function wrapping around a function to be transformed or completely replaces
a function.

For example, the functions for math.js use zero-based matrix indices (as is
common in programing languages), but the expression parser uses one-based
indices. To enable this, all functions dealing with indices have a transform,
which changes input from one-based to zero-based, and transforms output (and
error message) from zero-based to one-based.

// using plain JavaScript, indices are zero-based:
const a = [[1, 2], [3, 4]]       // a 2x2 matrix
math.subset(a, math.index(0, 1)) // returns 2

// using the expression parser, indices are transformed to one-based:
const a = [[1, 2], [3, 4]] // a 2x2 matrix
let scope = {
  a: a
}
math.evaluate('subset(a, index(1, 2))', scope) // returns 2


To create a transform for a function, the transform function must be attached
to the function as property transform:

import { create, all } from 'mathjs'
const math = create(all)

// create a function
function addIt(a, b) {
  return a + b
}

// attach a transform function to the function addIt
addIt.transform = function (a, b) {
  console.log('input: a=' + a + ', b=' + b)
  // we can manipulate input here before executing addIt

  const res = addIt(a, b)

  console.log('result: ' + res)
  // we can manipulate result here before returning

  return res
}

// import the function into math.js
math.import({
  addIt: addIt
})

// use the function via the expression parser
console.log('Using expression parser:')
console.log('2+4=' + math.evaluate('addIt(2, 4)'))
// This will output:
//
//     input: a=2, b=4
//     result: 6
//     2+4=6

// when used via plain JavaScript, the transform is not invoked
console.log('')
console.log('Using plain JavaScript:')
console.log('2+4=' + math.addIt(2, 4))
// This will output:
//
//     6


Functions with a transform must be imported in the math namespace, as they
need to be processed at compile time. They are not supported when passed via a
scope at evaluation time.

Custom argument parsing #

The expression parser of math.js has support for letting functions
parse and evaluate arguments themselves, instead of calling them with
evaluated arguments. This is useful for example when creating a function
like plot(f(x), x) or integrate(f(x), x, start, end), where some of the
arguments need to be processed in a special way. In these cases, the expression
f(x) will be evaluated repeatedly by the function, and x is not evaluated
but used to specify the variable looping over the function f(x).

Functions having a property rawArgs with value true are treated in a special
way by the expression parser: they will be invoked with unevaluated arguments,
allowing the function to process the arguments in a customized way. Raw
functions are called as:

rawFunction(args: Node[], math: Object, scope: Map)


Where :


  args is an Array with nodes of the parsed arguments.
  math is the math namespace against which the expression was compiled.
  scope is a Map 
interface containing the variables defined in the scope 
passed via evaluate(scope). The passed scope is always a Map interface,
and normally a PartitionedMap is used to separate local function variables
like x in a custom defined function f(x) = rawFunction(x) ^ 2 from the 
scope variables. Note that a PartitionedMap can recursively link to another
PartitionedMap.


Raw functions must be imported in the math namespace, as they need to be
processed at compile time. They are not supported when passed via a scope
at evaluation time.

A simple example:

function myFunction(args, math, scope) {
  // get string representation of the arguments
  const str = args.map(function (arg) {
    return arg.toString()
  })

  // evaluate the arguments
  const res = args.map(function (arg) {
    return arg.compile().evaluate(scope)
  })

  return 'arguments: ' + str.join(',') + ', evaluated: ' + res.join(',')
}

// mark the function as "rawArgs", so it will be called with unevaluated arguments
myFunction.rawArgs = true

// import the new function in the math namespace
math.import({
  myFunction: myFunction
})

// use the function
math.evaluate('myFunction(2 + 3, sqrt(4))')
// returns 'arguments: 2 + 3, sqrt(4), evaluated: 5, 2'


Custom LaTeX handlers #

You can attach a toTex property to your custom functions before importing them to define their LaTeX output. This
toTex property can be a handler in the format described in the next section ‘Custom LaTeX and String conversion’
or a template string similar to ES6 templates.

Template syntax #


  ${name}: Gets replaced by the name of the function
  ${args}: Gets replaced by a comma separated list of the arguments of the function.
  ${args[0]}: Gets replaced by the first argument of a function
  $$: Gets replaced by $


Example #

const customFunctions = {
  plus: function (a, b) {
    return a + b
  },
  minus: function (a, b) {
    return a - b
  },
  binom: function (n, k) {
    return 1
  }
}

customFunctions.plus.toTex = '${args[0]}+${args[1]}' //template string
customFunctions.binom.toTex = '\\mathrm{${name}}\\left(${args}\\right)' //template string
customFunctions.minus.toTex = function (node, options) { //handler function
  return node.args[0].toTex(options) + node.name + node.args[1].toTex(options)
}

math.import(customFunctions)

math.parse('plus(1,2)').toTex()    // '1+2'
math.parse('binom(1,2)').toTex()   // '\\mathrm{binom}\\left(1,2\\right)'
math.parse('minus(1,2)').toTex()   // '1minus2'


Custom HTML, LaTeX and string output #

All expression nodes have a method toTex and toString to output an expression respectively in HTML or LaTex format or as regular text .
The functions toHTML, toTex and toString accept an options argument to customise output. This object is of the following form:

{
  parenthesis: 'keep',    // parenthesis option
  handler: someHandler,   // handler to change the output
  implicit: 'hide'        // how to treat implicit multiplication
}


Parenthesis #

The parenthesis option changes the way parentheses are used in the output. There are three options available:


  keep Keep the parentheses from the input and display them as is. This is the default.
  auto Only display parentheses that are necessary. Mathjs tries to get rid of as much parentheses as possible.
  all Display all parentheses that are given by the structure of the node tree. This makes the output precedence unambiguous.


There’s two ways of passing callbacks:


  Pass an object that maps function names to callbacks. Those callbacks will be used for FunctionNodes with
functions of that name.
  Pass a function to toTex. This function will then be used for every node.


const expression = math.parse('(1+1+1)')

expression.toString()                      // (1 + 1 + 1)
expression.toString({parenthesis: 'keep'}) // (1 + 1 + 1)
expression.toString({parenthesis: 'auto'}) // 1 + 1 + 1
expression.toString({parenthesis: 'all'})  // (1 + 1) + 1


Handler #

You can provide the toTex and toString functions of an expression with your own custom handlers that override the internal behaviour. This is especially useful to provide LaTeX/string output for your own custom functions. This can be done in two ways:


  Pass an object that maps function names to callbacks. Those callbacks will be used for FunctionNodes that contain functions with that name.
  Pass a callback directly. This callback will run for every node, so you can replace the output of anything you like.


A callback function has the following form:

function callback (node, options) {
  ...
}

Where options is the object passed to toHTML/toTex/toString. Don’t forget to pass this on to the child nodes, and node is a reference to the current node.

If a callback returns nothing, the standard output will be used. If your callback returns a string, this string will be used.

Although the following examples use toTex, it works for toString and toHTML in the same way

Examples for option 1 #

const customFunctions = {
  binomial: function (n, k) {
    //calculate n choose k
    // (do some stuff)
    return result
  }
}

const customLaTeX = {
  'binomial': function (node, options) { //provide toTex for your own custom function
    return '\\binom{' + node.args[0].toTex(options) + '}{' + node.args[1].toTex(options) + '}'
  },
  'factorial': function (node, options) { //override toTex for builtin functions
  	return 'factorial\\left(' + node.args[0] + '\\right)'
  }
}


You can simply use your custom toTex functions by passing them to toTex:

math.import(customFunctions)
const expression = math.parse('binomial(factorial(2),1)')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains "\binom{factorial\\left(2\\right)}{1}"


Examples for option 2: #

function customLaTeX(node, options) {
  if ((node.type === 'OperatorNode') && (node.fn === 'add')) {
    //don't forget to pass the options to the toTex functions
    return node.args[0].toTex(options) + ' plus ' + node.args[1].toTex(options)
  }
  else if (node.type === 'ConstantNode') {
    if (node.value === 0) {
        return '\\mbox{zero}'
    }
    else if (node.value === 1) {
        return '\\mbox{one}'
    }
    else if (node.value === 2) {
        return '\\mbox{two}'
    }
    else {
        return node.value
    }
  }
}

const expression = math.parse('1+2')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains '\mbox{one} plus \mbox{two}'


Another example in conjunction with custom functions:

const customFunctions = {
  binomial: function (n, k) {
    //calculate n choose k
    // (do some stuff)
    return result
  }
}

function customLaTeX(node, options) {
  if ((node.type === 'FunctionNode') && (node.name === 'binomial')) {
      return '\\binom{' + node.args[0].toTex(options) + '}{' + node.args[1].toTex(options) + '}'
  }
}

math.import(customFunctions)
const expression = math.parse('binomial(2,1)')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains "\binom{2}{1}"


Implicit multiplication #

You can change the way that implicit multiplication is converted to a string or LaTeX. The two options are hide, to not show a multiplication operator for implicit multiplication and show to show it.

Example:

const node = math.parse('2a')

node.toString()                   // '2 a'
node.toString({implicit: 'hide'}) // '2 a'
node.toString({implicit: 'show'}) // '2 * a'

node.toTex()                      // '2~ a'
node.toTex({implicit: 'hide'})    // '2~ a'
node.toTex({implicit: 'show'})    // '2\\cdot a'


Customize supported characters #

It is possible to customize the characters allowed in symbols and digits.
The parse function exposes the following test functions:


  math.parse.isAlpha(c, cPrev, cNext)
  math.parse.isWhitespace(c, nestingLevel)
  math.parse.isDecimalMark(c, cNext)
  math.parse.isDigitDot(c)
  math.parse.isDigit(c)


The exact signature and implementation of these functions can be looked up in
the source code of the parser. The allowed alpha characters are described here: Constants and variables.

For example, the phone character ☎ is not supported by default. It can be enabled
by replacing the isAlpha function:

const isAlphaOriginal = math.parse.isAlpha
math.parse.isAlpha = function (c, cPrev, cNext) {
  return isAlphaOriginal(c, cPrev, cNext) || (c === '\u260E')
}

// now we can use the \u260E (phone) character in expressions
const result = math.evaluate('\u260Efoo', {'\u260Efoo': 42}) // returns 42
console.log(result)\n\n\n\nCustomization #

Besides parsing and evaluating expressions, the expression parser supports
a number of features to customize processing and evaluation of expressions
and outputting expressions.

On this page:


  Function transforms
  Custom argument parsing
  Custom LaTeX handlers
  Custom HTML, LaTeX and string output
  Customize supported characters


Function transforms #

It is possible to preprocess function arguments and post process a functions
return value by writing a transform for the function. A transform is a
function wrapping around a function to be transformed or completely replaces
a function.

For example, the functions for math.js use zero-based matrix indices (as is
common in programing languages), but the expression parser uses one-based
indices. To enable this, all functions dealing with indices have a transform,
which changes input from one-based to zero-based, and transforms output (and
error message) from zero-based to one-based.

// using plain JavaScript, indices are zero-based:
const a = [[1, 2], [3, 4]]       // a 2x2 matrix
math.subset(a, math.index(0, 1)) // returns 2

// using the expression parser, indices are transformed to one-based:
const a = [[1, 2], [3, 4]] // a 2x2 matrix
let scope = {
  a: a
}
math.evaluate('subset(a, index(1, 2))', scope) // returns 2


To create a transform for a function, the transform function must be attached
to the function as property transform:

import { create, all } from 'mathjs'
const math = create(all)

// create a function
function addIt(a, b) {
  return a + b
}

// attach a transform function to the function addIt
addIt.transform = function (a, b) {
  console.log('input: a=' + a + ', b=' + b)
  // we can manipulate input here before executing addIt

  const res = addIt(a, b)

  console.log('result: ' + res)
  // we can manipulate result here before returning

  return res
}

// import the function into math.js
math.import({
  addIt: addIt
})

// use the function via the expression parser
console.log('Using expression parser:')
console.log('2+4=' + math.evaluate('addIt(2, 4)'))
// This will output:
//
//     input: a=2, b=4
//     result: 6
//     2+4=6

// when used via plain JavaScript, the transform is not invoked
console.log('')
console.log('Using plain JavaScript:')
console.log('2+4=' + math.addIt(2, 4))
// This will output:
//
//     6


Functions with a transform must be imported in the math namespace, as they
need to be processed at compile time. They are not supported when passed via a
scope at evaluation time.

Custom argument parsing #

The expression parser of math.js has support for letting functions
parse and evaluate arguments themselves, instead of calling them with
evaluated arguments. This is useful for example when creating a function
like plot(f(x), x) or integrate(f(x), x, start, end), where some of the
arguments need to be processed in a special way. In these cases, the expression
f(x) will be evaluated repeatedly by the function, and x is not evaluated
but used to specify the variable looping over the function f(x).

Functions having a property rawArgs with value true are treated in a special
way by the expression parser: they will be invoked with unevaluated arguments,
allowing the function to process the arguments in a customized way. Raw
functions are called as:

rawFunction(args: Node[], math: Object, scope: Map)


Where :


  args is an Array with nodes of the parsed arguments.
  math is the math namespace against which the expression was compiled.
  scope is a Map 
interface containing the variables defined in the scope 
passed via evaluate(scope). The passed scope is always a Map interface,
and normally a PartitionedMap is used to separate local function variables
like x in a custom defined function f(x) = rawFunction(x) ^ 2 from the 
scope variables. Note that a PartitionedMap can recursively link to another
PartitionedMap.


Raw functions must be imported in the math namespace, as they need to be
processed at compile time. They are not supported when passed via a scope
at evaluation time.

A simple example:

function myFunction(args, math, scope) {
  // get string representation of the arguments
  const str = args.map(function (arg) {
    return arg.toString()
  })

  // evaluate the arguments
  const res = args.map(function (arg) {
    return arg.compile().evaluate(scope)
  })

  return 'arguments: ' + str.join(',') + ', evaluated: ' + res.join(',')
}

// mark the function as "rawArgs", so it will be called with unevaluated arguments
myFunction.rawArgs = true

// import the new function in the math namespace
math.import({
  myFunction: myFunction
})

// use the function
math.evaluate('myFunction(2 + 3, sqrt(4))')
// returns 'arguments: 2 + 3, sqrt(4), evaluated: 5, 2'


Custom LaTeX handlers #

You can attach a toTex property to your custom functions before importing them to define their LaTeX output. This
toTex property can be a handler in the format described in the next section ‘Custom LaTeX and String conversion’
or a template string similar to ES6 templates.

Template syntax #


  ${name}: Gets replaced by the name of the function
  ${args}: Gets replaced by a comma separated list of the arguments of the function.
  ${args[0]}: Gets replaced by the first argument of a function
  $$: Gets replaced by $


Example #

const customFunctions = {
  plus: function (a, b) {
    return a + b
  },
  minus: function (a, b) {
    return a - b
  },
  binom: function (n, k) {
    return 1
  }
}

customFunctions.plus.toTex = '${args[0]}+${args[1]}' //template string
customFunctions.binom.toTex = '\\mathrm{${name}}\\left(${args}\\right)' //template string
customFunctions.minus.toTex = function (node, options) { //handler function
  return node.args[0].toTex(options) + node.name + node.args[1].toTex(options)
}

math.import(customFunctions)

math.parse('plus(1,2)').toTex()    // '1+2'
math.parse('binom(1,2)').toTex()   // '\\mathrm{binom}\\left(1,2\\right)'
math.parse('minus(1,2)').toTex()   // '1minus2'


Custom HTML, LaTeX and string output #

All expression nodes have a method toTex and toString to output an expression respectively in HTML or LaTex format or as regular text .
The functions toHTML, toTex and toString accept an options argument to customise output. This object is of the following form:

{
  parenthesis: 'keep',    // parenthesis option
  handler: someHandler,   // handler to change the output
  implicit: 'hide'        // how to treat implicit multiplication
}


Parenthesis #

The parenthesis option changes the way parentheses are used in the output. There are three options available:


  keep Keep the parentheses from the input and display them as is. This is the default.
  auto Only display parentheses that are necessary. Mathjs tries to get rid of as much parentheses as possible.
  all Display all parentheses that are given by the structure of the node tree. This makes the output precedence unambiguous.


There’s two ways of passing callbacks:


  Pass an object that maps function names to callbacks. Those callbacks will be used for FunctionNodes with
functions of that name.
  Pass a function to toTex. This function will then be used for every node.


const expression = math.parse('(1+1+1)')

expression.toString()                      // (1 + 1 + 1)
expression.toString({parenthesis: 'keep'}) // (1 + 1 + 1)
expression.toString({parenthesis: 'auto'}) // 1 + 1 + 1
expression.toString({parenthesis: 'all'})  // (1 + 1) + 1


Handler #

You can provide the toTex and toString functions of an expression with your own custom handlers that override the internal behaviour. This is especially useful to provide LaTeX/string output for your own custom functions. This can be done in two ways:


  Pass an object that maps function names to callbacks. Those callbacks will be used for FunctionNodes that contain functions with that name.
  Pass a callback directly. This callback will run for every node, so you can replace the output of anything you like.


A callback function has the following form:

function callback (node, options) {
  ...
}

Where options is the object passed to toHTML/toTex/toString. Don’t forget to pass this on to the child nodes, and node is a reference to the current node.

If a callback returns nothing, the standard output will be used. If your callback returns a string, this string will be used.

Although the following examples use toTex, it works for toString and toHTML in the same way

Examples for option 1 #

const customFunctions = {
  binomial: function (n, k) {
    //calculate n choose k
    // (do some stuff)
    return result
  }
}

const customLaTeX = {
  'binomial': function (node, options) { //provide toTex for your own custom function
    return '\\binom{' + node.args[0].toTex(options) + '}{' + node.args[1].toTex(options) + '}'
  },
  'factorial': function (node, options) { //override toTex for builtin functions
  	return 'factorial\\left(' + node.args[0] + '\\right)'
  }
}


You can simply use your custom toTex functions by passing them to toTex:

math.import(customFunctions)
const expression = math.parse('binomial(factorial(2),1)')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains "\binom{factorial\\left(2\\right)}{1}"


Examples for option 2: #

function customLaTeX(node, options) {
  if ((node.type === 'OperatorNode') && (node.fn === 'add')) {
    //don't forget to pass the options to the toTex functions
    return node.args[0].toTex(options) + ' plus ' + node.args[1].toTex(options)
  }
  else if (node.type === 'ConstantNode') {
    if (node.value === 0) {
        return '\\mbox{zero}'
    }
    else if (node.value === 1) {
        return '\\mbox{one}'
    }
    else if (node.value === 2) {
        return '\\mbox{two}'
    }
    else {
        return node.value
    }
  }
}

const expression = math.parse('1+2')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains '\mbox{one} plus \mbox{two}'


Another example in conjunction with custom functions:

const customFunctions = {
  binomial: function (n, k) {
    //calculate n choose k
    // (do some stuff)
    return result
  }
}

function customLaTeX(node, options) {
  if ((node.type === 'FunctionNode') && (node.name === 'binomial')) {
      return '\\binom{' + node.args[0].toTex(options) + '}{' + node.args[1].toTex(options) + '}'
  }
}

math.import(customFunctions)
const expression = math.parse('binomial(2,1)')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains "\binom{2}{1}"


Implicit multiplication #

You can change the way that implicit multiplication is converted to a string or LaTeX. The two options are hide, to not show a multiplication operator for implicit multiplication and show to show it.

Example:

const node = math.parse('2a')

node.toString()                   // '2 a'
node.toString({implicit: 'hide'}) // '2 a'
node.toString({implicit: 'show'}) // '2 * a'

node.toTex()                      // '2~ a'
node.toTex({implicit: 'hide'})    // '2~ a'
node.toTex({implicit: 'show'})    // '2\\cdot a'


Customize supported characters #

It is possible to customize the characters allowed in symbols and digits.
The parse function exposes the following test functions:


  math.parse.isAlpha(c, cPrev, cNext)
  math.parse.isWhitespace(c, nestingLevel)
  math.parse.isDecimalMark(c, cNext)
  math.parse.isDigitDot(c)
  math.parse.isDigit(c)


The exact signature and implementation of these functions can be looked up in
the source code of the parser. The allowed alpha characters are described here: Constants and variables.

For example, the phone character ☎ is not supported by default. It can be enabled
by replacing the isAlpha function:

const isAlphaOriginal = math.parse.isAlpha
math.parse.isAlpha = function (c, cPrev, cNext) {
  return isAlphaOriginal(c, cPrev, cNext) || (c === '\u260E')
}

// now we can use the \u260E (phone) character in expressions
const result = math.evaluate('\u260Efoo', {'\u260Efoo': 42}) // returns 42
console.log(result)\n\n\n\nCustomization #

Besides parsing and evaluating expressions, the expression parser supports
a number of features to customize processing and evaluation of expressions
and outputting expressions.

On this page:


  Function transforms
  Custom argument parsing
  Custom LaTeX handlers
  Custom HTML, LaTeX and string output
  Customize supported characters


Function transforms #

It is possible to preprocess function arguments and post process a functions
return value by writing a transform for the function. A transform is a
function wrapping around a function to be transformed or completely replaces
a function.

For example, the functions for math.js use zero-based matrix indices (as is
common in programing languages), but the expression parser uses one-based
indices. To enable this, all functions dealing with indices have a transform,
which changes input from one-based to zero-based, and transforms output (and
error message) from zero-based to one-based.

// using plain JavaScript, indices are zero-based:
const a = [[1, 2], [3, 4]]       // a 2x2 matrix
math.subset(a, math.index(0, 1)) // returns 2

// using the expression parser, indices are transformed to one-based:
const a = [[1, 2], [3, 4]] // a 2x2 matrix
let scope = {
  a: a
}
math.evaluate('subset(a, index(1, 2))', scope) // returns 2


To create a transform for a function, the transform function must be attached
to the function as property transform:

import { create, all } from 'mathjs'
const math = create(all)

// create a function
function addIt(a, b) {
  return a + b
}

// attach a transform function to the function addIt
addIt.transform = function (a, b) {
  console.log('input: a=' + a + ', b=' + b)
  // we can manipulate input here before executing addIt

  const res = addIt(a, b)

  console.log('result: ' + res)
  // we can manipulate result here before returning

  return res
}

// import the function into math.js
math.import({
  addIt: addIt
})

// use the function via the expression parser
console.log('Using expression parser:')
console.log('2+4=' + math.evaluate('addIt(2, 4)'))
// This will output:
//
//     input: a=2, b=4
//     result: 6
//     2+4=6

// when used via plain JavaScript, the transform is not invoked
console.log('')
console.log('Using plain JavaScript:')
console.log('2+4=' + math.addIt(2, 4))
// This will output:
//
//     6


Functions with a transform must be imported in the math namespace, as they
need to be processed at compile time. They are not supported when passed via a
scope at evaluation time.

Custom argument parsing #

The expression parser of math.js has support for letting functions
parse and evaluate arguments themselves, instead of calling them with
evaluated arguments. This is useful for example when creating a function
like plot(f(x), x) or integrate(f(x), x, start, end), where some of the
arguments need to be processed in a special way. In these cases, the expression
f(x) will be evaluated repeatedly by the function, and x is not evaluated
but used to specify the variable looping over the function f(x).

Functions having a property rawArgs with value true are treated in a special
way by the expression parser: they will be invoked with unevaluated arguments,
allowing the function to process the arguments in a customized way. Raw
functions are called as:

rawFunction(args: Node[], math: Object, scope: Map)


Where :


  args is an Array with nodes of the parsed arguments.
  math is the math namespace against which the expression was compiled.
  scope is a Map 
interface containing the variables defined in the scope 
passed via evaluate(scope). The passed scope is always a Map interface,
and normally a PartitionedMap is used to separate local function variables
like x in a custom defined function f(x) = rawFunction(x) ^ 2 from the 
scope variables. Note that a PartitionedMap can recursively link to another
PartitionedMap.


Raw functions must be imported in the math namespace, as they need to be
processed at compile time. They are not supported when passed via a scope
at evaluation time.

A simple example:

function myFunction(args, math, scope) {
  // get string representation of the arguments
  const str = args.map(function (arg) {
    return arg.toString()
  })

  // evaluate the arguments
  const res = args.map(function (arg) {
    return arg.compile().evaluate(scope)
  })

  return 'arguments: ' + str.join(',') + ', evaluated: ' + res.join(',')
}

// mark the function as "rawArgs", so it will be called with unevaluated arguments
myFunction.rawArgs = true

// import the new function in the math namespace
math.import({
  myFunction: myFunction
})

// use the function
math.evaluate('myFunction(2 + 3, sqrt(4))')
// returns 'arguments: 2 + 3, sqrt(4), evaluated: 5, 2'


Custom LaTeX handlers #

You can attach a toTex property to your custom functions before importing them to define their LaTeX output. This
toTex property can be a handler in the format described in the next section ‘Custom LaTeX and String conversion’
or a template string similar to ES6 templates.

Template syntax #


  ${name}: Gets replaced by the name of the function
  ${args}: Gets replaced by a comma separated list of the arguments of the function.
  ${args[0]}: Gets replaced by the first argument of a function
  $$: Gets replaced by $


Example #

const customFunctions = {
  plus: function (a, b) {
    return a + b
  },
  minus: function (a, b) {
    return a - b
  },
  binom: function (n, k) {
    return 1
  }
}

customFunctions.plus.toTex = '${args[0]}+${args[1]}' //template string
customFunctions.binom.toTex = '\\mathrm{${name}}\\left(${args}\\right)' //template string
customFunctions.minus.toTex = function (node, options) { //handler function
  return node.args[0].toTex(options) + node.name + node.args[1].toTex(options)
}

math.import(customFunctions)

math.parse('plus(1,2)').toTex()    // '1+2'
math.parse('binom(1,2)').toTex()   // '\\mathrm{binom}\\left(1,2\\right)'
math.parse('minus(1,2)').toTex()   // '1minus2'


Custom HTML, LaTeX and string output #

All expression nodes have a method toTex and toString to output an expression respectively in HTML or LaTex format or as regular text .
The functions toHTML, toTex and toString accept an options argument to customise output. This object is of the following form:

{
  parenthesis: 'keep',    // parenthesis option
  handler: someHandler,   // handler to change the output
  implicit: 'hide'        // how to treat implicit multiplication
}


Parenthesis #

The parenthesis option changes the way parentheses are used in the output. There are three options available:


  keep Keep the parentheses from the input and display them as is. This is the default.
  auto Only display parentheses that are necessary. Mathjs tries to get rid of as much parentheses as possible.
  all Display all parentheses that are given by the structure of the node tree. This makes the output precedence unambiguous.


There’s two ways of passing callbacks:


  Pass an object that maps function names to callbacks. Those callbacks will be used for FunctionNodes with
functions of that name.
  Pass a function to toTex. This function will then be used for every node.


const expression = math.parse('(1+1+1)')

expression.toString()                      // (1 + 1 + 1)
expression.toString({parenthesis: 'keep'}) // (1 + 1 + 1)
expression.toString({parenthesis: 'auto'}) // 1 + 1 + 1
expression.toString({parenthesis: 'all'})  // (1 + 1) + 1


Handler #

You can provide the toTex and toString functions of an expression with your own custom handlers that override the internal behaviour. This is especially useful to provide LaTeX/string output for your own custom functions. This can be done in two ways:


  Pass an object that maps function names to callbacks. Those callbacks will be used for FunctionNodes that contain functions with that name.
  Pass a callback directly. This callback will run for every node, so you can replace the output of anything you like.


A callback function has the following form:

function callback (node, options) {
  ...
}

Where options is the object passed to toHTML/toTex/toString. Don’t forget to pass this on to the child nodes, and node is a reference to the current node.

If a callback returns nothing, the standard output will be used. If your callback returns a string, this string will be used.

Although the following examples use toTex, it works for toString and toHTML in the same way

Examples for option 1 #

const customFunctions = {
  binomial: function (n, k) {
    //calculate n choose k
    // (do some stuff)
    return result
  }
}

const customLaTeX = {
  'binomial': function (node, options) { //provide toTex for your own custom function
    return '\\binom{' + node.args[0].toTex(options) + '}{' + node.args[1].toTex(options) + '}'
  },
  'factorial': function (node, options) { //override toTex for builtin functions
  	return 'factorial\\left(' + node.args[0] + '\\right)'
  }
}


You can simply use your custom toTex functions by passing them to toTex:

math.import(customFunctions)
const expression = math.parse('binomial(factorial(2),1)')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains "\binom{factorial\\left(2\\right)}{1}"


Examples for option 2: #

function customLaTeX(node, options) {
  if ((node.type === 'OperatorNode') && (node.fn === 'add')) {
    //don't forget to pass the options to the toTex functions
    return node.args[0].toTex(options) + ' plus ' + node.args[1].toTex(options)
  }
  else if (node.type === 'ConstantNode') {
    if (node.value === 0) {
        return '\\mbox{zero}'
    }
    else if (node.value === 1) {
        return '\\mbox{one}'
    }
    else if (node.value === 2) {
        return '\\mbox{two}'
    }
    else {
        return node.value
    }
  }
}

const expression = math.parse('1+2')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains '\mbox{one} plus \mbox{two}'


Another example in conjunction with custom functions:

const customFunctions = {
  binomial: function (n, k) {
    //calculate n choose k
    // (do some stuff)
    return result
  }
}

function customLaTeX(node, options) {
  if ((node.type === 'FunctionNode') && (node.name === 'binomial')) {
      return '\\binom{' + node.args[0].toTex(options) + '}{' + node.args[1].toTex(options) + '}'
  }
}

math.import(customFunctions)
const expression = math.parse('binomial(2,1)')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains "\binom{2}{1}"


Implicit multiplication #

You can change the way that implicit multiplication is converted to a string or LaTeX. The two options are hide, to not show a multiplication operator for implicit multiplication and show to show it.

Example:

const node = math.parse('2a')

node.toString()                   // '2 a'
node.toString({implicit: 'hide'}) // '2 a'
node.toString({implicit: 'show'}) // '2 * a'

node.toTex()                      // '2~ a'
node.toTex({implicit: 'hide'})    // '2~ a'
node.toTex({implicit: 'show'})    // '2\\cdot a'


Customize supported characters #

It is possible to customize the characters allowed in symbols and digits.
The parse function exposes the following test functions:


  math.parse.isAlpha(c, cPrev, cNext)
  math.parse.isWhitespace(c, nestingLevel)
  math.parse.isDecimalMark(c, cNext)
  math.parse.isDigitDot(c)
  math.parse.isDigit(c)


The exact signature and implementation of these functions can be looked up in
the source code of the parser. The allowed alpha characters are described here: Constants and variables.

For example, the phone character ☎ is not supported by default. It can be enabled
by replacing the isAlpha function:

const isAlphaOriginal = math.parse.isAlpha
math.parse.isAlpha = function (c, cPrev, cNext) {
  return isAlphaOriginal(c, cPrev, cNext) || (c === '\u260E')
}

// now we can use the \u260E (phone) character in expressions
const result = math.evaluate('\u260Efoo', {'\u260Efoo': 42}) // returns 42
console.log(result)\n\n\n\nCustomization #

Besides parsing and evaluating expressions, the expression parser supports
a number of features to customize processing and evaluation of expressions
and outputting expressions.

On this page:


  Function transforms
  Custom argument parsing
  Custom LaTeX handlers
  Custom HTML, LaTeX and string output
  Customize supported characters


Function transforms #

It is possible to preprocess function arguments and post process a functions
return value by writing a transform for the function. A transform is a
function wrapping around a function to be transformed or completely replaces
a function.

For example, the functions for math.js use zero-based matrix indices (as is
common in programing languages), but the expression parser uses one-based
indices. To enable this, all functions dealing with indices have a transform,
which changes input from one-based to zero-based, and transforms output (and
error message) from zero-based to one-based.

// using plain JavaScript, indices are zero-based:
const a = [[1, 2], [3, 4]]       // a 2x2 matrix
math.subset(a, math.index(0, 1)) // returns 2

// using the expression parser, indices are transformed to one-based:
const a = [[1, 2], [3, 4]] // a 2x2 matrix
let scope = {
  a: a
}
math.evaluate('subset(a, index(1, 2))', scope) // returns 2


To create a transform for a function, the transform function must be attached
to the function as property transform:

import { create, all } from 'mathjs'
const math = create(all)

// create a function
function addIt(a, b) {
  return a + b
}

// attach a transform function to the function addIt
addIt.transform = function (a, b) {
  console.log('input: a=' + a + ', b=' + b)
  // we can manipulate input here before executing addIt

  const res = addIt(a, b)

  console.log('result: ' + res)
  // we can manipulate result here before returning

  return res
}

// import the function into math.js
math.import({
  addIt: addIt
})

// use the function via the expression parser
console.log('Using expression parser:')
console.log('2+4=' + math.evaluate('addIt(2, 4)'))
// This will output:
//
//     input: a=2, b=4
//     result: 6
//     2+4=6

// when used via plain JavaScript, the transform is not invoked
console.log('')
console.log('Using plain JavaScript:')
console.log('2+4=' + math.addIt(2, 4))
// This will output:
//
//     6


Functions with a transform must be imported in the math namespace, as they
need to be processed at compile time. They are not supported when passed via a
scope at evaluation time.

Custom argument parsing #

The expression parser of math.js has support for letting functions
parse and evaluate arguments themselves, instead of calling them with
evaluated arguments. This is useful for example when creating a function
like plot(f(x), x) or integrate(f(x), x, start, end), where some of the
arguments need to be processed in a special way. In these cases, the expression
f(x) will be evaluated repeatedly by the function, and x is not evaluated
but used to specify the variable looping over the function f(x).

Functions having a property rawArgs with value true are treated in a special
way by the expression parser: they will be invoked with unevaluated arguments,
allowing the function to process the arguments in a customized way. Raw
functions are called as:

rawFunction(args: Node[], math: Object, scope: Map)


Where :


  args is an Array with nodes of the parsed arguments.
  math is the math namespace against which the expression was compiled.
  scope is a Map 
interface containing the variables defined in the scope 
passed via evaluate(scope). The passed scope is always a Map interface,
and normally a PartitionedMap is used to separate local function variables
like x in a custom defined function f(x) = rawFunction(x) ^ 2 from the 
scope variables. Note that a PartitionedMap can recursively link to another
PartitionedMap.


Raw functions must be imported in the math namespace, as they need to be
processed at compile time. They are not supported when passed via a scope
at evaluation time.

A simple example:

function myFunction(args, math, scope) {
  // get string representation of the arguments
  const str = args.map(function (arg) {
    return arg.toString()
  })

  // evaluate the arguments
  const res = args.map(function (arg) {
    return arg.compile().evaluate(scope)
  })

  return 'arguments: ' + str.join(',') + ', evaluated: ' + res.join(',')
}

// mark the function as "rawArgs", so it will be called with unevaluated arguments
myFunction.rawArgs = true

// import the new function in the math namespace
math.import({
  myFunction: myFunction
})

// use the function
math.evaluate('myFunction(2 + 3, sqrt(4))')
// returns 'arguments: 2 + 3, sqrt(4), evaluated: 5, 2'


Custom LaTeX handlers #

You can attach a toTex property to your custom functions before importing them to define their LaTeX output. This
toTex property can be a handler in the format described in the next section ‘Custom LaTeX and String conversion’
or a template string similar to ES6 templates.

Template syntax #


  ${name}: Gets replaced by the name of the function
  ${args}: Gets replaced by a comma separated list of the arguments of the function.
  ${args[0]}: Gets replaced by the first argument of a function
  $$: Gets replaced by $


Example #

const customFunctions = {
  plus: function (a, b) {
    return a + b
  },
  minus: function (a, b) {
    return a - b
  },
  binom: function (n, k) {
    return 1
  }
}

customFunctions.plus.toTex = '${args[0]}+${args[1]}' //template string
customFunctions.binom.toTex = '\\mathrm{${name}}\\left(${args}\\right)' //template string
customFunctions.minus.toTex = function (node, options) { //handler function
  return node.args[0].toTex(options) + node.name + node.args[1].toTex(options)
}

math.import(customFunctions)

math.parse('plus(1,2)').toTex()    // '1+2'
math.parse('binom(1,2)').toTex()   // '\\mathrm{binom}\\left(1,2\\right)'
math.parse('minus(1,2)').toTex()   // '1minus2'


Custom HTML, LaTeX and string output #

All expression nodes have a method toTex and toString to output an expression respectively in HTML or LaTex format or as regular text .
The functions toHTML, toTex and toString accept an options argument to customise output. This object is of the following form:

{
  parenthesis: 'keep',    // parenthesis option
  handler: someHandler,   // handler to change the output
  implicit: 'hide'        // how to treat implicit multiplication
}


Parenthesis #

The parenthesis option changes the way parentheses are used in the output. There are three options available:


  keep Keep the parentheses from the input and display them as is. This is the default.
  auto Only display parentheses that are necessary. Mathjs tries to get rid of as much parentheses as possible.
  all Display all parentheses that are given by the structure of the node tree. This makes the output precedence unambiguous.


There’s two ways of passing callbacks:


  Pass an object that maps function names to callbacks. Those callbacks will be used for FunctionNodes with
functions of that name.
  Pass a function to toTex. This function will then be used for every node.


const expression = math.parse('(1+1+1)')

expression.toString()                      // (1 + 1 + 1)
expression.toString({parenthesis: 'keep'}) // (1 + 1 + 1)
expression.toString({parenthesis: 'auto'}) // 1 + 1 + 1
expression.toString({parenthesis: 'all'})  // (1 + 1) + 1


Handler #

You can provide the toTex and toString functions of an expression with your own custom handlers that override the internal behaviour. This is especially useful to provide LaTeX/string output for your own custom functions. This can be done in two ways:


  Pass an object that maps function names to callbacks. Those callbacks will be used for FunctionNodes that contain functions with that name.
  Pass a callback directly. This callback will run for every node, so you can replace the output of anything you like.


A callback function has the following form:

function callback (node, options) {
  ...
}

Where options is the object passed to toHTML/toTex/toString. Don’t forget to pass this on to the child nodes, and node is a reference to the current node.

If a callback returns nothing, the standard output will be used. If your callback returns a string, this string will be used.

Although the following examples use toTex, it works for toString and toHTML in the same way

Examples for option 1 #

const customFunctions = {
  binomial: function (n, k) {
    //calculate n choose k
    // (do some stuff)
    return result
  }
}

const customLaTeX = {
  'binomial': function (node, options) { //provide toTex for your own custom function
    return '\\binom{' + node.args[0].toTex(options) + '}{' + node.args[1].toTex(options) + '}'
  },
  'factorial': function (node, options) { //override toTex for builtin functions
  	return 'factorial\\left(' + node.args[0] + '\\right)'
  }
}


You can simply use your custom toTex functions by passing them to toTex:

math.import(customFunctions)
const expression = math.parse('binomial(factorial(2),1)')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains "\binom{factorial\\left(2\\right)}{1}"


Examples for option 2: #

function customLaTeX(node, options) {
  if ((node.type === 'OperatorNode') && (node.fn === 'add')) {
    //don't forget to pass the options to the toTex functions
    return node.args[0].toTex(options) + ' plus ' + node.args[1].toTex(options)
  }
  else if (node.type === 'ConstantNode') {
    if (node.value === 0) {
        return '\\mbox{zero}'
    }
    else if (node.value === 1) {
        return '\\mbox{one}'
    }
    else if (node.value === 2) {
        return '\\mbox{two}'
    }
    else {
        return node.value
    }
  }
}

const expression = math.parse('1+2')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains '\mbox{one} plus \mbox{two}'


Another example in conjunction with custom functions:

const customFunctions = {
  binomial: function (n, k) {
    //calculate n choose k
    // (do some stuff)
    return result
  }
}

function customLaTeX(node, options) {
  if ((node.type === 'FunctionNode') && (node.name === 'binomial')) {
      return '\\binom{' + node.args[0].toTex(options) + '}{' + node.args[1].toTex(options) + '}'
  }
}

math.import(customFunctions)
const expression = math.parse('binomial(2,1)')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains "\binom{2}{1}"


Implicit multiplication #

You can change the way that implicit multiplication is converted to a string or LaTeX. The two options are hide, to not show a multiplication operator for implicit multiplication and show to show it.

Example:

const node = math.parse('2a')

node.toString()                   // '2 a'
node.toString({implicit: 'hide'}) // '2 a'
node.toString({implicit: 'show'}) // '2 * a'

node.toTex()                      // '2~ a'
node.toTex({implicit: 'hide'})    // '2~ a'
node.toTex({implicit: 'show'})    // '2\\cdot a'


Customize supported characters #

It is possible to customize the characters allowed in symbols and digits.
The parse function exposes the following test functions:


  math.parse.isAlpha(c, cPrev, cNext)
  math.parse.isWhitespace(c, nestingLevel)
  math.parse.isDecimalMark(c, cNext)
  math.parse.isDigitDot(c)
  math.parse.isDigit(c)


The exact signature and implementation of these functions can be looked up in
the source code of the parser. The allowed alpha characters are described here: Constants and variables.

For example, the phone character ☎ is not supported by default. It can be enabled
by replacing the isAlpha function:

const isAlphaOriginal = math.parse.isAlpha
math.parse.isAlpha = function (c, cPrev, cNext) {
  return isAlphaOriginal(c, cPrev, cNext) || (c === '\u260E')
}

// now we can use the \u260E (phone) character in expressions
const result = math.evaluate('\u260Efoo', {'\u260Efoo': 42}) // returns 42
console.log(result)\n\n\n\nCustomization #

Besides parsing and evaluating expressions, the expression parser supports
a number of features to customize processing and evaluation of expressions
and outputting expressions.

On this page:


  Function transforms
  Custom argument parsing
  Custom LaTeX handlers
  Custom HTML, LaTeX and string output
  Customize supported characters


Function transforms #

It is possible to preprocess function arguments and post process a functions
return value by writing a transform for the function. A transform is a
function wrapping around a function to be transformed or completely replaces
a function.

For example, the functions for math.js use zero-based matrix indices (as is
common in programing languages), but the expression parser uses one-based
indices. To enable this, all functions dealing with indices have a transform,
which changes input from one-based to zero-based, and transforms output (and
error message) from zero-based to one-based.

// using plain JavaScript, indices are zero-based:
const a = [[1, 2], [3, 4]]       // a 2x2 matrix
math.subset(a, math.index(0, 1)) // returns 2

// using the expression parser, indices are transformed to one-based:
const a = [[1, 2], [3, 4]] // a 2x2 matrix
let scope = {
  a: a
}
math.evaluate('subset(a, index(1, 2))', scope) // returns 2


To create a transform for a function, the transform function must be attached
to the function as property transform:

import { create, all } from 'mathjs'
const math = create(all)

// create a function
function addIt(a, b) {
  return a + b
}

// attach a transform function to the function addIt
addIt.transform = function (a, b) {
  console.log('input: a=' + a + ', b=' + b)
  // we can manipulate input here before executing addIt

  const res = addIt(a, b)

  console.log('result: ' + res)
  // we can manipulate result here before returning

  return res
}

// import the function into math.js
math.import({
  addIt: addIt
})

// use the function via the expression parser
console.log('Using expression parser:')
console.log('2+4=' + math.evaluate('addIt(2, 4)'))
// This will output:
//
//     input: a=2, b=4
//     result: 6
//     2+4=6

// when used via plain JavaScript, the transform is not invoked
console.log('')
console.log('Using plain JavaScript:')
console.log('2+4=' + math.addIt(2, 4))
// This will output:
//
//     6


Functions with a transform must be imported in the math namespace, as they
need to be processed at compile time. They are not supported when passed via a
scope at evaluation time.

Custom argument parsing #

The expression parser of math.js has support for letting functions
parse and evaluate arguments themselves, instead of calling them with
evaluated arguments. This is useful for example when creating a function
like plot(f(x), x) or integrate(f(x), x, start, end), where some of the
arguments need to be processed in a special way. In these cases, the expression
f(x) will be evaluated repeatedly by the function, and x is not evaluated
but used to specify the variable looping over the function f(x).

Functions having a property rawArgs with value true are treated in a special
way by the expression parser: they will be invoked with unevaluated arguments,
allowing the function to process the arguments in a customized way. Raw
functions are called as:

rawFunction(args: Node[], math: Object, scope: Map)


Where :


  args is an Array with nodes of the parsed arguments.
  math is the math namespace against which the expression was compiled.
  scope is a Map 
interface containing the variables defined in the scope 
passed via evaluate(scope). The passed scope is always a Map interface,
and normally a PartitionedMap is used to separate local function variables
like x in a custom defined function f(x) = rawFunction(x) ^ 2 from the 
scope variables. Note that a PartitionedMap can recursively link to another
PartitionedMap.


Raw functions must be imported in the math namespace, as they need to be
processed at compile time. They are not supported when passed via a scope
at evaluation time.

A simple example:

function myFunction(args, math, scope) {
  // get string representation of the arguments
  const str = args.map(function (arg) {
    return arg.toString()
  })

  // evaluate the arguments
  const res = args.map(function (arg) {
    return arg.compile().evaluate(scope)
  })

  return 'arguments: ' + str.join(',') + ', evaluated: ' + res.join(',')
}

// mark the function as "rawArgs", so it will be called with unevaluated arguments
myFunction.rawArgs = true

// import the new function in the math namespace
math.import({
  myFunction: myFunction
})

// use the function
math.evaluate('myFunction(2 + 3, sqrt(4))')
// returns 'arguments: 2 + 3, sqrt(4), evaluated: 5, 2'


Custom LaTeX handlers #

You can attach a toTex property to your custom functions before importing them to define their LaTeX output. This
toTex property can be a handler in the format described in the next section ‘Custom LaTeX and String conversion’
or a template string similar to ES6 templates.

Template syntax #


  ${name}: Gets replaced by the name of the function
  ${args}: Gets replaced by a comma separated list of the arguments of the function.
  ${args[0]}: Gets replaced by the first argument of a function
  $$: Gets replaced by $


Example #

const customFunctions = {
  plus: function (a, b) {
    return a + b
  },
  minus: function (a, b) {
    return a - b
  },
  binom: function (n, k) {
    return 1
  }
}

customFunctions.plus.toTex = '${args[0]}+${args[1]}' //template string
customFunctions.binom.toTex = '\\mathrm{${name}}\\left(${args}\\right)' //template string
customFunctions.minus.toTex = function (node, options) { //handler function
  return node.args[0].toTex(options) + node.name + node.args[1].toTex(options)
}

math.import(customFunctions)

math.parse('plus(1,2)').toTex()    // '1+2'
math.parse('binom(1,2)').toTex()   // '\\mathrm{binom}\\left(1,2\\right)'
math.parse('minus(1,2)').toTex()   // '1minus2'


Custom HTML, LaTeX and string output #

All expression nodes have a method toTex and toString to output an expression respectively in HTML or LaTex format or as regular text .
The functions toHTML, toTex and toString accept an options argument to customise output. This object is of the following form:

{
  parenthesis: 'keep',    // parenthesis option
  handler: someHandler,   // handler to change the output
  implicit: 'hide'        // how to treat implicit multiplication
}


Parenthesis #

The parenthesis option changes the way parentheses are used in the output. There are three options available:


  keep Keep the parentheses from the input and display them as is. This is the default.
  auto Only display parentheses that are necessary. Mathjs tries to get rid of as much parentheses as possible.
  all Display all parentheses that are given by the structure of the node tree. This makes the output precedence unambiguous.


There’s two ways of passing callbacks:


  Pass an object that maps function names to callbacks. Those callbacks will be used for FunctionNodes with
functions of that name.
  Pass a function to toTex. This function will then be used for every node.


const expression = math.parse('(1+1+1)')

expression.toString()                      // (1 + 1 + 1)
expression.toString({parenthesis: 'keep'}) // (1 + 1 + 1)
expression.toString({parenthesis: 'auto'}) // 1 + 1 + 1
expression.toString({parenthesis: 'all'})  // (1 + 1) + 1


Handler #

You can provide the toTex and toString functions of an expression with your own custom handlers that override the internal behaviour. This is especially useful to provide LaTeX/string output for your own custom functions. This can be done in two ways:


  Pass an object that maps function names to callbacks. Those callbacks will be used for FunctionNodes that contain functions with that name.
  Pass a callback directly. This callback will run for every node, so you can replace the output of anything you like.


A callback function has the following form:

function callback (node, options) {
  ...
}

Where options is the object passed to toHTML/toTex/toString. Don’t forget to pass this on to the child nodes, and node is a reference to the current node.

If a callback returns nothing, the standard output will be used. If your callback returns a string, this string will be used.

Although the following examples use toTex, it works for toString and toHTML in the same way

Examples for option 1 #

const customFunctions = {
  binomial: function (n, k) {
    //calculate n choose k
    // (do some stuff)
    return result
  }
}

const customLaTeX = {
  'binomial': function (node, options) { //provide toTex for your own custom function
    return '\\binom{' + node.args[0].toTex(options) + '}{' + node.args[1].toTex(options) + '}'
  },
  'factorial': function (node, options) { //override toTex for builtin functions
  	return 'factorial\\left(' + node.args[0] + '\\right)'
  }
}


You can simply use your custom toTex functions by passing them to toTex:

math.import(customFunctions)
const expression = math.parse('binomial(factorial(2),1)')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains "\binom{factorial\\left(2\\right)}{1}"


Examples for option 2: #

function customLaTeX(node, options) {
  if ((node.type === 'OperatorNode') && (node.fn === 'add')) {
    //don't forget to pass the options to the toTex functions
    return node.args[0].toTex(options) + ' plus ' + node.args[1].toTex(options)
  }
  else if (node.type === 'ConstantNode') {
    if (node.value === 0) {
        return '\\mbox{zero}'
    }
    else if (node.value === 1) {
        return '\\mbox{one}'
    }
    else if (node.value === 2) {
        return '\\mbox{two}'
    }
    else {
        return node.value
    }
  }
}

const expression = math.parse('1+2')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains '\mbox{one} plus \mbox{two}'


Another example in conjunction with custom functions:

const customFunctions = {
  binomial: function (n, k) {
    //calculate n choose k
    // (do some stuff)
    return result
  }
}

function customLaTeX(node, options) {
  if ((node.type === 'FunctionNode') && (node.name === 'binomial')) {
      return '\\binom{' + node.args[0].toTex(options) + '}{' + node.args[1].toTex(options) + '}'
  }
}

math.import(customFunctions)
const expression = math.parse('binomial(2,1)')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains "\binom{2}{1}"


Implicit multiplication #

You can change the way that implicit multiplication is converted to a string or LaTeX. The two options are hide, to not show a multiplication operator for implicit multiplication and show to show it.

Example:

const node = math.parse('2a')

node.toString()                   // '2 a'
node.toString({implicit: 'hide'}) // '2 a'
node.toString({implicit: 'show'}) // '2 * a'

node.toTex()                      // '2~ a'
node.toTex({implicit: 'hide'})    // '2~ a'
node.toTex({implicit: 'show'})    // '2\\cdot a'


Customize supported characters #

It is possible to customize the characters allowed in symbols and digits.
The parse function exposes the following test functions:


  math.parse.isAlpha(c, cPrev, cNext)
  math.parse.isWhitespace(c, nestingLevel)
  math.parse.isDecimalMark(c, cNext)
  math.parse.isDigitDot(c)
  math.parse.isDigit(c)


The exact signature and implementation of these functions can be looked up in
the source code of the parser. The allowed alpha characters are described here: Constants and variables.

For example, the phone character ☎ is not supported by default. It can be enabled
by replacing the isAlpha function:

const isAlphaOriginal = math.parse.isAlpha
math.parse.isAlpha = function (c, cPrev, cNext) {
  return isAlphaOriginal(c, cPrev, cNext) || (c === '\u260E')
}

// now we can use the \u260E (phone) character in expressions
const result = math.evaluate('\u260Efoo', {'\u260Efoo': 42}) // returns 42
console.log(result)\n\n\n\nCustomization #

Besides parsing and evaluating expressions, the expression parser supports
a number of features to customize processing and evaluation of expressions
and outputting expressions.

On this page:


  Function transforms
  Custom argument parsing
  Custom LaTeX handlers
  Custom HTML, LaTeX and string output
  Customize supported characters


Function transforms #

It is possible to preprocess function arguments and post process a functions
return value by writing a transform for the function. A transform is a
function wrapping around a function to be transformed or completely replaces
a function.

For example, the functions for math.js use zero-based matrix indices (as is
common in programing languages), but the expression parser uses one-based
indices. To enable this, all functions dealing with indices have a transform,
which changes input from one-based to zero-based, and transforms output (and
error message) from zero-based to one-based.

// using plain JavaScript, indices are zero-based:
const a = [[1, 2], [3, 4]]       // a 2x2 matrix
math.subset(a, math.index(0, 1)) // returns 2

// using the expression parser, indices are transformed to one-based:
const a = [[1, 2], [3, 4]] // a 2x2 matrix
let scope = {
  a: a
}
math.evaluate('subset(a, index(1, 2))', scope) // returns 2


To create a transform for a function, the transform function must be attached
to the function as property transform:

import { create, all } from 'mathjs'
const math = create(all)

// create a function
function addIt(a, b) {
  return a + b
}

// attach a transform function to the function addIt
addIt.transform = function (a, b) {
  console.log('input: a=' + a + ', b=' + b)
  // we can manipulate input here before executing addIt

  const res = addIt(a, b)

  console.log('result: ' + res)
  // we can manipulate result here before returning

  return res
}

// import the function into math.js
math.import({
  addIt: addIt
})

// use the function via the expression parser
console.log('Using expression parser:')
console.log('2+4=' + math.evaluate('addIt(2, 4)'))
// This will output:
//
//     input: a=2, b=4
//     result: 6
//     2+4=6

// when used via plain JavaScript, the transform is not invoked
console.log('')
console.log('Using plain JavaScript:')
console.log('2+4=' + math.addIt(2, 4))
// This will output:
//
//     6


Functions with a transform must be imported in the math namespace, as they
need to be processed at compile time. They are not supported when passed via a
scope at evaluation time.

Custom argument parsing #

The expression parser of math.js has support for letting functions
parse and evaluate arguments themselves, instead of calling them with
evaluated arguments. This is useful for example when creating a function
like plot(f(x), x) or integrate(f(x), x, start, end), where some of the
arguments need to be processed in a special way. In these cases, the expression
f(x) will be evaluated repeatedly by the function, and x is not evaluated
but used to specify the variable looping over the function f(x).

Functions having a property rawArgs with value true are treated in a special
way by the expression parser: they will be invoked with unevaluated arguments,
allowing the function to process the arguments in a customized way. Raw
functions are called as:

rawFunction(args: Node[], math: Object, scope: Map)


Where :


  args is an Array with nodes of the parsed arguments.
  math is the math namespace against which the expression was compiled.
  scope is a Map 
interface containing the variables defined in the scope 
passed via evaluate(scope). The passed scope is always a Map interface,
and normally a PartitionedMap is used to separate local function variables
like x in a custom defined function f(x) = rawFunction(x) ^ 2 from the 
scope variables. Note that a PartitionedMap can recursively link to another
PartitionedMap.


Raw functions must be imported in the math namespace, as they need to be
processed at compile time. They are not supported when passed via a scope
at evaluation time.

A simple example:

function myFunction(args, math, scope) {
  // get string representation of the arguments
  const str = args.map(function (arg) {
    return arg.toString()
  })

  // evaluate the arguments
  const res = args.map(function (arg) {
    return arg.compile().evaluate(scope)
  })

  return 'arguments: ' + str.join(',') + ', evaluated: ' + res.join(',')
}

// mark the function as "rawArgs", so it will be called with unevaluated arguments
myFunction.rawArgs = true

// import the new function in the math namespace
math.import({
  myFunction: myFunction
})

// use the function
math.evaluate('myFunction(2 + 3, sqrt(4))')
// returns 'arguments: 2 + 3, sqrt(4), evaluated: 5, 2'


Custom LaTeX handlers #

You can attach a toTex property to your custom functions before importing them to define their LaTeX output. This
toTex property can be a handler in the format described in the next section ‘Custom LaTeX and String conversion’
or a template string similar to ES6 templates.

Template syntax #


  ${name}: Gets replaced by the name of the function
  ${args}: Gets replaced by a comma separated list of the arguments of the function.
  ${args[0]}: Gets replaced by the first argument of a function
  $$: Gets replaced by $


Example #

const customFunctions = {
  plus: function (a, b) {
    return a + b
  },
  minus: function (a, b) {
    return a - b
  },
  binom: function (n, k) {
    return 1
  }
}

customFunctions.plus.toTex = '${args[0]}+${args[1]}' //template string
customFunctions.binom.toTex = '\\mathrm{${name}}\\left(${args}\\right)' //template string
customFunctions.minus.toTex = function (node, options) { //handler function
  return node.args[0].toTex(options) + node.name + node.args[1].toTex(options)
}

math.import(customFunctions)

math.parse('plus(1,2)').toTex()    // '1+2'
math.parse('binom(1,2)').toTex()   // '\\mathrm{binom}\\left(1,2\\right)'
math.parse('minus(1,2)').toTex()   // '1minus2'


Custom HTML, LaTeX and string output #

All expression nodes have a method toTex and toString to output an expression respectively in HTML or LaTex format or as regular text .
The functions toHTML, toTex and toString accept an options argument to customise output. This object is of the following form:

{
  parenthesis: 'keep',    // parenthesis option
  handler: someHandler,   // handler to change the output
  implicit: 'hide'        // how to treat implicit multiplication
}


Parenthesis #

The parenthesis option changes the way parentheses are used in the output. There are three options available:


  keep Keep the parentheses from the input and display them as is. This is the default.
  auto Only display parentheses that are necessary. Mathjs tries to get rid of as much parentheses as possible.
  all Display all parentheses that are given by the structure of the node tree. This makes the output precedence unambiguous.


There’s two ways of passing callbacks:


  Pass an object that maps function names to callbacks. Those callbacks will be used for FunctionNodes with
functions of that name.
  Pass a function to toTex. This function will then be used for every node.


const expression = math.parse('(1+1+1)')

expression.toString()                      // (1 + 1 + 1)
expression.toString({parenthesis: 'keep'}) // (1 + 1 + 1)
expression.toString({parenthesis: 'auto'}) // 1 + 1 + 1
expression.toString({parenthesis: 'all'})  // (1 + 1) + 1


Handler #

You can provide the toTex and toString functions of an expression with your own custom handlers that override the internal behaviour. This is especially useful to provide LaTeX/string output for your own custom functions. This can be done in two ways:


  Pass an object that maps function names to callbacks. Those callbacks will be used for FunctionNodes that contain functions with that name.
  Pass a callback directly. This callback will run for every node, so you can replace the output of anything you like.


A callback function has the following form:

function callback (node, options) {
  ...
}

Where options is the object passed to toHTML/toTex/toString. Don’t forget to pass this on to the child nodes, and node is a reference to the current node.

If a callback returns nothing, the standard output will be used. If your callback returns a string, this string will be used.

Although the following examples use toTex, it works for toString and toHTML in the same way

Examples for option 1 #

const customFunctions = {
  binomial: function (n, k) {
    //calculate n choose k
    // (do some stuff)
    return result
  }
}

const customLaTeX = {
  'binomial': function (node, options) { //provide toTex for your own custom function
    return '\\binom{' + node.args[0].toTex(options) + '}{' + node.args[1].toTex(options) + '}'
  },
  'factorial': function (node, options) { //override toTex for builtin functions
  	return 'factorial\\left(' + node.args[0] + '\\right)'
  }
}


You can simply use your custom toTex functions by passing them to toTex:

math.import(customFunctions)
const expression = math.parse('binomial(factorial(2),1)')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains "\binom{factorial\\left(2\\right)}{1}"


Examples for option 2: #

function customLaTeX(node, options) {
  if ((node.type === 'OperatorNode') && (node.fn === 'add')) {
    //don't forget to pass the options to the toTex functions
    return node.args[0].toTex(options) + ' plus ' + node.args[1].toTex(options)
  }
  else if (node.type === 'ConstantNode') {
    if (node.value === 0) {
        return '\\mbox{zero}'
    }
    else if (node.value === 1) {
        return '\\mbox{one}'
    }
    else if (node.value === 2) {
        return '\\mbox{two}'
    }
    else {
        return node.value
    }
  }
}

const expression = math.parse('1+2')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains '\mbox{one} plus \mbox{two}'


Another example in conjunction with custom functions:

const customFunctions = {
  binomial: function (n, k) {
    //calculate n choose k
    // (do some stuff)
    return result
  }
}

function customLaTeX(node, options) {
  if ((node.type === 'FunctionNode') && (node.name === 'binomial')) {
      return '\\binom{' + node.args[0].toTex(options) + '}{' + node.args[1].toTex(options) + '}'
  }
}

math.import(customFunctions)
const expression = math.parse('binomial(2,1)')
const latex = expression.toTex({handler: customLaTeX})
// latex now contains "\binom{2}{1}"


Implicit multiplication #

You can change the way that implicit multiplication is converted to a string or LaTeX. The two options are hide, to not show a multiplication operator for implicit multiplication and show to show it.

Example:

const node = math.parse('2a')

node.toString()                   // '2 a'
node.toString({implicit: 'hide'}) // '2 a'
node.toString({implicit: 'show'}) // '2 * a'

node.toTex()                      // '2~ a'
node.toTex({implicit: 'hide'})    // '2~ a'
node.toTex({implicit: 'show'})    // '2\\cdot a'


Customize supported characters #

It is possible to customize the characters allowed in symbols and digits.
The parse function exposes the following test functions:


  math.parse.isAlpha(c, cPrev, cNext)
  math.parse.isWhitespace(c, nestingLevel)
  math.parse.isDecimalMark(c, cNext)
  math.parse.isDigitDot(c)
  math.parse.isDigit(c)


The exact signature and implementation of these functions can be looked up in
the source code of the parser. The allowed alpha characters are described here: Constants and variables.

For example, the phone character ☎ is not supported by default. It can be enabled
by replacing the isAlpha function:

const isAlphaOriginal = math.parse.isAlpha
math.parse.isAlpha = function (c, cPrev, cNext) {
  return isAlphaOriginal(c, cPrev, cNext) || (c === '\u260E')
}

// now we can use the \u260E (phone) character in expressions
const result = math.evaluate('\u260Efoo', {'\u260Efoo': 42}) // returns 42
console.log(result)\n\n\n\nSecurity #

Executing arbitrary expressions like enabled by the expression parser of
mathjs involves a risk in general. When you’re using mathjs to let users
execute arbitrary expressions, it’s good to take a moment to think about
possible security and stability implications, especially when running
the code server side.

Security risks #

A user could try to inject malicious JavaScript code via the expression
parser. The expression parser of mathjs offers a sandboxed environment
to execute expressions which should make this impossible. It’s possible
though that there are unknown security vulnerabilities, so it’s important
to be careful, especially when allowing server side execution of
arbitrary expressions.

The expression parser of mathjs parses the input in a controlled
way into an expression tree or abstract syntax tree (AST).
In a “compile” step, it does as much as possible preprocessing on the
static parts of the expression, and creates a fast performing function
which can be used to evaluate the expression repeatedly using a
dynamically passed scope.

The parser actively prevents access to JavaScripts internal eval and
new Function which are the main cause of security attacks. Mathjs
versions 4 and newer does not use JavaScript’s eval under the hood.
Version 3 and older did use eval for the compile step. This is not
directly a security issue but results in a larger possible attack surface.

When running a node.js server, it’s good to be aware of the different
types of security risks. The risk when running inside a browser may be
limited, though it’s good to be aware of Cross side scripting (XSS) vulnerabilities. A nice overview of
the security risks of node.js servers is listed in the article Node.js security checklist by Gergely Nemeth.

Less vulnerable expression parser #

There is a small number of functions which yield the biggest security
risk in the expression parser:


  import and createUnit which alter the built-in functionality and
allow overriding existing functions and units, and reviver which parses 
values into class instances.
  evaluate, parse, simplify, derivative, and resolve which parse 
arbitrary input into a manipulable expression tree.


To make the expression parser less vulnerable whilst still supporting
most functionality, these functions can be disabled:

import { create, all } from 'mathjs'

const math = create(all)
const limitedEvaluate = math.evaluate

math.import({
  // most important (hardly any functional impact)
  'import':     function () { throw new Error('Function import is disabled') },
  'createUnit': function () { throw new Error('Function createUnit is disabled') },
  'reviver':    function () { throw new Error('Function reviver is disabled') },

  // extra (has functional impact)
  'evaluate':   function () { throw new Error('Function evaluate is disabled') },
  'parse':      function () { throw new Error('Function parse is disabled') },
  'simplify':   function () { throw new Error('Function simplify is disabled') },
  'derivative': function () { throw new Error('Function derivative is disabled') },
  'resolve':    function () { throw new Error('Function resolve is disabled') },
}, { override: true })

console.log(limitedEvaluate('sqrt(16)'))     // Ok, 4
console.log(limitedEvaluate('parse("2+3")')) // Error: Function parse is disabled


Found a security vulnerability? Please report in private! #

You found a security vulnerability? Awesome! We hope you don’t have bad
intentions and want to help fix the issue. Please report the
vulnerability in a private way by contacting one of the maintainers
via mail or another private channel. That way we can work together
on a fix before sharing the issue with everybody including the bad guys.

Stability risks #

A user could accidentally or on purpose execute a
heavy expression like creating a huge matrix. That can let the
JavaScript engine run out of memory or freeze it when the CPU goes
to 100% for a long time.

To protect against this sort of issue, one can run the expression parser
in a separate Web Worker or child_process, so it can’t affect the
main process. The workers can be killed when it runs for too
long or consumes too much memory. A useful library in this regard
is workerpool, which makes
it easy to manage a pool of workers in both browser and node.js.\n\n\n\nSecurity #

Executing arbitrary expressions like enabled by the expression parser of
mathjs involves a risk in general. When you’re using mathjs to let users
execute arbitrary expressions, it’s good to take a moment to think about
possible security and stability implications, especially when running
the code server side.

Security risks #

A user could try to inject malicious JavaScript code via the expression
parser. The expression parser of mathjs offers a sandboxed environment
to execute expressions which should make this impossible. It’s possible
though that there are unknown security vulnerabilities, so it’s important
to be careful, especially when allowing server side execution of
arbitrary expressions.

The expression parser of mathjs parses the input in a controlled
way into an expression tree or abstract syntax tree (AST).
In a “compile” step, it does as much as possible preprocessing on the
static parts of the expression, and creates a fast performing function
which can be used to evaluate the expression repeatedly using a
dynamically passed scope.

The parser actively prevents access to JavaScripts internal eval and
new Function which are the main cause of security attacks. Mathjs
versions 4 and newer does not use JavaScript’s eval under the hood.
Version 3 and older did use eval for the compile step. This is not
directly a security issue but results in a larger possible attack surface.

When running a node.js server, it’s good to be aware of the different
types of security risks. The risk when running inside a browser may be
limited, though it’s good to be aware of Cross side scripting (XSS) vulnerabilities. A nice overview of
the security risks of node.js servers is listed in the article Node.js security checklist by Gergely Nemeth.

Less vulnerable expression parser #

There is a small number of functions which yield the biggest security
risk in the expression parser:


  import and createUnit which alter the built-in functionality and
allow overriding existing functions and units, and reviver which parses 
values into class instances.
  evaluate, parse, simplify, derivative, and resolve which parse 
arbitrary input into a manipulable expression tree.


To make the expression parser less vulnerable whilst still supporting
most functionality, these functions can be disabled:

import { create, all } from 'mathjs'

const math = create(all)
const limitedEvaluate = math.evaluate

math.import({
  // most important (hardly any functional impact)
  'import':     function () { throw new Error('Function import is disabled') },
  'createUnit': function () { throw new Error('Function createUnit is disabled') },
  'reviver':    function () { throw new Error('Function reviver is disabled') },

  // extra (has functional impact)
  'evaluate':   function () { throw new Error('Function evaluate is disabled') },
  'parse':      function () { throw new Error('Function parse is disabled') },
  'simplify':   function () { throw new Error('Function simplify is disabled') },
  'derivative': function () { throw new Error('Function derivative is disabled') },
  'resolve':    function () { throw new Error('Function resolve is disabled') },
}, { override: true })

console.log(limitedEvaluate('sqrt(16)'))     // Ok, 4
console.log(limitedEvaluate('parse("2+3")')) // Error: Function parse is disabled


Found a security vulnerability? Please report in private! #

You found a security vulnerability? Awesome! We hope you don’t have bad
intentions and want to help fix the issue. Please report the
vulnerability in a private way by contacting one of the maintainers
via mail or another private channel. That way we can work together
on a fix before sharing the issue with everybody including the bad guys.

Stability risks #

A user could accidentally or on purpose execute a
heavy expression like creating a huge matrix. That can let the
JavaScript engine run out of memory or freeze it when the CPU goes
to 100% for a long time.

To protect against this sort of issue, one can run the expression parser
in a separate Web Worker or child_process, so it can’t affect the
main process. The workers can be killed when it runs for too
long or consumes too much memory. A useful library in this regard
is workerpool, which makes
it easy to manage a pool of workers in both browser and node.js.\n\n\n\nSecurity #

Executing arbitrary expressions like enabled by the expression parser of
mathjs involves a risk in general. When you’re using mathjs to let users
execute arbitrary expressions, it’s good to take a moment to think about
possible security and stability implications, especially when running
the code server side.

Security risks #

A user could try to inject malicious JavaScript code via the expression
parser. The expression parser of mathjs offers a sandboxed environment
to execute expressions which should make this impossible. It’s possible
though that there are unknown security vulnerabilities, so it’s important
to be careful, especially when allowing server side execution of
arbitrary expressions.

The expression parser of mathjs parses the input in a controlled
way into an expression tree or abstract syntax tree (AST).
In a “compile” step, it does as much as possible preprocessing on the
static parts of the expression, and creates a fast performing function
which can be used to evaluate the expression repeatedly using a
dynamically passed scope.

The parser actively prevents access to JavaScripts internal eval and
new Function which are the main cause of security attacks. Mathjs
versions 4 and newer does not use JavaScript’s eval under the hood.
Version 3 and older did use eval for the compile step. This is not
directly a security issue but results in a larger possible attack surface.

When running a node.js server, it’s good to be aware of the different
types of security risks. The risk when running inside a browser may be
limited, though it’s good to be aware of Cross side scripting (XSS) vulnerabilities. A nice overview of
the security risks of node.js servers is listed in the article Node.js security checklist by Gergely Nemeth.

Less vulnerable expression parser #

There is a small number of functions which yield the biggest security
risk in the expression parser:


  import and createUnit which alter the built-in functionality and
allow overriding existing functions and units, and reviver which parses 
values into class instances.
  evaluate, parse, simplify, derivative, and resolve which parse 
arbitrary input into a manipulable expression tree.


To make the expression parser less vulnerable whilst still supporting
most functionality, these functions can be disabled:

import { create, all } from 'mathjs'

const math = create(all)
const limitedEvaluate = math.evaluate

math.import({
  // most important (hardly any functional impact)
  'import':     function () { throw new Error('Function import is disabled') },
  'createUnit': function () { throw new Error('Function createUnit is disabled') },
  'reviver':    function () { throw new Error('Function reviver is disabled') },

  // extra (has functional impact)
  'evaluate':   function () { throw new Error('Function evaluate is disabled') },
  'parse':      function () { throw new Error('Function parse is disabled') },
  'simplify':   function () { throw new Error('Function simplify is disabled') },
  'derivative': function () { throw new Error('Function derivative is disabled') },
  'resolve':    function () { throw new Error('Function resolve is disabled') },
}, { override: true })

console.log(limitedEvaluate('sqrt(16)'))     // Ok, 4
console.log(limitedEvaluate('parse("2+3")')) // Error: Function parse is disabled


Found a security vulnerability? Please report in private! #

You found a security vulnerability? Awesome! We hope you don’t have bad
intentions and want to help fix the issue. Please report the
vulnerability in a private way by contacting one of the maintainers
via mail or another private channel. That way we can work together
on a fix before sharing the issue with everybody including the bad guys.

Stability risks #

A user could accidentally or on purpose execute a
heavy expression like creating a huge matrix. That can let the
JavaScript engine run out of memory or freeze it when the CPU goes
to 100% for a long time.

To protect against this sort of issue, one can run the expression parser
in a separate Web Worker or child_process, so it can’t affect the
main process. The workers can be killed when it runs for too
long or consumes too much memory. A useful library in this regard
is workerpool, which makes
it easy to manage a pool of workers in both browser and node.js.\n\n\n\nSecurity #

Executing arbitrary expressions like enabled by the expression parser of
mathjs involves a risk in general. When you’re using mathjs to let users
execute arbitrary expressions, it’s good to take a moment to think about
possible security and stability implications, especially when running
the code server side.

Security risks #

A user could try to inject malicious JavaScript code via the expression
parser. The expression parser of mathjs offers a sandboxed environment
to execute expressions which should make this impossible. It’s possible
though that there are unknown security vulnerabilities, so it’s important
to be careful, especially when allowing server side execution of
arbitrary expressions.

The expression parser of mathjs parses the input in a controlled
way into an expression tree or abstract syntax tree (AST).
In a “compile” step, it does as much as possible preprocessing on the
static parts of the expression, and creates a fast performing function
which can be used to evaluate the expression repeatedly using a
dynamically passed scope.

The parser actively prevents access to JavaScripts internal eval and
new Function which are the main cause of security attacks. Mathjs
versions 4 and newer does not use JavaScript’s eval under the hood.
Version 3 and older did use eval for the compile step. This is not
directly a security issue but results in a larger possible attack surface.

When running a node.js server, it’s good to be aware of the different
types of security risks. The risk when running inside a browser may be
limited, though it’s good to be aware of Cross side scripting (XSS) vulnerabilities. A nice overview of
the security risks of node.js servers is listed in the article Node.js security checklist by Gergely Nemeth.

Less vulnerable expression parser #

There is a small number of functions which yield the biggest security
risk in the expression parser:


  import and createUnit which alter the built-in functionality and
allow overriding existing functions and units, and reviver which parses 
values into class instances.
  evaluate, parse, simplify, derivative, and resolve which parse 
arbitrary input into a manipulable expression tree.


To make the expression parser less vulnerable whilst still supporting
most functionality, these functions can be disabled:

import { create, all } from 'mathjs'

const math = create(all)
const limitedEvaluate = math.evaluate

math.import({
  // most important (hardly any functional impact)
  'import':     function () { throw new Error('Function import is disabled') },
  'createUnit': function () { throw new Error('Function createUnit is disabled') },
  'reviver':    function () { throw new Error('Function reviver is disabled') },

  // extra (has functional impact)
  'evaluate':   function () { throw new Error('Function evaluate is disabled') },
  'parse':      function () { throw new Error('Function parse is disabled') },
  'simplify':   function () { throw new Error('Function simplify is disabled') },
  'derivative': function () { throw new Error('Function derivative is disabled') },
  'resolve':    function () { throw new Error('Function resolve is disabled') },
}, { override: true })

console.log(limitedEvaluate('sqrt(16)'))     // Ok, 4
console.log(limitedEvaluate('parse("2+3")')) // Error: Function parse is disabled


Found a security vulnerability? Please report in private! #

You found a security vulnerability? Awesome! We hope you don’t have bad
intentions and want to help fix the issue. Please report the
vulnerability in a private way by contacting one of the maintainers
via mail or another private channel. That way we can work together
on a fix before sharing the issue with everybody including the bad guys.

Stability risks #

A user could accidentally or on purpose execute a
heavy expression like creating a huge matrix. That can let the
JavaScript engine run out of memory or freeze it when the CPU goes
to 100% for a long time.

To protect against this sort of issue, one can run the expression parser
in a separate Web Worker or child_process, so it can’t affect the
main process. The workers can be killed when it runs for too
long or consumes too much memory. A useful library in this regard
is workerpool, which makes
it easy to manage a pool of workers in both browser and node.js.\n\n\n\nSecurity #

Executing arbitrary expressions like enabled by the expression parser of
mathjs involves a risk in general. When you’re using mathjs to let users
execute arbitrary expressions, it’s good to take a moment to think about
possible security and stability implications, especially when running
the code server side.

Security risks #

A user could try to inject malicious JavaScript code via the expression
parser. The expression parser of mathjs offers a sandboxed environment
to execute expressions which should make this impossible. It’s possible
though that there are unknown security vulnerabilities, so it’s important
to be careful, especially when allowing server side execution of
arbitrary expressions.

The expression parser of mathjs parses the input in a controlled
way into an expression tree or abstract syntax tree (AST).
In a “compile” step, it does as much as possible preprocessing on the
static parts of the expression, and creates a fast performing function
which can be used to evaluate the expression repeatedly using a
dynamically passed scope.

The parser actively prevents access to JavaScripts internal eval and
new Function which are the main cause of security attacks. Mathjs
versions 4 and newer does not use JavaScript’s eval under the hood.
Version 3 and older did use eval for the compile step. This is not
directly a security issue but results in a larger possible attack surface.

When running a node.js server, it’s good to be aware of the different
types of security risks. The risk when running inside a browser may be
limited, though it’s good to be aware of Cross side scripting (XSS) vulnerabilities. A nice overview of
the security risks of node.js servers is listed in the article Node.js security checklist by Gergely Nemeth.

Less vulnerable expression parser #

There is a small number of functions which yield the biggest security
risk in the expression parser:


  import and createUnit which alter the built-in functionality and
allow overriding existing functions and units, and reviver which parses 
values into class instances.
  evaluate, parse, simplify, derivative, and resolve which parse 
arbitrary input into a manipulable expression tree.


To make the expression parser less vulnerable whilst still supporting
most functionality, these functions can be disabled:

import { create, all } from 'mathjs'

const math = create(all)
const limitedEvaluate = math.evaluate

math.import({
  // most important (hardly any functional impact)
  'import':     function () { throw new Error('Function import is disabled') },
  'createUnit': function () { throw new Error('Function createUnit is disabled') },
  'reviver':    function () { throw new Error('Function reviver is disabled') },

  // extra (has functional impact)
  'evaluate':   function () { throw new Error('Function evaluate is disabled') },
  'parse':      function () { throw new Error('Function parse is disabled') },
  'simplify':   function () { throw new Error('Function simplify is disabled') },
  'derivative': function () { throw new Error('Function derivative is disabled') },
  'resolve':    function () { throw new Error('Function resolve is disabled') },
}, { override: true })

console.log(limitedEvaluate('sqrt(16)'))     // Ok, 4
console.log(limitedEvaluate('parse("2+3")')) // Error: Function parse is disabled


Found a security vulnerability? Please report in private! #

You found a security vulnerability? Awesome! We hope you don’t have bad
intentions and want to help fix the issue. Please report the
vulnerability in a private way by contacting one of the maintainers
via mail or another private channel. That way we can work together
on a fix before sharing the issue with everybody including the bad guys.

Stability risks #

A user could accidentally or on purpose execute a
heavy expression like creating a huge matrix. That can let the
JavaScript engine run out of memory or freeze it when the CPU goes
to 100% for a long time.

To protect against this sort of issue, one can run the expression parser
in a separate Web Worker or child_process, so it can’t affect the
main process. The workers can be killed when it runs for too
long or consumes too much memory. A useful library in this regard
is workerpool, which makes
it easy to manage a pool of workers in both browser and node.js.\n\n\n\nData Types #

The functions of math.js support multiple data types, both native JavaScript
types as well as more advanced types implemented in math.js. The data types can
be mixed together in calculations, for example by adding a Number to a
Complex number or Array.

The supported data types are:


  Boolean
  Number
  BigNumber
  Complex
  Fraction
  Array
  Matrix
  Unit
  String


Function math.typeOf(x) can be used to get
the type of a variable.

Example usage:

// use numbers
math.subtract(7.1, 2.3)          // 4.8
math.round(math.pi, 3)           // 3.142
math.sqrt(4.41e2)                // 21

// use BigNumbers
math.add(math.bignumber(0.1), math.bignumber(0.2)) // BigNumber, 0.3

// use bigint
math.add(300000000000000000n, 1n) // 300000000000000001n

// use Fractions
math.add(math.fraction(1), math.fraction(3)) // Fraction, 0.(3)

// use strings
math.add('hello ', 'world')      // 'hello world'
math.max('A', 'D', 'C')          // 'D'

// use complex numbers
const a = math.complex(2, 3)     // 2 + 3i
a.re                             // 2
a.im                             // 3
const b = math.complex('4 - 2i') // 4 - 2i
math.add(a, b)                   // 6 + i
math.sqrt(-4)                    // 2i

// use arrays
const array = [1, 2, 3, 4, 5]
math.factorial(array)            // Array,  [1, 2, 6, 24, 120]
math.add(array, 3)               // Array,  [3, 5, 6, 7, 8]

// use matrices
const matrix = math.matrix([1, 4, 9, 16, 25]) // Matrix, [1, 4, 9, 16, 25]
math.sqrt(matrix)                             // Matrix, [1, 2, 3, 4, 5]

// use units
const a = math.unit(55, 'cm')    // 550 mm
const b = math.unit('0.1m')      // 100 mm
math.add(a, b)                   // 0.65 m

// check the type of a variable
math.typeOf(2)                   // 'number'
math.typeOf(math.unit('2 inch')) // 'Unit'
math.typeOf(math.sqrt(-4))       // 'Complex'\n\n\n\nFunction typeOf #

Determine the type of an entity.

Syntax #

math.typeOf(x)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      x
      *
      The variable for which to test the type.
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      string
      Returns the name of the type. Primitive types are lower case, non-primitive types are upper-camel-case. For example ‘number’, ‘string’, ‘Array’, ‘Date’.
    
  


Throws #

Type | Description
—- | ———–

Examples #

// This list is intended to include all relevant types, for testing
// purposes:
math.typeOf(3.5)                      // returns 'number'
math.typeOf(42n)                      // returns 'bigint'
math.typeOf(math.complex('2-4i'))     // returns 'Complex'
math.typeOf(math.unit('45 deg'))      // returns 'Unit'
math.typeOf('hello world')            // returns 'string'
math.typeOf(null)                     // returns 'null'
math.typeOf(true)                     // returns 'boolean'
math.typeOf([1, 2, 3])                // returns 'Array'
math.typeOf(new Date())               // returns 'Date'
math.typeOf(function () {})           // returns 'function'
math.typeOf({a: 2, b: 3})             // returns 'Object'
math.typeOf(/a regexp/)               // returns 'RegExp'
math.typeOf(undefined)                // returns 'undefined'
math.typeOf(math.bignumber('23e99'))  // returns 'BigNumber'
math.typeOf(math.chain(2))            // returns 'Chain'
math.typeOf(math.fraction(1, 3))      // returns 'Fraction'
math.typeOf(math.help('sqrt'))        // returns 'Help'
math.typeOf(math.index(1, 3))         // returns 'Index'
math.typeOf(math.matrix([[1],[3]]))   // returns 'DenseMatrix'
math.typeOf(math.matrix([],'sparse')) // returns 'SparseMatrix'
math.typeOf(new math.Range(0, 10))    // returns 'Range'
math.typeOf(math.evaluate('a=2\na'))  // returns 'ResultSet'
math.typeOf(math.parse('A[2]'))       // returns 'AccessorNode'
math.typeOf(math.parse('[1,2,3]'))    // returns 'ArrayNode'
math.typeOf(math.parse('x=2'))        // returns 'AssignmentNode'
math.typeOf(math.parse('a=2; b=3'))   // returns 'BlockNode'
math.typeOf(math.parse('x<0?-1:1'))   // returns 'ConditionalNode'
math.typeOf(math.parse('2.3'))        // returns 'ConstantNode'
math.typeOf(math.parse('f(x)=x^2'))   // returns 'FunctionAssignmentNode'
math.typeOf(math.parse('sqrt(4)'))    // returns 'FunctionNode'
math.typeOf(math.parse('A[2]').index) // returns 'IndexNode'
math.typeOf(math.parse('{a:2}'))      // returns 'ObjectNode'
math.typeOf(math.parse('(2+3)'))      // returns 'ParenthesisNode'
math.typeOf(math.parse('1:10'))       // returns 'RangeNode'
math.typeOf(math.parse('a<b<c'))      // returns 'RelationalNode'
math.typeOf(math.parse('x'))          // returns 'SymbolNode'\n\n\n\nNumbers #

Math.js supports three types of numbers:


  Number for fast floating point arithmetic, described on this page.
  BigNumber for arbitrary precision arithmetic, described on the page
BigNumbers.
  Fraction, which stores numbers in terms of a numerator and denominators, 
described on the page Fractions.


Configuration #

Most functions can determine the type of output from the type of input:
a number as input will return a number as output, a BigNumber as input returns
a BigNumber as output. Functions which cannot determine the type of output
from the input (for example math.evaluate) use the default number type, which
can be configured when instantiating math.js:

math.config({
  number: 'number' // Default type of number: 
                   // 'number' (default), 'BigNumber', or 'Fraction'
})


Round-off errors #

Math.js uses the built-in JavaScript Number type. A Number is a floating point
number with a limited precision of 64 bits, about 16 digits. The largest integer
number which can be represented by a JavaScript Number
is +/- 9007199254740992 (+/- 2^53). Because of the limited precision of
floating point numbers round-off errors can occur during calculations.
This can be easily demonstrated:

// a round-off error
0.1 + 0.2            // 0.30000000000000004
math.add(0.1, 0.2)   // 0.30000000000000004


In most cases, round-off errors don’t matter: they have no significant
impact on the results. However, it looks ugly when displaying output to a user.
A solution is to limit the precision just below the actual precision of 16
digits in the displayed output:

// prevent round-off errors showing up in output
const ans = math.add(0.1, 0.2)     //  0.30000000000000004
math.format(ans, {precision: 14})  // '0.3'


Alternatives are to use Fractions which store a number as a numerator and denominator, BigNumbers which store a number with a higher precision, or bigint which can store larger integer numbers.

Minimum and maximum #

A Number can store values between 5e-324 and 1.7976931348623157e+308.
Values smaller than the minimum are stored as 0, and values larger than the
maximum are stored as +/- Infinity.

// exceeding the maximum and minimum number
console.log(1e309)   // Infinity
console.log(1e-324)  // 0


Equality #

Because of rounding errors in calculations, it is unsafe to compare JavaScript
Numbers. For example executing 0.1 + 0.2 == 0.3 in JavaScript will return
false, as the addition 0.1 + 0.2 introduces a round-off error and does not
return exactly 0.3.

To solve this problem, the relational functions of math.js check whether the
relative and absolute differences between the compared values is smaller than the configured
option relTol and absTol. In pseudo code (without exceptions for 0, Infinity and NaN):

abs(a-b) <= max(relTol * max(abs(a), abs(b)), absTol)


where:


  relTol is the relative tolerance between x and y and absTol the absolute tolerance. Relative tolerance and absolute tolerance are configurable and are 1e-12 and 1e-15 respectively by default. See Configuration.
  DBL_EPSILON is the minimum positive floating point number such that
1.0 + DBL_EPSILON !== 1.0. This is a constant with a value of approximately
2.2204460492503130808472633361816e-16.


Note that the relational functions cannot be used to compare small values
(< 2.22e-16). These values are all considered equal to zero.

Examples:

// compare values having a round-off error
console.log(0.1 + 0.2 === 0.3)           // false
console.log(math.equal(0.1 + 0.2, 0.3))  // true

// small values (< 2.22e-16) cannot be compared
console.log(3e-20 === 3.1e-20)           // false
console.log(math.equal(3e-20, 3.1e-20))  // true


The available relational functions are: compare, equal, larger,
largerEq, smaller, smallerEq, unequal.\n\n\n\nNumbers #

Math.js supports three types of numbers:


  Number for fast floating point arithmetic, described on this page.
  BigNumber for arbitrary precision arithmetic, described on the page
BigNumbers.
  Fraction, which stores numbers in terms of a numerator and denominators, 
described on the page Fractions.


Configuration #

Most functions can determine the type of output from the type of input:
a number as input will return a number as output, a BigNumber as input returns
a BigNumber as output. Functions which cannot determine the type of output
from the input (for example math.evaluate) use the default number type, which
can be configured when instantiating math.js:

math.config({
  number: 'number' // Default type of number: 
                   // 'number' (default), 'BigNumber', or 'Fraction'
})


Round-off errors #

Math.js uses the built-in JavaScript Number type. A Number is a floating point
number with a limited precision of 64 bits, about 16 digits. The largest integer
number which can be represented by a JavaScript Number
is +/- 9007199254740992 (+/- 2^53). Because of the limited precision of
floating point numbers round-off errors can occur during calculations.
This can be easily demonstrated:

// a round-off error
0.1 + 0.2            // 0.30000000000000004
math.add(0.1, 0.2)   // 0.30000000000000004


In most cases, round-off errors don’t matter: they have no significant
impact on the results. However, it looks ugly when displaying output to a user.
A solution is to limit the precision just below the actual precision of 16
digits in the displayed output:

// prevent round-off errors showing up in output
const ans = math.add(0.1, 0.2)     //  0.30000000000000004
math.format(ans, {precision: 14})  // '0.3'


Alternatives are to use Fractions which store a number as a numerator and denominator, BigNumbers which store a number with a higher precision, or bigint which can store larger integer numbers.

Minimum and maximum #

A Number can store values between 5e-324 and 1.7976931348623157e+308.
Values smaller than the minimum are stored as 0, and values larger than the
maximum are stored as +/- Infinity.

// exceeding the maximum and minimum number
console.log(1e309)   // Infinity
console.log(1e-324)  // 0


Equality #

Because of rounding errors in calculations, it is unsafe to compare JavaScript
Numbers. For example executing 0.1 + 0.2 == 0.3 in JavaScript will return
false, as the addition 0.1 + 0.2 introduces a round-off error and does not
return exactly 0.3.

To solve this problem, the relational functions of math.js check whether the
relative and absolute differences between the compared values is smaller than the configured
option relTol and absTol. In pseudo code (without exceptions for 0, Infinity and NaN):

abs(a-b) <= max(relTol * max(abs(a), abs(b)), absTol)


where:


  relTol is the relative tolerance between x and y and absTol the absolute tolerance. Relative tolerance and absolute tolerance are configurable and are 1e-12 and 1e-15 respectively by default. See Configuration.
  DBL_EPSILON is the minimum positive floating point number such that
1.0 + DBL_EPSILON !== 1.0. This is a constant with a value of approximately
2.2204460492503130808472633361816e-16.


Note that the relational functions cannot be used to compare small values
(< 2.22e-16). These values are all considered equal to zero.

Examples:

// compare values having a round-off error
console.log(0.1 + 0.2 === 0.3)           // false
console.log(math.equal(0.1 + 0.2, 0.3))  // true

// small values (< 2.22e-16) cannot be compared
console.log(3e-20 === 3.1e-20)           // false
console.log(math.equal(3e-20, 3.1e-20))  // true


The available relational functions are: compare, equal, larger,
largerEq, smaller, smallerEq, unequal.\n\n\n\nNumbers #

Math.js supports three types of numbers:


  Number for fast floating point arithmetic, described on this page.
  BigNumber for arbitrary precision arithmetic, described on the page
BigNumbers.
  Fraction, which stores numbers in terms of a numerator and denominators, 
described on the page Fractions.


Configuration #

Most functions can determine the type of output from the type of input:
a number as input will return a number as output, a BigNumber as input returns
a BigNumber as output. Functions which cannot determine the type of output
from the input (for example math.evaluate) use the default number type, which
can be configured when instantiating math.js:

math.config({
  number: 'number' // Default type of number: 
                   // 'number' (default), 'BigNumber', or 'Fraction'
})


Round-off errors #

Math.js uses the built-in JavaScript Number type. A Number is a floating point
number with a limited precision of 64 bits, about 16 digits. The largest integer
number which can be represented by a JavaScript Number
is +/- 9007199254740992 (+/- 2^53). Because of the limited precision of
floating point numbers round-off errors can occur during calculations.
This can be easily demonstrated:

// a round-off error
0.1 + 0.2            // 0.30000000000000004
math.add(0.1, 0.2)   // 0.30000000000000004


In most cases, round-off errors don’t matter: they have no significant
impact on the results. However, it looks ugly when displaying output to a user.
A solution is to limit the precision just below the actual precision of 16
digits in the displayed output:

// prevent round-off errors showing up in output
const ans = math.add(0.1, 0.2)     //  0.30000000000000004
math.format(ans, {precision: 14})  // '0.3'


Alternatives are to use Fractions which store a number as a numerator and denominator, BigNumbers which store a number with a higher precision, or bigint which can store larger integer numbers.

Minimum and maximum #

A Number can store values between 5e-324 and 1.7976931348623157e+308.
Values smaller than the minimum are stored as 0, and values larger than the
maximum are stored as +/- Infinity.

// exceeding the maximum and minimum number
console.log(1e309)   // Infinity
console.log(1e-324)  // 0


Equality #

Because of rounding errors in calculations, it is unsafe to compare JavaScript
Numbers. For example executing 0.1 + 0.2 == 0.3 in JavaScript will return
false, as the addition 0.1 + 0.2 introduces a round-off error and does not
return exactly 0.3.

To solve this problem, the relational functions of math.js check whether the
relative and absolute differences between the compared values is smaller than the configured
option relTol and absTol. In pseudo code (without exceptions for 0, Infinity and NaN):

abs(a-b) <= max(relTol * max(abs(a), abs(b)), absTol)


where:


  relTol is the relative tolerance between x and y and absTol the absolute tolerance. Relative tolerance and absolute tolerance are configurable and are 1e-12 and 1e-15 respectively by default. See Configuration.
  DBL_EPSILON is the minimum positive floating point number such that
1.0 + DBL_EPSILON !== 1.0. This is a constant with a value of approximately
2.2204460492503130808472633361816e-16.


Note that the relational functions cannot be used to compare small values
(< 2.22e-16). These values are all considered equal to zero.

Examples:

// compare values having a round-off error
console.log(0.1 + 0.2 === 0.3)           // false
console.log(math.equal(0.1 + 0.2, 0.3))  // true

// small values (< 2.22e-16) cannot be compared
console.log(3e-20 === 3.1e-20)           // false
console.log(math.equal(3e-20, 3.1e-20))  // true


The available relational functions are: compare, equal, larger,
largerEq, smaller, smallerEq, unequal.\n\n\n\nNumbers #

Math.js supports three types of numbers:


  Number for fast floating point arithmetic, described on this page.
  BigNumber for arbitrary precision arithmetic, described on the page
BigNumbers.
  Fraction, which stores numbers in terms of a numerator and denominators, 
described on the page Fractions.


Configuration #

Most functions can determine the type of output from the type of input:
a number as input will return a number as output, a BigNumber as input returns
a BigNumber as output. Functions which cannot determine the type of output
from the input (for example math.evaluate) use the default number type, which
can be configured when instantiating math.js:

math.config({
  number: 'number' // Default type of number: 
                   // 'number' (default), 'BigNumber', or 'Fraction'
})


Round-off errors #

Math.js uses the built-in JavaScript Number type. A Number is a floating point
number with a limited precision of 64 bits, about 16 digits. The largest integer
number which can be represented by a JavaScript Number
is +/- 9007199254740992 (+/- 2^53). Because of the limited precision of
floating point numbers round-off errors can occur during calculations.
This can be easily demonstrated:

// a round-off error
0.1 + 0.2            // 0.30000000000000004
math.add(0.1, 0.2)   // 0.30000000000000004


In most cases, round-off errors don’t matter: they have no significant
impact on the results. However, it looks ugly when displaying output to a user.
A solution is to limit the precision just below the actual precision of 16
digits in the displayed output:

// prevent round-off errors showing up in output
const ans = math.add(0.1, 0.2)     //  0.30000000000000004
math.format(ans, {precision: 14})  // '0.3'


Alternatives are to use Fractions which store a number as a numerator and denominator, BigNumbers which store a number with a higher precision, or bigint which can store larger integer numbers.

Minimum and maximum #

A Number can store values between 5e-324 and 1.7976931348623157e+308.
Values smaller than the minimum are stored as 0, and values larger than the
maximum are stored as +/- Infinity.

// exceeding the maximum and minimum number
console.log(1e309)   // Infinity
console.log(1e-324)  // 0


Equality #

Because of rounding errors in calculations, it is unsafe to compare JavaScript
Numbers. For example executing 0.1 + 0.2 == 0.3 in JavaScript will return
false, as the addition 0.1 + 0.2 introduces a round-off error and does not
return exactly 0.3.

To solve this problem, the relational functions of math.js check whether the
relative and absolute differences between the compared values is smaller than the configured
option relTol and absTol. In pseudo code (without exceptions for 0, Infinity and NaN):

abs(a-b) <= max(relTol * max(abs(a), abs(b)), absTol)


where:


  relTol is the relative tolerance between x and y and absTol the absolute tolerance. Relative tolerance and absolute tolerance are configurable and are 1e-12 and 1e-15 respectively by default. See Configuration.
  DBL_EPSILON is the minimum positive floating point number such that
1.0 + DBL_EPSILON !== 1.0. This is a constant with a value of approximately
2.2204460492503130808472633361816e-16.


Note that the relational functions cannot be used to compare small values
(< 2.22e-16). These values are all considered equal to zero.

Examples:

// compare values having a round-off error
console.log(0.1 + 0.2 === 0.3)           // false
console.log(math.equal(0.1 + 0.2, 0.3))  // true

// small values (< 2.22e-16) cannot be compared
console.log(3e-20 === 3.1e-20)           // false
console.log(math.equal(3e-20, 3.1e-20))  // true


The available relational functions are: compare, equal, larger,
largerEq, smaller, smallerEq, unequal.\n\n\n\nNumbers #

Math.js supports three types of numbers:


  Number for fast floating point arithmetic, described on this page.
  BigNumber for arbitrary precision arithmetic, described on the page
BigNumbers.
  Fraction, which stores numbers in terms of a numerator and denominators, 
described on the page Fractions.


Configuration #

Most functions can determine the type of output from the type of input:
a number as input will return a number as output, a BigNumber as input returns
a BigNumber as output. Functions which cannot determine the type of output
from the input (for example math.evaluate) use the default number type, which
can be configured when instantiating math.js:

math.config({
  number: 'number' // Default type of number: 
                   // 'number' (default), 'BigNumber', or 'Fraction'
})


Round-off errors #

Math.js uses the built-in JavaScript Number type. A Number is a floating point
number with a limited precision of 64 bits, about 16 digits. The largest integer
number which can be represented by a JavaScript Number
is +/- 9007199254740992 (+/- 2^53). Because of the limited precision of
floating point numbers round-off errors can occur during calculations.
This can be easily demonstrated:

// a round-off error
0.1 + 0.2            // 0.30000000000000004
math.add(0.1, 0.2)   // 0.30000000000000004


In most cases, round-off errors don’t matter: they have no significant
impact on the results. However, it looks ugly when displaying output to a user.
A solution is to limit the precision just below the actual precision of 16
digits in the displayed output:

// prevent round-off errors showing up in output
const ans = math.add(0.1, 0.2)     //  0.30000000000000004
math.format(ans, {precision: 14})  // '0.3'


Alternatives are to use Fractions which store a number as a numerator and denominator, BigNumbers which store a number with a higher precision, or bigint which can store larger integer numbers.

Minimum and maximum #

A Number can store values between 5e-324 and 1.7976931348623157e+308.
Values smaller than the minimum are stored as 0, and values larger than the
maximum are stored as +/- Infinity.

// exceeding the maximum and minimum number
console.log(1e309)   // Infinity
console.log(1e-324)  // 0


Equality #

Because of rounding errors in calculations, it is unsafe to compare JavaScript
Numbers. For example executing 0.1 + 0.2 == 0.3 in JavaScript will return
false, as the addition 0.1 + 0.2 introduces a round-off error and does not
return exactly 0.3.

To solve this problem, the relational functions of math.js check whether the
relative and absolute differences between the compared values is smaller than the configured
option relTol and absTol. In pseudo code (without exceptions for 0, Infinity and NaN):

abs(a-b) <= max(relTol * max(abs(a), abs(b)), absTol)


where:


  relTol is the relative tolerance between x and y and absTol the absolute tolerance. Relative tolerance and absolute tolerance are configurable and are 1e-12 and 1e-15 respectively by default. See Configuration.
  DBL_EPSILON is the minimum positive floating point number such that
1.0 + DBL_EPSILON !== 1.0. This is a constant with a value of approximately
2.2204460492503130808472633361816e-16.


Note that the relational functions cannot be used to compare small values
(< 2.22e-16). These values are all considered equal to zero.

Examples:

// compare values having a round-off error
console.log(0.1 + 0.2 === 0.3)           // false
console.log(math.equal(0.1 + 0.2, 0.3))  // true

// small values (< 2.22e-16) cannot be compared
console.log(3e-20 === 3.1e-20)           // false
console.log(math.equal(3e-20, 3.1e-20))  // true


The available relational functions are: compare, equal, larger,
largerEq, smaller, smallerEq, unequal.\n\n\n\nBigNumbers #

For calculations with an arbitrary precision, math.js supports a BigNumber
datatype. BigNumber support is powered by
decimal.js.

Usage #

A BigNumber can be created using the function bignumber:

math.bignumber('2.3e+500') // BigNumber, 2.3e+500


Most functions can determine the type of output from the type of input:
a number as input will return a number as output, a BigNumber as input returns
a BigNumber as output. Functions which cannot determine the type of output
from the input (for example math.evaluate) use the default number type number,
which can be configured when instantiating math.js. To configure the use of
BigNumbers instead of numbers by default, configure math.js like:

math.config({
  number: 'BigNumber',      // Default type of number:
                            // 'number' (default), 'BigNumber', or 'Fraction'
  precision: 64,            // Number of significant digits for BigNumbers
  relTol: 1e-60,
  absTol: 1e-63
})

// use math
math.evaluate('0.1 + 0.2')  // BigNumber, 0.3


The default precision for BigNumber is 64 digits, and can be configured with
the option precision.

Note that we also change the configuration of relTol and absTol 
to be close to the precision limit of our BigNumbers. relTol and absTol are used for 
example in relational and rounding functions (equal, larger, smaller, 
round, floor, etc) to determine when a value is nearly equal, 
see Equality. If we would leave relTol and absTol  unchanged, 
having the default value of 1e-12 and 1e-15 respectively, we could get inaccurate and misleading 
results since we’re now working with a higher precision.

Support #

Most functions in math.js support BigNumbers, but not all of them.
For example the function random doesn’t support BigNumbers.

Round-off errors #

Calculations with BigNumber are much slower than calculations with Number,
but they can be executed with an arbitrary precision. By using a higher
precision, it is less likely that round-off errors occur:

// round-off errors with numbers
math.add(0.1, 0.2)                                     // Number, 0.30000000000000004
math.divide(0.3, 0.2)                                  // Number, 1.4999999999999998

// no round-off errors with BigNumbers :)
math.add(math.bignumber(0.1), math.bignumber(0.2))     // BigNumber, 0.3
math.divide(math.bignumber(0.3), math.bignumber(0.2))  // BigNumber, 1.5


Limitations #

It’s important to realize that BigNumbers do not solve all problems related
to precision and round-off errors. Numbers with an infinite number of digits
cannot be represented with a regular number nor a BigNumber. Though a BigNumber
can store a much larger number of digits, the amount of digits remains limited
if only to keep calculations fast enough to remain practical.

const one = math.bignumber(1)
const three = math.bignumber(3)
const third = math.divide(one, three)
console.log(third.toString())
// outputs 0.3333333333333333333333333333333333333333333333333333333333333333

const ans = math.multiply(third, three)
console.log(ans.toString())
// outputs 0.9999999999999999999999999999999999999999999999999999999999999999
// this should be 1 again, but `third` is rounded to a limited number of digits 3


Conversion #

BigNumbers can be converted to numbers and vice versa using the functions
number and bignumber. When converting a BigNumber to a number, the high
precision of the BigNumber will be lost. When a BigNumber is too large to be represented
as Number, it will be initialized as Infinity.

// converting numbers and BigNumbers
const a = math.number(0.3)                         // number, 0.3
const b = math.bignumber(a)                        // BigNumber, 0.3
const c = math.number(b)                           // number, 0.3

// exceeding the maximum of a number
const d = math.bignumber('1.2e500')                // BigNumber, 1.2e+500
const e = math.number(d)                           // number, Infinity

// loosing precision when converting to number
const f = math.bignumber('0.2222222222222222222')  // BigNumber, 0.2222222222222222222
const g = math.number(f)                           // number,    0.2222222222222222\n\n\n\nBigNumbers #

For calculations with an arbitrary precision, math.js supports a BigNumber
datatype. BigNumber support is powered by
decimal.js.

Usage #

A BigNumber can be created using the function bignumber:

math.bignumber('2.3e+500') // BigNumber, 2.3e+500


Most functions can determine the type of output from the type of input:
a number as input will return a number as output, a BigNumber as input returns
a BigNumber as output. Functions which cannot determine the type of output
from the input (for example math.evaluate) use the default number type number,
which can be configured when instantiating math.js. To configure the use of
BigNumbers instead of numbers by default, configure math.js like:

math.config({
  number: 'BigNumber',      // Default type of number:
                            // 'number' (default), 'BigNumber', or 'Fraction'
  precision: 64,            // Number of significant digits for BigNumbers
  relTol: 1e-60,
  absTol: 1e-63
})

// use math
math.evaluate('0.1 + 0.2')  // BigNumber, 0.3


The default precision for BigNumber is 64 digits, and can be configured with
the option precision.

Note that we also change the configuration of relTol and absTol 
to be close to the precision limit of our BigNumbers. relTol and absTol are used for 
example in relational and rounding functions (equal, larger, smaller, 
round, floor, etc) to determine when a value is nearly equal, 
see Equality. If we would leave relTol and absTol  unchanged, 
having the default value of 1e-12 and 1e-15 respectively, we could get inaccurate and misleading 
results since we’re now working with a higher precision.

Support #

Most functions in math.js support BigNumbers, but not all of them.
For example the function random doesn’t support BigNumbers.

Round-off errors #

Calculations with BigNumber are much slower than calculations with Number,
but they can be executed with an arbitrary precision. By using a higher
precision, it is less likely that round-off errors occur:

// round-off errors with numbers
math.add(0.1, 0.2)                                     // Number, 0.30000000000000004
math.divide(0.3, 0.2)                                  // Number, 1.4999999999999998

// no round-off errors with BigNumbers :)
math.add(math.bignumber(0.1), math.bignumber(0.2))     // BigNumber, 0.3
math.divide(math.bignumber(0.3), math.bignumber(0.2))  // BigNumber, 1.5


Limitations #

It’s important to realize that BigNumbers do not solve all problems related
to precision and round-off errors. Numbers with an infinite number of digits
cannot be represented with a regular number nor a BigNumber. Though a BigNumber
can store a much larger number of digits, the amount of digits remains limited
if only to keep calculations fast enough to remain practical.

const one = math.bignumber(1)
const three = math.bignumber(3)
const third = math.divide(one, three)
console.log(third.toString())
// outputs 0.3333333333333333333333333333333333333333333333333333333333333333

const ans = math.multiply(third, three)
console.log(ans.toString())
// outputs 0.9999999999999999999999999999999999999999999999999999999999999999
// this should be 1 again, but `third` is rounded to a limited number of digits 3


Conversion #

BigNumbers can be converted to numbers and vice versa using the functions
number and bignumber. When converting a BigNumber to a number, the high
precision of the BigNumber will be lost. When a BigNumber is too large to be represented
as Number, it will be initialized as Infinity.

// converting numbers and BigNumbers
const a = math.number(0.3)                         // number, 0.3
const b = math.bignumber(a)                        // BigNumber, 0.3
const c = math.number(b)                           // number, 0.3

// exceeding the maximum of a number
const d = math.bignumber('1.2e500')                // BigNumber, 1.2e+500
const e = math.number(d)                           // number, Infinity

// loosing precision when converting to number
const f = math.bignumber('0.2222222222222222222')  // BigNumber, 0.2222222222222222222
const g = math.number(f)                           // number,    0.2222222222222222\n\n\n\nBigNumbers #

For calculations with an arbitrary precision, math.js supports a BigNumber
datatype. BigNumber support is powered by
decimal.js.

Usage #

A BigNumber can be created using the function bignumber:

math.bignumber('2.3e+500') // BigNumber, 2.3e+500


Most functions can determine the type of output from the type of input:
a number as input will return a number as output, a BigNumber as input returns
a BigNumber as output. Functions which cannot determine the type of output
from the input (for example math.evaluate) use the default number type number,
which can be configured when instantiating math.js. To configure the use of
BigNumbers instead of numbers by default, configure math.js like:

math.config({
  number: 'BigNumber',      // Default type of number:
                            // 'number' (default), 'BigNumber', or 'Fraction'
  precision: 64,            // Number of significant digits for BigNumbers
  relTol: 1e-60,
  absTol: 1e-63
})

// use math
math.evaluate('0.1 + 0.2')  // BigNumber, 0.3


The default precision for BigNumber is 64 digits, and can be configured with
the option precision.

Note that we also change the configuration of relTol and absTol 
to be close to the precision limit of our BigNumbers. relTol and absTol are used for 
example in relational and rounding functions (equal, larger, smaller, 
round, floor, etc) to determine when a value is nearly equal, 
see Equality. If we would leave relTol and absTol  unchanged, 
having the default value of 1e-12 and 1e-15 respectively, we could get inaccurate and misleading 
results since we’re now working with a higher precision.

Support #

Most functions in math.js support BigNumbers, but not all of them.
For example the function random doesn’t support BigNumbers.

Round-off errors #

Calculations with BigNumber are much slower than calculations with Number,
but they can be executed with an arbitrary precision. By using a higher
precision, it is less likely that round-off errors occur:

// round-off errors with numbers
math.add(0.1, 0.2)                                     // Number, 0.30000000000000004
math.divide(0.3, 0.2)                                  // Number, 1.4999999999999998

// no round-off errors with BigNumbers :)
math.add(math.bignumber(0.1), math.bignumber(0.2))     // BigNumber, 0.3
math.divide(math.bignumber(0.3), math.bignumber(0.2))  // BigNumber, 1.5


Limitations #

It’s important to realize that BigNumbers do not solve all problems related
to precision and round-off errors. Numbers with an infinite number of digits
cannot be represented with a regular number nor a BigNumber. Though a BigNumber
can store a much larger number of digits, the amount of digits remains limited
if only to keep calculations fast enough to remain practical.

const one = math.bignumber(1)
const three = math.bignumber(3)
const third = math.divide(one, three)
console.log(third.toString())
// outputs 0.3333333333333333333333333333333333333333333333333333333333333333

const ans = math.multiply(third, three)
console.log(ans.toString())
// outputs 0.9999999999999999999999999999999999999999999999999999999999999999
// this should be 1 again, but `third` is rounded to a limited number of digits 3


Conversion #

BigNumbers can be converted to numbers and vice versa using the functions
number and bignumber. When converting a BigNumber to a number, the high
precision of the BigNumber will be lost. When a BigNumber is too large to be represented
as Number, it will be initialized as Infinity.

// converting numbers and BigNumbers
const a = math.number(0.3)                         // number, 0.3
const b = math.bignumber(a)                        // BigNumber, 0.3
const c = math.number(b)                           // number, 0.3

// exceeding the maximum of a number
const d = math.bignumber('1.2e500')                // BigNumber, 1.2e+500
const e = math.number(d)                           // number, Infinity

// loosing precision when converting to number
const f = math.bignumber('0.2222222222222222222')  // BigNumber, 0.2222222222222222222
const g = math.number(f)                           // number,    0.2222222222222222\n\n\n\nBigNumbers #

For calculations with an arbitrary precision, math.js supports a BigNumber
datatype. BigNumber support is powered by
decimal.js.

Usage #

A BigNumber can be created using the function bignumber:

math.bignumber('2.3e+500') // BigNumber, 2.3e+500


Most functions can determine the type of output from the type of input:
a number as input will return a number as output, a BigNumber as input returns
a BigNumber as output. Functions which cannot determine the type of output
from the input (for example math.evaluate) use the default number type number,
which can be configured when instantiating math.js. To configure the use of
BigNumbers instead of numbers by default, configure math.js like:

math.config({
  number: 'BigNumber',      // Default type of number:
                            // 'number' (default), 'BigNumber', or 'Fraction'
  precision: 64,            // Number of significant digits for BigNumbers
  relTol: 1e-60,
  absTol: 1e-63
})

// use math
math.evaluate('0.1 + 0.2')  // BigNumber, 0.3


The default precision for BigNumber is 64 digits, and can be configured with
the option precision.

Note that we also change the configuration of relTol and absTol 
to be close to the precision limit of our BigNumbers. relTol and absTol are used for 
example in relational and rounding functions (equal, larger, smaller, 
round, floor, etc) to determine when a value is nearly equal, 
see Equality. If we would leave relTol and absTol  unchanged, 
having the default value of 1e-12 and 1e-15 respectively, we could get inaccurate and misleading 
results since we’re now working with a higher precision.

Support #

Most functions in math.js support BigNumbers, but not all of them.
For example the function random doesn’t support BigNumbers.

Round-off errors #

Calculations with BigNumber are much slower than calculations with Number,
but they can be executed with an arbitrary precision. By using a higher
precision, it is less likely that round-off errors occur:

// round-off errors with numbers
math.add(0.1, 0.2)                                     // Number, 0.30000000000000004
math.divide(0.3, 0.2)                                  // Number, 1.4999999999999998

// no round-off errors with BigNumbers :)
math.add(math.bignumber(0.1), math.bignumber(0.2))     // BigNumber, 0.3
math.divide(math.bignumber(0.3), math.bignumber(0.2))  // BigNumber, 1.5


Limitations #

It’s important to realize that BigNumbers do not solve all problems related
to precision and round-off errors. Numbers with an infinite number of digits
cannot be represented with a regular number nor a BigNumber. Though a BigNumber
can store a much larger number of digits, the amount of digits remains limited
if only to keep calculations fast enough to remain practical.

const one = math.bignumber(1)
const three = math.bignumber(3)
const third = math.divide(one, three)
console.log(third.toString())
// outputs 0.3333333333333333333333333333333333333333333333333333333333333333

const ans = math.multiply(third, three)
console.log(ans.toString())
// outputs 0.9999999999999999999999999999999999999999999999999999999999999999
// this should be 1 again, but `third` is rounded to a limited number of digits 3


Conversion #

BigNumbers can be converted to numbers and vice versa using the functions
number and bignumber. When converting a BigNumber to a number, the high
precision of the BigNumber will be lost. When a BigNumber is too large to be represented
as Number, it will be initialized as Infinity.

// converting numbers and BigNumbers
const a = math.number(0.3)                         // number, 0.3
const b = math.bignumber(a)                        // BigNumber, 0.3
const c = math.number(b)                           // number, 0.3

// exceeding the maximum of a number
const d = math.bignumber('1.2e500')                // BigNumber, 1.2e+500
const e = math.number(d)                           // number, Infinity

// loosing precision when converting to number
const f = math.bignumber('0.2222222222222222222')  // BigNumber, 0.2222222222222222222
const g = math.number(f)                           // number,    0.2222222222222222\n\n\n\nBigNumbers #

For calculations with an arbitrary precision, math.js supports a BigNumber
datatype. BigNumber support is powered by
decimal.js.

Usage #

A BigNumber can be created using the function bignumber:

math.bignumber('2.3e+500') // BigNumber, 2.3e+500


Most functions can determine the type of output from the type of input:
a number as input will return a number as output, a BigNumber as input returns
a BigNumber as output. Functions which cannot determine the type of output
from the input (for example math.evaluate) use the default number type number,
which can be configured when instantiating math.js. To configure the use of
BigNumbers instead of numbers by default, configure math.js like:

math.config({
  number: 'BigNumber',      // Default type of number:
                            // 'number' (default), 'BigNumber', or 'Fraction'
  precision: 64,            // Number of significant digits for BigNumbers
  relTol: 1e-60,
  absTol: 1e-63
})

// use math
math.evaluate('0.1 + 0.2')  // BigNumber, 0.3


The default precision for BigNumber is 64 digits, and can be configured with
the option precision.

Note that we also change the configuration of relTol and absTol 
to be close to the precision limit of our BigNumbers. relTol and absTol are used for 
example in relational and rounding functions (equal, larger, smaller, 
round, floor, etc) to determine when a value is nearly equal, 
see Equality. If we would leave relTol and absTol  unchanged, 
having the default value of 1e-12 and 1e-15 respectively, we could get inaccurate and misleading 
results since we’re now working with a higher precision.

Support #

Most functions in math.js support BigNumbers, but not all of them.
For example the function random doesn’t support BigNumbers.

Round-off errors #

Calculations with BigNumber are much slower than calculations with Number,
but they can be executed with an arbitrary precision. By using a higher
precision, it is less likely that round-off errors occur:

// round-off errors with numbers
math.add(0.1, 0.2)                                     // Number, 0.30000000000000004
math.divide(0.3, 0.2)                                  // Number, 1.4999999999999998

// no round-off errors with BigNumbers :)
math.add(math.bignumber(0.1), math.bignumber(0.2))     // BigNumber, 0.3
math.divide(math.bignumber(0.3), math.bignumber(0.2))  // BigNumber, 1.5


Limitations #

It’s important to realize that BigNumbers do not solve all problems related
to precision and round-off errors. Numbers with an infinite number of digits
cannot be represented with a regular number nor a BigNumber. Though a BigNumber
can store a much larger number of digits, the amount of digits remains limited
if only to keep calculations fast enough to remain practical.

const one = math.bignumber(1)
const three = math.bignumber(3)
const third = math.divide(one, three)
console.log(third.toString())
// outputs 0.3333333333333333333333333333333333333333333333333333333333333333

const ans = math.multiply(third, three)
console.log(ans.toString())
// outputs 0.9999999999999999999999999999999999999999999999999999999999999999
// this should be 1 again, but `third` is rounded to a limited number of digits 3


Conversion #

BigNumbers can be converted to numbers and vice versa using the functions
number and bignumber. When converting a BigNumber to a number, the high
precision of the BigNumber will be lost. When a BigNumber is too large to be represented
as Number, it will be initialized as Infinity.

// converting numbers and BigNumbers
const a = math.number(0.3)                         // number, 0.3
const b = math.bignumber(a)                        // BigNumber, 0.3
const c = math.number(b)                           // number, 0.3

// exceeding the maximum of a number
const d = math.bignumber('1.2e500')                // BigNumber, 1.2e+500
const e = math.number(d)                           // number, Infinity

// loosing precision when converting to number
const f = math.bignumber('0.2222222222222222222')  // BigNumber, 0.2222222222222222222
const g = math.number(f)                           // number,    0.2222222222222222\n\n\n\nBigNumbers #

For calculations with an arbitrary precision, math.js supports a BigNumber
datatype. BigNumber support is powered by
decimal.js.

Usage #

A BigNumber can be created using the function bignumber:

math.bignumber('2.3e+500') // BigNumber, 2.3e+500


Most functions can determine the type of output from the type of input:
a number as input will return a number as output, a BigNumber as input returns
a BigNumber as output. Functions which cannot determine the type of output
from the input (for example math.evaluate) use the default number type number,
which can be configured when instantiating math.js. To configure the use of
BigNumbers instead of numbers by default, configure math.js like:

math.config({
  number: 'BigNumber',      // Default type of number:
                            // 'number' (default), 'BigNumber', or 'Fraction'
  precision: 64,            // Number of significant digits for BigNumbers
  relTol: 1e-60,
  absTol: 1e-63
})

// use math
math.evaluate('0.1 + 0.2')  // BigNumber, 0.3


The default precision for BigNumber is 64 digits, and can be configured with
the option precision.

Note that we also change the configuration of relTol and absTol 
to be close to the precision limit of our BigNumbers. relTol and absTol are used for 
example in relational and rounding functions (equal, larger, smaller, 
round, floor, etc) to determine when a value is nearly equal, 
see Equality. If we would leave relTol and absTol  unchanged, 
having the default value of 1e-12 and 1e-15 respectively, we could get inaccurate and misleading 
results since we’re now working with a higher precision.

Support #

Most functions in math.js support BigNumbers, but not all of them.
For example the function random doesn’t support BigNumbers.

Round-off errors #

Calculations with BigNumber are much slower than calculations with Number,
but they can be executed with an arbitrary precision. By using a higher
precision, it is less likely that round-off errors occur:

// round-off errors with numbers
math.add(0.1, 0.2)                                     // Number, 0.30000000000000004
math.divide(0.3, 0.2)                                  // Number, 1.4999999999999998

// no round-off errors with BigNumbers :)
math.add(math.bignumber(0.1), math.bignumber(0.2))     // BigNumber, 0.3
math.divide(math.bignumber(0.3), math.bignumber(0.2))  // BigNumber, 1.5


Limitations #

It’s important to realize that BigNumbers do not solve all problems related
to precision and round-off errors. Numbers with an infinite number of digits
cannot be represented with a regular number nor a BigNumber. Though a BigNumber
can store a much larger number of digits, the amount of digits remains limited
if only to keep calculations fast enough to remain practical.

const one = math.bignumber(1)
const three = math.bignumber(3)
const third = math.divide(one, three)
console.log(third.toString())
// outputs 0.3333333333333333333333333333333333333333333333333333333333333333

const ans = math.multiply(third, three)
console.log(ans.toString())
// outputs 0.9999999999999999999999999999999999999999999999999999999999999999
// this should be 1 again, but `third` is rounded to a limited number of digits 3


Conversion #

BigNumbers can be converted to numbers and vice versa using the functions
number and bignumber. When converting a BigNumber to a number, the high
precision of the BigNumber will be lost. When a BigNumber is too large to be represented
as Number, it will be initialized as Infinity.

// converting numbers and BigNumbers
const a = math.number(0.3)                         // number, 0.3
const b = math.bignumber(a)                        // BigNumber, 0.3
const c = math.number(b)                           // number, 0.3

// exceeding the maximum of a number
const d = math.bignumber('1.2e500')                // BigNumber, 1.2e+500
const e = math.number(d)                           // number, Infinity

// loosing precision when converting to number
const f = math.bignumber('0.2222222222222222222')  // BigNumber, 0.2222222222222222222
const g = math.number(f)                           // number,    0.2222222222222222\n\n\n\nBigInts #

For calculations with large integer numbers, math.js supports the built-in bigint data type.

Usage #

A bigint can be created either by adding the suffix n to a number, using the BigInt constructor function, or using the util function math.bigint:

42n
BigInt('42')
math.bigint('42')


Most functions can determine the type of output from the type of input:
a number as input will return a number as output, a bigint as input returns
a bigint as output. Functions which cannot determine the type of output
from the input (for example math.evaluate) use the default number type number,
which can be configured when instantiating math.js. To configure the use of
bigint instead of numbers by default, configure math.js like:

math.config({
  number: 'bigint'
})

// use math
math.evaluate('70000000000000000123')  // bigint 70000000000000000123n


Support #

All basic arithmetic functions in math.js support bigint. Since bigint can only hold integer values, it is not applicable to for example trigonometric functions. When using a bigint in a function that does not support it, like sqrt, it will convert the bigint into a regular number and then execute the function:

math.sin(2n) // number 0.9092974268256817


Conversion #

There are utility functions to convert a bigint into a number or BigNumber:

// convert a number to bigint or BigNumber
math.bigint(42)                    // bigint, 42n
math.bignumber(42)                 // BigNumber, 42

// convert a bigint to a number or BigNumber
math.number(42n)                   // number, 42
math.bignumber(42n)                // BigNumber, 42

// losing digits when converting to number
math.number(70000000000000000123n) // number, 7000000000000000000\n\n\n\nBigInts #

For calculations with large integer numbers, math.js supports the built-in bigint data type.

Usage #

A bigint can be created either by adding the suffix n to a number, using the BigInt constructor function, or using the util function math.bigint:

42n
BigInt('42')
math.bigint('42')


Most functions can determine the type of output from the type of input:
a number as input will return a number as output, a bigint as input returns
a bigint as output. Functions which cannot determine the type of output
from the input (for example math.evaluate) use the default number type number,
which can be configured when instantiating math.js. To configure the use of
bigint instead of numbers by default, configure math.js like:

math.config({
  number: 'bigint'
})

// use math
math.evaluate('70000000000000000123')  // bigint 70000000000000000123n


Support #

All basic arithmetic functions in math.js support bigint. Since bigint can only hold integer values, it is not applicable to for example trigonometric functions. When using a bigint in a function that does not support it, like sqrt, it will convert the bigint into a regular number and then execute the function:

math.sin(2n) // number 0.9092974268256817


Conversion #

There are utility functions to convert a bigint into a number or BigNumber:

// convert a number to bigint or BigNumber
math.bigint(42)                    // bigint, 42n
math.bignumber(42)                 // BigNumber, 42

// convert a bigint to a number or BigNumber
math.number(42n)                   // number, 42
math.bignumber(42n)                // BigNumber, 42

// losing digits when converting to number
math.number(70000000000000000123n) // number, 7000000000000000000\n\n\n\nBigInts #

For calculations with large integer numbers, math.js supports the built-in bigint data type.

Usage #

A bigint can be created either by adding the suffix n to a number, using the BigInt constructor function, or using the util function math.bigint:

42n
BigInt('42')
math.bigint('42')


Most functions can determine the type of output from the type of input:
a number as input will return a number as output, a bigint as input returns
a bigint as output. Functions which cannot determine the type of output
from the input (for example math.evaluate) use the default number type number,
which can be configured when instantiating math.js. To configure the use of
bigint instead of numbers by default, configure math.js like:

math.config({
  number: 'bigint'
})

// use math
math.evaluate('70000000000000000123')  // bigint 70000000000000000123n


Support #

All basic arithmetic functions in math.js support bigint. Since bigint can only hold integer values, it is not applicable to for example trigonometric functions. When using a bigint in a function that does not support it, like sqrt, it will convert the bigint into a regular number and then execute the function:

math.sin(2n) // number 0.9092974268256817


Conversion #

There are utility functions to convert a bigint into a number or BigNumber:

// convert a number to bigint or BigNumber
math.bigint(42)                    // bigint, 42n
math.bignumber(42)                 // BigNumber, 42

// convert a bigint to a number or BigNumber
math.number(42n)                   // number, 42
math.bignumber(42n)                // BigNumber, 42

// losing digits when converting to number
math.number(70000000000000000123n) // number, 7000000000000000000\n\n\n\nBigInts #

For calculations with large integer numbers, math.js supports the built-in bigint data type.

Usage #

A bigint can be created either by adding the suffix n to a number, using the BigInt constructor function, or using the util function math.bigint:

42n
BigInt('42')
math.bigint('42')


Most functions can determine the type of output from the type of input:
a number as input will return a number as output, a bigint as input returns
a bigint as output. Functions which cannot determine the type of output
from the input (for example math.evaluate) use the default number type number,
which can be configured when instantiating math.js. To configure the use of
bigint instead of numbers by default, configure math.js like:

math.config({
  number: 'bigint'
})

// use math
math.evaluate('70000000000000000123')  // bigint 70000000000000000123n


Support #

All basic arithmetic functions in math.js support bigint. Since bigint can only hold integer values, it is not applicable to for example trigonometric functions. When using a bigint in a function that does not support it, like sqrt, it will convert the bigint into a regular number and then execute the function:

math.sin(2n) // number 0.9092974268256817


Conversion #

There are utility functions to convert a bigint into a number or BigNumber:

// convert a number to bigint or BigNumber
math.bigint(42)                    // bigint, 42n
math.bignumber(42)                 // BigNumber, 42

// convert a bigint to a number or BigNumber
math.number(42n)                   // number, 42
math.bignumber(42n)                // BigNumber, 42

// losing digits when converting to number
math.number(70000000000000000123n) // number, 7000000000000000000\n\n\n\nFractions #

For calculations with fractions, math.js supports a Fraction data type. 
Fraction support is powered by fraction.js.
Unlike numbers and BigNumbers, fractions can 
store numbers with infinitely repeating decimals, for example 1/3 = 0.3333333..., 
which can be represented as 0.(3), or 2/7 which can be represented as 0.(285714).

Usage #

A Fraction can be created using the function fraction:

math.fraction('1/3')   // Fraction, 1/3
math.fraction(2, 3)    // Fraction, 2/3
math.fraction('0.(3)') // Fraction, 1/3


And can be used in functions like add and multiply like:

math.add(math.fraction('1/3'), math.fraction('1/6'))      // Fraction, 1/2
math.multiply(math.fraction('1/4'), math.fraction('1/2')) // Fraction, 1/8


Note that not all functions support fractions. For example trigonometric 
functions doesn’t support fractions. When not supported, the functions
will convert the input to numbers and return a number as result.

Most functions will determine the type of output from the type of input:
a number as input will return a number as output, a Fraction as input returns
a Fraction as output. Functions which cannot determine the type of output
from the input (for example math.evaluate) use the default number type number,
which can be configured when instantiating math.js. To configure the use of
fractions instead of numbers by default, configure math.js like:

// Configure the default type of number: 'number' (default), 'BigNumber', or 'Fraction'
math.config({
  number: 'Fraction'
})

// use the expression parser
math.evaluate('0.32 + 0.08') // Fraction, 2/5


Support #

The following functions support fractions:


  Arithmetic functions: abs, add, ceil, cube, divide, dotDivide, dotMultiply, fix, floor, gcd, mod, multiply, round, sign, square, subtract, unaryMinus, unaryPlus.
  Construction functions: fraction.
  Relational functions: compare, deepEqual, equal, larger, largerEq, smaller, smallerEq, unequal.
  Utils functions: format.


Conversion #

Fractions can be converted to numbers and vice versa using the functions
number and fraction. When converting a Fraction to a number, precision
may be lost when the value cannot represented in 16 digits.

// converting numbers and fractions
const a = math.number(0.3)                       // number, 0.3
const b = math.fraction(a)                       // Fraction, 3/10
const c = math.number(b)                         // number, 0.3

// loosing precision when converting to number: a fraction can represent
// a number with an infinite number of repeating decimals, a number just
// stores about 16 digits and cuts consecutive digits.
const d = math.fraction('2/5')                   // Fraction, 2/5
const e = math.number(d)                         // number, 0.4\n\n\n\nFractions #

For calculations with fractions, math.js supports a Fraction data type. 
Fraction support is powered by fraction.js.
Unlike numbers and BigNumbers, fractions can 
store numbers with infinitely repeating decimals, for example 1/3 = 0.3333333..., 
which can be represented as 0.(3), or 2/7 which can be represented as 0.(285714).

Usage #

A Fraction can be created using the function fraction:

math.fraction('1/3')   // Fraction, 1/3
math.fraction(2, 3)    // Fraction, 2/3
math.fraction('0.(3)') // Fraction, 1/3


And can be used in functions like add and multiply like:

math.add(math.fraction('1/3'), math.fraction('1/6'))      // Fraction, 1/2
math.multiply(math.fraction('1/4'), math.fraction('1/2')) // Fraction, 1/8


Note that not all functions support fractions. For example trigonometric 
functions doesn’t support fractions. When not supported, the functions
will convert the input to numbers and return a number as result.

Most functions will determine the type of output from the type of input:
a number as input will return a number as output, a Fraction as input returns
a Fraction as output. Functions which cannot determine the type of output
from the input (for example math.evaluate) use the default number type number,
which can be configured when instantiating math.js. To configure the use of
fractions instead of numbers by default, configure math.js like:

// Configure the default type of number: 'number' (default), 'BigNumber', or 'Fraction'
math.config({
  number: 'Fraction'
})

// use the expression parser
math.evaluate('0.32 + 0.08') // Fraction, 2/5


Support #

The following functions support fractions:


  Arithmetic functions: abs, add, ceil, cube, divide, dotDivide, dotMultiply, fix, floor, gcd, mod, multiply, round, sign, square, subtract, unaryMinus, unaryPlus.
  Construction functions: fraction.
  Relational functions: compare, deepEqual, equal, larger, largerEq, smaller, smallerEq, unequal.
  Utils functions: format.


Conversion #

Fractions can be converted to numbers and vice versa using the functions
number and fraction. When converting a Fraction to a number, precision
may be lost when the value cannot represented in 16 digits.

// converting numbers and fractions
const a = math.number(0.3)                       // number, 0.3
const b = math.fraction(a)                       // Fraction, 3/10
const c = math.number(b)                         // number, 0.3

// loosing precision when converting to number: a fraction can represent
// a number with an infinite number of repeating decimals, a number just
// stores about 16 digits and cuts consecutive digits.
const d = math.fraction('2/5')                   // Fraction, 2/5
const e = math.number(d)                         // number, 0.4\n\n\n\nFractions #

For calculations with fractions, math.js supports a Fraction data type. 
Fraction support is powered by fraction.js.
Unlike numbers and BigNumbers, fractions can 
store numbers with infinitely repeating decimals, for example 1/3 = 0.3333333..., 
which can be represented as 0.(3), or 2/7 which can be represented as 0.(285714).

Usage #

A Fraction can be created using the function fraction:

math.fraction('1/3')   // Fraction, 1/3
math.fraction(2, 3)    // Fraction, 2/3
math.fraction('0.(3)') // Fraction, 1/3


And can be used in functions like add and multiply like:

math.add(math.fraction('1/3'), math.fraction('1/6'))      // Fraction, 1/2
math.multiply(math.fraction('1/4'), math.fraction('1/2')) // Fraction, 1/8


Note that not all functions support fractions. For example trigonometric 
functions doesn’t support fractions. When not supported, the functions
will convert the input to numbers and return a number as result.

Most functions will determine the type of output from the type of input:
a number as input will return a number as output, a Fraction as input returns
a Fraction as output. Functions which cannot determine the type of output
from the input (for example math.evaluate) use the default number type number,
which can be configured when instantiating math.js. To configure the use of
fractions instead of numbers by default, configure math.js like:

// Configure the default type of number: 'number' (default), 'BigNumber', or 'Fraction'
math.config({
  number: 'Fraction'
})

// use the expression parser
math.evaluate('0.32 + 0.08') // Fraction, 2/5


Support #

The following functions support fractions:


  Arithmetic functions: abs, add, ceil, cube, divide, dotDivide, dotMultiply, fix, floor, gcd, mod, multiply, round, sign, square, subtract, unaryMinus, unaryPlus.
  Construction functions: fraction.
  Relational functions: compare, deepEqual, equal, larger, largerEq, smaller, smallerEq, unequal.
  Utils functions: format.


Conversion #

Fractions can be converted to numbers and vice versa using the functions
number and fraction. When converting a Fraction to a number, precision
may be lost when the value cannot represented in 16 digits.

// converting numbers and fractions
const a = math.number(0.3)                       // number, 0.3
const b = math.fraction(a)                       // Fraction, 3/10
const c = math.number(b)                         // number, 0.3

// loosing precision when converting to number: a fraction can represent
// a number with an infinite number of repeating decimals, a number just
// stores about 16 digits and cuts consecutive digits.
const d = math.fraction('2/5')                   // Fraction, 2/5
const e = math.number(d)                         // number, 0.4\n\n\n\nFractions #

For calculations with fractions, math.js supports a Fraction data type. 
Fraction support is powered by fraction.js.
Unlike numbers and BigNumbers, fractions can 
store numbers with infinitely repeating decimals, for example 1/3 = 0.3333333..., 
which can be represented as 0.(3), or 2/7 which can be represented as 0.(285714).

Usage #

A Fraction can be created using the function fraction:

math.fraction('1/3')   // Fraction, 1/3
math.fraction(2, 3)    // Fraction, 2/3
math.fraction('0.(3)') // Fraction, 1/3


And can be used in functions like add and multiply like:

math.add(math.fraction('1/3'), math.fraction('1/6'))      // Fraction, 1/2
math.multiply(math.fraction('1/4'), math.fraction('1/2')) // Fraction, 1/8


Note that not all functions support fractions. For example trigonometric 
functions doesn’t support fractions. When not supported, the functions
will convert the input to numbers and return a number as result.

Most functions will determine the type of output from the type of input:
a number as input will return a number as output, a Fraction as input returns
a Fraction as output. Functions which cannot determine the type of output
from the input (for example math.evaluate) use the default number type number,
which can be configured when instantiating math.js. To configure the use of
fractions instead of numbers by default, configure math.js like:

// Configure the default type of number: 'number' (default), 'BigNumber', or 'Fraction'
math.config({
  number: 'Fraction'
})

// use the expression parser
math.evaluate('0.32 + 0.08') // Fraction, 2/5


Support #

The following functions support fractions:


  Arithmetic functions: abs, add, ceil, cube, divide, dotDivide, dotMultiply, fix, floor, gcd, mod, multiply, round, sign, square, subtract, unaryMinus, unaryPlus.
  Construction functions: fraction.
  Relational functions: compare, deepEqual, equal, larger, largerEq, smaller, smallerEq, unequal.
  Utils functions: format.


Conversion #

Fractions can be converted to numbers and vice versa using the functions
number and fraction. When converting a Fraction to a number, precision
may be lost when the value cannot represented in 16 digits.

// converting numbers and fractions
const a = math.number(0.3)                       // number, 0.3
const b = math.fraction(a)                       // Fraction, 3/10
const c = math.number(b)                         // number, 0.3

// loosing precision when converting to number: a fraction can represent
// a number with an infinite number of repeating decimals, a number just
// stores about 16 digits and cuts consecutive digits.
const d = math.fraction('2/5')                   // Fraction, 2/5
const e = math.number(d)                         // number, 0.4\n\n\n\nComplex Numbers #

Math.js supports the creation, manipulation, and calculations with complex numbers.
Support of complex numbers is powered by the library complex.js.

In mathematics, a complex number is an expression of the form a + bi,
where a and b are real numbers and i represents the imaginary number
defined as i^2 = -1. (In other words, i is the square root of -1.)
The real number a is called the real part of the complex number,
and the real number b is the imaginary part. For example, 3 + 2i is a
complex number, having real part 3 and imaginary part 2.
Complex numbers are often used in applied mathematics, control theory,
signal analysis, fluid dynamics and other fields.

Usage #

A complex number is created using the function math.complex. This function
accepts:


  two numbers representing the real and imaginary part of the value,
  a single string containing a complex value in the form a + bi where a
and b respectively represent the real and imaginary part of the complex number.
  an object with either properties re and im for the real and imaginary
part of the value, or two properties r and phi containing the polar
coordinates of a complex value.
The function returns a Complex object.


Syntax:

math.complex(re: number) : Complex
math.complex(re: number, im: number) : Complex
math.complex(complex: Complex) : Complex
math.complex({re: Number, im: Number}) : Complex
math.complex({r: number, phi: number}) : Complex
math.complex({abs: number, arg: number}) : Complex
math.complex(str: string) : Complex


Examples:

const a = math.complex(2, 3)     // Complex 2 + 3i
a.re                             // Number 2
a.im                             // Number 3

const b = math.complex('4 - 2i') // Complex 4 - 2i
b.re = 5                         // Number 5
b                                // Complex 5 - 2i


Calculations #

Most functions of math.js support complex numbers. Complex and real numbers
can be used together.

const a = math.complex(2, 3)     // Complex 2 + 3i
const b = math.complex('4 - 2i') // Complex 4 - 2i

math.re(a)                       // Number 2
math.im(a)                       // Number 3
math.conj(a)                     // Complex 2 - 3i

math.add(a, b)                   // Complex 6 + i
math.multiply(a, 2)              // Complex 4 + 6i
math.sqrt(-4)                    // Complex 2i


API #
A Complex object created by math.complex contains the following properties and functions:

complex.re #

A number containing the real part of the complex number. Can be read and replaced.

complex.im #

A number containing the imaginary part of the complex number. Can be read and replaced.

complex.clone() #

Create a clone of the complex number.

complex.equals(other) #

Test whether a complex number equals another complex value.

Two complex numbers are equal when both their real and imaginary parts are
  equal.

complex.neg() #

Returns a complex number with a real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.conjugate() #

Returns a complex number with an equal real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.inverse() #

Returns a complex number that is inverse of the current complex number.

complex.toVector() #

Get the vector representation of the current complex number. Returns an array of size 2.

complex.toJSON() #

Returns a JSON representation of the complex number, with signature
  {mathjs: 'Complex', re: number, im: number}.
  Used when serializing a complex number, see Serialization.

complex.toPolar() #

Get the polar coordinates of the complex number, returns
  an object with properties r and phi.

complex.toString() #

Returns a string representation of the complex number, formatted
  as a + bi where a is the real part and b the imaginary part.

complex.format([precision: number]) #

Get a string representation of the complex number,
  formatted as a + bi where a is the real part and b the imaginary part.
  If precision is defined, the units value will be rounded to the provided
  number of digits.

Static methods #
The following static methods can be accessed using math.Complex

Complex.fromJSON(json) #

Revive a complex number from a JSON object. Accepts
  An object {mathjs: 'Complex', re: number, im: number}, where the property
  mathjs is optional.
  Used when deserializing a complex number, see Serialization.

Complex.fromPolar(r: number, phi: number) #

Create a complex number from polar coordinates.

Complex.compare(a: Complex, b: Complex) #

Returns the comparision result of two complex number:


  Returns 1 when the real part of a is larger than the real part of b
  Returns -1 when the real part of a is smaller than the real part of b
  Returns 1 when the real parts are equal
and the imaginary part of a is larger than the imaginary part of b
  Returns -1 when the real parts are equal
and the imaginary part of a is smaller than the imaginary part of b
  Returns 0 when both real and imaginary parts are equal.


Example:
const a = math.complex(2, 3)   // Complex 2 + 3i
const b = math.complex(2, 1)   // Complex 2 + 1i
math.Complex.compare(a,b) // returns 1

//create from json 
const c = math.Complex.fromJSON({mathjs: 'Complex', re: 4, im: 3})  // Complex 4 + 3i\n\n\n\nComplex Numbers #

Math.js supports the creation, manipulation, and calculations with complex numbers.
Support of complex numbers is powered by the library complex.js.

In mathematics, a complex number is an expression of the form a + bi,
where a and b are real numbers and i represents the imaginary number
defined as i^2 = -1. (In other words, i is the square root of -1.)
The real number a is called the real part of the complex number,
and the real number b is the imaginary part. For example, 3 + 2i is a
complex number, having real part 3 and imaginary part 2.
Complex numbers are often used in applied mathematics, control theory,
signal analysis, fluid dynamics and other fields.

Usage #

A complex number is created using the function math.complex. This function
accepts:


  two numbers representing the real and imaginary part of the value,
  a single string containing a complex value in the form a + bi where a
and b respectively represent the real and imaginary part of the complex number.
  an object with either properties re and im for the real and imaginary
part of the value, or two properties r and phi containing the polar
coordinates of a complex value.
The function returns a Complex object.


Syntax:

math.complex(re: number) : Complex
math.complex(re: number, im: number) : Complex
math.complex(complex: Complex) : Complex
math.complex({re: Number, im: Number}) : Complex
math.complex({r: number, phi: number}) : Complex
math.complex({abs: number, arg: number}) : Complex
math.complex(str: string) : Complex


Examples:

const a = math.complex(2, 3)     // Complex 2 + 3i
a.re                             // Number 2
a.im                             // Number 3

const b = math.complex('4 - 2i') // Complex 4 - 2i
b.re = 5                         // Number 5
b                                // Complex 5 - 2i


Calculations #

Most functions of math.js support complex numbers. Complex and real numbers
can be used together.

const a = math.complex(2, 3)     // Complex 2 + 3i
const b = math.complex('4 - 2i') // Complex 4 - 2i

math.re(a)                       // Number 2
math.im(a)                       // Number 3
math.conj(a)                     // Complex 2 - 3i

math.add(a, b)                   // Complex 6 + i
math.multiply(a, 2)              // Complex 4 + 6i
math.sqrt(-4)                    // Complex 2i


API #
A Complex object created by math.complex contains the following properties and functions:

complex.re #

A number containing the real part of the complex number. Can be read and replaced.

complex.im #

A number containing the imaginary part of the complex number. Can be read and replaced.

complex.clone() #

Create a clone of the complex number.

complex.equals(other) #

Test whether a complex number equals another complex value.

Two complex numbers are equal when both their real and imaginary parts are
  equal.

complex.neg() #

Returns a complex number with a real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.conjugate() #

Returns a complex number with an equal real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.inverse() #

Returns a complex number that is inverse of the current complex number.

complex.toVector() #

Get the vector representation of the current complex number. Returns an array of size 2.

complex.toJSON() #

Returns a JSON representation of the complex number, with signature
  {mathjs: 'Complex', re: number, im: number}.
  Used when serializing a complex number, see Serialization.

complex.toPolar() #

Get the polar coordinates of the complex number, returns
  an object with properties r and phi.

complex.toString() #

Returns a string representation of the complex number, formatted
  as a + bi where a is the real part and b the imaginary part.

complex.format([precision: number]) #

Get a string representation of the complex number,
  formatted as a + bi where a is the real part and b the imaginary part.
  If precision is defined, the units value will be rounded to the provided
  number of digits.

Static methods #
The following static methods can be accessed using math.Complex

Complex.fromJSON(json) #

Revive a complex number from a JSON object. Accepts
  An object {mathjs: 'Complex', re: number, im: number}, where the property
  mathjs is optional.
  Used when deserializing a complex number, see Serialization.

Complex.fromPolar(r: number, phi: number) #

Create a complex number from polar coordinates.

Complex.compare(a: Complex, b: Complex) #

Returns the comparision result of two complex number:


  Returns 1 when the real part of a is larger than the real part of b
  Returns -1 when the real part of a is smaller than the real part of b
  Returns 1 when the real parts are equal
and the imaginary part of a is larger than the imaginary part of b
  Returns -1 when the real parts are equal
and the imaginary part of a is smaller than the imaginary part of b
  Returns 0 when both real and imaginary parts are equal.


Example:
const a = math.complex(2, 3)   // Complex 2 + 3i
const b = math.complex(2, 1)   // Complex 2 + 1i
math.Complex.compare(a,b) // returns 1

//create from json 
const c = math.Complex.fromJSON({mathjs: 'Complex', re: 4, im: 3})  // Complex 4 + 3i\n\n\n\nComplex Numbers #

Math.js supports the creation, manipulation, and calculations with complex numbers.
Support of complex numbers is powered by the library complex.js.

In mathematics, a complex number is an expression of the form a + bi,
where a and b are real numbers and i represents the imaginary number
defined as i^2 = -1. (In other words, i is the square root of -1.)
The real number a is called the real part of the complex number,
and the real number b is the imaginary part. For example, 3 + 2i is a
complex number, having real part 3 and imaginary part 2.
Complex numbers are often used in applied mathematics, control theory,
signal analysis, fluid dynamics and other fields.

Usage #

A complex number is created using the function math.complex. This function
accepts:


  two numbers representing the real and imaginary part of the value,
  a single string containing a complex value in the form a + bi where a
and b respectively represent the real and imaginary part of the complex number.
  an object with either properties re and im for the real and imaginary
part of the value, or two properties r and phi containing the polar
coordinates of a complex value.
The function returns a Complex object.


Syntax:

math.complex(re: number) : Complex
math.complex(re: number, im: number) : Complex
math.complex(complex: Complex) : Complex
math.complex({re: Number, im: Number}) : Complex
math.complex({r: number, phi: number}) : Complex
math.complex({abs: number, arg: number}) : Complex
math.complex(str: string) : Complex


Examples:

const a = math.complex(2, 3)     // Complex 2 + 3i
a.re                             // Number 2
a.im                             // Number 3

const b = math.complex('4 - 2i') // Complex 4 - 2i
b.re = 5                         // Number 5
b                                // Complex 5 - 2i


Calculations #

Most functions of math.js support complex numbers. Complex and real numbers
can be used together.

const a = math.complex(2, 3)     // Complex 2 + 3i
const b = math.complex('4 - 2i') // Complex 4 - 2i

math.re(a)                       // Number 2
math.im(a)                       // Number 3
math.conj(a)                     // Complex 2 - 3i

math.add(a, b)                   // Complex 6 + i
math.multiply(a, 2)              // Complex 4 + 6i
math.sqrt(-4)                    // Complex 2i


API #
A Complex object created by math.complex contains the following properties and functions:

complex.re #

A number containing the real part of the complex number. Can be read and replaced.

complex.im #

A number containing the imaginary part of the complex number. Can be read and replaced.

complex.clone() #

Create a clone of the complex number.

complex.equals(other) #

Test whether a complex number equals another complex value.

Two complex numbers are equal when both their real and imaginary parts are
  equal.

complex.neg() #

Returns a complex number with a real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.conjugate() #

Returns a complex number with an equal real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.inverse() #

Returns a complex number that is inverse of the current complex number.

complex.toVector() #

Get the vector representation of the current complex number. Returns an array of size 2.

complex.toJSON() #

Returns a JSON representation of the complex number, with signature
  {mathjs: 'Complex', re: number, im: number}.
  Used when serializing a complex number, see Serialization.

complex.toPolar() #

Get the polar coordinates of the complex number, returns
  an object with properties r and phi.

complex.toString() #

Returns a string representation of the complex number, formatted
  as a + bi where a is the real part and b the imaginary part.

complex.format([precision: number]) #

Get a string representation of the complex number,
  formatted as a + bi where a is the real part and b the imaginary part.
  If precision is defined, the units value will be rounded to the provided
  number of digits.

Static methods #
The following static methods can be accessed using math.Complex

Complex.fromJSON(json) #

Revive a complex number from a JSON object. Accepts
  An object {mathjs: 'Complex', re: number, im: number}, where the property
  mathjs is optional.
  Used when deserializing a complex number, see Serialization.

Complex.fromPolar(r: number, phi: number) #

Create a complex number from polar coordinates.

Complex.compare(a: Complex, b: Complex) #

Returns the comparision result of two complex number:


  Returns 1 when the real part of a is larger than the real part of b
  Returns -1 when the real part of a is smaller than the real part of b
  Returns 1 when the real parts are equal
and the imaginary part of a is larger than the imaginary part of b
  Returns -1 when the real parts are equal
and the imaginary part of a is smaller than the imaginary part of b
  Returns 0 when both real and imaginary parts are equal.


Example:
const a = math.complex(2, 3)   // Complex 2 + 3i
const b = math.complex(2, 1)   // Complex 2 + 1i
math.Complex.compare(a,b) // returns 1

//create from json 
const c = math.Complex.fromJSON({mathjs: 'Complex', re: 4, im: 3})  // Complex 4 + 3i\n\n\n\nComplex Numbers #

Math.js supports the creation, manipulation, and calculations with complex numbers.
Support of complex numbers is powered by the library complex.js.

In mathematics, a complex number is an expression of the form a + bi,
where a and b are real numbers and i represents the imaginary number
defined as i^2 = -1. (In other words, i is the square root of -1.)
The real number a is called the real part of the complex number,
and the real number b is the imaginary part. For example, 3 + 2i is a
complex number, having real part 3 and imaginary part 2.
Complex numbers are often used in applied mathematics, control theory,
signal analysis, fluid dynamics and other fields.

Usage #

A complex number is created using the function math.complex. This function
accepts:


  two numbers representing the real and imaginary part of the value,
  a single string containing a complex value in the form a + bi where a
and b respectively represent the real and imaginary part of the complex number.
  an object with either properties re and im for the real and imaginary
part of the value, or two properties r and phi containing the polar
coordinates of a complex value.
The function returns a Complex object.


Syntax:

math.complex(re: number) : Complex
math.complex(re: number, im: number) : Complex
math.complex(complex: Complex) : Complex
math.complex({re: Number, im: Number}) : Complex
math.complex({r: number, phi: number}) : Complex
math.complex({abs: number, arg: number}) : Complex
math.complex(str: string) : Complex


Examples:

const a = math.complex(2, 3)     // Complex 2 + 3i
a.re                             // Number 2
a.im                             // Number 3

const b = math.complex('4 - 2i') // Complex 4 - 2i
b.re = 5                         // Number 5
b                                // Complex 5 - 2i


Calculations #

Most functions of math.js support complex numbers. Complex and real numbers
can be used together.

const a = math.complex(2, 3)     // Complex 2 + 3i
const b = math.complex('4 - 2i') // Complex 4 - 2i

math.re(a)                       // Number 2
math.im(a)                       // Number 3
math.conj(a)                     // Complex 2 - 3i

math.add(a, b)                   // Complex 6 + i
math.multiply(a, 2)              // Complex 4 + 6i
math.sqrt(-4)                    // Complex 2i


API #
A Complex object created by math.complex contains the following properties and functions:

complex.re #

A number containing the real part of the complex number. Can be read and replaced.

complex.im #

A number containing the imaginary part of the complex number. Can be read and replaced.

complex.clone() #

Create a clone of the complex number.

complex.equals(other) #

Test whether a complex number equals another complex value.

Two complex numbers are equal when both their real and imaginary parts are
  equal.

complex.neg() #

Returns a complex number with a real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.conjugate() #

Returns a complex number with an equal real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.inverse() #

Returns a complex number that is inverse of the current complex number.

complex.toVector() #

Get the vector representation of the current complex number. Returns an array of size 2.

complex.toJSON() #

Returns a JSON representation of the complex number, with signature
  {mathjs: 'Complex', re: number, im: number}.
  Used when serializing a complex number, see Serialization.

complex.toPolar() #

Get the polar coordinates of the complex number, returns
  an object with properties r and phi.

complex.toString() #

Returns a string representation of the complex number, formatted
  as a + bi where a is the real part and b the imaginary part.

complex.format([precision: number]) #

Get a string representation of the complex number,
  formatted as a + bi where a is the real part and b the imaginary part.
  If precision is defined, the units value will be rounded to the provided
  number of digits.

Static methods #
The following static methods can be accessed using math.Complex

Complex.fromJSON(json) #

Revive a complex number from a JSON object. Accepts
  An object {mathjs: 'Complex', re: number, im: number}, where the property
  mathjs is optional.
  Used when deserializing a complex number, see Serialization.

Complex.fromPolar(r: number, phi: number) #

Create a complex number from polar coordinates.

Complex.compare(a: Complex, b: Complex) #

Returns the comparision result of two complex number:


  Returns 1 when the real part of a is larger than the real part of b
  Returns -1 when the real part of a is smaller than the real part of b
  Returns 1 when the real parts are equal
and the imaginary part of a is larger than the imaginary part of b
  Returns -1 when the real parts are equal
and the imaginary part of a is smaller than the imaginary part of b
  Returns 0 when both real and imaginary parts are equal.


Example:
const a = math.complex(2, 3)   // Complex 2 + 3i
const b = math.complex(2, 1)   // Complex 2 + 1i
math.Complex.compare(a,b) // returns 1

//create from json 
const c = math.Complex.fromJSON({mathjs: 'Complex', re: 4, im: 3})  // Complex 4 + 3i\n\n\n\nComplex Numbers #

Math.js supports the creation, manipulation, and calculations with complex numbers.
Support of complex numbers is powered by the library complex.js.

In mathematics, a complex number is an expression of the form a + bi,
where a and b are real numbers and i represents the imaginary number
defined as i^2 = -1. (In other words, i is the square root of -1.)
The real number a is called the real part of the complex number,
and the real number b is the imaginary part. For example, 3 + 2i is a
complex number, having real part 3 and imaginary part 2.
Complex numbers are often used in applied mathematics, control theory,
signal analysis, fluid dynamics and other fields.

Usage #

A complex number is created using the function math.complex. This function
accepts:


  two numbers representing the real and imaginary part of the value,
  a single string containing a complex value in the form a + bi where a
and b respectively represent the real and imaginary part of the complex number.
  an object with either properties re and im for the real and imaginary
part of the value, or two properties r and phi containing the polar
coordinates of a complex value.
The function returns a Complex object.


Syntax:

math.complex(re: number) : Complex
math.complex(re: number, im: number) : Complex
math.complex(complex: Complex) : Complex
math.complex({re: Number, im: Number}) : Complex
math.complex({r: number, phi: number}) : Complex
math.complex({abs: number, arg: number}) : Complex
math.complex(str: string) : Complex


Examples:

const a = math.complex(2, 3)     // Complex 2 + 3i
a.re                             // Number 2
a.im                             // Number 3

const b = math.complex('4 - 2i') // Complex 4 - 2i
b.re = 5                         // Number 5
b                                // Complex 5 - 2i


Calculations #

Most functions of math.js support complex numbers. Complex and real numbers
can be used together.

const a = math.complex(2, 3)     // Complex 2 + 3i
const b = math.complex('4 - 2i') // Complex 4 - 2i

math.re(a)                       // Number 2
math.im(a)                       // Number 3
math.conj(a)                     // Complex 2 - 3i

math.add(a, b)                   // Complex 6 + i
math.multiply(a, 2)              // Complex 4 + 6i
math.sqrt(-4)                    // Complex 2i


API #
A Complex object created by math.complex contains the following properties and functions:

complex.re #

A number containing the real part of the complex number. Can be read and replaced.

complex.im #

A number containing the imaginary part of the complex number. Can be read and replaced.

complex.clone() #

Create a clone of the complex number.

complex.equals(other) #

Test whether a complex number equals another complex value.

Two complex numbers are equal when both their real and imaginary parts are
  equal.

complex.neg() #

Returns a complex number with a real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.conjugate() #

Returns a complex number with an equal real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.inverse() #

Returns a complex number that is inverse of the current complex number.

complex.toVector() #

Get the vector representation of the current complex number. Returns an array of size 2.

complex.toJSON() #

Returns a JSON representation of the complex number, with signature
  {mathjs: 'Complex', re: number, im: number}.
  Used when serializing a complex number, see Serialization.

complex.toPolar() #

Get the polar coordinates of the complex number, returns
  an object with properties r and phi.

complex.toString() #

Returns a string representation of the complex number, formatted
  as a + bi where a is the real part and b the imaginary part.

complex.format([precision: number]) #

Get a string representation of the complex number,
  formatted as a + bi where a is the real part and b the imaginary part.
  If precision is defined, the units value will be rounded to the provided
  number of digits.

Static methods #
The following static methods can be accessed using math.Complex

Complex.fromJSON(json) #

Revive a complex number from a JSON object. Accepts
  An object {mathjs: 'Complex', re: number, im: number}, where the property
  mathjs is optional.
  Used when deserializing a complex number, see Serialization.

Complex.fromPolar(r: number, phi: number) #

Create a complex number from polar coordinates.

Complex.compare(a: Complex, b: Complex) #

Returns the comparision result of two complex number:


  Returns 1 when the real part of a is larger than the real part of b
  Returns -1 when the real part of a is smaller than the real part of b
  Returns 1 when the real parts are equal
and the imaginary part of a is larger than the imaginary part of b
  Returns -1 when the real parts are equal
and the imaginary part of a is smaller than the imaginary part of b
  Returns 0 when both real and imaginary parts are equal.


Example:
const a = math.complex(2, 3)   // Complex 2 + 3i
const b = math.complex(2, 1)   // Complex 2 + 1i
math.Complex.compare(a,b) // returns 1

//create from json 
const c = math.Complex.fromJSON({mathjs: 'Complex', re: 4, im: 3})  // Complex 4 + 3i\n\n\n\nComplex Numbers #

Math.js supports the creation, manipulation, and calculations with complex numbers.
Support of complex numbers is powered by the library complex.js.

In mathematics, a complex number is an expression of the form a + bi,
where a and b are real numbers and i represents the imaginary number
defined as i^2 = -1. (In other words, i is the square root of -1.)
The real number a is called the real part of the complex number,
and the real number b is the imaginary part. For example, 3 + 2i is a
complex number, having real part 3 and imaginary part 2.
Complex numbers are often used in applied mathematics, control theory,
signal analysis, fluid dynamics and other fields.

Usage #

A complex number is created using the function math.complex. This function
accepts:


  two numbers representing the real and imaginary part of the value,
  a single string containing a complex value in the form a + bi where a
and b respectively represent the real and imaginary part of the complex number.
  an object with either properties re and im for the real and imaginary
part of the value, or two properties r and phi containing the polar
coordinates of a complex value.
The function returns a Complex object.


Syntax:

math.complex(re: number) : Complex
math.complex(re: number, im: number) : Complex
math.complex(complex: Complex) : Complex
math.complex({re: Number, im: Number}) : Complex
math.complex({r: number, phi: number}) : Complex
math.complex({abs: number, arg: number}) : Complex
math.complex(str: string) : Complex


Examples:

const a = math.complex(2, 3)     // Complex 2 + 3i
a.re                             // Number 2
a.im                             // Number 3

const b = math.complex('4 - 2i') // Complex 4 - 2i
b.re = 5                         // Number 5
b                                // Complex 5 - 2i


Calculations #

Most functions of math.js support complex numbers. Complex and real numbers
can be used together.

const a = math.complex(2, 3)     // Complex 2 + 3i
const b = math.complex('4 - 2i') // Complex 4 - 2i

math.re(a)                       // Number 2
math.im(a)                       // Number 3
math.conj(a)                     // Complex 2 - 3i

math.add(a, b)                   // Complex 6 + i
math.multiply(a, 2)              // Complex 4 + 6i
math.sqrt(-4)                    // Complex 2i


API #
A Complex object created by math.complex contains the following properties and functions:

complex.re #

A number containing the real part of the complex number. Can be read and replaced.

complex.im #

A number containing the imaginary part of the complex number. Can be read and replaced.

complex.clone() #

Create a clone of the complex number.

complex.equals(other) #

Test whether a complex number equals another complex value.

Two complex numbers are equal when both their real and imaginary parts are
  equal.

complex.neg() #

Returns a complex number with a real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.conjugate() #

Returns a complex number with an equal real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.inverse() #

Returns a complex number that is inverse of the current complex number.

complex.toVector() #

Get the vector representation of the current complex number. Returns an array of size 2.

complex.toJSON() #

Returns a JSON representation of the complex number, with signature
  {mathjs: 'Complex', re: number, im: number}.
  Used when serializing a complex number, see Serialization.

complex.toPolar() #

Get the polar coordinates of the complex number, returns
  an object with properties r and phi.

complex.toString() #

Returns a string representation of the complex number, formatted
  as a + bi where a is the real part and b the imaginary part.

complex.format([precision: number]) #

Get a string representation of the complex number,
  formatted as a + bi where a is the real part and b the imaginary part.
  If precision is defined, the units value will be rounded to the provided
  number of digits.

Static methods #
The following static methods can be accessed using math.Complex

Complex.fromJSON(json) #

Revive a complex number from a JSON object. Accepts
  An object {mathjs: 'Complex', re: number, im: number}, where the property
  mathjs is optional.
  Used when deserializing a complex number, see Serialization.

Complex.fromPolar(r: number, phi: number) #

Create a complex number from polar coordinates.

Complex.compare(a: Complex, b: Complex) #

Returns the comparision result of two complex number:


  Returns 1 when the real part of a is larger than the real part of b
  Returns -1 when the real part of a is smaller than the real part of b
  Returns 1 when the real parts are equal
and the imaginary part of a is larger than the imaginary part of b
  Returns -1 when the real parts are equal
and the imaginary part of a is smaller than the imaginary part of b
  Returns 0 when both real and imaginary parts are equal.


Example:
const a = math.complex(2, 3)   // Complex 2 + 3i
const b = math.complex(2, 1)   // Complex 2 + 1i
math.Complex.compare(a,b) // returns 1

//create from json 
const c = math.Complex.fromJSON({mathjs: 'Complex', re: 4, im: 3})  // Complex 4 + 3i\n\n\n\nComplex Numbers #

Math.js supports the creation, manipulation, and calculations with complex numbers.
Support of complex numbers is powered by the library complex.js.

In mathematics, a complex number is an expression of the form a + bi,
where a and b are real numbers and i represents the imaginary number
defined as i^2 = -1. (In other words, i is the square root of -1.)
The real number a is called the real part of the complex number,
and the real number b is the imaginary part. For example, 3 + 2i is a
complex number, having real part 3 and imaginary part 2.
Complex numbers are often used in applied mathematics, control theory,
signal analysis, fluid dynamics and other fields.

Usage #

A complex number is created using the function math.complex. This function
accepts:


  two numbers representing the real and imaginary part of the value,
  a single string containing a complex value in the form a + bi where a
and b respectively represent the real and imaginary part of the complex number.
  an object with either properties re and im for the real and imaginary
part of the value, or two properties r and phi containing the polar
coordinates of a complex value.
The function returns a Complex object.


Syntax:

math.complex(re: number) : Complex
math.complex(re: number, im: number) : Complex
math.complex(complex: Complex) : Complex
math.complex({re: Number, im: Number}) : Complex
math.complex({r: number, phi: number}) : Complex
math.complex({abs: number, arg: number}) : Complex
math.complex(str: string) : Complex


Examples:

const a = math.complex(2, 3)     // Complex 2 + 3i
a.re                             // Number 2
a.im                             // Number 3

const b = math.complex('4 - 2i') // Complex 4 - 2i
b.re = 5                         // Number 5
b                                // Complex 5 - 2i


Calculations #

Most functions of math.js support complex numbers. Complex and real numbers
can be used together.

const a = math.complex(2, 3)     // Complex 2 + 3i
const b = math.complex('4 - 2i') // Complex 4 - 2i

math.re(a)                       // Number 2
math.im(a)                       // Number 3
math.conj(a)                     // Complex 2 - 3i

math.add(a, b)                   // Complex 6 + i
math.multiply(a, 2)              // Complex 4 + 6i
math.sqrt(-4)                    // Complex 2i


API #
A Complex object created by math.complex contains the following properties and functions:

complex.re #

A number containing the real part of the complex number. Can be read and replaced.

complex.im #

A number containing the imaginary part of the complex number. Can be read and replaced.

complex.clone() #

Create a clone of the complex number.

complex.equals(other) #

Test whether a complex number equals another complex value.

Two complex numbers are equal when both their real and imaginary parts are
  equal.

complex.neg() #

Returns a complex number with a real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.conjugate() #

Returns a complex number with an equal real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.inverse() #

Returns a complex number that is inverse of the current complex number.

complex.toVector() #

Get the vector representation of the current complex number. Returns an array of size 2.

complex.toJSON() #

Returns a JSON representation of the complex number, with signature
  {mathjs: 'Complex', re: number, im: number}.
  Used when serializing a complex number, see Serialization.

complex.toPolar() #

Get the polar coordinates of the complex number, returns
  an object with properties r and phi.

complex.toString() #

Returns a string representation of the complex number, formatted
  as a + bi where a is the real part and b the imaginary part.

complex.format([precision: number]) #

Get a string representation of the complex number,
  formatted as a + bi where a is the real part and b the imaginary part.
  If precision is defined, the units value will be rounded to the provided
  number of digits.

Static methods #
The following static methods can be accessed using math.Complex

Complex.fromJSON(json) #

Revive a complex number from a JSON object. Accepts
  An object {mathjs: 'Complex', re: number, im: number}, where the property
  mathjs is optional.
  Used when deserializing a complex number, see Serialization.

Complex.fromPolar(r: number, phi: number) #

Create a complex number from polar coordinates.

Complex.compare(a: Complex, b: Complex) #

Returns the comparision result of two complex number:


  Returns 1 when the real part of a is larger than the real part of b
  Returns -1 when the real part of a is smaller than the real part of b
  Returns 1 when the real parts are equal
and the imaginary part of a is larger than the imaginary part of b
  Returns -1 when the real parts are equal
and the imaginary part of a is smaller than the imaginary part of b
  Returns 0 when both real and imaginary parts are equal.


Example:
const a = math.complex(2, 3)   // Complex 2 + 3i
const b = math.complex(2, 1)   // Complex 2 + 1i
math.Complex.compare(a,b) // returns 1

//create from json 
const c = math.Complex.fromJSON({mathjs: 'Complex', re: 4, im: 3})  // Complex 4 + 3i\n\n\n\nComplex Numbers #

Math.js supports the creation, manipulation, and calculations with complex numbers.
Support of complex numbers is powered by the library complex.js.

In mathematics, a complex number is an expression of the form a + bi,
where a and b are real numbers and i represents the imaginary number
defined as i^2 = -1. (In other words, i is the square root of -1.)
The real number a is called the real part of the complex number,
and the real number b is the imaginary part. For example, 3 + 2i is a
complex number, having real part 3 and imaginary part 2.
Complex numbers are often used in applied mathematics, control theory,
signal analysis, fluid dynamics and other fields.

Usage #

A complex number is created using the function math.complex. This function
accepts:


  two numbers representing the real and imaginary part of the value,
  a single string containing a complex value in the form a + bi where a
and b respectively represent the real and imaginary part of the complex number.
  an object with either properties re and im for the real and imaginary
part of the value, or two properties r and phi containing the polar
coordinates of a complex value.
The function returns a Complex object.


Syntax:

math.complex(re: number) : Complex
math.complex(re: number, im: number) : Complex
math.complex(complex: Complex) : Complex
math.complex({re: Number, im: Number}) : Complex
math.complex({r: number, phi: number}) : Complex
math.complex({abs: number, arg: number}) : Complex
math.complex(str: string) : Complex


Examples:

const a = math.complex(2, 3)     // Complex 2 + 3i
a.re                             // Number 2
a.im                             // Number 3

const b = math.complex('4 - 2i') // Complex 4 - 2i
b.re = 5                         // Number 5
b                                // Complex 5 - 2i


Calculations #

Most functions of math.js support complex numbers. Complex and real numbers
can be used together.

const a = math.complex(2, 3)     // Complex 2 + 3i
const b = math.complex('4 - 2i') // Complex 4 - 2i

math.re(a)                       // Number 2
math.im(a)                       // Number 3
math.conj(a)                     // Complex 2 - 3i

math.add(a, b)                   // Complex 6 + i
math.multiply(a, 2)              // Complex 4 + 6i
math.sqrt(-4)                    // Complex 2i


API #
A Complex object created by math.complex contains the following properties and functions:

complex.re #

A number containing the real part of the complex number. Can be read and replaced.

complex.im #

A number containing the imaginary part of the complex number. Can be read and replaced.

complex.clone() #

Create a clone of the complex number.

complex.equals(other) #

Test whether a complex number equals another complex value.

Two complex numbers are equal when both their real and imaginary parts are
  equal.

complex.neg() #

Returns a complex number with a real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.conjugate() #

Returns a complex number with an equal real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.inverse() #

Returns a complex number that is inverse of the current complex number.

complex.toVector() #

Get the vector representation of the current complex number. Returns an array of size 2.

complex.toJSON() #

Returns a JSON representation of the complex number, with signature
  {mathjs: 'Complex', re: number, im: number}.
  Used when serializing a complex number, see Serialization.

complex.toPolar() #

Get the polar coordinates of the complex number, returns
  an object with properties r and phi.

complex.toString() #

Returns a string representation of the complex number, formatted
  as a + bi where a is the real part and b the imaginary part.

complex.format([precision: number]) #

Get a string representation of the complex number,
  formatted as a + bi where a is the real part and b the imaginary part.
  If precision is defined, the units value will be rounded to the provided
  number of digits.

Static methods #
The following static methods can be accessed using math.Complex

Complex.fromJSON(json) #

Revive a complex number from a JSON object. Accepts
  An object {mathjs: 'Complex', re: number, im: number}, where the property
  mathjs is optional.
  Used when deserializing a complex number, see Serialization.

Complex.fromPolar(r: number, phi: number) #

Create a complex number from polar coordinates.

Complex.compare(a: Complex, b: Complex) #

Returns the comparision result of two complex number:


  Returns 1 when the real part of a is larger than the real part of b
  Returns -1 when the real part of a is smaller than the real part of b
  Returns 1 when the real parts are equal
and the imaginary part of a is larger than the imaginary part of b
  Returns -1 when the real parts are equal
and the imaginary part of a is smaller than the imaginary part of b
  Returns 0 when both real and imaginary parts are equal.


Example:
const a = math.complex(2, 3)   // Complex 2 + 3i
const b = math.complex(2, 1)   // Complex 2 + 1i
math.Complex.compare(a,b) // returns 1

//create from json 
const c = math.Complex.fromJSON({mathjs: 'Complex', re: 4, im: 3})  // Complex 4 + 3i\n\n\n\nComplex Numbers #

Math.js supports the creation, manipulation, and calculations with complex numbers.
Support of complex numbers is powered by the library complex.js.

In mathematics, a complex number is an expression of the form a + bi,
where a and b are real numbers and i represents the imaginary number
defined as i^2 = -1. (In other words, i is the square root of -1.)
The real number a is called the real part of the complex number,
and the real number b is the imaginary part. For example, 3 + 2i is a
complex number, having real part 3 and imaginary part 2.
Complex numbers are often used in applied mathematics, control theory,
signal analysis, fluid dynamics and other fields.

Usage #

A complex number is created using the function math.complex. This function
accepts:


  two numbers representing the real and imaginary part of the value,
  a single string containing a complex value in the form a + bi where a
and b respectively represent the real and imaginary part of the complex number.
  an object with either properties re and im for the real and imaginary
part of the value, or two properties r and phi containing the polar
coordinates of a complex value.
The function returns a Complex object.


Syntax:

math.complex(re: number) : Complex
math.complex(re: number, im: number) : Complex
math.complex(complex: Complex) : Complex
math.complex({re: Number, im: Number}) : Complex
math.complex({r: number, phi: number}) : Complex
math.complex({abs: number, arg: number}) : Complex
math.complex(str: string) : Complex


Examples:

const a = math.complex(2, 3)     // Complex 2 + 3i
a.re                             // Number 2
a.im                             // Number 3

const b = math.complex('4 - 2i') // Complex 4 - 2i
b.re = 5                         // Number 5
b                                // Complex 5 - 2i


Calculations #

Most functions of math.js support complex numbers. Complex and real numbers
can be used together.

const a = math.complex(2, 3)     // Complex 2 + 3i
const b = math.complex('4 - 2i') // Complex 4 - 2i

math.re(a)                       // Number 2
math.im(a)                       // Number 3
math.conj(a)                     // Complex 2 - 3i

math.add(a, b)                   // Complex 6 + i
math.multiply(a, 2)              // Complex 4 + 6i
math.sqrt(-4)                    // Complex 2i


API #
A Complex object created by math.complex contains the following properties and functions:

complex.re #

A number containing the real part of the complex number. Can be read and replaced.

complex.im #

A number containing the imaginary part of the complex number. Can be read and replaced.

complex.clone() #

Create a clone of the complex number.

complex.equals(other) #

Test whether a complex number equals another complex value.

Two complex numbers are equal when both their real and imaginary parts are
  equal.

complex.neg() #

Returns a complex number with a real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.conjugate() #

Returns a complex number with an equal real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.inverse() #

Returns a complex number that is inverse of the current complex number.

complex.toVector() #

Get the vector representation of the current complex number. Returns an array of size 2.

complex.toJSON() #

Returns a JSON representation of the complex number, with signature
  {mathjs: 'Complex', re: number, im: number}.
  Used when serializing a complex number, see Serialization.

complex.toPolar() #

Get the polar coordinates of the complex number, returns
  an object with properties r and phi.

complex.toString() #

Returns a string representation of the complex number, formatted
  as a + bi where a is the real part and b the imaginary part.

complex.format([precision: number]) #

Get a string representation of the complex number,
  formatted as a + bi where a is the real part and b the imaginary part.
  If precision is defined, the units value will be rounded to the provided
  number of digits.

Static methods #
The following static methods can be accessed using math.Complex

Complex.fromJSON(json) #

Revive a complex number from a JSON object. Accepts
  An object {mathjs: 'Complex', re: number, im: number}, where the property
  mathjs is optional.
  Used when deserializing a complex number, see Serialization.

Complex.fromPolar(r: number, phi: number) #

Create a complex number from polar coordinates.

Complex.compare(a: Complex, b: Complex) #

Returns the comparision result of two complex number:


  Returns 1 when the real part of a is larger than the real part of b
  Returns -1 when the real part of a is smaller than the real part of b
  Returns 1 when the real parts are equal
and the imaginary part of a is larger than the imaginary part of b
  Returns -1 when the real parts are equal
and the imaginary part of a is smaller than the imaginary part of b
  Returns 0 when both real and imaginary parts are equal.


Example:
const a = math.complex(2, 3)   // Complex 2 + 3i
const b = math.complex(2, 1)   // Complex 2 + 1i
math.Complex.compare(a,b) // returns 1

//create from json 
const c = math.Complex.fromJSON({mathjs: 'Complex', re: 4, im: 3})  // Complex 4 + 3i\n\n\n\nComplex Numbers #

Math.js supports the creation, manipulation, and calculations with complex numbers.
Support of complex numbers is powered by the library complex.js.

In mathematics, a complex number is an expression of the form a + bi,
where a and b are real numbers and i represents the imaginary number
defined as i^2 = -1. (In other words, i is the square root of -1.)
The real number a is called the real part of the complex number,
and the real number b is the imaginary part. For example, 3 + 2i is a
complex number, having real part 3 and imaginary part 2.
Complex numbers are often used in applied mathematics, control theory,
signal analysis, fluid dynamics and other fields.

Usage #

A complex number is created using the function math.complex. This function
accepts:


  two numbers representing the real and imaginary part of the value,
  a single string containing a complex value in the form a + bi where a
and b respectively represent the real and imaginary part of the complex number.
  an object with either properties re and im for the real and imaginary
part of the value, or two properties r and phi containing the polar
coordinates of a complex value.
The function returns a Complex object.


Syntax:

math.complex(re: number) : Complex
math.complex(re: number, im: number) : Complex
math.complex(complex: Complex) : Complex
math.complex({re: Number, im: Number}) : Complex
math.complex({r: number, phi: number}) : Complex
math.complex({abs: number, arg: number}) : Complex
math.complex(str: string) : Complex


Examples:

const a = math.complex(2, 3)     // Complex 2 + 3i
a.re                             // Number 2
a.im                             // Number 3

const b = math.complex('4 - 2i') // Complex 4 - 2i
b.re = 5                         // Number 5
b                                // Complex 5 - 2i


Calculations #

Most functions of math.js support complex numbers. Complex and real numbers
can be used together.

const a = math.complex(2, 3)     // Complex 2 + 3i
const b = math.complex('4 - 2i') // Complex 4 - 2i

math.re(a)                       // Number 2
math.im(a)                       // Number 3
math.conj(a)                     // Complex 2 - 3i

math.add(a, b)                   // Complex 6 + i
math.multiply(a, 2)              // Complex 4 + 6i
math.sqrt(-4)                    // Complex 2i


API #
A Complex object created by math.complex contains the following properties and functions:

complex.re #

A number containing the real part of the complex number. Can be read and replaced.

complex.im #

A number containing the imaginary part of the complex number. Can be read and replaced.

complex.clone() #

Create a clone of the complex number.

complex.equals(other) #

Test whether a complex number equals another complex value.

Two complex numbers are equal when both their real and imaginary parts are
  equal.

complex.neg() #

Returns a complex number with a real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.conjugate() #

Returns a complex number with an equal real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.inverse() #

Returns a complex number that is inverse of the current complex number.

complex.toVector() #

Get the vector representation of the current complex number. Returns an array of size 2.

complex.toJSON() #

Returns a JSON representation of the complex number, with signature
  {mathjs: 'Complex', re: number, im: number}.
  Used when serializing a complex number, see Serialization.

complex.toPolar() #

Get the polar coordinates of the complex number, returns
  an object with properties r and phi.

complex.toString() #

Returns a string representation of the complex number, formatted
  as a + bi where a is the real part and b the imaginary part.

complex.format([precision: number]) #

Get a string representation of the complex number,
  formatted as a + bi where a is the real part and b the imaginary part.
  If precision is defined, the units value will be rounded to the provided
  number of digits.

Static methods #
The following static methods can be accessed using math.Complex

Complex.fromJSON(json) #

Revive a complex number from a JSON object. Accepts
  An object {mathjs: 'Complex', re: number, im: number}, where the property
  mathjs is optional.
  Used when deserializing a complex number, see Serialization.

Complex.fromPolar(r: number, phi: number) #

Create a complex number from polar coordinates.

Complex.compare(a: Complex, b: Complex) #

Returns the comparision result of two complex number:


  Returns 1 when the real part of a is larger than the real part of b
  Returns -1 when the real part of a is smaller than the real part of b
  Returns 1 when the real parts are equal
and the imaginary part of a is larger than the imaginary part of b
  Returns -1 when the real parts are equal
and the imaginary part of a is smaller than the imaginary part of b
  Returns 0 when both real and imaginary parts are equal.


Example:
const a = math.complex(2, 3)   // Complex 2 + 3i
const b = math.complex(2, 1)   // Complex 2 + 1i
math.Complex.compare(a,b) // returns 1

//create from json 
const c = math.Complex.fromJSON({mathjs: 'Complex', re: 4, im: 3})  // Complex 4 + 3i\n\n\n\nComplex Numbers #

Math.js supports the creation, manipulation, and calculations with complex numbers.
Support of complex numbers is powered by the library complex.js.

In mathematics, a complex number is an expression of the form a + bi,
where a and b are real numbers and i represents the imaginary number
defined as i^2 = -1. (In other words, i is the square root of -1.)
The real number a is called the real part of the complex number,
and the real number b is the imaginary part. For example, 3 + 2i is a
complex number, having real part 3 and imaginary part 2.
Complex numbers are often used in applied mathematics, control theory,
signal analysis, fluid dynamics and other fields.

Usage #

A complex number is created using the function math.complex. This function
accepts:


  two numbers representing the real and imaginary part of the value,
  a single string containing a complex value in the form a + bi where a
and b respectively represent the real and imaginary part of the complex number.
  an object with either properties re and im for the real and imaginary
part of the value, or two properties r and phi containing the polar
coordinates of a complex value.
The function returns a Complex object.


Syntax:

math.complex(re: number) : Complex
math.complex(re: number, im: number) : Complex
math.complex(complex: Complex) : Complex
math.complex({re: Number, im: Number}) : Complex
math.complex({r: number, phi: number}) : Complex
math.complex({abs: number, arg: number}) : Complex
math.complex(str: string) : Complex


Examples:

const a = math.complex(2, 3)     // Complex 2 + 3i
a.re                             // Number 2
a.im                             // Number 3

const b = math.complex('4 - 2i') // Complex 4 - 2i
b.re = 5                         // Number 5
b                                // Complex 5 - 2i


Calculations #

Most functions of math.js support complex numbers. Complex and real numbers
can be used together.

const a = math.complex(2, 3)     // Complex 2 + 3i
const b = math.complex('4 - 2i') // Complex 4 - 2i

math.re(a)                       // Number 2
math.im(a)                       // Number 3
math.conj(a)                     // Complex 2 - 3i

math.add(a, b)                   // Complex 6 + i
math.multiply(a, 2)              // Complex 4 + 6i
math.sqrt(-4)                    // Complex 2i


API #
A Complex object created by math.complex contains the following properties and functions:

complex.re #

A number containing the real part of the complex number. Can be read and replaced.

complex.im #

A number containing the imaginary part of the complex number. Can be read and replaced.

complex.clone() #

Create a clone of the complex number.

complex.equals(other) #

Test whether a complex number equals another complex value.

Two complex numbers are equal when both their real and imaginary parts are
  equal.

complex.neg() #

Returns a complex number with a real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.conjugate() #

Returns a complex number with an equal real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.inverse() #

Returns a complex number that is inverse of the current complex number.

complex.toVector() #

Get the vector representation of the current complex number. Returns an array of size 2.

complex.toJSON() #

Returns a JSON representation of the complex number, with signature
  {mathjs: 'Complex', re: number, im: number}.
  Used when serializing a complex number, see Serialization.

complex.toPolar() #

Get the polar coordinates of the complex number, returns
  an object with properties r and phi.

complex.toString() #

Returns a string representation of the complex number, formatted
  as a + bi where a is the real part and b the imaginary part.

complex.format([precision: number]) #

Get a string representation of the complex number,
  formatted as a + bi where a is the real part and b the imaginary part.
  If precision is defined, the units value will be rounded to the provided
  number of digits.

Static methods #
The following static methods can be accessed using math.Complex

Complex.fromJSON(json) #

Revive a complex number from a JSON object. Accepts
  An object {mathjs: 'Complex', re: number, im: number}, where the property
  mathjs is optional.
  Used when deserializing a complex number, see Serialization.

Complex.fromPolar(r: number, phi: number) #

Create a complex number from polar coordinates.

Complex.compare(a: Complex, b: Complex) #

Returns the comparision result of two complex number:


  Returns 1 when the real part of a is larger than the real part of b
  Returns -1 when the real part of a is smaller than the real part of b
  Returns 1 when the real parts are equal
and the imaginary part of a is larger than the imaginary part of b
  Returns -1 when the real parts are equal
and the imaginary part of a is smaller than the imaginary part of b
  Returns 0 when both real and imaginary parts are equal.


Example:
const a = math.complex(2, 3)   // Complex 2 + 3i
const b = math.complex(2, 1)   // Complex 2 + 1i
math.Complex.compare(a,b) // returns 1

//create from json 
const c = math.Complex.fromJSON({mathjs: 'Complex', re: 4, im: 3})  // Complex 4 + 3i\n\n\n\nComplex Numbers #

Math.js supports the creation, manipulation, and calculations with complex numbers.
Support of complex numbers is powered by the library complex.js.

In mathematics, a complex number is an expression of the form a + bi,
where a and b are real numbers and i represents the imaginary number
defined as i^2 = -1. (In other words, i is the square root of -1.)
The real number a is called the real part of the complex number,
and the real number b is the imaginary part. For example, 3 + 2i is a
complex number, having real part 3 and imaginary part 2.
Complex numbers are often used in applied mathematics, control theory,
signal analysis, fluid dynamics and other fields.

Usage #

A complex number is created using the function math.complex. This function
accepts:


  two numbers representing the real and imaginary part of the value,
  a single string containing a complex value in the form a + bi where a
and b respectively represent the real and imaginary part of the complex number.
  an object with either properties re and im for the real and imaginary
part of the value, or two properties r and phi containing the polar
coordinates of a complex value.
The function returns a Complex object.


Syntax:

math.complex(re: number) : Complex
math.complex(re: number, im: number) : Complex
math.complex(complex: Complex) : Complex
math.complex({re: Number, im: Number}) : Complex
math.complex({r: number, phi: number}) : Complex
math.complex({abs: number, arg: number}) : Complex
math.complex(str: string) : Complex


Examples:

const a = math.complex(2, 3)     // Complex 2 + 3i
a.re                             // Number 2
a.im                             // Number 3

const b = math.complex('4 - 2i') // Complex 4 - 2i
b.re = 5                         // Number 5
b                                // Complex 5 - 2i


Calculations #

Most functions of math.js support complex numbers. Complex and real numbers
can be used together.

const a = math.complex(2, 3)     // Complex 2 + 3i
const b = math.complex('4 - 2i') // Complex 4 - 2i

math.re(a)                       // Number 2
math.im(a)                       // Number 3
math.conj(a)                     // Complex 2 - 3i

math.add(a, b)                   // Complex 6 + i
math.multiply(a, 2)              // Complex 4 + 6i
math.sqrt(-4)                    // Complex 2i


API #
A Complex object created by math.complex contains the following properties and functions:

complex.re #

A number containing the real part of the complex number. Can be read and replaced.

complex.im #

A number containing the imaginary part of the complex number. Can be read and replaced.

complex.clone() #

Create a clone of the complex number.

complex.equals(other) #

Test whether a complex number equals another complex value.

Two complex numbers are equal when both their real and imaginary parts are
  equal.

complex.neg() #

Returns a complex number with a real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.conjugate() #

Returns a complex number with an equal real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.inverse() #

Returns a complex number that is inverse of the current complex number.

complex.toVector() #

Get the vector representation of the current complex number. Returns an array of size 2.

complex.toJSON() #

Returns a JSON representation of the complex number, with signature
  {mathjs: 'Complex', re: number, im: number}.
  Used when serializing a complex number, see Serialization.

complex.toPolar() #

Get the polar coordinates of the complex number, returns
  an object with properties r and phi.

complex.toString() #

Returns a string representation of the complex number, formatted
  as a + bi where a is the real part and b the imaginary part.

complex.format([precision: number]) #

Get a string representation of the complex number,
  formatted as a + bi where a is the real part and b the imaginary part.
  If precision is defined, the units value will be rounded to the provided
  number of digits.

Static methods #
The following static methods can be accessed using math.Complex

Complex.fromJSON(json) #

Revive a complex number from a JSON object. Accepts
  An object {mathjs: 'Complex', re: number, im: number}, where the property
  mathjs is optional.
  Used when deserializing a complex number, see Serialization.

Complex.fromPolar(r: number, phi: number) #

Create a complex number from polar coordinates.

Complex.compare(a: Complex, b: Complex) #

Returns the comparision result of two complex number:


  Returns 1 when the real part of a is larger than the real part of b
  Returns -1 when the real part of a is smaller than the real part of b
  Returns 1 when the real parts are equal
and the imaginary part of a is larger than the imaginary part of b
  Returns -1 when the real parts are equal
and the imaginary part of a is smaller than the imaginary part of b
  Returns 0 when both real and imaginary parts are equal.


Example:
const a = math.complex(2, 3)   // Complex 2 + 3i
const b = math.complex(2, 1)   // Complex 2 + 1i
math.Complex.compare(a,b) // returns 1

//create from json 
const c = math.Complex.fromJSON({mathjs: 'Complex', re: 4, im: 3})  // Complex 4 + 3i\n\n\n\nComplex Numbers #

Math.js supports the creation, manipulation, and calculations with complex numbers.
Support of complex numbers is powered by the library complex.js.

In mathematics, a complex number is an expression of the form a + bi,
where a and b are real numbers and i represents the imaginary number
defined as i^2 = -1. (In other words, i is the square root of -1.)
The real number a is called the real part of the complex number,
and the real number b is the imaginary part. For example, 3 + 2i is a
complex number, having real part 3 and imaginary part 2.
Complex numbers are often used in applied mathematics, control theory,
signal analysis, fluid dynamics and other fields.

Usage #

A complex number is created using the function math.complex. This function
accepts:


  two numbers representing the real and imaginary part of the value,
  a single string containing a complex value in the form a + bi where a
and b respectively represent the real and imaginary part of the complex number.
  an object with either properties re and im for the real and imaginary
part of the value, or two properties r and phi containing the polar
coordinates of a complex value.
The function returns a Complex object.


Syntax:

math.complex(re: number) : Complex
math.complex(re: number, im: number) : Complex
math.complex(complex: Complex) : Complex
math.complex({re: Number, im: Number}) : Complex
math.complex({r: number, phi: number}) : Complex
math.complex({abs: number, arg: number}) : Complex
math.complex(str: string) : Complex


Examples:

const a = math.complex(2, 3)     // Complex 2 + 3i
a.re                             // Number 2
a.im                             // Number 3

const b = math.complex('4 - 2i') // Complex 4 - 2i
b.re = 5                         // Number 5
b                                // Complex 5 - 2i


Calculations #

Most functions of math.js support complex numbers. Complex and real numbers
can be used together.

const a = math.complex(2, 3)     // Complex 2 + 3i
const b = math.complex('4 - 2i') // Complex 4 - 2i

math.re(a)                       // Number 2
math.im(a)                       // Number 3
math.conj(a)                     // Complex 2 - 3i

math.add(a, b)                   // Complex 6 + i
math.multiply(a, 2)              // Complex 4 + 6i
math.sqrt(-4)                    // Complex 2i


API #
A Complex object created by math.complex contains the following properties and functions:

complex.re #

A number containing the real part of the complex number. Can be read and replaced.

complex.im #

A number containing the imaginary part of the complex number. Can be read and replaced.

complex.clone() #

Create a clone of the complex number.

complex.equals(other) #

Test whether a complex number equals another complex value.

Two complex numbers are equal when both their real and imaginary parts are
  equal.

complex.neg() #

Returns a complex number with a real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.conjugate() #

Returns a complex number with an equal real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.inverse() #

Returns a complex number that is inverse of the current complex number.

complex.toVector() #

Get the vector representation of the current complex number. Returns an array of size 2.

complex.toJSON() #

Returns a JSON representation of the complex number, with signature
  {mathjs: 'Complex', re: number, im: number}.
  Used when serializing a complex number, see Serialization.

complex.toPolar() #

Get the polar coordinates of the complex number, returns
  an object with properties r and phi.

complex.toString() #

Returns a string representation of the complex number, formatted
  as a + bi where a is the real part and b the imaginary part.

complex.format([precision: number]) #

Get a string representation of the complex number,
  formatted as a + bi where a is the real part and b the imaginary part.
  If precision is defined, the units value will be rounded to the provided
  number of digits.

Static methods #
The following static methods can be accessed using math.Complex

Complex.fromJSON(json) #

Revive a complex number from a JSON object. Accepts
  An object {mathjs: 'Complex', re: number, im: number}, where the property
  mathjs is optional.
  Used when deserializing a complex number, see Serialization.

Complex.fromPolar(r: number, phi: number) #

Create a complex number from polar coordinates.

Complex.compare(a: Complex, b: Complex) #

Returns the comparision result of two complex number:


  Returns 1 when the real part of a is larger than the real part of b
  Returns -1 when the real part of a is smaller than the real part of b
  Returns 1 when the real parts are equal
and the imaginary part of a is larger than the imaginary part of b
  Returns -1 when the real parts are equal
and the imaginary part of a is smaller than the imaginary part of b
  Returns 0 when both real and imaginary parts are equal.


Example:
const a = math.complex(2, 3)   // Complex 2 + 3i
const b = math.complex(2, 1)   // Complex 2 + 1i
math.Complex.compare(a,b) // returns 1

//create from json 
const c = math.Complex.fromJSON({mathjs: 'Complex', re: 4, im: 3})  // Complex 4 + 3i\n\n\n\nComplex Numbers #

Math.js supports the creation, manipulation, and calculations with complex numbers.
Support of complex numbers is powered by the library complex.js.

In mathematics, a complex number is an expression of the form a + bi,
where a and b are real numbers and i represents the imaginary number
defined as i^2 = -1. (In other words, i is the square root of -1.)
The real number a is called the real part of the complex number,
and the real number b is the imaginary part. For example, 3 + 2i is a
complex number, having real part 3 and imaginary part 2.
Complex numbers are often used in applied mathematics, control theory,
signal analysis, fluid dynamics and other fields.

Usage #

A complex number is created using the function math.complex. This function
accepts:


  two numbers representing the real and imaginary part of the value,
  a single string containing a complex value in the form a + bi where a
and b respectively represent the real and imaginary part of the complex number.
  an object with either properties re and im for the real and imaginary
part of the value, or two properties r and phi containing the polar
coordinates of a complex value.
The function returns a Complex object.


Syntax:

math.complex(re: number) : Complex
math.complex(re: number, im: number) : Complex
math.complex(complex: Complex) : Complex
math.complex({re: Number, im: Number}) : Complex
math.complex({r: number, phi: number}) : Complex
math.complex({abs: number, arg: number}) : Complex
math.complex(str: string) : Complex


Examples:

const a = math.complex(2, 3)     // Complex 2 + 3i
a.re                             // Number 2
a.im                             // Number 3

const b = math.complex('4 - 2i') // Complex 4 - 2i
b.re = 5                         // Number 5
b                                // Complex 5 - 2i


Calculations #

Most functions of math.js support complex numbers. Complex and real numbers
can be used together.

const a = math.complex(2, 3)     // Complex 2 + 3i
const b = math.complex('4 - 2i') // Complex 4 - 2i

math.re(a)                       // Number 2
math.im(a)                       // Number 3
math.conj(a)                     // Complex 2 - 3i

math.add(a, b)                   // Complex 6 + i
math.multiply(a, 2)              // Complex 4 + 6i
math.sqrt(-4)                    // Complex 2i


API #
A Complex object created by math.complex contains the following properties and functions:

complex.re #

A number containing the real part of the complex number. Can be read and replaced.

complex.im #

A number containing the imaginary part of the complex number. Can be read and replaced.

complex.clone() #

Create a clone of the complex number.

complex.equals(other) #

Test whether a complex number equals another complex value.

Two complex numbers are equal when both their real and imaginary parts are
  equal.

complex.neg() #

Returns a complex number with a real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.conjugate() #

Returns a complex number with an equal real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.inverse() #

Returns a complex number that is inverse of the current complex number.

complex.toVector() #

Get the vector representation of the current complex number. Returns an array of size 2.

complex.toJSON() #

Returns a JSON representation of the complex number, with signature
  {mathjs: 'Complex', re: number, im: number}.
  Used when serializing a complex number, see Serialization.

complex.toPolar() #

Get the polar coordinates of the complex number, returns
  an object with properties r and phi.

complex.toString() #

Returns a string representation of the complex number, formatted
  as a + bi where a is the real part and b the imaginary part.

complex.format([precision: number]) #

Get a string representation of the complex number,
  formatted as a + bi where a is the real part and b the imaginary part.
  If precision is defined, the units value will be rounded to the provided
  number of digits.

Static methods #
The following static methods can be accessed using math.Complex

Complex.fromJSON(json) #

Revive a complex number from a JSON object. Accepts
  An object {mathjs: 'Complex', re: number, im: number}, where the property
  mathjs is optional.
  Used when deserializing a complex number, see Serialization.

Complex.fromPolar(r: number, phi: number) #

Create a complex number from polar coordinates.

Complex.compare(a: Complex, b: Complex) #

Returns the comparision result of two complex number:


  Returns 1 when the real part of a is larger than the real part of b
  Returns -1 when the real part of a is smaller than the real part of b
  Returns 1 when the real parts are equal
and the imaginary part of a is larger than the imaginary part of b
  Returns -1 when the real parts are equal
and the imaginary part of a is smaller than the imaginary part of b
  Returns 0 when both real and imaginary parts are equal.


Example:
const a = math.complex(2, 3)   // Complex 2 + 3i
const b = math.complex(2, 1)   // Complex 2 + 1i
math.Complex.compare(a,b) // returns 1

//create from json 
const c = math.Complex.fromJSON({mathjs: 'Complex', re: 4, im: 3})  // Complex 4 + 3i\n\n\n\nComplex Numbers #

Math.js supports the creation, manipulation, and calculations with complex numbers.
Support of complex numbers is powered by the library complex.js.

In mathematics, a complex number is an expression of the form a + bi,
where a and b are real numbers and i represents the imaginary number
defined as i^2 = -1. (In other words, i is the square root of -1.)
The real number a is called the real part of the complex number,
and the real number b is the imaginary part. For example, 3 + 2i is a
complex number, having real part 3 and imaginary part 2.
Complex numbers are often used in applied mathematics, control theory,
signal analysis, fluid dynamics and other fields.

Usage #

A complex number is created using the function math.complex. This function
accepts:


  two numbers representing the real and imaginary part of the value,
  a single string containing a complex value in the form a + bi where a
and b respectively represent the real and imaginary part of the complex number.
  an object with either properties re and im for the real and imaginary
part of the value, or two properties r and phi containing the polar
coordinates of a complex value.
The function returns a Complex object.


Syntax:

math.complex(re: number) : Complex
math.complex(re: number, im: number) : Complex
math.complex(complex: Complex) : Complex
math.complex({re: Number, im: Number}) : Complex
math.complex({r: number, phi: number}) : Complex
math.complex({abs: number, arg: number}) : Complex
math.complex(str: string) : Complex


Examples:

const a = math.complex(2, 3)     // Complex 2 + 3i
a.re                             // Number 2
a.im                             // Number 3

const b = math.complex('4 - 2i') // Complex 4 - 2i
b.re = 5                         // Number 5
b                                // Complex 5 - 2i


Calculations #

Most functions of math.js support complex numbers. Complex and real numbers
can be used together.

const a = math.complex(2, 3)     // Complex 2 + 3i
const b = math.complex('4 - 2i') // Complex 4 - 2i

math.re(a)                       // Number 2
math.im(a)                       // Number 3
math.conj(a)                     // Complex 2 - 3i

math.add(a, b)                   // Complex 6 + i
math.multiply(a, 2)              // Complex 4 + 6i
math.sqrt(-4)                    // Complex 2i


API #
A Complex object created by math.complex contains the following properties and functions:

complex.re #

A number containing the real part of the complex number. Can be read and replaced.

complex.im #

A number containing the imaginary part of the complex number. Can be read and replaced.

complex.clone() #

Create a clone of the complex number.

complex.equals(other) #

Test whether a complex number equals another complex value.

Two complex numbers are equal when both their real and imaginary parts are
  equal.

complex.neg() #

Returns a complex number with a real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.conjugate() #

Returns a complex number with an equal real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.inverse() #

Returns a complex number that is inverse of the current complex number.

complex.toVector() #

Get the vector representation of the current complex number. Returns an array of size 2.

complex.toJSON() #

Returns a JSON representation of the complex number, with signature
  {mathjs: 'Complex', re: number, im: number}.
  Used when serializing a complex number, see Serialization.

complex.toPolar() #

Get the polar coordinates of the complex number, returns
  an object with properties r and phi.

complex.toString() #

Returns a string representation of the complex number, formatted
  as a + bi where a is the real part and b the imaginary part.

complex.format([precision: number]) #

Get a string representation of the complex number,
  formatted as a + bi where a is the real part and b the imaginary part.
  If precision is defined, the units value will be rounded to the provided
  number of digits.

Static methods #
The following static methods can be accessed using math.Complex

Complex.fromJSON(json) #

Revive a complex number from a JSON object. Accepts
  An object {mathjs: 'Complex', re: number, im: number}, where the property
  mathjs is optional.
  Used when deserializing a complex number, see Serialization.

Complex.fromPolar(r: number, phi: number) #

Create a complex number from polar coordinates.

Complex.compare(a: Complex, b: Complex) #

Returns the comparision result of two complex number:


  Returns 1 when the real part of a is larger than the real part of b
  Returns -1 when the real part of a is smaller than the real part of b
  Returns 1 when the real parts are equal
and the imaginary part of a is larger than the imaginary part of b
  Returns -1 when the real parts are equal
and the imaginary part of a is smaller than the imaginary part of b
  Returns 0 when both real and imaginary parts are equal.


Example:
const a = math.complex(2, 3)   // Complex 2 + 3i
const b = math.complex(2, 1)   // Complex 2 + 1i
math.Complex.compare(a,b) // returns 1

//create from json 
const c = math.Complex.fromJSON({mathjs: 'Complex', re: 4, im: 3})  // Complex 4 + 3i\n\n\n\nComplex Numbers #

Math.js supports the creation, manipulation, and calculations with complex numbers.
Support of complex numbers is powered by the library complex.js.

In mathematics, a complex number is an expression of the form a + bi,
where a and b are real numbers and i represents the imaginary number
defined as i^2 = -1. (In other words, i is the square root of -1.)
The real number a is called the real part of the complex number,
and the real number b is the imaginary part. For example, 3 + 2i is a
complex number, having real part 3 and imaginary part 2.
Complex numbers are often used in applied mathematics, control theory,
signal analysis, fluid dynamics and other fields.

Usage #

A complex number is created using the function math.complex. This function
accepts:


  two numbers representing the real and imaginary part of the value,
  a single string containing a complex value in the form a + bi where a
and b respectively represent the real and imaginary part of the complex number.
  an object with either properties re and im for the real and imaginary
part of the value, or two properties r and phi containing the polar
coordinates of a complex value.
The function returns a Complex object.


Syntax:

math.complex(re: number) : Complex
math.complex(re: number, im: number) : Complex
math.complex(complex: Complex) : Complex
math.complex({re: Number, im: Number}) : Complex
math.complex({r: number, phi: number}) : Complex
math.complex({abs: number, arg: number}) : Complex
math.complex(str: string) : Complex


Examples:

const a = math.complex(2, 3)     // Complex 2 + 3i
a.re                             // Number 2
a.im                             // Number 3

const b = math.complex('4 - 2i') // Complex 4 - 2i
b.re = 5                         // Number 5
b                                // Complex 5 - 2i


Calculations #

Most functions of math.js support complex numbers. Complex and real numbers
can be used together.

const a = math.complex(2, 3)     // Complex 2 + 3i
const b = math.complex('4 - 2i') // Complex 4 - 2i

math.re(a)                       // Number 2
math.im(a)                       // Number 3
math.conj(a)                     // Complex 2 - 3i

math.add(a, b)                   // Complex 6 + i
math.multiply(a, 2)              // Complex 4 + 6i
math.sqrt(-4)                    // Complex 2i


API #
A Complex object created by math.complex contains the following properties and functions:

complex.re #

A number containing the real part of the complex number. Can be read and replaced.

complex.im #

A number containing the imaginary part of the complex number. Can be read and replaced.

complex.clone() #

Create a clone of the complex number.

complex.equals(other) #

Test whether a complex number equals another complex value.

Two complex numbers are equal when both their real and imaginary parts are
  equal.

complex.neg() #

Returns a complex number with a real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.conjugate() #

Returns a complex number with an equal real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.inverse() #

Returns a complex number that is inverse of the current complex number.

complex.toVector() #

Get the vector representation of the current complex number. Returns an array of size 2.

complex.toJSON() #

Returns a JSON representation of the complex number, with signature
  {mathjs: 'Complex', re: number, im: number}.
  Used when serializing a complex number, see Serialization.

complex.toPolar() #

Get the polar coordinates of the complex number, returns
  an object with properties r and phi.

complex.toString() #

Returns a string representation of the complex number, formatted
  as a + bi where a is the real part and b the imaginary part.

complex.format([precision: number]) #

Get a string representation of the complex number,
  formatted as a + bi where a is the real part and b the imaginary part.
  If precision is defined, the units value will be rounded to the provided
  number of digits.

Static methods #
The following static methods can be accessed using math.Complex

Complex.fromJSON(json) #

Revive a complex number from a JSON object. Accepts
  An object {mathjs: 'Complex', re: number, im: number}, where the property
  mathjs is optional.
  Used when deserializing a complex number, see Serialization.

Complex.fromPolar(r: number, phi: number) #

Create a complex number from polar coordinates.

Complex.compare(a: Complex, b: Complex) #

Returns the comparision result of two complex number:


  Returns 1 when the real part of a is larger than the real part of b
  Returns -1 when the real part of a is smaller than the real part of b
  Returns 1 when the real parts are equal
and the imaginary part of a is larger than the imaginary part of b
  Returns -1 when the real parts are equal
and the imaginary part of a is smaller than the imaginary part of b
  Returns 0 when both real and imaginary parts are equal.


Example:
const a = math.complex(2, 3)   // Complex 2 + 3i
const b = math.complex(2, 1)   // Complex 2 + 1i
math.Complex.compare(a,b) // returns 1

//create from json 
const c = math.Complex.fromJSON({mathjs: 'Complex', re: 4, im: 3})  // Complex 4 + 3i\n\n\n\nComplex Numbers #

Math.js supports the creation, manipulation, and calculations with complex numbers.
Support of complex numbers is powered by the library complex.js.

In mathematics, a complex number is an expression of the form a + bi,
where a and b are real numbers and i represents the imaginary number
defined as i^2 = -1. (In other words, i is the square root of -1.)
The real number a is called the real part of the complex number,
and the real number b is the imaginary part. For example, 3 + 2i is a
complex number, having real part 3 and imaginary part 2.
Complex numbers are often used in applied mathematics, control theory,
signal analysis, fluid dynamics and other fields.

Usage #

A complex number is created using the function math.complex. This function
accepts:


  two numbers representing the real and imaginary part of the value,
  a single string containing a complex value in the form a + bi where a
and b respectively represent the real and imaginary part of the complex number.
  an object with either properties re and im for the real and imaginary
part of the value, or two properties r and phi containing the polar
coordinates of a complex value.
The function returns a Complex object.


Syntax:

math.complex(re: number) : Complex
math.complex(re: number, im: number) : Complex
math.complex(complex: Complex) : Complex
math.complex({re: Number, im: Number}) : Complex
math.complex({r: number, phi: number}) : Complex
math.complex({abs: number, arg: number}) : Complex
math.complex(str: string) : Complex


Examples:

const a = math.complex(2, 3)     // Complex 2 + 3i
a.re                             // Number 2
a.im                             // Number 3

const b = math.complex('4 - 2i') // Complex 4 - 2i
b.re = 5                         // Number 5
b                                // Complex 5 - 2i


Calculations #

Most functions of math.js support complex numbers. Complex and real numbers
can be used together.

const a = math.complex(2, 3)     // Complex 2 + 3i
const b = math.complex('4 - 2i') // Complex 4 - 2i

math.re(a)                       // Number 2
math.im(a)                       // Number 3
math.conj(a)                     // Complex 2 - 3i

math.add(a, b)                   // Complex 6 + i
math.multiply(a, 2)              // Complex 4 + 6i
math.sqrt(-4)                    // Complex 2i


API #
A Complex object created by math.complex contains the following properties and functions:

complex.re #

A number containing the real part of the complex number. Can be read and replaced.

complex.im #

A number containing the imaginary part of the complex number. Can be read and replaced.

complex.clone() #

Create a clone of the complex number.

complex.equals(other) #

Test whether a complex number equals another complex value.

Two complex numbers are equal when both their real and imaginary parts are
  equal.

complex.neg() #

Returns a complex number with a real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.conjugate() #

Returns a complex number with an equal real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.inverse() #

Returns a complex number that is inverse of the current complex number.

complex.toVector() #

Get the vector representation of the current complex number. Returns an array of size 2.

complex.toJSON() #

Returns a JSON representation of the complex number, with signature
  {mathjs: 'Complex', re: number, im: number}.
  Used when serializing a complex number, see Serialization.

complex.toPolar() #

Get the polar coordinates of the complex number, returns
  an object with properties r and phi.

complex.toString() #

Returns a string representation of the complex number, formatted
  as a + bi where a is the real part and b the imaginary part.

complex.format([precision: number]) #

Get a string representation of the complex number,
  formatted as a + bi where a is the real part and b the imaginary part.
  If precision is defined, the units value will be rounded to the provided
  number of digits.

Static methods #
The following static methods can be accessed using math.Complex

Complex.fromJSON(json) #

Revive a complex number from a JSON object. Accepts
  An object {mathjs: 'Complex', re: number, im: number}, where the property
  mathjs is optional.
  Used when deserializing a complex number, see Serialization.

Complex.fromPolar(r: number, phi: number) #

Create a complex number from polar coordinates.

Complex.compare(a: Complex, b: Complex) #

Returns the comparision result of two complex number:


  Returns 1 when the real part of a is larger than the real part of b
  Returns -1 when the real part of a is smaller than the real part of b
  Returns 1 when the real parts are equal
and the imaginary part of a is larger than the imaginary part of b
  Returns -1 when the real parts are equal
and the imaginary part of a is smaller than the imaginary part of b
  Returns 0 when both real and imaginary parts are equal.


Example:
const a = math.complex(2, 3)   // Complex 2 + 3i
const b = math.complex(2, 1)   // Complex 2 + 1i
math.Complex.compare(a,b) // returns 1

//create from json 
const c = math.Complex.fromJSON({mathjs: 'Complex', re: 4, im: 3})  // Complex 4 + 3i\n\n\n\nComplex Numbers #

Math.js supports the creation, manipulation, and calculations with complex numbers.
Support of complex numbers is powered by the library complex.js.

In mathematics, a complex number is an expression of the form a + bi,
where a and b are real numbers and i represents the imaginary number
defined as i^2 = -1. (In other words, i is the square root of -1.)
The real number a is called the real part of the complex number,
and the real number b is the imaginary part. For example, 3 + 2i is a
complex number, having real part 3 and imaginary part 2.
Complex numbers are often used in applied mathematics, control theory,
signal analysis, fluid dynamics and other fields.

Usage #

A complex number is created using the function math.complex. This function
accepts:


  two numbers representing the real and imaginary part of the value,
  a single string containing a complex value in the form a + bi where a
and b respectively represent the real and imaginary part of the complex number.
  an object with either properties re and im for the real and imaginary
part of the value, or two properties r and phi containing the polar
coordinates of a complex value.
The function returns a Complex object.


Syntax:

math.complex(re: number) : Complex
math.complex(re: number, im: number) : Complex
math.complex(complex: Complex) : Complex
math.complex({re: Number, im: Number}) : Complex
math.complex({r: number, phi: number}) : Complex
math.complex({abs: number, arg: number}) : Complex
math.complex(str: string) : Complex


Examples:

const a = math.complex(2, 3)     // Complex 2 + 3i
a.re                             // Number 2
a.im                             // Number 3

const b = math.complex('4 - 2i') // Complex 4 - 2i
b.re = 5                         // Number 5
b                                // Complex 5 - 2i


Calculations #

Most functions of math.js support complex numbers. Complex and real numbers
can be used together.

const a = math.complex(2, 3)     // Complex 2 + 3i
const b = math.complex('4 - 2i') // Complex 4 - 2i

math.re(a)                       // Number 2
math.im(a)                       // Number 3
math.conj(a)                     // Complex 2 - 3i

math.add(a, b)                   // Complex 6 + i
math.multiply(a, 2)              // Complex 4 + 6i
math.sqrt(-4)                    // Complex 2i


API #
A Complex object created by math.complex contains the following properties and functions:

complex.re #

A number containing the real part of the complex number. Can be read and replaced.

complex.im #

A number containing the imaginary part of the complex number. Can be read and replaced.

complex.clone() #

Create a clone of the complex number.

complex.equals(other) #

Test whether a complex number equals another complex value.

Two complex numbers are equal when both their real and imaginary parts are
  equal.

complex.neg() #

Returns a complex number with a real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.conjugate() #

Returns a complex number with an equal real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.inverse() #

Returns a complex number that is inverse of the current complex number.

complex.toVector() #

Get the vector representation of the current complex number. Returns an array of size 2.

complex.toJSON() #

Returns a JSON representation of the complex number, with signature
  {mathjs: 'Complex', re: number, im: number}.
  Used when serializing a complex number, see Serialization.

complex.toPolar() #

Get the polar coordinates of the complex number, returns
  an object with properties r and phi.

complex.toString() #

Returns a string representation of the complex number, formatted
  as a + bi where a is the real part and b the imaginary part.

complex.format([precision: number]) #

Get a string representation of the complex number,
  formatted as a + bi where a is the real part and b the imaginary part.
  If precision is defined, the units value will be rounded to the provided
  number of digits.

Static methods #
The following static methods can be accessed using math.Complex

Complex.fromJSON(json) #

Revive a complex number from a JSON object. Accepts
  An object {mathjs: 'Complex', re: number, im: number}, where the property
  mathjs is optional.
  Used when deserializing a complex number, see Serialization.

Complex.fromPolar(r: number, phi: number) #

Create a complex number from polar coordinates.

Complex.compare(a: Complex, b: Complex) #

Returns the comparision result of two complex number:


  Returns 1 when the real part of a is larger than the real part of b
  Returns -1 when the real part of a is smaller than the real part of b
  Returns 1 when the real parts are equal
and the imaginary part of a is larger than the imaginary part of b
  Returns -1 when the real parts are equal
and the imaginary part of a is smaller than the imaginary part of b
  Returns 0 when both real and imaginary parts are equal.


Example:
const a = math.complex(2, 3)   // Complex 2 + 3i
const b = math.complex(2, 1)   // Complex 2 + 1i
math.Complex.compare(a,b) // returns 1

//create from json 
const c = math.Complex.fromJSON({mathjs: 'Complex', re: 4, im: 3})  // Complex 4 + 3i\n\n\n\nComplex Numbers #

Math.js supports the creation, manipulation, and calculations with complex numbers.
Support of complex numbers is powered by the library complex.js.

In mathematics, a complex number is an expression of the form a + bi,
where a and b are real numbers and i represents the imaginary number
defined as i^2 = -1. (In other words, i is the square root of -1.)
The real number a is called the real part of the complex number,
and the real number b is the imaginary part. For example, 3 + 2i is a
complex number, having real part 3 and imaginary part 2.
Complex numbers are often used in applied mathematics, control theory,
signal analysis, fluid dynamics and other fields.

Usage #

A complex number is created using the function math.complex. This function
accepts:


  two numbers representing the real and imaginary part of the value,
  a single string containing a complex value in the form a + bi where a
and b respectively represent the real and imaginary part of the complex number.
  an object with either properties re and im for the real and imaginary
part of the value, or two properties r and phi containing the polar
coordinates of a complex value.
The function returns a Complex object.


Syntax:

math.complex(re: number) : Complex
math.complex(re: number, im: number) : Complex
math.complex(complex: Complex) : Complex
math.complex({re: Number, im: Number}) : Complex
math.complex({r: number, phi: number}) : Complex
math.complex({abs: number, arg: number}) : Complex
math.complex(str: string) : Complex


Examples:

const a = math.complex(2, 3)     // Complex 2 + 3i
a.re                             // Number 2
a.im                             // Number 3

const b = math.complex('4 - 2i') // Complex 4 - 2i
b.re = 5                         // Number 5
b                                // Complex 5 - 2i


Calculations #

Most functions of math.js support complex numbers. Complex and real numbers
can be used together.

const a = math.complex(2, 3)     // Complex 2 + 3i
const b = math.complex('4 - 2i') // Complex 4 - 2i

math.re(a)                       // Number 2
math.im(a)                       // Number 3
math.conj(a)                     // Complex 2 - 3i

math.add(a, b)                   // Complex 6 + i
math.multiply(a, 2)              // Complex 4 + 6i
math.sqrt(-4)                    // Complex 2i


API #
A Complex object created by math.complex contains the following properties and functions:

complex.re #

A number containing the real part of the complex number. Can be read and replaced.

complex.im #

A number containing the imaginary part of the complex number. Can be read and replaced.

complex.clone() #

Create a clone of the complex number.

complex.equals(other) #

Test whether a complex number equals another complex value.

Two complex numbers are equal when both their real and imaginary parts are
  equal.

complex.neg() #

Returns a complex number with a real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.conjugate() #

Returns a complex number with an equal real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.inverse() #

Returns a complex number that is inverse of the current complex number.

complex.toVector() #

Get the vector representation of the current complex number. Returns an array of size 2.

complex.toJSON() #

Returns a JSON representation of the complex number, with signature
  {mathjs: 'Complex', re: number, im: number}.
  Used when serializing a complex number, see Serialization.

complex.toPolar() #

Get the polar coordinates of the complex number, returns
  an object with properties r and phi.

complex.toString() #

Returns a string representation of the complex number, formatted
  as a + bi where a is the real part and b the imaginary part.

complex.format([precision: number]) #

Get a string representation of the complex number,
  formatted as a + bi where a is the real part and b the imaginary part.
  If precision is defined, the units value will be rounded to the provided
  number of digits.

Static methods #
The following static methods can be accessed using math.Complex

Complex.fromJSON(json) #

Revive a complex number from a JSON object. Accepts
  An object {mathjs: 'Complex', re: number, im: number}, where the property
  mathjs is optional.
  Used when deserializing a complex number, see Serialization.

Complex.fromPolar(r: number, phi: number) #

Create a complex number from polar coordinates.

Complex.compare(a: Complex, b: Complex) #

Returns the comparision result of two complex number:


  Returns 1 when the real part of a is larger than the real part of b
  Returns -1 when the real part of a is smaller than the real part of b
  Returns 1 when the real parts are equal
and the imaginary part of a is larger than the imaginary part of b
  Returns -1 when the real parts are equal
and the imaginary part of a is smaller than the imaginary part of b
  Returns 0 when both real and imaginary parts are equal.


Example:
const a = math.complex(2, 3)   // Complex 2 + 3i
const b = math.complex(2, 1)   // Complex 2 + 1i
math.Complex.compare(a,b) // returns 1

//create from json 
const c = math.Complex.fromJSON({mathjs: 'Complex', re: 4, im: 3})  // Complex 4 + 3i\n\n\n\nComplex Numbers #

Math.js supports the creation, manipulation, and calculations with complex numbers.
Support of complex numbers is powered by the library complex.js.

In mathematics, a complex number is an expression of the form a + bi,
where a and b are real numbers and i represents the imaginary number
defined as i^2 = -1. (In other words, i is the square root of -1.)
The real number a is called the real part of the complex number,
and the real number b is the imaginary part. For example, 3 + 2i is a
complex number, having real part 3 and imaginary part 2.
Complex numbers are often used in applied mathematics, control theory,
signal analysis, fluid dynamics and other fields.

Usage #

A complex number is created using the function math.complex. This function
accepts:


  two numbers representing the real and imaginary part of the value,
  a single string containing a complex value in the form a + bi where a
and b respectively represent the real and imaginary part of the complex number.
  an object with either properties re and im for the real and imaginary
part of the value, or two properties r and phi containing the polar
coordinates of a complex value.
The function returns a Complex object.


Syntax:

math.complex(re: number) : Complex
math.complex(re: number, im: number) : Complex
math.complex(complex: Complex) : Complex
math.complex({re: Number, im: Number}) : Complex
math.complex({r: number, phi: number}) : Complex
math.complex({abs: number, arg: number}) : Complex
math.complex(str: string) : Complex


Examples:

const a = math.complex(2, 3)     // Complex 2 + 3i
a.re                             // Number 2
a.im                             // Number 3

const b = math.complex('4 - 2i') // Complex 4 - 2i
b.re = 5                         // Number 5
b                                // Complex 5 - 2i


Calculations #

Most functions of math.js support complex numbers. Complex and real numbers
can be used together.

const a = math.complex(2, 3)     // Complex 2 + 3i
const b = math.complex('4 - 2i') // Complex 4 - 2i

math.re(a)                       // Number 2
math.im(a)                       // Number 3
math.conj(a)                     // Complex 2 - 3i

math.add(a, b)                   // Complex 6 + i
math.multiply(a, 2)              // Complex 4 + 6i
math.sqrt(-4)                    // Complex 2i


API #
A Complex object created by math.complex contains the following properties and functions:

complex.re #

A number containing the real part of the complex number. Can be read and replaced.

complex.im #

A number containing the imaginary part of the complex number. Can be read and replaced.

complex.clone() #

Create a clone of the complex number.

complex.equals(other) #

Test whether a complex number equals another complex value.

Two complex numbers are equal when both their real and imaginary parts are
  equal.

complex.neg() #

Returns a complex number with a real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.conjugate() #

Returns a complex number with an equal real part and an imaginary part equal in magnitude but opposite in sign to the current complex number.

complex.inverse() #

Returns a complex number that is inverse of the current complex number.

complex.toVector() #

Get the vector representation of the current complex number. Returns an array of size 2.

complex.toJSON() #

Returns a JSON representation of the complex number, with signature
  {mathjs: 'Complex', re: number, im: number}.
  Used when serializing a complex number, see Serialization.

complex.toPolar() #

Get the polar coordinates of the complex number, returns
  an object with properties r and phi.

complex.toString() #

Returns a string representation of the complex number, formatted
  as a + bi where a is the real part and b the imaginary part.

complex.format([precision: number]) #

Get a string representation of the complex number,
  formatted as a + bi where a is the real part and b the imaginary part.
  If precision is defined, the units value will be rounded to the provided
  number of digits.

Static methods #
The following static methods can be accessed using math.Complex

Complex.fromJSON(json) #

Revive a complex number from a JSON object. Accepts
  An object {mathjs: 'Complex', re: number, im: number}, where the property
  mathjs is optional.
  Used when deserializing a complex number, see Serialization.

Complex.fromPolar(r: number, phi: number) #

Create a complex number from polar coordinates.

Complex.compare(a: Complex, b: Complex) #

Returns the comparision result of two complex number:


  Returns 1 when the real part of a is larger than the real part of b
  Returns -1 when the real part of a is smaller than the real part of b
  Returns 1 when the real parts are equal
and the imaginary part of a is larger than the imaginary part of b
  Returns -1 when the real parts are equal
and the imaginary part of a is smaller than the imaginary part of b
  Returns 0 when both real and imaginary parts are equal.


Example:
const a = math.complex(2, 3)   // Complex 2 + 3i
const b = math.complex(2, 1)   // Complex 2 + 1i
math.Complex.compare(a,b) // returns 1

//create from json 
const c = math.Complex.fromJSON({mathjs: 'Complex', re: 4, im: 3})  // Complex 4 + 3i\n\n\n\nMatrices #

Math.js supports multi dimensional matrices and arrays. Matrices can be
created, manipulated, and used in calculations. Both regular JavaScript
arrays as well as the matrix type implemented by math.js can be used
interchangeably in all relevant math.js functions. math.js supports both
dense and sparse matrices.

Arrays and matrices #

Math.js supports two types of matrices:


  Array, a regular JavaScript array. A multi dimensional array can be created
by nesting arrays.
  Matrix, a matrix implementation by math.js. A Matrix is an object wrapped
around a regular JavaScript Array, providing utility functions for easy
matrix manipulation such as subset, size, resize, clone, and more.


In most cases, the type of matrix output from functions is determined by the
function input: An Array as input will return an Array, a Matrix as input
will return a Matrix. In case of mixed input, a Matrix is returned.
For functions where the type of output cannot be determined from the
input, the output is determined by the configuration option matrix,
which can be a string 'Matrix' (default) or 'Array'.

// create an array and a matrix
const array = [[2, 0], [-1, 3]]               // Array
const matrix = math.matrix([[7, 1], [-2, 3]]) // Matrix

// perform a calculation on an array and matrix
math.map(array, math.square)                  // Array,  [[4, 0], [1, 9]]
math.map(matrix, math.square)                 // Matrix, [[49, 1], [4, 9]]

// perform calculations with mixed array and matrix input
math.add(array, matrix)                       // Matrix, [[9, 1], [-3, 6]]
math.multiply(array, matrix)                  // Matrix, [[14, 2], [-13, 8]]

// create a matrix. Type of output of function ones is determined by the
// configuration option `matrix`
math.ones(2, 3)                               // Matrix, [[1, 1, 1], [1, 1, 1]]


Creation #

A matrix can be created from an array using the function math.matrix. The
provided array can contain nested arrays in order to create a multi-dimensional matrix. When called without arguments, an empty matrix will be
created.

// create matrices
math.matrix()                           // Matrix, size [0]
math.matrix([0, 1, 2])                  // Matrix, size [3]
math.matrix([[0, 1], [2, 3], [4, 5]])   // Matrix, size [3, 2]


Math.js supports regular Arrays. Multiple dimensions can be created
by nesting Arrays in each other.

// create arrays
[]                                      // Array, size [0]
[0, 1, 2]                               // Array, size [3]
[[0, 1], [2, 3], [4, 5]]                // Array, size [3, 2]


Matrices can contain different types of values: numbers, complex numbers,
units, or strings. Different types can be mixed together in a single matrix.

// create a matrix with mixed types
const a = math.matrix([2.3, 'hello', math.complex(3, -4), math.unit('5.2 mm')]) 
a.subset(math.index(1))  // 'hello'


There are a number of functions to create a matrix with a specific size and
content: ones, zeros, identity.

// zeros creates a matrix filled with zeros
math.zeros(3)           // Matrix, size [3],    [0, 0, 0]
math.zeros(3, 2)        // Matrix, size [3, 2], [[0, 0], [0, 0], [0, 0]]
math.zeros(2, 2, 2)     // Matrix, size [2, 2, 2],
                        //   [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]

// ones creates a matrix filled with ones
math.ones(3)                        // Matrix, size [3],    [1, 1, 1]
math.multiply(math.ones(2, 2), 5)   // Matrix, size [2, 2], [[5, 5], [5, 5]]

// identity creates an identity matrix
math.identity(3)      // Matrix, size [3, 3], [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
math.identity(2, 3)   // Matrix, size [2, 3], [[1, 0, 0], [0, 1, 0]]


The functions ones, zeros, and identity also accept a single array
or matrix containing the dimensions for the matrix. When the input is an Array,
the functions will output an Array. When the input is a Matrix, the output will
be a Matrix. Note that in case of numbers as arguments, the output is
determined by the option matrix as discussed in section
Arrays and matrices.

// Array as input gives Array as output
math.ones([2, 3])               // Array,  size [3, 2], [[1, 1, 1], [1, 1, 1]]
math.ones(math.matrix([2, 3]))  // Matrix, size [3, 2], [[1, 1, 1], [1, 1, 1]]


Ranges can be created using the function range. The function range is
called with parameters start and end, and optionally a parameter step.
The start of the range is included, the end of the range is excluded.

math.range(0, 4)        // [0, 1, 2, 3]
math.range(0, 8, 2)     // [0, 2, 4, 6]
math.range(3, -1, -1)   // [3, 2, 1, 0]


Calculations #

Most functions of math.js support matrices and arrays. Unary functions can be applied element-wise using via math.map(matrix, function).

// perform an element-wise operation on a matrix using math.map
const a = math.matrix([1, 4, 9, 16, 25])  // Matrix, [1, 4, 9, 16, 25]
math.map(a, math.sqrt)                    // Matrix, [1, 2, 3, 4, 5]

// use a function that has built-in matrix and array support
const b = [1, 2, 3, 4, 5] 
math.factorial(b)                         // Array,  [1, 2, 6, 24, 120]

// multiply an array with a matrix
const c = [[2, 0], [-1, 3]]               // Array
const d = math.matrix([[7, 1], [-2, 3]])  // Matrix
math.multiply(c, d)                       // Matrix, [[14, 2], [-13, 8]]

// add a number to a matrix (see broadcasting)
math.add(c, 2)                            // Array, [[4, 2], [1, 5]]

// calculate the determinant of a matrix
math.det(c)                               // 6
math.det(d)                               // 23

Broadcasting #

Functions that require two or more matrix like arguments that operate elementwise automatically operate as if the arguments were the same size.

A = math.matrix([1, 2])       // Matrix, [1, 2]
math.add(A, 3)                // Matrix, [3, 4]

B = math.matrix([[3], [4]])   // Matrix, [[3], [4]]
math.add(A, B)                // Matrix, [[4, 5], [5, 6]]

Any index that is in one of the arguments, can be found as if it existed on the others when the size on that dimension is one or not existing. This is valid in N dimensions.

It’s not possible to broadcast in cases where the size in that dimension is higher than one.

math.add([1, 2], [3, 4, 5])
// Error: shape missmatch: missmatch is found in arg with shape (2) not possible to broadcast dimension 0 with size 2 to size 3

math.add([[1], [2], [3]], [[4], [5]])
// Error: shape missmatch: missmatch is found in arg with shape (2,1) not possible to broadcast dimension 0 with size 2 to size 3


Size and Dimensions #

Math.js uses geometric dimensions:


  A scalar is zero-dimensional.
  A vector is one-dimensional.
  A matrix is two or multi-dimensional.


The size of a matrix can be calculated with the function size. Function size
returns a Matrix or Array, depending on the configuration option matrix.
Furthermore, matrices have a function size as well, which always returns
an Array.

// get the size of a scalar
math.size(2.4)                                // Matrix, []
math.size(math.complex(3, 2))                 // Matrix, []
math.size(math.unit('5.3 mm'))                // Matrix, []

// get the size of a one-dimensional matrix (a vector) and a string
math.size([0, 1, 2, 3])                       // Array, [4]
math.size('hello world')                      // Matrix, [11]

// get the size of a two-dimensional matrix
const a = [[0, 1, 2, 3]]                      // Array
const b = math.matrix([[0, 1, 2], [3, 4, 5]]) // Matrix
math.size(a)                                  // Array, [1, 4]
math.size(b)                                  // Matrix, [2, 3]

// matrices have a function size (always returns an Array)
b.size()                                      // Array, [2, 3]

// get the size of a multi-dimensional matrix
const c = [[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]
math.size(c)                                  // Array, [2, 2, 3]


Note that the dimensions themselves do not have a meaning attached. 
When creating and printing a two dimensional matrix, the first dimension is 
normally rendered as the column, and the second dimension is rendered as 
the row. For example:

console.table(math.zeros([2, 4]))
// 0 0 0 0
// 0 0 0 0


If you have a matrix where the first dimension means x and the second 
means y, this will look confusing since x is printed as column 
(vertically) and y as row (horizontally).

Resizing #

Matrices can be resized using their resize function. This function is called
with an Array with the new size as the first argument, and accepts an optional
default value. By default, new entries will be set to 0, but it is possible
to pass a different default value like null to clearly indicate that
the entries haven’t been explicitly set.

const a = math.matrix() // Matrix, size [0],       []
a.resize([2, 3])        // Matrix, size [2, 3],    [[0, 0, 0], [0, 0, 0]]
a.resize([2, 2, 2])     // Matrix, size [2, 2, 2],
                        //   [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]

const b = math.matrix()
b.resize([3], 7)        // Matrix, size [3],    [7, 7, 7]
b.resize([5], 9)        // Matrix, size [5],    [7, 7, 7, 9, 9]
b.resize([2])           // Matrix, size [2],    [7, 7]


Outer dimensions of a matrix can be squeezed using the function squeeze. When
getting or setting a single value in a matrix using subset, the value is automatically squeezed
or unsqueezed too.

// squeeze a matrix
const a = [[[0, 1, 2]]]
math.squeeze(a)             // [0, 1, 2]
math.squeeze([[3]])         // 3

// when getting/setting a single value in a matrix using subset, 
// it automatically squeeze/unsqueeze the value
const b = math.matrix([[0, 1], [2, 3]])
b.subset(math.index(1, 0))  // 2 and not [[2]]


Getting or replacing subsets #

Subsets of a matrix can be retrieved or replaced using the function subset.
Matrices have a subset function, which is applied to the matrix itself:
Matrix.subset(index [, replacement]). For both matrices and arrays,
the static function subset(matrix, index [, replacement]) can be used.
When parameter replacement is provided, the function will replace a subset
in the matrix, and if not, a subset of the matrix will be returned.

A subset can be defined using an Index. An Index contains a single value
or a set of values for each dimension of a matrix. An Index can be
created using the function index. When getting a single value from a matrix,
subset will return the value itself instead of a matrix containing just this 
value.

The function subset normally returns a subset, but when getting or setting a
single value in a matrix, the value itself is returned.

Matrix indexes in math.js are zero-based, like most programming languages
including JavaScript itself. Note that mathematical applications like Matlab 
and Octave work differently, as they use one-based indexes.

// create some matrices
const a = [0, 1, 2, 3]
const b = [[0, 1], [2, 3]]
const c = math.zeros(2, 2)
const d = math.matrix([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
const e = math.matrix()

// get a subset
math.subset(a, math.index(1))                 // 1
math.subset(a, math.index([2, 3]))            // Array, [2, 3]
math.subset(a, math.index(math.range(0,4)))   // Array, [0, 1, 2, 3]
math.subset(b, math.index(1, 0))              // 2
math.subset(b, math.index(1, [0, 1]))         // Array, [2, 3]
math.subset(b, math.index([0, 1], 0))         // Matrix, [[0], [2]]

// get a subset
d.subset(math.index([1, 2], [0, 1]))          // Matrix, [[3, 4], [6, 7]]
d.subset(math.index(1, 2))                    // 5

// replace a subset. The subset will be applied to a clone of the matrix
math.subset(b, math.index(1, 0), 9)           // Array, [[0, 1], [9, 3]]
math.subset(b, math.index(2, [0, 1]), [4, 5]) // Array, [[0, 1], [2, 3], [4, 5]]

// replace a subset. The subset will be applied to the matrix itself
c.subset(math.index(0, 1),1)                  // Matrix, [[0, 1], [0, 0]]
c.subset(math.index(1, [0, 1]), [2, 3])       // Matrix, [[0, 1], [2, 3]]
e.resize([2, 3], 0)                           // Matrix, [[0, 0, 0], [0, 0, 0]]
e.subset(math.index(1, 2), 5)                 // Matrix, [[0, 0, 0], [0, 0, 5]]


Getting and setting a value in a matrix #

There are two methods available on matrices that allow to get or set a single 
value inside a matrix. It is important to note that the set method will 
mutate the matrix.

const p = math.matrix([[1, 2], [3, 4]])
p.set([0, 1], 5)
// p is now [[1, 5], [3, 4]]
p.get([1, 0]) // 3


When setting a value at a location outside of the current matrix size using the
method .set(), the matrix will be resized. By default, new items will be 
initialized with zero, but it is possible to specify an alternative value using
the optional third argument defaultValue.

Advanced Indexing #

Boolean array indexing is a technique that allows you to filter, replace, and set values in an array based on logical conditions. This can be done by creating a boolean array that represents the desired conditions, and then using that array as an index to select the elements of the original array that meet those conditions.

For example, a boolean array can be created to represent all the even numbers in an array, and then used to filter the original array to only include the even numbers. Alternatively, a boolean array can be created to represent all the elements of an array that are greater than a certain value, and then used to replace all the elements of the original array that are greater than that value with a new value.

const q = [1, 2, 3, 4]
math.subset(q, math.index([true, false, true, false]))      // Array [1, 3]

// filtering
math.subset(q, math.index(math.larger(q, 2)))               // Array [3, 4]

// filtering with no matches
math.subset(q, math.index(math.larger(q, 5)))               // Array []

// setting specific values, please note that the replacement value is broadcasted
q = math.subset(q, math.index(math.smaller(q, 3)), 0)       // q = [0, 0, 3, 4]

// replacing specific values
math.subset(q, math.index(math.equal(q, 0)), [1, 2])        // q = [1, 2, 3, 4]


The same can be accomplished in the parser in a much more compact manner. Please note that everything after # are comments.
math.evaluate(`
q = [1, 2, 3, 4]
q[[true, false, true, false]] # Matrix [1, 3]
q[q>2]                        # Matrix [3, 4]
q[q>5]                        # Matrix []
q[q <3] = 0                   # q = [0, 0, 3, 4]
q[q==0] = [1, 2]              # q = [1, 2, 3, 4]
`)

The expression inside the index can be as complex as needed as long it evaluates to an array of booleans of the same size.
math.evaluate(`
q = [1, 2, 3, 4]
r = [6, 5, 4, 3]
q[q > 3 and r < 4]     # [4]
`)


Iterating #

Matrices contain functions map and forEach to iterate over all elements of
the (multidimensional) matrix. The callback function of map and forEach has
three parameters: value (the value of the currently iterated element),
index (an array with the index value for each dimension), and matrix (the
matrix being iterated). This syntax is similar to the map and forEach
functions of native JavaScript Arrays, except that the index is no number but
an Array with numbers for each dimension.

const a = math.matrix([[0, 1], [2, 3], [4, 5]])

// The iteration below will output the following in the console:
//    value: 0 index: [0, 0]
//    value: 1 index: [0, 1]
//    value: 2 index: [1, 0]
//    value: 3 index: [1, 1]
//    value: 4 index: [2, 0]
//    value: 5 index: [2, 1]
a.forEach(function (value, index, matrix) {
  console.log('value:', value, 'index:', index) 
}) 

// Apply a transformation on the matrix
const b = a.map(function (value, index, matrix) {
  return math.multiply(math.sin(value), math.exp(math.abs(value))) 
}) 
console.log(b.format(5))  // [[0, 2.2874], [6.7188, 2.8345], [-41.32, -142.32]]

// Create a matrix with the cumulative of all elements
let count = 0
const cum = a.map(function (value, index, matrix) {
  count += value 
  return count 
}) 
console.log(cum.toString())  // [[0, 1], [3, 6], [10, 15]]


Iterating over multiple Matrixes or Arrays #

You can iterate over multiple matrices or arrays by using the map function. Mapping allows to perform element-wise operations on matrices by automatically adjusting their sizes to match each other.

To iterate over multiple matrices, you can use the map function. The map function applies a given function to each element of the matrices and returns a new matrix with the results.

Here’s an example of iterating over two matrices and adding their corresponding elements:

const a = math.matrix([[1, 2], [3, 4]]);
const b = math.matrix([[5, 6], [7, 8]]);

const result = math.map(a, b, (x, y) => x + y);

console.log(result); // [[6, 8], [10, 12]]


In this example, the map function takes matrices as the first two arguments and a callback function (x, y) => x + y as the third argument. The callback function is applied to each element of the matrices, where x represents the corresponding element from matrix a and y represents the corresponding element from matrix b. The result is a new matrix with the element-wise sum of the two matrices.

By using broadcasting and the map function, you can easily iterate over multiple matrices and perform element-wise operations.

const a = math.matrix([10, 20])
const b = math.matrix([[3, 4], [5, 6]])

const result = math.map(a, b, (x, y) => x + y)
console.log(result); // [[13, 24], [15, 26]]


It’s also possible to provide a callback with an index and the broadcasted arrays. Like (valueA, valueB, index) or even (valueA, valueB, index, broadcastedMatrixA, broadcastedMatrixB). There is no specific limit for the number of matrices N that can be mapped. Thus, the callback can have N arguments, N+1 arguments in the case of including the index, or 2N+1 arguments in the case of including the index and the broadcasted matrices in the callback.

At this moment forEach doesn’t include the same functionality.

Storage types #

Math.js supports both dense matrices as well as sparse matrices. Sparse matrices are efficient for matrices largely containing zeros. In that case they save a lot of memory, and calculations can be much faster than for dense matrices.

Math.js supports two type of matrices:


  Dense matrix ('dense', default) A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.
  Sparse matrix ('sparse'): A two dimensional sparse matrix implementation.


The type of matrix can be selected when creating a matrix using the construction functions matrix, diag, identity, ones, and zeros.

// create sparse matrices
const m1 = math.matrix([[0, 1], [0, 0]], 'sparse')
const m2 = math.identity(1000, 1000, 'sparse')


You can also coerce an array or matrix into sparse storage format with the
sparse function.
const md = math.matrix([[0, 1], [0,0]])  // dense
const ms = math.sparse(md)               // sparse


Caution: sparse called on a JavaScript array of n plain numbers produces
a matrix with one column and n rows – in contrast to matrix, which
produces a 1-dimensional matrix object with n entries, i.e., a vector
(not a 1 by n “row vector” nor an n by 1 “column vector”, but just a plain
vector of length n).
const mv = math.matrix([0, 0, 1])  // Has size [3]
const mc = math.sparse([0, 0, 1])  // A "column vector," has size [3, 1]


API #

All relevant functions in math.js support Matrices and Arrays. Functions like math.add and math.subtract, math.sqrt handle matrices element wise. There is a set of functions specifically for creating or manipulating matrices, such as:


  Functions like math.matrix and math.sparse, math.ones, math.zeros, and math.identity to create a matrix.
  Functions like math.subset and math.index to get or replace a part of a matrix
  Functions like math.transpose and math.diag to manipulate matrices.


A full list of matrix functions is available on the functions reference page.

Two types of matrix classes are available in math.js, for storage of dense and sparse matrices. Although they contain public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  DenseMatrix
  SparseMatrix\n\n\n\nMatrices #

Math.js supports multi dimensional matrices and arrays. Matrices can be
created, manipulated, and used in calculations. Both regular JavaScript
arrays as well as the matrix type implemented by math.js can be used
interchangeably in all relevant math.js functions. math.js supports both
dense and sparse matrices.

Arrays and matrices #

Math.js supports two types of matrices:


  Array, a regular JavaScript array. A multi dimensional array can be created
by nesting arrays.
  Matrix, a matrix implementation by math.js. A Matrix is an object wrapped
around a regular JavaScript Array, providing utility functions for easy
matrix manipulation such as subset, size, resize, clone, and more.


In most cases, the type of matrix output from functions is determined by the
function input: An Array as input will return an Array, a Matrix as input
will return a Matrix. In case of mixed input, a Matrix is returned.
For functions where the type of output cannot be determined from the
input, the output is determined by the configuration option matrix,
which can be a string 'Matrix' (default) or 'Array'.

// create an array and a matrix
const array = [[2, 0], [-1, 3]]               // Array
const matrix = math.matrix([[7, 1], [-2, 3]]) // Matrix

// perform a calculation on an array and matrix
math.map(array, math.square)                  // Array,  [[4, 0], [1, 9]]
math.map(matrix, math.square)                 // Matrix, [[49, 1], [4, 9]]

// perform calculations with mixed array and matrix input
math.add(array, matrix)                       // Matrix, [[9, 1], [-3, 6]]
math.multiply(array, matrix)                  // Matrix, [[14, 2], [-13, 8]]

// create a matrix. Type of output of function ones is determined by the
// configuration option `matrix`
math.ones(2, 3)                               // Matrix, [[1, 1, 1], [1, 1, 1]]


Creation #

A matrix can be created from an array using the function math.matrix. The
provided array can contain nested arrays in order to create a multi-dimensional matrix. When called without arguments, an empty matrix will be
created.

// create matrices
math.matrix()                           // Matrix, size [0]
math.matrix([0, 1, 2])                  // Matrix, size [3]
math.matrix([[0, 1], [2, 3], [4, 5]])   // Matrix, size [3, 2]


Math.js supports regular Arrays. Multiple dimensions can be created
by nesting Arrays in each other.

// create arrays
[]                                      // Array, size [0]
[0, 1, 2]                               // Array, size [3]
[[0, 1], [2, 3], [4, 5]]                // Array, size [3, 2]


Matrices can contain different types of values: numbers, complex numbers,
units, or strings. Different types can be mixed together in a single matrix.

// create a matrix with mixed types
const a = math.matrix([2.3, 'hello', math.complex(3, -4), math.unit('5.2 mm')]) 
a.subset(math.index(1))  // 'hello'


There are a number of functions to create a matrix with a specific size and
content: ones, zeros, identity.

// zeros creates a matrix filled with zeros
math.zeros(3)           // Matrix, size [3],    [0, 0, 0]
math.zeros(3, 2)        // Matrix, size [3, 2], [[0, 0], [0, 0], [0, 0]]
math.zeros(2, 2, 2)     // Matrix, size [2, 2, 2],
                        //   [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]

// ones creates a matrix filled with ones
math.ones(3)                        // Matrix, size [3],    [1, 1, 1]
math.multiply(math.ones(2, 2), 5)   // Matrix, size [2, 2], [[5, 5], [5, 5]]

// identity creates an identity matrix
math.identity(3)      // Matrix, size [3, 3], [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
math.identity(2, 3)   // Matrix, size [2, 3], [[1, 0, 0], [0, 1, 0]]


The functions ones, zeros, and identity also accept a single array
or matrix containing the dimensions for the matrix. When the input is an Array,
the functions will output an Array. When the input is a Matrix, the output will
be a Matrix. Note that in case of numbers as arguments, the output is
determined by the option matrix as discussed in section
Arrays and matrices.

// Array as input gives Array as output
math.ones([2, 3])               // Array,  size [3, 2], [[1, 1, 1], [1, 1, 1]]
math.ones(math.matrix([2, 3]))  // Matrix, size [3, 2], [[1, 1, 1], [1, 1, 1]]


Ranges can be created using the function range. The function range is
called with parameters start and end, and optionally a parameter step.
The start of the range is included, the end of the range is excluded.

math.range(0, 4)        // [0, 1, 2, 3]
math.range(0, 8, 2)     // [0, 2, 4, 6]
math.range(3, -1, -1)   // [3, 2, 1, 0]


Calculations #

Most functions of math.js support matrices and arrays. Unary functions can be applied element-wise using via math.map(matrix, function).

// perform an element-wise operation on a matrix using math.map
const a = math.matrix([1, 4, 9, 16, 25])  // Matrix, [1, 4, 9, 16, 25]
math.map(a, math.sqrt)                    // Matrix, [1, 2, 3, 4, 5]

// use a function that has built-in matrix and array support
const b = [1, 2, 3, 4, 5] 
math.factorial(b)                         // Array,  [1, 2, 6, 24, 120]

// multiply an array with a matrix
const c = [[2, 0], [-1, 3]]               // Array
const d = math.matrix([[7, 1], [-2, 3]])  // Matrix
math.multiply(c, d)                       // Matrix, [[14, 2], [-13, 8]]

// add a number to a matrix (see broadcasting)
math.add(c, 2)                            // Array, [[4, 2], [1, 5]]

// calculate the determinant of a matrix
math.det(c)                               // 6
math.det(d)                               // 23

Broadcasting #

Functions that require two or more matrix like arguments that operate elementwise automatically operate as if the arguments were the same size.

A = math.matrix([1, 2])       // Matrix, [1, 2]
math.add(A, 3)                // Matrix, [3, 4]

B = math.matrix([[3], [4]])   // Matrix, [[3], [4]]
math.add(A, B)                // Matrix, [[4, 5], [5, 6]]

Any index that is in one of the arguments, can be found as if it existed on the others when the size on that dimension is one or not existing. This is valid in N dimensions.

It’s not possible to broadcast in cases where the size in that dimension is higher than one.

math.add([1, 2], [3, 4, 5])
// Error: shape missmatch: missmatch is found in arg with shape (2) not possible to broadcast dimension 0 with size 2 to size 3

math.add([[1], [2], [3]], [[4], [5]])
// Error: shape missmatch: missmatch is found in arg with shape (2,1) not possible to broadcast dimension 0 with size 2 to size 3


Size and Dimensions #

Math.js uses geometric dimensions:


  A scalar is zero-dimensional.
  A vector is one-dimensional.
  A matrix is two or multi-dimensional.


The size of a matrix can be calculated with the function size. Function size
returns a Matrix or Array, depending on the configuration option matrix.
Furthermore, matrices have a function size as well, which always returns
an Array.

// get the size of a scalar
math.size(2.4)                                // Matrix, []
math.size(math.complex(3, 2))                 // Matrix, []
math.size(math.unit('5.3 mm'))                // Matrix, []

// get the size of a one-dimensional matrix (a vector) and a string
math.size([0, 1, 2, 3])                       // Array, [4]
math.size('hello world')                      // Matrix, [11]

// get the size of a two-dimensional matrix
const a = [[0, 1, 2, 3]]                      // Array
const b = math.matrix([[0, 1, 2], [3, 4, 5]]) // Matrix
math.size(a)                                  // Array, [1, 4]
math.size(b)                                  // Matrix, [2, 3]

// matrices have a function size (always returns an Array)
b.size()                                      // Array, [2, 3]

// get the size of a multi-dimensional matrix
const c = [[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]
math.size(c)                                  // Array, [2, 2, 3]


Note that the dimensions themselves do not have a meaning attached. 
When creating and printing a two dimensional matrix, the first dimension is 
normally rendered as the column, and the second dimension is rendered as 
the row. For example:

console.table(math.zeros([2, 4]))
// 0 0 0 0
// 0 0 0 0


If you have a matrix where the first dimension means x and the second 
means y, this will look confusing since x is printed as column 
(vertically) and y as row (horizontally).

Resizing #

Matrices can be resized using their resize function. This function is called
with an Array with the new size as the first argument, and accepts an optional
default value. By default, new entries will be set to 0, but it is possible
to pass a different default value like null to clearly indicate that
the entries haven’t been explicitly set.

const a = math.matrix() // Matrix, size [0],       []
a.resize([2, 3])        // Matrix, size [2, 3],    [[0, 0, 0], [0, 0, 0]]
a.resize([2, 2, 2])     // Matrix, size [2, 2, 2],
                        //   [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]

const b = math.matrix()
b.resize([3], 7)        // Matrix, size [3],    [7, 7, 7]
b.resize([5], 9)        // Matrix, size [5],    [7, 7, 7, 9, 9]
b.resize([2])           // Matrix, size [2],    [7, 7]


Outer dimensions of a matrix can be squeezed using the function squeeze. When
getting or setting a single value in a matrix using subset, the value is automatically squeezed
or unsqueezed too.

// squeeze a matrix
const a = [[[0, 1, 2]]]
math.squeeze(a)             // [0, 1, 2]
math.squeeze([[3]])         // 3

// when getting/setting a single value in a matrix using subset, 
// it automatically squeeze/unsqueeze the value
const b = math.matrix([[0, 1], [2, 3]])
b.subset(math.index(1, 0))  // 2 and not [[2]]


Getting or replacing subsets #

Subsets of a matrix can be retrieved or replaced using the function subset.
Matrices have a subset function, which is applied to the matrix itself:
Matrix.subset(index [, replacement]). For both matrices and arrays,
the static function subset(matrix, index [, replacement]) can be used.
When parameter replacement is provided, the function will replace a subset
in the matrix, and if not, a subset of the matrix will be returned.

A subset can be defined using an Index. An Index contains a single value
or a set of values for each dimension of a matrix. An Index can be
created using the function index. When getting a single value from a matrix,
subset will return the value itself instead of a matrix containing just this 
value.

The function subset normally returns a subset, but when getting or setting a
single value in a matrix, the value itself is returned.

Matrix indexes in math.js are zero-based, like most programming languages
including JavaScript itself. Note that mathematical applications like Matlab 
and Octave work differently, as they use one-based indexes.

// create some matrices
const a = [0, 1, 2, 3]
const b = [[0, 1], [2, 3]]
const c = math.zeros(2, 2)
const d = math.matrix([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
const e = math.matrix()

// get a subset
math.subset(a, math.index(1))                 // 1
math.subset(a, math.index([2, 3]))            // Array, [2, 3]
math.subset(a, math.index(math.range(0,4)))   // Array, [0, 1, 2, 3]
math.subset(b, math.index(1, 0))              // 2
math.subset(b, math.index(1, [0, 1]))         // Array, [2, 3]
math.subset(b, math.index([0, 1], 0))         // Matrix, [[0], [2]]

// get a subset
d.subset(math.index([1, 2], [0, 1]))          // Matrix, [[3, 4], [6, 7]]
d.subset(math.index(1, 2))                    // 5

// replace a subset. The subset will be applied to a clone of the matrix
math.subset(b, math.index(1, 0), 9)           // Array, [[0, 1], [9, 3]]
math.subset(b, math.index(2, [0, 1]), [4, 5]) // Array, [[0, 1], [2, 3], [4, 5]]

// replace a subset. The subset will be applied to the matrix itself
c.subset(math.index(0, 1),1)                  // Matrix, [[0, 1], [0, 0]]
c.subset(math.index(1, [0, 1]), [2, 3])       // Matrix, [[0, 1], [2, 3]]
e.resize([2, 3], 0)                           // Matrix, [[0, 0, 0], [0, 0, 0]]
e.subset(math.index(1, 2), 5)                 // Matrix, [[0, 0, 0], [0, 0, 5]]


Getting and setting a value in a matrix #

There are two methods available on matrices that allow to get or set a single 
value inside a matrix. It is important to note that the set method will 
mutate the matrix.

const p = math.matrix([[1, 2], [3, 4]])
p.set([0, 1], 5)
// p is now [[1, 5], [3, 4]]
p.get([1, 0]) // 3


When setting a value at a location outside of the current matrix size using the
method .set(), the matrix will be resized. By default, new items will be 
initialized with zero, but it is possible to specify an alternative value using
the optional third argument defaultValue.

Advanced Indexing #

Boolean array indexing is a technique that allows you to filter, replace, and set values in an array based on logical conditions. This can be done by creating a boolean array that represents the desired conditions, and then using that array as an index to select the elements of the original array that meet those conditions.

For example, a boolean array can be created to represent all the even numbers in an array, and then used to filter the original array to only include the even numbers. Alternatively, a boolean array can be created to represent all the elements of an array that are greater than a certain value, and then used to replace all the elements of the original array that are greater than that value with a new value.

const q = [1, 2, 3, 4]
math.subset(q, math.index([true, false, true, false]))      // Array [1, 3]

// filtering
math.subset(q, math.index(math.larger(q, 2)))               // Array [3, 4]

// filtering with no matches
math.subset(q, math.index(math.larger(q, 5)))               // Array []

// setting specific values, please note that the replacement value is broadcasted
q = math.subset(q, math.index(math.smaller(q, 3)), 0)       // q = [0, 0, 3, 4]

// replacing specific values
math.subset(q, math.index(math.equal(q, 0)), [1, 2])        // q = [1, 2, 3, 4]


The same can be accomplished in the parser in a much more compact manner. Please note that everything after # are comments.
math.evaluate(`
q = [1, 2, 3, 4]
q[[true, false, true, false]] # Matrix [1, 3]
q[q>2]                        # Matrix [3, 4]
q[q>5]                        # Matrix []
q[q <3] = 0                   # q = [0, 0, 3, 4]
q[q==0] = [1, 2]              # q = [1, 2, 3, 4]
`)

The expression inside the index can be as complex as needed as long it evaluates to an array of booleans of the same size.
math.evaluate(`
q = [1, 2, 3, 4]
r = [6, 5, 4, 3]
q[q > 3 and r < 4]     # [4]
`)


Iterating #

Matrices contain functions map and forEach to iterate over all elements of
the (multidimensional) matrix. The callback function of map and forEach has
three parameters: value (the value of the currently iterated element),
index (an array with the index value for each dimension), and matrix (the
matrix being iterated). This syntax is similar to the map and forEach
functions of native JavaScript Arrays, except that the index is no number but
an Array with numbers for each dimension.

const a = math.matrix([[0, 1], [2, 3], [4, 5]])

// The iteration below will output the following in the console:
//    value: 0 index: [0, 0]
//    value: 1 index: [0, 1]
//    value: 2 index: [1, 0]
//    value: 3 index: [1, 1]
//    value: 4 index: [2, 0]
//    value: 5 index: [2, 1]
a.forEach(function (value, index, matrix) {
  console.log('value:', value, 'index:', index) 
}) 

// Apply a transformation on the matrix
const b = a.map(function (value, index, matrix) {
  return math.multiply(math.sin(value), math.exp(math.abs(value))) 
}) 
console.log(b.format(5))  // [[0, 2.2874], [6.7188, 2.8345], [-41.32, -142.32]]

// Create a matrix with the cumulative of all elements
let count = 0
const cum = a.map(function (value, index, matrix) {
  count += value 
  return count 
}) 
console.log(cum.toString())  // [[0, 1], [3, 6], [10, 15]]


Iterating over multiple Matrixes or Arrays #

You can iterate over multiple matrices or arrays by using the map function. Mapping allows to perform element-wise operations on matrices by automatically adjusting their sizes to match each other.

To iterate over multiple matrices, you can use the map function. The map function applies a given function to each element of the matrices and returns a new matrix with the results.

Here’s an example of iterating over two matrices and adding their corresponding elements:

const a = math.matrix([[1, 2], [3, 4]]);
const b = math.matrix([[5, 6], [7, 8]]);

const result = math.map(a, b, (x, y) => x + y);

console.log(result); // [[6, 8], [10, 12]]


In this example, the map function takes matrices as the first two arguments and a callback function (x, y) => x + y as the third argument. The callback function is applied to each element of the matrices, where x represents the corresponding element from matrix a and y represents the corresponding element from matrix b. The result is a new matrix with the element-wise sum of the two matrices.

By using broadcasting and the map function, you can easily iterate over multiple matrices and perform element-wise operations.

const a = math.matrix([10, 20])
const b = math.matrix([[3, 4], [5, 6]])

const result = math.map(a, b, (x, y) => x + y)
console.log(result); // [[13, 24], [15, 26]]


It’s also possible to provide a callback with an index and the broadcasted arrays. Like (valueA, valueB, index) or even (valueA, valueB, index, broadcastedMatrixA, broadcastedMatrixB). There is no specific limit for the number of matrices N that can be mapped. Thus, the callback can have N arguments, N+1 arguments in the case of including the index, or 2N+1 arguments in the case of including the index and the broadcasted matrices in the callback.

At this moment forEach doesn’t include the same functionality.

Storage types #

Math.js supports both dense matrices as well as sparse matrices. Sparse matrices are efficient for matrices largely containing zeros. In that case they save a lot of memory, and calculations can be much faster than for dense matrices.

Math.js supports two type of matrices:


  Dense matrix ('dense', default) A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.
  Sparse matrix ('sparse'): A two dimensional sparse matrix implementation.


The type of matrix can be selected when creating a matrix using the construction functions matrix, diag, identity, ones, and zeros.

// create sparse matrices
const m1 = math.matrix([[0, 1], [0, 0]], 'sparse')
const m2 = math.identity(1000, 1000, 'sparse')


You can also coerce an array or matrix into sparse storage format with the
sparse function.
const md = math.matrix([[0, 1], [0,0]])  // dense
const ms = math.sparse(md)               // sparse


Caution: sparse called on a JavaScript array of n plain numbers produces
a matrix with one column and n rows – in contrast to matrix, which
produces a 1-dimensional matrix object with n entries, i.e., a vector
(not a 1 by n “row vector” nor an n by 1 “column vector”, but just a plain
vector of length n).
const mv = math.matrix([0, 0, 1])  // Has size [3]
const mc = math.sparse([0, 0, 1])  // A "column vector," has size [3, 1]


API #

All relevant functions in math.js support Matrices and Arrays. Functions like math.add and math.subtract, math.sqrt handle matrices element wise. There is a set of functions specifically for creating or manipulating matrices, such as:


  Functions like math.matrix and math.sparse, math.ones, math.zeros, and math.identity to create a matrix.
  Functions like math.subset and math.index to get or replace a part of a matrix
  Functions like math.transpose and math.diag to manipulate matrices.


A full list of matrix functions is available on the functions reference page.

Two types of matrix classes are available in math.js, for storage of dense and sparse matrices. Although they contain public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  DenseMatrix
  SparseMatrix\n\n\n\nMatrices #

Math.js supports multi dimensional matrices and arrays. Matrices can be
created, manipulated, and used in calculations. Both regular JavaScript
arrays as well as the matrix type implemented by math.js can be used
interchangeably in all relevant math.js functions. math.js supports both
dense and sparse matrices.

Arrays and matrices #

Math.js supports two types of matrices:


  Array, a regular JavaScript array. A multi dimensional array can be created
by nesting arrays.
  Matrix, a matrix implementation by math.js. A Matrix is an object wrapped
around a regular JavaScript Array, providing utility functions for easy
matrix manipulation such as subset, size, resize, clone, and more.


In most cases, the type of matrix output from functions is determined by the
function input: An Array as input will return an Array, a Matrix as input
will return a Matrix. In case of mixed input, a Matrix is returned.
For functions where the type of output cannot be determined from the
input, the output is determined by the configuration option matrix,
which can be a string 'Matrix' (default) or 'Array'.

// create an array and a matrix
const array = [[2, 0], [-1, 3]]               // Array
const matrix = math.matrix([[7, 1], [-2, 3]]) // Matrix

// perform a calculation on an array and matrix
math.map(array, math.square)                  // Array,  [[4, 0], [1, 9]]
math.map(matrix, math.square)                 // Matrix, [[49, 1], [4, 9]]

// perform calculations with mixed array and matrix input
math.add(array, matrix)                       // Matrix, [[9, 1], [-3, 6]]
math.multiply(array, matrix)                  // Matrix, [[14, 2], [-13, 8]]

// create a matrix. Type of output of function ones is determined by the
// configuration option `matrix`
math.ones(2, 3)                               // Matrix, [[1, 1, 1], [1, 1, 1]]


Creation #

A matrix can be created from an array using the function math.matrix. The
provided array can contain nested arrays in order to create a multi-dimensional matrix. When called without arguments, an empty matrix will be
created.

// create matrices
math.matrix()                           // Matrix, size [0]
math.matrix([0, 1, 2])                  // Matrix, size [3]
math.matrix([[0, 1], [2, 3], [4, 5]])   // Matrix, size [3, 2]


Math.js supports regular Arrays. Multiple dimensions can be created
by nesting Arrays in each other.

// create arrays
[]                                      // Array, size [0]
[0, 1, 2]                               // Array, size [3]
[[0, 1], [2, 3], [4, 5]]                // Array, size [3, 2]


Matrices can contain different types of values: numbers, complex numbers,
units, or strings. Different types can be mixed together in a single matrix.

// create a matrix with mixed types
const a = math.matrix([2.3, 'hello', math.complex(3, -4), math.unit('5.2 mm')]) 
a.subset(math.index(1))  // 'hello'


There are a number of functions to create a matrix with a specific size and
content: ones, zeros, identity.

// zeros creates a matrix filled with zeros
math.zeros(3)           // Matrix, size [3],    [0, 0, 0]
math.zeros(3, 2)        // Matrix, size [3, 2], [[0, 0], [0, 0], [0, 0]]
math.zeros(2, 2, 2)     // Matrix, size [2, 2, 2],
                        //   [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]

// ones creates a matrix filled with ones
math.ones(3)                        // Matrix, size [3],    [1, 1, 1]
math.multiply(math.ones(2, 2), 5)   // Matrix, size [2, 2], [[5, 5], [5, 5]]

// identity creates an identity matrix
math.identity(3)      // Matrix, size [3, 3], [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
math.identity(2, 3)   // Matrix, size [2, 3], [[1, 0, 0], [0, 1, 0]]


The functions ones, zeros, and identity also accept a single array
or matrix containing the dimensions for the matrix. When the input is an Array,
the functions will output an Array. When the input is a Matrix, the output will
be a Matrix. Note that in case of numbers as arguments, the output is
determined by the option matrix as discussed in section
Arrays and matrices.

// Array as input gives Array as output
math.ones([2, 3])               // Array,  size [3, 2], [[1, 1, 1], [1, 1, 1]]
math.ones(math.matrix([2, 3]))  // Matrix, size [3, 2], [[1, 1, 1], [1, 1, 1]]


Ranges can be created using the function range. The function range is
called with parameters start and end, and optionally a parameter step.
The start of the range is included, the end of the range is excluded.

math.range(0, 4)        // [0, 1, 2, 3]
math.range(0, 8, 2)     // [0, 2, 4, 6]
math.range(3, -1, -1)   // [3, 2, 1, 0]


Calculations #

Most functions of math.js support matrices and arrays. Unary functions can be applied element-wise using via math.map(matrix, function).

// perform an element-wise operation on a matrix using math.map
const a = math.matrix([1, 4, 9, 16, 25])  // Matrix, [1, 4, 9, 16, 25]
math.map(a, math.sqrt)                    // Matrix, [1, 2, 3, 4, 5]

// use a function that has built-in matrix and array support
const b = [1, 2, 3, 4, 5] 
math.factorial(b)                         // Array,  [1, 2, 6, 24, 120]

// multiply an array with a matrix
const c = [[2, 0], [-1, 3]]               // Array
const d = math.matrix([[7, 1], [-2, 3]])  // Matrix
math.multiply(c, d)                       // Matrix, [[14, 2], [-13, 8]]

// add a number to a matrix (see broadcasting)
math.add(c, 2)                            // Array, [[4, 2], [1, 5]]

// calculate the determinant of a matrix
math.det(c)                               // 6
math.det(d)                               // 23

Broadcasting #

Functions that require two or more matrix like arguments that operate elementwise automatically operate as if the arguments were the same size.

A = math.matrix([1, 2])       // Matrix, [1, 2]
math.add(A, 3)                // Matrix, [3, 4]

B = math.matrix([[3], [4]])   // Matrix, [[3], [4]]
math.add(A, B)                // Matrix, [[4, 5], [5, 6]]

Any index that is in one of the arguments, can be found as if it existed on the others when the size on that dimension is one or not existing. This is valid in N dimensions.

It’s not possible to broadcast in cases where the size in that dimension is higher than one.

math.add([1, 2], [3, 4, 5])
// Error: shape missmatch: missmatch is found in arg with shape (2) not possible to broadcast dimension 0 with size 2 to size 3

math.add([[1], [2], [3]], [[4], [5]])
// Error: shape missmatch: missmatch is found in arg with shape (2,1) not possible to broadcast dimension 0 with size 2 to size 3


Size and Dimensions #

Math.js uses geometric dimensions:


  A scalar is zero-dimensional.
  A vector is one-dimensional.
  A matrix is two or multi-dimensional.


The size of a matrix can be calculated with the function size. Function size
returns a Matrix or Array, depending on the configuration option matrix.
Furthermore, matrices have a function size as well, which always returns
an Array.

// get the size of a scalar
math.size(2.4)                                // Matrix, []
math.size(math.complex(3, 2))                 // Matrix, []
math.size(math.unit('5.3 mm'))                // Matrix, []

// get the size of a one-dimensional matrix (a vector) and a string
math.size([0, 1, 2, 3])                       // Array, [4]
math.size('hello world')                      // Matrix, [11]

// get the size of a two-dimensional matrix
const a = [[0, 1, 2, 3]]                      // Array
const b = math.matrix([[0, 1, 2], [3, 4, 5]]) // Matrix
math.size(a)                                  // Array, [1, 4]
math.size(b)                                  // Matrix, [2, 3]

// matrices have a function size (always returns an Array)
b.size()                                      // Array, [2, 3]

// get the size of a multi-dimensional matrix
const c = [[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]
math.size(c)                                  // Array, [2, 2, 3]


Note that the dimensions themselves do not have a meaning attached. 
When creating and printing a two dimensional matrix, the first dimension is 
normally rendered as the column, and the second dimension is rendered as 
the row. For example:

console.table(math.zeros([2, 4]))
// 0 0 0 0
// 0 0 0 0


If you have a matrix where the first dimension means x and the second 
means y, this will look confusing since x is printed as column 
(vertically) and y as row (horizontally).

Resizing #

Matrices can be resized using their resize function. This function is called
with an Array with the new size as the first argument, and accepts an optional
default value. By default, new entries will be set to 0, but it is possible
to pass a different default value like null to clearly indicate that
the entries haven’t been explicitly set.

const a = math.matrix() // Matrix, size [0],       []
a.resize([2, 3])        // Matrix, size [2, 3],    [[0, 0, 0], [0, 0, 0]]
a.resize([2, 2, 2])     // Matrix, size [2, 2, 2],
                        //   [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]

const b = math.matrix()
b.resize([3], 7)        // Matrix, size [3],    [7, 7, 7]
b.resize([5], 9)        // Matrix, size [5],    [7, 7, 7, 9, 9]
b.resize([2])           // Matrix, size [2],    [7, 7]


Outer dimensions of a matrix can be squeezed using the function squeeze. When
getting or setting a single value in a matrix using subset, the value is automatically squeezed
or unsqueezed too.

// squeeze a matrix
const a = [[[0, 1, 2]]]
math.squeeze(a)             // [0, 1, 2]
math.squeeze([[3]])         // 3

// when getting/setting a single value in a matrix using subset, 
// it automatically squeeze/unsqueeze the value
const b = math.matrix([[0, 1], [2, 3]])
b.subset(math.index(1, 0))  // 2 and not [[2]]


Getting or replacing subsets #

Subsets of a matrix can be retrieved or replaced using the function subset.
Matrices have a subset function, which is applied to the matrix itself:
Matrix.subset(index [, replacement]). For both matrices and arrays,
the static function subset(matrix, index [, replacement]) can be used.
When parameter replacement is provided, the function will replace a subset
in the matrix, and if not, a subset of the matrix will be returned.

A subset can be defined using an Index. An Index contains a single value
or a set of values for each dimension of a matrix. An Index can be
created using the function index. When getting a single value from a matrix,
subset will return the value itself instead of a matrix containing just this 
value.

The function subset normally returns a subset, but when getting or setting a
single value in a matrix, the value itself is returned.

Matrix indexes in math.js are zero-based, like most programming languages
including JavaScript itself. Note that mathematical applications like Matlab 
and Octave work differently, as they use one-based indexes.

// create some matrices
const a = [0, 1, 2, 3]
const b = [[0, 1], [2, 3]]
const c = math.zeros(2, 2)
const d = math.matrix([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
const e = math.matrix()

// get a subset
math.subset(a, math.index(1))                 // 1
math.subset(a, math.index([2, 3]))            // Array, [2, 3]
math.subset(a, math.index(math.range(0,4)))   // Array, [0, 1, 2, 3]
math.subset(b, math.index(1, 0))              // 2
math.subset(b, math.index(1, [0, 1]))         // Array, [2, 3]
math.subset(b, math.index([0, 1], 0))         // Matrix, [[0], [2]]

// get a subset
d.subset(math.index([1, 2], [0, 1]))          // Matrix, [[3, 4], [6, 7]]
d.subset(math.index(1, 2))                    // 5

// replace a subset. The subset will be applied to a clone of the matrix
math.subset(b, math.index(1, 0), 9)           // Array, [[0, 1], [9, 3]]
math.subset(b, math.index(2, [0, 1]), [4, 5]) // Array, [[0, 1], [2, 3], [4, 5]]

// replace a subset. The subset will be applied to the matrix itself
c.subset(math.index(0, 1),1)                  // Matrix, [[0, 1], [0, 0]]
c.subset(math.index(1, [0, 1]), [2, 3])       // Matrix, [[0, 1], [2, 3]]
e.resize([2, 3], 0)                           // Matrix, [[0, 0, 0], [0, 0, 0]]
e.subset(math.index(1, 2), 5)                 // Matrix, [[0, 0, 0], [0, 0, 5]]


Getting and setting a value in a matrix #

There are two methods available on matrices that allow to get or set a single 
value inside a matrix. It is important to note that the set method will 
mutate the matrix.

const p = math.matrix([[1, 2], [3, 4]])
p.set([0, 1], 5)
// p is now [[1, 5], [3, 4]]
p.get([1, 0]) // 3


When setting a value at a location outside of the current matrix size using the
method .set(), the matrix will be resized. By default, new items will be 
initialized with zero, but it is possible to specify an alternative value using
the optional third argument defaultValue.

Advanced Indexing #

Boolean array indexing is a technique that allows you to filter, replace, and set values in an array based on logical conditions. This can be done by creating a boolean array that represents the desired conditions, and then using that array as an index to select the elements of the original array that meet those conditions.

For example, a boolean array can be created to represent all the even numbers in an array, and then used to filter the original array to only include the even numbers. Alternatively, a boolean array can be created to represent all the elements of an array that are greater than a certain value, and then used to replace all the elements of the original array that are greater than that value with a new value.

const q = [1, 2, 3, 4]
math.subset(q, math.index([true, false, true, false]))      // Array [1, 3]

// filtering
math.subset(q, math.index(math.larger(q, 2)))               // Array [3, 4]

// filtering with no matches
math.subset(q, math.index(math.larger(q, 5)))               // Array []

// setting specific values, please note that the replacement value is broadcasted
q = math.subset(q, math.index(math.smaller(q, 3)), 0)       // q = [0, 0, 3, 4]

// replacing specific values
math.subset(q, math.index(math.equal(q, 0)), [1, 2])        // q = [1, 2, 3, 4]


The same can be accomplished in the parser in a much more compact manner. Please note that everything after # are comments.
math.evaluate(`
q = [1, 2, 3, 4]
q[[true, false, true, false]] # Matrix [1, 3]
q[q>2]                        # Matrix [3, 4]
q[q>5]                        # Matrix []
q[q <3] = 0                   # q = [0, 0, 3, 4]
q[q==0] = [1, 2]              # q = [1, 2, 3, 4]
`)

The expression inside the index can be as complex as needed as long it evaluates to an array of booleans of the same size.
math.evaluate(`
q = [1, 2, 3, 4]
r = [6, 5, 4, 3]
q[q > 3 and r < 4]     # [4]
`)


Iterating #

Matrices contain functions map and forEach to iterate over all elements of
the (multidimensional) matrix. The callback function of map and forEach has
three parameters: value (the value of the currently iterated element),
index (an array with the index value for each dimension), and matrix (the
matrix being iterated). This syntax is similar to the map and forEach
functions of native JavaScript Arrays, except that the index is no number but
an Array with numbers for each dimension.

const a = math.matrix([[0, 1], [2, 3], [4, 5]])

// The iteration below will output the following in the console:
//    value: 0 index: [0, 0]
//    value: 1 index: [0, 1]
//    value: 2 index: [1, 0]
//    value: 3 index: [1, 1]
//    value: 4 index: [2, 0]
//    value: 5 index: [2, 1]
a.forEach(function (value, index, matrix) {
  console.log('value:', value, 'index:', index) 
}) 

// Apply a transformation on the matrix
const b = a.map(function (value, index, matrix) {
  return math.multiply(math.sin(value), math.exp(math.abs(value))) 
}) 
console.log(b.format(5))  // [[0, 2.2874], [6.7188, 2.8345], [-41.32, -142.32]]

// Create a matrix with the cumulative of all elements
let count = 0
const cum = a.map(function (value, index, matrix) {
  count += value 
  return count 
}) 
console.log(cum.toString())  // [[0, 1], [3, 6], [10, 15]]


Iterating over multiple Matrixes or Arrays #

You can iterate over multiple matrices or arrays by using the map function. Mapping allows to perform element-wise operations on matrices by automatically adjusting their sizes to match each other.

To iterate over multiple matrices, you can use the map function. The map function applies a given function to each element of the matrices and returns a new matrix with the results.

Here’s an example of iterating over two matrices and adding their corresponding elements:

const a = math.matrix([[1, 2], [3, 4]]);
const b = math.matrix([[5, 6], [7, 8]]);

const result = math.map(a, b, (x, y) => x + y);

console.log(result); // [[6, 8], [10, 12]]


In this example, the map function takes matrices as the first two arguments and a callback function (x, y) => x + y as the third argument. The callback function is applied to each element of the matrices, where x represents the corresponding element from matrix a and y represents the corresponding element from matrix b. The result is a new matrix with the element-wise sum of the two matrices.

By using broadcasting and the map function, you can easily iterate over multiple matrices and perform element-wise operations.

const a = math.matrix([10, 20])
const b = math.matrix([[3, 4], [5, 6]])

const result = math.map(a, b, (x, y) => x + y)
console.log(result); // [[13, 24], [15, 26]]


It’s also possible to provide a callback with an index and the broadcasted arrays. Like (valueA, valueB, index) or even (valueA, valueB, index, broadcastedMatrixA, broadcastedMatrixB). There is no specific limit for the number of matrices N that can be mapped. Thus, the callback can have N arguments, N+1 arguments in the case of including the index, or 2N+1 arguments in the case of including the index and the broadcasted matrices in the callback.

At this moment forEach doesn’t include the same functionality.

Storage types #

Math.js supports both dense matrices as well as sparse matrices. Sparse matrices are efficient for matrices largely containing zeros. In that case they save a lot of memory, and calculations can be much faster than for dense matrices.

Math.js supports two type of matrices:


  Dense matrix ('dense', default) A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.
  Sparse matrix ('sparse'): A two dimensional sparse matrix implementation.


The type of matrix can be selected when creating a matrix using the construction functions matrix, diag, identity, ones, and zeros.

// create sparse matrices
const m1 = math.matrix([[0, 1], [0, 0]], 'sparse')
const m2 = math.identity(1000, 1000, 'sparse')


You can also coerce an array or matrix into sparse storage format with the
sparse function.
const md = math.matrix([[0, 1], [0,0]])  // dense
const ms = math.sparse(md)               // sparse


Caution: sparse called on a JavaScript array of n plain numbers produces
a matrix with one column and n rows – in contrast to matrix, which
produces a 1-dimensional matrix object with n entries, i.e., a vector
(not a 1 by n “row vector” nor an n by 1 “column vector”, but just a plain
vector of length n).
const mv = math.matrix([0, 0, 1])  // Has size [3]
const mc = math.sparse([0, 0, 1])  // A "column vector," has size [3, 1]


API #

All relevant functions in math.js support Matrices and Arrays. Functions like math.add and math.subtract, math.sqrt handle matrices element wise. There is a set of functions specifically for creating or manipulating matrices, such as:


  Functions like math.matrix and math.sparse, math.ones, math.zeros, and math.identity to create a matrix.
  Functions like math.subset and math.index to get or replace a part of a matrix
  Functions like math.transpose and math.diag to manipulate matrices.


A full list of matrix functions is available on the functions reference page.

Two types of matrix classes are available in math.js, for storage of dense and sparse matrices. Although they contain public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  DenseMatrix
  SparseMatrix\n\n\n\nMatrices #

Math.js supports multi dimensional matrices and arrays. Matrices can be
created, manipulated, and used in calculations. Both regular JavaScript
arrays as well as the matrix type implemented by math.js can be used
interchangeably in all relevant math.js functions. math.js supports both
dense and sparse matrices.

Arrays and matrices #

Math.js supports two types of matrices:


  Array, a regular JavaScript array. A multi dimensional array can be created
by nesting arrays.
  Matrix, a matrix implementation by math.js. A Matrix is an object wrapped
around a regular JavaScript Array, providing utility functions for easy
matrix manipulation such as subset, size, resize, clone, and more.


In most cases, the type of matrix output from functions is determined by the
function input: An Array as input will return an Array, a Matrix as input
will return a Matrix. In case of mixed input, a Matrix is returned.
For functions where the type of output cannot be determined from the
input, the output is determined by the configuration option matrix,
which can be a string 'Matrix' (default) or 'Array'.

// create an array and a matrix
const array = [[2, 0], [-1, 3]]               // Array
const matrix = math.matrix([[7, 1], [-2, 3]]) // Matrix

// perform a calculation on an array and matrix
math.map(array, math.square)                  // Array,  [[4, 0], [1, 9]]
math.map(matrix, math.square)                 // Matrix, [[49, 1], [4, 9]]

// perform calculations with mixed array and matrix input
math.add(array, matrix)                       // Matrix, [[9, 1], [-3, 6]]
math.multiply(array, matrix)                  // Matrix, [[14, 2], [-13, 8]]

// create a matrix. Type of output of function ones is determined by the
// configuration option `matrix`
math.ones(2, 3)                               // Matrix, [[1, 1, 1], [1, 1, 1]]


Creation #

A matrix can be created from an array using the function math.matrix. The
provided array can contain nested arrays in order to create a multi-dimensional matrix. When called without arguments, an empty matrix will be
created.

// create matrices
math.matrix()                           // Matrix, size [0]
math.matrix([0, 1, 2])                  // Matrix, size [3]
math.matrix([[0, 1], [2, 3], [4, 5]])   // Matrix, size [3, 2]


Math.js supports regular Arrays. Multiple dimensions can be created
by nesting Arrays in each other.

// create arrays
[]                                      // Array, size [0]
[0, 1, 2]                               // Array, size [3]
[[0, 1], [2, 3], [4, 5]]                // Array, size [3, 2]


Matrices can contain different types of values: numbers, complex numbers,
units, or strings. Different types can be mixed together in a single matrix.

// create a matrix with mixed types
const a = math.matrix([2.3, 'hello', math.complex(3, -4), math.unit('5.2 mm')]) 
a.subset(math.index(1))  // 'hello'


There are a number of functions to create a matrix with a specific size and
content: ones, zeros, identity.

// zeros creates a matrix filled with zeros
math.zeros(3)           // Matrix, size [3],    [0, 0, 0]
math.zeros(3, 2)        // Matrix, size [3, 2], [[0, 0], [0, 0], [0, 0]]
math.zeros(2, 2, 2)     // Matrix, size [2, 2, 2],
                        //   [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]

// ones creates a matrix filled with ones
math.ones(3)                        // Matrix, size [3],    [1, 1, 1]
math.multiply(math.ones(2, 2), 5)   // Matrix, size [2, 2], [[5, 5], [5, 5]]

// identity creates an identity matrix
math.identity(3)      // Matrix, size [3, 3], [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
math.identity(2, 3)   // Matrix, size [2, 3], [[1, 0, 0], [0, 1, 0]]


The functions ones, zeros, and identity also accept a single array
or matrix containing the dimensions for the matrix. When the input is an Array,
the functions will output an Array. When the input is a Matrix, the output will
be a Matrix. Note that in case of numbers as arguments, the output is
determined by the option matrix as discussed in section
Arrays and matrices.

// Array as input gives Array as output
math.ones([2, 3])               // Array,  size [3, 2], [[1, 1, 1], [1, 1, 1]]
math.ones(math.matrix([2, 3]))  // Matrix, size [3, 2], [[1, 1, 1], [1, 1, 1]]


Ranges can be created using the function range. The function range is
called with parameters start and end, and optionally a parameter step.
The start of the range is included, the end of the range is excluded.

math.range(0, 4)        // [0, 1, 2, 3]
math.range(0, 8, 2)     // [0, 2, 4, 6]
math.range(3, -1, -1)   // [3, 2, 1, 0]


Calculations #

Most functions of math.js support matrices and arrays. Unary functions can be applied element-wise using via math.map(matrix, function).

// perform an element-wise operation on a matrix using math.map
const a = math.matrix([1, 4, 9, 16, 25])  // Matrix, [1, 4, 9, 16, 25]
math.map(a, math.sqrt)                    // Matrix, [1, 2, 3, 4, 5]

// use a function that has built-in matrix and array support
const b = [1, 2, 3, 4, 5] 
math.factorial(b)                         // Array,  [1, 2, 6, 24, 120]

// multiply an array with a matrix
const c = [[2, 0], [-1, 3]]               // Array
const d = math.matrix([[7, 1], [-2, 3]])  // Matrix
math.multiply(c, d)                       // Matrix, [[14, 2], [-13, 8]]

// add a number to a matrix (see broadcasting)
math.add(c, 2)                            // Array, [[4, 2], [1, 5]]

// calculate the determinant of a matrix
math.det(c)                               // 6
math.det(d)                               // 23

Broadcasting #

Functions that require two or more matrix like arguments that operate elementwise automatically operate as if the arguments were the same size.

A = math.matrix([1, 2])       // Matrix, [1, 2]
math.add(A, 3)                // Matrix, [3, 4]

B = math.matrix([[3], [4]])   // Matrix, [[3], [4]]
math.add(A, B)                // Matrix, [[4, 5], [5, 6]]

Any index that is in one of the arguments, can be found as if it existed on the others when the size on that dimension is one or not existing. This is valid in N dimensions.

It’s not possible to broadcast in cases where the size in that dimension is higher than one.

math.add([1, 2], [3, 4, 5])
// Error: shape missmatch: missmatch is found in arg with shape (2) not possible to broadcast dimension 0 with size 2 to size 3

math.add([[1], [2], [3]], [[4], [5]])
// Error: shape missmatch: missmatch is found in arg with shape (2,1) not possible to broadcast dimension 0 with size 2 to size 3


Size and Dimensions #

Math.js uses geometric dimensions:


  A scalar is zero-dimensional.
  A vector is one-dimensional.
  A matrix is two or multi-dimensional.


The size of a matrix can be calculated with the function size. Function size
returns a Matrix or Array, depending on the configuration option matrix.
Furthermore, matrices have a function size as well, which always returns
an Array.

// get the size of a scalar
math.size(2.4)                                // Matrix, []
math.size(math.complex(3, 2))                 // Matrix, []
math.size(math.unit('5.3 mm'))                // Matrix, []

// get the size of a one-dimensional matrix (a vector) and a string
math.size([0, 1, 2, 3])                       // Array, [4]
math.size('hello world')                      // Matrix, [11]

// get the size of a two-dimensional matrix
const a = [[0, 1, 2, 3]]                      // Array
const b = math.matrix([[0, 1, 2], [3, 4, 5]]) // Matrix
math.size(a)                                  // Array, [1, 4]
math.size(b)                                  // Matrix, [2, 3]

// matrices have a function size (always returns an Array)
b.size()                                      // Array, [2, 3]

// get the size of a multi-dimensional matrix
const c = [[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]
math.size(c)                                  // Array, [2, 2, 3]


Note that the dimensions themselves do not have a meaning attached. 
When creating and printing a two dimensional matrix, the first dimension is 
normally rendered as the column, and the second dimension is rendered as 
the row. For example:

console.table(math.zeros([2, 4]))
// 0 0 0 0
// 0 0 0 0


If you have a matrix where the first dimension means x and the second 
means y, this will look confusing since x is printed as column 
(vertically) and y as row (horizontally).

Resizing #

Matrices can be resized using their resize function. This function is called
with an Array with the new size as the first argument, and accepts an optional
default value. By default, new entries will be set to 0, but it is possible
to pass a different default value like null to clearly indicate that
the entries haven’t been explicitly set.

const a = math.matrix() // Matrix, size [0],       []
a.resize([2, 3])        // Matrix, size [2, 3],    [[0, 0, 0], [0, 0, 0]]
a.resize([2, 2, 2])     // Matrix, size [2, 2, 2],
                        //   [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]

const b = math.matrix()
b.resize([3], 7)        // Matrix, size [3],    [7, 7, 7]
b.resize([5], 9)        // Matrix, size [5],    [7, 7, 7, 9, 9]
b.resize([2])           // Matrix, size [2],    [7, 7]


Outer dimensions of a matrix can be squeezed using the function squeeze. When
getting or setting a single value in a matrix using subset, the value is automatically squeezed
or unsqueezed too.

// squeeze a matrix
const a = [[[0, 1, 2]]]
math.squeeze(a)             // [0, 1, 2]
math.squeeze([[3]])         // 3

// when getting/setting a single value in a matrix using subset, 
// it automatically squeeze/unsqueeze the value
const b = math.matrix([[0, 1], [2, 3]])
b.subset(math.index(1, 0))  // 2 and not [[2]]


Getting or replacing subsets #

Subsets of a matrix can be retrieved or replaced using the function subset.
Matrices have a subset function, which is applied to the matrix itself:
Matrix.subset(index [, replacement]). For both matrices and arrays,
the static function subset(matrix, index [, replacement]) can be used.
When parameter replacement is provided, the function will replace a subset
in the matrix, and if not, a subset of the matrix will be returned.

A subset can be defined using an Index. An Index contains a single value
or a set of values for each dimension of a matrix. An Index can be
created using the function index. When getting a single value from a matrix,
subset will return the value itself instead of a matrix containing just this 
value.

The function subset normally returns a subset, but when getting or setting a
single value in a matrix, the value itself is returned.

Matrix indexes in math.js are zero-based, like most programming languages
including JavaScript itself. Note that mathematical applications like Matlab 
and Octave work differently, as they use one-based indexes.

// create some matrices
const a = [0, 1, 2, 3]
const b = [[0, 1], [2, 3]]
const c = math.zeros(2, 2)
const d = math.matrix([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
const e = math.matrix()

// get a subset
math.subset(a, math.index(1))                 // 1
math.subset(a, math.index([2, 3]))            // Array, [2, 3]
math.subset(a, math.index(math.range(0,4)))   // Array, [0, 1, 2, 3]
math.subset(b, math.index(1, 0))              // 2
math.subset(b, math.index(1, [0, 1]))         // Array, [2, 3]
math.subset(b, math.index([0, 1], 0))         // Matrix, [[0], [2]]

// get a subset
d.subset(math.index([1, 2], [0, 1]))          // Matrix, [[3, 4], [6, 7]]
d.subset(math.index(1, 2))                    // 5

// replace a subset. The subset will be applied to a clone of the matrix
math.subset(b, math.index(1, 0), 9)           // Array, [[0, 1], [9, 3]]
math.subset(b, math.index(2, [0, 1]), [4, 5]) // Array, [[0, 1], [2, 3], [4, 5]]

// replace a subset. The subset will be applied to the matrix itself
c.subset(math.index(0, 1),1)                  // Matrix, [[0, 1], [0, 0]]
c.subset(math.index(1, [0, 1]), [2, 3])       // Matrix, [[0, 1], [2, 3]]
e.resize([2, 3], 0)                           // Matrix, [[0, 0, 0], [0, 0, 0]]
e.subset(math.index(1, 2), 5)                 // Matrix, [[0, 0, 0], [0, 0, 5]]


Getting and setting a value in a matrix #

There are two methods available on matrices that allow to get or set a single 
value inside a matrix. It is important to note that the set method will 
mutate the matrix.

const p = math.matrix([[1, 2], [3, 4]])
p.set([0, 1], 5)
// p is now [[1, 5], [3, 4]]
p.get([1, 0]) // 3


When setting a value at a location outside of the current matrix size using the
method .set(), the matrix will be resized. By default, new items will be 
initialized with zero, but it is possible to specify an alternative value using
the optional third argument defaultValue.

Advanced Indexing #

Boolean array indexing is a technique that allows you to filter, replace, and set values in an array based on logical conditions. This can be done by creating a boolean array that represents the desired conditions, and then using that array as an index to select the elements of the original array that meet those conditions.

For example, a boolean array can be created to represent all the even numbers in an array, and then used to filter the original array to only include the even numbers. Alternatively, a boolean array can be created to represent all the elements of an array that are greater than a certain value, and then used to replace all the elements of the original array that are greater than that value with a new value.

const q = [1, 2, 3, 4]
math.subset(q, math.index([true, false, true, false]))      // Array [1, 3]

// filtering
math.subset(q, math.index(math.larger(q, 2)))               // Array [3, 4]

// filtering with no matches
math.subset(q, math.index(math.larger(q, 5)))               // Array []

// setting specific values, please note that the replacement value is broadcasted
q = math.subset(q, math.index(math.smaller(q, 3)), 0)       // q = [0, 0, 3, 4]

// replacing specific values
math.subset(q, math.index(math.equal(q, 0)), [1, 2])        // q = [1, 2, 3, 4]


The same can be accomplished in the parser in a much more compact manner. Please note that everything after # are comments.
math.evaluate(`
q = [1, 2, 3, 4]
q[[true, false, true, false]] # Matrix [1, 3]
q[q>2]                        # Matrix [3, 4]
q[q>5]                        # Matrix []
q[q <3] = 0                   # q = [0, 0, 3, 4]
q[q==0] = [1, 2]              # q = [1, 2, 3, 4]
`)

The expression inside the index can be as complex as needed as long it evaluates to an array of booleans of the same size.
math.evaluate(`
q = [1, 2, 3, 4]
r = [6, 5, 4, 3]
q[q > 3 and r < 4]     # [4]
`)


Iterating #

Matrices contain functions map and forEach to iterate over all elements of
the (multidimensional) matrix. The callback function of map and forEach has
three parameters: value (the value of the currently iterated element),
index (an array with the index value for each dimension), and matrix (the
matrix being iterated). This syntax is similar to the map and forEach
functions of native JavaScript Arrays, except that the index is no number but
an Array with numbers for each dimension.

const a = math.matrix([[0, 1], [2, 3], [4, 5]])

// The iteration below will output the following in the console:
//    value: 0 index: [0, 0]
//    value: 1 index: [0, 1]
//    value: 2 index: [1, 0]
//    value: 3 index: [1, 1]
//    value: 4 index: [2, 0]
//    value: 5 index: [2, 1]
a.forEach(function (value, index, matrix) {
  console.log('value:', value, 'index:', index) 
}) 

// Apply a transformation on the matrix
const b = a.map(function (value, index, matrix) {
  return math.multiply(math.sin(value), math.exp(math.abs(value))) 
}) 
console.log(b.format(5))  // [[0, 2.2874], [6.7188, 2.8345], [-41.32, -142.32]]

// Create a matrix with the cumulative of all elements
let count = 0
const cum = a.map(function (value, index, matrix) {
  count += value 
  return count 
}) 
console.log(cum.toString())  // [[0, 1], [3, 6], [10, 15]]


Iterating over multiple Matrixes or Arrays #

You can iterate over multiple matrices or arrays by using the map function. Mapping allows to perform element-wise operations on matrices by automatically adjusting their sizes to match each other.

To iterate over multiple matrices, you can use the map function. The map function applies a given function to each element of the matrices and returns a new matrix with the results.

Here’s an example of iterating over two matrices and adding their corresponding elements:

const a = math.matrix([[1, 2], [3, 4]]);
const b = math.matrix([[5, 6], [7, 8]]);

const result = math.map(a, b, (x, y) => x + y);

console.log(result); // [[6, 8], [10, 12]]


In this example, the map function takes matrices as the first two arguments and a callback function (x, y) => x + y as the third argument. The callback function is applied to each element of the matrices, where x represents the corresponding element from matrix a and y represents the corresponding element from matrix b. The result is a new matrix with the element-wise sum of the two matrices.

By using broadcasting and the map function, you can easily iterate over multiple matrices and perform element-wise operations.

const a = math.matrix([10, 20])
const b = math.matrix([[3, 4], [5, 6]])

const result = math.map(a, b, (x, y) => x + y)
console.log(result); // [[13, 24], [15, 26]]


It’s also possible to provide a callback with an index and the broadcasted arrays. Like (valueA, valueB, index) or even (valueA, valueB, index, broadcastedMatrixA, broadcastedMatrixB). There is no specific limit for the number of matrices N that can be mapped. Thus, the callback can have N arguments, N+1 arguments in the case of including the index, or 2N+1 arguments in the case of including the index and the broadcasted matrices in the callback.

At this moment forEach doesn’t include the same functionality.

Storage types #

Math.js supports both dense matrices as well as sparse matrices. Sparse matrices are efficient for matrices largely containing zeros. In that case they save a lot of memory, and calculations can be much faster than for dense matrices.

Math.js supports two type of matrices:


  Dense matrix ('dense', default) A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.
  Sparse matrix ('sparse'): A two dimensional sparse matrix implementation.


The type of matrix can be selected when creating a matrix using the construction functions matrix, diag, identity, ones, and zeros.

// create sparse matrices
const m1 = math.matrix([[0, 1], [0, 0]], 'sparse')
const m2 = math.identity(1000, 1000, 'sparse')


You can also coerce an array or matrix into sparse storage format with the
sparse function.
const md = math.matrix([[0, 1], [0,0]])  // dense
const ms = math.sparse(md)               // sparse


Caution: sparse called on a JavaScript array of n plain numbers produces
a matrix with one column and n rows – in contrast to matrix, which
produces a 1-dimensional matrix object with n entries, i.e., a vector
(not a 1 by n “row vector” nor an n by 1 “column vector”, but just a plain
vector of length n).
const mv = math.matrix([0, 0, 1])  // Has size [3]
const mc = math.sparse([0, 0, 1])  // A "column vector," has size [3, 1]


API #

All relevant functions in math.js support Matrices and Arrays. Functions like math.add and math.subtract, math.sqrt handle matrices element wise. There is a set of functions specifically for creating or manipulating matrices, such as:


  Functions like math.matrix and math.sparse, math.ones, math.zeros, and math.identity to create a matrix.
  Functions like math.subset and math.index to get or replace a part of a matrix
  Functions like math.transpose and math.diag to manipulate matrices.


A full list of matrix functions is available on the functions reference page.

Two types of matrix classes are available in math.js, for storage of dense and sparse matrices. Although they contain public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  DenseMatrix
  SparseMatrix\n\n\n\nMatrices #

Math.js supports multi dimensional matrices and arrays. Matrices can be
created, manipulated, and used in calculations. Both regular JavaScript
arrays as well as the matrix type implemented by math.js can be used
interchangeably in all relevant math.js functions. math.js supports both
dense and sparse matrices.

Arrays and matrices #

Math.js supports two types of matrices:


  Array, a regular JavaScript array. A multi dimensional array can be created
by nesting arrays.
  Matrix, a matrix implementation by math.js. A Matrix is an object wrapped
around a regular JavaScript Array, providing utility functions for easy
matrix manipulation such as subset, size, resize, clone, and more.


In most cases, the type of matrix output from functions is determined by the
function input: An Array as input will return an Array, a Matrix as input
will return a Matrix. In case of mixed input, a Matrix is returned.
For functions where the type of output cannot be determined from the
input, the output is determined by the configuration option matrix,
which can be a string 'Matrix' (default) or 'Array'.

// create an array and a matrix
const array = [[2, 0], [-1, 3]]               // Array
const matrix = math.matrix([[7, 1], [-2, 3]]) // Matrix

// perform a calculation on an array and matrix
math.map(array, math.square)                  // Array,  [[4, 0], [1, 9]]
math.map(matrix, math.square)                 // Matrix, [[49, 1], [4, 9]]

// perform calculations with mixed array and matrix input
math.add(array, matrix)                       // Matrix, [[9, 1], [-3, 6]]
math.multiply(array, matrix)                  // Matrix, [[14, 2], [-13, 8]]

// create a matrix. Type of output of function ones is determined by the
// configuration option `matrix`
math.ones(2, 3)                               // Matrix, [[1, 1, 1], [1, 1, 1]]


Creation #

A matrix can be created from an array using the function math.matrix. The
provided array can contain nested arrays in order to create a multi-dimensional matrix. When called without arguments, an empty matrix will be
created.

// create matrices
math.matrix()                           // Matrix, size [0]
math.matrix([0, 1, 2])                  // Matrix, size [3]
math.matrix([[0, 1], [2, 3], [4, 5]])   // Matrix, size [3, 2]


Math.js supports regular Arrays. Multiple dimensions can be created
by nesting Arrays in each other.

// create arrays
[]                                      // Array, size [0]
[0, 1, 2]                               // Array, size [3]
[[0, 1], [2, 3], [4, 5]]                // Array, size [3, 2]


Matrices can contain different types of values: numbers, complex numbers,
units, or strings. Different types can be mixed together in a single matrix.

// create a matrix with mixed types
const a = math.matrix([2.3, 'hello', math.complex(3, -4), math.unit('5.2 mm')]) 
a.subset(math.index(1))  // 'hello'


There are a number of functions to create a matrix with a specific size and
content: ones, zeros, identity.

// zeros creates a matrix filled with zeros
math.zeros(3)           // Matrix, size [3],    [0, 0, 0]
math.zeros(3, 2)        // Matrix, size [3, 2], [[0, 0], [0, 0], [0, 0]]
math.zeros(2, 2, 2)     // Matrix, size [2, 2, 2],
                        //   [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]

// ones creates a matrix filled with ones
math.ones(3)                        // Matrix, size [3],    [1, 1, 1]
math.multiply(math.ones(2, 2), 5)   // Matrix, size [2, 2], [[5, 5], [5, 5]]

// identity creates an identity matrix
math.identity(3)      // Matrix, size [3, 3], [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
math.identity(2, 3)   // Matrix, size [2, 3], [[1, 0, 0], [0, 1, 0]]


The functions ones, zeros, and identity also accept a single array
or matrix containing the dimensions for the matrix. When the input is an Array,
the functions will output an Array. When the input is a Matrix, the output will
be a Matrix. Note that in case of numbers as arguments, the output is
determined by the option matrix as discussed in section
Arrays and matrices.

// Array as input gives Array as output
math.ones([2, 3])               // Array,  size [3, 2], [[1, 1, 1], [1, 1, 1]]
math.ones(math.matrix([2, 3]))  // Matrix, size [3, 2], [[1, 1, 1], [1, 1, 1]]


Ranges can be created using the function range. The function range is
called with parameters start and end, and optionally a parameter step.
The start of the range is included, the end of the range is excluded.

math.range(0, 4)        // [0, 1, 2, 3]
math.range(0, 8, 2)     // [0, 2, 4, 6]
math.range(3, -1, -1)   // [3, 2, 1, 0]


Calculations #

Most functions of math.js support matrices and arrays. Unary functions can be applied element-wise using via math.map(matrix, function).

// perform an element-wise operation on a matrix using math.map
const a = math.matrix([1, 4, 9, 16, 25])  // Matrix, [1, 4, 9, 16, 25]
math.map(a, math.sqrt)                    // Matrix, [1, 2, 3, 4, 5]

// use a function that has built-in matrix and array support
const b = [1, 2, 3, 4, 5] 
math.factorial(b)                         // Array,  [1, 2, 6, 24, 120]

// multiply an array with a matrix
const c = [[2, 0], [-1, 3]]               // Array
const d = math.matrix([[7, 1], [-2, 3]])  // Matrix
math.multiply(c, d)                       // Matrix, [[14, 2], [-13, 8]]

// add a number to a matrix (see broadcasting)
math.add(c, 2)                            // Array, [[4, 2], [1, 5]]

// calculate the determinant of a matrix
math.det(c)                               // 6
math.det(d)                               // 23

Broadcasting #

Functions that require two or more matrix like arguments that operate elementwise automatically operate as if the arguments were the same size.

A = math.matrix([1, 2])       // Matrix, [1, 2]
math.add(A, 3)                // Matrix, [3, 4]

B = math.matrix([[3], [4]])   // Matrix, [[3], [4]]
math.add(A, B)                // Matrix, [[4, 5], [5, 6]]

Any index that is in one of the arguments, can be found as if it existed on the others when the size on that dimension is one or not existing. This is valid in N dimensions.

It’s not possible to broadcast in cases where the size in that dimension is higher than one.

math.add([1, 2], [3, 4, 5])
// Error: shape missmatch: missmatch is found in arg with shape (2) not possible to broadcast dimension 0 with size 2 to size 3

math.add([[1], [2], [3]], [[4], [5]])
// Error: shape missmatch: missmatch is found in arg with shape (2,1) not possible to broadcast dimension 0 with size 2 to size 3


Size and Dimensions #

Math.js uses geometric dimensions:


  A scalar is zero-dimensional.
  A vector is one-dimensional.
  A matrix is two or multi-dimensional.


The size of a matrix can be calculated with the function size. Function size
returns a Matrix or Array, depending on the configuration option matrix.
Furthermore, matrices have a function size as well, which always returns
an Array.

// get the size of a scalar
math.size(2.4)                                // Matrix, []
math.size(math.complex(3, 2))                 // Matrix, []
math.size(math.unit('5.3 mm'))                // Matrix, []

// get the size of a one-dimensional matrix (a vector) and a string
math.size([0, 1, 2, 3])                       // Array, [4]
math.size('hello world')                      // Matrix, [11]

// get the size of a two-dimensional matrix
const a = [[0, 1, 2, 3]]                      // Array
const b = math.matrix([[0, 1, 2], [3, 4, 5]]) // Matrix
math.size(a)                                  // Array, [1, 4]
math.size(b)                                  // Matrix, [2, 3]

// matrices have a function size (always returns an Array)
b.size()                                      // Array, [2, 3]

// get the size of a multi-dimensional matrix
const c = [[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]
math.size(c)                                  // Array, [2, 2, 3]


Note that the dimensions themselves do not have a meaning attached. 
When creating and printing a two dimensional matrix, the first dimension is 
normally rendered as the column, and the second dimension is rendered as 
the row. For example:

console.table(math.zeros([2, 4]))
// 0 0 0 0
// 0 0 0 0


If you have a matrix where the first dimension means x and the second 
means y, this will look confusing since x is printed as column 
(vertically) and y as row (horizontally).

Resizing #

Matrices can be resized using their resize function. This function is called
with an Array with the new size as the first argument, and accepts an optional
default value. By default, new entries will be set to 0, but it is possible
to pass a different default value like null to clearly indicate that
the entries haven’t been explicitly set.

const a = math.matrix() // Matrix, size [0],       []
a.resize([2, 3])        // Matrix, size [2, 3],    [[0, 0, 0], [0, 0, 0]]
a.resize([2, 2, 2])     // Matrix, size [2, 2, 2],
                        //   [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]

const b = math.matrix()
b.resize([3], 7)        // Matrix, size [3],    [7, 7, 7]
b.resize([5], 9)        // Matrix, size [5],    [7, 7, 7, 9, 9]
b.resize([2])           // Matrix, size [2],    [7, 7]


Outer dimensions of a matrix can be squeezed using the function squeeze. When
getting or setting a single value in a matrix using subset, the value is automatically squeezed
or unsqueezed too.

// squeeze a matrix
const a = [[[0, 1, 2]]]
math.squeeze(a)             // [0, 1, 2]
math.squeeze([[3]])         // 3

// when getting/setting a single value in a matrix using subset, 
// it automatically squeeze/unsqueeze the value
const b = math.matrix([[0, 1], [2, 3]])
b.subset(math.index(1, 0))  // 2 and not [[2]]


Getting or replacing subsets #

Subsets of a matrix can be retrieved or replaced using the function subset.
Matrices have a subset function, which is applied to the matrix itself:
Matrix.subset(index [, replacement]). For both matrices and arrays,
the static function subset(matrix, index [, replacement]) can be used.
When parameter replacement is provided, the function will replace a subset
in the matrix, and if not, a subset of the matrix will be returned.

A subset can be defined using an Index. An Index contains a single value
or a set of values for each dimension of a matrix. An Index can be
created using the function index. When getting a single value from a matrix,
subset will return the value itself instead of a matrix containing just this 
value.

The function subset normally returns a subset, but when getting or setting a
single value in a matrix, the value itself is returned.

Matrix indexes in math.js are zero-based, like most programming languages
including JavaScript itself. Note that mathematical applications like Matlab 
and Octave work differently, as they use one-based indexes.

// create some matrices
const a = [0, 1, 2, 3]
const b = [[0, 1], [2, 3]]
const c = math.zeros(2, 2)
const d = math.matrix([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
const e = math.matrix()

// get a subset
math.subset(a, math.index(1))                 // 1
math.subset(a, math.index([2, 3]))            // Array, [2, 3]
math.subset(a, math.index(math.range(0,4)))   // Array, [0, 1, 2, 3]
math.subset(b, math.index(1, 0))              // 2
math.subset(b, math.index(1, [0, 1]))         // Array, [2, 3]
math.subset(b, math.index([0, 1], 0))         // Matrix, [[0], [2]]

// get a subset
d.subset(math.index([1, 2], [0, 1]))          // Matrix, [[3, 4], [6, 7]]
d.subset(math.index(1, 2))                    // 5

// replace a subset. The subset will be applied to a clone of the matrix
math.subset(b, math.index(1, 0), 9)           // Array, [[0, 1], [9, 3]]
math.subset(b, math.index(2, [0, 1]), [4, 5]) // Array, [[0, 1], [2, 3], [4, 5]]

// replace a subset. The subset will be applied to the matrix itself
c.subset(math.index(0, 1),1)                  // Matrix, [[0, 1], [0, 0]]
c.subset(math.index(1, [0, 1]), [2, 3])       // Matrix, [[0, 1], [2, 3]]
e.resize([2, 3], 0)                           // Matrix, [[0, 0, 0], [0, 0, 0]]
e.subset(math.index(1, 2), 5)                 // Matrix, [[0, 0, 0], [0, 0, 5]]


Getting and setting a value in a matrix #

There are two methods available on matrices that allow to get or set a single 
value inside a matrix. It is important to note that the set method will 
mutate the matrix.

const p = math.matrix([[1, 2], [3, 4]])
p.set([0, 1], 5)
// p is now [[1, 5], [3, 4]]
p.get([1, 0]) // 3


When setting a value at a location outside of the current matrix size using the
method .set(), the matrix will be resized. By default, new items will be 
initialized with zero, but it is possible to specify an alternative value using
the optional third argument defaultValue.

Advanced Indexing #

Boolean array indexing is a technique that allows you to filter, replace, and set values in an array based on logical conditions. This can be done by creating a boolean array that represents the desired conditions, and then using that array as an index to select the elements of the original array that meet those conditions.

For example, a boolean array can be created to represent all the even numbers in an array, and then used to filter the original array to only include the even numbers. Alternatively, a boolean array can be created to represent all the elements of an array that are greater than a certain value, and then used to replace all the elements of the original array that are greater than that value with a new value.

const q = [1, 2, 3, 4]
math.subset(q, math.index([true, false, true, false]))      // Array [1, 3]

// filtering
math.subset(q, math.index(math.larger(q, 2)))               // Array [3, 4]

// filtering with no matches
math.subset(q, math.index(math.larger(q, 5)))               // Array []

// setting specific values, please note that the replacement value is broadcasted
q = math.subset(q, math.index(math.smaller(q, 3)), 0)       // q = [0, 0, 3, 4]

// replacing specific values
math.subset(q, math.index(math.equal(q, 0)), [1, 2])        // q = [1, 2, 3, 4]


The same can be accomplished in the parser in a much more compact manner. Please note that everything after # are comments.
math.evaluate(`
q = [1, 2, 3, 4]
q[[true, false, true, false]] # Matrix [1, 3]
q[q>2]                        # Matrix [3, 4]
q[q>5]                        # Matrix []
q[q <3] = 0                   # q = [0, 0, 3, 4]
q[q==0] = [1, 2]              # q = [1, 2, 3, 4]
`)

The expression inside the index can be as complex as needed as long it evaluates to an array of booleans of the same size.
math.evaluate(`
q = [1, 2, 3, 4]
r = [6, 5, 4, 3]
q[q > 3 and r < 4]     # [4]
`)


Iterating #

Matrices contain functions map and forEach to iterate over all elements of
the (multidimensional) matrix. The callback function of map and forEach has
three parameters: value (the value of the currently iterated element),
index (an array with the index value for each dimension), and matrix (the
matrix being iterated). This syntax is similar to the map and forEach
functions of native JavaScript Arrays, except that the index is no number but
an Array with numbers for each dimension.

const a = math.matrix([[0, 1], [2, 3], [4, 5]])

// The iteration below will output the following in the console:
//    value: 0 index: [0, 0]
//    value: 1 index: [0, 1]
//    value: 2 index: [1, 0]
//    value: 3 index: [1, 1]
//    value: 4 index: [2, 0]
//    value: 5 index: [2, 1]
a.forEach(function (value, index, matrix) {
  console.log('value:', value, 'index:', index) 
}) 

// Apply a transformation on the matrix
const b = a.map(function (value, index, matrix) {
  return math.multiply(math.sin(value), math.exp(math.abs(value))) 
}) 
console.log(b.format(5))  // [[0, 2.2874], [6.7188, 2.8345], [-41.32, -142.32]]

// Create a matrix with the cumulative of all elements
let count = 0
const cum = a.map(function (value, index, matrix) {
  count += value 
  return count 
}) 
console.log(cum.toString())  // [[0, 1], [3, 6], [10, 15]]


Iterating over multiple Matrixes or Arrays #

You can iterate over multiple matrices or arrays by using the map function. Mapping allows to perform element-wise operations on matrices by automatically adjusting their sizes to match each other.

To iterate over multiple matrices, you can use the map function. The map function applies a given function to each element of the matrices and returns a new matrix with the results.

Here’s an example of iterating over two matrices and adding their corresponding elements:

const a = math.matrix([[1, 2], [3, 4]]);
const b = math.matrix([[5, 6], [7, 8]]);

const result = math.map(a, b, (x, y) => x + y);

console.log(result); // [[6, 8], [10, 12]]


In this example, the map function takes matrices as the first two arguments and a callback function (x, y) => x + y as the third argument. The callback function is applied to each element of the matrices, where x represents the corresponding element from matrix a and y represents the corresponding element from matrix b. The result is a new matrix with the element-wise sum of the two matrices.

By using broadcasting and the map function, you can easily iterate over multiple matrices and perform element-wise operations.

const a = math.matrix([10, 20])
const b = math.matrix([[3, 4], [5, 6]])

const result = math.map(a, b, (x, y) => x + y)
console.log(result); // [[13, 24], [15, 26]]


It’s also possible to provide a callback with an index and the broadcasted arrays. Like (valueA, valueB, index) or even (valueA, valueB, index, broadcastedMatrixA, broadcastedMatrixB). There is no specific limit for the number of matrices N that can be mapped. Thus, the callback can have N arguments, N+1 arguments in the case of including the index, or 2N+1 arguments in the case of including the index and the broadcasted matrices in the callback.

At this moment forEach doesn’t include the same functionality.

Storage types #

Math.js supports both dense matrices as well as sparse matrices. Sparse matrices are efficient for matrices largely containing zeros. In that case they save a lot of memory, and calculations can be much faster than for dense matrices.

Math.js supports two type of matrices:


  Dense matrix ('dense', default) A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.
  Sparse matrix ('sparse'): A two dimensional sparse matrix implementation.


The type of matrix can be selected when creating a matrix using the construction functions matrix, diag, identity, ones, and zeros.

// create sparse matrices
const m1 = math.matrix([[0, 1], [0, 0]], 'sparse')
const m2 = math.identity(1000, 1000, 'sparse')


You can also coerce an array or matrix into sparse storage format with the
sparse function.
const md = math.matrix([[0, 1], [0,0]])  // dense
const ms = math.sparse(md)               // sparse


Caution: sparse called on a JavaScript array of n plain numbers produces
a matrix with one column and n rows – in contrast to matrix, which
produces a 1-dimensional matrix object with n entries, i.e., a vector
(not a 1 by n “row vector” nor an n by 1 “column vector”, but just a plain
vector of length n).
const mv = math.matrix([0, 0, 1])  // Has size [3]
const mc = math.sparse([0, 0, 1])  // A "column vector," has size [3, 1]


API #

All relevant functions in math.js support Matrices and Arrays. Functions like math.add and math.subtract, math.sqrt handle matrices element wise. There is a set of functions specifically for creating or manipulating matrices, such as:


  Functions like math.matrix and math.sparse, math.ones, math.zeros, and math.identity to create a matrix.
  Functions like math.subset and math.index to get or replace a part of a matrix
  Functions like math.transpose and math.diag to manipulate matrices.


A full list of matrix functions is available on the functions reference page.

Two types of matrix classes are available in math.js, for storage of dense and sparse matrices. Although they contain public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  DenseMatrix
  SparseMatrix\n\n\n\nMatrices #

Math.js supports multi dimensional matrices and arrays. Matrices can be
created, manipulated, and used in calculations. Both regular JavaScript
arrays as well as the matrix type implemented by math.js can be used
interchangeably in all relevant math.js functions. math.js supports both
dense and sparse matrices.

Arrays and matrices #

Math.js supports two types of matrices:


  Array, a regular JavaScript array. A multi dimensional array can be created
by nesting arrays.
  Matrix, a matrix implementation by math.js. A Matrix is an object wrapped
around a regular JavaScript Array, providing utility functions for easy
matrix manipulation such as subset, size, resize, clone, and more.


In most cases, the type of matrix output from functions is determined by the
function input: An Array as input will return an Array, a Matrix as input
will return a Matrix. In case of mixed input, a Matrix is returned.
For functions where the type of output cannot be determined from the
input, the output is determined by the configuration option matrix,
which can be a string 'Matrix' (default) or 'Array'.

// create an array and a matrix
const array = [[2, 0], [-1, 3]]               // Array
const matrix = math.matrix([[7, 1], [-2, 3]]) // Matrix

// perform a calculation on an array and matrix
math.map(array, math.square)                  // Array,  [[4, 0], [1, 9]]
math.map(matrix, math.square)                 // Matrix, [[49, 1], [4, 9]]

// perform calculations with mixed array and matrix input
math.add(array, matrix)                       // Matrix, [[9, 1], [-3, 6]]
math.multiply(array, matrix)                  // Matrix, [[14, 2], [-13, 8]]

// create a matrix. Type of output of function ones is determined by the
// configuration option `matrix`
math.ones(2, 3)                               // Matrix, [[1, 1, 1], [1, 1, 1]]


Creation #

A matrix can be created from an array using the function math.matrix. The
provided array can contain nested arrays in order to create a multi-dimensional matrix. When called without arguments, an empty matrix will be
created.

// create matrices
math.matrix()                           // Matrix, size [0]
math.matrix([0, 1, 2])                  // Matrix, size [3]
math.matrix([[0, 1], [2, 3], [4, 5]])   // Matrix, size [3, 2]


Math.js supports regular Arrays. Multiple dimensions can be created
by nesting Arrays in each other.

// create arrays
[]                                      // Array, size [0]
[0, 1, 2]                               // Array, size [3]
[[0, 1], [2, 3], [4, 5]]                // Array, size [3, 2]


Matrices can contain different types of values: numbers, complex numbers,
units, or strings. Different types can be mixed together in a single matrix.

// create a matrix with mixed types
const a = math.matrix([2.3, 'hello', math.complex(3, -4), math.unit('5.2 mm')]) 
a.subset(math.index(1))  // 'hello'


There are a number of functions to create a matrix with a specific size and
content: ones, zeros, identity.

// zeros creates a matrix filled with zeros
math.zeros(3)           // Matrix, size [3],    [0, 0, 0]
math.zeros(3, 2)        // Matrix, size [3, 2], [[0, 0], [0, 0], [0, 0]]
math.zeros(2, 2, 2)     // Matrix, size [2, 2, 2],
                        //   [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]

// ones creates a matrix filled with ones
math.ones(3)                        // Matrix, size [3],    [1, 1, 1]
math.multiply(math.ones(2, 2), 5)   // Matrix, size [2, 2], [[5, 5], [5, 5]]

// identity creates an identity matrix
math.identity(3)      // Matrix, size [3, 3], [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
math.identity(2, 3)   // Matrix, size [2, 3], [[1, 0, 0], [0, 1, 0]]


The functions ones, zeros, and identity also accept a single array
or matrix containing the dimensions for the matrix. When the input is an Array,
the functions will output an Array. When the input is a Matrix, the output will
be a Matrix. Note that in case of numbers as arguments, the output is
determined by the option matrix as discussed in section
Arrays and matrices.

// Array as input gives Array as output
math.ones([2, 3])               // Array,  size [3, 2], [[1, 1, 1], [1, 1, 1]]
math.ones(math.matrix([2, 3]))  // Matrix, size [3, 2], [[1, 1, 1], [1, 1, 1]]


Ranges can be created using the function range. The function range is
called with parameters start and end, and optionally a parameter step.
The start of the range is included, the end of the range is excluded.

math.range(0, 4)        // [0, 1, 2, 3]
math.range(0, 8, 2)     // [0, 2, 4, 6]
math.range(3, -1, -1)   // [3, 2, 1, 0]


Calculations #

Most functions of math.js support matrices and arrays. Unary functions can be applied element-wise using via math.map(matrix, function).

// perform an element-wise operation on a matrix using math.map
const a = math.matrix([1, 4, 9, 16, 25])  // Matrix, [1, 4, 9, 16, 25]
math.map(a, math.sqrt)                    // Matrix, [1, 2, 3, 4, 5]

// use a function that has built-in matrix and array support
const b = [1, 2, 3, 4, 5] 
math.factorial(b)                         // Array,  [1, 2, 6, 24, 120]

// multiply an array with a matrix
const c = [[2, 0], [-1, 3]]               // Array
const d = math.matrix([[7, 1], [-2, 3]])  // Matrix
math.multiply(c, d)                       // Matrix, [[14, 2], [-13, 8]]

// add a number to a matrix (see broadcasting)
math.add(c, 2)                            // Array, [[4, 2], [1, 5]]

// calculate the determinant of a matrix
math.det(c)                               // 6
math.det(d)                               // 23

Broadcasting #

Functions that require two or more matrix like arguments that operate elementwise automatically operate as if the arguments were the same size.

A = math.matrix([1, 2])       // Matrix, [1, 2]
math.add(A, 3)                // Matrix, [3, 4]

B = math.matrix([[3], [4]])   // Matrix, [[3], [4]]
math.add(A, B)                // Matrix, [[4, 5], [5, 6]]

Any index that is in one of the arguments, can be found as if it existed on the others when the size on that dimension is one or not existing. This is valid in N dimensions.

It’s not possible to broadcast in cases where the size in that dimension is higher than one.

math.add([1, 2], [3, 4, 5])
// Error: shape missmatch: missmatch is found in arg with shape (2) not possible to broadcast dimension 0 with size 2 to size 3

math.add([[1], [2], [3]], [[4], [5]])
// Error: shape missmatch: missmatch is found in arg with shape (2,1) not possible to broadcast dimension 0 with size 2 to size 3


Size and Dimensions #

Math.js uses geometric dimensions:


  A scalar is zero-dimensional.
  A vector is one-dimensional.
  A matrix is two or multi-dimensional.


The size of a matrix can be calculated with the function size. Function size
returns a Matrix or Array, depending on the configuration option matrix.
Furthermore, matrices have a function size as well, which always returns
an Array.

// get the size of a scalar
math.size(2.4)                                // Matrix, []
math.size(math.complex(3, 2))                 // Matrix, []
math.size(math.unit('5.3 mm'))                // Matrix, []

// get the size of a one-dimensional matrix (a vector) and a string
math.size([0, 1, 2, 3])                       // Array, [4]
math.size('hello world')                      // Matrix, [11]

// get the size of a two-dimensional matrix
const a = [[0, 1, 2, 3]]                      // Array
const b = math.matrix([[0, 1, 2], [3, 4, 5]]) // Matrix
math.size(a)                                  // Array, [1, 4]
math.size(b)                                  // Matrix, [2, 3]

// matrices have a function size (always returns an Array)
b.size()                                      // Array, [2, 3]

// get the size of a multi-dimensional matrix
const c = [[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]
math.size(c)                                  // Array, [2, 2, 3]


Note that the dimensions themselves do not have a meaning attached. 
When creating and printing a two dimensional matrix, the first dimension is 
normally rendered as the column, and the second dimension is rendered as 
the row. For example:

console.table(math.zeros([2, 4]))
// 0 0 0 0
// 0 0 0 0


If you have a matrix where the first dimension means x and the second 
means y, this will look confusing since x is printed as column 
(vertically) and y as row (horizontally).

Resizing #

Matrices can be resized using their resize function. This function is called
with an Array with the new size as the first argument, and accepts an optional
default value. By default, new entries will be set to 0, but it is possible
to pass a different default value like null to clearly indicate that
the entries haven’t been explicitly set.

const a = math.matrix() // Matrix, size [0],       []
a.resize([2, 3])        // Matrix, size [2, 3],    [[0, 0, 0], [0, 0, 0]]
a.resize([2, 2, 2])     // Matrix, size [2, 2, 2],
                        //   [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]

const b = math.matrix()
b.resize([3], 7)        // Matrix, size [3],    [7, 7, 7]
b.resize([5], 9)        // Matrix, size [5],    [7, 7, 7, 9, 9]
b.resize([2])           // Matrix, size [2],    [7, 7]


Outer dimensions of a matrix can be squeezed using the function squeeze. When
getting or setting a single value in a matrix using subset, the value is automatically squeezed
or unsqueezed too.

// squeeze a matrix
const a = [[[0, 1, 2]]]
math.squeeze(a)             // [0, 1, 2]
math.squeeze([[3]])         // 3

// when getting/setting a single value in a matrix using subset, 
// it automatically squeeze/unsqueeze the value
const b = math.matrix([[0, 1], [2, 3]])
b.subset(math.index(1, 0))  // 2 and not [[2]]


Getting or replacing subsets #

Subsets of a matrix can be retrieved or replaced using the function subset.
Matrices have a subset function, which is applied to the matrix itself:
Matrix.subset(index [, replacement]). For both matrices and arrays,
the static function subset(matrix, index [, replacement]) can be used.
When parameter replacement is provided, the function will replace a subset
in the matrix, and if not, a subset of the matrix will be returned.

A subset can be defined using an Index. An Index contains a single value
or a set of values for each dimension of a matrix. An Index can be
created using the function index. When getting a single value from a matrix,
subset will return the value itself instead of a matrix containing just this 
value.

The function subset normally returns a subset, but when getting or setting a
single value in a matrix, the value itself is returned.

Matrix indexes in math.js are zero-based, like most programming languages
including JavaScript itself. Note that mathematical applications like Matlab 
and Octave work differently, as they use one-based indexes.

// create some matrices
const a = [0, 1, 2, 3]
const b = [[0, 1], [2, 3]]
const c = math.zeros(2, 2)
const d = math.matrix([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
const e = math.matrix()

// get a subset
math.subset(a, math.index(1))                 // 1
math.subset(a, math.index([2, 3]))            // Array, [2, 3]
math.subset(a, math.index(math.range(0,4)))   // Array, [0, 1, 2, 3]
math.subset(b, math.index(1, 0))              // 2
math.subset(b, math.index(1, [0, 1]))         // Array, [2, 3]
math.subset(b, math.index([0, 1], 0))         // Matrix, [[0], [2]]

// get a subset
d.subset(math.index([1, 2], [0, 1]))          // Matrix, [[3, 4], [6, 7]]
d.subset(math.index(1, 2))                    // 5

// replace a subset. The subset will be applied to a clone of the matrix
math.subset(b, math.index(1, 0), 9)           // Array, [[0, 1], [9, 3]]
math.subset(b, math.index(2, [0, 1]), [4, 5]) // Array, [[0, 1], [2, 3], [4, 5]]

// replace a subset. The subset will be applied to the matrix itself
c.subset(math.index(0, 1),1)                  // Matrix, [[0, 1], [0, 0]]
c.subset(math.index(1, [0, 1]), [2, 3])       // Matrix, [[0, 1], [2, 3]]
e.resize([2, 3], 0)                           // Matrix, [[0, 0, 0], [0, 0, 0]]
e.subset(math.index(1, 2), 5)                 // Matrix, [[0, 0, 0], [0, 0, 5]]


Getting and setting a value in a matrix #

There are two methods available on matrices that allow to get or set a single 
value inside a matrix. It is important to note that the set method will 
mutate the matrix.

const p = math.matrix([[1, 2], [3, 4]])
p.set([0, 1], 5)
// p is now [[1, 5], [3, 4]]
p.get([1, 0]) // 3


When setting a value at a location outside of the current matrix size using the
method .set(), the matrix will be resized. By default, new items will be 
initialized with zero, but it is possible to specify an alternative value using
the optional third argument defaultValue.

Advanced Indexing #

Boolean array indexing is a technique that allows you to filter, replace, and set values in an array based on logical conditions. This can be done by creating a boolean array that represents the desired conditions, and then using that array as an index to select the elements of the original array that meet those conditions.

For example, a boolean array can be created to represent all the even numbers in an array, and then used to filter the original array to only include the even numbers. Alternatively, a boolean array can be created to represent all the elements of an array that are greater than a certain value, and then used to replace all the elements of the original array that are greater than that value with a new value.

const q = [1, 2, 3, 4]
math.subset(q, math.index([true, false, true, false]))      // Array [1, 3]

// filtering
math.subset(q, math.index(math.larger(q, 2)))               // Array [3, 4]

// filtering with no matches
math.subset(q, math.index(math.larger(q, 5)))               // Array []

// setting specific values, please note that the replacement value is broadcasted
q = math.subset(q, math.index(math.smaller(q, 3)), 0)       // q = [0, 0, 3, 4]

// replacing specific values
math.subset(q, math.index(math.equal(q, 0)), [1, 2])        // q = [1, 2, 3, 4]


The same can be accomplished in the parser in a much more compact manner. Please note that everything after # are comments.
math.evaluate(`
q = [1, 2, 3, 4]
q[[true, false, true, false]] # Matrix [1, 3]
q[q>2]                        # Matrix [3, 4]
q[q>5]                        # Matrix []
q[q <3] = 0                   # q = [0, 0, 3, 4]
q[q==0] = [1, 2]              # q = [1, 2, 3, 4]
`)

The expression inside the index can be as complex as needed as long it evaluates to an array of booleans of the same size.
math.evaluate(`
q = [1, 2, 3, 4]
r = [6, 5, 4, 3]
q[q > 3 and r < 4]     # [4]
`)


Iterating #

Matrices contain functions map and forEach to iterate over all elements of
the (multidimensional) matrix. The callback function of map and forEach has
three parameters: value (the value of the currently iterated element),
index (an array with the index value for each dimension), and matrix (the
matrix being iterated). This syntax is similar to the map and forEach
functions of native JavaScript Arrays, except that the index is no number but
an Array with numbers for each dimension.

const a = math.matrix([[0, 1], [2, 3], [4, 5]])

// The iteration below will output the following in the console:
//    value: 0 index: [0, 0]
//    value: 1 index: [0, 1]
//    value: 2 index: [1, 0]
//    value: 3 index: [1, 1]
//    value: 4 index: [2, 0]
//    value: 5 index: [2, 1]
a.forEach(function (value, index, matrix) {
  console.log('value:', value, 'index:', index) 
}) 

// Apply a transformation on the matrix
const b = a.map(function (value, index, matrix) {
  return math.multiply(math.sin(value), math.exp(math.abs(value))) 
}) 
console.log(b.format(5))  // [[0, 2.2874], [6.7188, 2.8345], [-41.32, -142.32]]

// Create a matrix with the cumulative of all elements
let count = 0
const cum = a.map(function (value, index, matrix) {
  count += value 
  return count 
}) 
console.log(cum.toString())  // [[0, 1], [3, 6], [10, 15]]


Iterating over multiple Matrixes or Arrays #

You can iterate over multiple matrices or arrays by using the map function. Mapping allows to perform element-wise operations on matrices by automatically adjusting their sizes to match each other.

To iterate over multiple matrices, you can use the map function. The map function applies a given function to each element of the matrices and returns a new matrix with the results.

Here’s an example of iterating over two matrices and adding their corresponding elements:

const a = math.matrix([[1, 2], [3, 4]]);
const b = math.matrix([[5, 6], [7, 8]]);

const result = math.map(a, b, (x, y) => x + y);

console.log(result); // [[6, 8], [10, 12]]


In this example, the map function takes matrices as the first two arguments and a callback function (x, y) => x + y as the third argument. The callback function is applied to each element of the matrices, where x represents the corresponding element from matrix a and y represents the corresponding element from matrix b. The result is a new matrix with the element-wise sum of the two matrices.

By using broadcasting and the map function, you can easily iterate over multiple matrices and perform element-wise operations.

const a = math.matrix([10, 20])
const b = math.matrix([[3, 4], [5, 6]])

const result = math.map(a, b, (x, y) => x + y)
console.log(result); // [[13, 24], [15, 26]]


It’s also possible to provide a callback with an index and the broadcasted arrays. Like (valueA, valueB, index) or even (valueA, valueB, index, broadcastedMatrixA, broadcastedMatrixB). There is no specific limit for the number of matrices N that can be mapped. Thus, the callback can have N arguments, N+1 arguments in the case of including the index, or 2N+1 arguments in the case of including the index and the broadcasted matrices in the callback.

At this moment forEach doesn’t include the same functionality.

Storage types #

Math.js supports both dense matrices as well as sparse matrices. Sparse matrices are efficient for matrices largely containing zeros. In that case they save a lot of memory, and calculations can be much faster than for dense matrices.

Math.js supports two type of matrices:


  Dense matrix ('dense', default) A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.
  Sparse matrix ('sparse'): A two dimensional sparse matrix implementation.


The type of matrix can be selected when creating a matrix using the construction functions matrix, diag, identity, ones, and zeros.

// create sparse matrices
const m1 = math.matrix([[0, 1], [0, 0]], 'sparse')
const m2 = math.identity(1000, 1000, 'sparse')


You can also coerce an array or matrix into sparse storage format with the
sparse function.
const md = math.matrix([[0, 1], [0,0]])  // dense
const ms = math.sparse(md)               // sparse


Caution: sparse called on a JavaScript array of n plain numbers produces
a matrix with one column and n rows – in contrast to matrix, which
produces a 1-dimensional matrix object with n entries, i.e., a vector
(not a 1 by n “row vector” nor an n by 1 “column vector”, but just a plain
vector of length n).
const mv = math.matrix([0, 0, 1])  // Has size [3]
const mc = math.sparse([0, 0, 1])  // A "column vector," has size [3, 1]


API #

All relevant functions in math.js support Matrices and Arrays. Functions like math.add and math.subtract, math.sqrt handle matrices element wise. There is a set of functions specifically for creating or manipulating matrices, such as:


  Functions like math.matrix and math.sparse, math.ones, math.zeros, and math.identity to create a matrix.
  Functions like math.subset and math.index to get or replace a part of a matrix
  Functions like math.transpose and math.diag to manipulate matrices.


A full list of matrix functions is available on the functions reference page.

Two types of matrix classes are available in math.js, for storage of dense and sparse matrices. Although they contain public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  DenseMatrix
  SparseMatrix\n\n\n\nMatrices #

Math.js supports multi dimensional matrices and arrays. Matrices can be
created, manipulated, and used in calculations. Both regular JavaScript
arrays as well as the matrix type implemented by math.js can be used
interchangeably in all relevant math.js functions. math.js supports both
dense and sparse matrices.

Arrays and matrices #

Math.js supports two types of matrices:


  Array, a regular JavaScript array. A multi dimensional array can be created
by nesting arrays.
  Matrix, a matrix implementation by math.js. A Matrix is an object wrapped
around a regular JavaScript Array, providing utility functions for easy
matrix manipulation such as subset, size, resize, clone, and more.


In most cases, the type of matrix output from functions is determined by the
function input: An Array as input will return an Array, a Matrix as input
will return a Matrix. In case of mixed input, a Matrix is returned.
For functions where the type of output cannot be determined from the
input, the output is determined by the configuration option matrix,
which can be a string 'Matrix' (default) or 'Array'.

// create an array and a matrix
const array = [[2, 0], [-1, 3]]               // Array
const matrix = math.matrix([[7, 1], [-2, 3]]) // Matrix

// perform a calculation on an array and matrix
math.map(array, math.square)                  // Array,  [[4, 0], [1, 9]]
math.map(matrix, math.square)                 // Matrix, [[49, 1], [4, 9]]

// perform calculations with mixed array and matrix input
math.add(array, matrix)                       // Matrix, [[9, 1], [-3, 6]]
math.multiply(array, matrix)                  // Matrix, [[14, 2], [-13, 8]]

// create a matrix. Type of output of function ones is determined by the
// configuration option `matrix`
math.ones(2, 3)                               // Matrix, [[1, 1, 1], [1, 1, 1]]


Creation #

A matrix can be created from an array using the function math.matrix. The
provided array can contain nested arrays in order to create a multi-dimensional matrix. When called without arguments, an empty matrix will be
created.

// create matrices
math.matrix()                           // Matrix, size [0]
math.matrix([0, 1, 2])                  // Matrix, size [3]
math.matrix([[0, 1], [2, 3], [4, 5]])   // Matrix, size [3, 2]


Math.js supports regular Arrays. Multiple dimensions can be created
by nesting Arrays in each other.

// create arrays
[]                                      // Array, size [0]
[0, 1, 2]                               // Array, size [3]
[[0, 1], [2, 3], [4, 5]]                // Array, size [3, 2]


Matrices can contain different types of values: numbers, complex numbers,
units, or strings. Different types can be mixed together in a single matrix.

// create a matrix with mixed types
const a = math.matrix([2.3, 'hello', math.complex(3, -4), math.unit('5.2 mm')]) 
a.subset(math.index(1))  // 'hello'


There are a number of functions to create a matrix with a specific size and
content: ones, zeros, identity.

// zeros creates a matrix filled with zeros
math.zeros(3)           // Matrix, size [3],    [0, 0, 0]
math.zeros(3, 2)        // Matrix, size [3, 2], [[0, 0], [0, 0], [0, 0]]
math.zeros(2, 2, 2)     // Matrix, size [2, 2, 2],
                        //   [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]

// ones creates a matrix filled with ones
math.ones(3)                        // Matrix, size [3],    [1, 1, 1]
math.multiply(math.ones(2, 2), 5)   // Matrix, size [2, 2], [[5, 5], [5, 5]]

// identity creates an identity matrix
math.identity(3)      // Matrix, size [3, 3], [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
math.identity(2, 3)   // Matrix, size [2, 3], [[1, 0, 0], [0, 1, 0]]


The functions ones, zeros, and identity also accept a single array
or matrix containing the dimensions for the matrix. When the input is an Array,
the functions will output an Array. When the input is a Matrix, the output will
be a Matrix. Note that in case of numbers as arguments, the output is
determined by the option matrix as discussed in section
Arrays and matrices.

// Array as input gives Array as output
math.ones([2, 3])               // Array,  size [3, 2], [[1, 1, 1], [1, 1, 1]]
math.ones(math.matrix([2, 3]))  // Matrix, size [3, 2], [[1, 1, 1], [1, 1, 1]]


Ranges can be created using the function range. The function range is
called with parameters start and end, and optionally a parameter step.
The start of the range is included, the end of the range is excluded.

math.range(0, 4)        // [0, 1, 2, 3]
math.range(0, 8, 2)     // [0, 2, 4, 6]
math.range(3, -1, -1)   // [3, 2, 1, 0]


Calculations #

Most functions of math.js support matrices and arrays. Unary functions can be applied element-wise using via math.map(matrix, function).

// perform an element-wise operation on a matrix using math.map
const a = math.matrix([1, 4, 9, 16, 25])  // Matrix, [1, 4, 9, 16, 25]
math.map(a, math.sqrt)                    // Matrix, [1, 2, 3, 4, 5]

// use a function that has built-in matrix and array support
const b = [1, 2, 3, 4, 5] 
math.factorial(b)                         // Array,  [1, 2, 6, 24, 120]

// multiply an array with a matrix
const c = [[2, 0], [-1, 3]]               // Array
const d = math.matrix([[7, 1], [-2, 3]])  // Matrix
math.multiply(c, d)                       // Matrix, [[14, 2], [-13, 8]]

// add a number to a matrix (see broadcasting)
math.add(c, 2)                            // Array, [[4, 2], [1, 5]]

// calculate the determinant of a matrix
math.det(c)                               // 6
math.det(d)                               // 23

Broadcasting #

Functions that require two or more matrix like arguments that operate elementwise automatically operate as if the arguments were the same size.

A = math.matrix([1, 2])       // Matrix, [1, 2]
math.add(A, 3)                // Matrix, [3, 4]

B = math.matrix([[3], [4]])   // Matrix, [[3], [4]]
math.add(A, B)                // Matrix, [[4, 5], [5, 6]]

Any index that is in one of the arguments, can be found as if it existed on the others when the size on that dimension is one or not existing. This is valid in N dimensions.

It’s not possible to broadcast in cases where the size in that dimension is higher than one.

math.add([1, 2], [3, 4, 5])
// Error: shape missmatch: missmatch is found in arg with shape (2) not possible to broadcast dimension 0 with size 2 to size 3

math.add([[1], [2], [3]], [[4], [5]])
// Error: shape missmatch: missmatch is found in arg with shape (2,1) not possible to broadcast dimension 0 with size 2 to size 3


Size and Dimensions #

Math.js uses geometric dimensions:


  A scalar is zero-dimensional.
  A vector is one-dimensional.
  A matrix is two or multi-dimensional.


The size of a matrix can be calculated with the function size. Function size
returns a Matrix or Array, depending on the configuration option matrix.
Furthermore, matrices have a function size as well, which always returns
an Array.

// get the size of a scalar
math.size(2.4)                                // Matrix, []
math.size(math.complex(3, 2))                 // Matrix, []
math.size(math.unit('5.3 mm'))                // Matrix, []

// get the size of a one-dimensional matrix (a vector) and a string
math.size([0, 1, 2, 3])                       // Array, [4]
math.size('hello world')                      // Matrix, [11]

// get the size of a two-dimensional matrix
const a = [[0, 1, 2, 3]]                      // Array
const b = math.matrix([[0, 1, 2], [3, 4, 5]]) // Matrix
math.size(a)                                  // Array, [1, 4]
math.size(b)                                  // Matrix, [2, 3]

// matrices have a function size (always returns an Array)
b.size()                                      // Array, [2, 3]

// get the size of a multi-dimensional matrix
const c = [[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]
math.size(c)                                  // Array, [2, 2, 3]


Note that the dimensions themselves do not have a meaning attached. 
When creating and printing a two dimensional matrix, the first dimension is 
normally rendered as the column, and the second dimension is rendered as 
the row. For example:

console.table(math.zeros([2, 4]))
// 0 0 0 0
// 0 0 0 0


If you have a matrix where the first dimension means x and the second 
means y, this will look confusing since x is printed as column 
(vertically) and y as row (horizontally).

Resizing #

Matrices can be resized using their resize function. This function is called
with an Array with the new size as the first argument, and accepts an optional
default value. By default, new entries will be set to 0, but it is possible
to pass a different default value like null to clearly indicate that
the entries haven’t been explicitly set.

const a = math.matrix() // Matrix, size [0],       []
a.resize([2, 3])        // Matrix, size [2, 3],    [[0, 0, 0], [0, 0, 0]]
a.resize([2, 2, 2])     // Matrix, size [2, 2, 2],
                        //   [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]

const b = math.matrix()
b.resize([3], 7)        // Matrix, size [3],    [7, 7, 7]
b.resize([5], 9)        // Matrix, size [5],    [7, 7, 7, 9, 9]
b.resize([2])           // Matrix, size [2],    [7, 7]


Outer dimensions of a matrix can be squeezed using the function squeeze. When
getting or setting a single value in a matrix using subset, the value is automatically squeezed
or unsqueezed too.

// squeeze a matrix
const a = [[[0, 1, 2]]]
math.squeeze(a)             // [0, 1, 2]
math.squeeze([[3]])         // 3

// when getting/setting a single value in a matrix using subset, 
// it automatically squeeze/unsqueeze the value
const b = math.matrix([[0, 1], [2, 3]])
b.subset(math.index(1, 0))  // 2 and not [[2]]


Getting or replacing subsets #

Subsets of a matrix can be retrieved or replaced using the function subset.
Matrices have a subset function, which is applied to the matrix itself:
Matrix.subset(index [, replacement]). For both matrices and arrays,
the static function subset(matrix, index [, replacement]) can be used.
When parameter replacement is provided, the function will replace a subset
in the matrix, and if not, a subset of the matrix will be returned.

A subset can be defined using an Index. An Index contains a single value
or a set of values for each dimension of a matrix. An Index can be
created using the function index. When getting a single value from a matrix,
subset will return the value itself instead of a matrix containing just this 
value.

The function subset normally returns a subset, but when getting or setting a
single value in a matrix, the value itself is returned.

Matrix indexes in math.js are zero-based, like most programming languages
including JavaScript itself. Note that mathematical applications like Matlab 
and Octave work differently, as they use one-based indexes.

// create some matrices
const a = [0, 1, 2, 3]
const b = [[0, 1], [2, 3]]
const c = math.zeros(2, 2)
const d = math.matrix([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
const e = math.matrix()

// get a subset
math.subset(a, math.index(1))                 // 1
math.subset(a, math.index([2, 3]))            // Array, [2, 3]
math.subset(a, math.index(math.range(0,4)))   // Array, [0, 1, 2, 3]
math.subset(b, math.index(1, 0))              // 2
math.subset(b, math.index(1, [0, 1]))         // Array, [2, 3]
math.subset(b, math.index([0, 1], 0))         // Matrix, [[0], [2]]

// get a subset
d.subset(math.index([1, 2], [0, 1]))          // Matrix, [[3, 4], [6, 7]]
d.subset(math.index(1, 2))                    // 5

// replace a subset. The subset will be applied to a clone of the matrix
math.subset(b, math.index(1, 0), 9)           // Array, [[0, 1], [9, 3]]
math.subset(b, math.index(2, [0, 1]), [4, 5]) // Array, [[0, 1], [2, 3], [4, 5]]

// replace a subset. The subset will be applied to the matrix itself
c.subset(math.index(0, 1),1)                  // Matrix, [[0, 1], [0, 0]]
c.subset(math.index(1, [0, 1]), [2, 3])       // Matrix, [[0, 1], [2, 3]]
e.resize([2, 3], 0)                           // Matrix, [[0, 0, 0], [0, 0, 0]]
e.subset(math.index(1, 2), 5)                 // Matrix, [[0, 0, 0], [0, 0, 5]]


Getting and setting a value in a matrix #

There are two methods available on matrices that allow to get or set a single 
value inside a matrix. It is important to note that the set method will 
mutate the matrix.

const p = math.matrix([[1, 2], [3, 4]])
p.set([0, 1], 5)
// p is now [[1, 5], [3, 4]]
p.get([1, 0]) // 3


When setting a value at a location outside of the current matrix size using the
method .set(), the matrix will be resized. By default, new items will be 
initialized with zero, but it is possible to specify an alternative value using
the optional third argument defaultValue.

Advanced Indexing #

Boolean array indexing is a technique that allows you to filter, replace, and set values in an array based on logical conditions. This can be done by creating a boolean array that represents the desired conditions, and then using that array as an index to select the elements of the original array that meet those conditions.

For example, a boolean array can be created to represent all the even numbers in an array, and then used to filter the original array to only include the even numbers. Alternatively, a boolean array can be created to represent all the elements of an array that are greater than a certain value, and then used to replace all the elements of the original array that are greater than that value with a new value.

const q = [1, 2, 3, 4]
math.subset(q, math.index([true, false, true, false]))      // Array [1, 3]

// filtering
math.subset(q, math.index(math.larger(q, 2)))               // Array [3, 4]

// filtering with no matches
math.subset(q, math.index(math.larger(q, 5)))               // Array []

// setting specific values, please note that the replacement value is broadcasted
q = math.subset(q, math.index(math.smaller(q, 3)), 0)       // q = [0, 0, 3, 4]

// replacing specific values
math.subset(q, math.index(math.equal(q, 0)), [1, 2])        // q = [1, 2, 3, 4]


The same can be accomplished in the parser in a much more compact manner. Please note that everything after # are comments.
math.evaluate(`
q = [1, 2, 3, 4]
q[[true, false, true, false]] # Matrix [1, 3]
q[q>2]                        # Matrix [3, 4]
q[q>5]                        # Matrix []
q[q <3] = 0                   # q = [0, 0, 3, 4]
q[q==0] = [1, 2]              # q = [1, 2, 3, 4]
`)

The expression inside the index can be as complex as needed as long it evaluates to an array of booleans of the same size.
math.evaluate(`
q = [1, 2, 3, 4]
r = [6, 5, 4, 3]
q[q > 3 and r < 4]     # [4]
`)


Iterating #

Matrices contain functions map and forEach to iterate over all elements of
the (multidimensional) matrix. The callback function of map and forEach has
three parameters: value (the value of the currently iterated element),
index (an array with the index value for each dimension), and matrix (the
matrix being iterated). This syntax is similar to the map and forEach
functions of native JavaScript Arrays, except that the index is no number but
an Array with numbers for each dimension.

const a = math.matrix([[0, 1], [2, 3], [4, 5]])

// The iteration below will output the following in the console:
//    value: 0 index: [0, 0]
//    value: 1 index: [0, 1]
//    value: 2 index: [1, 0]
//    value: 3 index: [1, 1]
//    value: 4 index: [2, 0]
//    value: 5 index: [2, 1]
a.forEach(function (value, index, matrix) {
  console.log('value:', value, 'index:', index) 
}) 

// Apply a transformation on the matrix
const b = a.map(function (value, index, matrix) {
  return math.multiply(math.sin(value), math.exp(math.abs(value))) 
}) 
console.log(b.format(5))  // [[0, 2.2874], [6.7188, 2.8345], [-41.32, -142.32]]

// Create a matrix with the cumulative of all elements
let count = 0
const cum = a.map(function (value, index, matrix) {
  count += value 
  return count 
}) 
console.log(cum.toString())  // [[0, 1], [3, 6], [10, 15]]


Iterating over multiple Matrixes or Arrays #

You can iterate over multiple matrices or arrays by using the map function. Mapping allows to perform element-wise operations on matrices by automatically adjusting their sizes to match each other.

To iterate over multiple matrices, you can use the map function. The map function applies a given function to each element of the matrices and returns a new matrix with the results.

Here’s an example of iterating over two matrices and adding their corresponding elements:

const a = math.matrix([[1, 2], [3, 4]]);
const b = math.matrix([[5, 6], [7, 8]]);

const result = math.map(a, b, (x, y) => x + y);

console.log(result); // [[6, 8], [10, 12]]


In this example, the map function takes matrices as the first two arguments and a callback function (x, y) => x + y as the third argument. The callback function is applied to each element of the matrices, where x represents the corresponding element from matrix a and y represents the corresponding element from matrix b. The result is a new matrix with the element-wise sum of the two matrices.

By using broadcasting and the map function, you can easily iterate over multiple matrices and perform element-wise operations.

const a = math.matrix([10, 20])
const b = math.matrix([[3, 4], [5, 6]])

const result = math.map(a, b, (x, y) => x + y)
console.log(result); // [[13, 24], [15, 26]]


It’s also possible to provide a callback with an index and the broadcasted arrays. Like (valueA, valueB, index) or even (valueA, valueB, index, broadcastedMatrixA, broadcastedMatrixB). There is no specific limit for the number of matrices N that can be mapped. Thus, the callback can have N arguments, N+1 arguments in the case of including the index, or 2N+1 arguments in the case of including the index and the broadcasted matrices in the callback.

At this moment forEach doesn’t include the same functionality.

Storage types #

Math.js supports both dense matrices as well as sparse matrices. Sparse matrices are efficient for matrices largely containing zeros. In that case they save a lot of memory, and calculations can be much faster than for dense matrices.

Math.js supports two type of matrices:


  Dense matrix ('dense', default) A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.
  Sparse matrix ('sparse'): A two dimensional sparse matrix implementation.


The type of matrix can be selected when creating a matrix using the construction functions matrix, diag, identity, ones, and zeros.

// create sparse matrices
const m1 = math.matrix([[0, 1], [0, 0]], 'sparse')
const m2 = math.identity(1000, 1000, 'sparse')


You can also coerce an array or matrix into sparse storage format with the
sparse function.
const md = math.matrix([[0, 1], [0,0]])  // dense
const ms = math.sparse(md)               // sparse


Caution: sparse called on a JavaScript array of n plain numbers produces
a matrix with one column and n rows – in contrast to matrix, which
produces a 1-dimensional matrix object with n entries, i.e., a vector
(not a 1 by n “row vector” nor an n by 1 “column vector”, but just a plain
vector of length n).
const mv = math.matrix([0, 0, 1])  // Has size [3]
const mc = math.sparse([0, 0, 1])  // A "column vector," has size [3, 1]


API #

All relevant functions in math.js support Matrices and Arrays. Functions like math.add and math.subtract, math.sqrt handle matrices element wise. There is a set of functions specifically for creating or manipulating matrices, such as:


  Functions like math.matrix and math.sparse, math.ones, math.zeros, and math.identity to create a matrix.
  Functions like math.subset and math.index to get or replace a part of a matrix
  Functions like math.transpose and math.diag to manipulate matrices.


A full list of matrix functions is available on the functions reference page.

Two types of matrix classes are available in math.js, for storage of dense and sparse matrices. Although they contain public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  DenseMatrix
  SparseMatrix\n\n\n\nMatrices #

Math.js supports multi dimensional matrices and arrays. Matrices can be
created, manipulated, and used in calculations. Both regular JavaScript
arrays as well as the matrix type implemented by math.js can be used
interchangeably in all relevant math.js functions. math.js supports both
dense and sparse matrices.

Arrays and matrices #

Math.js supports two types of matrices:


  Array, a regular JavaScript array. A multi dimensional array can be created
by nesting arrays.
  Matrix, a matrix implementation by math.js. A Matrix is an object wrapped
around a regular JavaScript Array, providing utility functions for easy
matrix manipulation such as subset, size, resize, clone, and more.


In most cases, the type of matrix output from functions is determined by the
function input: An Array as input will return an Array, a Matrix as input
will return a Matrix. In case of mixed input, a Matrix is returned.
For functions where the type of output cannot be determined from the
input, the output is determined by the configuration option matrix,
which can be a string 'Matrix' (default) or 'Array'.

// create an array and a matrix
const array = [[2, 0], [-1, 3]]               // Array
const matrix = math.matrix([[7, 1], [-2, 3]]) // Matrix

// perform a calculation on an array and matrix
math.map(array, math.square)                  // Array,  [[4, 0], [1, 9]]
math.map(matrix, math.square)                 // Matrix, [[49, 1], [4, 9]]

// perform calculations with mixed array and matrix input
math.add(array, matrix)                       // Matrix, [[9, 1], [-3, 6]]
math.multiply(array, matrix)                  // Matrix, [[14, 2], [-13, 8]]

// create a matrix. Type of output of function ones is determined by the
// configuration option `matrix`
math.ones(2, 3)                               // Matrix, [[1, 1, 1], [1, 1, 1]]


Creation #

A matrix can be created from an array using the function math.matrix. The
provided array can contain nested arrays in order to create a multi-dimensional matrix. When called without arguments, an empty matrix will be
created.

// create matrices
math.matrix()                           // Matrix, size [0]
math.matrix([0, 1, 2])                  // Matrix, size [3]
math.matrix([[0, 1], [2, 3], [4, 5]])   // Matrix, size [3, 2]


Math.js supports regular Arrays. Multiple dimensions can be created
by nesting Arrays in each other.

// create arrays
[]                                      // Array, size [0]
[0, 1, 2]                               // Array, size [3]
[[0, 1], [2, 3], [4, 5]]                // Array, size [3, 2]


Matrices can contain different types of values: numbers, complex numbers,
units, or strings. Different types can be mixed together in a single matrix.

// create a matrix with mixed types
const a = math.matrix([2.3, 'hello', math.complex(3, -4), math.unit('5.2 mm')]) 
a.subset(math.index(1))  // 'hello'


There are a number of functions to create a matrix with a specific size and
content: ones, zeros, identity.

// zeros creates a matrix filled with zeros
math.zeros(3)           // Matrix, size [3],    [0, 0, 0]
math.zeros(3, 2)        // Matrix, size [3, 2], [[0, 0], [0, 0], [0, 0]]
math.zeros(2, 2, 2)     // Matrix, size [2, 2, 2],
                        //   [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]

// ones creates a matrix filled with ones
math.ones(3)                        // Matrix, size [3],    [1, 1, 1]
math.multiply(math.ones(2, 2), 5)   // Matrix, size [2, 2], [[5, 5], [5, 5]]

// identity creates an identity matrix
math.identity(3)      // Matrix, size [3, 3], [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
math.identity(2, 3)   // Matrix, size [2, 3], [[1, 0, 0], [0, 1, 0]]


The functions ones, zeros, and identity also accept a single array
or matrix containing the dimensions for the matrix. When the input is an Array,
the functions will output an Array. When the input is a Matrix, the output will
be a Matrix. Note that in case of numbers as arguments, the output is
determined by the option matrix as discussed in section
Arrays and matrices.

// Array as input gives Array as output
math.ones([2, 3])               // Array,  size [3, 2], [[1, 1, 1], [1, 1, 1]]
math.ones(math.matrix([2, 3]))  // Matrix, size [3, 2], [[1, 1, 1], [1, 1, 1]]


Ranges can be created using the function range. The function range is
called with parameters start and end, and optionally a parameter step.
The start of the range is included, the end of the range is excluded.

math.range(0, 4)        // [0, 1, 2, 3]
math.range(0, 8, 2)     // [0, 2, 4, 6]
math.range(3, -1, -1)   // [3, 2, 1, 0]


Calculations #

Most functions of math.js support matrices and arrays. Unary functions can be applied element-wise using via math.map(matrix, function).

// perform an element-wise operation on a matrix using math.map
const a = math.matrix([1, 4, 9, 16, 25])  // Matrix, [1, 4, 9, 16, 25]
math.map(a, math.sqrt)                    // Matrix, [1, 2, 3, 4, 5]

// use a function that has built-in matrix and array support
const b = [1, 2, 3, 4, 5] 
math.factorial(b)                         // Array,  [1, 2, 6, 24, 120]

// multiply an array with a matrix
const c = [[2, 0], [-1, 3]]               // Array
const d = math.matrix([[7, 1], [-2, 3]])  // Matrix
math.multiply(c, d)                       // Matrix, [[14, 2], [-13, 8]]

// add a number to a matrix (see broadcasting)
math.add(c, 2)                            // Array, [[4, 2], [1, 5]]

// calculate the determinant of a matrix
math.det(c)                               // 6
math.det(d)                               // 23

Broadcasting #

Functions that require two or more matrix like arguments that operate elementwise automatically operate as if the arguments were the same size.

A = math.matrix([1, 2])       // Matrix, [1, 2]
math.add(A, 3)                // Matrix, [3, 4]

B = math.matrix([[3], [4]])   // Matrix, [[3], [4]]
math.add(A, B)                // Matrix, [[4, 5], [5, 6]]

Any index that is in one of the arguments, can be found as if it existed on the others when the size on that dimension is one or not existing. This is valid in N dimensions.

It’s not possible to broadcast in cases where the size in that dimension is higher than one.

math.add([1, 2], [3, 4, 5])
// Error: shape missmatch: missmatch is found in arg with shape (2) not possible to broadcast dimension 0 with size 2 to size 3

math.add([[1], [2], [3]], [[4], [5]])
// Error: shape missmatch: missmatch is found in arg with shape (2,1) not possible to broadcast dimension 0 with size 2 to size 3


Size and Dimensions #

Math.js uses geometric dimensions:


  A scalar is zero-dimensional.
  A vector is one-dimensional.
  A matrix is two or multi-dimensional.


The size of a matrix can be calculated with the function size. Function size
returns a Matrix or Array, depending on the configuration option matrix.
Furthermore, matrices have a function size as well, which always returns
an Array.

// get the size of a scalar
math.size(2.4)                                // Matrix, []
math.size(math.complex(3, 2))                 // Matrix, []
math.size(math.unit('5.3 mm'))                // Matrix, []

// get the size of a one-dimensional matrix (a vector) and a string
math.size([0, 1, 2, 3])                       // Array, [4]
math.size('hello world')                      // Matrix, [11]

// get the size of a two-dimensional matrix
const a = [[0, 1, 2, 3]]                      // Array
const b = math.matrix([[0, 1, 2], [3, 4, 5]]) // Matrix
math.size(a)                                  // Array, [1, 4]
math.size(b)                                  // Matrix, [2, 3]

// matrices have a function size (always returns an Array)
b.size()                                      // Array, [2, 3]

// get the size of a multi-dimensional matrix
const c = [[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]
math.size(c)                                  // Array, [2, 2, 3]


Note that the dimensions themselves do not have a meaning attached. 
When creating and printing a two dimensional matrix, the first dimension is 
normally rendered as the column, and the second dimension is rendered as 
the row. For example:

console.table(math.zeros([2, 4]))
// 0 0 0 0
// 0 0 0 0


If you have a matrix where the first dimension means x and the second 
means y, this will look confusing since x is printed as column 
(vertically) and y as row (horizontally).

Resizing #

Matrices can be resized using their resize function. This function is called
with an Array with the new size as the first argument, and accepts an optional
default value. By default, new entries will be set to 0, but it is possible
to pass a different default value like null to clearly indicate that
the entries haven’t been explicitly set.

const a = math.matrix() // Matrix, size [0],       []
a.resize([2, 3])        // Matrix, size [2, 3],    [[0, 0, 0], [0, 0, 0]]
a.resize([2, 2, 2])     // Matrix, size [2, 2, 2],
                        //   [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]

const b = math.matrix()
b.resize([3], 7)        // Matrix, size [3],    [7, 7, 7]
b.resize([5], 9)        // Matrix, size [5],    [7, 7, 7, 9, 9]
b.resize([2])           // Matrix, size [2],    [7, 7]


Outer dimensions of a matrix can be squeezed using the function squeeze. When
getting or setting a single value in a matrix using subset, the value is automatically squeezed
or unsqueezed too.

// squeeze a matrix
const a = [[[0, 1, 2]]]
math.squeeze(a)             // [0, 1, 2]
math.squeeze([[3]])         // 3

// when getting/setting a single value in a matrix using subset, 
// it automatically squeeze/unsqueeze the value
const b = math.matrix([[0, 1], [2, 3]])
b.subset(math.index(1, 0))  // 2 and not [[2]]


Getting or replacing subsets #

Subsets of a matrix can be retrieved or replaced using the function subset.
Matrices have a subset function, which is applied to the matrix itself:
Matrix.subset(index [, replacement]). For both matrices and arrays,
the static function subset(matrix, index [, replacement]) can be used.
When parameter replacement is provided, the function will replace a subset
in the matrix, and if not, a subset of the matrix will be returned.

A subset can be defined using an Index. An Index contains a single value
or a set of values for each dimension of a matrix. An Index can be
created using the function index. When getting a single value from a matrix,
subset will return the value itself instead of a matrix containing just this 
value.

The function subset normally returns a subset, but when getting or setting a
single value in a matrix, the value itself is returned.

Matrix indexes in math.js are zero-based, like most programming languages
including JavaScript itself. Note that mathematical applications like Matlab 
and Octave work differently, as they use one-based indexes.

// create some matrices
const a = [0, 1, 2, 3]
const b = [[0, 1], [2, 3]]
const c = math.zeros(2, 2)
const d = math.matrix([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
const e = math.matrix()

// get a subset
math.subset(a, math.index(1))                 // 1
math.subset(a, math.index([2, 3]))            // Array, [2, 3]
math.subset(a, math.index(math.range(0,4)))   // Array, [0, 1, 2, 3]
math.subset(b, math.index(1, 0))              // 2
math.subset(b, math.index(1, [0, 1]))         // Array, [2, 3]
math.subset(b, math.index([0, 1], 0))         // Matrix, [[0], [2]]

// get a subset
d.subset(math.index([1, 2], [0, 1]))          // Matrix, [[3, 4], [6, 7]]
d.subset(math.index(1, 2))                    // 5

// replace a subset. The subset will be applied to a clone of the matrix
math.subset(b, math.index(1, 0), 9)           // Array, [[0, 1], [9, 3]]
math.subset(b, math.index(2, [0, 1]), [4, 5]) // Array, [[0, 1], [2, 3], [4, 5]]

// replace a subset. The subset will be applied to the matrix itself
c.subset(math.index(0, 1),1)                  // Matrix, [[0, 1], [0, 0]]
c.subset(math.index(1, [0, 1]), [2, 3])       // Matrix, [[0, 1], [2, 3]]
e.resize([2, 3], 0)                           // Matrix, [[0, 0, 0], [0, 0, 0]]
e.subset(math.index(1, 2), 5)                 // Matrix, [[0, 0, 0], [0, 0, 5]]


Getting and setting a value in a matrix #

There are two methods available on matrices that allow to get or set a single 
value inside a matrix. It is important to note that the set method will 
mutate the matrix.

const p = math.matrix([[1, 2], [3, 4]])
p.set([0, 1], 5)
// p is now [[1, 5], [3, 4]]
p.get([1, 0]) // 3


When setting a value at a location outside of the current matrix size using the
method .set(), the matrix will be resized. By default, new items will be 
initialized with zero, but it is possible to specify an alternative value using
the optional third argument defaultValue.

Advanced Indexing #

Boolean array indexing is a technique that allows you to filter, replace, and set values in an array based on logical conditions. This can be done by creating a boolean array that represents the desired conditions, and then using that array as an index to select the elements of the original array that meet those conditions.

For example, a boolean array can be created to represent all the even numbers in an array, and then used to filter the original array to only include the even numbers. Alternatively, a boolean array can be created to represent all the elements of an array that are greater than a certain value, and then used to replace all the elements of the original array that are greater than that value with a new value.

const q = [1, 2, 3, 4]
math.subset(q, math.index([true, false, true, false]))      // Array [1, 3]

// filtering
math.subset(q, math.index(math.larger(q, 2)))               // Array [3, 4]

// filtering with no matches
math.subset(q, math.index(math.larger(q, 5)))               // Array []

// setting specific values, please note that the replacement value is broadcasted
q = math.subset(q, math.index(math.smaller(q, 3)), 0)       // q = [0, 0, 3, 4]

// replacing specific values
math.subset(q, math.index(math.equal(q, 0)), [1, 2])        // q = [1, 2, 3, 4]


The same can be accomplished in the parser in a much more compact manner. Please note that everything after # are comments.
math.evaluate(`
q = [1, 2, 3, 4]
q[[true, false, true, false]] # Matrix [1, 3]
q[q>2]                        # Matrix [3, 4]
q[q>5]                        # Matrix []
q[q <3] = 0                   # q = [0, 0, 3, 4]
q[q==0] = [1, 2]              # q = [1, 2, 3, 4]
`)

The expression inside the index can be as complex as needed as long it evaluates to an array of booleans of the same size.
math.evaluate(`
q = [1, 2, 3, 4]
r = [6, 5, 4, 3]
q[q > 3 and r < 4]     # [4]
`)


Iterating #

Matrices contain functions map and forEach to iterate over all elements of
the (multidimensional) matrix. The callback function of map and forEach has
three parameters: value (the value of the currently iterated element),
index (an array with the index value for each dimension), and matrix (the
matrix being iterated). This syntax is similar to the map and forEach
functions of native JavaScript Arrays, except that the index is no number but
an Array with numbers for each dimension.

const a = math.matrix([[0, 1], [2, 3], [4, 5]])

// The iteration below will output the following in the console:
//    value: 0 index: [0, 0]
//    value: 1 index: [0, 1]
//    value: 2 index: [1, 0]
//    value: 3 index: [1, 1]
//    value: 4 index: [2, 0]
//    value: 5 index: [2, 1]
a.forEach(function (value, index, matrix) {
  console.log('value:', value, 'index:', index) 
}) 

// Apply a transformation on the matrix
const b = a.map(function (value, index, matrix) {
  return math.multiply(math.sin(value), math.exp(math.abs(value))) 
}) 
console.log(b.format(5))  // [[0, 2.2874], [6.7188, 2.8345], [-41.32, -142.32]]

// Create a matrix with the cumulative of all elements
let count = 0
const cum = a.map(function (value, index, matrix) {
  count += value 
  return count 
}) 
console.log(cum.toString())  // [[0, 1], [3, 6], [10, 15]]


Iterating over multiple Matrixes or Arrays #

You can iterate over multiple matrices or arrays by using the map function. Mapping allows to perform element-wise operations on matrices by automatically adjusting their sizes to match each other.

To iterate over multiple matrices, you can use the map function. The map function applies a given function to each element of the matrices and returns a new matrix with the results.

Here’s an example of iterating over two matrices and adding their corresponding elements:

const a = math.matrix([[1, 2], [3, 4]]);
const b = math.matrix([[5, 6], [7, 8]]);

const result = math.map(a, b, (x, y) => x + y);

console.log(result); // [[6, 8], [10, 12]]


In this example, the map function takes matrices as the first two arguments and a callback function (x, y) => x + y as the third argument. The callback function is applied to each element of the matrices, where x represents the corresponding element from matrix a and y represents the corresponding element from matrix b. The result is a new matrix with the element-wise sum of the two matrices.

By using broadcasting and the map function, you can easily iterate over multiple matrices and perform element-wise operations.

const a = math.matrix([10, 20])
const b = math.matrix([[3, 4], [5, 6]])

const result = math.map(a, b, (x, y) => x + y)
console.log(result); // [[13, 24], [15, 26]]


It’s also possible to provide a callback with an index and the broadcasted arrays. Like (valueA, valueB, index) or even (valueA, valueB, index, broadcastedMatrixA, broadcastedMatrixB). There is no specific limit for the number of matrices N that can be mapped. Thus, the callback can have N arguments, N+1 arguments in the case of including the index, or 2N+1 arguments in the case of including the index and the broadcasted matrices in the callback.

At this moment forEach doesn’t include the same functionality.

Storage types #

Math.js supports both dense matrices as well as sparse matrices. Sparse matrices are efficient for matrices largely containing zeros. In that case they save a lot of memory, and calculations can be much faster than for dense matrices.

Math.js supports two type of matrices:


  Dense matrix ('dense', default) A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.
  Sparse matrix ('sparse'): A two dimensional sparse matrix implementation.


The type of matrix can be selected when creating a matrix using the construction functions matrix, diag, identity, ones, and zeros.

// create sparse matrices
const m1 = math.matrix([[0, 1], [0, 0]], 'sparse')
const m2 = math.identity(1000, 1000, 'sparse')


You can also coerce an array or matrix into sparse storage format with the
sparse function.
const md = math.matrix([[0, 1], [0,0]])  // dense
const ms = math.sparse(md)               // sparse


Caution: sparse called on a JavaScript array of n plain numbers produces
a matrix with one column and n rows – in contrast to matrix, which
produces a 1-dimensional matrix object with n entries, i.e., a vector
(not a 1 by n “row vector” nor an n by 1 “column vector”, but just a plain
vector of length n).
const mv = math.matrix([0, 0, 1])  // Has size [3]
const mc = math.sparse([0, 0, 1])  // A "column vector," has size [3, 1]


API #

All relevant functions in math.js support Matrices and Arrays. Functions like math.add and math.subtract, math.sqrt handle matrices element wise. There is a set of functions specifically for creating or manipulating matrices, such as:


  Functions like math.matrix and math.sparse, math.ones, math.zeros, and math.identity to create a matrix.
  Functions like math.subset and math.index to get or replace a part of a matrix
  Functions like math.transpose and math.diag to manipulate matrices.


A full list of matrix functions is available on the functions reference page.

Two types of matrix classes are available in math.js, for storage of dense and sparse matrices. Although they contain public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  DenseMatrix
  SparseMatrix\n\n\n\nMatrices #

Math.js supports multi dimensional matrices and arrays. Matrices can be
created, manipulated, and used in calculations. Both regular JavaScript
arrays as well as the matrix type implemented by math.js can be used
interchangeably in all relevant math.js functions. math.js supports both
dense and sparse matrices.

Arrays and matrices #

Math.js supports two types of matrices:


  Array, a regular JavaScript array. A multi dimensional array can be created
by nesting arrays.
  Matrix, a matrix implementation by math.js. A Matrix is an object wrapped
around a regular JavaScript Array, providing utility functions for easy
matrix manipulation such as subset, size, resize, clone, and more.


In most cases, the type of matrix output from functions is determined by the
function input: An Array as input will return an Array, a Matrix as input
will return a Matrix. In case of mixed input, a Matrix is returned.
For functions where the type of output cannot be determined from the
input, the output is determined by the configuration option matrix,
which can be a string 'Matrix' (default) or 'Array'.

// create an array and a matrix
const array = [[2, 0], [-1, 3]]               // Array
const matrix = math.matrix([[7, 1], [-2, 3]]) // Matrix

// perform a calculation on an array and matrix
math.map(array, math.square)                  // Array,  [[4, 0], [1, 9]]
math.map(matrix, math.square)                 // Matrix, [[49, 1], [4, 9]]

// perform calculations with mixed array and matrix input
math.add(array, matrix)                       // Matrix, [[9, 1], [-3, 6]]
math.multiply(array, matrix)                  // Matrix, [[14, 2], [-13, 8]]

// create a matrix. Type of output of function ones is determined by the
// configuration option `matrix`
math.ones(2, 3)                               // Matrix, [[1, 1, 1], [1, 1, 1]]


Creation #

A matrix can be created from an array using the function math.matrix. The
provided array can contain nested arrays in order to create a multi-dimensional matrix. When called without arguments, an empty matrix will be
created.

// create matrices
math.matrix()                           // Matrix, size [0]
math.matrix([0, 1, 2])                  // Matrix, size [3]
math.matrix([[0, 1], [2, 3], [4, 5]])   // Matrix, size [3, 2]


Math.js supports regular Arrays. Multiple dimensions can be created
by nesting Arrays in each other.

// create arrays
[]                                      // Array, size [0]
[0, 1, 2]                               // Array, size [3]
[[0, 1], [2, 3], [4, 5]]                // Array, size [3, 2]


Matrices can contain different types of values: numbers, complex numbers,
units, or strings. Different types can be mixed together in a single matrix.

// create a matrix with mixed types
const a = math.matrix([2.3, 'hello', math.complex(3, -4), math.unit('5.2 mm')]) 
a.subset(math.index(1))  // 'hello'


There are a number of functions to create a matrix with a specific size and
content: ones, zeros, identity.

// zeros creates a matrix filled with zeros
math.zeros(3)           // Matrix, size [3],    [0, 0, 0]
math.zeros(3, 2)        // Matrix, size [3, 2], [[0, 0], [0, 0], [0, 0]]
math.zeros(2, 2, 2)     // Matrix, size [2, 2, 2],
                        //   [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]

// ones creates a matrix filled with ones
math.ones(3)                        // Matrix, size [3],    [1, 1, 1]
math.multiply(math.ones(2, 2), 5)   // Matrix, size [2, 2], [[5, 5], [5, 5]]

// identity creates an identity matrix
math.identity(3)      // Matrix, size [3, 3], [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
math.identity(2, 3)   // Matrix, size [2, 3], [[1, 0, 0], [0, 1, 0]]


The functions ones, zeros, and identity also accept a single array
or matrix containing the dimensions for the matrix. When the input is an Array,
the functions will output an Array. When the input is a Matrix, the output will
be a Matrix. Note that in case of numbers as arguments, the output is
determined by the option matrix as discussed in section
Arrays and matrices.

// Array as input gives Array as output
math.ones([2, 3])               // Array,  size [3, 2], [[1, 1, 1], [1, 1, 1]]
math.ones(math.matrix([2, 3]))  // Matrix, size [3, 2], [[1, 1, 1], [1, 1, 1]]


Ranges can be created using the function range. The function range is
called with parameters start and end, and optionally a parameter step.
The start of the range is included, the end of the range is excluded.

math.range(0, 4)        // [0, 1, 2, 3]
math.range(0, 8, 2)     // [0, 2, 4, 6]
math.range(3, -1, -1)   // [3, 2, 1, 0]


Calculations #

Most functions of math.js support matrices and arrays. Unary functions can be applied element-wise using via math.map(matrix, function).

// perform an element-wise operation on a matrix using math.map
const a = math.matrix([1, 4, 9, 16, 25])  // Matrix, [1, 4, 9, 16, 25]
math.map(a, math.sqrt)                    // Matrix, [1, 2, 3, 4, 5]

// use a function that has built-in matrix and array support
const b = [1, 2, 3, 4, 5] 
math.factorial(b)                         // Array,  [1, 2, 6, 24, 120]

// multiply an array with a matrix
const c = [[2, 0], [-1, 3]]               // Array
const d = math.matrix([[7, 1], [-2, 3]])  // Matrix
math.multiply(c, d)                       // Matrix, [[14, 2], [-13, 8]]

// add a number to a matrix (see broadcasting)
math.add(c, 2)                            // Array, [[4, 2], [1, 5]]

// calculate the determinant of a matrix
math.det(c)                               // 6
math.det(d)                               // 23

Broadcasting #

Functions that require two or more matrix like arguments that operate elementwise automatically operate as if the arguments were the same size.

A = math.matrix([1, 2])       // Matrix, [1, 2]
math.add(A, 3)                // Matrix, [3, 4]

B = math.matrix([[3], [4]])   // Matrix, [[3], [4]]
math.add(A, B)                // Matrix, [[4, 5], [5, 6]]

Any index that is in one of the arguments, can be found as if it existed on the others when the size on that dimension is one or not existing. This is valid in N dimensions.

It’s not possible to broadcast in cases where the size in that dimension is higher than one.

math.add([1, 2], [3, 4, 5])
// Error: shape missmatch: missmatch is found in arg with shape (2) not possible to broadcast dimension 0 with size 2 to size 3

math.add([[1], [2], [3]], [[4], [5]])
// Error: shape missmatch: missmatch is found in arg with shape (2,1) not possible to broadcast dimension 0 with size 2 to size 3


Size and Dimensions #

Math.js uses geometric dimensions:


  A scalar is zero-dimensional.
  A vector is one-dimensional.
  A matrix is two or multi-dimensional.


The size of a matrix can be calculated with the function size. Function size
returns a Matrix or Array, depending on the configuration option matrix.
Furthermore, matrices have a function size as well, which always returns
an Array.

// get the size of a scalar
math.size(2.4)                                // Matrix, []
math.size(math.complex(3, 2))                 // Matrix, []
math.size(math.unit('5.3 mm'))                // Matrix, []

// get the size of a one-dimensional matrix (a vector) and a string
math.size([0, 1, 2, 3])                       // Array, [4]
math.size('hello world')                      // Matrix, [11]

// get the size of a two-dimensional matrix
const a = [[0, 1, 2, 3]]                      // Array
const b = math.matrix([[0, 1, 2], [3, 4, 5]]) // Matrix
math.size(a)                                  // Array, [1, 4]
math.size(b)                                  // Matrix, [2, 3]

// matrices have a function size (always returns an Array)
b.size()                                      // Array, [2, 3]

// get the size of a multi-dimensional matrix
const c = [[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]
math.size(c)                                  // Array, [2, 2, 3]


Note that the dimensions themselves do not have a meaning attached. 
When creating and printing a two dimensional matrix, the first dimension is 
normally rendered as the column, and the second dimension is rendered as 
the row. For example:

console.table(math.zeros([2, 4]))
// 0 0 0 0
// 0 0 0 0


If you have a matrix where the first dimension means x and the second 
means y, this will look confusing since x is printed as column 
(vertically) and y as row (horizontally).

Resizing #

Matrices can be resized using their resize function. This function is called
with an Array with the new size as the first argument, and accepts an optional
default value. By default, new entries will be set to 0, but it is possible
to pass a different default value like null to clearly indicate that
the entries haven’t been explicitly set.

const a = math.matrix() // Matrix, size [0],       []
a.resize([2, 3])        // Matrix, size [2, 3],    [[0, 0, 0], [0, 0, 0]]
a.resize([2, 2, 2])     // Matrix, size [2, 2, 2],
                        //   [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]

const b = math.matrix()
b.resize([3], 7)        // Matrix, size [3],    [7, 7, 7]
b.resize([5], 9)        // Matrix, size [5],    [7, 7, 7, 9, 9]
b.resize([2])           // Matrix, size [2],    [7, 7]


Outer dimensions of a matrix can be squeezed using the function squeeze. When
getting or setting a single value in a matrix using subset, the value is automatically squeezed
or unsqueezed too.

// squeeze a matrix
const a = [[[0, 1, 2]]]
math.squeeze(a)             // [0, 1, 2]
math.squeeze([[3]])         // 3

// when getting/setting a single value in a matrix using subset, 
// it automatically squeeze/unsqueeze the value
const b = math.matrix([[0, 1], [2, 3]])
b.subset(math.index(1, 0))  // 2 and not [[2]]


Getting or replacing subsets #

Subsets of a matrix can be retrieved or replaced using the function subset.
Matrices have a subset function, which is applied to the matrix itself:
Matrix.subset(index [, replacement]). For both matrices and arrays,
the static function subset(matrix, index [, replacement]) can be used.
When parameter replacement is provided, the function will replace a subset
in the matrix, and if not, a subset of the matrix will be returned.

A subset can be defined using an Index. An Index contains a single value
or a set of values for each dimension of a matrix. An Index can be
created using the function index. When getting a single value from a matrix,
subset will return the value itself instead of a matrix containing just this 
value.

The function subset normally returns a subset, but when getting or setting a
single value in a matrix, the value itself is returned.

Matrix indexes in math.js are zero-based, like most programming languages
including JavaScript itself. Note that mathematical applications like Matlab 
and Octave work differently, as they use one-based indexes.

// create some matrices
const a = [0, 1, 2, 3]
const b = [[0, 1], [2, 3]]
const c = math.zeros(2, 2)
const d = math.matrix([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
const e = math.matrix()

// get a subset
math.subset(a, math.index(1))                 // 1
math.subset(a, math.index([2, 3]))            // Array, [2, 3]
math.subset(a, math.index(math.range(0,4)))   // Array, [0, 1, 2, 3]
math.subset(b, math.index(1, 0))              // 2
math.subset(b, math.index(1, [0, 1]))         // Array, [2, 3]
math.subset(b, math.index([0, 1], 0))         // Matrix, [[0], [2]]

// get a subset
d.subset(math.index([1, 2], [0, 1]))          // Matrix, [[3, 4], [6, 7]]
d.subset(math.index(1, 2))                    // 5

// replace a subset. The subset will be applied to a clone of the matrix
math.subset(b, math.index(1, 0), 9)           // Array, [[0, 1], [9, 3]]
math.subset(b, math.index(2, [0, 1]), [4, 5]) // Array, [[0, 1], [2, 3], [4, 5]]

// replace a subset. The subset will be applied to the matrix itself
c.subset(math.index(0, 1),1)                  // Matrix, [[0, 1], [0, 0]]
c.subset(math.index(1, [0, 1]), [2, 3])       // Matrix, [[0, 1], [2, 3]]
e.resize([2, 3], 0)                           // Matrix, [[0, 0, 0], [0, 0, 0]]
e.subset(math.index(1, 2), 5)                 // Matrix, [[0, 0, 0], [0, 0, 5]]


Getting and setting a value in a matrix #

There are two methods available on matrices that allow to get or set a single 
value inside a matrix. It is important to note that the set method will 
mutate the matrix.

const p = math.matrix([[1, 2], [3, 4]])
p.set([0, 1], 5)
// p is now [[1, 5], [3, 4]]
p.get([1, 0]) // 3


When setting a value at a location outside of the current matrix size using the
method .set(), the matrix will be resized. By default, new items will be 
initialized with zero, but it is possible to specify an alternative value using
the optional third argument defaultValue.

Advanced Indexing #

Boolean array indexing is a technique that allows you to filter, replace, and set values in an array based on logical conditions. This can be done by creating a boolean array that represents the desired conditions, and then using that array as an index to select the elements of the original array that meet those conditions.

For example, a boolean array can be created to represent all the even numbers in an array, and then used to filter the original array to only include the even numbers. Alternatively, a boolean array can be created to represent all the elements of an array that are greater than a certain value, and then used to replace all the elements of the original array that are greater than that value with a new value.

const q = [1, 2, 3, 4]
math.subset(q, math.index([true, false, true, false]))      // Array [1, 3]

// filtering
math.subset(q, math.index(math.larger(q, 2)))               // Array [3, 4]

// filtering with no matches
math.subset(q, math.index(math.larger(q, 5)))               // Array []

// setting specific values, please note that the replacement value is broadcasted
q = math.subset(q, math.index(math.smaller(q, 3)), 0)       // q = [0, 0, 3, 4]

// replacing specific values
math.subset(q, math.index(math.equal(q, 0)), [1, 2])        // q = [1, 2, 3, 4]


The same can be accomplished in the parser in a much more compact manner. Please note that everything after # are comments.
math.evaluate(`
q = [1, 2, 3, 4]
q[[true, false, true, false]] # Matrix [1, 3]
q[q>2]                        # Matrix [3, 4]
q[q>5]                        # Matrix []
q[q <3] = 0                   # q = [0, 0, 3, 4]
q[q==0] = [1, 2]              # q = [1, 2, 3, 4]
`)

The expression inside the index can be as complex as needed as long it evaluates to an array of booleans of the same size.
math.evaluate(`
q = [1, 2, 3, 4]
r = [6, 5, 4, 3]
q[q > 3 and r < 4]     # [4]
`)


Iterating #

Matrices contain functions map and forEach to iterate over all elements of
the (multidimensional) matrix. The callback function of map and forEach has
three parameters: value (the value of the currently iterated element),
index (an array with the index value for each dimension), and matrix (the
matrix being iterated). This syntax is similar to the map and forEach
functions of native JavaScript Arrays, except that the index is no number but
an Array with numbers for each dimension.

const a = math.matrix([[0, 1], [2, 3], [4, 5]])

// The iteration below will output the following in the console:
//    value: 0 index: [0, 0]
//    value: 1 index: [0, 1]
//    value: 2 index: [1, 0]
//    value: 3 index: [1, 1]
//    value: 4 index: [2, 0]
//    value: 5 index: [2, 1]
a.forEach(function (value, index, matrix) {
  console.log('value:', value, 'index:', index) 
}) 

// Apply a transformation on the matrix
const b = a.map(function (value, index, matrix) {
  return math.multiply(math.sin(value), math.exp(math.abs(value))) 
}) 
console.log(b.format(5))  // [[0, 2.2874], [6.7188, 2.8345], [-41.32, -142.32]]

// Create a matrix with the cumulative of all elements
let count = 0
const cum = a.map(function (value, index, matrix) {
  count += value 
  return count 
}) 
console.log(cum.toString())  // [[0, 1], [3, 6], [10, 15]]


Iterating over multiple Matrixes or Arrays #

You can iterate over multiple matrices or arrays by using the map function. Mapping allows to perform element-wise operations on matrices by automatically adjusting their sizes to match each other.

To iterate over multiple matrices, you can use the map function. The map function applies a given function to each element of the matrices and returns a new matrix with the results.

Here’s an example of iterating over two matrices and adding their corresponding elements:

const a = math.matrix([[1, 2], [3, 4]]);
const b = math.matrix([[5, 6], [7, 8]]);

const result = math.map(a, b, (x, y) => x + y);

console.log(result); // [[6, 8], [10, 12]]


In this example, the map function takes matrices as the first two arguments and a callback function (x, y) => x + y as the third argument. The callback function is applied to each element of the matrices, where x represents the corresponding element from matrix a and y represents the corresponding element from matrix b. The result is a new matrix with the element-wise sum of the two matrices.

By using broadcasting and the map function, you can easily iterate over multiple matrices and perform element-wise operations.

const a = math.matrix([10, 20])
const b = math.matrix([[3, 4], [5, 6]])

const result = math.map(a, b, (x, y) => x + y)
console.log(result); // [[13, 24], [15, 26]]


It’s also possible to provide a callback with an index and the broadcasted arrays. Like (valueA, valueB, index) or even (valueA, valueB, index, broadcastedMatrixA, broadcastedMatrixB). There is no specific limit for the number of matrices N that can be mapped. Thus, the callback can have N arguments, N+1 arguments in the case of including the index, or 2N+1 arguments in the case of including the index and the broadcasted matrices in the callback.

At this moment forEach doesn’t include the same functionality.

Storage types #

Math.js supports both dense matrices as well as sparse matrices. Sparse matrices are efficient for matrices largely containing zeros. In that case they save a lot of memory, and calculations can be much faster than for dense matrices.

Math.js supports two type of matrices:


  Dense matrix ('dense', default) A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.
  Sparse matrix ('sparse'): A two dimensional sparse matrix implementation.


The type of matrix can be selected when creating a matrix using the construction functions matrix, diag, identity, ones, and zeros.

// create sparse matrices
const m1 = math.matrix([[0, 1], [0, 0]], 'sparse')
const m2 = math.identity(1000, 1000, 'sparse')


You can also coerce an array or matrix into sparse storage format with the
sparse function.
const md = math.matrix([[0, 1], [0,0]])  // dense
const ms = math.sparse(md)               // sparse


Caution: sparse called on a JavaScript array of n plain numbers produces
a matrix with one column and n rows – in contrast to matrix, which
produces a 1-dimensional matrix object with n entries, i.e., a vector
(not a 1 by n “row vector” nor an n by 1 “column vector”, but just a plain
vector of length n).
const mv = math.matrix([0, 0, 1])  // Has size [3]
const mc = math.sparse([0, 0, 1])  // A "column vector," has size [3, 1]


API #

All relevant functions in math.js support Matrices and Arrays. Functions like math.add and math.subtract, math.sqrt handle matrices element wise. There is a set of functions specifically for creating or manipulating matrices, such as:


  Functions like math.matrix and math.sparse, math.ones, math.zeros, and math.identity to create a matrix.
  Functions like math.subset and math.index to get or replace a part of a matrix
  Functions like math.transpose and math.diag to manipulate matrices.


A full list of matrix functions is available on the functions reference page.

Two types of matrix classes are available in math.js, for storage of dense and sparse matrices. Although they contain public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  DenseMatrix
  SparseMatrix\n\n\n\nMatrices #

Math.js supports multi dimensional matrices and arrays. Matrices can be
created, manipulated, and used in calculations. Both regular JavaScript
arrays as well as the matrix type implemented by math.js can be used
interchangeably in all relevant math.js functions. math.js supports both
dense and sparse matrices.

Arrays and matrices #

Math.js supports two types of matrices:


  Array, a regular JavaScript array. A multi dimensional array can be created
by nesting arrays.
  Matrix, a matrix implementation by math.js. A Matrix is an object wrapped
around a regular JavaScript Array, providing utility functions for easy
matrix manipulation such as subset, size, resize, clone, and more.


In most cases, the type of matrix output from functions is determined by the
function input: An Array as input will return an Array, a Matrix as input
will return a Matrix. In case of mixed input, a Matrix is returned.
For functions where the type of output cannot be determined from the
input, the output is determined by the configuration option matrix,
which can be a string 'Matrix' (default) or 'Array'.

// create an array and a matrix
const array = [[2, 0], [-1, 3]]               // Array
const matrix = math.matrix([[7, 1], [-2, 3]]) // Matrix

// perform a calculation on an array and matrix
math.map(array, math.square)                  // Array,  [[4, 0], [1, 9]]
math.map(matrix, math.square)                 // Matrix, [[49, 1], [4, 9]]

// perform calculations with mixed array and matrix input
math.add(array, matrix)                       // Matrix, [[9, 1], [-3, 6]]
math.multiply(array, matrix)                  // Matrix, [[14, 2], [-13, 8]]

// create a matrix. Type of output of function ones is determined by the
// configuration option `matrix`
math.ones(2, 3)                               // Matrix, [[1, 1, 1], [1, 1, 1]]


Creation #

A matrix can be created from an array using the function math.matrix. The
provided array can contain nested arrays in order to create a multi-dimensional matrix. When called without arguments, an empty matrix will be
created.

// create matrices
math.matrix()                           // Matrix, size [0]
math.matrix([0, 1, 2])                  // Matrix, size [3]
math.matrix([[0, 1], [2, 3], [4, 5]])   // Matrix, size [3, 2]


Math.js supports regular Arrays. Multiple dimensions can be created
by nesting Arrays in each other.

// create arrays
[]                                      // Array, size [0]
[0, 1, 2]                               // Array, size [3]
[[0, 1], [2, 3], [4, 5]]                // Array, size [3, 2]


Matrices can contain different types of values: numbers, complex numbers,
units, or strings. Different types can be mixed together in a single matrix.

// create a matrix with mixed types
const a = math.matrix([2.3, 'hello', math.complex(3, -4), math.unit('5.2 mm')]) 
a.subset(math.index(1))  // 'hello'


There are a number of functions to create a matrix with a specific size and
content: ones, zeros, identity.

// zeros creates a matrix filled with zeros
math.zeros(3)           // Matrix, size [3],    [0, 0, 0]
math.zeros(3, 2)        // Matrix, size [3, 2], [[0, 0], [0, 0], [0, 0]]
math.zeros(2, 2, 2)     // Matrix, size [2, 2, 2],
                        //   [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]

// ones creates a matrix filled with ones
math.ones(3)                        // Matrix, size [3],    [1, 1, 1]
math.multiply(math.ones(2, 2), 5)   // Matrix, size [2, 2], [[5, 5], [5, 5]]

// identity creates an identity matrix
math.identity(3)      // Matrix, size [3, 3], [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
math.identity(2, 3)   // Matrix, size [2, 3], [[1, 0, 0], [0, 1, 0]]


The functions ones, zeros, and identity also accept a single array
or matrix containing the dimensions for the matrix. When the input is an Array,
the functions will output an Array. When the input is a Matrix, the output will
be a Matrix. Note that in case of numbers as arguments, the output is
determined by the option matrix as discussed in section
Arrays and matrices.

// Array as input gives Array as output
math.ones([2, 3])               // Array,  size [3, 2], [[1, 1, 1], [1, 1, 1]]
math.ones(math.matrix([2, 3]))  // Matrix, size [3, 2], [[1, 1, 1], [1, 1, 1]]


Ranges can be created using the function range. The function range is
called with parameters start and end, and optionally a parameter step.
The start of the range is included, the end of the range is excluded.

math.range(0, 4)        // [0, 1, 2, 3]
math.range(0, 8, 2)     // [0, 2, 4, 6]
math.range(3, -1, -1)   // [3, 2, 1, 0]


Calculations #

Most functions of math.js support matrices and arrays. Unary functions can be applied element-wise using via math.map(matrix, function).

// perform an element-wise operation on a matrix using math.map
const a = math.matrix([1, 4, 9, 16, 25])  // Matrix, [1, 4, 9, 16, 25]
math.map(a, math.sqrt)                    // Matrix, [1, 2, 3, 4, 5]

// use a function that has built-in matrix and array support
const b = [1, 2, 3, 4, 5] 
math.factorial(b)                         // Array,  [1, 2, 6, 24, 120]

// multiply an array with a matrix
const c = [[2, 0], [-1, 3]]               // Array
const d = math.matrix([[7, 1], [-2, 3]])  // Matrix
math.multiply(c, d)                       // Matrix, [[14, 2], [-13, 8]]

// add a number to a matrix (see broadcasting)
math.add(c, 2)                            // Array, [[4, 2], [1, 5]]

// calculate the determinant of a matrix
math.det(c)                               // 6
math.det(d)                               // 23

Broadcasting #

Functions that require two or more matrix like arguments that operate elementwise automatically operate as if the arguments were the same size.

A = math.matrix([1, 2])       // Matrix, [1, 2]
math.add(A, 3)                // Matrix, [3, 4]

B = math.matrix([[3], [4]])   // Matrix, [[3], [4]]
math.add(A, B)                // Matrix, [[4, 5], [5, 6]]

Any index that is in one of the arguments, can be found as if it existed on the others when the size on that dimension is one or not existing. This is valid in N dimensions.

It’s not possible to broadcast in cases where the size in that dimension is higher than one.

math.add([1, 2], [3, 4, 5])
// Error: shape missmatch: missmatch is found in arg with shape (2) not possible to broadcast dimension 0 with size 2 to size 3

math.add([[1], [2], [3]], [[4], [5]])
// Error: shape missmatch: missmatch is found in arg with shape (2,1) not possible to broadcast dimension 0 with size 2 to size 3


Size and Dimensions #

Math.js uses geometric dimensions:


  A scalar is zero-dimensional.
  A vector is one-dimensional.
  A matrix is two or multi-dimensional.


The size of a matrix can be calculated with the function size. Function size
returns a Matrix or Array, depending on the configuration option matrix.
Furthermore, matrices have a function size as well, which always returns
an Array.

// get the size of a scalar
math.size(2.4)                                // Matrix, []
math.size(math.complex(3, 2))                 // Matrix, []
math.size(math.unit('5.3 mm'))                // Matrix, []

// get the size of a one-dimensional matrix (a vector) and a string
math.size([0, 1, 2, 3])                       // Array, [4]
math.size('hello world')                      // Matrix, [11]

// get the size of a two-dimensional matrix
const a = [[0, 1, 2, 3]]                      // Array
const b = math.matrix([[0, 1, 2], [3, 4, 5]]) // Matrix
math.size(a)                                  // Array, [1, 4]
math.size(b)                                  // Matrix, [2, 3]

// matrices have a function size (always returns an Array)
b.size()                                      // Array, [2, 3]

// get the size of a multi-dimensional matrix
const c = [[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]
math.size(c)                                  // Array, [2, 2, 3]


Note that the dimensions themselves do not have a meaning attached. 
When creating and printing a two dimensional matrix, the first dimension is 
normally rendered as the column, and the second dimension is rendered as 
the row. For example:

console.table(math.zeros([2, 4]))
// 0 0 0 0
// 0 0 0 0


If you have a matrix where the first dimension means x and the second 
means y, this will look confusing since x is printed as column 
(vertically) and y as row (horizontally).

Resizing #

Matrices can be resized using their resize function. This function is called
with an Array with the new size as the first argument, and accepts an optional
default value. By default, new entries will be set to 0, but it is possible
to pass a different default value like null to clearly indicate that
the entries haven’t been explicitly set.

const a = math.matrix() // Matrix, size [0],       []
a.resize([2, 3])        // Matrix, size [2, 3],    [[0, 0, 0], [0, 0, 0]]
a.resize([2, 2, 2])     // Matrix, size [2, 2, 2],
                        //   [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]

const b = math.matrix()
b.resize([3], 7)        // Matrix, size [3],    [7, 7, 7]
b.resize([5], 9)        // Matrix, size [5],    [7, 7, 7, 9, 9]
b.resize([2])           // Matrix, size [2],    [7, 7]


Outer dimensions of a matrix can be squeezed using the function squeeze. When
getting or setting a single value in a matrix using subset, the value is automatically squeezed
or unsqueezed too.

// squeeze a matrix
const a = [[[0, 1, 2]]]
math.squeeze(a)             // [0, 1, 2]
math.squeeze([[3]])         // 3

// when getting/setting a single value in a matrix using subset, 
// it automatically squeeze/unsqueeze the value
const b = math.matrix([[0, 1], [2, 3]])
b.subset(math.index(1, 0))  // 2 and not [[2]]


Getting or replacing subsets #

Subsets of a matrix can be retrieved or replaced using the function subset.
Matrices have a subset function, which is applied to the matrix itself:
Matrix.subset(index [, replacement]). For both matrices and arrays,
the static function subset(matrix, index [, replacement]) can be used.
When parameter replacement is provided, the function will replace a subset
in the matrix, and if not, a subset of the matrix will be returned.

A subset can be defined using an Index. An Index contains a single value
or a set of values for each dimension of a matrix. An Index can be
created using the function index. When getting a single value from a matrix,
subset will return the value itself instead of a matrix containing just this 
value.

The function subset normally returns a subset, but when getting or setting a
single value in a matrix, the value itself is returned.

Matrix indexes in math.js are zero-based, like most programming languages
including JavaScript itself. Note that mathematical applications like Matlab 
and Octave work differently, as they use one-based indexes.

// create some matrices
const a = [0, 1, 2, 3]
const b = [[0, 1], [2, 3]]
const c = math.zeros(2, 2)
const d = math.matrix([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
const e = math.matrix()

// get a subset
math.subset(a, math.index(1))                 // 1
math.subset(a, math.index([2, 3]))            // Array, [2, 3]
math.subset(a, math.index(math.range(0,4)))   // Array, [0, 1, 2, 3]
math.subset(b, math.index(1, 0))              // 2
math.subset(b, math.index(1, [0, 1]))         // Array, [2, 3]
math.subset(b, math.index([0, 1], 0))         // Matrix, [[0], [2]]

// get a subset
d.subset(math.index([1, 2], [0, 1]))          // Matrix, [[3, 4], [6, 7]]
d.subset(math.index(1, 2))                    // 5

// replace a subset. The subset will be applied to a clone of the matrix
math.subset(b, math.index(1, 0), 9)           // Array, [[0, 1], [9, 3]]
math.subset(b, math.index(2, [0, 1]), [4, 5]) // Array, [[0, 1], [2, 3], [4, 5]]

// replace a subset. The subset will be applied to the matrix itself
c.subset(math.index(0, 1),1)                  // Matrix, [[0, 1], [0, 0]]
c.subset(math.index(1, [0, 1]), [2, 3])       // Matrix, [[0, 1], [2, 3]]
e.resize([2, 3], 0)                           // Matrix, [[0, 0, 0], [0, 0, 0]]
e.subset(math.index(1, 2), 5)                 // Matrix, [[0, 0, 0], [0, 0, 5]]


Getting and setting a value in a matrix #

There are two methods available on matrices that allow to get or set a single 
value inside a matrix. It is important to note that the set method will 
mutate the matrix.

const p = math.matrix([[1, 2], [3, 4]])
p.set([0, 1], 5)
// p is now [[1, 5], [3, 4]]
p.get([1, 0]) // 3


When setting a value at a location outside of the current matrix size using the
method .set(), the matrix will be resized. By default, new items will be 
initialized with zero, but it is possible to specify an alternative value using
the optional third argument defaultValue.

Advanced Indexing #

Boolean array indexing is a technique that allows you to filter, replace, and set values in an array based on logical conditions. This can be done by creating a boolean array that represents the desired conditions, and then using that array as an index to select the elements of the original array that meet those conditions.

For example, a boolean array can be created to represent all the even numbers in an array, and then used to filter the original array to only include the even numbers. Alternatively, a boolean array can be created to represent all the elements of an array that are greater than a certain value, and then used to replace all the elements of the original array that are greater than that value with a new value.

const q = [1, 2, 3, 4]
math.subset(q, math.index([true, false, true, false]))      // Array [1, 3]

// filtering
math.subset(q, math.index(math.larger(q, 2)))               // Array [3, 4]

// filtering with no matches
math.subset(q, math.index(math.larger(q, 5)))               // Array []

// setting specific values, please note that the replacement value is broadcasted
q = math.subset(q, math.index(math.smaller(q, 3)), 0)       // q = [0, 0, 3, 4]

// replacing specific values
math.subset(q, math.index(math.equal(q, 0)), [1, 2])        // q = [1, 2, 3, 4]


The same can be accomplished in the parser in a much more compact manner. Please note that everything after # are comments.
math.evaluate(`
q = [1, 2, 3, 4]
q[[true, false, true, false]] # Matrix [1, 3]
q[q>2]                        # Matrix [3, 4]
q[q>5]                        # Matrix []
q[q <3] = 0                   # q = [0, 0, 3, 4]
q[q==0] = [1, 2]              # q = [1, 2, 3, 4]
`)

The expression inside the index can be as complex as needed as long it evaluates to an array of booleans of the same size.
math.evaluate(`
q = [1, 2, 3, 4]
r = [6, 5, 4, 3]
q[q > 3 and r < 4]     # [4]
`)


Iterating #

Matrices contain functions map and forEach to iterate over all elements of
the (multidimensional) matrix. The callback function of map and forEach has
three parameters: value (the value of the currently iterated element),
index (an array with the index value for each dimension), and matrix (the
matrix being iterated). This syntax is similar to the map and forEach
functions of native JavaScript Arrays, except that the index is no number but
an Array with numbers for each dimension.

const a = math.matrix([[0, 1], [2, 3], [4, 5]])

// The iteration below will output the following in the console:
//    value: 0 index: [0, 0]
//    value: 1 index: [0, 1]
//    value: 2 index: [1, 0]
//    value: 3 index: [1, 1]
//    value: 4 index: [2, 0]
//    value: 5 index: [2, 1]
a.forEach(function (value, index, matrix) {
  console.log('value:', value, 'index:', index) 
}) 

// Apply a transformation on the matrix
const b = a.map(function (value, index, matrix) {
  return math.multiply(math.sin(value), math.exp(math.abs(value))) 
}) 
console.log(b.format(5))  // [[0, 2.2874], [6.7188, 2.8345], [-41.32, -142.32]]

// Create a matrix with the cumulative of all elements
let count = 0
const cum = a.map(function (value, index, matrix) {
  count += value 
  return count 
}) 
console.log(cum.toString())  // [[0, 1], [3, 6], [10, 15]]


Iterating over multiple Matrixes or Arrays #

You can iterate over multiple matrices or arrays by using the map function. Mapping allows to perform element-wise operations on matrices by automatically adjusting their sizes to match each other.

To iterate over multiple matrices, you can use the map function. The map function applies a given function to each element of the matrices and returns a new matrix with the results.

Here’s an example of iterating over two matrices and adding their corresponding elements:

const a = math.matrix([[1, 2], [3, 4]]);
const b = math.matrix([[5, 6], [7, 8]]);

const result = math.map(a, b, (x, y) => x + y);

console.log(result); // [[6, 8], [10, 12]]


In this example, the map function takes matrices as the first two arguments and a callback function (x, y) => x + y as the third argument. The callback function is applied to each element of the matrices, where x represents the corresponding element from matrix a and y represents the corresponding element from matrix b. The result is a new matrix with the element-wise sum of the two matrices.

By using broadcasting and the map function, you can easily iterate over multiple matrices and perform element-wise operations.

const a = math.matrix([10, 20])
const b = math.matrix([[3, 4], [5, 6]])

const result = math.map(a, b, (x, y) => x + y)
console.log(result); // [[13, 24], [15, 26]]


It’s also possible to provide a callback with an index and the broadcasted arrays. Like (valueA, valueB, index) or even (valueA, valueB, index, broadcastedMatrixA, broadcastedMatrixB). There is no specific limit for the number of matrices N that can be mapped. Thus, the callback can have N arguments, N+1 arguments in the case of including the index, or 2N+1 arguments in the case of including the index and the broadcasted matrices in the callback.

At this moment forEach doesn’t include the same functionality.

Storage types #

Math.js supports both dense matrices as well as sparse matrices. Sparse matrices are efficient for matrices largely containing zeros. In that case they save a lot of memory, and calculations can be much faster than for dense matrices.

Math.js supports two type of matrices:


  Dense matrix ('dense', default) A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.
  Sparse matrix ('sparse'): A two dimensional sparse matrix implementation.


The type of matrix can be selected when creating a matrix using the construction functions matrix, diag, identity, ones, and zeros.

// create sparse matrices
const m1 = math.matrix([[0, 1], [0, 0]], 'sparse')
const m2 = math.identity(1000, 1000, 'sparse')


You can also coerce an array or matrix into sparse storage format with the
sparse function.
const md = math.matrix([[0, 1], [0,0]])  // dense
const ms = math.sparse(md)               // sparse


Caution: sparse called on a JavaScript array of n plain numbers produces
a matrix with one column and n rows – in contrast to matrix, which
produces a 1-dimensional matrix object with n entries, i.e., a vector
(not a 1 by n “row vector” nor an n by 1 “column vector”, but just a plain
vector of length n).
const mv = math.matrix([0, 0, 1])  // Has size [3]
const mc = math.sparse([0, 0, 1])  // A "column vector," has size [3, 1]


API #

All relevant functions in math.js support Matrices and Arrays. Functions like math.add and math.subtract, math.sqrt handle matrices element wise. There is a set of functions specifically for creating or manipulating matrices, such as:


  Functions like math.matrix and math.sparse, math.ones, math.zeros, and math.identity to create a matrix.
  Functions like math.subset and math.index to get or replace a part of a matrix
  Functions like math.transpose and math.diag to manipulate matrices.


A full list of matrix functions is available on the functions reference page.

Two types of matrix classes are available in math.js, for storage of dense and sparse matrices. Although they contain public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  DenseMatrix
  SparseMatrix\n\n\n\nMatrices #

Math.js supports multi dimensional matrices and arrays. Matrices can be
created, manipulated, and used in calculations. Both regular JavaScript
arrays as well as the matrix type implemented by math.js can be used
interchangeably in all relevant math.js functions. math.js supports both
dense and sparse matrices.

Arrays and matrices #

Math.js supports two types of matrices:


  Array, a regular JavaScript array. A multi dimensional array can be created
by nesting arrays.
  Matrix, a matrix implementation by math.js. A Matrix is an object wrapped
around a regular JavaScript Array, providing utility functions for easy
matrix manipulation such as subset, size, resize, clone, and more.


In most cases, the type of matrix output from functions is determined by the
function input: An Array as input will return an Array, a Matrix as input
will return a Matrix. In case of mixed input, a Matrix is returned.
For functions where the type of output cannot be determined from the
input, the output is determined by the configuration option matrix,
which can be a string 'Matrix' (default) or 'Array'.

// create an array and a matrix
const array = [[2, 0], [-1, 3]]               // Array
const matrix = math.matrix([[7, 1], [-2, 3]]) // Matrix

// perform a calculation on an array and matrix
math.map(array, math.square)                  // Array,  [[4, 0], [1, 9]]
math.map(matrix, math.square)                 // Matrix, [[49, 1], [4, 9]]

// perform calculations with mixed array and matrix input
math.add(array, matrix)                       // Matrix, [[9, 1], [-3, 6]]
math.multiply(array, matrix)                  // Matrix, [[14, 2], [-13, 8]]

// create a matrix. Type of output of function ones is determined by the
// configuration option `matrix`
math.ones(2, 3)                               // Matrix, [[1, 1, 1], [1, 1, 1]]


Creation #

A matrix can be created from an array using the function math.matrix. The
provided array can contain nested arrays in order to create a multi-dimensional matrix. When called without arguments, an empty matrix will be
created.

// create matrices
math.matrix()                           // Matrix, size [0]
math.matrix([0, 1, 2])                  // Matrix, size [3]
math.matrix([[0, 1], [2, 3], [4, 5]])   // Matrix, size [3, 2]


Math.js supports regular Arrays. Multiple dimensions can be created
by nesting Arrays in each other.

// create arrays
[]                                      // Array, size [0]
[0, 1, 2]                               // Array, size [3]
[[0, 1], [2, 3], [4, 5]]                // Array, size [3, 2]


Matrices can contain different types of values: numbers, complex numbers,
units, or strings. Different types can be mixed together in a single matrix.

// create a matrix with mixed types
const a = math.matrix([2.3, 'hello', math.complex(3, -4), math.unit('5.2 mm')]) 
a.subset(math.index(1))  // 'hello'


There are a number of functions to create a matrix with a specific size and
content: ones, zeros, identity.

// zeros creates a matrix filled with zeros
math.zeros(3)           // Matrix, size [3],    [0, 0, 0]
math.zeros(3, 2)        // Matrix, size [3, 2], [[0, 0], [0, 0], [0, 0]]
math.zeros(2, 2, 2)     // Matrix, size [2, 2, 2],
                        //   [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]

// ones creates a matrix filled with ones
math.ones(3)                        // Matrix, size [3],    [1, 1, 1]
math.multiply(math.ones(2, 2), 5)   // Matrix, size [2, 2], [[5, 5], [5, 5]]

// identity creates an identity matrix
math.identity(3)      // Matrix, size [3, 3], [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
math.identity(2, 3)   // Matrix, size [2, 3], [[1, 0, 0], [0, 1, 0]]


The functions ones, zeros, and identity also accept a single array
or matrix containing the dimensions for the matrix. When the input is an Array,
the functions will output an Array. When the input is a Matrix, the output will
be a Matrix. Note that in case of numbers as arguments, the output is
determined by the option matrix as discussed in section
Arrays and matrices.

// Array as input gives Array as output
math.ones([2, 3])               // Array,  size [3, 2], [[1, 1, 1], [1, 1, 1]]
math.ones(math.matrix([2, 3]))  // Matrix, size [3, 2], [[1, 1, 1], [1, 1, 1]]


Ranges can be created using the function range. The function range is
called with parameters start and end, and optionally a parameter step.
The start of the range is included, the end of the range is excluded.

math.range(0, 4)        // [0, 1, 2, 3]
math.range(0, 8, 2)     // [0, 2, 4, 6]
math.range(3, -1, -1)   // [3, 2, 1, 0]


Calculations #

Most functions of math.js support matrices and arrays. Unary functions can be applied element-wise using via math.map(matrix, function).

// perform an element-wise operation on a matrix using math.map
const a = math.matrix([1, 4, 9, 16, 25])  // Matrix, [1, 4, 9, 16, 25]
math.map(a, math.sqrt)                    // Matrix, [1, 2, 3, 4, 5]

// use a function that has built-in matrix and array support
const b = [1, 2, 3, 4, 5] 
math.factorial(b)                         // Array,  [1, 2, 6, 24, 120]

// multiply an array with a matrix
const c = [[2, 0], [-1, 3]]               // Array
const d = math.matrix([[7, 1], [-2, 3]])  // Matrix
math.multiply(c, d)                       // Matrix, [[14, 2], [-13, 8]]

// add a number to a matrix (see broadcasting)
math.add(c, 2)                            // Array, [[4, 2], [1, 5]]

// calculate the determinant of a matrix
math.det(c)                               // 6
math.det(d)                               // 23

Broadcasting #

Functions that require two or more matrix like arguments that operate elementwise automatically operate as if the arguments were the same size.

A = math.matrix([1, 2])       // Matrix, [1, 2]
math.add(A, 3)                // Matrix, [3, 4]

B = math.matrix([[3], [4]])   // Matrix, [[3], [4]]
math.add(A, B)                // Matrix, [[4, 5], [5, 6]]

Any index that is in one of the arguments, can be found as if it existed on the others when the size on that dimension is one or not existing. This is valid in N dimensions.

It’s not possible to broadcast in cases where the size in that dimension is higher than one.

math.add([1, 2], [3, 4, 5])
// Error: shape missmatch: missmatch is found in arg with shape (2) not possible to broadcast dimension 0 with size 2 to size 3

math.add([[1], [2], [3]], [[4], [5]])
// Error: shape missmatch: missmatch is found in arg with shape (2,1) not possible to broadcast dimension 0 with size 2 to size 3


Size and Dimensions #

Math.js uses geometric dimensions:


  A scalar is zero-dimensional.
  A vector is one-dimensional.
  A matrix is two or multi-dimensional.


The size of a matrix can be calculated with the function size. Function size
returns a Matrix or Array, depending on the configuration option matrix.
Furthermore, matrices have a function size as well, which always returns
an Array.

// get the size of a scalar
math.size(2.4)                                // Matrix, []
math.size(math.complex(3, 2))                 // Matrix, []
math.size(math.unit('5.3 mm'))                // Matrix, []

// get the size of a one-dimensional matrix (a vector) and a string
math.size([0, 1, 2, 3])                       // Array, [4]
math.size('hello world')                      // Matrix, [11]

// get the size of a two-dimensional matrix
const a = [[0, 1, 2, 3]]                      // Array
const b = math.matrix([[0, 1, 2], [3, 4, 5]]) // Matrix
math.size(a)                                  // Array, [1, 4]
math.size(b)                                  // Matrix, [2, 3]

// matrices have a function size (always returns an Array)
b.size()                                      // Array, [2, 3]

// get the size of a multi-dimensional matrix
const c = [[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]
math.size(c)                                  // Array, [2, 2, 3]


Note that the dimensions themselves do not have a meaning attached. 
When creating and printing a two dimensional matrix, the first dimension is 
normally rendered as the column, and the second dimension is rendered as 
the row. For example:

console.table(math.zeros([2, 4]))
// 0 0 0 0
// 0 0 0 0


If you have a matrix where the first dimension means x and the second 
means y, this will look confusing since x is printed as column 
(vertically) and y as row (horizontally).

Resizing #

Matrices can be resized using their resize function. This function is called
with an Array with the new size as the first argument, and accepts an optional
default value. By default, new entries will be set to 0, but it is possible
to pass a different default value like null to clearly indicate that
the entries haven’t been explicitly set.

const a = math.matrix() // Matrix, size [0],       []
a.resize([2, 3])        // Matrix, size [2, 3],    [[0, 0, 0], [0, 0, 0]]
a.resize([2, 2, 2])     // Matrix, size [2, 2, 2],
                        //   [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]

const b = math.matrix()
b.resize([3], 7)        // Matrix, size [3],    [7, 7, 7]
b.resize([5], 9)        // Matrix, size [5],    [7, 7, 7, 9, 9]
b.resize([2])           // Matrix, size [2],    [7, 7]


Outer dimensions of a matrix can be squeezed using the function squeeze. When
getting or setting a single value in a matrix using subset, the value is automatically squeezed
or unsqueezed too.

// squeeze a matrix
const a = [[[0, 1, 2]]]
math.squeeze(a)             // [0, 1, 2]
math.squeeze([[3]])         // 3

// when getting/setting a single value in a matrix using subset, 
// it automatically squeeze/unsqueeze the value
const b = math.matrix([[0, 1], [2, 3]])
b.subset(math.index(1, 0))  // 2 and not [[2]]


Getting or replacing subsets #

Subsets of a matrix can be retrieved or replaced using the function subset.
Matrices have a subset function, which is applied to the matrix itself:
Matrix.subset(index [, replacement]). For both matrices and arrays,
the static function subset(matrix, index [, replacement]) can be used.
When parameter replacement is provided, the function will replace a subset
in the matrix, and if not, a subset of the matrix will be returned.

A subset can be defined using an Index. An Index contains a single value
or a set of values for each dimension of a matrix. An Index can be
created using the function index. When getting a single value from a matrix,
subset will return the value itself instead of a matrix containing just this 
value.

The function subset normally returns a subset, but when getting or setting a
single value in a matrix, the value itself is returned.

Matrix indexes in math.js are zero-based, like most programming languages
including JavaScript itself. Note that mathematical applications like Matlab 
and Octave work differently, as they use one-based indexes.

// create some matrices
const a = [0, 1, 2, 3]
const b = [[0, 1], [2, 3]]
const c = math.zeros(2, 2)
const d = math.matrix([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
const e = math.matrix()

// get a subset
math.subset(a, math.index(1))                 // 1
math.subset(a, math.index([2, 3]))            // Array, [2, 3]
math.subset(a, math.index(math.range(0,4)))   // Array, [0, 1, 2, 3]
math.subset(b, math.index(1, 0))              // 2
math.subset(b, math.index(1, [0, 1]))         // Array, [2, 3]
math.subset(b, math.index([0, 1], 0))         // Matrix, [[0], [2]]

// get a subset
d.subset(math.index([1, 2], [0, 1]))          // Matrix, [[3, 4], [6, 7]]
d.subset(math.index(1, 2))                    // 5

// replace a subset. The subset will be applied to a clone of the matrix
math.subset(b, math.index(1, 0), 9)           // Array, [[0, 1], [9, 3]]
math.subset(b, math.index(2, [0, 1]), [4, 5]) // Array, [[0, 1], [2, 3], [4, 5]]

// replace a subset. The subset will be applied to the matrix itself
c.subset(math.index(0, 1),1)                  // Matrix, [[0, 1], [0, 0]]
c.subset(math.index(1, [0, 1]), [2, 3])       // Matrix, [[0, 1], [2, 3]]
e.resize([2, 3], 0)                           // Matrix, [[0, 0, 0], [0, 0, 0]]
e.subset(math.index(1, 2), 5)                 // Matrix, [[0, 0, 0], [0, 0, 5]]


Getting and setting a value in a matrix #

There are two methods available on matrices that allow to get or set a single 
value inside a matrix. It is important to note that the set method will 
mutate the matrix.

const p = math.matrix([[1, 2], [3, 4]])
p.set([0, 1], 5)
// p is now [[1, 5], [3, 4]]
p.get([1, 0]) // 3


When setting a value at a location outside of the current matrix size using the
method .set(), the matrix will be resized. By default, new items will be 
initialized with zero, but it is possible to specify an alternative value using
the optional third argument defaultValue.

Advanced Indexing #

Boolean array indexing is a technique that allows you to filter, replace, and set values in an array based on logical conditions. This can be done by creating a boolean array that represents the desired conditions, and then using that array as an index to select the elements of the original array that meet those conditions.

For example, a boolean array can be created to represent all the even numbers in an array, and then used to filter the original array to only include the even numbers. Alternatively, a boolean array can be created to represent all the elements of an array that are greater than a certain value, and then used to replace all the elements of the original array that are greater than that value with a new value.

const q = [1, 2, 3, 4]
math.subset(q, math.index([true, false, true, false]))      // Array [1, 3]

// filtering
math.subset(q, math.index(math.larger(q, 2)))               // Array [3, 4]

// filtering with no matches
math.subset(q, math.index(math.larger(q, 5)))               // Array []

// setting specific values, please note that the replacement value is broadcasted
q = math.subset(q, math.index(math.smaller(q, 3)), 0)       // q = [0, 0, 3, 4]

// replacing specific values
math.subset(q, math.index(math.equal(q, 0)), [1, 2])        // q = [1, 2, 3, 4]


The same can be accomplished in the parser in a much more compact manner. Please note that everything after # are comments.
math.evaluate(`
q = [1, 2, 3, 4]
q[[true, false, true, false]] # Matrix [1, 3]
q[q>2]                        # Matrix [3, 4]
q[q>5]                        # Matrix []
q[q <3] = 0                   # q = [0, 0, 3, 4]
q[q==0] = [1, 2]              # q = [1, 2, 3, 4]
`)

The expression inside the index can be as complex as needed as long it evaluates to an array of booleans of the same size.
math.evaluate(`
q = [1, 2, 3, 4]
r = [6, 5, 4, 3]
q[q > 3 and r < 4]     # [4]
`)


Iterating #

Matrices contain functions map and forEach to iterate over all elements of
the (multidimensional) matrix. The callback function of map and forEach has
three parameters: value (the value of the currently iterated element),
index (an array with the index value for each dimension), and matrix (the
matrix being iterated). This syntax is similar to the map and forEach
functions of native JavaScript Arrays, except that the index is no number but
an Array with numbers for each dimension.

const a = math.matrix([[0, 1], [2, 3], [4, 5]])

// The iteration below will output the following in the console:
//    value: 0 index: [0, 0]
//    value: 1 index: [0, 1]
//    value: 2 index: [1, 0]
//    value: 3 index: [1, 1]
//    value: 4 index: [2, 0]
//    value: 5 index: [2, 1]
a.forEach(function (value, index, matrix) {
  console.log('value:', value, 'index:', index) 
}) 

// Apply a transformation on the matrix
const b = a.map(function (value, index, matrix) {
  return math.multiply(math.sin(value), math.exp(math.abs(value))) 
}) 
console.log(b.format(5))  // [[0, 2.2874], [6.7188, 2.8345], [-41.32, -142.32]]

// Create a matrix with the cumulative of all elements
let count = 0
const cum = a.map(function (value, index, matrix) {
  count += value 
  return count 
}) 
console.log(cum.toString())  // [[0, 1], [3, 6], [10, 15]]


Iterating over multiple Matrixes or Arrays #

You can iterate over multiple matrices or arrays by using the map function. Mapping allows to perform element-wise operations on matrices by automatically adjusting their sizes to match each other.

To iterate over multiple matrices, you can use the map function. The map function applies a given function to each element of the matrices and returns a new matrix with the results.

Here’s an example of iterating over two matrices and adding their corresponding elements:

const a = math.matrix([[1, 2], [3, 4]]);
const b = math.matrix([[5, 6], [7, 8]]);

const result = math.map(a, b, (x, y) => x + y);

console.log(result); // [[6, 8], [10, 12]]


In this example, the map function takes matrices as the first two arguments and a callback function (x, y) => x + y as the third argument. The callback function is applied to each element of the matrices, where x represents the corresponding element from matrix a and y represents the corresponding element from matrix b. The result is a new matrix with the element-wise sum of the two matrices.

By using broadcasting and the map function, you can easily iterate over multiple matrices and perform element-wise operations.

const a = math.matrix([10, 20])
const b = math.matrix([[3, 4], [5, 6]])

const result = math.map(a, b, (x, y) => x + y)
console.log(result); // [[13, 24], [15, 26]]


It’s also possible to provide a callback with an index and the broadcasted arrays. Like (valueA, valueB, index) or even (valueA, valueB, index, broadcastedMatrixA, broadcastedMatrixB). There is no specific limit for the number of matrices N that can be mapped. Thus, the callback can have N arguments, N+1 arguments in the case of including the index, or 2N+1 arguments in the case of including the index and the broadcasted matrices in the callback.

At this moment forEach doesn’t include the same functionality.

Storage types #

Math.js supports both dense matrices as well as sparse matrices. Sparse matrices are efficient for matrices largely containing zeros. In that case they save a lot of memory, and calculations can be much faster than for dense matrices.

Math.js supports two type of matrices:


  Dense matrix ('dense', default) A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.
  Sparse matrix ('sparse'): A two dimensional sparse matrix implementation.


The type of matrix can be selected when creating a matrix using the construction functions matrix, diag, identity, ones, and zeros.

// create sparse matrices
const m1 = math.matrix([[0, 1], [0, 0]], 'sparse')
const m2 = math.identity(1000, 1000, 'sparse')


You can also coerce an array or matrix into sparse storage format with the
sparse function.
const md = math.matrix([[0, 1], [0,0]])  // dense
const ms = math.sparse(md)               // sparse


Caution: sparse called on a JavaScript array of n plain numbers produces
a matrix with one column and n rows – in contrast to matrix, which
produces a 1-dimensional matrix object with n entries, i.e., a vector
(not a 1 by n “row vector” nor an n by 1 “column vector”, but just a plain
vector of length n).
const mv = math.matrix([0, 0, 1])  // Has size [3]
const mc = math.sparse([0, 0, 1])  // A "column vector," has size [3, 1]


API #

All relevant functions in math.js support Matrices and Arrays. Functions like math.add and math.subtract, math.sqrt handle matrices element wise. There is a set of functions specifically for creating or manipulating matrices, such as:


  Functions like math.matrix and math.sparse, math.ones, math.zeros, and math.identity to create a matrix.
  Functions like math.subset and math.index to get or replace a part of a matrix
  Functions like math.transpose and math.diag to manipulate matrices.


A full list of matrix functions is available on the functions reference page.

Two types of matrix classes are available in math.js, for storage of dense and sparse matrices. Although they contain public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  DenseMatrix
  SparseMatrix\n\n\n\nMatrices #

Math.js supports multi dimensional matrices and arrays. Matrices can be
created, manipulated, and used in calculations. Both regular JavaScript
arrays as well as the matrix type implemented by math.js can be used
interchangeably in all relevant math.js functions. math.js supports both
dense and sparse matrices.

Arrays and matrices #

Math.js supports two types of matrices:


  Array, a regular JavaScript array. A multi dimensional array can be created
by nesting arrays.
  Matrix, a matrix implementation by math.js. A Matrix is an object wrapped
around a regular JavaScript Array, providing utility functions for easy
matrix manipulation such as subset, size, resize, clone, and more.


In most cases, the type of matrix output from functions is determined by the
function input: An Array as input will return an Array, a Matrix as input
will return a Matrix. In case of mixed input, a Matrix is returned.
For functions where the type of output cannot be determined from the
input, the output is determined by the configuration option matrix,
which can be a string 'Matrix' (default) or 'Array'.

// create an array and a matrix
const array = [[2, 0], [-1, 3]]               // Array
const matrix = math.matrix([[7, 1], [-2, 3]]) // Matrix

// perform a calculation on an array and matrix
math.map(array, math.square)                  // Array,  [[4, 0], [1, 9]]
math.map(matrix, math.square)                 // Matrix, [[49, 1], [4, 9]]

// perform calculations with mixed array and matrix input
math.add(array, matrix)                       // Matrix, [[9, 1], [-3, 6]]
math.multiply(array, matrix)                  // Matrix, [[14, 2], [-13, 8]]

// create a matrix. Type of output of function ones is determined by the
// configuration option `matrix`
math.ones(2, 3)                               // Matrix, [[1, 1, 1], [1, 1, 1]]


Creation #

A matrix can be created from an array using the function math.matrix. The
provided array can contain nested arrays in order to create a multi-dimensional matrix. When called without arguments, an empty matrix will be
created.

// create matrices
math.matrix()                           // Matrix, size [0]
math.matrix([0, 1, 2])                  // Matrix, size [3]
math.matrix([[0, 1], [2, 3], [4, 5]])   // Matrix, size [3, 2]


Math.js supports regular Arrays. Multiple dimensions can be created
by nesting Arrays in each other.

// create arrays
[]                                      // Array, size [0]
[0, 1, 2]                               // Array, size [3]
[[0, 1], [2, 3], [4, 5]]                // Array, size [3, 2]


Matrices can contain different types of values: numbers, complex numbers,
units, or strings. Different types can be mixed together in a single matrix.

// create a matrix with mixed types
const a = math.matrix([2.3, 'hello', math.complex(3, -4), math.unit('5.2 mm')]) 
a.subset(math.index(1))  // 'hello'


There are a number of functions to create a matrix with a specific size and
content: ones, zeros, identity.

// zeros creates a matrix filled with zeros
math.zeros(3)           // Matrix, size [3],    [0, 0, 0]
math.zeros(3, 2)        // Matrix, size [3, 2], [[0, 0], [0, 0], [0, 0]]
math.zeros(2, 2, 2)     // Matrix, size [2, 2, 2],
                        //   [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]

// ones creates a matrix filled with ones
math.ones(3)                        // Matrix, size [3],    [1, 1, 1]
math.multiply(math.ones(2, 2), 5)   // Matrix, size [2, 2], [[5, 5], [5, 5]]

// identity creates an identity matrix
math.identity(3)      // Matrix, size [3, 3], [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
math.identity(2, 3)   // Matrix, size [2, 3], [[1, 0, 0], [0, 1, 0]]


The functions ones, zeros, and identity also accept a single array
or matrix containing the dimensions for the matrix. When the input is an Array,
the functions will output an Array. When the input is a Matrix, the output will
be a Matrix. Note that in case of numbers as arguments, the output is
determined by the option matrix as discussed in section
Arrays and matrices.

// Array as input gives Array as output
math.ones([2, 3])               // Array,  size [3, 2], [[1, 1, 1], [1, 1, 1]]
math.ones(math.matrix([2, 3]))  // Matrix, size [3, 2], [[1, 1, 1], [1, 1, 1]]


Ranges can be created using the function range. The function range is
called with parameters start and end, and optionally a parameter step.
The start of the range is included, the end of the range is excluded.

math.range(0, 4)        // [0, 1, 2, 3]
math.range(0, 8, 2)     // [0, 2, 4, 6]
math.range(3, -1, -1)   // [3, 2, 1, 0]


Calculations #

Most functions of math.js support matrices and arrays. Unary functions can be applied element-wise using via math.map(matrix, function).

// perform an element-wise operation on a matrix using math.map
const a = math.matrix([1, 4, 9, 16, 25])  // Matrix, [1, 4, 9, 16, 25]
math.map(a, math.sqrt)                    // Matrix, [1, 2, 3, 4, 5]

// use a function that has built-in matrix and array support
const b = [1, 2, 3, 4, 5] 
math.factorial(b)                         // Array,  [1, 2, 6, 24, 120]

// multiply an array with a matrix
const c = [[2, 0], [-1, 3]]               // Array
const d = math.matrix([[7, 1], [-2, 3]])  // Matrix
math.multiply(c, d)                       // Matrix, [[14, 2], [-13, 8]]

// add a number to a matrix (see broadcasting)
math.add(c, 2)                            // Array, [[4, 2], [1, 5]]

// calculate the determinant of a matrix
math.det(c)                               // 6
math.det(d)                               // 23

Broadcasting #

Functions that require two or more matrix like arguments that operate elementwise automatically operate as if the arguments were the same size.

A = math.matrix([1, 2])       // Matrix, [1, 2]
math.add(A, 3)                // Matrix, [3, 4]

B = math.matrix([[3], [4]])   // Matrix, [[3], [4]]
math.add(A, B)                // Matrix, [[4, 5], [5, 6]]

Any index that is in one of the arguments, can be found as if it existed on the others when the size on that dimension is one or not existing. This is valid in N dimensions.

It’s not possible to broadcast in cases where the size in that dimension is higher than one.

math.add([1, 2], [3, 4, 5])
// Error: shape missmatch: missmatch is found in arg with shape (2) not possible to broadcast dimension 0 with size 2 to size 3

math.add([[1], [2], [3]], [[4], [5]])
// Error: shape missmatch: missmatch is found in arg with shape (2,1) not possible to broadcast dimension 0 with size 2 to size 3


Size and Dimensions #

Math.js uses geometric dimensions:


  A scalar is zero-dimensional.
  A vector is one-dimensional.
  A matrix is two or multi-dimensional.


The size of a matrix can be calculated with the function size. Function size
returns a Matrix or Array, depending on the configuration option matrix.
Furthermore, matrices have a function size as well, which always returns
an Array.

// get the size of a scalar
math.size(2.4)                                // Matrix, []
math.size(math.complex(3, 2))                 // Matrix, []
math.size(math.unit('5.3 mm'))                // Matrix, []

// get the size of a one-dimensional matrix (a vector) and a string
math.size([0, 1, 2, 3])                       // Array, [4]
math.size('hello world')                      // Matrix, [11]

// get the size of a two-dimensional matrix
const a = [[0, 1, 2, 3]]                      // Array
const b = math.matrix([[0, 1, 2], [3, 4, 5]]) // Matrix
math.size(a)                                  // Array, [1, 4]
math.size(b)                                  // Matrix, [2, 3]

// matrices have a function size (always returns an Array)
b.size()                                      // Array, [2, 3]

// get the size of a multi-dimensional matrix
const c = [[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]
math.size(c)                                  // Array, [2, 2, 3]


Note that the dimensions themselves do not have a meaning attached. 
When creating and printing a two dimensional matrix, the first dimension is 
normally rendered as the column, and the second dimension is rendered as 
the row. For example:

console.table(math.zeros([2, 4]))
// 0 0 0 0
// 0 0 0 0


If you have a matrix where the first dimension means x and the second 
means y, this will look confusing since x is printed as column 
(vertically) and y as row (horizontally).

Resizing #

Matrices can be resized using their resize function. This function is called
with an Array with the new size as the first argument, and accepts an optional
default value. By default, new entries will be set to 0, but it is possible
to pass a different default value like null to clearly indicate that
the entries haven’t been explicitly set.

const a = math.matrix() // Matrix, size [0],       []
a.resize([2, 3])        // Matrix, size [2, 3],    [[0, 0, 0], [0, 0, 0]]
a.resize([2, 2, 2])     // Matrix, size [2, 2, 2],
                        //   [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]

const b = math.matrix()
b.resize([3], 7)        // Matrix, size [3],    [7, 7, 7]
b.resize([5], 9)        // Matrix, size [5],    [7, 7, 7, 9, 9]
b.resize([2])           // Matrix, size [2],    [7, 7]


Outer dimensions of a matrix can be squeezed using the function squeeze. When
getting or setting a single value in a matrix using subset, the value is automatically squeezed
or unsqueezed too.

// squeeze a matrix
const a = [[[0, 1, 2]]]
math.squeeze(a)             // [0, 1, 2]
math.squeeze([[3]])         // 3

// when getting/setting a single value in a matrix using subset, 
// it automatically squeeze/unsqueeze the value
const b = math.matrix([[0, 1], [2, 3]])
b.subset(math.index(1, 0))  // 2 and not [[2]]


Getting or replacing subsets #

Subsets of a matrix can be retrieved or replaced using the function subset.
Matrices have a subset function, which is applied to the matrix itself:
Matrix.subset(index [, replacement]). For both matrices and arrays,
the static function subset(matrix, index [, replacement]) can be used.
When parameter replacement is provided, the function will replace a subset
in the matrix, and if not, a subset of the matrix will be returned.

A subset can be defined using an Index. An Index contains a single value
or a set of values for each dimension of a matrix. An Index can be
created using the function index. When getting a single value from a matrix,
subset will return the value itself instead of a matrix containing just this 
value.

The function subset normally returns a subset, but when getting or setting a
single value in a matrix, the value itself is returned.

Matrix indexes in math.js are zero-based, like most programming languages
including JavaScript itself. Note that mathematical applications like Matlab 
and Octave work differently, as they use one-based indexes.

// create some matrices
const a = [0, 1, 2, 3]
const b = [[0, 1], [2, 3]]
const c = math.zeros(2, 2)
const d = math.matrix([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
const e = math.matrix()

// get a subset
math.subset(a, math.index(1))                 // 1
math.subset(a, math.index([2, 3]))            // Array, [2, 3]
math.subset(a, math.index(math.range(0,4)))   // Array, [0, 1, 2, 3]
math.subset(b, math.index(1, 0))              // 2
math.subset(b, math.index(1, [0, 1]))         // Array, [2, 3]
math.subset(b, math.index([0, 1], 0))         // Matrix, [[0], [2]]

// get a subset
d.subset(math.index([1, 2], [0, 1]))          // Matrix, [[3, 4], [6, 7]]
d.subset(math.index(1, 2))                    // 5

// replace a subset. The subset will be applied to a clone of the matrix
math.subset(b, math.index(1, 0), 9)           // Array, [[0, 1], [9, 3]]
math.subset(b, math.index(2, [0, 1]), [4, 5]) // Array, [[0, 1], [2, 3], [4, 5]]

// replace a subset. The subset will be applied to the matrix itself
c.subset(math.index(0, 1),1)                  // Matrix, [[0, 1], [0, 0]]
c.subset(math.index(1, [0, 1]), [2, 3])       // Matrix, [[0, 1], [2, 3]]
e.resize([2, 3], 0)                           // Matrix, [[0, 0, 0], [0, 0, 0]]
e.subset(math.index(1, 2), 5)                 // Matrix, [[0, 0, 0], [0, 0, 5]]


Getting and setting a value in a matrix #

There are two methods available on matrices that allow to get or set a single 
value inside a matrix. It is important to note that the set method will 
mutate the matrix.

const p = math.matrix([[1, 2], [3, 4]])
p.set([0, 1], 5)
// p is now [[1, 5], [3, 4]]
p.get([1, 0]) // 3


When setting a value at a location outside of the current matrix size using the
method .set(), the matrix will be resized. By default, new items will be 
initialized with zero, but it is possible to specify an alternative value using
the optional third argument defaultValue.

Advanced Indexing #

Boolean array indexing is a technique that allows you to filter, replace, and set values in an array based on logical conditions. This can be done by creating a boolean array that represents the desired conditions, and then using that array as an index to select the elements of the original array that meet those conditions.

For example, a boolean array can be created to represent all the even numbers in an array, and then used to filter the original array to only include the even numbers. Alternatively, a boolean array can be created to represent all the elements of an array that are greater than a certain value, and then used to replace all the elements of the original array that are greater than that value with a new value.

const q = [1, 2, 3, 4]
math.subset(q, math.index([true, false, true, false]))      // Array [1, 3]

// filtering
math.subset(q, math.index(math.larger(q, 2)))               // Array [3, 4]

// filtering with no matches
math.subset(q, math.index(math.larger(q, 5)))               // Array []

// setting specific values, please note that the replacement value is broadcasted
q = math.subset(q, math.index(math.smaller(q, 3)), 0)       // q = [0, 0, 3, 4]

// replacing specific values
math.subset(q, math.index(math.equal(q, 0)), [1, 2])        // q = [1, 2, 3, 4]


The same can be accomplished in the parser in a much more compact manner. Please note that everything after # are comments.
math.evaluate(`
q = [1, 2, 3, 4]
q[[true, false, true, false]] # Matrix [1, 3]
q[q>2]                        # Matrix [3, 4]
q[q>5]                        # Matrix []
q[q <3] = 0                   # q = [0, 0, 3, 4]
q[q==0] = [1, 2]              # q = [1, 2, 3, 4]
`)

The expression inside the index can be as complex as needed as long it evaluates to an array of booleans of the same size.
math.evaluate(`
q = [1, 2, 3, 4]
r = [6, 5, 4, 3]
q[q > 3 and r < 4]     # [4]
`)


Iterating #

Matrices contain functions map and forEach to iterate over all elements of
the (multidimensional) matrix. The callback function of map and forEach has
three parameters: value (the value of the currently iterated element),
index (an array with the index value for each dimension), and matrix (the
matrix being iterated). This syntax is similar to the map and forEach
functions of native JavaScript Arrays, except that the index is no number but
an Array with numbers for each dimension.

const a = math.matrix([[0, 1], [2, 3], [4, 5]])

// The iteration below will output the following in the console:
//    value: 0 index: [0, 0]
//    value: 1 index: [0, 1]
//    value: 2 index: [1, 0]
//    value: 3 index: [1, 1]
//    value: 4 index: [2, 0]
//    value: 5 index: [2, 1]
a.forEach(function (value, index, matrix) {
  console.log('value:', value, 'index:', index) 
}) 

// Apply a transformation on the matrix
const b = a.map(function (value, index, matrix) {
  return math.multiply(math.sin(value), math.exp(math.abs(value))) 
}) 
console.log(b.format(5))  // [[0, 2.2874], [6.7188, 2.8345], [-41.32, -142.32]]

// Create a matrix with the cumulative of all elements
let count = 0
const cum = a.map(function (value, index, matrix) {
  count += value 
  return count 
}) 
console.log(cum.toString())  // [[0, 1], [3, 6], [10, 15]]


Iterating over multiple Matrixes or Arrays #

You can iterate over multiple matrices or arrays by using the map function. Mapping allows to perform element-wise operations on matrices by automatically adjusting their sizes to match each other.

To iterate over multiple matrices, you can use the map function. The map function applies a given function to each element of the matrices and returns a new matrix with the results.

Here’s an example of iterating over two matrices and adding their corresponding elements:

const a = math.matrix([[1, 2], [3, 4]]);
const b = math.matrix([[5, 6], [7, 8]]);

const result = math.map(a, b, (x, y) => x + y);

console.log(result); // [[6, 8], [10, 12]]


In this example, the map function takes matrices as the first two arguments and a callback function (x, y) => x + y as the third argument. The callback function is applied to each element of the matrices, where x represents the corresponding element from matrix a and y represents the corresponding element from matrix b. The result is a new matrix with the element-wise sum of the two matrices.

By using broadcasting and the map function, you can easily iterate over multiple matrices and perform element-wise operations.

const a = math.matrix([10, 20])
const b = math.matrix([[3, 4], [5, 6]])

const result = math.map(a, b, (x, y) => x + y)
console.log(result); // [[13, 24], [15, 26]]


It’s also possible to provide a callback with an index and the broadcasted arrays. Like (valueA, valueB, index) or even (valueA, valueB, index, broadcastedMatrixA, broadcastedMatrixB). There is no specific limit for the number of matrices N that can be mapped. Thus, the callback can have N arguments, N+1 arguments in the case of including the index, or 2N+1 arguments in the case of including the index and the broadcasted matrices in the callback.

At this moment forEach doesn’t include the same functionality.

Storage types #

Math.js supports both dense matrices as well as sparse matrices. Sparse matrices are efficient for matrices largely containing zeros. In that case they save a lot of memory, and calculations can be much faster than for dense matrices.

Math.js supports two type of matrices:


  Dense matrix ('dense', default) A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.
  Sparse matrix ('sparse'): A two dimensional sparse matrix implementation.


The type of matrix can be selected when creating a matrix using the construction functions matrix, diag, identity, ones, and zeros.

// create sparse matrices
const m1 = math.matrix([[0, 1], [0, 0]], 'sparse')
const m2 = math.identity(1000, 1000, 'sparse')


You can also coerce an array or matrix into sparse storage format with the
sparse function.
const md = math.matrix([[0, 1], [0,0]])  // dense
const ms = math.sparse(md)               // sparse


Caution: sparse called on a JavaScript array of n plain numbers produces
a matrix with one column and n rows – in contrast to matrix, which
produces a 1-dimensional matrix object with n entries, i.e., a vector
(not a 1 by n “row vector” nor an n by 1 “column vector”, but just a plain
vector of length n).
const mv = math.matrix([0, 0, 1])  // Has size [3]
const mc = math.sparse([0, 0, 1])  // A "column vector," has size [3, 1]


API #

All relevant functions in math.js support Matrices and Arrays. Functions like math.add and math.subtract, math.sqrt handle matrices element wise. There is a set of functions specifically for creating or manipulating matrices, such as:


  Functions like math.matrix and math.sparse, math.ones, math.zeros, and math.identity to create a matrix.
  Functions like math.subset and math.index to get or replace a part of a matrix
  Functions like math.transpose and math.diag to manipulate matrices.


A full list of matrix functions is available on the functions reference page.

Two types of matrix classes are available in math.js, for storage of dense and sparse matrices. Although they contain public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  DenseMatrix
  SparseMatrix\n\n\n\nMatrices #

Math.js supports multi dimensional matrices and arrays. Matrices can be
created, manipulated, and used in calculations. Both regular JavaScript
arrays as well as the matrix type implemented by math.js can be used
interchangeably in all relevant math.js functions. math.js supports both
dense and sparse matrices.

Arrays and matrices #

Math.js supports two types of matrices:


  Array, a regular JavaScript array. A multi dimensional array can be created
by nesting arrays.
  Matrix, a matrix implementation by math.js. A Matrix is an object wrapped
around a regular JavaScript Array, providing utility functions for easy
matrix manipulation such as subset, size, resize, clone, and more.


In most cases, the type of matrix output from functions is determined by the
function input: An Array as input will return an Array, a Matrix as input
will return a Matrix. In case of mixed input, a Matrix is returned.
For functions where the type of output cannot be determined from the
input, the output is determined by the configuration option matrix,
which can be a string 'Matrix' (default) or 'Array'.

// create an array and a matrix
const array = [[2, 0], [-1, 3]]               // Array
const matrix = math.matrix([[7, 1], [-2, 3]]) // Matrix

// perform a calculation on an array and matrix
math.map(array, math.square)                  // Array,  [[4, 0], [1, 9]]
math.map(matrix, math.square)                 // Matrix, [[49, 1], [4, 9]]

// perform calculations with mixed array and matrix input
math.add(array, matrix)                       // Matrix, [[9, 1], [-3, 6]]
math.multiply(array, matrix)                  // Matrix, [[14, 2], [-13, 8]]

// create a matrix. Type of output of function ones is determined by the
// configuration option `matrix`
math.ones(2, 3)                               // Matrix, [[1, 1, 1], [1, 1, 1]]


Creation #

A matrix can be created from an array using the function math.matrix. The
provided array can contain nested arrays in order to create a multi-dimensional matrix. When called without arguments, an empty matrix will be
created.

// create matrices
math.matrix()                           // Matrix, size [0]
math.matrix([0, 1, 2])                  // Matrix, size [3]
math.matrix([[0, 1], [2, 3], [4, 5]])   // Matrix, size [3, 2]


Math.js supports regular Arrays. Multiple dimensions can be created
by nesting Arrays in each other.

// create arrays
[]                                      // Array, size [0]
[0, 1, 2]                               // Array, size [3]
[[0, 1], [2, 3], [4, 5]]                // Array, size [3, 2]


Matrices can contain different types of values: numbers, complex numbers,
units, or strings. Different types can be mixed together in a single matrix.

// create a matrix with mixed types
const a = math.matrix([2.3, 'hello', math.complex(3, -4), math.unit('5.2 mm')]) 
a.subset(math.index(1))  // 'hello'


There are a number of functions to create a matrix with a specific size and
content: ones, zeros, identity.

// zeros creates a matrix filled with zeros
math.zeros(3)           // Matrix, size [3],    [0, 0, 0]
math.zeros(3, 2)        // Matrix, size [3, 2], [[0, 0], [0, 0], [0, 0]]
math.zeros(2, 2, 2)     // Matrix, size [2, 2, 2],
                        //   [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]

// ones creates a matrix filled with ones
math.ones(3)                        // Matrix, size [3],    [1, 1, 1]
math.multiply(math.ones(2, 2), 5)   // Matrix, size [2, 2], [[5, 5], [5, 5]]

// identity creates an identity matrix
math.identity(3)      // Matrix, size [3, 3], [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
math.identity(2, 3)   // Matrix, size [2, 3], [[1, 0, 0], [0, 1, 0]]


The functions ones, zeros, and identity also accept a single array
or matrix containing the dimensions for the matrix. When the input is an Array,
the functions will output an Array. When the input is a Matrix, the output will
be a Matrix. Note that in case of numbers as arguments, the output is
determined by the option matrix as discussed in section
Arrays and matrices.

// Array as input gives Array as output
math.ones([2, 3])               // Array,  size [3, 2], [[1, 1, 1], [1, 1, 1]]
math.ones(math.matrix([2, 3]))  // Matrix, size [3, 2], [[1, 1, 1], [1, 1, 1]]


Ranges can be created using the function range. The function range is
called with parameters start and end, and optionally a parameter step.
The start of the range is included, the end of the range is excluded.

math.range(0, 4)        // [0, 1, 2, 3]
math.range(0, 8, 2)     // [0, 2, 4, 6]
math.range(3, -1, -1)   // [3, 2, 1, 0]


Calculations #

Most functions of math.js support matrices and arrays. Unary functions can be applied element-wise using via math.map(matrix, function).

// perform an element-wise operation on a matrix using math.map
const a = math.matrix([1, 4, 9, 16, 25])  // Matrix, [1, 4, 9, 16, 25]
math.map(a, math.sqrt)                    // Matrix, [1, 2, 3, 4, 5]

// use a function that has built-in matrix and array support
const b = [1, 2, 3, 4, 5] 
math.factorial(b)                         // Array,  [1, 2, 6, 24, 120]

// multiply an array with a matrix
const c = [[2, 0], [-1, 3]]               // Array
const d = math.matrix([[7, 1], [-2, 3]])  // Matrix
math.multiply(c, d)                       // Matrix, [[14, 2], [-13, 8]]

// add a number to a matrix (see broadcasting)
math.add(c, 2)                            // Array, [[4, 2], [1, 5]]

// calculate the determinant of a matrix
math.det(c)                               // 6
math.det(d)                               // 23

Broadcasting #

Functions that require two or more matrix like arguments that operate elementwise automatically operate as if the arguments were the same size.

A = math.matrix([1, 2])       // Matrix, [1, 2]
math.add(A, 3)                // Matrix, [3, 4]

B = math.matrix([[3], [4]])   // Matrix, [[3], [4]]
math.add(A, B)                // Matrix, [[4, 5], [5, 6]]

Any index that is in one of the arguments, can be found as if it existed on the others when the size on that dimension is one or not existing. This is valid in N dimensions.

It’s not possible to broadcast in cases where the size in that dimension is higher than one.

math.add([1, 2], [3, 4, 5])
// Error: shape missmatch: missmatch is found in arg with shape (2) not possible to broadcast dimension 0 with size 2 to size 3

math.add([[1], [2], [3]], [[4], [5]])
// Error: shape missmatch: missmatch is found in arg with shape (2,1) not possible to broadcast dimension 0 with size 2 to size 3


Size and Dimensions #

Math.js uses geometric dimensions:


  A scalar is zero-dimensional.
  A vector is one-dimensional.
  A matrix is two or multi-dimensional.


The size of a matrix can be calculated with the function size. Function size
returns a Matrix or Array, depending on the configuration option matrix.
Furthermore, matrices have a function size as well, which always returns
an Array.

// get the size of a scalar
math.size(2.4)                                // Matrix, []
math.size(math.complex(3, 2))                 // Matrix, []
math.size(math.unit('5.3 mm'))                // Matrix, []

// get the size of a one-dimensional matrix (a vector) and a string
math.size([0, 1, 2, 3])                       // Array, [4]
math.size('hello world')                      // Matrix, [11]

// get the size of a two-dimensional matrix
const a = [[0, 1, 2, 3]]                      // Array
const b = math.matrix([[0, 1, 2], [3, 4, 5]]) // Matrix
math.size(a)                                  // Array, [1, 4]
math.size(b)                                  // Matrix, [2, 3]

// matrices have a function size (always returns an Array)
b.size()                                      // Array, [2, 3]

// get the size of a multi-dimensional matrix
const c = [[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]
math.size(c)                                  // Array, [2, 2, 3]


Note that the dimensions themselves do not have a meaning attached. 
When creating and printing a two dimensional matrix, the first dimension is 
normally rendered as the column, and the second dimension is rendered as 
the row. For example:

console.table(math.zeros([2, 4]))
// 0 0 0 0
// 0 0 0 0


If you have a matrix where the first dimension means x and the second 
means y, this will look confusing since x is printed as column 
(vertically) and y as row (horizontally).

Resizing #

Matrices can be resized using their resize function. This function is called
with an Array with the new size as the first argument, and accepts an optional
default value. By default, new entries will be set to 0, but it is possible
to pass a different default value like null to clearly indicate that
the entries haven’t been explicitly set.

const a = math.matrix() // Matrix, size [0],       []
a.resize([2, 3])        // Matrix, size [2, 3],    [[0, 0, 0], [0, 0, 0]]
a.resize([2, 2, 2])     // Matrix, size [2, 2, 2],
                        //   [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]

const b = math.matrix()
b.resize([3], 7)        // Matrix, size [3],    [7, 7, 7]
b.resize([5], 9)        // Matrix, size [5],    [7, 7, 7, 9, 9]
b.resize([2])           // Matrix, size [2],    [7, 7]


Outer dimensions of a matrix can be squeezed using the function squeeze. When
getting or setting a single value in a matrix using subset, the value is automatically squeezed
or unsqueezed too.

// squeeze a matrix
const a = [[[0, 1, 2]]]
math.squeeze(a)             // [0, 1, 2]
math.squeeze([[3]])         // 3

// when getting/setting a single value in a matrix using subset, 
// it automatically squeeze/unsqueeze the value
const b = math.matrix([[0, 1], [2, 3]])
b.subset(math.index(1, 0))  // 2 and not [[2]]


Getting or replacing subsets #

Subsets of a matrix can be retrieved or replaced using the function subset.
Matrices have a subset function, which is applied to the matrix itself:
Matrix.subset(index [, replacement]). For both matrices and arrays,
the static function subset(matrix, index [, replacement]) can be used.
When parameter replacement is provided, the function will replace a subset
in the matrix, and if not, a subset of the matrix will be returned.

A subset can be defined using an Index. An Index contains a single value
or a set of values for each dimension of a matrix. An Index can be
created using the function index. When getting a single value from a matrix,
subset will return the value itself instead of a matrix containing just this 
value.

The function subset normally returns a subset, but when getting or setting a
single value in a matrix, the value itself is returned.

Matrix indexes in math.js are zero-based, like most programming languages
including JavaScript itself. Note that mathematical applications like Matlab 
and Octave work differently, as they use one-based indexes.

// create some matrices
const a = [0, 1, 2, 3]
const b = [[0, 1], [2, 3]]
const c = math.zeros(2, 2)
const d = math.matrix([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
const e = math.matrix()

// get a subset
math.subset(a, math.index(1))                 // 1
math.subset(a, math.index([2, 3]))            // Array, [2, 3]
math.subset(a, math.index(math.range(0,4)))   // Array, [0, 1, 2, 3]
math.subset(b, math.index(1, 0))              // 2
math.subset(b, math.index(1, [0, 1]))         // Array, [2, 3]
math.subset(b, math.index([0, 1], 0))         // Matrix, [[0], [2]]

// get a subset
d.subset(math.index([1, 2], [0, 1]))          // Matrix, [[3, 4], [6, 7]]
d.subset(math.index(1, 2))                    // 5

// replace a subset. The subset will be applied to a clone of the matrix
math.subset(b, math.index(1, 0), 9)           // Array, [[0, 1], [9, 3]]
math.subset(b, math.index(2, [0, 1]), [4, 5]) // Array, [[0, 1], [2, 3], [4, 5]]

// replace a subset. The subset will be applied to the matrix itself
c.subset(math.index(0, 1),1)                  // Matrix, [[0, 1], [0, 0]]
c.subset(math.index(1, [0, 1]), [2, 3])       // Matrix, [[0, 1], [2, 3]]
e.resize([2, 3], 0)                           // Matrix, [[0, 0, 0], [0, 0, 0]]
e.subset(math.index(1, 2), 5)                 // Matrix, [[0, 0, 0], [0, 0, 5]]


Getting and setting a value in a matrix #

There are two methods available on matrices that allow to get or set a single 
value inside a matrix. It is important to note that the set method will 
mutate the matrix.

const p = math.matrix([[1, 2], [3, 4]])
p.set([0, 1], 5)
// p is now [[1, 5], [3, 4]]
p.get([1, 0]) // 3


When setting a value at a location outside of the current matrix size using the
method .set(), the matrix will be resized. By default, new items will be 
initialized with zero, but it is possible to specify an alternative value using
the optional third argument defaultValue.

Advanced Indexing #

Boolean array indexing is a technique that allows you to filter, replace, and set values in an array based on logical conditions. This can be done by creating a boolean array that represents the desired conditions, and then using that array as an index to select the elements of the original array that meet those conditions.

For example, a boolean array can be created to represent all the even numbers in an array, and then used to filter the original array to only include the even numbers. Alternatively, a boolean array can be created to represent all the elements of an array that are greater than a certain value, and then used to replace all the elements of the original array that are greater than that value with a new value.

const q = [1, 2, 3, 4]
math.subset(q, math.index([true, false, true, false]))      // Array [1, 3]

// filtering
math.subset(q, math.index(math.larger(q, 2)))               // Array [3, 4]

// filtering with no matches
math.subset(q, math.index(math.larger(q, 5)))               // Array []

// setting specific values, please note that the replacement value is broadcasted
q = math.subset(q, math.index(math.smaller(q, 3)), 0)       // q = [0, 0, 3, 4]

// replacing specific values
math.subset(q, math.index(math.equal(q, 0)), [1, 2])        // q = [1, 2, 3, 4]


The same can be accomplished in the parser in a much more compact manner. Please note that everything after # are comments.
math.evaluate(`
q = [1, 2, 3, 4]
q[[true, false, true, false]] # Matrix [1, 3]
q[q>2]                        # Matrix [3, 4]
q[q>5]                        # Matrix []
q[q <3] = 0                   # q = [0, 0, 3, 4]
q[q==0] = [1, 2]              # q = [1, 2, 3, 4]
`)

The expression inside the index can be as complex as needed as long it evaluates to an array of booleans of the same size.
math.evaluate(`
q = [1, 2, 3, 4]
r = [6, 5, 4, 3]
q[q > 3 and r < 4]     # [4]
`)


Iterating #

Matrices contain functions map and forEach to iterate over all elements of
the (multidimensional) matrix. The callback function of map and forEach has
three parameters: value (the value of the currently iterated element),
index (an array with the index value for each dimension), and matrix (the
matrix being iterated). This syntax is similar to the map and forEach
functions of native JavaScript Arrays, except that the index is no number but
an Array with numbers for each dimension.

const a = math.matrix([[0, 1], [2, 3], [4, 5]])

// The iteration below will output the following in the console:
//    value: 0 index: [0, 0]
//    value: 1 index: [0, 1]
//    value: 2 index: [1, 0]
//    value: 3 index: [1, 1]
//    value: 4 index: [2, 0]
//    value: 5 index: [2, 1]
a.forEach(function (value, index, matrix) {
  console.log('value:', value, 'index:', index) 
}) 

// Apply a transformation on the matrix
const b = a.map(function (value, index, matrix) {
  return math.multiply(math.sin(value), math.exp(math.abs(value))) 
}) 
console.log(b.format(5))  // [[0, 2.2874], [6.7188, 2.8345], [-41.32, -142.32]]

// Create a matrix with the cumulative of all elements
let count = 0
const cum = a.map(function (value, index, matrix) {
  count += value 
  return count 
}) 
console.log(cum.toString())  // [[0, 1], [3, 6], [10, 15]]


Iterating over multiple Matrixes or Arrays #

You can iterate over multiple matrices or arrays by using the map function. Mapping allows to perform element-wise operations on matrices by automatically adjusting their sizes to match each other.

To iterate over multiple matrices, you can use the map function. The map function applies a given function to each element of the matrices and returns a new matrix with the results.

Here’s an example of iterating over two matrices and adding their corresponding elements:

const a = math.matrix([[1, 2], [3, 4]]);
const b = math.matrix([[5, 6], [7, 8]]);

const result = math.map(a, b, (x, y) => x + y);

console.log(result); // [[6, 8], [10, 12]]


In this example, the map function takes matrices as the first two arguments and a callback function (x, y) => x + y as the third argument. The callback function is applied to each element of the matrices, where x represents the corresponding element from matrix a and y represents the corresponding element from matrix b. The result is a new matrix with the element-wise sum of the two matrices.

By using broadcasting and the map function, you can easily iterate over multiple matrices and perform element-wise operations.

const a = math.matrix([10, 20])
const b = math.matrix([[3, 4], [5, 6]])

const result = math.map(a, b, (x, y) => x + y)
console.log(result); // [[13, 24], [15, 26]]


It’s also possible to provide a callback with an index and the broadcasted arrays. Like (valueA, valueB, index) or even (valueA, valueB, index, broadcastedMatrixA, broadcastedMatrixB). There is no specific limit for the number of matrices N that can be mapped. Thus, the callback can have N arguments, N+1 arguments in the case of including the index, or 2N+1 arguments in the case of including the index and the broadcasted matrices in the callback.

At this moment forEach doesn’t include the same functionality.

Storage types #

Math.js supports both dense matrices as well as sparse matrices. Sparse matrices are efficient for matrices largely containing zeros. In that case they save a lot of memory, and calculations can be much faster than for dense matrices.

Math.js supports two type of matrices:


  Dense matrix ('dense', default) A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.
  Sparse matrix ('sparse'): A two dimensional sparse matrix implementation.


The type of matrix can be selected when creating a matrix using the construction functions matrix, diag, identity, ones, and zeros.

// create sparse matrices
const m1 = math.matrix([[0, 1], [0, 0]], 'sparse')
const m2 = math.identity(1000, 1000, 'sparse')


You can also coerce an array or matrix into sparse storage format with the
sparse function.
const md = math.matrix([[0, 1], [0,0]])  // dense
const ms = math.sparse(md)               // sparse


Caution: sparse called on a JavaScript array of n plain numbers produces
a matrix with one column and n rows – in contrast to matrix, which
produces a 1-dimensional matrix object with n entries, i.e., a vector
(not a 1 by n “row vector” nor an n by 1 “column vector”, but just a plain
vector of length n).
const mv = math.matrix([0, 0, 1])  // Has size [3]
const mc = math.sparse([0, 0, 1])  // A "column vector," has size [3, 1]


API #

All relevant functions in math.js support Matrices and Arrays. Functions like math.add and math.subtract, math.sqrt handle matrices element wise. There is a set of functions specifically for creating or manipulating matrices, such as:


  Functions like math.matrix and math.sparse, math.ones, math.zeros, and math.identity to create a matrix.
  Functions like math.subset and math.index to get or replace a part of a matrix
  Functions like math.transpose and math.diag to manipulate matrices.


A full list of matrix functions is available on the functions reference page.

Two types of matrix classes are available in math.js, for storage of dense and sparse matrices. Although they contain public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  DenseMatrix
  SparseMatrix\n\n\n\nMatrices #

Math.js supports multi dimensional matrices and arrays. Matrices can be
created, manipulated, and used in calculations. Both regular JavaScript
arrays as well as the matrix type implemented by math.js can be used
interchangeably in all relevant math.js functions. math.js supports both
dense and sparse matrices.

Arrays and matrices #

Math.js supports two types of matrices:


  Array, a regular JavaScript array. A multi dimensional array can be created
by nesting arrays.
  Matrix, a matrix implementation by math.js. A Matrix is an object wrapped
around a regular JavaScript Array, providing utility functions for easy
matrix manipulation such as subset, size, resize, clone, and more.


In most cases, the type of matrix output from functions is determined by the
function input: An Array as input will return an Array, a Matrix as input
will return a Matrix. In case of mixed input, a Matrix is returned.
For functions where the type of output cannot be determined from the
input, the output is determined by the configuration option matrix,
which can be a string 'Matrix' (default) or 'Array'.

// create an array and a matrix
const array = [[2, 0], [-1, 3]]               // Array
const matrix = math.matrix([[7, 1], [-2, 3]]) // Matrix

// perform a calculation on an array and matrix
math.map(array, math.square)                  // Array,  [[4, 0], [1, 9]]
math.map(matrix, math.square)                 // Matrix, [[49, 1], [4, 9]]

// perform calculations with mixed array and matrix input
math.add(array, matrix)                       // Matrix, [[9, 1], [-3, 6]]
math.multiply(array, matrix)                  // Matrix, [[14, 2], [-13, 8]]

// create a matrix. Type of output of function ones is determined by the
// configuration option `matrix`
math.ones(2, 3)                               // Matrix, [[1, 1, 1], [1, 1, 1]]


Creation #

A matrix can be created from an array using the function math.matrix. The
provided array can contain nested arrays in order to create a multi-dimensional matrix. When called without arguments, an empty matrix will be
created.

// create matrices
math.matrix()                           // Matrix, size [0]
math.matrix([0, 1, 2])                  // Matrix, size [3]
math.matrix([[0, 1], [2, 3], [4, 5]])   // Matrix, size [3, 2]


Math.js supports regular Arrays. Multiple dimensions can be created
by nesting Arrays in each other.

// create arrays
[]                                      // Array, size [0]
[0, 1, 2]                               // Array, size [3]
[[0, 1], [2, 3], [4, 5]]                // Array, size [3, 2]


Matrices can contain different types of values: numbers, complex numbers,
units, or strings. Different types can be mixed together in a single matrix.

// create a matrix with mixed types
const a = math.matrix([2.3, 'hello', math.complex(3, -4), math.unit('5.2 mm')]) 
a.subset(math.index(1))  // 'hello'


There are a number of functions to create a matrix with a specific size and
content: ones, zeros, identity.

// zeros creates a matrix filled with zeros
math.zeros(3)           // Matrix, size [3],    [0, 0, 0]
math.zeros(3, 2)        // Matrix, size [3, 2], [[0, 0], [0, 0], [0, 0]]
math.zeros(2, 2, 2)     // Matrix, size [2, 2, 2],
                        //   [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]

// ones creates a matrix filled with ones
math.ones(3)                        // Matrix, size [3],    [1, 1, 1]
math.multiply(math.ones(2, 2), 5)   // Matrix, size [2, 2], [[5, 5], [5, 5]]

// identity creates an identity matrix
math.identity(3)      // Matrix, size [3, 3], [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
math.identity(2, 3)   // Matrix, size [2, 3], [[1, 0, 0], [0, 1, 0]]


The functions ones, zeros, and identity also accept a single array
or matrix containing the dimensions for the matrix. When the input is an Array,
the functions will output an Array. When the input is a Matrix, the output will
be a Matrix. Note that in case of numbers as arguments, the output is
determined by the option matrix as discussed in section
Arrays and matrices.

// Array as input gives Array as output
math.ones([2, 3])               // Array,  size [3, 2], [[1, 1, 1], [1, 1, 1]]
math.ones(math.matrix([2, 3]))  // Matrix, size [3, 2], [[1, 1, 1], [1, 1, 1]]


Ranges can be created using the function range. The function range is
called with parameters start and end, and optionally a parameter step.
The start of the range is included, the end of the range is excluded.

math.range(0, 4)        // [0, 1, 2, 3]
math.range(0, 8, 2)     // [0, 2, 4, 6]
math.range(3, -1, -1)   // [3, 2, 1, 0]


Calculations #

Most functions of math.js support matrices and arrays. Unary functions can be applied element-wise using via math.map(matrix, function).

// perform an element-wise operation on a matrix using math.map
const a = math.matrix([1, 4, 9, 16, 25])  // Matrix, [1, 4, 9, 16, 25]
math.map(a, math.sqrt)                    // Matrix, [1, 2, 3, 4, 5]

// use a function that has built-in matrix and array support
const b = [1, 2, 3, 4, 5] 
math.factorial(b)                         // Array,  [1, 2, 6, 24, 120]

// multiply an array with a matrix
const c = [[2, 0], [-1, 3]]               // Array
const d = math.matrix([[7, 1], [-2, 3]])  // Matrix
math.multiply(c, d)                       // Matrix, [[14, 2], [-13, 8]]

// add a number to a matrix (see broadcasting)
math.add(c, 2)                            // Array, [[4, 2], [1, 5]]

// calculate the determinant of a matrix
math.det(c)                               // 6
math.det(d)                               // 23

Broadcasting #

Functions that require two or more matrix like arguments that operate elementwise automatically operate as if the arguments were the same size.

A = math.matrix([1, 2])       // Matrix, [1, 2]
math.add(A, 3)                // Matrix, [3, 4]

B = math.matrix([[3], [4]])   // Matrix, [[3], [4]]
math.add(A, B)                // Matrix, [[4, 5], [5, 6]]

Any index that is in one of the arguments, can be found as if it existed on the others when the size on that dimension is one or not existing. This is valid in N dimensions.

It’s not possible to broadcast in cases where the size in that dimension is higher than one.

math.add([1, 2], [3, 4, 5])
// Error: shape missmatch: missmatch is found in arg with shape (2) not possible to broadcast dimension 0 with size 2 to size 3

math.add([[1], [2], [3]], [[4], [5]])
// Error: shape missmatch: missmatch is found in arg with shape (2,1) not possible to broadcast dimension 0 with size 2 to size 3


Size and Dimensions #

Math.js uses geometric dimensions:


  A scalar is zero-dimensional.
  A vector is one-dimensional.
  A matrix is two or multi-dimensional.


The size of a matrix can be calculated with the function size. Function size
returns a Matrix or Array, depending on the configuration option matrix.
Furthermore, matrices have a function size as well, which always returns
an Array.

// get the size of a scalar
math.size(2.4)                                // Matrix, []
math.size(math.complex(3, 2))                 // Matrix, []
math.size(math.unit('5.3 mm'))                // Matrix, []

// get the size of a one-dimensional matrix (a vector) and a string
math.size([0, 1, 2, 3])                       // Array, [4]
math.size('hello world')                      // Matrix, [11]

// get the size of a two-dimensional matrix
const a = [[0, 1, 2, 3]]                      // Array
const b = math.matrix([[0, 1, 2], [3, 4, 5]]) // Matrix
math.size(a)                                  // Array, [1, 4]
math.size(b)                                  // Matrix, [2, 3]

// matrices have a function size (always returns an Array)
b.size()                                      // Array, [2, 3]

// get the size of a multi-dimensional matrix
const c = [[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]
math.size(c)                                  // Array, [2, 2, 3]


Note that the dimensions themselves do not have a meaning attached. 
When creating and printing a two dimensional matrix, the first dimension is 
normally rendered as the column, and the second dimension is rendered as 
the row. For example:

console.table(math.zeros([2, 4]))
// 0 0 0 0
// 0 0 0 0


If you have a matrix where the first dimension means x and the second 
means y, this will look confusing since x is printed as column 
(vertically) and y as row (horizontally).

Resizing #

Matrices can be resized using their resize function. This function is called
with an Array with the new size as the first argument, and accepts an optional
default value. By default, new entries will be set to 0, but it is possible
to pass a different default value like null to clearly indicate that
the entries haven’t been explicitly set.

const a = math.matrix() // Matrix, size [0],       []
a.resize([2, 3])        // Matrix, size [2, 3],    [[0, 0, 0], [0, 0, 0]]
a.resize([2, 2, 2])     // Matrix, size [2, 2, 2],
                        //   [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]

const b = math.matrix()
b.resize([3], 7)        // Matrix, size [3],    [7, 7, 7]
b.resize([5], 9)        // Matrix, size [5],    [7, 7, 7, 9, 9]
b.resize([2])           // Matrix, size [2],    [7, 7]


Outer dimensions of a matrix can be squeezed using the function squeeze. When
getting or setting a single value in a matrix using subset, the value is automatically squeezed
or unsqueezed too.

// squeeze a matrix
const a = [[[0, 1, 2]]]
math.squeeze(a)             // [0, 1, 2]
math.squeeze([[3]])         // 3

// when getting/setting a single value in a matrix using subset, 
// it automatically squeeze/unsqueeze the value
const b = math.matrix([[0, 1], [2, 3]])
b.subset(math.index(1, 0))  // 2 and not [[2]]


Getting or replacing subsets #

Subsets of a matrix can be retrieved or replaced using the function subset.
Matrices have a subset function, which is applied to the matrix itself:
Matrix.subset(index [, replacement]). For both matrices and arrays,
the static function subset(matrix, index [, replacement]) can be used.
When parameter replacement is provided, the function will replace a subset
in the matrix, and if not, a subset of the matrix will be returned.

A subset can be defined using an Index. An Index contains a single value
or a set of values for each dimension of a matrix. An Index can be
created using the function index. When getting a single value from a matrix,
subset will return the value itself instead of a matrix containing just this 
value.

The function subset normally returns a subset, but when getting or setting a
single value in a matrix, the value itself is returned.

Matrix indexes in math.js are zero-based, like most programming languages
including JavaScript itself. Note that mathematical applications like Matlab 
and Octave work differently, as they use one-based indexes.

// create some matrices
const a = [0, 1, 2, 3]
const b = [[0, 1], [2, 3]]
const c = math.zeros(2, 2)
const d = math.matrix([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
const e = math.matrix()

// get a subset
math.subset(a, math.index(1))                 // 1
math.subset(a, math.index([2, 3]))            // Array, [2, 3]
math.subset(a, math.index(math.range(0,4)))   // Array, [0, 1, 2, 3]
math.subset(b, math.index(1, 0))              // 2
math.subset(b, math.index(1, [0, 1]))         // Array, [2, 3]
math.subset(b, math.index([0, 1], 0))         // Matrix, [[0], [2]]

// get a subset
d.subset(math.index([1, 2], [0, 1]))          // Matrix, [[3, 4], [6, 7]]
d.subset(math.index(1, 2))                    // 5

// replace a subset. The subset will be applied to a clone of the matrix
math.subset(b, math.index(1, 0), 9)           // Array, [[0, 1], [9, 3]]
math.subset(b, math.index(2, [0, 1]), [4, 5]) // Array, [[0, 1], [2, 3], [4, 5]]

// replace a subset. The subset will be applied to the matrix itself
c.subset(math.index(0, 1),1)                  // Matrix, [[0, 1], [0, 0]]
c.subset(math.index(1, [0, 1]), [2, 3])       // Matrix, [[0, 1], [2, 3]]
e.resize([2, 3], 0)                           // Matrix, [[0, 0, 0], [0, 0, 0]]
e.subset(math.index(1, 2), 5)                 // Matrix, [[0, 0, 0], [0, 0, 5]]


Getting and setting a value in a matrix #

There are two methods available on matrices that allow to get or set a single 
value inside a matrix. It is important to note that the set method will 
mutate the matrix.

const p = math.matrix([[1, 2], [3, 4]])
p.set([0, 1], 5)
// p is now [[1, 5], [3, 4]]
p.get([1, 0]) // 3


When setting a value at a location outside of the current matrix size using the
method .set(), the matrix will be resized. By default, new items will be 
initialized with zero, but it is possible to specify an alternative value using
the optional third argument defaultValue.

Advanced Indexing #

Boolean array indexing is a technique that allows you to filter, replace, and set values in an array based on logical conditions. This can be done by creating a boolean array that represents the desired conditions, and then using that array as an index to select the elements of the original array that meet those conditions.

For example, a boolean array can be created to represent all the even numbers in an array, and then used to filter the original array to only include the even numbers. Alternatively, a boolean array can be created to represent all the elements of an array that are greater than a certain value, and then used to replace all the elements of the original array that are greater than that value with a new value.

const q = [1, 2, 3, 4]
math.subset(q, math.index([true, false, true, false]))      // Array [1, 3]

// filtering
math.subset(q, math.index(math.larger(q, 2)))               // Array [3, 4]

// filtering with no matches
math.subset(q, math.index(math.larger(q, 5)))               // Array []

// setting specific values, please note that the replacement value is broadcasted
q = math.subset(q, math.index(math.smaller(q, 3)), 0)       // q = [0, 0, 3, 4]

// replacing specific values
math.subset(q, math.index(math.equal(q, 0)), [1, 2])        // q = [1, 2, 3, 4]


The same can be accomplished in the parser in a much more compact manner. Please note that everything after # are comments.
math.evaluate(`
q = [1, 2, 3, 4]
q[[true, false, true, false]] # Matrix [1, 3]
q[q>2]                        # Matrix [3, 4]
q[q>5]                        # Matrix []
q[q <3] = 0                   # q = [0, 0, 3, 4]
q[q==0] = [1, 2]              # q = [1, 2, 3, 4]
`)

The expression inside the index can be as complex as needed as long it evaluates to an array of booleans of the same size.
math.evaluate(`
q = [1, 2, 3, 4]
r = [6, 5, 4, 3]
q[q > 3 and r < 4]     # [4]
`)


Iterating #

Matrices contain functions map and forEach to iterate over all elements of
the (multidimensional) matrix. The callback function of map and forEach has
three parameters: value (the value of the currently iterated element),
index (an array with the index value for each dimension), and matrix (the
matrix being iterated). This syntax is similar to the map and forEach
functions of native JavaScript Arrays, except that the index is no number but
an Array with numbers for each dimension.

const a = math.matrix([[0, 1], [2, 3], [4, 5]])

// The iteration below will output the following in the console:
//    value: 0 index: [0, 0]
//    value: 1 index: [0, 1]
//    value: 2 index: [1, 0]
//    value: 3 index: [1, 1]
//    value: 4 index: [2, 0]
//    value: 5 index: [2, 1]
a.forEach(function (value, index, matrix) {
  console.log('value:', value, 'index:', index) 
}) 

// Apply a transformation on the matrix
const b = a.map(function (value, index, matrix) {
  return math.multiply(math.sin(value), math.exp(math.abs(value))) 
}) 
console.log(b.format(5))  // [[0, 2.2874], [6.7188, 2.8345], [-41.32, -142.32]]

// Create a matrix with the cumulative of all elements
let count = 0
const cum = a.map(function (value, index, matrix) {
  count += value 
  return count 
}) 
console.log(cum.toString())  // [[0, 1], [3, 6], [10, 15]]


Iterating over multiple Matrixes or Arrays #

You can iterate over multiple matrices or arrays by using the map function. Mapping allows to perform element-wise operations on matrices by automatically adjusting their sizes to match each other.

To iterate over multiple matrices, you can use the map function. The map function applies a given function to each element of the matrices and returns a new matrix with the results.

Here’s an example of iterating over two matrices and adding their corresponding elements:

const a = math.matrix([[1, 2], [3, 4]]);
const b = math.matrix([[5, 6], [7, 8]]);

const result = math.map(a, b, (x, y) => x + y);

console.log(result); // [[6, 8], [10, 12]]


In this example, the map function takes matrices as the first two arguments and a callback function (x, y) => x + y as the third argument. The callback function is applied to each element of the matrices, where x represents the corresponding element from matrix a and y represents the corresponding element from matrix b. The result is a new matrix with the element-wise sum of the two matrices.

By using broadcasting and the map function, you can easily iterate over multiple matrices and perform element-wise operations.

const a = math.matrix([10, 20])
const b = math.matrix([[3, 4], [5, 6]])

const result = math.map(a, b, (x, y) => x + y)
console.log(result); // [[13, 24], [15, 26]]


It’s also possible to provide a callback with an index and the broadcasted arrays. Like (valueA, valueB, index) or even (valueA, valueB, index, broadcastedMatrixA, broadcastedMatrixB). There is no specific limit for the number of matrices N that can be mapped. Thus, the callback can have N arguments, N+1 arguments in the case of including the index, or 2N+1 arguments in the case of including the index and the broadcasted matrices in the callback.

At this moment forEach doesn’t include the same functionality.

Storage types #

Math.js supports both dense matrices as well as sparse matrices. Sparse matrices are efficient for matrices largely containing zeros. In that case they save a lot of memory, and calculations can be much faster than for dense matrices.

Math.js supports two type of matrices:


  Dense matrix ('dense', default) A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.
  Sparse matrix ('sparse'): A two dimensional sparse matrix implementation.


The type of matrix can be selected when creating a matrix using the construction functions matrix, diag, identity, ones, and zeros.

// create sparse matrices
const m1 = math.matrix([[0, 1], [0, 0]], 'sparse')
const m2 = math.identity(1000, 1000, 'sparse')


You can also coerce an array or matrix into sparse storage format with the
sparse function.
const md = math.matrix([[0, 1], [0,0]])  // dense
const ms = math.sparse(md)               // sparse


Caution: sparse called on a JavaScript array of n plain numbers produces
a matrix with one column and n rows – in contrast to matrix, which
produces a 1-dimensional matrix object with n entries, i.e., a vector
(not a 1 by n “row vector” nor an n by 1 “column vector”, but just a plain
vector of length n).
const mv = math.matrix([0, 0, 1])  // Has size [3]
const mc = math.sparse([0, 0, 1])  // A "column vector," has size [3, 1]


API #

All relevant functions in math.js support Matrices and Arrays. Functions like math.add and math.subtract, math.sqrt handle matrices element wise. There is a set of functions specifically for creating or manipulating matrices, such as:


  Functions like math.matrix and math.sparse, math.ones, math.zeros, and math.identity to create a matrix.
  Functions like math.subset and math.index to get or replace a part of a matrix
  Functions like math.transpose and math.diag to manipulate matrices.


A full list of matrix functions is available on the functions reference page.

Two types of matrix classes are available in math.js, for storage of dense and sparse matrices. Although they contain public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  DenseMatrix
  SparseMatrix\n\n\n\nFunction reference #

Expression functions #


  
    
      Function
      Description
    
  
  
    
      math.compile(expr)
      Parse and compile an expression.
    
    
      math.evaluate(expr [, scope])
      Evaluate an expression.
    
    
      math.help(search)
      Retrieve help on a function or data type.
    
    
      math.parser()
      Create a parser.
    
  


Algebra functions #


  
    
      Function
      Description
    
  
  
    
      math.derivative(expr, variable)
      Takes the derivative of an expression expressed in parser Nodes.
    
    
      math.leafCount(expr)
      Gives the number of “leaf nodes” in the parse tree of the given expression A leaf node is one that has no subexpressions, essentially either a symbol or a constant.
    
    
      math.lsolve(L, b)
      Finds one solution of a linear equation system by forwards substitution.
    
    
      math.lsolveAll(L, b)
      Finds all solutions of a linear equation system by forwards substitution.
    
    
      math.lup(A)
      Calculate the Matrix LU decomposition with partial pivoting.
    
    
      math.lusolve(A, b)
      Solves the linear system A * x = b where A is an [n x n] matrix and b is a [n] column vector.
    
    
      math.lyap(A, Q)
      Solves the Continuous-time Lyapunov equation AP+PA’+Q=0 for P, where Q is an input matrix.
    
    
      math.polynomialRoot(constant, linearCoeff, quadraticCoeff, cubicCoeff)
      Finds the numerical values of the distinct roots of a polynomial with real or complex coefficients.
    
    
      math.qr(A)
      Calculate the Matrix QR decomposition.
    
    
      math.rationalize(expr)
      Transform a rationalizable expression in a rational fraction.
    
    
      math.resolve(expr, scope)
      resolve(expr, scope) replaces variable nodes with their scoped values.
    
    
      math.schur(A)
      Performs a real Schur decomposition of the real matrix A = UTU’ where U is orthogonal and T is upper quasi-triangular.
    
    
      math.simplify(expr)
      Simplify an expression tree.
    
    
      math.simplifyConstant(expr)
      simplifyConstant() takes a mathjs expression (either a Node representing a parse tree or a string which it parses to produce a node), and replaces any subexpression of it consisting entirely of constants with the computed value of that subexpression.
    
    
      math.simplifyCore(expr)
      simplifyCore() performs single pass simplification suitable for applications requiring ultimate performance.
    
    
      math.slu(A, order, threshold)
      Calculate the Sparse Matrix LU decomposition with full pivoting.
    
    
      math.sylvester(A, B, C)
      Solves the real-valued Sylvester equation AX+XB=C for X, where A, B and C are matrices of appropriate dimensions, being A and B squared.
    
    
      math.symbolicEqual(expr1, expr2)
      Attempts to determine if two expressions are symbolically equal, i.
    
    
      math.usolve(U, b)
      Finds one solution of a linear equation system by backward substitution.
    
    
      math.usolveAll(U, b)
      Finds all solutions of a linear equation system by backward substitution.
    
  


Arithmetic functions #


  
    
      Function
      Description
    
  
  
    
      math.abs(x)
      Calculate the absolute value of a number.
    
    
      math.add(x, y)
      Add two or more values, x + y.
    
    
      math.cbrt(x [, allRoots])
      Calculate the cubic root of a value.
    
    
      math.ceil(x)
      Round a value towards plus infinity If x is complex, both real and imaginary part are rounded towards plus infinity.
    
    
      math.cube(x)
      Compute the cube of a value, x * x * x.
    
    
      math.divide(x, y)
      Divide two values, x / y.
    
    
      math.dotDivide(x, y)
      Divide two matrices element wise.
    
    
      math.dotMultiply(x, y)
      Multiply two matrices element wise.
    
    
      math.dotPow(x, y)
      Calculates the power of x to y element wise.
    
    
      math.exp(x)
      Calculate the exponential of a value.
    
    
      math.expm1(x)
      Calculate the value of subtracting 1 from the exponential value.
    
    
      math.fix(x)
      Round a value towards zero.
    
    
      math.floor(x)
      Round a value towards minus infinity.
    
    
      math.gcd(a, b)
      Calculate the greatest common divisor for two or more values or arrays.
    
    
      math.hypot(a, b, …)
      Calculate the hypotenuse of a list with values.
    
    
      math.invmod(a, b)
      Calculate the (modular) multiplicative inverse of a modulo b.
    
    
      math.lcm(a, b)
      Calculate the least common multiple for two or more values or arrays.
    
    
      math.log(x [, base])
      Calculate the logarithm of a value.
    
    
      math.log10(x)
      Calculate the 10-base logarithm of a value.
    
    
      math.log1p(x)
      Calculate the logarithm of a value+1.
    
    
      math.log2(x)
      Calculate the 2-base of a value.
    
    
      math.mod(x, y)
      Calculates the modulus, the remainder of an integer division.
    
    
      math.multiply(x, y)
      Multiply two or more values, x * y.
    
    
      math.norm(x [, p])
      Calculate the norm of a number, vector or matrix.
    
    
      math.nthRoot(a)
      Calculate the nth root of a value.
    
    
      math.nthRoots(x)
      Calculate the nth roots of a value.
    
    
      math.pow(x, y)
      Calculates the power of x to y, x ^ y.
    
    
      math.round(x [, n])
      Round a value towards the nearest rounded value.
    
    
      math.sign(x)
      Compute the sign of a value.
    
    
      math.sqrt(x)
      Calculate the square root of a value.
    
    
      math.square(x)
      Compute the square of a value, x * x.
    
    
      math.subtract(x, y)
      Subtract two values, x - y.
    
    
      math.unaryMinus(x)
      Inverse the sign of a value, apply a unary minus operation.
    
    
      math.unaryPlus(x)
      Unary plus operation.
    
    
      math.xgcd(a, b)
      Calculate the extended greatest common divisor for two values.
    
  


Bitwise functions #


  
    
      Function
      Description
    
  
  
    
      math.bitAnd(x, y)
      Bitwise AND two values, x & y.
    
    
      math.bitNot(x)
      Bitwise NOT value, ~x.
    
    
      math.bitOr(x, y)
      Bitwise OR two values, x | y.
    
    
      math.bitXor(x, y)
      Bitwise XOR two values, x ^ y.
    
    
      math.leftShift(x, y)
      Bitwise left logical shift of a value x by y number of bits, x << y.
    
    
      math.rightArithShift(x, y)
      Bitwise right arithmetic shift of a value x by y number of bits, x >> y.
    
    
      math.rightLogShift(x, y)
      Bitwise right logical shift of value x by y number of bits, x >>> y.
    
  


Combinatorics functions #


  
    
      Function
      Description
    
  
  
    
      math.bellNumbers(n)
      The Bell Numbers count the number of partitions of a set.
    
    
      math.catalan(n)
      The Catalan Numbers enumerate combinatorial structures of many different types.
    
    
      math.composition(n, k)
      The composition counts of n into k parts.
    
    
      math.stirlingS2(n, k)
      The Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets.
    
  


Complex functions #


  
    
      Function
      Description
    
  
  
    
      math.arg(x)
      Compute the argument of a complex value.
    
    
      math.conj(x)
      Compute the complex conjugate of a complex value.
    
    
      math.im(x)
      Get the imaginary part of a complex number.
    
    
      math.re(x)
      Get the real part of a complex number.
    
  


Geometry functions #


  
    
      Function
      Description
    
  
  
    
      math.distance([x1,y1], [x2,y2])
      Calculates:    The eucledian distance between two points in N-dimensional spaces.
    
    
      math.intersect(endPoint1Line1, endPoint2Line1, endPoint1Line2, endPoint2Line2)
      Calculates the point of intersection of two lines in two or three dimensions and of a line and a plane in three dimensions.
    
  


Logical functions #


  
    
      Function
      Description
    
  
  
    
      math.and(x, y)
      Logical and.
    
    
      math.not(x)
      Logical not.
    
    
      math.or(x, y)
      Logical or.
    
    
      math.xor(x, y)
      Logical xor.
    
  


Matrix functions #


  
    
      Function
      Description
    
  
  
    
      math.column(value, index)
      Return a column from a Matrix.
    
    
      math.concat(a, b, c, … [, dim])
      Concatenate two or more matrices.
    
    
      math.count(x)
      Count the number of elements of a matrix, array or string.
    
    
      math.cross(x, y)
      Calculate the cross product for two vectors in three dimensional space.
    
    
      math.ctranspose(x)
      Transpose and complex conjugate a matrix.
    
    
      math.det(x)
      Calculate the determinant of a matrix.
    
    
      math.diag(X)
      Create a diagonal matrix or retrieve the diagonal of a matrix  When x is a vector, a matrix with vector x on the diagonal will be returned.
    
    
      math.diff(arr)
      Create a new matrix or array of the difference between elements of the given array The optional dim parameter lets you specify the dimension to evaluate the difference of If no dimension parameter is passed it is assumed as dimension 0  Dimension is zero-based in javascript and one-based in the parser and can be a number or bignumber Arrays must be ‘rectangular’ meaning arrays like [1, 2] If something is passed as a matrix it will be returned as a matrix but other than that all matrices are converted to arrays.
    
    
      math.dot(x, y)
      Calculate the dot product of two vectors.
    
    
      math.eigs(x, [prec])
      Compute eigenvalues and optionally eigenvectors of a square matrix.
    
    
      math.expm(x)
      Compute the matrix exponential, expm(A) = e^A.
    
    
      math.fft(arr)
      Calculate N-dimensional Fourier transform.
    
    
      math.filter(x, test)
      Filter the items in an array or one dimensional matrix.
    
    
      math.flatten(x)
      Flatten a multidimensional matrix into a single dimensional matrix.
    
    
      math.forEach(x, callback)
      Iterate over all elements of a matrix/array, and executes the given callback function.
    
    
      math.getMatrixDataType(x)
      Find the data type of all elements in a matrix or array, for example ‘number’ if all items are a number and ‘Complex’ if all values are complex numbers.
    
    
      math.identity(n)
      Create a 2-dimensional identity matrix with size m x n or n x n.
    
    
      math.ifft(arr)
      Calculate N-dimensional inverse Fourier transform.
    
    
      math.inv(x)
      Calculate the inverse of a square matrix.
    
    
      math.kron(x, y)
      Calculates the Kronecker product of 2 matrices or vectors.
    
    
      math.map(x, callback)
      Create a new matrix or array with the results of a callback function executed on each entry of a given matrix/array.
    
    
      math.mapSlices(A, dim, callback)
      Apply a function that maps an array to a scalar along a given axis of a matrix or array.
    
    
      math.matrixFromColumns(…arr)
      Create a dense matrix from vectors as individual columns.
    
    
      math.matrixFromFunction(size, fn)
      Create a matrix by evaluating a generating function at each index.
    
    
      math.matrixFromRows(…arr)
      Create a dense matrix from vectors as individual rows.
    
    
      math.ones(m, n, p, …)
      Create a matrix filled with ones.
    
    
      math.partitionSelect(x, k)
      Partition-based selection of an array or 1D matrix.
    
    
      math.pinv(x)
      Calculate the Moore–Penrose inverse of a matrix.
    
    
      math.range(start, end [, step])
      Create an array from a range.
    
    
      math.reshape(x, sizes)
      Reshape a multi dimensional array to fit the specified dimensions.
    
    
      math.resize(x, size [, defaultValue])
      Resize a matrix.
    
    
      math.rotate(w, theta)
      Rotate a vector of size 1x2 counter-clockwise by a given angle Rotate a vector of size 1x3 counter-clockwise by a given angle around the given axis.
    
    
      math.rotationMatrix(theta)
      Create a 2-dimensional counter-clockwise rotation matrix (2x2) for a given angle (expressed in radians).
    
    
      math.row(value, index)
      Return a row from a Matrix.
    
    
      math.size(x)
      Calculate the size of a matrix or scalar.
    
    
      math.sort(x)
      Sort the items in a matrix.
    
    
      math.sqrtm(A)
      Calculate the principal square root of a square matrix.
    
    
      math.squeeze(x)
      Squeeze a matrix, remove inner and outer singleton dimensions from a matrix.
    
    
      math.subset(x, index [, replacement])
      Get or set a subset of a matrix or string.
    
    
      math.trace(x)
      Calculate the trace of a matrix: the sum of the elements on the main diagonal of a square matrix.
    
    
      math.transpose(x)
      Transpose a matrix.
    
    
      math.zeros(m, n, p, …)
      Create a matrix filled with zeros.
    
  


Numeric functions #


  
    
      Function
      Description
    
  
  
    
      math.solveODE(func, tspan, y0)
      Numerical Integration of Ordinary Differential Equations  Two variable step methods are provided: - “RK23”: Bogacki–Shampine method - “RK45”: Dormand-Prince method RK5(4)7M (default)  The arguments are expected as follows.
    
  


Probability functions #


  
    
      Function
      Description
    
  
  
    
      math.combinations(n, k)
      Compute the number of ways of picking k unordered outcomes from n possibilities.
    
    
      math.combinationsWithRep(n, k)
      Compute the number of ways of picking k unordered outcomes from n possibilities, allowing individual outcomes to be repeated more than once.
    
    
      math.factorial(n)
      Compute the factorial of a value  Factorial only supports an integer value as argument.
    
    
      math.gamma(n)
      Compute the gamma function of a value using Lanczos approximation for small values, and an extended Stirling approximation for large values.
    
    
      math.kldivergence(x, y)
      Calculate the Kullback-Leibler (KL) divergence  between two distributions.
    
    
      math.lgamma(n)
      Logarithm of the gamma function for real, positive numbers and complex numbers, using Lanczos approximation for numbers and Stirling series for complex numbers.
    
    
      math.multinomial(a)
      Multinomial Coefficients compute the number of ways of picking a1, a2, .
    
    
      math.permutations(n [, k])
      Compute the number of ways of obtaining an ordered subset of k elements from a set of n elements.
    
    
      math.pickRandom(array)
      Random pick one or more values from a one dimensional array.
    
    
      math.random([min, max])
      Return a random number larger or equal to min and smaller than max using a uniform distribution.
    
    
      math.randomInt([min, max])
      Return a random integer number larger or equal to min and smaller than max using a uniform distribution.
    
  


Relational functions #


  
    
      Function
      Description
    
  
  
    
      math.compare(x, y)
      Compare two values.
    
    
      math.compareNatural(x, y)
      Compare two values of any type in a deterministic, natural way.
    
    
      math.compareText(x, y)
      Compare two strings lexically.
    
    
      math.deepEqual(x, y)
      Test element wise whether two matrices are equal.
    
    
      math.equal(x, y)
      Test whether two values are equal.
    
    
      math.equalText(x, y)
      Check equality of two strings.
    
    
      math.larger(x, y)
      Test whether value x is larger than y.
    
    
      math.largerEq(x, y)
      Test whether value x is larger or equal to y.
    
    
      math.smaller(x, y)
      Test whether value x is smaller than y.
    
    
      math.smallerEq(x, y)
      Test whether value x is smaller or equal to y.
    
    
      math.unequal(x, y)
      Test whether two values are unequal.
    
  


Set functions #


  
    
      Function
      Description
    
  
  
    
      math.setCartesian(set1, set2)
      Create the cartesian product of two (multi)sets.
    
    
      math.setDifference(set1, set2)
      Create the difference of two (multi)sets: every element of set1, that is not the element of set2.
    
    
      math.setDistinct(set)
      Collect the distinct elements of a multiset.
    
    
      math.setIntersect(set1, set2)
      Create the intersection of two (multi)sets.
    
    
      math.setIsSubset(set1, set2)
      Check whether a (multi)set is a subset of another (multi)set.
    
    
      math.setMultiplicity(element, set)
      Count the multiplicity of an element in a multiset.
    
    
      math.setPowerset(set)
      Create the powerset of a (multi)set.
    
    
      math.setSize(set)
      Count the number of elements of a (multi)set.
    
    
      math.setSymDifference(set1, set2)
      Create the symmetric difference of two (multi)sets.
    
    
      math.setUnion(set1, set2)
      Create the union of two (multi)sets.
    
  


Signal functions #


  
    
      Function
      Description
    
  
  
    
      math.freqz(b, a)
      Calculates the frequency response of a filter given its numerator and denominator coefficients.
    
    
      math.zpk2tf(z, p, k)
      Compute the transfer function of a zero-pole-gain model.
    
  


Special functions #


  
    
      Function
      Description
    
  
  
    
      math.erf(x)
      Compute the erf function of a value using a rational Chebyshev approximations for different intervals of x.
    
    
      math.zeta(n)
      Compute the Riemann Zeta function of a value using an infinite series for all of the complex plane using Riemann’s Functional equation.
    
  


Statistics functions #


  
    
      Function
      Description
    
  
  
    
      math.corr(A, B)
      Compute the correlation coefficient of a two list with values, For matrices, the matrix correlation coefficient is calculated.
    
    
      math.cumsum(a, b, c, …)
      Compute the cumulative sum of a matrix or a list with values.
    
    
      math.mad(a, b, c, …)
      Compute the median absolute deviation of a matrix or a list with values.
    
    
      math.max(a, b, c, …)
      Compute the maximum value of a matrix or a  list with values.
    
    
      math.mean(a, b, c, …)
      Compute the mean value of matrix or a list with values.
    
    
      math.median(a, b, c, …)
      Compute the median of a matrix or a list with values.
    
    
      math.min(a, b, c, …)
      Compute the minimum value of a matrix or a  list of values.
    
    
      math.mode(a, b, c, …)
      Computes the mode of a set of numbers or a list with values(numbers or characters).
    
    
      math.prod(a, b, c, …)
      Compute the product of a matrix or a list with values.
    
    
      math.quantileSeq(A, prob[, sorted])
      Compute the prob order quantile of a matrix or a list with values.
    
    
      math.std(a, b, c, …)
      Compute the standard deviation of a matrix or a  list with values.
    
    
      math.sum(a, b, c, …)
      Compute the sum of a matrix or a list with values.
    
    
      math.variance(a, b, c, …)
      Compute the variance of a matrix or a  list with values.
    
  


String functions #


  
    
      Function
      Description
    
  
  
    
      math.bin(value)
      Format a number as binary.
    
    
      math.format(value [, precision])
      Format a value of any type into a string.
    
    
      math.hex(value)
      Format a number as hexadecimal.
    
    
      math.oct(value)
      Format a number as octal.
    
    
      math.print(template, values [, precision])
      Interpolate values into a string template.
    
  


Trigonometry functions #


  
    
      Function
      Description
    
  
  
    
      math.acos(x)
      Calculate the inverse cosine of a value.
    
    
      math.acosh(x)
      Calculate the hyperbolic arccos of a value, defined as acosh(x) = ln(sqrt(x^2 - 1) + x).
    
    
      math.acot(x)
      Calculate the inverse cotangent of a value, defined as acot(x) = atan(1/x).
    
    
      math.acoth(x)
      Calculate the inverse hyperbolic tangent of a value, defined as acoth(x) = atanh(1/x) = (ln((x+1)/x) + ln(x/(x-1))) / 2.
    
    
      math.acsc(x)
      Calculate the inverse cosecant of a value, defined as acsc(x) = asin(1/x).
    
    
      math.acsch(x)
      Calculate the inverse hyperbolic cosecant of a value, defined as acsch(x) = asinh(1/x) = ln(1/x + sqrt(1/x^2 + 1)).
    
    
      math.asec(x)
      Calculate the inverse secant of a value.
    
    
      math.asech(x)
      Calculate the hyperbolic arcsecant of a value, defined as asech(x) = acosh(1/x) = ln(sqrt(1/x^2 - 1) + 1/x).
    
    
      math.asin(x)
      Calculate the inverse sine of a value.
    
    
      math.asinh(x)
      Calculate the hyperbolic arcsine of a value, defined as asinh(x) = ln(x + sqrt(x^2 + 1)).
    
    
      math.atan(x)
      Calculate the inverse tangent of a value.
    
    
      math.atan2(y, x)
      Calculate the inverse tangent function with two arguments, y/x.
    
    
      math.atanh(x)
      Calculate the hyperbolic arctangent of a value, defined as atanh(x) = ln((1 + x)/(1 - x)) / 2.
    
    
      math.cos(x)
      Calculate the cosine of a value.
    
    
      math.cosh(x)
      Calculate the hyperbolic cosine of a value, defined as cosh(x) = 1/2 * (exp(x) + exp(-x)).
    
    
      math.cot(x)
      Calculate the cotangent of a value.
    
    
      math.coth(x)
      Calculate the hyperbolic cotangent of a value, defined as coth(x) = 1 / tanh(x).
    
    
      math.csc(x)
      Calculate the cosecant of a value, defined as csc(x) = 1/sin(x).
    
    
      math.csch(x)
      Calculate the hyperbolic cosecant of a value, defined as csch(x) = 1 / sinh(x).
    
    
      math.sec(x)
      Calculate the secant of a value, defined as sec(x) = 1/cos(x).
    
    
      math.sech(x)
      Calculate the hyperbolic secant of a value, defined as sech(x) = 1 / cosh(x).
    
    
      math.sin(x)
      Calculate the sine of a value.
    
    
      math.sinh(x)
      Calculate the hyperbolic sine of a value, defined as sinh(x) = 1/2 * (exp(x) - exp(-x)).
    
    
      math.tan(x)
      Calculate the tangent of a value.
    
    
      math.tanh(x)
      Calculate the hyperbolic tangent of a value, defined as tanh(x) = (exp(2 * x) - 1) / (exp(2 * x) + 1).
    
  


Unit functions #


  
    
      Function
      Description
    
  
  
    
      math.to(x, unit)
      Change the unit of a value.
    
  


Utils functions #


  
    
      Function
      Description
    
  
  
    
      math.clone(x)
      Clone an object.
    
    
      math.hasNumericValue(x)
      Test whether a value is an numeric value.
    
    
      math.isInteger(x)
      Test whether a value is an integer number.
    
    
      math.isNaN(x)
      Test whether a value is NaN (not a number).
    
    
      math.isNegative(x)
      Test whether a value is negative: smaller than zero.
    
    
      math.isNumeric(x)
      Test whether a value is an numeric value.
    
    
      math.isPositive(x)
      Test whether a value is positive: larger than zero.
    
    
      math.isPrime(x)
      Test whether a value is prime: has no divisors other than itself and one.
    
    
      math.isZero(x)
      Test whether a value is zero.
    
    
      math.numeric(x)
      Convert a numeric input to a specific numeric type: number, BigNumber, bigint, or Fraction.
    
    
      math.typeOf(x)
      Determine the type of an entity.\n\n\n\nDenseMatrix #
Dense Matrix implementation. This type implements an efficient Array format
for dense matrices.


  instance
    
      .storage() ⇒ string
      .datatype() ⇒ string
      .create(data, [datatype])
      .subset(index, [replacement], [defaultValue])
      .get(index) ⇒ \*
      .set(index, value, [defaultValue]) ⇒ DenseMatrix
      .resize(size, [defaultValue], [copy]) ⇒ Matrix
      .clone() ⇒ DenseMatrix
      .size() ⇒ Array.<number>
      .map(callback) ⇒ DenseMatrix
      .forEach(callback)
      .toArray() ⇒ Array
      .valueOf() ⇒ Array
      .format([options]) ⇒ string
      .toString() ⇒ string
      .toJSON() ⇒ Object
      .diagonal([k]) ⇒ Array
      .swapRows(i, j) ⇒ Matrix
    
  
  static
    
      .diagonal(size, value, [k], [defaultValue]) ⇒ DenseMatrix
      .fromJSON(json) ⇒ DenseMatrix
      .preprocess(data) ⇒ Array
    
  



denseMatrix.storage() ⇒ string #
Get the storage format used by the matrix.

Usage:

const format = matrix.storage()                   // retrieve storage format


Kind: instance method of DenseMatrix 
Returns: string - The storage format.

denseMatrix.datatype() ⇒ string #
Get the datatype of the data stored in the matrix.

Usage:

const format = matrix.datatype()                   // retrieve matrix datatype


Kind: instance method of DenseMatrix 
Returns: string - The datatype.

denseMatrix.create(data, [datatype]) #
Create a new DenseMatrix

Kind: instance method of DenseMatrix


  
    
      Param
      Type
    
  
  
    
      data
      Array
    
    
      [datatype]
      string
    
  



denseMatrix.subset(index, [replacement], [defaultValue]) #
Get a subset of the matrix, or replace a subset of the matrix.

Usage:

const subset = matrix.subset(index)               // retrieve subset
const value = matrix.subset(index, replacement)   // replace subset


Kind: instance method of DenseMatrix


  
    
      Param
      Type
      Default
      Description
    
  
  
    
      index
      Index
       
       
    
    
      [replacement]
      Array | DenseMatrix| \*
       
       
    
    
      [defaultValue]
      \*
      0
      Default value, filled in on new entries when                                  the matrix is resized. If not provided,                                  new matrix elements will be filled with zeros.
    
  



denseMatrix.get(index) ⇒ \* #
Get a single element from the matrix.

Kind: instance method of DenseMatrix 
Returns: \* - value


  
    
      Param
      Type
      Description
    
  
  
    
      index
      Array.<number>
      Zero-based index
    
  



denseMatrix.set(index, value, [defaultValue]) ⇒ DenseMatrix #
Replace a single element in the matrix.

Kind: instance method of DenseMatrix 
Returns: DenseMatrix- self


  
    
      Param
      Type
      Description
    
  
  
    
      index
      Array.<number>
      Zero-based index
    
    
      value
      \*
       
    
    
      [defaultValue]
      \*
      Default value, filled in on new entries when                                  the matrix is resized. If not provided,                                  new matrix elements will be left undefined.
    
  



denseMatrix.resize(size, [defaultValue], [copy]) ⇒ Matrix #
Resize the matrix to the given size. Returns a copy of the matrix when
copy=true, otherwise return the matrix itself (resize in place).

Kind: instance method of DenseMatrix 
Returns: Matrix - The resized matrix


  
    
      Param
      Type
      Default
      Description
    
  
  
    
      size
      Array.<number>
       
      The new size the matrix should have.
    
    
      [defaultValue]
      \*
      0
      Default value, filled in on new entries.                                  If not provided, the matrix elements will                                  be filled with zeros.
    
    
      [copy]
      boolean
       
      Return a resized copy of the matrix
    
  



denseMatrix.clone() ⇒ DenseMatrix #
Create a clone of the matrix

Kind: instance method of DenseMatrix 
Returns: DenseMatrix- clone

denseMatrix.size() ⇒ Array.<number> #
Retrieve the size of the matrix.

Kind: instance method of DenseMatrix 
Returns: Array.<number> - size

denseMatrix.map(callback) ⇒ DenseMatrix #
Create a new matrix with the results of the callback function executed on
each entry of the matrix.

Kind: instance method of DenseMatrix 
Returns: DenseMatrix- matrix


  
    
      Param
      Type
      Description
    
  
  
    
      callback
      function
      The callback function is invoked with three                              parameters: the value of the element, the index                              of the element, and the Matrix being traversed.
    
  



denseMatrix.forEach(callback) #
Execute a callback function on each entry of the matrix.

Kind: instance method of DenseMatrix


  
    
      Param
      Type
      Description
    
  
  
    
      callback
      function
      The callback function is invoked with three                              parameters: the value of the element, the index                              of the element, and the Matrix being traversed.
    
  



denseMatrix.toArray() ⇒ Array #
Create an Array with a copy of the data of the DenseMatrix

Kind: instance method of DenseMatrix 
Returns: Array - array

denseMatrix.valueOf() ⇒ Array #
Get the primitive value of the DenseMatrix: a multidimensional array

Kind: instance method of DenseMatrix 
Returns: Array - array

denseMatrix.format([options]) ⇒ string #
Get a string representation of the matrix, with optional formatting options.

Kind: instance method of DenseMatrix 
Returns: string - str


  
    
      Param
      Type
      Description
    
  
  
    
      [options]
      Object | number | function
      Formatting options. See                                                lib/utils/number:format for a                                                description of the available                                                options.
    
  



denseMatrix.toString() ⇒ string #
Get a string representation of the matrix

Kind: instance method of DenseMatrix 
Returns: string - str

denseMatrix.toJSON() ⇒ Object #
Get a JSON representation of the matrix

Kind: instance method of DenseMatrix 

denseMatrix.diagonal([k]) ⇒ Array #
Get the kth Matrix diagonal.

Kind: instance method of DenseMatrix 
Returns: Array - The array vector with the diagonal values.


  
    
      Param
      Type
      Default
      Description
    
  
  
    
      [k]
      number | BigNumber
      0
      The kth diagonal where the vector will retrieved.
    
  



denseMatrix.swapRows(i, j) ⇒ Matrix #
Swap rows i and j in Matrix.

Kind: instance method of DenseMatrix 
Returns: Matrix - The matrix reference


  
    
      Param
      Type
      Description
    
  
  
    
      i
      number
      Matrix row index 1
    
    
      j
      number
      Matrix row index 2
    
  



DenseMatrix.diagonal(size, value, [k], [defaultValue]) ⇒ DenseMatrix #
Create a diagonal matrix.

Kind: static method of DenseMatrix


  
    
      Param
      Type
      Default
      Description
    
  
  
    
      size
      Array
       
      The matrix size.
    
    
      value
      number | Array
       
      The values for the diagonal.
    
    
      [k]
      number | BigNumber
      0
      The kth diagonal where the vector will be filled in.
    
    
      [defaultValue]
      number
       
      The default value for non-diagonal
    
  



DenseMatrix.fromJSON(json) ⇒ DenseMatrix #
Generate a matrix from a JSON object

Kind: static method of DenseMatrix


  
    
      Param
      Type
      Description
    
  
  
    
      json
      Object
      An object structured like                       {"mathjs": "DenseMatrix", data: [], size: []},                       where mathjs is optional
    
  



DenseMatrix.preprocess(data) ⇒ Array #
Preprocess data, which can be an Array or DenseMatrix with nested Arrays and
Matrices. Replaces all nested Matrices with Arrays

Kind: static method of DenseMatrix 
Returns: Array - data


  
    
      Param
      Type
    
  
  
    
      data
      Array\n\n\n\nSparseMatrix #
Sparse Matrix implementation. This type implements a Compressed Column Storage format
for sparse matrices.


  instance
    
      .storage() ⇒ string
      .datatype() ⇒ string
      .create(data, [datatype])
      .density() ⇒ number
      .subset(index, [replacement], [defaultValue])
      .get(index) ⇒ \*
      .set(index, value, [defaultValue]) ⇒ [SparseMatrix](#SparseMatrix)
      .resize(size, [defaultValue], [copy]) ⇒ Matrix
      .clone() ⇒ [SparseMatrix](#SparseMatrix)
      .size() ⇒ Array.<number>
      .map(callback, [skipZeros]) ⇒ [SparseMatrix](#SparseMatrix)
      .forEach(callback, [skipZeros])
      .toArray() ⇒ Array
      .valueOf() ⇒ Array
      .format([options]) ⇒ string
      .toString() ⇒ string
      .toJSON() ⇒ Object
      .diagonal([k]) ⇒ Matrix
      .swapRows(i, j) ⇒ Matrix
    
  
  static
    
      .fromJSON(json) ⇒ [SparseMatrix](#SparseMatrix)
      .diagonal(size, value, [k], [datatype]) ⇒ [SparseMatrix](#SparseMatrix)
    
  



sparseMatrix.storage() ⇒ string #
Get the storage format used by the matrix.

Usage:
const format = matrix.storage()  // retrieve storage format


Kind: instance method of [SparseMatrix](#SparseMatrix)
Returns: string - The storage format.

sparseMatrix.datatype() ⇒ string #
Get the datatype of the data stored in the matrix.

Usage:
const format = matrix.datatype()  // retrieve matrix datatype


Kind: instance method of [SparseMatrix](#SparseMatrix)
Returns: string - The datatype.

sparseMatrix.create(data, [datatype]) #
Create a new SparseMatrix

Kind: instance method of [SparseMatrix](#SparseMatrix)


  
    
      Param
      Type
    
  
  
    
      data
      Array
    
    
      [datatype]
      string
    
  



sparseMatrix.density() ⇒ number #
Get the matrix density.

Usage:
const density = matrix.density()  // retrieve matrix density


Kind: instance method of [SparseMatrix](#SparseMatrix)
Returns: number - The matrix density.

sparseMatrix.subset(index, [replacement], [defaultValue]) #
Get a subset of the matrix, or replace a subset of the matrix.

Usage:
const subset = matrix.subset(index)               // retrieve subset
const value = matrix.subset(index, replacement)   // replace subset


Kind: instance method of [SparseMatrix](#SparseMatrix)


  
    
      Param
      Type
      Default
      Description
    
  
  
    
      index
      Index
       
       
    
    
      [replacement]
      Array | Maytrix | \*
       
       
    
    
      [defaultValue]
      \*
      0
      Default value, filled in on new entries when                                  the matrix is resized. If not provided,                                  new matrix elements will be filled with zeros.
    
  



sparseMatrix.get(index) ⇒ \* #
Get a single element from the matrix.

Kind: instance method of [SparseMatrix](#SparseMatrix)
Returns: \* - value


  
    
      Param
      Type
      Description
    
  
  
    
      index
      Array.<number>
      Zero-based index
    
  



sparseMatrix.set(index, value, [defaultValue]) ⇒ [SparseMatrix](#SparseMatrix) #
Replace a single element in the matrix.

Kind: instance method of [SparseMatrix](#SparseMatrix)
Returns: [SparseMatrix](#SparseMatrix) - self


  
    
      Param
      Type
      Description
    
  
  
    
      index
      Array.<number>
      Zero-based index
    
    
      value
      \*
       
    
    
      [defaultValue]
      \*
      Default value, filled in on new entries when                                  the matrix is resized. If not provided,                                  new matrix elements will be set to zero.
    
  



sparseMatrix.resize(size, [defaultValue], [copy]) ⇒ Matrix #
Resize the matrix to the given size. Returns a copy of the matrix when 
copy=true, otherwise return the matrix itself (resize in place).

Kind: instance method of [SparseMatrix](#SparseMatrix)
Returns: Matrix - The resized matrix


  
    
      Param
      Type
      Default
      Description
    
  
  
    
      size
      Array.<number>
       
      The new size the matrix should have.
    
    
      [defaultValue]
      \*
      0
      Default value, filled in on new entries.                                  If not provided, the matrix elements will                                  be filled with zeros.
    
    
      [copy]
      boolean
       
      Return a resized copy of the matrix
    
  



sparseMatrix.clone() ⇒ [SparseMatrix](#SparseMatrix) #
Create a clone of the matrix

Kind: instance method of [SparseMatrix](#SparseMatrix)
Returns: [SparseMatrix](#SparseMatrix) - clone

sparseMatrix.size() ⇒ Array.<number> #
Retrieve the size of the matrix.

Kind: instance method of [SparseMatrix](#SparseMatrix)
Returns: Array.<number> - size

sparseMatrix.map(callback, [skipZeros]) ⇒ [SparseMatrix](#SparseMatrix) #
Create a new matrix with the results of the callback function executed on
each entry of the matrix.

Kind: instance method of [SparseMatrix](#SparseMatrix)
Returns: [SparseMatrix](#SparseMatrix) - matrix


  
    
      Param
      Type
      Description
    
  
  
    
      callback
      function
      The callback function is invoked with three                              parameters: the value of the element, the index                              of the element, and the Matrix being traversed.
    
    
      [skipZeros]
      boolean
      Invoke callback function for non-zero values only.
    
  



sparseMatrix.forEach(callback, [skipZeros]) #
Execute a callback function on each entry of the matrix.

Kind: instance method of [SparseMatrix](#SparseMatrix)


  
    
      Param
      Type
      Description
    
  
  
    
      callback
      function
      The callback function is invoked with three                              parameters: the value of the element, the index                              of the element, and the Matrix being traversed.
    
    
      [skipZeros]
      boolean
      Invoke callback function for non-zero values only.
    
  



sparseMatrix.toArray() ⇒ Array #
Create an Array with a copy of the data of the SparseMatrix

Kind: instance method of [SparseMatrix](#SparseMatrix)
Returns: Array - array

sparseMatrix.valueOf() ⇒ Array #
Get the primitive value of the SparseMatrix: a two dimensions array

Kind: instance method of [SparseMatrix](#SparseMatrix)
Returns: Array - array

sparseMatrix.format([options]) ⇒ string #
Get a string representation of the matrix, with optional formatting options.

Kind: instance method of [SparseMatrix](#SparseMatrix)
Returns: string - str


  
    
      Param
      Type
      Description
    
  
  
    
      [options]
      Object | number | function
      Formatting options. See                                                lib/utils/number:format for a                                                description of the available                                                options.
    
  



sparseMatrix.toString() ⇒ string #
Get a string representation of the matrix

Kind: instance method of [SparseMatrix](#SparseMatrix)
Returns: string - str

sparseMatrix.toJSON() ⇒ Object #
Get a JSON representation of the matrix

Kind: instance method of [SparseMatrix](#SparseMatrix)

sparseMatrix.diagonal([k]) ⇒ Matrix #
Get the kth Matrix diagonal.

Kind: instance method of [SparseMatrix](#SparseMatrix)
Returns: Matrix - The matrix vector with the diagonal values.


  
    
      Param
      Type
      Default
      Description
    
  
  
    
      [k]
      number | BigNumber
      0
      The kth diagonal where the vector will retrieved.
    
  



sparseMatrix.swapRows(i, j) ⇒ Matrix #
Swap rows i and j in Matrix.

Kind: instance method of [SparseMatrix](#SparseMatrix)
Returns: Matrix - The matrix reference


  
    
      Param
      Type
      Description
    
  
  
    
      i
      number
      Matrix row index 1
    
    
      j
      number
      Matrix row index 2
    
  



SparseMatrix.fromJSON(json) ⇒ [SparseMatrix](#SparseMatrix) #
Generate a matrix from a JSON object

Kind: static method of [SparseMatrix](#SparseMatrix)


  
    
      Param
      Type
      Description
    
  
  
    
      json
      Object
      An object structured like                       {"mathjs": "SparseMatrix", "values": [], "index": [], "ptr": [], "size": []},                       where mathjs is optional
    
  



SparseMatrix.diagonal(size, value, [k], [datatype]) ⇒ [SparseMatrix](#SparseMatrix) #
Create a diagonal matrix.

Kind: static method of [SparseMatrix](#SparseMatrix)


  
    
      Param
      Type
      Default
      Description
    
  
  
    
      size
      Array
       
      The matrix size.
    
    
      value
      number | Array | Matrix
       
      The values for the diagonal.
    
    
      [k]
      number | BigNumber
      0
      The kth diagonal where the vector will be filled in.
    
    
      [datatype]
      string
       
      The Matrix datatype, values must be of this datatype.\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nFunction format #

Format a value of any type into a string.

Syntax #

math.format(value)
math.format(value, options)
math.format(value, precision)
math.format(value, callback)


Where #


  value: *
The value to be formatted
  options: Object
An object with formatting options. Available options:
    
      notation: string
Number notation. Choose from:
        
          'fixed'
Always use regular number notation.
For example '123.40' and '14000000'
          'exponential'
Always use exponential notation.
For example '1.234e+2' and '1.4e+7'
          'engineering'
Always use engineering notation: always have exponential notation,
and select the exponent to be a multiple of 3.
For example '123.4e+0' and '14.0e+6'
          'auto' (default)
Regular number notation for numbers having an absolute value between
lower and upper bounds, and uses exponential notation elsewhere.
Lower bound is included, upper bound is excluded.
For example '123.4' and '1.4e7'.
          'bin', 'oct', or 'hex'
Format the number using binary, octal, or hexadecimal notation.
For example '0b1101' and '0x10fe'.
        
      
      wordSize: number | BigNumber
The word size in bits to use for formatting in binary, octal, or
hexadecimal notation. To be used only with 'bin', 'oct', or 'hex'
values for notation option. When this option is defined the value
is formatted as a signed twos complement integer of the given word
size and the size suffix is appended to the output.
For example format(-1, {notation: 'hex', wordSize: 8}) === '0xffi8'.
Default value is undefined.
      precision: number | BigNumber
Limit the number of digits of the formatted value.
For regular numbers, must be a number between 0 and 16.
For bignumbers, the maximum depends on the configured precision,
see function config().
In case of notations 'exponential', 'engineering', and 'auto',
precision defines the total number of significant digits returned.
In case of notation 'fixed', precision defines the number of
significant digits after the decimal point.
precision is undefined by default.
      lowerExp: number
Exponent determining the lower boundary for formatting a value with
an exponent when notation='auto'. Default value is -3.
      upperExp: number
Exponent determining the upper boundary for formatting a value with
an exponent when notation='auto'. Default value is 5.
      fraction: string. Available values: 'ratio' (default) or 'decimal'.
For example format(fraction(1, 3)) will output '1/3' when 'ratio'
is configured, and will output '0.(3)' when 'decimal' is configured.
      truncate: number. Specifies the maximum allowed length of the
returned string. If it had been longer, the excess characters
are deleted and replaced with '...'.
    
  
  callback: function
A custom formatting function, invoked for all numeric elements in value,
for example all elements of a matrix, or the real and imaginary
parts of a complex number. This callback can be used to override the
built-in numeric notation with any type of formatting. Function callback
is called with value as parameter and must return a string.


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      value
      *
      Value to be stringified
    
    
      options
      Object | Function | number
      Formatting options
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      string
      The formatted value
    
  


Throws #

Type | Description
—- | ———–

Examples #

math.format(6.4)                                        // returns '6.4'
math.format(1240000)                                    // returns '1.24e+6'
math.format(1/3)                                        // returns '0.3333333333333333'
math.format(1/3, 3)                                     // returns '0.333'
math.format(21385, 2)                                   // returns '21000'
math.format(12e8, {notation: 'fixed'})                  // returns '1200000000'
math.format(2.3,  {notation: 'fixed', precision: 4})    // returns '2.3000'
math.format(52.8, {notation: 'exponential'})            // returns '5.28e+1'
math.format(12400, {notation: 'engineering'})           // returns '12.4e+3'
math.format(2000, {lowerExp: -2, upperExp: 2})          // returns '2e+3'

function formatCurrency(value) {
  // return currency notation with two digits:
  return '$' + value.toFixed(2)

  // you could also use math.format inside the callback:
  // return '$' + math.format(value, {notation: 'fixed', precision: 2})
}
math.format([2.1, 3, 0.016], formatCurrency)            // returns '[$2.10, $3.00, $0.02]'


See also #

print\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nUnits #

Math.js supports units. Units can be used to do calculations and to perform
conversions.

Usage #

Units can be created using the function math.unit. This function accepts
either a single string argument containing a value and unit, or two arguments,
the first being a numeric value and the second a string containing a unit.
Most units support prefixes like k or kilo, and many units have both a
full name and an abbreviation. The returned object is a Unit.

Syntax:

math.unit(value: number, valuelessUnit: string) : Unit
math.unit(value: number, valuelessUnit: Unit) : Unit
math.unit(unit: string) : Unit
math.unit(unit: Unit) : Unit


Example usage:

const a = math.unit(45, 'cm')             // Unit 450 mm
const b = math.unit('0.1 kilogram')       // Unit 100 gram
const c = math.unit('2 inch')             // Unit 2 inch
const d = math.unit('90 km/h')            // Unit 90 km/h
const e = math.unit('101325 kg/(m s^2)')  // Unit 101325 kg / (m s^2)

const f = c.to('cm')                      // Unit 5.08 cm
b.toNumber('gram')                        // Number 100
math.number(b, 'gram')                    // Number 100

c.equals(a)                               // false
c.equals(f)                               // true
c.equalBase(a)                            // true
c.equalBase(b)                            // false

f.toString()                              // String "5.08 cm"

const kph = math.unit('km/h')             // valueless Unit km/h
const mps = math.unit('m/s')              // valueless Unit m/s
const speed = math.unit(36, kph)          // Unit 36 km/h
speed.toNumber(mps)                       // Number 10


Use care when creating a unit with multiple terms in the denominator. Implicit multiplication has the same operator precedence as explicit multiplication and division, which means these three expressions are identical:

// These three are identical
const correct1 = math.unit('8.314 m^3 Pa / mol / K')           // Unit 8.314 (m^3 Pa) / (mol K)
const correct2 = math.unit('8.314 (m^3 Pa) / (mol K)')         // Unit 8.314 (m^3 Pa) / (mol K)
const correct3 = math.unit('8.314 (m^3 * Pa) / (mol * K)')     // Unit 8.314 (m^3 Pa) / (mol K)

But this expression, which omits the second / between mol and K, results in the wrong value:

// Missing the second '/' between 'mol' and 'K'
const incorrect = math.unit('8.314 m^3 Pa / mol K')            // Unit 8.314 (m^3 Pa K) / mol


The function math.unit has its own small parser. This parser differs a bit from the expression parser math.evaluate, and returns the expected result in this case:

// using math.evaluate instead of math.unit
const correct4 = math.evaluate('8.314 (m^3 * Pa) / (mol * K)') // Unit 8.314 (m^3 Pa) / (mol K)


In summary: be careful with implicit multiplication. In case of doubt, always use an explicit * and parenthesis.

Calculations #

The operations that support units are add, subtract, multiply, divide, pow, abs, sqrt, square, cube, and sign.
Trigonometric functions like cos are also supported when the argument is an angle.

const a = math.unit(45, 'cm')       // Unit 450 mm
const b = math.unit('0.1m')         // Unit 100 mm
math.add(a, b)                      // Unit 0.55 m
math.multiply(b, 2)                 // Unit 200 mm

const c = math.unit(45, 'deg')      // Unit 45 deg
math.cos(c)                         // Number 0.7071067811865476

// Kinetic energy of average sedan on highway
const d = math.unit('80 mi/h')      // Unit 80 mi/h
const e = math.unit('2 tonne')      // Unit 2 tonne
const f = math.multiply(0.5, math.multipy(math.pow(d, 2), e))
                                    // 1.2790064742399996 MJ


Operations with arrays are supported too:

// Force on a charged particle moving through a magnetic field
const B = math.evaluate('[1, 0, 0] T')         // [1 T, 0 T, 0 T]
const v = math.evaluate('[0, 1, 0] m/s')       // [0 m / s, 1 m / s, 0 m / s]
const q = math.evaluate('1 C')                 // 1 C

const F = math.multiply(q, math.cross(v, B))   // [0 N, 0 N, -1 N]


All arithmetic operators act on the value of the unit as it is represented in SI units.
This may lead to surprising behavior when working with temperature scales like celsius (or degC) and fahrenheit (or degF).
In general, you should avoid calculations using celsius and fahrenheit. Rather, use kelvin (or K) and rankine (or degR) instead.
This example highlights some problems when using celsius and fahrenheit in calculations:

const T_14F = math.unit('14 degF')            // Unit 14 degF (263.15 K)
const T_28F = math.multiply(T_14F, 2)         // Unit 28 degF (270.93 K), not 526.3 K

const Tnegative = math.unit(-13, 'degF')      // Unit -13 degF (248.15 K)
const Tpositive = math.abs(Tnegative)         // Unit -13 degF (248.15 K), not 13 degF


The expression parser supports units too. This is described in the section about
units on the page Syntax.

User-Defined Units #

You can add your own units to Math.js using the math.createUnit function. The following example defines a new unit furlong, then uses the user-defined unit in a calculation:

math.createUnit('furlong', '220 yards')
math.evaluate('1 mile to furlong')            // 8 furlong


If you cannot express the new unit in terms of any existing unit, then the second argument can be omitted. In this case, a new base unit is created:

// A 'foo' cannot be expressed in terms of any other unit.
math.createUnit('foo')
math.evaluate('8 foo * 4 feet')               // 32 foo feet


The second argument to createUnit can also be a configuration object consisting of the following properties:


  definition A string or Unit which defines the user-defined unit in terms of existing built-in or user-defined units. If omitted, a new base unit is created.
  prefixes A string indicating which prefixes math.js should use with the new unit. Possible values are 'none', 'short', 'long', 'binary_short', or 'binary_long'. Default is 'none'.
  offset A value applied when converting to the unit. This is very helpful for temperature scales that do not share a zero with the absolute temperature scale. For example, if we were defining fahrenheit for the first time, we would use: math.createUnit('fahrenheit', {definition: '0.555556 kelvin', offset: 459.67})
  aliases An array of strings to alias the new unit. Example: math.createUnit('knot', {definition: '0.514444 m/s', aliases: ['knots', 'kt', 'kts']})
  baseName A string that specifies the name of the new dimension in case one needs to be created. Every unit in math.js has a dimension: length, time, velocity, etc. If the unit’s definition doesn’t match any existing dimension, or it is a new base unit, then createUnit will create a new dimension with the name baseName and assign it to the new unit. The default is to append '_STUFF' to the unit’s name. If the unit already matches an existing dimension, this option has no effect.


An optional options object can also be supplied as the last argument to createUnits. Currently only the override option is supported:

// Redefine the mile (would not be the first time in history)
math.createUnit('mile', '1609.347218694 m', {override: true})

Base units created without specifying a definition cannot be overridden.

Create several units at once #
Multiple units can defined using a single call to createUnit by passing an object map as the first argument, where each key in the object is the name of a new unit and the value is either a string defining the unit, or an object with the configuration properties listed above. If the value is an empty string or an object lacking a definition property, a new base unit is created.

For example:

math.createUnit( {
  foo: {
    prefixes: 'long',
    baseName: 'essence-of-foo'
  },
  bar: '40 foo',
  baz: {
    definition: '1 bar/hour',
    prefixes: 'long'
  }
},
{
  override: true
})
math.evaluate('50000 kilofoo/s')  // 4.5 gigabaz


Return Value #
createUnit returns the created unit, or, when multiple units are created, the last unit created. Since createUnit is also compatible with the expression parser, this allows you to do things like this:

math.evaluate('45 mile/hour to createUnit("knot", "0.514444m/s")')
// 39.103964668651976 knot


Support of custom characters in unit names #
Per default, the name of a new unit:

  should start by a latin (A-Z or a-z) character
  should contain only numeric (0-9) or latin characters


It is possible to allow the usage of special characters (such as Greek alphabet, cyrillic alphabet, any Unicode symbols, etc.) by overriding the Unit.isValidAlpha static method. For example:
const isAlphaOriginal = math.Unit.isValidAlpha
const isGreekLowercaseChar = function (c) {
  const charCode = c.charCodeAt(0)
  return charCode > 944 && charCode < 970
}
math.Unit.isValidAlpha = function (c) {
  return isAlphaOriginal(c) || isGreekLowercaseChar(c)
}

math.createUnit('θ', '1 rad')
math.evaluate('1θ + 3 deg').toNumber('deg') // 60.29577951308232


Numeric type of the value of a unit #

The built-in units are always created with a value being a number. To turn the value into for example a BigNumber or Fraction, you can convert the value using the function math.fraction and math.bignumber:

math.unit(math.fraction(10), 'inch').toNumeric('cm')  // Fraction 127/5
math.fraction(math.unit(10, 'inch')).toNumeric('cm')  // Fraction 127/5

math.bignumber(math.unit(10, 'inch')).toNumeric('cm') // BigNumber 25.4
math.unit(math.bignumber(10), 'inch').toNumeric('cm') // BigNumber 25.4


When using the expression parser, it is possible to configure numeric values to be parsed as Fraction or BigNumber:

math.config({ number: 'Fraction' })
math.evaluate('10 inch').toNumeric('cm') // Fraction 127/5


API #
A Unit object contains the following functions:

unit.clone() #
Clone the unit, returns a new unit with the same parameters.

unit.equalBase(unit) #
Test whether a unit has the same base as an other unit:
length, mass, etc.

unit.equals(unit) #
Test whether a unit equals an other unit. Units are equal
when they have the same base and same value when normalized to SI units.

unit.format([options]) #
Get a string representation of the unit. The function
will determine the best fitting prefix for the unit. See the Format
page for available options.

unit.fromJSON(json) #
Revive a unit from a JSON object. Accepts
An object {mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean},
where the property mathjs and fixPrefix are optional.
Used when deserializing a unit, see Serialization.

unit.splitUnit(parts) #
Split a unit into the specified parts. For example:

const u = math.unit(1, 'm')
u.splitUnit(['ft', 'in'])    // 3 feet,3.3700787401574765 inch


unit.to(unitName) #
Convert the unit to a specific unit name. Returns a clone of
the unit with a fixed prefix and unit.

unit.toJSON() #
Returns a JSON representation of the unit, with signature
{mathjs: 'Unit', value: number, unit: string, fixPrefix: boolean}.
Used when serializing a unit, see Serialization.

unit.toNumber(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value is always number.

unit.toNumeric(unitName) #
Get the value of a unit when converted to the
specified unit (a unit with optional prefix but without value).
The type of the returned value depends on how the unit was created and
can be number, Fraction, or BigNumber.

unit.toSI() #
Returns a clone of a unit represented in SI units. Works with units with or without a value.

unit.toString() #
Get a string representation of the unit. The function will
determine the best fitting prefix for the unit.

unit.valType() #
Get the string name of the current type of the value of this Unit object, e.g.
‘number’, ‘BigNumber’, etc.

Unit reference #

This section lists all available units, prefixes, and physical constants. These can be used via the Unit object, or via math.evaluate().

Reference #

Math.js comes with the following built-in units.


  
    
      Base
      Unit
    
  
  
    
      Length
      meter (m), inch (in), foot (ft), yard (yd), mile (mi), link (li), rod (rd), chain (ch), angstrom, mil
    
    
      Surface area
      m2, sqin, sqft, sqyd, sqmi, sqrd, sqch, sqmil, acre, hectare
    
    
      Volume
      m3, litre (l, L, lt, liter), cc, cuin, cuft, cuyd, teaspoon, tablespoon
    
    
      Liquid volume
      minim, fluiddram (fldr), fluidounce (floz), gill (gi), cup (cp), pint (pt), quart (qt), gallon (gal), beerbarrel (bbl), oilbarrel (obl), hogshead, drop (gtt)
    
    
      Angles
      rad (radian), deg (degree), grad (gradian), cycle, arcsec (arcsecond), arcmin (arcminute)
    
    
      Time
      second (s, secs, seconds), minute (min, mins, minutes), hour (h, hr, hrs, hours), day (days), week (weeks), month (months), year (years), decade (decades), century (centuries), millennium (millennia)
    
    
      Frequency
      hertz (Hz)
    
    
      Mass
      gram(g), tonne, ton, grain (gr), dram (dr), ounce (oz), poundmass (lbm, lb, lbs), hundredweight (cwt), stick, stone
    
    
      Electric current
      ampere (A)
    
    
      Temperature
      kelvin (K), celsius (degC), fahrenheit (degF), rankine (degR)
    
    
      Amount of substance
      mole (mol)
    
    
      Luminous intensity
      candela (cd)
    
    
      Force
      newton (N), dyne (dyn), poundforce (lbf), kip
    
    
      Energy
      joule (J), erg, Wh, BTU, electronvolt (eV)
    
    
      Power
      watt (W), hp
    
    
      Pressure
      Pa, psi, atm, torr, bar, mmHg, mmH2O, cmH2O
    
    
      Electricity and magnetism
      ampere (A), coulomb (C), watt (W), volt (V), ohm, farad (F), weber (Wb), tesla (T), henry (H), siemens (S), electronvolt (eV)
    
    
      Binary
      bits (b), bytes (B)
    
  


Note: all time units are based on the Julian year, with one month being 1/12th of a Julian year, a year being one Julian year, a decade being 10 Julian years, a century being 100, and a millennium being 1000.

Note that all relevant units can also be written in plural form, for example 5 meters instead of 5 meter or 10 seconds instead of 10 second.

Surface and volume units can alternatively be expressed in terms of length units raised to a power, for example 100 in^2 instead of 100 sqin.

Prefixes #

The following decimal prefixes are available.


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deca
      da
      1e1
    
    
      hecto
      h
      1e2
    
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
    
      ronna
      R
      1e27
    
    
      quetta
      Q
      1e30
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      deci
      d
      1e-1
    
    
      centi
      c
      1e-2
    
    
      milli
      m
      1e-3
    
    
      micro
      u
      1e-6
    
    
      nano
      n
      1e-9
    
    
      pico
      p
      1e-12
    
    
      femto
      f
      1e-15
    
    
      atto
      a
      1e-18
    
    
      zepto
      z
      1e-21
    
    
      yocto
      y
      1e-24
    
    
      ronto
      r
      1e-27
    
    
      quecto
      q
      1e-30
    
  


The following binary prefixes are available.
They can be used with units bits (b) and bytes (B).


  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kibi
      Ki
      1024
    
    
      mebi
      Mi
      1024^2
    
    
      gibi
      Gi
      1024^3
    
    
      tebi
      Ti
      1024^4
    
    
      pebi
      Pi
      1024^5
    
    
      exi
      Ei
      1024^6
    
    
      zebi
      Zi
      1024^7
    
    
      yobi
      Yi
      1024^8
    
  



  
    
      Name
      Abbreviation
      Value
    
  
  
    
      kilo
      k
      1e3
    
    
      mega
      M
      1e6
    
    
      giga
      G
      1e9
    
    
      tera
      T
      1e12
    
    
      peta
      P
      1e15
    
    
      exa
      E
      1e18
    
    
      zetta
      Z
      1e21
    
    
      yotta
      Y
      1e24
    
  


Physical Constants #

Math.js includes the following physical constants. See Wikipedia for more information.

Universal constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      speedOfLight
      c
      299792458
      m · s-1
    
    
      gravitationConstant
      G
      6.6738480e-11
      m3 · kg-1 · s-2
    
    
      planckConstant
      h
      6.626069311e-34
      J · s
    
    
      reducedPlanckConstant
      h
      1.05457172647e-34
      J · s
    
  


Electromagnetic constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      magneticConstant
      μ0
      1.2566370614e-6
      N · A-2
    
    
      electricConstant
      ε0
      8.854187817e-12
      F · m-1
    
    
      vacuumImpedance
      Z0
      376.730313461
      &ohm;
    
    
      coulomb
      κ
      8.9875517873681764e9
      N · m2 · C-2
    
    
      elementaryCharge
      e
      1.60217656535e-19
      C
    
    
      bohrMagneton
      μB
      9.2740096820e-24
      J · T-1
    
    
      conductanceQuantum
      G0
      7.748091734625e-5
      S
    
    
      inverseConductanceQuantum
      G0-1
      12906.403721742
      &ohm;
    
    
      magneticFluxQuantum
      f0
      2.06783375846e-15
      Wb
    
    
      nuclearMagneton
      μN
      5.0507835311e-27
      J · T-1
    
    
      klitzing
      RK
      25812.807443484
      &ohm;
    
  




Atomic and nuclear constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      bohrRadius
      a0
      5.291772109217e-11
      m
    
    
      classicalElectronRadius
      re
      2.817940326727e-15
      m
    
    
      electronMass
      me
      9.1093829140e-31
      kg
    
    
      fermiCoupling
      GF
      1.1663645e-5
      GeV-2
    
    
      fineStructure
      α
      7.297352569824e-3
      -
    
    
      hartreeEnergy
      Eh 
      4.3597443419e-18
      J
    
    
      protonMass
      mp
      1.67262177774e-27
      kg
    
    
      deuteronMass
      md
      3.3435830926e-27
      kg
    
    
      neutronMass
      mn
      1.6749271613e-27
      kg
    
    
      quantumOfCirculation
      h / (2me)
      3.636947552024e-4
      m2 · s-1
    
    
      rydberg
      R∞
      10973731.56853955
      m-1
    
    
      thomsonCrossSection
       
      6.65245873413e-29
      m2
    
    
      weakMixingAngle
       
      0.222321
      -
    
    
      efimovFactor
       
      22.7
      -
    
  


Physico-chemical constants #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      atomicMass
      mu
      1.66053892173e-27
      kg
    
    
      avogadro
      NA
      6.0221412927e23
      mol-1
    
    
      boltzmann
      k
      1.380648813e-23
      J · K-1
    
    
      faraday
      F
      96485.336521
      C · mol-1
    
    
      firstRadiation
      c1
      3.7417715317e-16
      W · m2
    
    
      loschmidt
      n0
      2.686780524e25
      m-3
    
    
      gasConstant
      R
      8.314462175
      J · K-1 · mol-1
    
    
      molarPlanckConstant
      NA · h
      3.990312717628e-10
      J · s · mol-1
    
    
      molarVolume
      Vm
      2.241396820e-10
      m3 · mol-1
    
    
      sackurTetrode
       
      -1.164870823
      -
    
    
      secondRadiation
      c2
      1.438777013e-2
      m · K
    
    
      stefanBoltzmann
      σ
      5.67037321e-8
      W · m-2 · K-4
    
    
      wienDisplacement
      b
      2.897772126e-3
      m · K
    
  




Note that the values of loschmidt and molarVolume are at T = 273.15 K and p = 101.325 kPa.
The value of sackurTetrode is at T = 1 K and p = 101.325 kPa.

Adopted values #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      molarMass
      Mu
      1e-3
      kg · mol-1
    
    
      molarMassC12
      M(12C)
      1.2e-2
      kg · mol-1
    
    
      gravity
      gn
      9.80665
      m · s-2
    
    
      atm
      atm
      101325
      Pa
    
  


Natural units #


  
    
      Name
      Symbol
      Value
      Unit
    
  
  
    
      planckLength
      lP
      1.61619997e-35
      m
    
    
      planckMass
      mP
      2.1765113e-8
      kg
    
    
      planckTime
      tP
      5.3910632e-44
      s
    
    
      planckCharge
      qP
      1.87554595641e-18
      C
    
    
      planckTemperature
      TP
      1.41683385e+32
      K\n\n\n\nReference #


  Classes
  Constants
  Functions\n\n\n\nClass Reference #

This page lists all the various class types in Math.js. Every top-level function is listed here and links to its detailed reference to other parts of the documentation.

math #

The “math” namespace contains the entire math.js functionality. All of the mathematical functions are available in the “math” namespace, and allow for inputs of various types.


  Function reference
  Constant reference


Unit #

Stores values for a scalar unit and its postfix. (eg 100 mm or 100 kg). Although the Unit class contains public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  Overview
  Class API


Fraction #

Stores values for a fractional number.


  Overview
  Class API


BigNumber #

Stores values for a arbitrary-precision floating point number.


  Overview
  Class API


Matrix #

Two types of matrix classes are available in math.js, for storage of dense and sparse matrices. Although they contain public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  Overview
  DenseMatrix
  SparseMatrix


Classes used internally that may be of use to developers:


  Index
  Range
  ResultSet
  FibonacciHeap


Complex #

Stores values for a complex number.


  Overview
  Class API


Parser #

The Parser object returned by math.parser().


  Overview


Node #

A node in an expression-tree, which can be used to analyze, manipulate, and evaluate expressions.


  Overview


Node is the base class of all other node classes:


  AccessorNode
  ArrayNode
  AssignmentNode
  BlockNode
  ConditionalNode
  ConstantNode
  FunctionAssignmentNode
  FunctionNode
  IndexNode
  ObjectNode
  OperatorNode
  ParenthesisNode
  RangeNode
  SymbolNode\n\n\n\nClass Reference #

This page lists all the various class types in Math.js. Every top-level function is listed here and links to its detailed reference to other parts of the documentation.

math #

The “math” namespace contains the entire math.js functionality. All of the mathematical functions are available in the “math” namespace, and allow for inputs of various types.


  Function reference
  Constant reference


Unit #

Stores values for a scalar unit and its postfix. (eg 100 mm or 100 kg). Although the Unit class contains public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  Overview
  Class API


Fraction #

Stores values for a fractional number.


  Overview
  Class API


BigNumber #

Stores values for a arbitrary-precision floating point number.


  Overview
  Class API


Matrix #

Two types of matrix classes are available in math.js, for storage of dense and sparse matrices. Although they contain public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  Overview
  DenseMatrix
  SparseMatrix


Classes used internally that may be of use to developers:


  Index
  Range
  ResultSet
  FibonacciHeap


Complex #

Stores values for a complex number.


  Overview
  Class API


Parser #

The Parser object returned by math.parser().


  Overview


Node #

A node in an expression-tree, which can be used to analyze, manipulate, and evaluate expressions.


  Overview


Node is the base class of all other node classes:


  AccessorNode
  ArrayNode
  AssignmentNode
  BlockNode
  ConditionalNode
  ConstantNode
  FunctionAssignmentNode
  FunctionNode
  IndexNode
  ObjectNode
  OperatorNode
  ParenthesisNode
  RangeNode
  SymbolNode\n\n\n\nClass Reference #

This page lists all the various class types in Math.js. Every top-level function is listed here and links to its detailed reference to other parts of the documentation.

math #

The “math” namespace contains the entire math.js functionality. All of the mathematical functions are available in the “math” namespace, and allow for inputs of various types.


  Function reference
  Constant reference


Unit #

Stores values for a scalar unit and its postfix. (eg 100 mm or 100 kg). Although the Unit class contains public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  Overview
  Class API


Fraction #

Stores values for a fractional number.


  Overview
  Class API


BigNumber #

Stores values for a arbitrary-precision floating point number.


  Overview
  Class API


Matrix #

Two types of matrix classes are available in math.js, for storage of dense and sparse matrices. Although they contain public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  Overview
  DenseMatrix
  SparseMatrix


Classes used internally that may be of use to developers:


  Index
  Range
  ResultSet
  FibonacciHeap


Complex #

Stores values for a complex number.


  Overview
  Class API


Parser #

The Parser object returned by math.parser().


  Overview


Node #

A node in an expression-tree, which can be used to analyze, manipulate, and evaluate expressions.


  Overview


Node is the base class of all other node classes:


  AccessorNode
  ArrayNode
  AssignmentNode
  BlockNode
  ConditionalNode
  ConstantNode
  FunctionAssignmentNode
  FunctionNode
  IndexNode
  ObjectNode
  OperatorNode
  ParenthesisNode
  RangeNode
  SymbolNode\n\n\n\nUnit #

  new Unit([value], [name])
  instance
    
      .valueOf ⇒ string
      .clone() ⇒ Unit
      ._isDerived() ⇒ boolean
      .hasBase(base)
      .equalBase(other) ⇒ boolean
      .equals(other) ⇒ boolean
      .multiply(other) ⇒ Unit
      .divide(other) ⇒ Unit
      .pow(p) ⇒ Unit
      .abs(x) ⇒ Unit
      .to(valuelessUnit) ⇒ Unit
      .toNumber(valuelessUnit) ⇒ number
      .toNumeric(valuelessUnit) ⇒ number | BigNumber | Fraction
      .toString() ⇒ string
      .toJSON() ⇒ Object
      .formatUnits() ⇒ string
      .format([options]) ⇒ string
    
  
  static
    
      .parse(str) ⇒ Unit
      .isValuelessUnit(name) ⇒ boolean
      .fromJSON(json) ⇒ Unit
    
  



new Unit([value], [name]) #
A unit can be constructed in the following ways:

const a = new Unit(value, name)
const b = new Unit(null, name)
const c = Unit.parse(str)


Example usage:

const a = new Unit(5, 'cm')               // 50 mm
const b = Unit.parse('23 kg')             // 23 kg
const c = math.in(a, new Unit(null, 'm')  // 0.05 m
const d = new Unit(9.81, "m/s^2")         // 9.81 m/s^2



  
    
      Param
      Type
      Description
    
  
  
    
      [value]
      number | BigNumber | Fraction | Complex | boolean
      A value like 5.2
    
    
      [name]
      string
      A unit name like “cm” or “inch”, or a derived unit of the form: “u1[^ex1] [u2[^ex2] …] [/ u3[^ex3] [u4[^ex4]]]”, such as “kg m^2/s^2”, where each unit appearing after the forward slash is taken to be in the denominator. “kg m^2 s^-2” is a synonym and is also acceptable. Any of the units can include a prefix.
    
  



unit.valueOf ⇒ string #
Returns the string representation of the unit.

Kind: instance property of Unit

unit.clone() ⇒ Unit #
create a copy of this unit

Kind: instance method of Unit
Returns: Unit - Returns a cloned version of the unit

unit._isDerived() ⇒ boolean #
Return whether the unit is derived (such as m/s, or cm^2, but not N)

Kind: instance method of Unit
Returns: boolean - True if the unit is derived

unit.hasBase(base) #
check if this unit has given base unit
If this unit is a derived unit, this will ALWAYS return false, since by definition base units are not derived.

Kind: instance method of Unit


  
    
      Param
      Type
    
  
  
    
      base
      BASE_UNITS | STRING | undefined
    
  



unit.equalBase(other) ⇒ boolean #
Check if this unit has a base or bases equal to another base or bases
For derived units, the exponent on each base also must match

Kind: instance method of Unit
Returns: boolean - true if equal base


  
    
      Param
      Type
    
  
  
    
      other
      Unit
    
  



unit.equals(other) ⇒ boolean #
Check if this unit equals another unit

Kind: instance method of Unit
Returns: boolean - true if both units are equal


  
    
      Param
      Type
    
  
  
    
      other
      Unit
    
  



unit.multiply(other) ⇒ Unit #
Multiply this unit with another one

Kind: instance method of Unit
Returns: Unit - product of this unit and the other unit


  
    
      Param
      Type
    
  
  
    
      other
      Unit
    
  



unit.divide(other) ⇒ Unit #
Divide this unit by another one

Kind: instance method of Unit
Returns: Unit - result of dividing this unit by the other unit


  
    
      Param
      Type
    
  
  
    
      other
      Unit
    
  



unit.pow(p) ⇒ Unit #
Calculate the power of a unit

Kind: instance method of Unit
Returns: Unit - The result: this^p


  
    
      Param
      Type
    
  
  
    
      p
      number | Fraction | BigNumber
    
  



unit.abs(x) ⇒ Unit #
Calculate the absolute value of a unit

Kind: instance method of Unit
Returns: Unit - The result: |x|, absolute value of x


  
    
      Param
      Type
    
  
  
    
      x
      number | Fraction | BigNumber
    
  



unit.to(valuelessUnit) ⇒ Unit #
Convert the unit to a specific unit name.

Kind: instance method of Unit
Returns: Unit - Returns a clone of the unit with a fixed prefix and unit.


  
    
      Param
      Type
      Description
    
  
  
    
      valuelessUnit
      string | Unit
      A unit without value. Can have prefix, like “cm”
    
  



unit.toNumber(valuelessUnit) ⇒ number #
Return the value of the unit when represented with given valueless unit

Kind: instance method of Unit
Returns: number - Returns the unit value as number.


  
    
      Param
      Type
      Description
    
  
  
    
      valuelessUnit
      string | Unit
      For example ‘cm’ or ‘inch’
    
  



unit.toNumeric(valuelessUnit) ⇒ number | BigNumber | Fraction #
Return the value of the unit in the original numeric type

Kind: instance method of Unit
Returns: number | BigNumber | Fraction - Returns the unit value


  
    
      Param
      Type
      Description
    
  
  
    
      valuelessUnit
      string | Unit
      For example ‘cm’ or ‘inch’
    
  



unit.toString() ⇒ string #
Get a string representation of the unit.

Kind: instance method of Unit

unit.toJSON() ⇒ Object #
Get a JSON representation of the unit

Kind: instance method of Unit
Returns: Object - Returns a JSON object structured as:
                  {"mathjs": "Unit", "value": 2, "unit": "cm", "fixPrefix": false}

unit.formatUnits() ⇒ string #
Get a string representation of the units of this Unit, without the value.

Kind: instance method of Unit

unit.format([options]) ⇒ string #
Get a string representation of the Unit, with optional formatting options.

Kind: instance method of Unit


  
    
      Param
      Type
      Description
    
  
  
    
      [options]
      Object | number | function
      Formatting options. See                                                lib/utils/number:format for a                                                description of the available                                                options.
    
  



Unit.parse(str) ⇒ Unit #
Parse a string into a unit. The value of the unit is parsed as number,
BigNumber, or Fraction depending on the math.js config setting number.

Throws an exception if the provided string does not contain a valid unit or
cannot be parsed.

Kind: static method of Unit
Returns: Unit - unit


  
    
      Param
      Type
      Description
    
  
  
    
      str
      string
      A string like “5.2 inch”, “4e2 cm/s^2”
    
  



Unit.isValuelessUnit(name) ⇒ boolean #
Test if the given expression is a unit.
The unit can have a prefix but cannot have a value.

Kind: static method of Unit
Returns: boolean - true if the given string is a unit


  
    
      Param
      Type
      Description
    
  
  
    
      name
      string
      A string to be tested whether it is a value less unit.                        The unit can have prefix, like “cm”
    
  



Unit.fromJSON(json) ⇒ Unit #
Instantiate a Unit from a JSON object

Kind: static method of Unit


  
    
      Param
      Type
      Description
    
  
  
    
      json
      Object
      A JSON object structured as:                       {"mathjs": "Unit", "value": 2, "unit": "cm", "fixPrefix": false}\n\n\n\nClass Reference #

This page lists all the various class types in Math.js. Every top-level function is listed here and links to its detailed reference to other parts of the documentation.

math #

The “math” namespace contains the entire math.js functionality. All of the mathematical functions are available in the “math” namespace, and allow for inputs of various types.


  Function reference
  Constant reference


Unit #

Stores values for a scalar unit and its postfix. (eg 100 mm or 100 kg). Although the Unit class contains public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  Overview
  Class API


Fraction #

Stores values for a fractional number.


  Overview
  Class API


BigNumber #

Stores values for a arbitrary-precision floating point number.


  Overview
  Class API


Matrix #

Two types of matrix classes are available in math.js, for storage of dense and sparse matrices. Although they contain public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  Overview
  DenseMatrix
  SparseMatrix


Classes used internally that may be of use to developers:


  Index
  Range
  ResultSet
  FibonacciHeap


Complex #

Stores values for a complex number.


  Overview
  Class API


Parser #

The Parser object returned by math.parser().


  Overview


Node #

A node in an expression-tree, which can be used to analyze, manipulate, and evaluate expressions.


  Overview


Node is the base class of all other node classes:


  AccessorNode
  ArrayNode
  AssignmentNode
  BlockNode
  ConditionalNode
  ConstantNode
  FunctionAssignmentNode
  FunctionNode
  IndexNode
  ObjectNode
  OperatorNode
  ParenthesisNode
  RangeNode
  SymbolNode\n\n\n\nClass Reference #

This page lists all the various class types in Math.js. Every top-level function is listed here and links to its detailed reference to other parts of the documentation.

math #

The “math” namespace contains the entire math.js functionality. All of the mathematical functions are available in the “math” namespace, and allow for inputs of various types.


  Function reference
  Constant reference


Unit #

Stores values for a scalar unit and its postfix. (eg 100 mm or 100 kg). Although the Unit class contains public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  Overview
  Class API


Fraction #

Stores values for a fractional number.


  Overview
  Class API


BigNumber #

Stores values for a arbitrary-precision floating point number.


  Overview
  Class API


Matrix #

Two types of matrix classes are available in math.js, for storage of dense and sparse matrices. Although they contain public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  Overview
  DenseMatrix
  SparseMatrix


Classes used internally that may be of use to developers:


  Index
  Range
  ResultSet
  FibonacciHeap


Complex #

Stores values for a complex number.


  Overview
  Class API


Parser #

The Parser object returned by math.parser().


  Overview


Node #

A node in an expression-tree, which can be used to analyze, manipulate, and evaluate expressions.


  Overview


Node is the base class of all other node classes:


  AccessorNode
  ArrayNode
  AssignmentNode
  BlockNode
  ConditionalNode
  ConstantNode
  FunctionAssignmentNode
  FunctionNode
  IndexNode
  ObjectNode
  OperatorNode
  ParenthesisNode
  RangeNode
  SymbolNode\n\n\n\nClass Reference #

This page lists all the various class types in Math.js. Every top-level function is listed here and links to its detailed reference to other parts of the documentation.

math #

The “math” namespace contains the entire math.js functionality. All of the mathematical functions are available in the “math” namespace, and allow for inputs of various types.


  Function reference
  Constant reference


Unit #

Stores values for a scalar unit and its postfix. (eg 100 mm or 100 kg). Although the Unit class contains public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  Overview
  Class API


Fraction #

Stores values for a fractional number.


  Overview
  Class API


BigNumber #

Stores values for a arbitrary-precision floating point number.


  Overview
  Class API


Matrix #

Two types of matrix classes are available in math.js, for storage of dense and sparse matrices. Although they contain public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  Overview
  DenseMatrix
  SparseMatrix


Classes used internally that may be of use to developers:


  Index
  Range
  ResultSet
  FibonacciHeap


Complex #

Stores values for a complex number.


  Overview
  Class API


Parser #

The Parser object returned by math.parser().


  Overview


Node #

A node in an expression-tree, which can be used to analyze, manipulate, and evaluate expressions.


  Overview


Node is the base class of all other node classes:


  AccessorNode
  ArrayNode
  AssignmentNode
  BlockNode
  ConditionalNode
  ConstantNode
  FunctionAssignmentNode
  FunctionNode
  IndexNode
  ObjectNode
  OperatorNode
  ParenthesisNode
  RangeNode
  SymbolNode\n\n\n\nIndex #

  new Index(…ranges)
  instance
    
      .valueOf ⇒ Array
      .clone() ⇒ [Index](#Index)
      .size() ⇒ Array.<number>
      .max() ⇒ Array.<number>
      .min() ⇒ Array.<number>
      .forEach(callback)
      .dimension(dim) ⇒ Range | null
      .isScalar() ⇒ boolean
      .toArray() ⇒ Array
      .toString() ⇒ String
      .toJSON() ⇒ Object
    
  
  static
    
      .fromJSON(json) ⇒ [Index](#Index)
    
  



new Index(...ranges) #
Create an index. An Index can store ranges and sets for multiple dimensions.
Matrix.get, Matrix.set, and math.subset accept an Index as input.

Usage:
const index = new Index(range1, range2, matrix1, array1, ...)


Where each parameter can be any of:


  A number
  An instance of Range
  An Array with the Set values
  A Matrix with the Set values


The parameters start, end, and step must be integer numbers.


  
    
      Param
      Type
    
  
  
    
      …ranges
      \*
    
  



index.valueOf ⇒ Array #
Get the primitive value of the Index, a two dimensional array.
Equivalent to Index.toArray().

Kind: instance property of [Index](#Index)
Returns: Array - array

index.clone() ⇒ [Index](#Index) #
Create a clone of the index

Kind: instance method of [Index](#Index)
Returns: [Index](#Index) - clone

index.size() ⇒ Array.<number> #
Retrieve the size of the index, the number of elements for each dimension.

Kind: instance method of [Index](#Index)
Returns: Array.<number> - size

index.max() ⇒ Array.<number> #
Get the maximum value for each of the indexes ranges.

Kind: instance method of [Index](#Index)
Returns: Array.<number> - max

index.min() ⇒ Array.<number> #
Get the minimum value for each of the indexes ranges.

Kind: instance method of [Index](#Index)
Returns: Array.<number> - min

index.forEach(callback) #
Loop over each of the ranges of the index

Kind: instance method of [Index](#Index)


  
    
      Param
      Type
      Description
    
  
  
    
      callback
      function
      Called for each range with a Range as first                              argument, the dimension as second, and the                              index object as third.
    
  



index.dimension(dim) ⇒ Range | null #
Retrieve the dimension for the given index

Kind: instance method of [Index](#Index)
Returns: Range | null - range


  
    
      Param
      Type
      Description
    
  
  
    
      dim
      Number
      Number of the dimension
    
  



index.isScalar() ⇒ boolean #
Test whether this index contains only a single value.

This is the case when the index is created with only scalar values as ranges,
not for ranges resolving into a single value.

Kind: instance method of [Index](#Index)
Returns: boolean - isScalar

index.toArray() ⇒ Array #
Expand the Index into an array.
For example new Index([0,3], [2,7]) returns [[0,1,2], [2,3,4,5,6]]

Kind: instance method of [Index](#Index)
Returns: Array - array

index.toString() ⇒ String #
Get the string representation of the index, for example ‘[2:6]’ or ‘[0:2:10, 4:7, [1,2,3]]’

Kind: instance method of [Index](#Index)
Returns: String - str

index.toJSON() ⇒ Object #
Get a JSON representation of the Index

Kind: instance method of [Index](#Index)
Returns: Object - Returns a JSON object structured as:
                  {"mathjs": "Index", "ranges": [{"mathjs": "Range", start: 0, end: 10, step:1}, ...]}

Index.fromJSON(json) ⇒ [Index](#Index) #
Instantiate an Index from a JSON object

Kind: static method of [Index](#Index)


  
    
      Param
      Type
      Description
    
  
  
    
      json
      Object
      A JSON object structured as:                     {"mathjs": "Index", "dimensions": [{"mathjs": "Range", start: 0, end: 10, step:1}, ...]}\n\n\n\nRange #

  new Range(start, end, [step])
  instance
    
      .size() ⇒ Array.<number>
      .min() ⇒ number | undefined
      .max() ⇒ number | undefined
      .forEach(callback)
      .map(callback) ⇒ Array
      .toArray() ⇒ Array
      .valueOf() ⇒ Array
      .format([options]) ⇒ string
      .toString() ⇒ string
      .toJSON() ⇒ Object
    
  
  static
    
      .parse(str) ⇒ [Range](#Range) | null
      .fromJSON(json) ⇒ [Range](#Range)
    
  



new Range(start, end, [step]) #
Create a range. A range has a start, step, and end, and contains functions
to iterate over the range.

A range can be constructed as:

const range = new Range(start, end) 
const range = new Range(start, end, step) 


To get the result of the range:

range.forEach(function (x) {
    console.log(x) 
}) 
range.map(function (x) {
    return math.sin(x) 
}) 
range.toArray() 


Example usage:

const c = new Range(2, 6)        // 2:1:5
c.toArray()                      // [2, 3, 4, 5]
const d = new Range(2, -3, -1)   // 2:-1:-2
d.toArray()                      // [2, 1, 0, -1, -2]



  
    
      Param
      Type
      Description
    
  
  
    
      start
      number
      included lower bound
    
    
      end
      number
      excluded upper bound
    
    
      [step]
      number
      step size, default value is 1
    
  



range.size() ⇒ Array.<number> #
Retrieve the size of the range.
Returns an array containing one number, the number of elements in the range.

Kind: instance method of [Range](#Range)
Returns: Array.<number> - size

range.min() ⇒ number | undefined #
Calculate the minimum value in the range

Kind: instance method of [Range](#Range)
Returns: number | undefined - min

range.max() ⇒ number | undefined #
Calculate the maximum value in the range

Kind: instance method of [Range](#Range)
Returns: number | undefined - max

range.forEach(callback) #
Execute a callback function for each value in the range.

Kind: instance method of [Range](#Range)


  
    
      Param
      Type
      Description
    
  
  
    
      callback
      function
      The callback method is invoked with three                              parameters: the value of the element, the index                              of the element, and the Range being traversed.
    
  



range.map(callback) ⇒ Array #
Execute a callback function for each value in the Range, and return the
results as an array

Kind: instance method of [Range](#Range)
Returns: Array - array


  
    
      Param
      Type
      Description
    
  
  
    
      callback
      function
      The callback method is invoked with three                              parameters: the value of the element, the index                              of the element, and the Matrix being traversed.
    
  



range.toArray() ⇒ Array #
Create an Array with a copy of the Ranges data

Kind: instance method of [Range](#Range)
Returns: Array - array

range.valueOf() ⇒ Array #
Get the primitive value of the Range, a one dimensional array

Kind: instance method of [Range](#Range)
Returns: Array - array

range.format([options]) ⇒ string #
Get a string representation of the range, with optional formatting options.
Output is formatted as ‘start:step:end’, for example ‘2:6’ or ‘0:0.2:11’

Kind: instance method of [Range](#Range)
Returns: string - str


  
    
      Param
      Type
      Description
    
  
  
    
      [options]
      Object | number | function
      Formatting options. See                                                lib/utils/number:format for a                                                description of the available                                                options.
    
  



range.toString() ⇒ string #
Get a string representation of the range.

Kind: instance method of [Range](#Range)

range.toJSON() ⇒ Object #
Get a JSON representation of the range

Kind: instance method of [Range](#Range)
Returns: Object - Returns a JSON object structured as:
                  {"mathjs": "Range", "start": 2, "end": 4, "step": 1}

Range.parse(str) ⇒ [Range](#Range) | null #
Parse a string into a range,
The string contains the start, optional step, and end, separated by a colon.
If the string does not contain a valid range, null is returned.
For example str=’0:2:11’.

Kind: static method of [Range](#Range)
Returns: [Range](#Range) | null - range


  
    
      Param
      Type
    
  
  
    
      str
      string
    
  



Range.fromJSON(json) ⇒ [Range](#Range) #
Instantiate a Range from a JSON object

Kind: static method of [Range](#Range)


  
    
      Param
      Type
      Description
    
  
  
    
      json
      Object
      A JSON object structured as:                      {"mathjs": "Range", "start": 2, "end": 4, "step": 1}\n\n\n\nResultSet #

  new ResultSet(entries)
  instance
    
      .valueOf() ⇒ Array
      .toString() ⇒ string
      .toJSON() ⇒ Object
    
  
  static
    
      .fromJSON(json) ⇒ [ResultSet](#ResultSet)
    
  



new ResultSet(entries) #
A ResultSet contains a list or results


  
    
      Param
      Type
    
  
  
    
      entries
      Array
    
  



resultSet.valueOf() ⇒ Array #
Returns the array with results hold by this ResultSet

Kind: instance method of [ResultSet](#ResultSet)
Returns: Array - entries

resultSet.toString() ⇒ string #
Returns the stringified results of the ResultSet

Kind: instance method of [ResultSet](#ResultSet)
Returns: string - string

resultSet.toJSON() ⇒ Object #
Get a JSON representation of the ResultSet

Kind: instance method of [ResultSet](#ResultSet)
Returns: Object - Returns a JSON object structured as:
                  {"mathjs": "ResultSet", "entries": [...]}

ResultSet.fromJSON(json) ⇒ [ResultSet](#ResultSet) #
Instantiate a ResultSet from a JSON object

Kind: static method of [ResultSet](#ResultSet)


  
    
      Param
      Type
      Description
    
  
  
    
      json
      Object
      A JSON object structured as:                       {"mathjs": "ResultSet", "entries": [...]}\n\n\n\nFibonacciHeap #

  new FibonacciHeap()
  instance
    
      .insert()
      .size()
      .clear()
      .isEmpty()
      .extractMinimum()
      .remove()
    
  
  static
    
      ._decreaseKey()
      ._cut()
      ._cascadingCut()
      ._linkNodes()
    
  



new FibonacciHeap() #
Creates a new instance of a Fibonacci Heap.


fibonacciHeap.insert() #
Inserts a new data element into the heap. No heap consolidation is
performed at this time, the new node is simply inserted into the root
list of this heap. Running time: O(1) actual.

Kind: instance method of [FibonacciHeap](#FibonacciHeap)

fibonacciHeap.size() #
Returns the number of nodes in heap. Running time: O(1) actual.

Kind: instance method of [FibonacciHeap](#FibonacciHeap)

fibonacciHeap.clear() #
Removes all elements from this heap.

Kind: instance method of [FibonacciHeap](#FibonacciHeap)

fibonacciHeap.isEmpty() #
Returns true if the heap is empty, otherwise false.

Kind: instance method of [FibonacciHeap](#FibonacciHeap)

fibonacciHeap.extractMinimum() #
Extracts the node with minimum key from heap. Amortized running 
time: O(log n).

Kind: instance method of [FibonacciHeap](#FibonacciHeap)

fibonacciHeap.remove() #
Removes a node from the heap given the reference to the node. The trees
in the heap will be consolidated, if necessary. This operation may fail
to remove the correct element if there are nodes with key value -Infinity.
Running time: O(log n) amortized.

Kind: instance method of [FibonacciHeap](#FibonacciHeap)

FibonacciHeap._decreaseKey() #
Decreases the key value for a heap node, given the new value to take on.
The structure of the heap may be changed and will not be consolidated. 
Running time: O(1) amortized.

Kind: static method of [FibonacciHeap](#FibonacciHeap)

FibonacciHeap._cut() #
The reverse of the link operation: removes node from the child list of parent.
This method assumes that min is non-null. Running time: O(1).

Kind: static method of [FibonacciHeap](#FibonacciHeap)

FibonacciHeap._cascadingCut() #
Performs a cascading cut operation. This cuts node from its parent and then
does the same for its parent, and so on up the tree.
Running time: O(log n); O(1) excluding the recursion.

Kind: static method of [FibonacciHeap](#FibonacciHeap)

FibonacciHeap._linkNodes() #
Make the first node a child of the second one. Running time: O(1) actual.

Kind: static method of [FibonacciHeap](#FibonacciHeap)\n\n\n\nClass Reference #

This page lists all the various class types in Math.js. Every top-level function is listed here and links to its detailed reference to other parts of the documentation.

math #

The “math” namespace contains the entire math.js functionality. All of the mathematical functions are available in the “math” namespace, and allow for inputs of various types.


  Function reference
  Constant reference


Unit #

Stores values for a scalar unit and its postfix. (eg 100 mm or 100 kg). Although the Unit class contains public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  Overview
  Class API


Fraction #

Stores values for a fractional number.


  Overview
  Class API


BigNumber #

Stores values for a arbitrary-precision floating point number.


  Overview
  Class API


Matrix #

Two types of matrix classes are available in math.js, for storage of dense and sparse matrices. Although they contain public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  Overview
  DenseMatrix
  SparseMatrix


Classes used internally that may be of use to developers:


  Index
  Range
  ResultSet
  FibonacciHeap


Complex #

Stores values for a complex number.


  Overview
  Class API


Parser #

The Parser object returned by math.parser().


  Overview


Node #

A node in an expression-tree, which can be used to analyze, manipulate, and evaluate expressions.


  Overview


Node is the base class of all other node classes:


  AccessorNode
  ArrayNode
  AssignmentNode
  BlockNode
  ConditionalNode
  ConstantNode
  FunctionAssignmentNode
  FunctionNode
  IndexNode
  ObjectNode
  OperatorNode
  ParenthesisNode
  RangeNode
  SymbolNode\n\n\n\nClass Reference #

This page lists all the various class types in Math.js. Every top-level function is listed here and links to its detailed reference to other parts of the documentation.

math #

The “math” namespace contains the entire math.js functionality. All of the mathematical functions are available in the “math” namespace, and allow for inputs of various types.


  Function reference
  Constant reference


Unit #

Stores values for a scalar unit and its postfix. (eg 100 mm or 100 kg). Although the Unit class contains public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  Overview
  Class API


Fraction #

Stores values for a fractional number.


  Overview
  Class API


BigNumber #

Stores values for a arbitrary-precision floating point number.


  Overview
  Class API


Matrix #

Two types of matrix classes are available in math.js, for storage of dense and sparse matrices. Although they contain public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  Overview
  DenseMatrix
  SparseMatrix


Classes used internally that may be of use to developers:


  Index
  Range
  ResultSet
  FibonacciHeap


Complex #

Stores values for a complex number.


  Overview
  Class API


Parser #

The Parser object returned by math.parser().


  Overview


Node #

A node in an expression-tree, which can be used to analyze, manipulate, and evaluate expressions.


  Overview


Node is the base class of all other node classes:


  AccessorNode
  ArrayNode
  AssignmentNode
  BlockNode
  ConditionalNode
  ConstantNode
  FunctionAssignmentNode
  FunctionNode
  IndexNode
  ObjectNode
  OperatorNode
  ParenthesisNode
  RangeNode
  SymbolNode\n\n\n\nClass Reference #

This page lists all the various class types in Math.js. Every top-level function is listed here and links to its detailed reference to other parts of the documentation.

math #

The “math” namespace contains the entire math.js functionality. All of the mathematical functions are available in the “math” namespace, and allow for inputs of various types.


  Function reference
  Constant reference


Unit #

Stores values for a scalar unit and its postfix. (eg 100 mm or 100 kg). Although the Unit class contains public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  Overview
  Class API


Fraction #

Stores values for a fractional number.


  Overview
  Class API


BigNumber #

Stores values for a arbitrary-precision floating point number.


  Overview
  Class API


Matrix #

Two types of matrix classes are available in math.js, for storage of dense and sparse matrices. Although they contain public functions documented as follows, using the following API directly is not recommended. Prefer using the functions in the “math” namespace wherever possible.


  Overview
  DenseMatrix
  SparseMatrix


Classes used internally that may be of use to developers:


  Index
  Range
  ResultSet
  FibonacciHeap


Complex #

Stores values for a complex number.


  Overview
  Class API


Parser #

The Parser object returned by math.parser().


  Overview


Node #

A node in an expression-tree, which can be used to analyze, manipulate, and evaluate expressions.


  Overview


Node is the base class of all other node classes:


  AccessorNode
  ArrayNode
  AssignmentNode
  BlockNode
  ConditionalNode
  ConstantNode
  FunctionAssignmentNode
  FunctionNode
  IndexNode
  ObjectNode
  OperatorNode
  ParenthesisNode
  RangeNode
  SymbolNode\n\n\n\nFunction reference #

Expression functions #


  
    
      Function
      Description
    
  
  
    
      math.compile(expr)
      Parse and compile an expression.
    
    
      math.evaluate(expr [, scope])
      Evaluate an expression.
    
    
      math.help(search)
      Retrieve help on a function or data type.
    
    
      math.parser()
      Create a parser.
    
  


Algebra functions #


  
    
      Function
      Description
    
  
  
    
      math.derivative(expr, variable)
      Takes the derivative of an expression expressed in parser Nodes.
    
    
      math.leafCount(expr)
      Gives the number of “leaf nodes” in the parse tree of the given expression A leaf node is one that has no subexpressions, essentially either a symbol or a constant.
    
    
      math.lsolve(L, b)
      Finds one solution of a linear equation system by forwards substitution.
    
    
      math.lsolveAll(L, b)
      Finds all solutions of a linear equation system by forwards substitution.
    
    
      math.lup(A)
      Calculate the Matrix LU decomposition with partial pivoting.
    
    
      math.lusolve(A, b)
      Solves the linear system A * x = b where A is an [n x n] matrix and b is a [n] column vector.
    
    
      math.lyap(A, Q)
      Solves the Continuous-time Lyapunov equation AP+PA’+Q=0 for P, where Q is an input matrix.
    
    
      math.polynomialRoot(constant, linearCoeff, quadraticCoeff, cubicCoeff)
      Finds the numerical values of the distinct roots of a polynomial with real or complex coefficients.
    
    
      math.qr(A)
      Calculate the Matrix QR decomposition.
    
    
      math.rationalize(expr)
      Transform a rationalizable expression in a rational fraction.
    
    
      math.resolve(expr, scope)
      resolve(expr, scope) replaces variable nodes with their scoped values.
    
    
      math.schur(A)
      Performs a real Schur decomposition of the real matrix A = UTU’ where U is orthogonal and T is upper quasi-triangular.
    
    
      math.simplify(expr)
      Simplify an expression tree.
    
    
      math.simplifyConstant(expr)
      simplifyConstant() takes a mathjs expression (either a Node representing a parse tree or a string which it parses to produce a node), and replaces any subexpression of it consisting entirely of constants with the computed value of that subexpression.
    
    
      math.simplifyCore(expr)
      simplifyCore() performs single pass simplification suitable for applications requiring ultimate performance.
    
    
      math.slu(A, order, threshold)
      Calculate the Sparse Matrix LU decomposition with full pivoting.
    
    
      math.sylvester(A, B, C)
      Solves the real-valued Sylvester equation AX+XB=C for X, where A, B and C are matrices of appropriate dimensions, being A and B squared.
    
    
      math.symbolicEqual(expr1, expr2)
      Attempts to determine if two expressions are symbolically equal, i.
    
    
      math.usolve(U, b)
      Finds one solution of a linear equation system by backward substitution.
    
    
      math.usolveAll(U, b)
      Finds all solutions of a linear equation system by backward substitution.
    
  


Arithmetic functions #


  
    
      Function
      Description
    
  
  
    
      math.abs(x)
      Calculate the absolute value of a number.
    
    
      math.add(x, y)
      Add two or more values, x + y.
    
    
      math.cbrt(x [, allRoots])
      Calculate the cubic root of a value.
    
    
      math.ceil(x)
      Round a value towards plus infinity If x is complex, both real and imaginary part are rounded towards plus infinity.
    
    
      math.cube(x)
      Compute the cube of a value, x * x * x.
    
    
      math.divide(x, y)
      Divide two values, x / y.
    
    
      math.dotDivide(x, y)
      Divide two matrices element wise.
    
    
      math.dotMultiply(x, y)
      Multiply two matrices element wise.
    
    
      math.dotPow(x, y)
      Calculates the power of x to y element wise.
    
    
      math.exp(x)
      Calculate the exponential of a value.
    
    
      math.expm1(x)
      Calculate the value of subtracting 1 from the exponential value.
    
    
      math.fix(x)
      Round a value towards zero.
    
    
      math.floor(x)
      Round a value towards minus infinity.
    
    
      math.gcd(a, b)
      Calculate the greatest common divisor for two or more values or arrays.
    
    
      math.hypot(a, b, …)
      Calculate the hypotenuse of a list with values.
    
    
      math.invmod(a, b)
      Calculate the (modular) multiplicative inverse of a modulo b.
    
    
      math.lcm(a, b)
      Calculate the least common multiple for two or more values or arrays.
    
    
      math.log(x [, base])
      Calculate the logarithm of a value.
    
    
      math.log10(x)
      Calculate the 10-base logarithm of a value.
    
    
      math.log1p(x)
      Calculate the logarithm of a value+1.
    
    
      math.log2(x)
      Calculate the 2-base of a value.
    
    
      math.mod(x, y)
      Calculates the modulus, the remainder of an integer division.
    
    
      math.multiply(x, y)
      Multiply two or more values, x * y.
    
    
      math.norm(x [, p])
      Calculate the norm of a number, vector or matrix.
    
    
      math.nthRoot(a)
      Calculate the nth root of a value.
    
    
      math.nthRoots(x)
      Calculate the nth roots of a value.
    
    
      math.pow(x, y)
      Calculates the power of x to y, x ^ y.
    
    
      math.round(x [, n])
      Round a value towards the nearest rounded value.
    
    
      math.sign(x)
      Compute the sign of a value.
    
    
      math.sqrt(x)
      Calculate the square root of a value.
    
    
      math.square(x)
      Compute the square of a value, x * x.
    
    
      math.subtract(x, y)
      Subtract two values, x - y.
    
    
      math.unaryMinus(x)
      Inverse the sign of a value, apply a unary minus operation.
    
    
      math.unaryPlus(x)
      Unary plus operation.
    
    
      math.xgcd(a, b)
      Calculate the extended greatest common divisor for two values.
    
  


Bitwise functions #


  
    
      Function
      Description
    
  
  
    
      math.bitAnd(x, y)
      Bitwise AND two values, x & y.
    
    
      math.bitNot(x)
      Bitwise NOT value, ~x.
    
    
      math.bitOr(x, y)
      Bitwise OR two values, x | y.
    
    
      math.bitXor(x, y)
      Bitwise XOR two values, x ^ y.
    
    
      math.leftShift(x, y)
      Bitwise left logical shift of a value x by y number of bits, x << y.
    
    
      math.rightArithShift(x, y)
      Bitwise right arithmetic shift of a value x by y number of bits, x >> y.
    
    
      math.rightLogShift(x, y)
      Bitwise right logical shift of value x by y number of bits, x >>> y.
    
  


Combinatorics functions #


  
    
      Function
      Description
    
  
  
    
      math.bellNumbers(n)
      The Bell Numbers count the number of partitions of a set.
    
    
      math.catalan(n)
      The Catalan Numbers enumerate combinatorial structures of many different types.
    
    
      math.composition(n, k)
      The composition counts of n into k parts.
    
    
      math.stirlingS2(n, k)
      The Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets.
    
  


Complex functions #


  
    
      Function
      Description
    
  
  
    
      math.arg(x)
      Compute the argument of a complex value.
    
    
      math.conj(x)
      Compute the complex conjugate of a complex value.
    
    
      math.im(x)
      Get the imaginary part of a complex number.
    
    
      math.re(x)
      Get the real part of a complex number.
    
  


Geometry functions #


  
    
      Function
      Description
    
  
  
    
      math.distance([x1,y1], [x2,y2])
      Calculates:    The eucledian distance between two points in N-dimensional spaces.
    
    
      math.intersect(endPoint1Line1, endPoint2Line1, endPoint1Line2, endPoint2Line2)
      Calculates the point of intersection of two lines in two or three dimensions and of a line and a plane in three dimensions.
    
  


Logical functions #


  
    
      Function
      Description
    
  
  
    
      math.and(x, y)
      Logical and.
    
    
      math.not(x)
      Logical not.
    
    
      math.or(x, y)
      Logical or.
    
    
      math.xor(x, y)
      Logical xor.
    
  


Matrix functions #


  
    
      Function
      Description
    
  
  
    
      math.column(value, index)
      Return a column from a Matrix.
    
    
      math.concat(a, b, c, … [, dim])
      Concatenate two or more matrices.
    
    
      math.count(x)
      Count the number of elements of a matrix, array or string.
    
    
      math.cross(x, y)
      Calculate the cross product for two vectors in three dimensional space.
    
    
      math.ctranspose(x)
      Transpose and complex conjugate a matrix.
    
    
      math.det(x)
      Calculate the determinant of a matrix.
    
    
      math.diag(X)
      Create a diagonal matrix or retrieve the diagonal of a matrix  When x is a vector, a matrix with vector x on the diagonal will be returned.
    
    
      math.diff(arr)
      Create a new matrix or array of the difference between elements of the given array The optional dim parameter lets you specify the dimension to evaluate the difference of If no dimension parameter is passed it is assumed as dimension 0  Dimension is zero-based in javascript and one-based in the parser and can be a number or bignumber Arrays must be ‘rectangular’ meaning arrays like [1, 2] If something is passed as a matrix it will be returned as a matrix but other than that all matrices are converted to arrays.
    
    
      math.dot(x, y)
      Calculate the dot product of two vectors.
    
    
      math.eigs(x, [prec])
      Compute eigenvalues and optionally eigenvectors of a square matrix.
    
    
      math.expm(x)
      Compute the matrix exponential, expm(A) = e^A.
    
    
      math.fft(arr)
      Calculate N-dimensional Fourier transform.
    
    
      math.filter(x, test)
      Filter the items in an array or one dimensional matrix.
    
    
      math.flatten(x)
      Flatten a multidimensional matrix into a single dimensional matrix.
    
    
      math.forEach(x, callback)
      Iterate over all elements of a matrix/array, and executes the given callback function.
    
    
      math.getMatrixDataType(x)
      Find the data type of all elements in a matrix or array, for example ‘number’ if all items are a number and ‘Complex’ if all values are complex numbers.
    
    
      math.identity(n)
      Create a 2-dimensional identity matrix with size m x n or n x n.
    
    
      math.ifft(arr)
      Calculate N-dimensional inverse Fourier transform.
    
    
      math.inv(x)
      Calculate the inverse of a square matrix.
    
    
      math.kron(x, y)
      Calculates the Kronecker product of 2 matrices or vectors.
    
    
      math.map(x, callback)
      Create a new matrix or array with the results of a callback function executed on each entry of a given matrix/array.
    
    
      math.mapSlices(A, dim, callback)
      Apply a function that maps an array to a scalar along a given axis of a matrix or array.
    
    
      math.matrixFromColumns(…arr)
      Create a dense matrix from vectors as individual columns.
    
    
      math.matrixFromFunction(size, fn)
      Create a matrix by evaluating a generating function at each index.
    
    
      math.matrixFromRows(…arr)
      Create a dense matrix from vectors as individual rows.
    
    
      math.ones(m, n, p, …)
      Create a matrix filled with ones.
    
    
      math.partitionSelect(x, k)
      Partition-based selection of an array or 1D matrix.
    
    
      math.pinv(x)
      Calculate the Moore–Penrose inverse of a matrix.
    
    
      math.range(start, end [, step])
      Create an array from a range.
    
    
      math.reshape(x, sizes)
      Reshape a multi dimensional array to fit the specified dimensions.
    
    
      math.resize(x, size [, defaultValue])
      Resize a matrix.
    
    
      math.rotate(w, theta)
      Rotate a vector of size 1x2 counter-clockwise by a given angle Rotate a vector of size 1x3 counter-clockwise by a given angle around the given axis.
    
    
      math.rotationMatrix(theta)
      Create a 2-dimensional counter-clockwise rotation matrix (2x2) for a given angle (expressed in radians).
    
    
      math.row(value, index)
      Return a row from a Matrix.
    
    
      math.size(x)
      Calculate the size of a matrix or scalar.
    
    
      math.sort(x)
      Sort the items in a matrix.
    
    
      math.sqrtm(A)
      Calculate the principal square root of a square matrix.
    
    
      math.squeeze(x)
      Squeeze a matrix, remove inner and outer singleton dimensions from a matrix.
    
    
      math.subset(x, index [, replacement])
      Get or set a subset of a matrix or string.
    
    
      math.trace(x)
      Calculate the trace of a matrix: the sum of the elements on the main diagonal of a square matrix.
    
    
      math.transpose(x)
      Transpose a matrix.
    
    
      math.zeros(m, n, p, …)
      Create a matrix filled with zeros.
    
  


Numeric functions #


  
    
      Function
      Description
    
  
  
    
      math.solveODE(func, tspan, y0)
      Numerical Integration of Ordinary Differential Equations  Two variable step methods are provided: - “RK23”: Bogacki–Shampine method - “RK45”: Dormand-Prince method RK5(4)7M (default)  The arguments are expected as follows.
    
  


Probability functions #


  
    
      Function
      Description
    
  
  
    
      math.combinations(n, k)
      Compute the number of ways of picking k unordered outcomes from n possibilities.
    
    
      math.combinationsWithRep(n, k)
      Compute the number of ways of picking k unordered outcomes from n possibilities, allowing individual outcomes to be repeated more than once.
    
    
      math.factorial(n)
      Compute the factorial of a value  Factorial only supports an integer value as argument.
    
    
      math.gamma(n)
      Compute the gamma function of a value using Lanczos approximation for small values, and an extended Stirling approximation for large values.
    
    
      math.kldivergence(x, y)
      Calculate the Kullback-Leibler (KL) divergence  between two distributions.
    
    
      math.lgamma(n)
      Logarithm of the gamma function for real, positive numbers and complex numbers, using Lanczos approximation for numbers and Stirling series for complex numbers.
    
    
      math.multinomial(a)
      Multinomial Coefficients compute the number of ways of picking a1, a2, .
    
    
      math.permutations(n [, k])
      Compute the number of ways of obtaining an ordered subset of k elements from a set of n elements.
    
    
      math.pickRandom(array)
      Random pick one or more values from a one dimensional array.
    
    
      math.random([min, max])
      Return a random number larger or equal to min and smaller than max using a uniform distribution.
    
    
      math.randomInt([min, max])
      Return a random integer number larger or equal to min and smaller than max using a uniform distribution.
    
  


Relational functions #


  
    
      Function
      Description
    
  
  
    
      math.compare(x, y)
      Compare two values.
    
    
      math.compareNatural(x, y)
      Compare two values of any type in a deterministic, natural way.
    
    
      math.compareText(x, y)
      Compare two strings lexically.
    
    
      math.deepEqual(x, y)
      Test element wise whether two matrices are equal.
    
    
      math.equal(x, y)
      Test whether two values are equal.
    
    
      math.equalText(x, y)
      Check equality of two strings.
    
    
      math.larger(x, y)
      Test whether value x is larger than y.
    
    
      math.largerEq(x, y)
      Test whether value x is larger or equal to y.
    
    
      math.smaller(x, y)
      Test whether value x is smaller than y.
    
    
      math.smallerEq(x, y)
      Test whether value x is smaller or equal to y.
    
    
      math.unequal(x, y)
      Test whether two values are unequal.
    
  


Set functions #


  
    
      Function
      Description
    
  
  
    
      math.setCartesian(set1, set2)
      Create the cartesian product of two (multi)sets.
    
    
      math.setDifference(set1, set2)
      Create the difference of two (multi)sets: every element of set1, that is not the element of set2.
    
    
      math.setDistinct(set)
      Collect the distinct elements of a multiset.
    
    
      math.setIntersect(set1, set2)
      Create the intersection of two (multi)sets.
    
    
      math.setIsSubset(set1, set2)
      Check whether a (multi)set is a subset of another (multi)set.
    
    
      math.setMultiplicity(element, set)
      Count the multiplicity of an element in a multiset.
    
    
      math.setPowerset(set)
      Create the powerset of a (multi)set.
    
    
      math.setSize(set)
      Count the number of elements of a (multi)set.
    
    
      math.setSymDifference(set1, set2)
      Create the symmetric difference of two (multi)sets.
    
    
      math.setUnion(set1, set2)
      Create the union of two (multi)sets.
    
  


Signal functions #


  
    
      Function
      Description
    
  
  
    
      math.freqz(b, a)
      Calculates the frequency response of a filter given its numerator and denominator coefficients.
    
    
      math.zpk2tf(z, p, k)
      Compute the transfer function of a zero-pole-gain model.
    
  


Special functions #


  
    
      Function
      Description
    
  
  
    
      math.erf(x)
      Compute the erf function of a value using a rational Chebyshev approximations for different intervals of x.
    
    
      math.zeta(n)
      Compute the Riemann Zeta function of a value using an infinite series for all of the complex plane using Riemann’s Functional equation.
    
  


Statistics functions #


  
    
      Function
      Description
    
  
  
    
      math.corr(A, B)
      Compute the correlation coefficient of a two list with values, For matrices, the matrix correlation coefficient is calculated.
    
    
      math.cumsum(a, b, c, …)
      Compute the cumulative sum of a matrix or a list with values.
    
    
      math.mad(a, b, c, …)
      Compute the median absolute deviation of a matrix or a list with values.
    
    
      math.max(a, b, c, …)
      Compute the maximum value of a matrix or a  list with values.
    
    
      math.mean(a, b, c, …)
      Compute the mean value of matrix or a list with values.
    
    
      math.median(a, b, c, …)
      Compute the median of a matrix or a list with values.
    
    
      math.min(a, b, c, …)
      Compute the minimum value of a matrix or a  list of values.
    
    
      math.mode(a, b, c, …)
      Computes the mode of a set of numbers or a list with values(numbers or characters).
    
    
      math.prod(a, b, c, …)
      Compute the product of a matrix or a list with values.
    
    
      math.quantileSeq(A, prob[, sorted])
      Compute the prob order quantile of a matrix or a list with values.
    
    
      math.std(a, b, c, …)
      Compute the standard deviation of a matrix or a  list with values.
    
    
      math.sum(a, b, c, …)
      Compute the sum of a matrix or a list with values.
    
    
      math.variance(a, b, c, …)
      Compute the variance of a matrix or a  list with values.
    
  


String functions #


  
    
      Function
      Description
    
  
  
    
      math.bin(value)
      Format a number as binary.
    
    
      math.format(value [, precision])
      Format a value of any type into a string.
    
    
      math.hex(value)
      Format a number as hexadecimal.
    
    
      math.oct(value)
      Format a number as octal.
    
    
      math.print(template, values [, precision])
      Interpolate values into a string template.
    
  


Trigonometry functions #


  
    
      Function
      Description
    
  
  
    
      math.acos(x)
      Calculate the inverse cosine of a value.
    
    
      math.acosh(x)
      Calculate the hyperbolic arccos of a value, defined as acosh(x) = ln(sqrt(x^2 - 1) + x).
    
    
      math.acot(x)
      Calculate the inverse cotangent of a value, defined as acot(x) = atan(1/x).
    
    
      math.acoth(x)
      Calculate the inverse hyperbolic tangent of a value, defined as acoth(x) = atanh(1/x) = (ln((x+1)/x) + ln(x/(x-1))) / 2.
    
    
      math.acsc(x)
      Calculate the inverse cosecant of a value, defined as acsc(x) = asin(1/x).
    
    
      math.acsch(x)
      Calculate the inverse hyperbolic cosecant of a value, defined as acsch(x) = asinh(1/x) = ln(1/x + sqrt(1/x^2 + 1)).
    
    
      math.asec(x)
      Calculate the inverse secant of a value.
    
    
      math.asech(x)
      Calculate the hyperbolic arcsecant of a value, defined as asech(x) = acosh(1/x) = ln(sqrt(1/x^2 - 1) + 1/x).
    
    
      math.asin(x)
      Calculate the inverse sine of a value.
    
    
      math.asinh(x)
      Calculate the hyperbolic arcsine of a value, defined as asinh(x) = ln(x + sqrt(x^2 + 1)).
    
    
      math.atan(x)
      Calculate the inverse tangent of a value.
    
    
      math.atan2(y, x)
      Calculate the inverse tangent function with two arguments, y/x.
    
    
      math.atanh(x)
      Calculate the hyperbolic arctangent of a value, defined as atanh(x) = ln((1 + x)/(1 - x)) / 2.
    
    
      math.cos(x)
      Calculate the cosine of a value.
    
    
      math.cosh(x)
      Calculate the hyperbolic cosine of a value, defined as cosh(x) = 1/2 * (exp(x) + exp(-x)).
    
    
      math.cot(x)
      Calculate the cotangent of a value.
    
    
      math.coth(x)
      Calculate the hyperbolic cotangent of a value, defined as coth(x) = 1 / tanh(x).
    
    
      math.csc(x)
      Calculate the cosecant of a value, defined as csc(x) = 1/sin(x).
    
    
      math.csch(x)
      Calculate the hyperbolic cosecant of a value, defined as csch(x) = 1 / sinh(x).
    
    
      math.sec(x)
      Calculate the secant of a value, defined as sec(x) = 1/cos(x).
    
    
      math.sech(x)
      Calculate the hyperbolic secant of a value, defined as sech(x) = 1 / cosh(x).
    
    
      math.sin(x)
      Calculate the sine of a value.
    
    
      math.sinh(x)
      Calculate the hyperbolic sine of a value, defined as sinh(x) = 1/2 * (exp(x) - exp(-x)).
    
    
      math.tan(x)
      Calculate the tangent of a value.
    
    
      math.tanh(x)
      Calculate the hyperbolic tangent of a value, defined as tanh(x) = (exp(2 * x) - 1) / (exp(2 * x) + 1).
    
  


Unit functions #


  
    
      Function
      Description
    
  
  
    
      math.to(x, unit)
      Change the unit of a value.
    
  


Utils functions #


  
    
      Function
      Description
    
  
  
    
      math.clone(x)
      Clone an object.
    
    
      math.hasNumericValue(x)
      Test whether a value is an numeric value.
    
    
      math.isInteger(x)
      Test whether a value is an integer number.
    
    
      math.isNaN(x)
      Test whether a value is NaN (not a number).
    
    
      math.isNegative(x)
      Test whether a value is negative: smaller than zero.
    
    
      math.isNumeric(x)
      Test whether a value is an numeric value.
    
    
      math.isPositive(x)
      Test whether a value is positive: larger than zero.
    
    
      math.isPrime(x)
      Test whether a value is prime: has no divisors other than itself and one.
    
    
      math.isZero(x)
      Test whether a value is zero.
    
    
      math.numeric(x)
      Convert a numeric input to a specific numeric type: number, BigNumber, bigint, or Fraction.
    
    
      math.typeOf(x)
      Determine the type of an entity.\n\n\n\nFunction reference #

Expression functions #


  
    
      Function
      Description
    
  
  
    
      math.compile(expr)
      Parse and compile an expression.
    
    
      math.evaluate(expr [, scope])
      Evaluate an expression.
    
    
      math.help(search)
      Retrieve help on a function or data type.
    
    
      math.parser()
      Create a parser.
    
  


Algebra functions #


  
    
      Function
      Description
    
  
  
    
      math.derivative(expr, variable)
      Takes the derivative of an expression expressed in parser Nodes.
    
    
      math.leafCount(expr)
      Gives the number of “leaf nodes” in the parse tree of the given expression A leaf node is one that has no subexpressions, essentially either a symbol or a constant.
    
    
      math.lsolve(L, b)
      Finds one solution of a linear equation system by forwards substitution.
    
    
      math.lsolveAll(L, b)
      Finds all solutions of a linear equation system by forwards substitution.
    
    
      math.lup(A)
      Calculate the Matrix LU decomposition with partial pivoting.
    
    
      math.lusolve(A, b)
      Solves the linear system A * x = b where A is an [n x n] matrix and b is a [n] column vector.
    
    
      math.lyap(A, Q)
      Solves the Continuous-time Lyapunov equation AP+PA’+Q=0 for P, where Q is an input matrix.
    
    
      math.polynomialRoot(constant, linearCoeff, quadraticCoeff, cubicCoeff)
      Finds the numerical values of the distinct roots of a polynomial with real or complex coefficients.
    
    
      math.qr(A)
      Calculate the Matrix QR decomposition.
    
    
      math.rationalize(expr)
      Transform a rationalizable expression in a rational fraction.
    
    
      math.resolve(expr, scope)
      resolve(expr, scope) replaces variable nodes with their scoped values.
    
    
      math.schur(A)
      Performs a real Schur decomposition of the real matrix A = UTU’ where U is orthogonal and T is upper quasi-triangular.
    
    
      math.simplify(expr)
      Simplify an expression tree.
    
    
      math.simplifyConstant(expr)
      simplifyConstant() takes a mathjs expression (either a Node representing a parse tree or a string which it parses to produce a node), and replaces any subexpression of it consisting entirely of constants with the computed value of that subexpression.
    
    
      math.simplifyCore(expr)
      simplifyCore() performs single pass simplification suitable for applications requiring ultimate performance.
    
    
      math.slu(A, order, threshold)
      Calculate the Sparse Matrix LU decomposition with full pivoting.
    
    
      math.sylvester(A, B, C)
      Solves the real-valued Sylvester equation AX+XB=C for X, where A, B and C are matrices of appropriate dimensions, being A and B squared.
    
    
      math.symbolicEqual(expr1, expr2)
      Attempts to determine if two expressions are symbolically equal, i.
    
    
      math.usolve(U, b)
      Finds one solution of a linear equation system by backward substitution.
    
    
      math.usolveAll(U, b)
      Finds all solutions of a linear equation system by backward substitution.
    
  


Arithmetic functions #


  
    
      Function
      Description
    
  
  
    
      math.abs(x)
      Calculate the absolute value of a number.
    
    
      math.add(x, y)
      Add two or more values, x + y.
    
    
      math.cbrt(x [, allRoots])
      Calculate the cubic root of a value.
    
    
      math.ceil(x)
      Round a value towards plus infinity If x is complex, both real and imaginary part are rounded towards plus infinity.
    
    
      math.cube(x)
      Compute the cube of a value, x * x * x.
    
    
      math.divide(x, y)
      Divide two values, x / y.
    
    
      math.dotDivide(x, y)
      Divide two matrices element wise.
    
    
      math.dotMultiply(x, y)
      Multiply two matrices element wise.
    
    
      math.dotPow(x, y)
      Calculates the power of x to y element wise.
    
    
      math.exp(x)
      Calculate the exponential of a value.
    
    
      math.expm1(x)
      Calculate the value of subtracting 1 from the exponential value.
    
    
      math.fix(x)
      Round a value towards zero.
    
    
      math.floor(x)
      Round a value towards minus infinity.
    
    
      math.gcd(a, b)
      Calculate the greatest common divisor for two or more values or arrays.
    
    
      math.hypot(a, b, …)
      Calculate the hypotenuse of a list with values.
    
    
      math.invmod(a, b)
      Calculate the (modular) multiplicative inverse of a modulo b.
    
    
      math.lcm(a, b)
      Calculate the least common multiple for two or more values or arrays.
    
    
      math.log(x [, base])
      Calculate the logarithm of a value.
    
    
      math.log10(x)
      Calculate the 10-base logarithm of a value.
    
    
      math.log1p(x)
      Calculate the logarithm of a value+1.
    
    
      math.log2(x)
      Calculate the 2-base of a value.
    
    
      math.mod(x, y)
      Calculates the modulus, the remainder of an integer division.
    
    
      math.multiply(x, y)
      Multiply two or more values, x * y.
    
    
      math.norm(x [, p])
      Calculate the norm of a number, vector or matrix.
    
    
      math.nthRoot(a)
      Calculate the nth root of a value.
    
    
      math.nthRoots(x)
      Calculate the nth roots of a value.
    
    
      math.pow(x, y)
      Calculates the power of x to y, x ^ y.
    
    
      math.round(x [, n])
      Round a value towards the nearest rounded value.
    
    
      math.sign(x)
      Compute the sign of a value.
    
    
      math.sqrt(x)
      Calculate the square root of a value.
    
    
      math.square(x)
      Compute the square of a value, x * x.
    
    
      math.subtract(x, y)
      Subtract two values, x - y.
    
    
      math.unaryMinus(x)
      Inverse the sign of a value, apply a unary minus operation.
    
    
      math.unaryPlus(x)
      Unary plus operation.
    
    
      math.xgcd(a, b)
      Calculate the extended greatest common divisor for two values.
    
  


Bitwise functions #


  
    
      Function
      Description
    
  
  
    
      math.bitAnd(x, y)
      Bitwise AND two values, x & y.
    
    
      math.bitNot(x)
      Bitwise NOT value, ~x.
    
    
      math.bitOr(x, y)
      Bitwise OR two values, x | y.
    
    
      math.bitXor(x, y)
      Bitwise XOR two values, x ^ y.
    
    
      math.leftShift(x, y)
      Bitwise left logical shift of a value x by y number of bits, x << y.
    
    
      math.rightArithShift(x, y)
      Bitwise right arithmetic shift of a value x by y number of bits, x >> y.
    
    
      math.rightLogShift(x, y)
      Bitwise right logical shift of value x by y number of bits, x >>> y.
    
  


Combinatorics functions #


  
    
      Function
      Description
    
  
  
    
      math.bellNumbers(n)
      The Bell Numbers count the number of partitions of a set.
    
    
      math.catalan(n)
      The Catalan Numbers enumerate combinatorial structures of many different types.
    
    
      math.composition(n, k)
      The composition counts of n into k parts.
    
    
      math.stirlingS2(n, k)
      The Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets.
    
  


Complex functions #


  
    
      Function
      Description
    
  
  
    
      math.arg(x)
      Compute the argument of a complex value.
    
    
      math.conj(x)
      Compute the complex conjugate of a complex value.
    
    
      math.im(x)
      Get the imaginary part of a complex number.
    
    
      math.re(x)
      Get the real part of a complex number.
    
  


Geometry functions #


  
    
      Function
      Description
    
  
  
    
      math.distance([x1,y1], [x2,y2])
      Calculates:    The eucledian distance between two points in N-dimensional spaces.
    
    
      math.intersect(endPoint1Line1, endPoint2Line1, endPoint1Line2, endPoint2Line2)
      Calculates the point of intersection of two lines in two or three dimensions and of a line and a plane in three dimensions.
    
  


Logical functions #


  
    
      Function
      Description
    
  
  
    
      math.and(x, y)
      Logical and.
    
    
      math.not(x)
      Logical not.
    
    
      math.or(x, y)
      Logical or.
    
    
      math.xor(x, y)
      Logical xor.
    
  


Matrix functions #


  
    
      Function
      Description
    
  
  
    
      math.column(value, index)
      Return a column from a Matrix.
    
    
      math.concat(a, b, c, … [, dim])
      Concatenate two or more matrices.
    
    
      math.count(x)
      Count the number of elements of a matrix, array or string.
    
    
      math.cross(x, y)
      Calculate the cross product for two vectors in three dimensional space.
    
    
      math.ctranspose(x)
      Transpose and complex conjugate a matrix.
    
    
      math.det(x)
      Calculate the determinant of a matrix.
    
    
      math.diag(X)
      Create a diagonal matrix or retrieve the diagonal of a matrix  When x is a vector, a matrix with vector x on the diagonal will be returned.
    
    
      math.diff(arr)
      Create a new matrix or array of the difference between elements of the given array The optional dim parameter lets you specify the dimension to evaluate the difference of If no dimension parameter is passed it is assumed as dimension 0  Dimension is zero-based in javascript and one-based in the parser and can be a number or bignumber Arrays must be ‘rectangular’ meaning arrays like [1, 2] If something is passed as a matrix it will be returned as a matrix but other than that all matrices are converted to arrays.
    
    
      math.dot(x, y)
      Calculate the dot product of two vectors.
    
    
      math.eigs(x, [prec])
      Compute eigenvalues and optionally eigenvectors of a square matrix.
    
    
      math.expm(x)
      Compute the matrix exponential, expm(A) = e^A.
    
    
      math.fft(arr)
      Calculate N-dimensional Fourier transform.
    
    
      math.filter(x, test)
      Filter the items in an array or one dimensional matrix.
    
    
      math.flatten(x)
      Flatten a multidimensional matrix into a single dimensional matrix.
    
    
      math.forEach(x, callback)
      Iterate over all elements of a matrix/array, and executes the given callback function.
    
    
      math.getMatrixDataType(x)
      Find the data type of all elements in a matrix or array, for example ‘number’ if all items are a number and ‘Complex’ if all values are complex numbers.
    
    
      math.identity(n)
      Create a 2-dimensional identity matrix with size m x n or n x n.
    
    
      math.ifft(arr)
      Calculate N-dimensional inverse Fourier transform.
    
    
      math.inv(x)
      Calculate the inverse of a square matrix.
    
    
      math.kron(x, y)
      Calculates the Kronecker product of 2 matrices or vectors.
    
    
      math.map(x, callback)
      Create a new matrix or array with the results of a callback function executed on each entry of a given matrix/array.
    
    
      math.mapSlices(A, dim, callback)
      Apply a function that maps an array to a scalar along a given axis of a matrix or array.
    
    
      math.matrixFromColumns(…arr)
      Create a dense matrix from vectors as individual columns.
    
    
      math.matrixFromFunction(size, fn)
      Create a matrix by evaluating a generating function at each index.
    
    
      math.matrixFromRows(…arr)
      Create a dense matrix from vectors as individual rows.
    
    
      math.ones(m, n, p, …)
      Create a matrix filled with ones.
    
    
      math.partitionSelect(x, k)
      Partition-based selection of an array or 1D matrix.
    
    
      math.pinv(x)
      Calculate the Moore–Penrose inverse of a matrix.
    
    
      math.range(start, end [, step])
      Create an array from a range.
    
    
      math.reshape(x, sizes)
      Reshape a multi dimensional array to fit the specified dimensions.
    
    
      math.resize(x, size [, defaultValue])
      Resize a matrix.
    
    
      math.rotate(w, theta)
      Rotate a vector of size 1x2 counter-clockwise by a given angle Rotate a vector of size 1x3 counter-clockwise by a given angle around the given axis.
    
    
      math.rotationMatrix(theta)
      Create a 2-dimensional counter-clockwise rotation matrix (2x2) for a given angle (expressed in radians).
    
    
      math.row(value, index)
      Return a row from a Matrix.
    
    
      math.size(x)
      Calculate the size of a matrix or scalar.
    
    
      math.sort(x)
      Sort the items in a matrix.
    
    
      math.sqrtm(A)
      Calculate the principal square root of a square matrix.
    
    
      math.squeeze(x)
      Squeeze a matrix, remove inner and outer singleton dimensions from a matrix.
    
    
      math.subset(x, index [, replacement])
      Get or set a subset of a matrix or string.
    
    
      math.trace(x)
      Calculate the trace of a matrix: the sum of the elements on the main diagonal of a square matrix.
    
    
      math.transpose(x)
      Transpose a matrix.
    
    
      math.zeros(m, n, p, …)
      Create a matrix filled with zeros.
    
  


Numeric functions #


  
    
      Function
      Description
    
  
  
    
      math.solveODE(func, tspan, y0)
      Numerical Integration of Ordinary Differential Equations  Two variable step methods are provided: - “RK23”: Bogacki–Shampine method - “RK45”: Dormand-Prince method RK5(4)7M (default)  The arguments are expected as follows.
    
  


Probability functions #


  
    
      Function
      Description
    
  
  
    
      math.combinations(n, k)
      Compute the number of ways of picking k unordered outcomes from n possibilities.
    
    
      math.combinationsWithRep(n, k)
      Compute the number of ways of picking k unordered outcomes from n possibilities, allowing individual outcomes to be repeated more than once.
    
    
      math.factorial(n)
      Compute the factorial of a value  Factorial only supports an integer value as argument.
    
    
      math.gamma(n)
      Compute the gamma function of a value using Lanczos approximation for small values, and an extended Stirling approximation for large values.
    
    
      math.kldivergence(x, y)
      Calculate the Kullback-Leibler (KL) divergence  between two distributions.
    
    
      math.lgamma(n)
      Logarithm of the gamma function for real, positive numbers and complex numbers, using Lanczos approximation for numbers and Stirling series for complex numbers.
    
    
      math.multinomial(a)
      Multinomial Coefficients compute the number of ways of picking a1, a2, .
    
    
      math.permutations(n [, k])
      Compute the number of ways of obtaining an ordered subset of k elements from a set of n elements.
    
    
      math.pickRandom(array)
      Random pick one or more values from a one dimensional array.
    
    
      math.random([min, max])
      Return a random number larger or equal to min and smaller than max using a uniform distribution.
    
    
      math.randomInt([min, max])
      Return a random integer number larger or equal to min and smaller than max using a uniform distribution.
    
  


Relational functions #


  
    
      Function
      Description
    
  
  
    
      math.compare(x, y)
      Compare two values.
    
    
      math.compareNatural(x, y)
      Compare two values of any type in a deterministic, natural way.
    
    
      math.compareText(x, y)
      Compare two strings lexically.
    
    
      math.deepEqual(x, y)
      Test element wise whether two matrices are equal.
    
    
      math.equal(x, y)
      Test whether two values are equal.
    
    
      math.equalText(x, y)
      Check equality of two strings.
    
    
      math.larger(x, y)
      Test whether value x is larger than y.
    
    
      math.largerEq(x, y)
      Test whether value x is larger or equal to y.
    
    
      math.smaller(x, y)
      Test whether value x is smaller than y.
    
    
      math.smallerEq(x, y)
      Test whether value x is smaller or equal to y.
    
    
      math.unequal(x, y)
      Test whether two values are unequal.
    
  


Set functions #


  
    
      Function
      Description
    
  
  
    
      math.setCartesian(set1, set2)
      Create the cartesian product of two (multi)sets.
    
    
      math.setDifference(set1, set2)
      Create the difference of two (multi)sets: every element of set1, that is not the element of set2.
    
    
      math.setDistinct(set)
      Collect the distinct elements of a multiset.
    
    
      math.setIntersect(set1, set2)
      Create the intersection of two (multi)sets.
    
    
      math.setIsSubset(set1, set2)
      Check whether a (multi)set is a subset of another (multi)set.
    
    
      math.setMultiplicity(element, set)
      Count the multiplicity of an element in a multiset.
    
    
      math.setPowerset(set)
      Create the powerset of a (multi)set.
    
    
      math.setSize(set)
      Count the number of elements of a (multi)set.
    
    
      math.setSymDifference(set1, set2)
      Create the symmetric difference of two (multi)sets.
    
    
      math.setUnion(set1, set2)
      Create the union of two (multi)sets.
    
  


Signal functions #


  
    
      Function
      Description
    
  
  
    
      math.freqz(b, a)
      Calculates the frequency response of a filter given its numerator and denominator coefficients.
    
    
      math.zpk2tf(z, p, k)
      Compute the transfer function of a zero-pole-gain model.
    
  


Special functions #


  
    
      Function
      Description
    
  
  
    
      math.erf(x)
      Compute the erf function of a value using a rational Chebyshev approximations for different intervals of x.
    
    
      math.zeta(n)
      Compute the Riemann Zeta function of a value using an infinite series for all of the complex plane using Riemann’s Functional equation.
    
  


Statistics functions #


  
    
      Function
      Description
    
  
  
    
      math.corr(A, B)
      Compute the correlation coefficient of a two list with values, For matrices, the matrix correlation coefficient is calculated.
    
    
      math.cumsum(a, b, c, …)
      Compute the cumulative sum of a matrix or a list with values.
    
    
      math.mad(a, b, c, …)
      Compute the median absolute deviation of a matrix or a list with values.
    
    
      math.max(a, b, c, …)
      Compute the maximum value of a matrix or a  list with values.
    
    
      math.mean(a, b, c, …)
      Compute the mean value of matrix or a list with values.
    
    
      math.median(a, b, c, …)
      Compute the median of a matrix or a list with values.
    
    
      math.min(a, b, c, …)
      Compute the minimum value of a matrix or a  list of values.
    
    
      math.mode(a, b, c, …)
      Computes the mode of a set of numbers or a list with values(numbers or characters).
    
    
      math.prod(a, b, c, …)
      Compute the product of a matrix or a list with values.
    
    
      math.quantileSeq(A, prob[, sorted])
      Compute the prob order quantile of a matrix or a list with values.
    
    
      math.std(a, b, c, …)
      Compute the standard deviation of a matrix or a  list with values.
    
    
      math.sum(a, b, c, …)
      Compute the sum of a matrix or a list with values.
    
    
      math.variance(a, b, c, …)
      Compute the variance of a matrix or a  list with values.
    
  


String functions #


  
    
      Function
      Description
    
  
  
    
      math.bin(value)
      Format a number as binary.
    
    
      math.format(value [, precision])
      Format a value of any type into a string.
    
    
      math.hex(value)
      Format a number as hexadecimal.
    
    
      math.oct(value)
      Format a number as octal.
    
    
      math.print(template, values [, precision])
      Interpolate values into a string template.
    
  


Trigonometry functions #


  
    
      Function
      Description
    
  
  
    
      math.acos(x)
      Calculate the inverse cosine of a value.
    
    
      math.acosh(x)
      Calculate the hyperbolic arccos of a value, defined as acosh(x) = ln(sqrt(x^2 - 1) + x).
    
    
      math.acot(x)
      Calculate the inverse cotangent of a value, defined as acot(x) = atan(1/x).
    
    
      math.acoth(x)
      Calculate the inverse hyperbolic tangent of a value, defined as acoth(x) = atanh(1/x) = (ln((x+1)/x) + ln(x/(x-1))) / 2.
    
    
      math.acsc(x)
      Calculate the inverse cosecant of a value, defined as acsc(x) = asin(1/x).
    
    
      math.acsch(x)
      Calculate the inverse hyperbolic cosecant of a value, defined as acsch(x) = asinh(1/x) = ln(1/x + sqrt(1/x^2 + 1)).
    
    
      math.asec(x)
      Calculate the inverse secant of a value.
    
    
      math.asech(x)
      Calculate the hyperbolic arcsecant of a value, defined as asech(x) = acosh(1/x) = ln(sqrt(1/x^2 - 1) + 1/x).
    
    
      math.asin(x)
      Calculate the inverse sine of a value.
    
    
      math.asinh(x)
      Calculate the hyperbolic arcsine of a value, defined as asinh(x) = ln(x + sqrt(x^2 + 1)).
    
    
      math.atan(x)
      Calculate the inverse tangent of a value.
    
    
      math.atan2(y, x)
      Calculate the inverse tangent function with two arguments, y/x.
    
    
      math.atanh(x)
      Calculate the hyperbolic arctangent of a value, defined as atanh(x) = ln((1 + x)/(1 - x)) / 2.
    
    
      math.cos(x)
      Calculate the cosine of a value.
    
    
      math.cosh(x)
      Calculate the hyperbolic cosine of a value, defined as cosh(x) = 1/2 * (exp(x) + exp(-x)).
    
    
      math.cot(x)
      Calculate the cotangent of a value.
    
    
      math.coth(x)
      Calculate the hyperbolic cotangent of a value, defined as coth(x) = 1 / tanh(x).
    
    
      math.csc(x)
      Calculate the cosecant of a value, defined as csc(x) = 1/sin(x).
    
    
      math.csch(x)
      Calculate the hyperbolic cosecant of a value, defined as csch(x) = 1 / sinh(x).
    
    
      math.sec(x)
      Calculate the secant of a value, defined as sec(x) = 1/cos(x).
    
    
      math.sech(x)
      Calculate the hyperbolic secant of a value, defined as sech(x) = 1 / cosh(x).
    
    
      math.sin(x)
      Calculate the sine of a value.
    
    
      math.sinh(x)
      Calculate the hyperbolic sine of a value, defined as sinh(x) = 1/2 * (exp(x) - exp(-x)).
    
    
      math.tan(x)
      Calculate the tangent of a value.
    
    
      math.tanh(x)
      Calculate the hyperbolic tangent of a value, defined as tanh(x) = (exp(2 * x) - 1) / (exp(2 * x) + 1).
    
  


Unit functions #


  
    
      Function
      Description
    
  
  
    
      math.to(x, unit)
      Change the unit of a value.
    
  


Utils functions #


  
    
      Function
      Description
    
  
  
    
      math.clone(x)
      Clone an object.
    
    
      math.hasNumericValue(x)
      Test whether a value is an numeric value.
    
    
      math.isInteger(x)
      Test whether a value is an integer number.
    
    
      math.isNaN(x)
      Test whether a value is NaN (not a number).
    
    
      math.isNegative(x)
      Test whether a value is negative: smaller than zero.
    
    
      math.isNumeric(x)
      Test whether a value is an numeric value.
    
    
      math.isPositive(x)
      Test whether a value is positive: larger than zero.
    
    
      math.isPrime(x)
      Test whether a value is prime: has no divisors other than itself and one.
    
    
      math.isZero(x)
      Test whether a value is zero.
    
    
      math.numeric(x)
      Convert a numeric input to a specific numeric type: number, BigNumber, bigint, or Fraction.
    
    
      math.typeOf(x)
      Determine the type of an entity.\n\n\n\nFunction compile #

Parse and compile an expression.
Returns a an object with a function evaluate([scope]) to evaluate the
compiled expression.

Syntax #

math.compile(expr)                       // returns one node
math.compile([expr1, expr2, expr3, ...]) // returns an array with nodes


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      expr
      string | string[] | Array | Matrix
      The expression to be compiled
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      {evaluate: Function} | Array.<{evaluate: Function}>
      code An object with the compiled expression
    
  


Throws #


  
    
      Type
      Description
    
  
  
    
      Error
       
    
  


Examples #

const code1 = math.compile('sqrt(3^2 + 4^2)')
code1.evaluate() // 5

let scope = {a: 3, b: 4}
const code2 = math.compile('a * b') // 12
code2.evaluate(scope) // 12
scope.a = 5
code2.evaluate(scope) // 20

const nodes = math.compile(['a = 3', 'b = 4', 'a * b'])
nodes[2].evaluate() // 12


See also #

parse,
evaluate\n\n\n\nFunction evaluate #

Evaluate an expression.

The expression parser does not use JavaScript. Its syntax is close
to JavaScript but more suited for mathematical expressions.
See https://mathjs.org/docs/expressions/syntax.html to learn
the syntax and get an overview of the exact differences from JavaScript.

Note the evaluating arbitrary expressions may involve security risks,
see https://mathjs.org/docs/expressions/security.html for more information.

Syntax #

math.evaluate(expr)
math.evaluate(expr, scope)
math.evaluate([expr1, expr2, expr3, ...])
math.evaluate([expr1, expr2, expr3, ...], scope)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      expr
      string | string[] | Matrix
      The expression to be evaluated
    
    
      scope
      Object
      Scope to read/write variables
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      *
      The result of the expression
    
  


Throws #


  
    
      Type
      Description
    
  
  
    
      Error
       
    
  


Examples #

math.evaluate('(2+3)/4')                // 1.25
math.evaluate('sqrt(3^2 + 4^2)')        // 5
math.evaluate('sqrt(-4)')               // 2i
math.evaluate(['a=3', 'b=4', 'a*b'])    // [3, 4, 12]

let scope = {a:3, b:4}
math.evaluate('a * b', scope)           // 12


See also #

parse,
compile\n\n\n\nFunction help #

Retrieve help on a function or data type.
Help files are retrieved from the embedded documentation in math.docs.

Syntax #

math.help(search)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      search
      Function | string | Object
      A function or function name for which to get help
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      Help
      A help object
    
  


Throws #

Type | Description
—- | ———–

Examples #

console.log(math.help('sin').toString())
console.log(math.help(math.add).toString())
console.log(math.help(math.add).toJSON())\n\n\n\nFunction parser #

Create a parser. The function creates a new math.Parser object.

Syntax #

math.parser()


Parameters #

Parameter | Type | Description
——— | —- | ———–

Returns #


  
    
      Type
      Description
    
  
  
    
      Parser
      Parser
    
  


Throws #

Type | Description
—- | ———–

Examples #

const parser = new math.parser()

// evaluate expressions
const a = parser.evaluate('sqrt(3^2 + 4^2)') // 5
const b = parser.evaluate('sqrt(-4)')        // 2i
const c = parser.evaluate('2 inch in cm')    // 5.08 cm
const d = parser.evaluate('cos(45 deg)')     // 0.7071067811865476

// define variables and functions
parser.evaluate('x = 7 / 2')             // 3.5
parser.evaluate('x + 3')                 // 6.5
parser.evaluate('f(x, y) = x^y')         // f(x, y)
parser.evaluate('f(2, 3)')               // 8

// get and set variables and functions
const x = parser.get('x')                // 3.5
const f = parser.get('f')                // function
const g = f(3, 2)                        // 9
parser.set('h', 500)
const i = parser.evaluate('h / 2')       // 250
parser.set('hello', function (name) {
  return 'hello, ' + name + '!'
})
parser.evaluate('hello("user")')         // "hello, user!"

// clear defined functions and variables
parser.clear()


See also #

evaluate,
compile,
parse\n\n\n\nFunction reference #

Expression functions #


  
    
      Function
      Description
    
  
  
    
      math.compile(expr)
      Parse and compile an expression.
    
    
      math.evaluate(expr [, scope])
      Evaluate an expression.
    
    
      math.help(search)
      Retrieve help on a function or data type.
    
    
      math.parser()
      Create a parser.
    
  


Algebra functions #


  
    
      Function
      Description
    
  
  
    
      math.derivative(expr, variable)
      Takes the derivative of an expression expressed in parser Nodes.
    
    
      math.leafCount(expr)
      Gives the number of “leaf nodes” in the parse tree of the given expression A leaf node is one that has no subexpressions, essentially either a symbol or a constant.
    
    
      math.lsolve(L, b)
      Finds one solution of a linear equation system by forwards substitution.
    
    
      math.lsolveAll(L, b)
      Finds all solutions of a linear equation system by forwards substitution.
    
    
      math.lup(A)
      Calculate the Matrix LU decomposition with partial pivoting.
    
    
      math.lusolve(A, b)
      Solves the linear system A * x = b where A is an [n x n] matrix and b is a [n] column vector.
    
    
      math.lyap(A, Q)
      Solves the Continuous-time Lyapunov equation AP+PA’+Q=0 for P, where Q is an input matrix.
    
    
      math.polynomialRoot(constant, linearCoeff, quadraticCoeff, cubicCoeff)
      Finds the numerical values of the distinct roots of a polynomial with real or complex coefficients.
    
    
      math.qr(A)
      Calculate the Matrix QR decomposition.
    
    
      math.rationalize(expr)
      Transform a rationalizable expression in a rational fraction.
    
    
      math.resolve(expr, scope)
      resolve(expr, scope) replaces variable nodes with their scoped values.
    
    
      math.schur(A)
      Performs a real Schur decomposition of the real matrix A = UTU’ where U is orthogonal and T is upper quasi-triangular.
    
    
      math.simplify(expr)
      Simplify an expression tree.
    
    
      math.simplifyConstant(expr)
      simplifyConstant() takes a mathjs expression (either a Node representing a parse tree or a string which it parses to produce a node), and replaces any subexpression of it consisting entirely of constants with the computed value of that subexpression.
    
    
      math.simplifyCore(expr)
      simplifyCore() performs single pass simplification suitable for applications requiring ultimate performance.
    
    
      math.slu(A, order, threshold)
      Calculate the Sparse Matrix LU decomposition with full pivoting.
    
    
      math.sylvester(A, B, C)
      Solves the real-valued Sylvester equation AX+XB=C for X, where A, B and C are matrices of appropriate dimensions, being A and B squared.
    
    
      math.symbolicEqual(expr1, expr2)
      Attempts to determine if two expressions are symbolically equal, i.
    
    
      math.usolve(U, b)
      Finds one solution of a linear equation system by backward substitution.
    
    
      math.usolveAll(U, b)
      Finds all solutions of a linear equation system by backward substitution.
    
  


Arithmetic functions #


  
    
      Function
      Description
    
  
  
    
      math.abs(x)
      Calculate the absolute value of a number.
    
    
      math.add(x, y)
      Add two or more values, x + y.
    
    
      math.cbrt(x [, allRoots])
      Calculate the cubic root of a value.
    
    
      math.ceil(x)
      Round a value towards plus infinity If x is complex, both real and imaginary part are rounded towards plus infinity.
    
    
      math.cube(x)
      Compute the cube of a value, x * x * x.
    
    
      math.divide(x, y)
      Divide two values, x / y.
    
    
      math.dotDivide(x, y)
      Divide two matrices element wise.
    
    
      math.dotMultiply(x, y)
      Multiply two matrices element wise.
    
    
      math.dotPow(x, y)
      Calculates the power of x to y element wise.
    
    
      math.exp(x)
      Calculate the exponential of a value.
    
    
      math.expm1(x)
      Calculate the value of subtracting 1 from the exponential value.
    
    
      math.fix(x)
      Round a value towards zero.
    
    
      math.floor(x)
      Round a value towards minus infinity.
    
    
      math.gcd(a, b)
      Calculate the greatest common divisor for two or more values or arrays.
    
    
      math.hypot(a, b, …)
      Calculate the hypotenuse of a list with values.
    
    
      math.invmod(a, b)
      Calculate the (modular) multiplicative inverse of a modulo b.
    
    
      math.lcm(a, b)
      Calculate the least common multiple for two or more values or arrays.
    
    
      math.log(x [, base])
      Calculate the logarithm of a value.
    
    
      math.log10(x)
      Calculate the 10-base logarithm of a value.
    
    
      math.log1p(x)
      Calculate the logarithm of a value+1.
    
    
      math.log2(x)
      Calculate the 2-base of a value.
    
    
      math.mod(x, y)
      Calculates the modulus, the remainder of an integer division.
    
    
      math.multiply(x, y)
      Multiply two or more values, x * y.
    
    
      math.norm(x [, p])
      Calculate the norm of a number, vector or matrix.
    
    
      math.nthRoot(a)
      Calculate the nth root of a value.
    
    
      math.nthRoots(x)
      Calculate the nth roots of a value.
    
    
      math.pow(x, y)
      Calculates the power of x to y, x ^ y.
    
    
      math.round(x [, n])
      Round a value towards the nearest rounded value.
    
    
      math.sign(x)
      Compute the sign of a value.
    
    
      math.sqrt(x)
      Calculate the square root of a value.
    
    
      math.square(x)
      Compute the square of a value, x * x.
    
    
      math.subtract(x, y)
      Subtract two values, x - y.
    
    
      math.unaryMinus(x)
      Inverse the sign of a value, apply a unary minus operation.
    
    
      math.unaryPlus(x)
      Unary plus operation.
    
    
      math.xgcd(a, b)
      Calculate the extended greatest common divisor for two values.
    
  


Bitwise functions #


  
    
      Function
      Description
    
  
  
    
      math.bitAnd(x, y)
      Bitwise AND two values, x & y.
    
    
      math.bitNot(x)
      Bitwise NOT value, ~x.
    
    
      math.bitOr(x, y)
      Bitwise OR two values, x | y.
    
    
      math.bitXor(x, y)
      Bitwise XOR two values, x ^ y.
    
    
      math.leftShift(x, y)
      Bitwise left logical shift of a value x by y number of bits, x << y.
    
    
      math.rightArithShift(x, y)
      Bitwise right arithmetic shift of a value x by y number of bits, x >> y.
    
    
      math.rightLogShift(x, y)
      Bitwise right logical shift of value x by y number of bits, x >>> y.
    
  


Combinatorics functions #


  
    
      Function
      Description
    
  
  
    
      math.bellNumbers(n)
      The Bell Numbers count the number of partitions of a set.
    
    
      math.catalan(n)
      The Catalan Numbers enumerate combinatorial structures of many different types.
    
    
      math.composition(n, k)
      The composition counts of n into k parts.
    
    
      math.stirlingS2(n, k)
      The Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets.
    
  


Complex functions #


  
    
      Function
      Description
    
  
  
    
      math.arg(x)
      Compute the argument of a complex value.
    
    
      math.conj(x)
      Compute the complex conjugate of a complex value.
    
    
      math.im(x)
      Get the imaginary part of a complex number.
    
    
      math.re(x)
      Get the real part of a complex number.
    
  


Geometry functions #


  
    
      Function
      Description
    
  
  
    
      math.distance([x1,y1], [x2,y2])
      Calculates:    The eucledian distance between two points in N-dimensional spaces.
    
    
      math.intersect(endPoint1Line1, endPoint2Line1, endPoint1Line2, endPoint2Line2)
      Calculates the point of intersection of two lines in two or three dimensions and of a line and a plane in three dimensions.
    
  


Logical functions #


  
    
      Function
      Description
    
  
  
    
      math.and(x, y)
      Logical and.
    
    
      math.not(x)
      Logical not.
    
    
      math.or(x, y)
      Logical or.
    
    
      math.xor(x, y)
      Logical xor.
    
  


Matrix functions #


  
    
      Function
      Description
    
  
  
    
      math.column(value, index)
      Return a column from a Matrix.
    
    
      math.concat(a, b, c, … [, dim])
      Concatenate two or more matrices.
    
    
      math.count(x)
      Count the number of elements of a matrix, array or string.
    
    
      math.cross(x, y)
      Calculate the cross product for two vectors in three dimensional space.
    
    
      math.ctranspose(x)
      Transpose and complex conjugate a matrix.
    
    
      math.det(x)
      Calculate the determinant of a matrix.
    
    
      math.diag(X)
      Create a diagonal matrix or retrieve the diagonal of a matrix  When x is a vector, a matrix with vector x on the diagonal will be returned.
    
    
      math.diff(arr)
      Create a new matrix or array of the difference between elements of the given array The optional dim parameter lets you specify the dimension to evaluate the difference of If no dimension parameter is passed it is assumed as dimension 0  Dimension is zero-based in javascript and one-based in the parser and can be a number or bignumber Arrays must be ‘rectangular’ meaning arrays like [1, 2] If something is passed as a matrix it will be returned as a matrix but other than that all matrices are converted to arrays.
    
    
      math.dot(x, y)
      Calculate the dot product of two vectors.
    
    
      math.eigs(x, [prec])
      Compute eigenvalues and optionally eigenvectors of a square matrix.
    
    
      math.expm(x)
      Compute the matrix exponential, expm(A) = e^A.
    
    
      math.fft(arr)
      Calculate N-dimensional Fourier transform.
    
    
      math.filter(x, test)
      Filter the items in an array or one dimensional matrix.
    
    
      math.flatten(x)
      Flatten a multidimensional matrix into a single dimensional matrix.
    
    
      math.forEach(x, callback)
      Iterate over all elements of a matrix/array, and executes the given callback function.
    
    
      math.getMatrixDataType(x)
      Find the data type of all elements in a matrix or array, for example ‘number’ if all items are a number and ‘Complex’ if all values are complex numbers.
    
    
      math.identity(n)
      Create a 2-dimensional identity matrix with size m x n or n x n.
    
    
      math.ifft(arr)
      Calculate N-dimensional inverse Fourier transform.
    
    
      math.inv(x)
      Calculate the inverse of a square matrix.
    
    
      math.kron(x, y)
      Calculates the Kronecker product of 2 matrices or vectors.
    
    
      math.map(x, callback)
      Create a new matrix or array with the results of a callback function executed on each entry of a given matrix/array.
    
    
      math.mapSlices(A, dim, callback)
      Apply a function that maps an array to a scalar along a given axis of a matrix or array.
    
    
      math.matrixFromColumns(…arr)
      Create a dense matrix from vectors as individual columns.
    
    
      math.matrixFromFunction(size, fn)
      Create a matrix by evaluating a generating function at each index.
    
    
      math.matrixFromRows(…arr)
      Create a dense matrix from vectors as individual rows.
    
    
      math.ones(m, n, p, …)
      Create a matrix filled with ones.
    
    
      math.partitionSelect(x, k)
      Partition-based selection of an array or 1D matrix.
    
    
      math.pinv(x)
      Calculate the Moore–Penrose inverse of a matrix.
    
    
      math.range(start, end [, step])
      Create an array from a range.
    
    
      math.reshape(x, sizes)
      Reshape a multi dimensional array to fit the specified dimensions.
    
    
      math.resize(x, size [, defaultValue])
      Resize a matrix.
    
    
      math.rotate(w, theta)
      Rotate a vector of size 1x2 counter-clockwise by a given angle Rotate a vector of size 1x3 counter-clockwise by a given angle around the given axis.
    
    
      math.rotationMatrix(theta)
      Create a 2-dimensional counter-clockwise rotation matrix (2x2) for a given angle (expressed in radians).
    
    
      math.row(value, index)
      Return a row from a Matrix.
    
    
      math.size(x)
      Calculate the size of a matrix or scalar.
    
    
      math.sort(x)
      Sort the items in a matrix.
    
    
      math.sqrtm(A)
      Calculate the principal square root of a square matrix.
    
    
      math.squeeze(x)
      Squeeze a matrix, remove inner and outer singleton dimensions from a matrix.
    
    
      math.subset(x, index [, replacement])
      Get or set a subset of a matrix or string.
    
    
      math.trace(x)
      Calculate the trace of a matrix: the sum of the elements on the main diagonal of a square matrix.
    
    
      math.transpose(x)
      Transpose a matrix.
    
    
      math.zeros(m, n, p, …)
      Create a matrix filled with zeros.
    
  


Numeric functions #


  
    
      Function
      Description
    
  
  
    
      math.solveODE(func, tspan, y0)
      Numerical Integration of Ordinary Differential Equations  Two variable step methods are provided: - “RK23”: Bogacki–Shampine method - “RK45”: Dormand-Prince method RK5(4)7M (default)  The arguments are expected as follows.
    
  


Probability functions #


  
    
      Function
      Description
    
  
  
    
      math.combinations(n, k)
      Compute the number of ways of picking k unordered outcomes from n possibilities.
    
    
      math.combinationsWithRep(n, k)
      Compute the number of ways of picking k unordered outcomes from n possibilities, allowing individual outcomes to be repeated more than once.
    
    
      math.factorial(n)
      Compute the factorial of a value  Factorial only supports an integer value as argument.
    
    
      math.gamma(n)
      Compute the gamma function of a value using Lanczos approximation for small values, and an extended Stirling approximation for large values.
    
    
      math.kldivergence(x, y)
      Calculate the Kullback-Leibler (KL) divergence  between two distributions.
    
    
      math.lgamma(n)
      Logarithm of the gamma function for real, positive numbers and complex numbers, using Lanczos approximation for numbers and Stirling series for complex numbers.
    
    
      math.multinomial(a)
      Multinomial Coefficients compute the number of ways of picking a1, a2, .
    
    
      math.permutations(n [, k])
      Compute the number of ways of obtaining an ordered subset of k elements from a set of n elements.
    
    
      math.pickRandom(array)
      Random pick one or more values from a one dimensional array.
    
    
      math.random([min, max])
      Return a random number larger or equal to min and smaller than max using a uniform distribution.
    
    
      math.randomInt([min, max])
      Return a random integer number larger or equal to min and smaller than max using a uniform distribution.
    
  


Relational functions #


  
    
      Function
      Description
    
  
  
    
      math.compare(x, y)
      Compare two values.
    
    
      math.compareNatural(x, y)
      Compare two values of any type in a deterministic, natural way.
    
    
      math.compareText(x, y)
      Compare two strings lexically.
    
    
      math.deepEqual(x, y)
      Test element wise whether two matrices are equal.
    
    
      math.equal(x, y)
      Test whether two values are equal.
    
    
      math.equalText(x, y)
      Check equality of two strings.
    
    
      math.larger(x, y)
      Test whether value x is larger than y.
    
    
      math.largerEq(x, y)
      Test whether value x is larger or equal to y.
    
    
      math.smaller(x, y)
      Test whether value x is smaller than y.
    
    
      math.smallerEq(x, y)
      Test whether value x is smaller or equal to y.
    
    
      math.unequal(x, y)
      Test whether two values are unequal.
    
  


Set functions #


  
    
      Function
      Description
    
  
  
    
      math.setCartesian(set1, set2)
      Create the cartesian product of two (multi)sets.
    
    
      math.setDifference(set1, set2)
      Create the difference of two (multi)sets: every element of set1, that is not the element of set2.
    
    
      math.setDistinct(set)
      Collect the distinct elements of a multiset.
    
    
      math.setIntersect(set1, set2)
      Create the intersection of two (multi)sets.
    
    
      math.setIsSubset(set1, set2)
      Check whether a (multi)set is a subset of another (multi)set.
    
    
      math.setMultiplicity(element, set)
      Count the multiplicity of an element in a multiset.
    
    
      math.setPowerset(set)
      Create the powerset of a (multi)set.
    
    
      math.setSize(set)
      Count the number of elements of a (multi)set.
    
    
      math.setSymDifference(set1, set2)
      Create the symmetric difference of two (multi)sets.
    
    
      math.setUnion(set1, set2)
      Create the union of two (multi)sets.
    
  


Signal functions #


  
    
      Function
      Description
    
  
  
    
      math.freqz(b, a)
      Calculates the frequency response of a filter given its numerator and denominator coefficients.
    
    
      math.zpk2tf(z, p, k)
      Compute the transfer function of a zero-pole-gain model.
    
  


Special functions #


  
    
      Function
      Description
    
  
  
    
      math.erf(x)
      Compute the erf function of a value using a rational Chebyshev approximations for different intervals of x.
    
    
      math.zeta(n)
      Compute the Riemann Zeta function of a value using an infinite series for all of the complex plane using Riemann’s Functional equation.
    
  


Statistics functions #


  
    
      Function
      Description
    
  
  
    
      math.corr(A, B)
      Compute the correlation coefficient of a two list with values, For matrices, the matrix correlation coefficient is calculated.
    
    
      math.cumsum(a, b, c, …)
      Compute the cumulative sum of a matrix or a list with values.
    
    
      math.mad(a, b, c, …)
      Compute the median absolute deviation of a matrix or a list with values.
    
    
      math.max(a, b, c, …)
      Compute the maximum value of a matrix or a  list with values.
    
    
      math.mean(a, b, c, …)
      Compute the mean value of matrix or a list with values.
    
    
      math.median(a, b, c, …)
      Compute the median of a matrix or a list with values.
    
    
      math.min(a, b, c, …)
      Compute the minimum value of a matrix or a  list of values.
    
    
      math.mode(a, b, c, …)
      Computes the mode of a set of numbers or a list with values(numbers or characters).
    
    
      math.prod(a, b, c, …)
      Compute the product of a matrix or a list with values.
    
    
      math.quantileSeq(A, prob[, sorted])
      Compute the prob order quantile of a matrix or a list with values.
    
    
      math.std(a, b, c, …)
      Compute the standard deviation of a matrix or a  list with values.
    
    
      math.sum(a, b, c, …)
      Compute the sum of a matrix or a list with values.
    
    
      math.variance(a, b, c, …)
      Compute the variance of a matrix or a  list with values.
    
  


String functions #


  
    
      Function
      Description
    
  
  
    
      math.bin(value)
      Format a number as binary.
    
    
      math.format(value [, precision])
      Format a value of any type into a string.
    
    
      math.hex(value)
      Format a number as hexadecimal.
    
    
      math.oct(value)
      Format a number as octal.
    
    
      math.print(template, values [, precision])
      Interpolate values into a string template.
    
  


Trigonometry functions #


  
    
      Function
      Description
    
  
  
    
      math.acos(x)
      Calculate the inverse cosine of a value.
    
    
      math.acosh(x)
      Calculate the hyperbolic arccos of a value, defined as acosh(x) = ln(sqrt(x^2 - 1) + x).
    
    
      math.acot(x)
      Calculate the inverse cotangent of a value, defined as acot(x) = atan(1/x).
    
    
      math.acoth(x)
      Calculate the inverse hyperbolic tangent of a value, defined as acoth(x) = atanh(1/x) = (ln((x+1)/x) + ln(x/(x-1))) / 2.
    
    
      math.acsc(x)
      Calculate the inverse cosecant of a value, defined as acsc(x) = asin(1/x).
    
    
      math.acsch(x)
      Calculate the inverse hyperbolic cosecant of a value, defined as acsch(x) = asinh(1/x) = ln(1/x + sqrt(1/x^2 + 1)).
    
    
      math.asec(x)
      Calculate the inverse secant of a value.
    
    
      math.asech(x)
      Calculate the hyperbolic arcsecant of a value, defined as asech(x) = acosh(1/x) = ln(sqrt(1/x^2 - 1) + 1/x).
    
    
      math.asin(x)
      Calculate the inverse sine of a value.
    
    
      math.asinh(x)
      Calculate the hyperbolic arcsine of a value, defined as asinh(x) = ln(x + sqrt(x^2 + 1)).
    
    
      math.atan(x)
      Calculate the inverse tangent of a value.
    
    
      math.atan2(y, x)
      Calculate the inverse tangent function with two arguments, y/x.
    
    
      math.atanh(x)
      Calculate the hyperbolic arctangent of a value, defined as atanh(x) = ln((1 + x)/(1 - x)) / 2.
    
    
      math.cos(x)
      Calculate the cosine of a value.
    
    
      math.cosh(x)
      Calculate the hyperbolic cosine of a value, defined as cosh(x) = 1/2 * (exp(x) + exp(-x)).
    
    
      math.cot(x)
      Calculate the cotangent of a value.
    
    
      math.coth(x)
      Calculate the hyperbolic cotangent of a value, defined as coth(x) = 1 / tanh(x).
    
    
      math.csc(x)
      Calculate the cosecant of a value, defined as csc(x) = 1/sin(x).
    
    
      math.csch(x)
      Calculate the hyperbolic cosecant of a value, defined as csch(x) = 1 / sinh(x).
    
    
      math.sec(x)
      Calculate the secant of a value, defined as sec(x) = 1/cos(x).
    
    
      math.sech(x)
      Calculate the hyperbolic secant of a value, defined as sech(x) = 1 / cosh(x).
    
    
      math.sin(x)
      Calculate the sine of a value.
    
    
      math.sinh(x)
      Calculate the hyperbolic sine of a value, defined as sinh(x) = 1/2 * (exp(x) - exp(-x)).
    
    
      math.tan(x)
      Calculate the tangent of a value.
    
    
      math.tanh(x)
      Calculate the hyperbolic tangent of a value, defined as tanh(x) = (exp(2 * x) - 1) / (exp(2 * x) + 1).
    
  


Unit functions #


  
    
      Function
      Description
    
  
  
    
      math.to(x, unit)
      Change the unit of a value.
    
  


Utils functions #


  
    
      Function
      Description
    
  
  
    
      math.clone(x)
      Clone an object.
    
    
      math.hasNumericValue(x)
      Test whether a value is an numeric value.
    
    
      math.isInteger(x)
      Test whether a value is an integer number.
    
    
      math.isNaN(x)
      Test whether a value is NaN (not a number).
    
    
      math.isNegative(x)
      Test whether a value is negative: smaller than zero.
    
    
      math.isNumeric(x)
      Test whether a value is an numeric value.
    
    
      math.isPositive(x)
      Test whether a value is positive: larger than zero.
    
    
      math.isPrime(x)
      Test whether a value is prime: has no divisors other than itself and one.
    
    
      math.isZero(x)
      Test whether a value is zero.
    
    
      math.numeric(x)
      Convert a numeric input to a specific numeric type: number, BigNumber, bigint, or Fraction.
    
    
      math.typeOf(x)
      Determine the type of an entity.\n\n\n\nFunction leafCount #

Gives the number of “leaf nodes” in the parse tree of the given expression
A leaf node is one that has no subexpressions, essentially either a
symbol or a constant. Note that 5! has just one leaf, the ‘5’; the
unary factorial operator does not add a leaf. On the other hand,
function symbols do add leaves, so sin(x)/cos(x) has four leaves.

The simplify() function should generally not increase the leafCount()
of an expression, although currently there is no guarantee that it never
does so. In many cases, simplify() reduces the leaf count.

Syntax #

math.leafCount(expr)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      expr
      Node | string
      The expression to count the leaves of
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      number
      The number of leaves of expr
    
  


Throws #

Type | Description
—- | ———–

Examples #

math.leafCount('x') // 1
math.leafCount(math.parse('a*d-b*c')) // 4
math.leafCount('[a,b;c,d][0,1]') // 6


See also #

simplify\n\n\n\nFunction lsolve #

Finds one solution of a linear equation system by forwards substitution. Matrix must be a lower triangular matrix. Throws an error if there’s no solution.

L * x = b

Syntax #

math.lsolve(L, b)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      L
      Matrix, Array
      A N x N matrix or array (L)
    
    
      b
      Matrix, Array
      A column vector with the b values
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      DenseMatrix | Array
      A column vector with the linear system solution (x)
    
  


Throws #

Type | Description
—- | ———–

Examples #

const a = [[-2, 3], [2, 1]]
const b = [11, 9]
const x = lsolve(a, b)  // [[-5.5], [20]]


See also #

lsolveAll,
lup,
slu,
usolve,
lusolve\n\n\n\nFunction lsolveAll #

Finds all solutions of a linear equation system by forwards substitution. Matrix must be a lower triangular matrix.

L * x = b

Syntax #

math.lsolveAll(L, b)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      L
      Matrix, Array
      A N x N matrix or array (L)
    
    
      b
      Matrix, Array
      A column vector with the b values
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      DenseMatrix[] | Array[]
      An array of affine-independent column vectors (x) that solve the linear system
    
  


Throws #

Type | Description
—- | ———–

Examples #

const a = [[-2, 3], [2, 1]]
const b = [11, 9]
const x = lsolveAll(a, b)  // [ [[-5.5], [20]] ]


See also #

lsolve,
lup,
slu,
usolve,
lusolve\n\n\n\nFunction lup #

Calculate the Matrix LU decomposition with partial pivoting. Matrix A is decomposed in two matrices (L, U) and a
row permutation vector p where A[p,:] = L * U

Syntax #

math.lup(A)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      A
      Matrix | Array
      A two dimensional matrix or array for which to get the LUP decomposition.
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      {L: Array | Matrix, U: Array | Matrix, P: Array.<number>}
      The lower triangular matrix, the upper triangular matrix and the permutation matrix.
    
  


Throws #

Type | Description
—- | ———–

Examples #

const m = [[2, 1], [1, 4]]
const r = math.lup(m)
// r = {
//   L: [[1, 0], [0.5, 1]],
//   U: [[2, 1], [0, 3.5]],
//   P: [0, 1]
// }


See also #

slu,
lsolve,
lusolve,
usolve\n\n\n\nFunction lusolve #

Solves the linear system A * x = b where A is an [n x n] matrix and b is a [n] column vector.

Syntax #

math.lusolve(A, b)     // returns column vector with the solution to the linear system A * x = b
math.lusolve(lup, b)   // returns column vector with the solution to the linear system A * x = b, lup = math.lup(A)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      A
      Matrix | Array | Object
      Invertible Matrix or the Matrix LU decomposition
    
    
      b
      Matrix | Array
      Column Vector
    
    
      order
      number
      The Symbolic Ordering and Analysis order, see slu for details. Matrix must be a SparseMatrix
    
    
      threshold
      Number
      Partial pivoting threshold (1 for partial pivoting), see slu for details. Matrix must be a SparseMatrix.
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      DenseMatrix | Array
      Column vector with the solution to the linear system A * x = b
    
  


Throws #

Type | Description
—- | ———–

Examples #

const m = [[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]]

const x = math.lusolve(m, [-1, -1, -1, -1])        // x = [[-1], [-0.5], [-1/3], [-0.25]]

const f = math.lup(m)
const x1 = math.lusolve(f, [-1, -1, -1, -1])       // x1 = [[-1], [-0.5], [-1/3], [-0.25]]
const x2 = math.lusolve(f, [1, 2, 1, -1])          // x2 = [[1], [1], [1/3], [-0.25]]

const a = [[-2, 3], [2, 1]]
const b = [11, 9]
const x = math.lusolve(a, b)  // [[2], [5]]


See also #

lup,
slu,
lsolve,
usolve\n\n\n\nFunction lyap #

Solves the Continuous-time Lyapunov equation AP+PA’+Q=0 for P, where
Q is an input matrix. When Q is symmetric, P is also symmetric. Notice
that different equivalent definitions exist for the Continuous-time
Lyapunov equation.
https://en.wikipedia.org/wiki/Lyapunov_equation

Syntax #

math.lyap(A, Q)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      A
      Matrix | Array
      Matrix A
    
    
      Q
      Matrix | Array
      Matrix Q
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      Matrix | Array
      Matrix P solution to the Continuous-time Lyapunov equation AP+PA’=Q
    
  


Throws #

Type | Description
—- | ———–

Examples #

const A = [[-2, 0], [1, -4]]
const Q = [[3, 1], [1, 3]]
const P = math.lyap(A, Q)


See also #

sylvester,
schur\n\n\n\nFunction polynomialRoot #

Finds the numerical values of the distinct roots of a polynomial with real or complex coefficients.
Currently operates only on linear, quadratic, and cubic polynomials using the standard
formulas for the roots.

Syntax #

math.polynomialRoot(constant, linearCoeff, quadraticCoeff, cubicCoeff)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      coeffs
      … number | Complex
      The coefficients of the polynomial, starting with with the constant coefficent, followed by the linear coefficient and subsequent coefficients of increasing powers.
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      Array
      The distinct roots of the polynomial
    
  


Throws #

Type | Description
—- | ———–

Examples #

// linear
math.polynomialRoot(6, 3)                                        // [-2]
math.polynomialRoot(math.complex(6,3), 3)                        // [-2 - i]
math.polynomialRoot(math.complex(6,3), math.complex(2,1))        // [-3 + 0i]
// quadratic
math.polynomialRoot(2, -3, 1)                                    // [2, 1]
math.polynomialRoot(8, 8, 2)                                     // [-2]
math.polynomialRoot(-2, 0, 1)                                    // [1.4142135623730951, -1.4142135623730951]
math.polynomialRoot(2, -2, 1)                                    // [1 + i, 1 - i]
math.polynomialRoot(math.complex(1,3), math.complex(-3, -2), 1)  // [2 + i, 1 + i]
// cubic
math.polynomialRoot(-6, 11, -6, 1)                               // [1, 3, 2]
math.polynomialRoot(-8, 0, 0, 1)                                 // [-1 - 1.7320508075688774i, 2, -1 + 1.7320508075688774i]
math.polynomialRoot(0, 8, 8, 2)                                  // [0, -2]
math.polynomialRoot(1, 1, 1, 1)                                  // [-1 + 0i, 0 - i, 0 + i]


See also #

cbrt,
sqrt\n\n\n\nFunction qr #

Calculate the Matrix QR decomposition. Matrix A is decomposed in
two matrices (Q, R) where Q is an
orthogonal matrix and R is an upper triangular matrix.

Syntax #

math.qr(A)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      A
      Matrix | Array
      A two dimensional matrix or array for which to get the QR decomposition.
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      {Q: Array | Matrix, R: Array | Matrix}
      Q: the orthogonal matrix and R: the upper triangular matrix
    
  


Throws #

Type | Description
—- | ———–

Examples #

const m = [
  [1, -1,  4],
  [1,  4, -2],
  [1,  4,  2],
  [1,  -1, 0]
]
const result = math.qr(m)
// r = {
//   Q: [
//     [0.5, -0.5,   0.5],
//     [0.5,  0.5,  -0.5],
//     [0.5,  0.5,   0.5],
//     [0.5, -0.5,  -0.5],
//   ],
//   R: [
//     [2, 3,  2],
//     [0, 5, -2],
//     [0, 0,  4],
//     [0, 0,  0]
//   ]
// }


See also #

lup,
lusolve\n\n\n\nFunction resolve #

resolve(expr, scope) replaces variable nodes with their scoped values

Syntax #

math.resolve(expr, scope)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      node
      Node | Node[]
      The expression tree (or trees) to be simplified
    
    
      scope
      Object
      Scope specifying variables to be resolved
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      Node | Node[]
      Returns node with variables recursively substituted.
    
  


Throws #


  
    
      Type
      Description
    
  
  
    
      ReferenceError
      If there is a cyclic dependency among the variables in scope, resolution is impossible and a ReferenceError is thrown.
    
  


Examples #

math.resolve('x + y', {x:1, y:2})           // Node '1 + 2'
math.resolve(math.parse('x+y'), {x:1, y:2}) // Node '1 + 2'
math.simplify('x+y', {x:2, y: math.parse('x+x')}).toString() // "6"


See also #

simplify,
evaluate\n\n\n\nFunction schur #

Performs a real Schur decomposition of the real matrix A = UTU’ where U is orthogonal
and T is upper quasi-triangular.
https://en.wikipedia.org/wiki/Schur_decomposition

Syntax #

math.schur(A)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      A
      Array | Matrix
      Matrix A
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      {U: Array | Matrix, T: Array | Matrix}
      Object containing both matrix U and T of the Schur Decomposition A=UTU’
    
  


Throws #

Type | Description
—- | ———–

Examples #

const A = [[1, 0], [-4, 3]]
math.schur(A) // returns {T: [[3, 4], [0, 1]], R: [[0, 1], [-1, 0]]}


See also #

sylvester,
lyap,
qr\n\n\n\nFunction simplifyConstant #

simplifyConstant() takes a mathjs expression (either a Node representing
a parse tree or a string which it parses to produce a node), and replaces
any subexpression of it consisting entirely of constants with the computed
value of that subexpression.

Syntax #

math.simplifyConstant(expr)
math.simplifyConstant(expr, options)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      node
      Node | string
      The expression to be simplified
    
    
      options
      Object
      Simplification options, as per simplify()
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      Node
      Returns expression with constant subexpressions evaluated
    
  


Throws #

Type | Description
—- | ———–

Examples #

math.simplifyConstant('x + 4*3/6')  // Node "x + 2"
math.simplifyConstant('z cos(0)')   // Node "z 1"
math.simplifyConstant('(5.2 + 1.08)t', {exactFractions: false})  // Node "6.28 t"


See also #

simplify,
simplifyCore,
resolve,
derivative\n\n\n\nFunction simplifyCore #

simplifyCore() performs single pass simplification suitable for
applications requiring ultimate performance. To roughly summarize,
it handles cases along the lines of simplifyConstant() but where
knowledge of a single argument is sufficient to determine the value.
In contrast, simplify() extends simplifyCore() with additional passes
to provide deeper simplification (such as gathering like terms).

Specifically, simplifyCore:


  Converts all function calls with operator equivalents to their
operator forms.
  Removes operators or function calls that are guaranteed to have no
effect (such as unary ‘+’).
  Removes double unary ‘-‘, ‘~’, and ‘not’
  Eliminates addition/subtraction of 0 and multiplication/division/powers
by 1 or 0.
  Converts addition of a negation into subtraction.
  Eliminates logical operations with constant true or false leading
arguments.
  Puts constants on the left of a product, if multiplication is
considered commutative by the options (which is the default)


Syntax #

math.simplifyCore(expr)
math.simplifyCore(expr, options)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      node
      Node | string
      The expression to be simplified
    
    
      options
      Object
      Simplification options, as per simplify()
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      Node
      Returns expression with basic simplifications applied
    
  


Throws #

Type | Description
—- | ———–

Examples #

const f = math.parse('2 * 1 * x ^ (1 - 0)')
math.simplifyCore(f)                          // Node "2 * x"
math.simplify('2 * 1 * x ^ (1 - 0)', [math.simplifyCore]) // Node "2 * x"


See also #

simplify,
simplifyConstant,
resolve,
derivative\n\n\n\nFunction slu #

Calculate the Sparse Matrix LU decomposition with full pivoting. Sparse Matrix A is decomposed in two matrices (L, U) and two permutation vectors (pinv, q) where

P * A * Q = L * U

Syntax #

math.slu(A, order, threshold)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      A
      SparseMatrix
      A two dimensional sparse matrix for which to get the LU decomposition.
    
    
      order
      Number
      The Symbolic Ordering and Analysis order: 0 - Natural ordering, no permutation vector q is returned 1 - Matrix must be square, symbolic ordering and analisis is performed on M = A + A’ 2 - Symbolic ordering and analisis is performed on M = A’ * A. Dense columns from A’ are dropped, A recreated from A’. This is appropriatefor LU factorization of unsymmetric matrices. 3 - Symbolic ordering and analisis is performed on M = A’ * A. This is best used for LU factorization is matrix M has no dense rows. A dense row is a row with more than 10*sqr(columns) entries.
    
    
      threshold
      Number
      Partial pivoting threshold (1 for partial pivoting)
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      Object
      The lower triangular matrix, the upper triangular matrix and the permutation vectors.
    
  


Throws #

Type | Description
—- | ———–

Examples #

const A = math.sparse([[4,3], [6, 3]])
math.slu(A, 1, 0.001)
// returns:
// {
//   L: [[1, 0], [1.5, 1]]
//   U: [[4, 3], [0, -1.5]]
//   p: [0, 1]
//   q: [0, 1]
// }


See also #

lup,
lsolve,
usolve,
lusolve\n\n\n\nFunction sylvester #

Solves the real-valued Sylvester equation AX+XB=C for X, where A, B and C are
matrices of appropriate dimensions, being A and B squared. Notice that other
equivalent definitions for the Sylvester equation exist and this function
assumes the one presented in the original publication of the the Bartels-
Stewart algorithm, which is implemented by this function.
https://en.wikipedia.org/wiki/Sylvester_equation

Syntax #

math.sylvester(A, B, C)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      A
      Matrix | Array
      Matrix A
    
    
      B
      Matrix | Array
      Matrix B
    
    
      C
      Matrix | Array
      Matrix C
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      Matrix | Array
      Matrix X, solving the Sylvester equation
    
  


Throws #

Type | Description
—- | ———–

Examples #

const A = [[-1, -2], [1, 1]]
const B = [[2, -1], [1, -2]]
const C = [[-3, 2], [3, 0]]
math.sylvester(A, B, C)      // returns DenseMatrix [[-0.25, 0.25], [1.5, -1.25]]


See also #

schur,
lyap\n\n\n\nFunction symbolicEqual #

Attempts to determine if two expressions are symbolically equal, i.e.
one is the result of valid algebraic manipulations on the other.
Currently, this simply checks if the difference of the two expressions
simplifies down to 0. So there are two important caveats:

  whether two expressions are symbolically equal depends on the
 manipulations allowed. Therefore, this function takes an optional
 third argument, which are the options that control the behavior
 as documented for the simplify() function.
  it is in general intractable to find the minimal simplification of
 an arbitrarily complicated expression. So while a true value
 of symbolicEqual ensures that the two expressions can be manipulated
 to match each other, a false value does not absolutely rule this out.


Syntax #

math.symbolicEqual(expr1, expr2)
math.symbolicEqual(expr1, expr2, options)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      expr1
      Node | string
      The first expression to compare
    
    
      expr2
      Node | string
      The second expression to compare
    
    
      options
      Object
      Optional option object, passed to simplify
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      boolean
      Returns true if a valid manipulation making the expressions equal is found.
    
  


Throws #

Type | Description
—- | ———–

Examples #

math.symbolicEqual('x*y', 'y*x') // Returns true
math.symbolicEqual('x*y', 'y*x', {context: {multiply: {commutative: false}}}) // Returns false
math.symbolicEqual('x/y', '(y*x^(-1))^(-1)') // Returns true
math.symbolicEqual('abs(x)','x') // Returns false
math.symbolicEqual('abs(x)','x', simplify.positiveContext) // Returns true


See also #

simplify,
evaluate\n\n\n\nFunction usolve #

Finds one solution of a linear equation system by backward substitution. Matrix must be an upper triangular matrix. Throws an error if there’s no solution.

U * x = b

Syntax #

math.usolve(U, b)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      U
      Matrix, Array
      A N x N matrix or array (U)
    
    
      b
      Matrix, Array
      A column vector with the b values
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      DenseMatrix | Array
      A column vector with the linear system solution (x)
    
  


Throws #

Type | Description
—- | ———–

Examples #

const a = [[-2, 3], [2, 1]]
const b = [11, 9]
const x = usolve(a, b)  // [[8], [9]]


See also #

usolveAll,
lup,
slu,
usolve,
lusolve\n\n\n\nFunction usolveAll #

Finds all solutions of a linear equation system by backward substitution. Matrix must be an upper triangular matrix.

U * x = b

Syntax #

math.usolveAll(U, b)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      U
      Matrix, Array
      A N x N matrix or array (U)
    
    
      b
      Matrix, Array
      A column vector with the b values
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      DenseMatrix[] | Array[]
      An array of affine-independent column vectors (x) that solve the linear system
    
  


Throws #

Type | Description
—- | ———–

Examples #

const a = [[-2, 3], [2, 1]]
const b = [11, 9]
const x = usolveAll(a, b)  // [ [[8], [9]] ]


See also #

usolve,
lup,
slu,
usolve,
lusolve\n\n\n\nFunction reference #

Expression functions #


  
    
      Function
      Description
    
  
  
    
      math.compile(expr)
      Parse and compile an expression.
    
    
      math.evaluate(expr [, scope])
      Evaluate an expression.
    
    
      math.help(search)
      Retrieve help on a function or data type.
    
    
      math.parser()
      Create a parser.
    
  


Algebra functions #


  
    
      Function
      Description
    
  
  
    
      math.derivative(expr, variable)
      Takes the derivative of an expression expressed in parser Nodes.
    
    
      math.leafCount(expr)
      Gives the number of “leaf nodes” in the parse tree of the given expression A leaf node is one that has no subexpressions, essentially either a symbol or a constant.
    
    
      math.lsolve(L, b)
      Finds one solution of a linear equation system by forwards substitution.
    
    
      math.lsolveAll(L, b)
      Finds all solutions of a linear equation system by forwards substitution.
    
    
      math.lup(A)
      Calculate the Matrix LU decomposition with partial pivoting.
    
    
      math.lusolve(A, b)
      Solves the linear system A * x = b where A is an [n x n] matrix and b is a [n] column vector.
    
    
      math.lyap(A, Q)
      Solves the Continuous-time Lyapunov equation AP+PA’+Q=0 for P, where Q is an input matrix.
    
    
      math.polynomialRoot(constant, linearCoeff, quadraticCoeff, cubicCoeff)
      Finds the numerical values of the distinct roots of a polynomial with real or complex coefficients.
    
    
      math.qr(A)
      Calculate the Matrix QR decomposition.
    
    
      math.rationalize(expr)
      Transform a rationalizable expression in a rational fraction.
    
    
      math.resolve(expr, scope)
      resolve(expr, scope) replaces variable nodes with their scoped values.
    
    
      math.schur(A)
      Performs a real Schur decomposition of the real matrix A = UTU’ where U is orthogonal and T is upper quasi-triangular.
    
    
      math.simplify(expr)
      Simplify an expression tree.
    
    
      math.simplifyConstant(expr)
      simplifyConstant() takes a mathjs expression (either a Node representing a parse tree or a string which it parses to produce a node), and replaces any subexpression of it consisting entirely of constants with the computed value of that subexpression.
    
    
      math.simplifyCore(expr)
      simplifyCore() performs single pass simplification suitable for applications requiring ultimate performance.
    
    
      math.slu(A, order, threshold)
      Calculate the Sparse Matrix LU decomposition with full pivoting.
    
    
      math.sylvester(A, B, C)
      Solves the real-valued Sylvester equation AX+XB=C for X, where A, B and C are matrices of appropriate dimensions, being A and B squared.
    
    
      math.symbolicEqual(expr1, expr2)
      Attempts to determine if two expressions are symbolically equal, i.
    
    
      math.usolve(U, b)
      Finds one solution of a linear equation system by backward substitution.
    
    
      math.usolveAll(U, b)
      Finds all solutions of a linear equation system by backward substitution.
    
  


Arithmetic functions #


  
    
      Function
      Description
    
  
  
    
      math.abs(x)
      Calculate the absolute value of a number.
    
    
      math.add(x, y)
      Add two or more values, x + y.
    
    
      math.cbrt(x [, allRoots])
      Calculate the cubic root of a value.
    
    
      math.ceil(x)
      Round a value towards plus infinity If x is complex, both real and imaginary part are rounded towards plus infinity.
    
    
      math.cube(x)
      Compute the cube of a value, x * x * x.
    
    
      math.divide(x, y)
      Divide two values, x / y.
    
    
      math.dotDivide(x, y)
      Divide two matrices element wise.
    
    
      math.dotMultiply(x, y)
      Multiply two matrices element wise.
    
    
      math.dotPow(x, y)
      Calculates the power of x to y element wise.
    
    
      math.exp(x)
      Calculate the exponential of a value.
    
    
      math.expm1(x)
      Calculate the value of subtracting 1 from the exponential value.
    
    
      math.fix(x)
      Round a value towards zero.
    
    
      math.floor(x)
      Round a value towards minus infinity.
    
    
      math.gcd(a, b)
      Calculate the greatest common divisor for two or more values or arrays.
    
    
      math.hypot(a, b, …)
      Calculate the hypotenuse of a list with values.
    
    
      math.invmod(a, b)
      Calculate the (modular) multiplicative inverse of a modulo b.
    
    
      math.lcm(a, b)
      Calculate the least common multiple for two or more values or arrays.
    
    
      math.log(x [, base])
      Calculate the logarithm of a value.
    
    
      math.log10(x)
      Calculate the 10-base logarithm of a value.
    
    
      math.log1p(x)
      Calculate the logarithm of a value+1.
    
    
      math.log2(x)
      Calculate the 2-base of a value.
    
    
      math.mod(x, y)
      Calculates the modulus, the remainder of an integer division.
    
    
      math.multiply(x, y)
      Multiply two or more values, x * y.
    
    
      math.norm(x [, p])
      Calculate the norm of a number, vector or matrix.
    
    
      math.nthRoot(a)
      Calculate the nth root of a value.
    
    
      math.nthRoots(x)
      Calculate the nth roots of a value.
    
    
      math.pow(x, y)
      Calculates the power of x to y, x ^ y.
    
    
      math.round(x [, n])
      Round a value towards the nearest rounded value.
    
    
      math.sign(x)
      Compute the sign of a value.
    
    
      math.sqrt(x)
      Calculate the square root of a value.
    
    
      math.square(x)
      Compute the square of a value, x * x.
    
    
      math.subtract(x, y)
      Subtract two values, x - y.
    
    
      math.unaryMinus(x)
      Inverse the sign of a value, apply a unary minus operation.
    
    
      math.unaryPlus(x)
      Unary plus operation.
    
    
      math.xgcd(a, b)
      Calculate the extended greatest common divisor for two values.
    
  


Bitwise functions #


  
    
      Function
      Description
    
  
  
    
      math.bitAnd(x, y)
      Bitwise AND two values, x & y.
    
    
      math.bitNot(x)
      Bitwise NOT value, ~x.
    
    
      math.bitOr(x, y)
      Bitwise OR two values, x | y.
    
    
      math.bitXor(x, y)
      Bitwise XOR two values, x ^ y.
    
    
      math.leftShift(x, y)
      Bitwise left logical shift of a value x by y number of bits, x << y.
    
    
      math.rightArithShift(x, y)
      Bitwise right arithmetic shift of a value x by y number of bits, x >> y.
    
    
      math.rightLogShift(x, y)
      Bitwise right logical shift of value x by y number of bits, x >>> y.
    
  


Combinatorics functions #


  
    
      Function
      Description
    
  
  
    
      math.bellNumbers(n)
      The Bell Numbers count the number of partitions of a set.
    
    
      math.catalan(n)
      The Catalan Numbers enumerate combinatorial structures of many different types.
    
    
      math.composition(n, k)
      The composition counts of n into k parts.
    
    
      math.stirlingS2(n, k)
      The Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets.
    
  


Complex functions #


  
    
      Function
      Description
    
  
  
    
      math.arg(x)
      Compute the argument of a complex value.
    
    
      math.conj(x)
      Compute the complex conjugate of a complex value.
    
    
      math.im(x)
      Get the imaginary part of a complex number.
    
    
      math.re(x)
      Get the real part of a complex number.
    
  


Geometry functions #


  
    
      Function
      Description
    
  
  
    
      math.distance([x1,y1], [x2,y2])
      Calculates:    The eucledian distance between two points in N-dimensional spaces.
    
    
      math.intersect(endPoint1Line1, endPoint2Line1, endPoint1Line2, endPoint2Line2)
      Calculates the point of intersection of two lines in two or three dimensions and of a line and a plane in three dimensions.
    
  


Logical functions #


  
    
      Function
      Description
    
  
  
    
      math.and(x, y)
      Logical and.
    
    
      math.not(x)
      Logical not.
    
    
      math.or(x, y)
      Logical or.
    
    
      math.xor(x, y)
      Logical xor.
    
  


Matrix functions #


  
    
      Function
      Description
    
  
  
    
      math.column(value, index)
      Return a column from a Matrix.
    
    
      math.concat(a, b, c, … [, dim])
      Concatenate two or more matrices.
    
    
      math.count(x)
      Count the number of elements of a matrix, array or string.
    
    
      math.cross(x, y)
      Calculate the cross product for two vectors in three dimensional space.
    
    
      math.ctranspose(x)
      Transpose and complex conjugate a matrix.
    
    
      math.det(x)
      Calculate the determinant of a matrix.
    
    
      math.diag(X)
      Create a diagonal matrix or retrieve the diagonal of a matrix  When x is a vector, a matrix with vector x on the diagonal will be returned.
    
    
      math.diff(arr)
      Create a new matrix or array of the difference between elements of the given array The optional dim parameter lets you specify the dimension to evaluate the difference of If no dimension parameter is passed it is assumed as dimension 0  Dimension is zero-based in javascript and one-based in the parser and can be a number or bignumber Arrays must be ‘rectangular’ meaning arrays like [1, 2] If something is passed as a matrix it will be returned as a matrix but other than that all matrices are converted to arrays.
    
    
      math.dot(x, y)
      Calculate the dot product of two vectors.
    
    
      math.eigs(x, [prec])
      Compute eigenvalues and optionally eigenvectors of a square matrix.
    
    
      math.expm(x)
      Compute the matrix exponential, expm(A) = e^A.
    
    
      math.fft(arr)
      Calculate N-dimensional Fourier transform.
    
    
      math.filter(x, test)
      Filter the items in an array or one dimensional matrix.
    
    
      math.flatten(x)
      Flatten a multidimensional matrix into a single dimensional matrix.
    
    
      math.forEach(x, callback)
      Iterate over all elements of a matrix/array, and executes the given callback function.
    
    
      math.getMatrixDataType(x)
      Find the data type of all elements in a matrix or array, for example ‘number’ if all items are a number and ‘Complex’ if all values are complex numbers.
    
    
      math.identity(n)
      Create a 2-dimensional identity matrix with size m x n or n x n.
    
    
      math.ifft(arr)
      Calculate N-dimensional inverse Fourier transform.
    
    
      math.inv(x)
      Calculate the inverse of a square matrix.
    
    
      math.kron(x, y)
      Calculates the Kronecker product of 2 matrices or vectors.
    
    
      math.map(x, callback)
      Create a new matrix or array with the results of a callback function executed on each entry of a given matrix/array.
    
    
      math.mapSlices(A, dim, callback)
      Apply a function that maps an array to a scalar along a given axis of a matrix or array.
    
    
      math.matrixFromColumns(…arr)
      Create a dense matrix from vectors as individual columns.
    
    
      math.matrixFromFunction(size, fn)
      Create a matrix by evaluating a generating function at each index.
    
    
      math.matrixFromRows(…arr)
      Create a dense matrix from vectors as individual rows.
    
    
      math.ones(m, n, p, …)
      Create a matrix filled with ones.
    
    
      math.partitionSelect(x, k)
      Partition-based selection of an array or 1D matrix.
    
    
      math.pinv(x)
      Calculate the Moore–Penrose inverse of a matrix.
    
    
      math.range(start, end [, step])
      Create an array from a range.
    
    
      math.reshape(x, sizes)
      Reshape a multi dimensional array to fit the specified dimensions.
    
    
      math.resize(x, size [, defaultValue])
      Resize a matrix.
    
    
      math.rotate(w, theta)
      Rotate a vector of size 1x2 counter-clockwise by a given angle Rotate a vector of size 1x3 counter-clockwise by a given angle around the given axis.
    
    
      math.rotationMatrix(theta)
      Create a 2-dimensional counter-clockwise rotation matrix (2x2) for a given angle (expressed in radians).
    
    
      math.row(value, index)
      Return a row from a Matrix.
    
    
      math.size(x)
      Calculate the size of a matrix or scalar.
    
    
      math.sort(x)
      Sort the items in a matrix.
    
    
      math.sqrtm(A)
      Calculate the principal square root of a square matrix.
    
    
      math.squeeze(x)
      Squeeze a matrix, remove inner and outer singleton dimensions from a matrix.
    
    
      math.subset(x, index [, replacement])
      Get or set a subset of a matrix or string.
    
    
      math.trace(x)
      Calculate the trace of a matrix: the sum of the elements on the main diagonal of a square matrix.
    
    
      math.transpose(x)
      Transpose a matrix.
    
    
      math.zeros(m, n, p, …)
      Create a matrix filled with zeros.
    
  


Numeric functions #


  
    
      Function
      Description
    
  
  
    
      math.solveODE(func, tspan, y0)
      Numerical Integration of Ordinary Differential Equations  Two variable step methods are provided: - “RK23”: Bogacki–Shampine method - “RK45”: Dormand-Prince method RK5(4)7M (default)  The arguments are expected as follows.
    
  


Probability functions #


  
    
      Function
      Description
    
  
  
    
      math.combinations(n, k)
      Compute the number of ways of picking k unordered outcomes from n possibilities.
    
    
      math.combinationsWithRep(n, k)
      Compute the number of ways of picking k unordered outcomes from n possibilities, allowing individual outcomes to be repeated more than once.
    
    
      math.factorial(n)
      Compute the factorial of a value  Factorial only supports an integer value as argument.
    
    
      math.gamma(n)
      Compute the gamma function of a value using Lanczos approximation for small values, and an extended Stirling approximation for large values.
    
    
      math.kldivergence(x, y)
      Calculate the Kullback-Leibler (KL) divergence  between two distributions.
    
    
      math.lgamma(n)
      Logarithm of the gamma function for real, positive numbers and complex numbers, using Lanczos approximation for numbers and Stirling series for complex numbers.
    
    
      math.multinomial(a)
      Multinomial Coefficients compute the number of ways of picking a1, a2, .
    
    
      math.permutations(n [, k])
      Compute the number of ways of obtaining an ordered subset of k elements from a set of n elements.
    
    
      math.pickRandom(array)
      Random pick one or more values from a one dimensional array.
    
    
      math.random([min, max])
      Return a random number larger or equal to min and smaller than max using a uniform distribution.
    
    
      math.randomInt([min, max])
      Return a random integer number larger or equal to min and smaller than max using a uniform distribution.
    
  


Relational functions #


  
    
      Function
      Description
    
  
  
    
      math.compare(x, y)
      Compare two values.
    
    
      math.compareNatural(x, y)
      Compare two values of any type in a deterministic, natural way.
    
    
      math.compareText(x, y)
      Compare two strings lexically.
    
    
      math.deepEqual(x, y)
      Test element wise whether two matrices are equal.
    
    
      math.equal(x, y)
      Test whether two values are equal.
    
    
      math.equalText(x, y)
      Check equality of two strings.
    
    
      math.larger(x, y)
      Test whether value x is larger than y.
    
    
      math.largerEq(x, y)
      Test whether value x is larger or equal to y.
    
    
      math.smaller(x, y)
      Test whether value x is smaller than y.
    
    
      math.smallerEq(x, y)
      Test whether value x is smaller or equal to y.
    
    
      math.unequal(x, y)
      Test whether two values are unequal.
    
  


Set functions #


  
    
      Function
      Description
    
  
  
    
      math.setCartesian(set1, set2)
      Create the cartesian product of two (multi)sets.
    
    
      math.setDifference(set1, set2)
      Create the difference of two (multi)sets: every element of set1, that is not the element of set2.
    
    
      math.setDistinct(set)
      Collect the distinct elements of a multiset.
    
    
      math.setIntersect(set1, set2)
      Create the intersection of two (multi)sets.
    
    
      math.setIsSubset(set1, set2)
      Check whether a (multi)set is a subset of another (multi)set.
    
    
      math.setMultiplicity(element, set)
      Count the multiplicity of an element in a multiset.
    
    
      math.setPowerset(set)
      Create the powerset of a (multi)set.
    
    
      math.setSize(set)
      Count the number of elements of a (multi)set.
    
    
      math.setSymDifference(set1, set2)
      Create the symmetric difference of two (multi)sets.
    
    
      math.setUnion(set1, set2)
      Create the union of two (multi)sets.
    
  


Signal functions #


  
    
      Function
      Description
    
  
  
    
      math.freqz(b, a)
      Calculates the frequency response of a filter given its numerator and denominator coefficients.
    
    
      math.zpk2tf(z, p, k)
      Compute the transfer function of a zero-pole-gain model.
    
  


Special functions #


  
    
      Function
      Description
    
  
  
    
      math.erf(x)
      Compute the erf function of a value using a rational Chebyshev approximations for different intervals of x.
    
    
      math.zeta(n)
      Compute the Riemann Zeta function of a value using an infinite series for all of the complex plane using Riemann’s Functional equation.
    
  


Statistics functions #


  
    
      Function
      Description
    
  
  
    
      math.corr(A, B)
      Compute the correlation coefficient of a two list with values, For matrices, the matrix correlation coefficient is calculated.
    
    
      math.cumsum(a, b, c, …)
      Compute the cumulative sum of a matrix or a list with values.
    
    
      math.mad(a, b, c, …)
      Compute the median absolute deviation of a matrix or a list with values.
    
    
      math.max(a, b, c, …)
      Compute the maximum value of a matrix or a  list with values.
    
    
      math.mean(a, b, c, …)
      Compute the mean value of matrix or a list with values.
    
    
      math.median(a, b, c, …)
      Compute the median of a matrix or a list with values.
    
    
      math.min(a, b, c, …)
      Compute the minimum value of a matrix or a  list of values.
    
    
      math.mode(a, b, c, …)
      Computes the mode of a set of numbers or a list with values(numbers or characters).
    
    
      math.prod(a, b, c, …)
      Compute the product of a matrix or a list with values.
    
    
      math.quantileSeq(A, prob[, sorted])
      Compute the prob order quantile of a matrix or a list with values.
    
    
      math.std(a, b, c, …)
      Compute the standard deviation of a matrix or a  list with values.
    
    
      math.sum(a, b, c, …)
      Compute the sum of a matrix or a list with values.
    
    
      math.variance(a, b, c, …)
      Compute the variance of a matrix or a  list with values.
    
  


String functions #


  
    
      Function
      Description
    
  
  
    
      math.bin(value)
      Format a number as binary.
    
    
      math.format(value [, precision])
      Format a value of any type into a string.
    
    
      math.hex(value)
      Format a number as hexadecimal.
    
    
      math.oct(value)
      Format a number as octal.
    
    
      math.print(template, values [, precision])
      Interpolate values into a string template.
    
  


Trigonometry functions #


  
    
      Function
      Description
    
  
  
    
      math.acos(x)
      Calculate the inverse cosine of a value.
    
    
      math.acosh(x)
      Calculate the hyperbolic arccos of a value, defined as acosh(x) = ln(sqrt(x^2 - 1) + x).
    
    
      math.acot(x)
      Calculate the inverse cotangent of a value, defined as acot(x) = atan(1/x).
    
    
      math.acoth(x)
      Calculate the inverse hyperbolic tangent of a value, defined as acoth(x) = atanh(1/x) = (ln((x+1)/x) + ln(x/(x-1))) / 2.
    
    
      math.acsc(x)
      Calculate the inverse cosecant of a value, defined as acsc(x) = asin(1/x).
    
    
      math.acsch(x)
      Calculate the inverse hyperbolic cosecant of a value, defined as acsch(x) = asinh(1/x) = ln(1/x + sqrt(1/x^2 + 1)).
    
    
      math.asec(x)
      Calculate the inverse secant of a value.
    
    
      math.asech(x)
      Calculate the hyperbolic arcsecant of a value, defined as asech(x) = acosh(1/x) = ln(sqrt(1/x^2 - 1) + 1/x).
    
    
      math.asin(x)
      Calculate the inverse sine of a value.
    
    
      math.asinh(x)
      Calculate the hyperbolic arcsine of a value, defined as asinh(x) = ln(x + sqrt(x^2 + 1)).
    
    
      math.atan(x)
      Calculate the inverse tangent of a value.
    
    
      math.atan2(y, x)
      Calculate the inverse tangent function with two arguments, y/x.
    
    
      math.atanh(x)
      Calculate the hyperbolic arctangent of a value, defined as atanh(x) = ln((1 + x)/(1 - x)) / 2.
    
    
      math.cos(x)
      Calculate the cosine of a value.
    
    
      math.cosh(x)
      Calculate the hyperbolic cosine of a value, defined as cosh(x) = 1/2 * (exp(x) + exp(-x)).
    
    
      math.cot(x)
      Calculate the cotangent of a value.
    
    
      math.coth(x)
      Calculate the hyperbolic cotangent of a value, defined as coth(x) = 1 / tanh(x).
    
    
      math.csc(x)
      Calculate the cosecant of a value, defined as csc(x) = 1/sin(x).
    
    
      math.csch(x)
      Calculate the hyperbolic cosecant of a value, defined as csch(x) = 1 / sinh(x).
    
    
      math.sec(x)
      Calculate the secant of a value, defined as sec(x) = 1/cos(x).
    
    
      math.sech(x)
      Calculate the hyperbolic secant of a value, defined as sech(x) = 1 / cosh(x).
    
    
      math.sin(x)
      Calculate the sine of a value.
    
    
      math.sinh(x)
      Calculate the hyperbolic sine of a value, defined as sinh(x) = 1/2 * (exp(x) - exp(-x)).
    
    
      math.tan(x)
      Calculate the tangent of a value.
    
    
      math.tanh(x)
      Calculate the hyperbolic tangent of a value, defined as tanh(x) = (exp(2 * x) - 1) / (exp(2 * x) + 1).
    
  


Unit functions #


  
    
      Function
      Description
    
  
  
    
      math.to(x, unit)
      Change the unit of a value.
    
  


Utils functions #


  
    
      Function
      Description
    
  
  
    
      math.clone(x)
      Clone an object.
    
    
      math.hasNumericValue(x)
      Test whether a value is an numeric value.
    
    
      math.isInteger(x)
      Test whether a value is an integer number.
    
    
      math.isNaN(x)
      Test whether a value is NaN (not a number).
    
    
      math.isNegative(x)
      Test whether a value is negative: smaller than zero.
    
    
      math.isNumeric(x)
      Test whether a value is an numeric value.
    
    
      math.isPositive(x)
      Test whether a value is positive: larger than zero.
    
    
      math.isPrime(x)
      Test whether a value is prime: has no divisors other than itself and one.
    
    
      math.isZero(x)
      Test whether a value is zero.
    
    
      math.numeric(x)
      Convert a numeric input to a specific numeric type: number, BigNumber, bigint, or Fraction.
    
    
      math.typeOf(x)
      Determine the type of an entity.\n\n\n\nFunction abs #

Calculate the absolute value of a number. For matrices, the function is
evaluated element wise.

Syntax #

math.abs(x)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      x
      number | BigNumber | bigint | Fraction | Complex | Array | Matrix | Unit
      A number or matrix for which to get the absolute value
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      number | BigNumber | bigint | Fraction | Complex | Array | Matrix | Unit
      Absolute value of x
    
  


Throws #

Type | Description
—- | ———–

Examples #

math.abs(3.5)                // returns number 3.5
math.abs(-4.2)               // returns number 4.2

math.abs([3, -5, -1, 0, 2])  // returns Array [3, 5, 1, 0, 2]


See also #

sign\n\n\n\nFunction add #

Add two or more values, x + y.
For matrices, the function is evaluated element wise.

Syntax #

math.add(x, y)
math.add(x, y, z, ...)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      x
      number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix
      First value to add
    
    
      y
      number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix
      Second value to add
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix
      Sum of x and y
    
  


Throws #

Type | Description
—- | ———–

Examples #

math.add(2, 3)               // returns number 5
math.add(2, 3, 4)            // returns number 9

const a = math.complex(2, 3)
const b = math.complex(-4, 1)
math.add(a, b)               // returns Complex -2 + 4i

math.add([1, 2, 3], 4)       // returns Array [5, 6, 7]

const c = math.unit('5 cm')
const d = math.unit('2.1 mm')
math.add(c, d)               // returns Unit 52.1 mm

math.add("2.3", "4")         // returns number 6.3


See also #

subtract,
sum\n\n\n\nFunction cbrt #

Calculate the cubic root of a value.

To avoid confusion with the matrix cube root, this function does not
apply to matrices. For a matrix, to take the cube root elementwise,
see the examples.

Syntax #

math.cbrt(x)
math.cbrt(x, allRoots)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      x
      number | BigNumber | Complex | Unit
      Value for which to calculate the cubic root.
    
    
      allRoots
      boolean
      Optional, false by default. Only applicable when x is a number or complex number. If true, all complex roots are returned, if false (default) the principal root is returned.
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      number | BigNumber | Complex | Unit
      Returns the cubic root of x
    
  


Throws #

Type | Description
—- | ———–

Examples #

math.cbrt(27)                  // returns 3
math.cube(3)                   // returns 27
math.cbrt(-64)                 // returns -4
math.cbrt(math.unit('27 m^3')) // returns Unit 3 m
math.map([27, 64, 125], x => math.cbrt(x))       // returns [3, 4, 5]

const x = math.complex('8i')
math.cbrt(x)                   // returns Complex 1.7320508075689 + i
math.cbrt(x, true)             // returns Matrix [
                                //    1.7320508075689 + i
                                //   -1.7320508075689 + i
                                //   -2i
                                // ]


See also #

square,
sqrt,
cube\n\n\n\nFunction ceil #

Round a value towards plus infinity
If x is complex, both real and imaginary part are rounded towards plus infinity.
For matrices, the function is evaluated element wise.

Syntax #

math.ceil(x)
math.ceil(x, n)
math.ceil(unit, valuelessUnit)
math.ceil(unit, n, valuelessUnit)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      x
      number | BigNumber | Fraction | Complex | Unit | Array | Matrix
      Value to be rounded
    
    
      n
      number | BigNumber | Array
      Number of decimals Default value: 0.
    
    
      valuelessUnit
      Unit
      A valueless unit
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      number | BigNumber | Fraction | Complex | Unit | Array | Matrix
      Rounded value
    
  


Throws #

Type | Description
—- | ———–

Examples #

math.ceil(3.2)               // returns number 4
math.ceil(3.8)               // returns number 4
math.ceil(-4.2)              // returns number -4
math.ceil(-4.7)              // returns number -4

math.ceil(3.212, 2)          // returns number 3.22
math.ceil(3.288, 2)          // returns number 3.29
math.ceil(-4.212, 2)         // returns number -4.21
math.ceil(-4.782, 2)         // returns number -4.78

const c = math.complex(3.24, -2.71)
math.ceil(c)                 // returns Complex 4 - 2i
math.ceil(c, 1)              // returns Complex 3.3 - 2.7i

const unit = math.unit('3.241 cm')
const cm = math.unit('cm')
const mm = math.unit('mm')
math.ceil(unit, 1, cm)      // returns Unit 3.3 cm
math.ceil(unit, 1, mm)      // returns Unit 32.5 mm

math.ceil([3.2, 3.8, -4.7])  // returns Array [4, 4, -4]
math.ceil([3.21, 3.82, -4.71], 1)  // returns Array [3.3, 3.9, -4.7]


See also #

floor,
fix,
round\n\n\n\nFunction cube #

Compute the cube of a value, x * x * x.
To avoid confusion with pow(M,3), this function does not apply to matrices.
If you wish to cube every entry of a matrix, see the examples.

Syntax #

math.cube(x)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      x
      number | BigNumber | bigint | Fraction | Complex | Unit
      Number for which to calculate the cube
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      number | BigNumber | bigint | Fraction | Complex | Unit
      Cube of x
    
  


Throws #

Type | Description
—- | ———–

Examples #

math.cube(2)            // returns number 8
math.pow(2, 3)          // returns number 8
math.cube(4)            // returns number 64
4 * 4 * 4               // returns number 64

math.map([1, 2, 3, 4], math.cube) // returns Array [1, 8, 27, 64]


See also #

multiply,
square,
pow,
cbrt\n\n\n\nFunction divide #

Divide two values, x / y.
To divide matrices, x is multiplied with the inverse of y: x * inv(y).

Syntax #

math.divide(x, y)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      x
      number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix
      Numerator
    
    
      y
      number | BigNumber | bigint | Fraction | Complex | Array | Matrix
      Denominator
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      number | BigNumber | bigint | Fraction | Complex | Unit | Array | Matrix
      Quotient, x / y
    
  


Throws #

Type | Description
—- | ———–

Examples #

math.divide(2, 3)            // returns number 0.6666666666666666

const a = math.complex(5, 14)
const b = math.complex(4, 1)
math.divide(a, b)            // returns Complex 2 + 3i

const c = [[7, -6], [13, -4]]
const d = [[1, 2], [4, 3]]
math.divide(c, d)            // returns Array [[-9, 4], [-11, 6]]

const e = math.unit('18 km')
math.divide(e, 4.5)          // returns Unit 4 km


See also #

multiply\n\n\n\nFunction dotDivide #

Divide two matrices element wise. The function accepts both matrices and
scalar values.

Syntax #

math.dotDivide(x, y)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      x
      number | BigNumber | Fraction | Complex | Unit | Array | Matrix
      Numerator
    
    
      y
      number | BigNumber | Fraction | Complex | Unit | Array | Matrix
      Denominator
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      number | BigNumber | Fraction | Complex | Unit | Array | Matrix
      Quotient, x ./ y
    
  


Throws #

Type | Description
—- | ———–

Examples #

math.dotDivide(2, 4)   // returns 0.5

a = [[9, 5], [6, 1]]
b = [[3, 2], [5, 2]]

math.dotDivide(a, b)   // returns [[3, 2.5], [1.2, 0.5]]
math.divide(a, b)      // returns [[1.75, 0.75], [-1.75, 2.25]]


See also #

divide,
multiply,
dotMultiply\n\n\n\nFunction dotMultiply #

Multiply two matrices element wise. The function accepts both matrices and
scalar values.

Syntax #

math.dotMultiply(x, y)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      x
      number | BigNumber | Fraction | Complex | Unit | Array | Matrix
      Left hand value
    
    
      y
      number | BigNumber | Fraction | Complex | Unit | Array | Matrix
      Right hand value
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      number | BigNumber | Fraction | Complex | Unit | Array | Matrix
      Multiplication of x and y
    
  


Throws #

Type | Description
—- | ———–

Examples #

math.dotMultiply(2, 4) // returns 8

a = [[9, 5], [6, 1]]
b = [[3, 2], [5, 2]]

math.dotMultiply(a, b) // returns [[27, 10], [30, 2]]
math.multiply(a, b)    // returns [[52, 28], [23, 14]]


See also #

multiply,
divide,
dotDivide\n\n\n\nFunction dotPow #

Calculates the power of x to y element wise.

Syntax #

math.dotPow(x, y)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      x
      number | BigNumber | Complex | Unit | Array | Matrix
      The base
    
    
      y
      number | BigNumber | Complex | Unit | Array | Matrix
      The exponent
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      number | BigNumber | Complex | Unit | Array | Matrix
      The value of x to the power y
    
  


Throws #

Type | Description
—- | ———–

Examples #

math.dotPow(2, 3)            // returns number 8

const a = [[1, 2], [4, 3]]
math.dotPow(a, 2)            // returns Array [[1, 4], [16, 9]]
math.pow(a, 2)               // returns Array [[9, 8], [16, 17]]


See also #

pow,
sqrt,
multiply\n\n\n\nFunction exp #

Calculate the exponential of a value.
For matrices, if you want the matrix exponential of square matrix, use
the expm function; if you want to take the exponential of each element,
see the examples.

Syntax #

math.exp(x)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      x
      number | BigNumber | Complex
      A number to exponentiate
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      number | BigNumber | Complex
      Exponential of x
    
  


Throws #

Type | Description
—- | ———–

Examples #

math.exp(2)                  // returns number 7.3890560989306495
math.pow(math.e, 2)          // returns number 7.3890560989306495
math.log(math.exp(2))        // returns number 2

math.map([1, 2, 3], math.exp)
// returns Array [
//   2.718281828459045,
//   7.3890560989306495,
//   20.085536923187668
// ]


See also #

expm1,
expm,
log,
pow\n\n\n\nFunction expm1 #

Calculate the value of subtracting 1 from the exponential value.
This function is more accurate than math.exp(x)-1 when x is near 0
To avoid ambiguity with the matrix exponential expm, this function
does not operate on matrices; if you wish to apply it elementwise, see
the examples.

Syntax #

math.expm1(x)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      x
      number | BigNumber | Complex
      The number to exponentiate
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      number | BigNumber | Complex
      Exponential of x, minus one
    
  


Throws #

Type | Description
—- | ———–

Examples #

math.expm1(2)                      // returns number 6.38905609893065
math.pow(math.e, 2) - 1            // returns number 6.3890560989306495
math.expm1(1e-8)                   // returns number 1.0000000050000001e-8
math.exp(1e-8) - 1                 // returns number 9.9999999392253e-9
math.log(math.expm1(2) + 1)        // returns number 2

math.map([1, 2, 3], math.expm1)
// returns Array [
//   1.718281828459045,
//   6.3890560989306495,
//   19.085536923187668
// ]


See also #

exp,
expm,
log,
pow\n\n\n\nFunction fix #

Round a value towards zero.
For matrices, the function is evaluated element wise.

Syntax #

math.fix(x)
math.fix(x,n)
math.fix(unit, valuelessUnit)
math.fix(unit, n, valuelessUnit)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      x
      number | BigNumber | Fraction | Complex | Unit | Array | Matrix
      Value to be rounded
    
    
      n
      number | BigNumber | Array
      Number of decimals Default value: 0.
    
    
      valuelessUnit
      Unit
      A valueless unit
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      number | BigNumber | Fraction | Complex | Unit | Array | Matrix
      Rounded value
    
  


Throws #

Type | Description
—- | ———–

Examples #

math.fix(3.2)                // returns number 3
math.fix(3.8)                // returns number 3
math.fix(-4.2)               // returns number -4
math.fix(-4.7)               // returns number -4

math.fix(3.12, 1)                // returns number 3.1
math.fix(3.18, 1)                // returns number 3.1
math.fix(-4.12, 1)               // returns number -4.1
math.fix(-4.17, 1)               // returns number -4.1

const c = math.complex(3.22, -2.78)
math.fix(c)                  // returns Complex 3 - 2i
math.fix(c, 1)               // returns Complex 3.2 -2.7i

const unit = math.unit('3.241 cm')
const cm = math.unit('cm')
const mm = math.unit('mm')
math.fix(unit, 1, cm)      // returns Unit 3.2 cm
math.fix(unit, 1, mm)      // returns Unit 32.4 mm

math.fix([3.2, 3.8, -4.7])      // returns Array [3, 3, -4]
math.fix([3.2, 3.8, -4.7], 1)   // returns Array [3.2, 3.8, -4.7]


See also #

ceil,
floor,
round\n\n\n\nFunction floor #

Round a value towards minus infinity.
For matrices, the function is evaluated element wise.

Syntax #

math.floor(x)
math.floor(x, n)
math.floor(unit, valuelessUnit)
math.floor(unit, n, valuelessUnit)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      x
      number | BigNumber | Fraction | Complex | Unit | Array | Matrix
      Value to be rounded
    
    
      n
      number | BigNumber | Array
      Number of decimals Default value: 0.
    
    
      valuelessUnit
      Unit
      A valueless unit
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      number | BigNumber | Fraction | Complex | Unit | Array | Matrix
      Rounded value
    
  


Throws #

Type | Description
—- | ———–

Examples #

math.floor(3.2)              // returns number 3
math.floor(3.8)              // returns number 3
math.floor(-4.2)             // returns number -5
math.floor(-4.7)             // returns number -5

math.floor(3.212, 2)          // returns number 3.21
math.floor(3.288, 2)          // returns number 3.28
math.floor(-4.212, 2)         // returns number -4.22
math.floor(-4.782, 2)         // returns number -4.79

const c = math.complex(3.24, -2.71)
math.floor(c)                 // returns Complex 3 - 3i
math.floor(c, 1)              // returns Complex 3.2 -2.8i

const unit = math.unit('3.241 cm')
const cm = math.unit('cm')
const mm = math.unit('mm')
math.floor(unit, 1, cm)      // returns Unit 3.2 cm
math.floor(unit, 1, mm)      // returns Unit 32.4 mm

math.floor([3.2, 3.8, -4.7])       // returns Array [3, 3, -5]
math.floor([3.21, 3.82, -4.71], 1)  // returns Array [3.2, 3.8, -4.8]

math.floor(math.tau, [2, 3])  // returns Array [6.28, 6.283]

// Note that floor(array, array) currently not implemented.


See also #

ceil,
fix,
round\n\n\n\nFunction gcd #

Calculate the greatest common divisor for two or more values or arrays.

For matrices, the function is evaluated element wise.

Syntax #

math.gcd(a, b)
math.gcd(a, b, c, ...)


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      args
      … number | BigNumber | Fraction | Array | Matrix
      Two or more integer numbers
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      number | BigNumber | Fraction | Array | Matrix
      The greatest common divisor
    
  


Throws #

Type | Description
—- | ———–

Examples #

math.gcd(8, 12)              // returns 4
math.gcd(-4, 6)              // returns 2
math.gcd(25, 15, -10)        // returns 5

math.gcd([8, -4], [12, 6])   // returns [4, 2]


See also #

lcm,
xgcd\n\n\n\nFunction hypot #

Calculate the hypotenuse of a list with values. The hypotenuse is defined as:

hypot(a, b, c, ...) = sqrt(a^2 + b^2 + c^2 + ...)


For matrix input, the hypotenuse is calculated for all values in the matrix.

Syntax #

math.hypot(a, b, ...)
math.hypot([a, b, c, ...])


Parameters #


  
    
      Parameter
      Type
      Description
    
  
  
    
      args
      … number | BigNumber | Array | Matrix
      A list with numeric values or an Array or Matrix. Matrix and Array input is flattened and returns a single number for the whole matrix.
    
  


Returns #


  
    
      Type
      Description
    
  
  
    
      number | BigNumber
      Returns the hypothenusa of the input values.
    
  


Throws #

Type | Description
—- | ———–

Examples #

math.hypot(3, 4)      // 5
math.hypot(3, 4, 5)   // 7.0710678118654755
math.hypot([3, 4, 5]) // 7.0710678118654755
math.hypot(-2)        // 2


See also #

abs,
norm\n\n\n\n