Express5.1.0
        Fast, unopinionated, minimalist web framework for Node.js
    
    $ npm install express --save
  

  

    const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})
    

  



  
    
       [email protected]: Now the Default on npm with LTS Timeline
      
        Express 5.1.0 is now the default on npm, and we’re introducing an official LTS schedule for the v4 and v5 release lines. Check out our latest blog for more information.
      
    

  




  
    
      Web Applications Express is a minimal and flexible Node.js web application framework that provides a robust set of features for web and mobile applications.
    

    
      APIs With a myriad of HTTP utility methods and middleware at your disposal, creating a robust API is quick and easy.
    

    
      Performance Express provides a thin layer of fundamental web application features, without obscuring Node.js features that you know and love.
    

    
      Middleware 
      Express is a lightweight and flexible routing framework with minimal core features 
      meant to be augmented through the use of Express middleware modules.\n\n\n\nInstalling

Assuming you’ve already installed Node.js, create a directory to hold your application, and make that your working directory.


  Express 4.x requires Node.js 0.10 or higher.
  Express 5.x requires Node.js 18 or higher.


$ mkdir myapp
$ cd myapp


Use the npm init command to create a package.json file for your application.
For more information on how package.json works, see Specifics of npm’s package.json handling.

$ npm init


This command prompts you for a number of things, such as the name and version of your application.
For now, you can simply hit RETURN to accept the defaults for most of them, with the following exception:

entry point: (index.js)


Enter app.js, or whatever you want the name of the main file to be. If you want it to be index.js, hit RETURN to accept the suggested default file name.

Now, install Express in the myapp directory and save it in the dependencies list. For example:

$ npm install express


To install Express temporarily and not add it to the dependencies list:

$ npm install express --no-save



  By default with version npm 5.0+, npm install adds the module to the dependencies list in the package.json file; with earlier versions of npm, you must specify the --save option explicitly. Then, afterwards, running npm install in the app directory will automatically install modules in the dependencies list.


Next: Hello World 

              
    
    Edit this page\n\nInstalling

Assuming you’ve already installed Node.js, create a directory to hold your application, and make that your working directory.


  Express 4.x requires Node.js 0.10 or higher.
  Express 5.x requires Node.js 18 or higher.


$ mkdir myapp
$ cd myapp


Use the npm init command to create a package.json file for your application.
For more information on how package.json works, see Specifics of npm’s package.json handling.

$ npm init


This command prompts you for a number of things, such as the name and version of your application.
For now, you can simply hit RETURN to accept the defaults for most of them, with the following exception:

entry point: (index.js)


Enter app.js, or whatever you want the name of the main file to be. If you want it to be index.js, hit RETURN to accept the suggested default file name.

Now, install Express in the myapp directory and save it in the dependencies list. For example:

$ npm install express


To install Express temporarily and not add it to the dependencies list:

$ npm install express --no-save



  By default with version npm 5.0+, npm install adds the module to the dependencies list in the package.json file; with earlier versions of npm, you must specify the --save option explicitly. Then, afterwards, running npm install in the app directory will automatically install modules in the dependencies list.


Next: Hello World 

              
    
    Edit this page\n\n\n\nHello world example


  Embedded below is essentially the simplest Express app you can create. It is a single file app — not what you’d get if you use the Express generator, which creates the scaffolding for a full app with numerous JavaScript files, Jade templates, and sub-directories for various purposes.


const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


This app starts a server and listens on port 3000 for connections. The app responds with “Hello World!” for requests
to the root URL (/) or route. For every other path, it will respond with a 404 Not Found.

Running Locally

First create a directory named myapp, change to it and run npm init. Then, install express as a dependency, as per the installation guide.

In the myapp directory, create a file named app.js and copy the code from the example above.


  The req (request) and res (response) are the exact same objects that Node provides, so you can invoke
req.pipe(), req.on('data', callback), and anything else you would do without Express involved.


Run the app with the following command:

$ node app.js


Then, load http://localhost:3000/ in a browser to see the output.

Previous: Installing     Next: Express Generator 

              
    
    Edit this page\n\nHello world example


  Embedded below is essentially the simplest Express app you can create. It is a single file app — not what you’d get if you use the Express generator, which creates the scaffolding for a full app with numerous JavaScript files, Jade templates, and sub-directories for various purposes.


const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


This app starts a server and listens on port 3000 for connections. The app responds with “Hello World!” for requests
to the root URL (/) or route. For every other path, it will respond with a 404 Not Found.

Running Locally

First create a directory named myapp, change to it and run npm init. Then, install express as a dependency, as per the installation guide.

In the myapp directory, create a file named app.js and copy the code from the example above.


  The req (request) and res (response) are the exact same objects that Node provides, so you can invoke
req.pipe(), req.on('data', callback), and anything else you would do without Express involved.


Run the app with the following command:

$ node app.js


Then, load http://localhost:3000/ in a browser to see the output.

Previous: Installing     Next: Express Generator 

              
    
    Edit this page\n\n\n\nExpress application generator

Use the application generator tool, express-generator, to quickly create an application skeleton.

You can run the application generator with the npx command (available in Node.js 8.2.0).

$ npx express-generator


For earlier Node versions, install the application generator as a global npm package and then launch it:

$ npm install -g express-generator
$ express


Display the command options with the -h option:

$ express -h

  Usage: express [options] [dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view <engine> add view <engine> support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css <engine>  add stylesheet <engine> support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


For example, the following creates an Express app named myapp. The app will be created in a folder named myapp in the current working directory and the view engine will be set to Pug:

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


Then install dependencies:

$ cd myapp
$ npm install


On MacOS or Linux, run the app with this command:

$ DEBUG=myapp:* npm start


On Windows Command Prompt, use this command:

> set DEBUG=myapp:* & npm start


On Windows PowerShell, use this command:

PS> $env:DEBUG='myapp:*'; npm start


Then, load http://localhost:3000/ in your browser to access the app.

The generated app has the following directory structure:

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  The app structure created by the generator is just one of many ways to structure Express apps. Feel free to use this structure or modify it to best suit your needs.


Previous: Hello World     Next: Basic routing

              
    
    Edit this page\n\nExpress application generator

Use the application generator tool, express-generator, to quickly create an application skeleton.

You can run the application generator with the npx command (available in Node.js 8.2.0).

$ npx express-generator


For earlier Node versions, install the application generator as a global npm package and then launch it:

$ npm install -g express-generator
$ express


Display the command options with the -h option:

$ express -h

  Usage: express [options] [dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view <engine> add view <engine> support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css <engine>  add stylesheet <engine> support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


For example, the following creates an Express app named myapp. The app will be created in a folder named myapp in the current working directory and the view engine will be set to Pug:

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


Then install dependencies:

$ cd myapp
$ npm install


On MacOS or Linux, run the app with this command:

$ DEBUG=myapp:* npm start


On Windows Command Prompt, use this command:

> set DEBUG=myapp:* & npm start


On Windows PowerShell, use this command:

PS> $env:DEBUG='myapp:*'; npm start


Then, load http://localhost:3000/ in your browser to access the app.

The generated app has the following directory structure:

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  The app structure created by the generator is just one of many ways to structure Express apps. Feel free to use this structure or modify it to best suit your needs.


Previous: Hello World     Next: Basic routing

              
    
    Edit this page\n\n\n\nBasic routing

Routing refers to determining how an application responds to a client request to a particular endpoint, which is a URI (or path) and a specific HTTP request method (GET, POST, and so on).

Each route can have one or more handler functions, which are executed when the route is matched.

Route definition takes the following structure:

app.METHOD(PATH, HANDLER)


Where:


  app is an instance of express.
  METHOD is an HTTP request method, in lowercase.
  PATH is a path on the server.
  HANDLER is the function executed when the route is matched.



  This tutorial assumes that an instance of express named app is created and the server is running. If you are not familiar with creating an app and starting it, see the Hello world example.


The following examples illustrate defining simple routes.

Respond with Hello World! on the homepage:

app.get('/', (req, res) => {
  res.send('Hello World!')
})


Respond to POST request on the root route (/), the application’s home page:

app.post('/', (req, res) => {
  res.send('Got a POST request')
})


Respond to a PUT request to the /user route:

app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})


Respond to a DELETE request to the /user route:

app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})


For more details about routing, see the routing guide.

Previous: Express application generator     Next: Serving static files in Express 

              
    
    Edit this page\n\nBasic routing

Routing refers to determining how an application responds to a client request to a particular endpoint, which is a URI (or path) and a specific HTTP request method (GET, POST, and so on).

Each route can have one or more handler functions, which are executed when the route is matched.

Route definition takes the following structure:

app.METHOD(PATH, HANDLER)


Where:


  app is an instance of express.
  METHOD is an HTTP request method, in lowercase.
  PATH is a path on the server.
  HANDLER is the function executed when the route is matched.



  This tutorial assumes that an instance of express named app is created and the server is running. If you are not familiar with creating an app and starting it, see the Hello world example.


The following examples illustrate defining simple routes.

Respond with Hello World! on the homepage:

app.get('/', (req, res) => {
  res.send('Hello World!')
})


Respond to POST request on the root route (/), the application’s home page:

app.post('/', (req, res) => {
  res.send('Got a POST request')
})


Respond to a PUT request to the /user route:

app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})


Respond to a DELETE request to the /user route:

app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})


For more details about routing, see the routing guide.

Previous: Express application generator     Next: Serving static files in Express 

              
    
    Edit this page\n\n\n\nServing static files in Express

To serve static files such as images, CSS files, and JavaScript files, use the express.static built-in middleware function in Express.

The function signature is:

express.static(root, [options])


The root argument specifies the root directory from which to serve static assets.
For more information on the options argument, see express.static.

For example, use the following code to serve images, CSS files, and JavaScript files in a directory named public:

app.use(express.static('public'))


Now, you can load the files that are in the public directory:

http://localhost:3000/images/kitten.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/app.js
http://localhost:3000/images/bg.png
http://localhost:3000/hello.html



Express looks up the files relative to the static directory, so the name of the static directory is not part of the URL.


To use multiple static assets directories, call the express.static middleware function multiple times:

app.use(express.static('public'))
app.use(express.static('files'))


Express looks up the files in the order in which you set the static directories with the express.static middleware function.


   Note

  For best results, use a reverse proxy cache to improve performance of serving static assets.



To create a virtual path prefix (where the path does not actually exist in the file system) for files that are served by the express.static function, specify a mount path for the static directory, as shown below:

app.use('/static', express.static('public'))


Now, you can load the files that are in the public directory from the /static path prefix.

http://localhost:3000/static/images/kitten.jpg
http://localhost:3000/static/css/style.css
http://localhost:3000/static/js/app.js
http://localhost:3000/static/images/bg.png
http://localhost:3000/static/hello.html


However, the path that you provide to the express.static function is relative to the directory from where you launch your node process. If you run the express app from another directory, it’s safer to use the absolute path of the directory that you want to serve:

const path = require('path')
app.use('/static', express.static(path.join(__dirname, 'public')))


For more details about the serve-static function and its options, see  serve-static.

Previous: Basic Routing     Next: More examples 

              
    
    Edit this page\n\nServing static files in Express

To serve static files such as images, CSS files, and JavaScript files, use the express.static built-in middleware function in Express.

The function signature is:

express.static(root, [options])


The root argument specifies the root directory from which to serve static assets.
For more information on the options argument, see express.static.

For example, use the following code to serve images, CSS files, and JavaScript files in a directory named public:

app.use(express.static('public'))


Now, you can load the files that are in the public directory:

http://localhost:3000/images/kitten.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/app.js
http://localhost:3000/images/bg.png
http://localhost:3000/hello.html



Express looks up the files relative to the static directory, so the name of the static directory is not part of the URL.


To use multiple static assets directories, call the express.static middleware function multiple times:

app.use(express.static('public'))
app.use(express.static('files'))


Express looks up the files in the order in which you set the static directories with the express.static middleware function.


   Note

  For best results, use a reverse proxy cache to improve performance of serving static assets.



To create a virtual path prefix (where the path does not actually exist in the file system) for files that are served by the express.static function, specify a mount path for the static directory, as shown below:

app.use('/static', express.static('public'))


Now, you can load the files that are in the public directory from the /static path prefix.

http://localhost:3000/static/images/kitten.jpg
http://localhost:3000/static/css/style.css
http://localhost:3000/static/js/app.js
http://localhost:3000/static/images/bg.png
http://localhost:3000/static/hello.html


However, the path that you provide to the express.static function is relative to the directory from where you launch your node process. If you run the express app from another directory, it’s safer to use the absolute path of the directory that you want to serve:

const path = require('path')
app.use('/static', express.static(path.join(__dirname, 'public')))


For more details about the serve-static function and its options, see  serve-static.

Previous: Basic Routing     Next: More examples 

              
    
    Edit this page\n\n\n\nExpress examples

This page contains list of examples using Express.


  auth - Authentication with login and password
  content-negotiation - HTTP content negotiation
  cookie-sessions - Working with cookie-based sessions
  cookies - Working with cookies
  downloads - Transferring files to client
  ejs - Working with Embedded JavaScript templating (ejs)
  error-pages - Creating error pages
  error - Working with error middleware
  hello-world - Simple request handler
  markdown - Markdown as template engine
  multi-router - Working with multiple Express routers
  mvc - MVC-style controllers
  online - Tracking online user activity with online and redis packages
  params - Working with route parameters
  resource - Multiple HTTP operations on the same resource
  route-map - Organizing routes using a map
  route-middleware - Working with route middleware
  route-separation - Organizing routes per each resource
  search - Search API
  session - User sessions
  static-files - Serving static files
  vhost - Working with virtual hosts
  view-constructor - Rendering views dynamically
  view-locals - Saving data in request object between middleware calls
  web-service - Simple API service


Additional examples

These are some additional examples with more extensive integrations.


   Warning

  This information refers to third-party sites, products, or modules that are not maintained by the Expressjs team. Listing here does not constitute an endorsement or recommendation from the Expressjs project team.




  prisma-fullstack - Fullstack app with Express and Next.js using Prisma as an ORM
  prisma-rest-api-ts - REST API with Express in TypeScript using Prisma as an ORM


Previous: Static Files     Next: FAQ 

              
    
    Edit this page\n\nExpress examples

This page contains list of examples using Express.


  auth - Authentication with login and password
  content-negotiation - HTTP content negotiation
  cookie-sessions - Working with cookie-based sessions
  cookies - Working with cookies
  downloads - Transferring files to client
  ejs - Working with Embedded JavaScript templating (ejs)
  error-pages - Creating error pages
  error - Working with error middleware
  hello-world - Simple request handler
  markdown - Markdown as template engine
  multi-router - Working with multiple Express routers
  mvc - MVC-style controllers
  online - Tracking online user activity with online and redis packages
  params - Working with route parameters
  resource - Multiple HTTP operations on the same resource
  route-map - Organizing routes using a map
  route-middleware - Working with route middleware
  route-separation - Organizing routes per each resource
  search - Search API
  session - User sessions
  static-files - Serving static files
  vhost - Working with virtual hosts
  view-constructor - Rendering views dynamically
  view-locals - Saving data in request object between middleware calls
  web-service - Simple API service


Additional examples

These are some additional examples with more extensive integrations.


   Warning

  This information refers to third-party sites, products, or modules that are not maintained by the Expressjs team. Listing here does not constitute an endorsement or recommendation from the Expressjs project team.




  prisma-fullstack - Fullstack app with Express and Next.js using Prisma as an ORM
  prisma-rest-api-ts - REST API with Express in TypeScript using Prisma as an ORM


Previous: Static Files     Next: FAQ 

              
    
    Edit this page\n\n\n\nFAQ

How should I structure my application?

There is no definitive answer to this question. The answer depends
on the scale of your application and the team that is involved. To be as
flexible as possible, Express makes no assumptions in terms of structure.

Routes and other application-specific logic can live in as many files
as you wish, in any directory structure you prefer. View the following
examples for inspiration:


  Route listings
  Route map
  MVC style controllers


Also, there are third-party extensions for Express, which simplify some of these patterns:


  Resourceful routing


How do I define models?

Express has no notion of a database. This concept is
left up to third-party Node modules, allowing you to
interface with nearly any database.

See LoopBack for an Express-based framework that is centered around models.

How can I authenticate users?

Authentication is another opinionated area that Express does not
venture into. You may use any authentication scheme you wish.
For a simple username / password scheme, see this example.

Which template engines does Express support?

Express supports any template engine that conforms with the (path, locals, callback) signature.
To normalize template engine interfaces and caching, see the
consolidate.js
project for support. Unlisted template engines might still support the Express signature.

For more information, see Using template engines with Express.

How do I handle 404 responses?

In Express, 404 responses are not the result of an error, so
the error-handler middleware will not capture them. This behavior is
because a 404 response simply indicates the absence of additional work to do;
in other words, Express has executed all middleware functions and routes,
and found that none of them responded. All you need to
do is add a middleware function at the very bottom of the stack (below all other functions)
to handle a 404 response:

app.use((req, res, next) => {
  res.status(404).send("Sorry can't find that!")
})


Add routes dynamically at runtime on an instance of express.Router()
so the routes are not superseded by a middleware function.

How do I setup an error handler?

You define error-handling middleware in the same way as other middleware,
except with four arguments instead of three; specifically with the signature (err, req, res, next):

app.use((err, req, res, next) => {
  console.error(err.stack)
  res.status(500).send('Something broke!')
})


For more information, see Error handling.

How do I render plain HTML?

You don’t! There’s no need to “render” HTML with the res.render() function.
If you have a specific file, use the res.sendFile() function.
If you are serving many assets from a directory, use the express.static()
middleware function.

What version of Node.js does Express require?


  Express 4.x requires Node.js 0.10 or higher.
  Express 5.x requires Node.js 18 or higher.


Previous: More examples 

              
    
    Edit this page\n\nFAQ

How should I structure my application?

There is no definitive answer to this question. The answer depends
on the scale of your application and the team that is involved. To be as
flexible as possible, Express makes no assumptions in terms of structure.

Routes and other application-specific logic can live in as many files
as you wish, in any directory structure you prefer. View the following
examples for inspiration:


  Route listings
  Route map
  MVC style controllers


Also, there are third-party extensions for Express, which simplify some of these patterns:


  Resourceful routing


How do I define models?

Express has no notion of a database. This concept is
left up to third-party Node modules, allowing you to
interface with nearly any database.

See LoopBack for an Express-based framework that is centered around models.

How can I authenticate users?

Authentication is another opinionated area that Express does not
venture into. You may use any authentication scheme you wish.
For a simple username / password scheme, see this example.

Which template engines does Express support?

Express supports any template engine that conforms with the (path, locals, callback) signature.
To normalize template engine interfaces and caching, see the
consolidate.js
project for support. Unlisted template engines might still support the Express signature.

For more information, see Using template engines with Express.

How do I handle 404 responses?

In Express, 404 responses are not the result of an error, so
the error-handler middleware will not capture them. This behavior is
because a 404 response simply indicates the absence of additional work to do;
in other words, Express has executed all middleware functions and routes,
and found that none of them responded. All you need to
do is add a middleware function at the very bottom of the stack (below all other functions)
to handle a 404 response:

app.use((req, res, next) => {
  res.status(404).send("Sorry can't find that!")
})


Add routes dynamically at runtime on an instance of express.Router()
so the routes are not superseded by a middleware function.

How do I setup an error handler?

You define error-handling middleware in the same way as other middleware,
except with four arguments instead of three; specifically with the signature (err, req, res, next):

app.use((err, req, res, next) => {
  console.error(err.stack)
  res.status(500).send('Something broke!')
})


For more information, see Error handling.

How do I render plain HTML?

You don’t! There’s no need to “render” HTML with the res.render() function.
If you have a specific file, use the res.sendFile() function.
If you are serving many assets from a directory, use the express.static()
middleware function.

What version of Node.js does Express require?


  Express 4.x requires Node.js 0.10 or higher.
  Express 5.x requires Node.js 18 or higher.


Previous: More examples 

              
    
    Edit this page\n\n\n\nRouting

Routing refers to how an application’s endpoints (URIs) respond to client requests.
For an introduction to routing, see Basic routing.

You define routing using methods of the Express app object that correspond to HTTP methods;
for example, app.get() to handle GET requests and app.post to handle POST requests. For a full list,
see app.METHOD. You can also use app.all() to handle all HTTP methods and app.use() to
specify middleware as the callback function (See Using middleware for details).

These routing methods specify a callback function (sometimes called “handler functions”) called when the application receives a request to the specified route (endpoint) and HTTP method. In other words, the application “listens” for requests that match the specified route(s) and method(s), and when it detects a match, it calls the specified callback function.

In fact, the routing methods can have more than one callback function as arguments.
With multiple callback functions, it is important to provide next as an argument to the callback function and then call next() within the body of the function to hand off control
to the next callback.

The following code is an example of a very basic route.

const express = require('express')
const app = express()

// respond with "hello world" when a GET request is made to the homepage
app.get('/', (req, res) => {
  res.send('hello world')
})


Route methods

A route method is derived from one of the HTTP methods, and is attached to an instance of the express class.

The following code is an example of routes that are defined for the GET and the POST methods to the root of the app.

// GET method route
app.get('/', (req, res) => {
  res.send('GET request to the homepage')
})

// POST method route
app.post('/', (req, res) => {
  res.send('POST request to the homepage')
})


Express supports methods that correspond to all HTTP request methods: get, post, and so on.
For a full list, see app.METHOD.

There is a special routing method, app.all(), used to load middleware functions at a path for all HTTP request methods. For example, the following handler is executed for requests to the route "/secret" whether using GET, POST, PUT, DELETE, or any other HTTP request method supported in the http module.

app.all('/secret', (req, res, next) => {
  console.log('Accessing the secret section ...')
  next() // pass control to the next handler
})


Route paths

Route paths, in combination with a request method, define the endpoints at which requests can be made. Route paths can be strings, string patterns, or regular expressions.


   Caution
  In express 5, the characters ?, +, *, [], and () are handled differently than in version 4, please review the migration guide for more information.



   Caution
  In express 4, regular expression characters such as $ need to be escaped with a \.




   Note

  Express uses path-to-regexp for matching the route paths; see the path-to-regexp documentation for all the possibilities in defining route paths. Express Playground Router is a handy tool for testing basic Express routes, although it does not support pattern matching.




   Warning

  Query strings are not part of the route path.



Route paths based on strings

This route path will match requests to the root route, /.

app.get('/', (req, res) => {
  res.send('root')
})


This route path will match requests to /about.

app.get('/about', (req, res) => {
  res.send('about')
})


This route path will match requests to /random.text.

app.get('/random.text', (req, res) => {
  res.send('random.text')
})


Route paths based on string patterns


   Caution
  The string patterns in Express 5 no longer work. Please refer to the migration guide for more information.


This route path will match acd and abcd.

app.get('/ab?cd', (req, res) => {
  res.send('ab?cd')
})


This route path will match abcd, abbcd, abbbcd, and so on.

app.get('/ab+cd', (req, res) => {
  res.send('ab+cd')
})


This route path will match abcd, abxcd, abRANDOMcd, ab123cd, and so on.

app.get('/ab*cd', (req, res) => {
  res.send('ab*cd')
})


This route path will match /abe and /abcde.

app.get('/ab(cd)?e', (req, res) => {
  res.send('ab(cd)?e')
})


Route paths based on regular expressions

This route path will match anything with an “a” in it.

app.get(/a/, (req, res) => {
  res.send('/a/')
})


This route path will match butterfly and dragonfly, but not butterflyman, dragonflyman, and so on.

app.get(/.*fly$/, (req, res) => {
  res.send('/.*fly$/')
})


Route parameters

Route parameters are named URL segments that are used to capture the values specified at their position in the URL. The captured values are populated in the req.params object, with the name of the route parameter specified in the path as their respective keys.

Route path: /users/:userId/books/:bookId
Request URL: http://localhost:3000/users/34/books/8989
req.params: { "userId": "34", "bookId": "8989" }


To define routes with route parameters, simply specify the route parameters in the path of the route as shown below.

app.get('/users/:userId/books/:bookId', (req, res) => {
  res.send(req.params)
})



  The name of route parameters must be made up of “word characters” ([A-Za-z0-9_]).


Since the hyphen (-) and the dot (.) are interpreted literally, they can be used along with route parameters for useful purposes.

Route path: /flights/:from-:to
Request URL: http://localhost:3000/flights/LAX-SFO
req.params: { "from": "LAX", "to": "SFO" }


Route path: /plantae/:genus.:species
Request URL: http://localhost:3000/plantae/Prunus.persica
req.params: { "genus": "Prunus", "species": "persica" }



   Caution

  In express 5, Regexp characters are not supported in route paths, for more information please refer to the migration guide.


To have more control over the exact string that can be matched by a route parameter, you can append a regular expression in parentheses (()):

Route path: /user/:userId(\d+)
Request URL: http://localhost:3000/user/42
req.params: {"userId": "42"}



   Warning

  Because the regular expression is usually part of a literal string, be sure to escape any \ characters with an additional backslash, for example \\d+.




   Warning

  In Express 4.x, the * character in regular expressions is not interpreted in the usual way. As a workaround, use {0,} instead of *. This will likely be fixed in Express 5.



Route handlers

You can provide multiple callback functions that behave like middleware to handle a request. The only exception is that these callbacks might invoke next('route') to bypass the remaining route callbacks. You can use this mechanism to impose pre-conditions on a route, then pass control to subsequent routes if there’s no reason to proceed with the current route.

Route handlers can be in the form of a function, an array of functions, or combinations of both, as shown in the following examples.

A single callback function can handle a route. For example:

app.get('/example/a', (req, res) => {
  res.send('Hello from A!')
})


More than one callback function can handle a route (make sure you specify the next object). For example:

app.get('/example/b', (req, res, next) => {
  console.log('the response will be sent by the next function ...')
  next()
}, (req, res) => {
  res.send('Hello from B!')
})


An array of callback functions can handle a route. For example:

const cb0 = function (req, res, next) {
  console.log('CB0')
  next()
}

const cb1 = function (req, res, next) {
  console.log('CB1')
  next()
}

const cb2 = function (req, res) {
  res.send('Hello from C!')
}

app.get('/example/c', [cb0, cb1, cb2])


A combination of independent functions and arrays of functions can handle a route. For example:

const cb0 = function (req, res, next) {
  console.log('CB0')
  next()
}

const cb1 = function (req, res, next) {
  console.log('CB1')
  next()
}

app.get('/example/d', [cb0, cb1], (req, res, next) => {
  console.log('the response will be sent by the next function ...')
  next()
}, (req, res) => {
  res.send('Hello from D!')
})


Response methods

The methods on the response object (res) in the following table can send a response to the client, and terminate the request-response cycle. If none of these methods are called from a route handler, the client request will be left hanging.


  
    
      Method
      Description
    
  
  
    
      res.download()
      Prompt a file to be downloaded.
    
    
      res.end()
      End the response process.
    
    
      res.json()
      Send a JSON response.
    
    
      res.jsonp()
      Send a JSON response with JSONP support.
    
    
      res.redirect()
      Redirect a request.
    
    
      res.render()
      Render a view template.
    
    
      res.send()
      Send a response of various types.
    
    
      res.sendFile()
      Send a file as an octet stream.
    
    
      res.sendStatus()
      Set the response status code and send its string representation as the response body.
    
  


app.route()

You can create chainable route handlers for a route path by using app.route().
Because the path is specified at a single location, creating modular routes is helpful, as is reducing redundancy and typos. For more information about routes, see: Router() documentation.

Here is an example of chained route handlers that are defined by using app.route().

app.route('/book')
  .get((req, res) => {
    res.send('Get a random book')
  })
  .post((req, res) => {
    res.send('Add a book')
  })
  .put((req, res) => {
    res.send('Update the book')
  })


express.Router

Use the express.Router class to create modular, mountable route handlers. A Router instance is a complete middleware and routing system; for this reason, it is often referred to as a “mini-app”.

The following example creates a router as a module, loads a middleware function in it, defines some routes, and mounts the router module on a path in the main app.

Create a router file named birds.js in the app directory, with the following content:

const express = require('express')
const router = express.Router()

// middleware that is specific to this router
const timeLog = (req, res, next) => {
  console.log('Time: ', Date.now())
  next()
}
router.use(timeLog)

// define the home page route
router.get('/', (req, res) => {
  res.send('Birds home page')
})
// define the about route
router.get('/about', (req, res) => {
  res.send('About birds')
})

module.exports = router


Then, load the router module in the app:

const birds = require('./birds')

// ...

app.use('/birds', birds)


The app will now be able to handle requests to /birds and /birds/about, as well as call the timeLog middleware function that is specific to the route.

But if the parent route /birds has path parameters, it will not be accessible by default from the sub-routes. To make it accessible, you will need to pass the mergeParams option to the Router constructor reference.

const router = express.Router({ mergeParams: true })


              
    
    Edit this page\n\nRouting

Routing refers to how an application’s endpoints (URIs) respond to client requests.
For an introduction to routing, see Basic routing.

You define routing using methods of the Express app object that correspond to HTTP methods;
for example, app.get() to handle GET requests and app.post to handle POST requests. For a full list,
see app.METHOD. You can also use app.all() to handle all HTTP methods and app.use() to
specify middleware as the callback function (See Using middleware for details).

These routing methods specify a callback function (sometimes called “handler functions”) called when the application receives a request to the specified route (endpoint) and HTTP method. In other words, the application “listens” for requests that match the specified route(s) and method(s), and when it detects a match, it calls the specified callback function.

In fact, the routing methods can have more than one callback function as arguments.
With multiple callback functions, it is important to provide next as an argument to the callback function and then call next() within the body of the function to hand off control
to the next callback.

The following code is an example of a very basic route.

const express = require('express')
const app = express()

// respond with "hello world" when a GET request is made to the homepage
app.get('/', (req, res) => {
  res.send('hello world')
})


Route methods

A route method is derived from one of the HTTP methods, and is attached to an instance of the express class.

The following code is an example of routes that are defined for the GET and the POST methods to the root of the app.

// GET method route
app.get('/', (req, res) => {
  res.send('GET request to the homepage')
})

// POST method route
app.post('/', (req, res) => {
  res.send('POST request to the homepage')
})


Express supports methods that correspond to all HTTP request methods: get, post, and so on.
For a full list, see app.METHOD.

There is a special routing method, app.all(), used to load middleware functions at a path for all HTTP request methods. For example, the following handler is executed for requests to the route "/secret" whether using GET, POST, PUT, DELETE, or any other HTTP request method supported in the http module.

app.all('/secret', (req, res, next) => {
  console.log('Accessing the secret section ...')
  next() // pass control to the next handler
})


Route paths

Route paths, in combination with a request method, define the endpoints at which requests can be made. Route paths can be strings, string patterns, or regular expressions.


   Caution
  In express 5, the characters ?, +, *, [], and () are handled differently than in version 4, please review the migration guide for more information.



   Caution
  In express 4, regular expression characters such as $ need to be escaped with a \.




   Note

  Express uses path-to-regexp for matching the route paths; see the path-to-regexp documentation for all the possibilities in defining route paths. Express Playground Router is a handy tool for testing basic Express routes, although it does not support pattern matching.




   Warning

  Query strings are not part of the route path.



Route paths based on strings

This route path will match requests to the root route, /.

app.get('/', (req, res) => {
  res.send('root')
})


This route path will match requests to /about.

app.get('/about', (req, res) => {
  res.send('about')
})


This route path will match requests to /random.text.

app.get('/random.text', (req, res) => {
  res.send('random.text')
})


Route paths based on string patterns


   Caution
  The string patterns in Express 5 no longer work. Please refer to the migration guide for more information.


This route path will match acd and abcd.

app.get('/ab?cd', (req, res) => {
  res.send('ab?cd')
})


This route path will match abcd, abbcd, abbbcd, and so on.

app.get('/ab+cd', (req, res) => {
  res.send('ab+cd')
})


This route path will match abcd, abxcd, abRANDOMcd, ab123cd, and so on.

app.get('/ab*cd', (req, res) => {
  res.send('ab*cd')
})


This route path will match /abe and /abcde.

app.get('/ab(cd)?e', (req, res) => {
  res.send('ab(cd)?e')
})


Route paths based on regular expressions

This route path will match anything with an “a” in it.

app.get(/a/, (req, res) => {
  res.send('/a/')
})


This route path will match butterfly and dragonfly, but not butterflyman, dragonflyman, and so on.

app.get(/.*fly$/, (req, res) => {
  res.send('/.*fly$/')
})


Route parameters

Route parameters are named URL segments that are used to capture the values specified at their position in the URL. The captured values are populated in the req.params object, with the name of the route parameter specified in the path as their respective keys.

Route path: /users/:userId/books/:bookId
Request URL: http://localhost:3000/users/34/books/8989
req.params: { "userId": "34", "bookId": "8989" }


To define routes with route parameters, simply specify the route parameters in the path of the route as shown below.

app.get('/users/:userId/books/:bookId', (req, res) => {
  res.send(req.params)
})



  The name of route parameters must be made up of “word characters” ([A-Za-z0-9_]).


Since the hyphen (-) and the dot (.) are interpreted literally, they can be used along with route parameters for useful purposes.

Route path: /flights/:from-:to
Request URL: http://localhost:3000/flights/LAX-SFO
req.params: { "from": "LAX", "to": "SFO" }


Route path: /plantae/:genus.:species
Request URL: http://localhost:3000/plantae/Prunus.persica
req.params: { "genus": "Prunus", "species": "persica" }



   Caution

  In express 5, Regexp characters are not supported in route paths, for more information please refer to the migration guide.


To have more control over the exact string that can be matched by a route parameter, you can append a regular expression in parentheses (()):

Route path: /user/:userId(\d+)
Request URL: http://localhost:3000/user/42
req.params: {"userId": "42"}



   Warning

  Because the regular expression is usually part of a literal string, be sure to escape any \ characters with an additional backslash, for example \\d+.




   Warning

  In Express 4.x, the * character in regular expressions is not interpreted in the usual way. As a workaround, use {0,} instead of *. This will likely be fixed in Express 5.



Route handlers

You can provide multiple callback functions that behave like middleware to handle a request. The only exception is that these callbacks might invoke next('route') to bypass the remaining route callbacks. You can use this mechanism to impose pre-conditions on a route, then pass control to subsequent routes if there’s no reason to proceed with the current route.

Route handlers can be in the form of a function, an array of functions, or combinations of both, as shown in the following examples.

A single callback function can handle a route. For example:

app.get('/example/a', (req, res) => {
  res.send('Hello from A!')
})


More than one callback function can handle a route (make sure you specify the next object). For example:

app.get('/example/b', (req, res, next) => {
  console.log('the response will be sent by the next function ...')
  next()
}, (req, res) => {
  res.send('Hello from B!')
})


An array of callback functions can handle a route. For example:

const cb0 = function (req, res, next) {
  console.log('CB0')
  next()
}

const cb1 = function (req, res, next) {
  console.log('CB1')
  next()
}

const cb2 = function (req, res) {
  res.send('Hello from C!')
}

app.get('/example/c', [cb0, cb1, cb2])


A combination of independent functions and arrays of functions can handle a route. For example:

const cb0 = function (req, res, next) {
  console.log('CB0')
  next()
}

const cb1 = function (req, res, next) {
  console.log('CB1')
  next()
}

app.get('/example/d', [cb0, cb1], (req, res, next) => {
  console.log('the response will be sent by the next function ...')
  next()
}, (req, res) => {
  res.send('Hello from D!')
})


Response methods

The methods on the response object (res) in the following table can send a response to the client, and terminate the request-response cycle. If none of these methods are called from a route handler, the client request will be left hanging.


  
    
      Method
      Description
    
  
  
    
      res.download()
      Prompt a file to be downloaded.
    
    
      res.end()
      End the response process.
    
    
      res.json()
      Send a JSON response.
    
    
      res.jsonp()
      Send a JSON response with JSONP support.
    
    
      res.redirect()
      Redirect a request.
    
    
      res.render()
      Render a view template.
    
    
      res.send()
      Send a response of various types.
    
    
      res.sendFile()
      Send a file as an octet stream.
    
    
      res.sendStatus()
      Set the response status code and send its string representation as the response body.
    
  


app.route()

You can create chainable route handlers for a route path by using app.route().
Because the path is specified at a single location, creating modular routes is helpful, as is reducing redundancy and typos. For more information about routes, see: Router() documentation.

Here is an example of chained route handlers that are defined by using app.route().

app.route('/book')
  .get((req, res) => {
    res.send('Get a random book')
  })
  .post((req, res) => {
    res.send('Add a book')
  })
  .put((req, res) => {
    res.send('Update the book')
  })


express.Router

Use the express.Router class to create modular, mountable route handlers. A Router instance is a complete middleware and routing system; for this reason, it is often referred to as a “mini-app”.

The following example creates a router as a module, loads a middleware function in it, defines some routes, and mounts the router module on a path in the main app.

Create a router file named birds.js in the app directory, with the following content:

const express = require('express')
const router = express.Router()

// middleware that is specific to this router
const timeLog = (req, res, next) => {
  console.log('Time: ', Date.now())
  next()
}
router.use(timeLog)

// define the home page route
router.get('/', (req, res) => {
  res.send('Birds home page')
})
// define the about route
router.get('/about', (req, res) => {
  res.send('About birds')
})

module.exports = router


Then, load the router module in the app:

const birds = require('./birds')

// ...

app.use('/birds', birds)


The app will now be able to handle requests to /birds and /birds/about, as well as call the timeLog middleware function that is specific to the route.

But if the parent route /birds has path parameters, it will not be accessible by default from the sub-routes. To make it accessible, you will need to pass the mergeParams option to the Router constructor reference.

const router = express.Router({ mergeParams: true })


              
    
    Edit this page\n\n\n\nWriting middleware for use in Express apps

Overview

Middleware functions are functions that have access to the request object (req), the response object (res), and the next function in the application’s request-response cycle. The next function is a function in the Express router which, when invoked, executes the middleware succeeding the current middleware.

Middleware functions can perform the following tasks:


  Execute any code.
  Make changes to the request and the response objects.
  End the request-response cycle.
  Call the next middleware in the stack.


If the current middleware function does not end the request-response cycle, it must call next() to pass control to the next middleware function. Otherwise, the request will be left hanging.

The following figure shows the elements of a middleware function call:






HTTP method for which the middleware function applies.

Path (route) for which the middleware function applies.

The middleware function.

Callback argument to the middleware function, called "next" by convention.

HTTP response argument to the middleware function, called "res" by convention.

HTTP request argument to the middleware function, called "req" by convention.



Starting with Express 5, middleware functions that return a Promise will call next(value) when they reject or throw an error. next will be called with either the rejected value or the thrown Error.

Example

Here is an example of a simple “Hello World” Express application.
The remainder of this article will define and add three middleware functions to the application:
one called myLogger that prints a simple log message, one called requestTime that
displays the timestamp of the HTTP request, and one called validateCookies that validates incoming cookies.

const express = require('express')
const app = express()

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(3000)


Middleware function myLogger
Here is a simple example of a middleware function called “myLogger”. This function just prints “LOGGED” when a request to the app passes through it. The middleware function is assigned to a variable named myLogger.

const myLogger = function (req, res, next) {
  console.log('LOGGED')
  next()
}



  Notice the call above to next(). Calling this function invokes the next middleware function in the app.
The next() function is not a part of the Node.js or Express API, but is the third argument that is passed to the middleware function. The next() function could be named anything, but by convention it is always named “next”.
To avoid confusion, always use this convention.


To load the middleware function, call app.use(), specifying the middleware function.
For example, the following code loads the myLogger middleware function before the route to the root path (/).

const express = require('express')
const app = express()

const myLogger = function (req, res, next) {
  console.log('LOGGED')
  next()
}

app.use(myLogger)

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(3000)


Every time the app receives a request, it prints the message “LOGGED” to the terminal.

The order of middleware loading is important: middleware functions that are loaded first are also executed first.

If myLogger is loaded after the route to the root path, the request never reaches it and the app doesn’t print “LOGGED”, because the route handler of the root path terminates the request-response cycle.

The middleware function myLogger simply prints a message, then passes on the request to the next middleware function in the stack by calling the next() function.

Middleware function requestTime

Next, we’ll create a middleware function called “requestTime” and add a property called requestTime
to the request object.

const requestTime = function (req, res, next) {
  req.requestTime = Date.now()
  next()
}


The app now uses the requestTime middleware function. Also, the callback function of the root path route uses the property that the middleware function adds to req (the request object).

const express = require('express')
const app = express()

const requestTime = function (req, res, next) {
  req.requestTime = Date.now()
  next()
}

app.use(requestTime)

app.get('/', (req, res) => {
  let responseText = 'Hello World!<br>'
  responseText += `<small>Requested at: ${req.requestTime}</small>`
  res.send(responseText)
})

app.listen(3000)


When you make a request to the root of the app, the app now displays the timestamp of your request in the browser.

Middleware function validateCookies

Finally, we’ll create a middleware function that validates incoming cookies and sends a 400 response if cookies are invalid.

Here’s an example function that validates cookies with an external async service.

async function cookieValidator (cookies) {
  try {
    await externallyValidateCookie(cookies.testCookie)
  } catch {
    throw new Error('Invalid cookies')
  }
}


Here, we use the cookie-parser middleware to parse incoming cookies off the req object and pass them to our cookieValidator function. The validateCookies middleware returns a Promise that upon rejection will automatically trigger our error handler.

const express = require('express')
const cookieParser = require('cookie-parser')
const cookieValidator = require('./cookieValidator')

const app = express()

async function validateCookies (req, res, next) {
  await cookieValidator(req.cookies)
  next()
}

app.use(cookieParser())

app.use(validateCookies)

// error handler
app.use((err, req, res, next) => {
  res.status(400).send(err.message)
})

app.listen(3000)



  Note how next() is called after await cookieValidator(req.cookies). This ensures that if cookieValidator resolves, the next middleware in the stack will get called. If you pass anything to the next() function (except the string 'route' or 'router'), Express regards the current request as being an error and will skip any remaining non-error handling routing and middleware functions.


Because you have access to the request object, the response object, the next middleware function in the stack, and the whole Node.js API, the possibilities with middleware functions are endless.

For more information about Express middleware, see: Using Express middleware.

Configurable middleware

If you need your middleware to be configurable, export a function which accepts an options object or other parameters, which, then returns the middleware implementation based on the input parameters.

File: my-middleware.js

module.exports = function (options) {
  return function (req, res, next) {
    // Implement the middleware function based on the options object
    next()
  }
}


The middleware can now be used as shown below.

const mw = require('./my-middleware.js')

app.use(mw({ option1: '1', option2: '2' }))


Refer to cookie-session and compression for examples of configurable middleware.

              
    
    Edit this page\n\nWriting middleware for use in Express apps

Overview

Middleware functions are functions that have access to the request object (req), the response object (res), and the next function in the application’s request-response cycle. The next function is a function in the Express router which, when invoked, executes the middleware succeeding the current middleware.

Middleware functions can perform the following tasks:


  Execute any code.
  Make changes to the request and the response objects.
  End the request-response cycle.
  Call the next middleware in the stack.


If the current middleware function does not end the request-response cycle, it must call next() to pass control to the next middleware function. Otherwise, the request will be left hanging.

The following figure shows the elements of a middleware function call:






HTTP method for which the middleware function applies.

Path (route) for which the middleware function applies.

The middleware function.

Callback argument to the middleware function, called "next" by convention.

HTTP response argument to the middleware function, called "res" by convention.

HTTP request argument to the middleware function, called "req" by convention.



Starting with Express 5, middleware functions that return a Promise will call next(value) when they reject or throw an error. next will be called with either the rejected value or the thrown Error.

Example

Here is an example of a simple “Hello World” Express application.
The remainder of this article will define and add three middleware functions to the application:
one called myLogger that prints a simple log message, one called requestTime that
displays the timestamp of the HTTP request, and one called validateCookies that validates incoming cookies.

const express = require('express')
const app = express()

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(3000)


Middleware function myLogger
Here is a simple example of a middleware function called “myLogger”. This function just prints “LOGGED” when a request to the app passes through it. The middleware function is assigned to a variable named myLogger.

const myLogger = function (req, res, next) {
  console.log('LOGGED')
  next()
}



  Notice the call above to next(). Calling this function invokes the next middleware function in the app.
The next() function is not a part of the Node.js or Express API, but is the third argument that is passed to the middleware function. The next() function could be named anything, but by convention it is always named “next”.
To avoid confusion, always use this convention.


To load the middleware function, call app.use(), specifying the middleware function.
For example, the following code loads the myLogger middleware function before the route to the root path (/).

const express = require('express')
const app = express()

const myLogger = function (req, res, next) {
  console.log('LOGGED')
  next()
}

app.use(myLogger)

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(3000)


Every time the app receives a request, it prints the message “LOGGED” to the terminal.

The order of middleware loading is important: middleware functions that are loaded first are also executed first.

If myLogger is loaded after the route to the root path, the request never reaches it and the app doesn’t print “LOGGED”, because the route handler of the root path terminates the request-response cycle.

The middleware function myLogger simply prints a message, then passes on the request to the next middleware function in the stack by calling the next() function.

Middleware function requestTime

Next, we’ll create a middleware function called “requestTime” and add a property called requestTime
to the request object.

const requestTime = function (req, res, next) {
  req.requestTime = Date.now()
  next()
}


The app now uses the requestTime middleware function. Also, the callback function of the root path route uses the property that the middleware function adds to req (the request object).

const express = require('express')
const app = express()

const requestTime = function (req, res, next) {
  req.requestTime = Date.now()
  next()
}

app.use(requestTime)

app.get('/', (req, res) => {
  let responseText = 'Hello World!<br>'
  responseText += `<small>Requested at: ${req.requestTime}</small>`
  res.send(responseText)
})

app.listen(3000)


When you make a request to the root of the app, the app now displays the timestamp of your request in the browser.

Middleware function validateCookies

Finally, we’ll create a middleware function that validates incoming cookies and sends a 400 response if cookies are invalid.

Here’s an example function that validates cookies with an external async service.

async function cookieValidator (cookies) {
  try {
    await externallyValidateCookie(cookies.testCookie)
  } catch {
    throw new Error('Invalid cookies')
  }
}


Here, we use the cookie-parser middleware to parse incoming cookies off the req object and pass them to our cookieValidator function. The validateCookies middleware returns a Promise that upon rejection will automatically trigger our error handler.

const express = require('express')
const cookieParser = require('cookie-parser')
const cookieValidator = require('./cookieValidator')

const app = express()

async function validateCookies (req, res, next) {
  await cookieValidator(req.cookies)
  next()
}

app.use(cookieParser())

app.use(validateCookies)

// error handler
app.use((err, req, res, next) => {
  res.status(400).send(err.message)
})

app.listen(3000)



  Note how next() is called after await cookieValidator(req.cookies). This ensures that if cookieValidator resolves, the next middleware in the stack will get called. If you pass anything to the next() function (except the string 'route' or 'router'), Express regards the current request as being an error and will skip any remaining non-error handling routing and middleware functions.


Because you have access to the request object, the response object, the next middleware function in the stack, and the whole Node.js API, the possibilities with middleware functions are endless.

For more information about Express middleware, see: Using Express middleware.

Configurable middleware

If you need your middleware to be configurable, export a function which accepts an options object or other parameters, which, then returns the middleware implementation based on the input parameters.

File: my-middleware.js

module.exports = function (options) {
  return function (req, res, next) {
    // Implement the middleware function based on the options object
    next()
  }
}


The middleware can now be used as shown below.

const mw = require('./my-middleware.js')

app.use(mw({ option1: '1', option2: '2' }))


Refer to cookie-session and compression for examples of configurable middleware.

              
    
    Edit this page\n\n\n\nUsing middleware

Express is a routing and middleware web framework that has minimal functionality of its own: An Express application is essentially a series of middleware function calls.

Middleware functions are functions that have access to the request object  (req), the response object (res), and the next middleware function in the application’s request-response cycle. The next middleware function is commonly denoted by a variable named next.

Middleware functions can perform the following tasks:


  Execute any code.
  Make changes to the request and the response objects.
  End the request-response cycle.
  Call the next middleware function in the stack.


If the current middleware function does not end the request-response cycle, it must call next() to pass control to the next middleware function. Otherwise, the request will be left hanging.

An Express application can use the following types of middleware:


  Application-level middleware
  Router-level middleware
  Error-handling middleware
  Built-in middleware
  Third-party middleware


You can load application-level and router-level middleware with an optional mount path.
You can also load a series of middleware functions together, which creates a sub-stack of the middleware system at a mount point.

Application-level middleware

Bind application-level middleware to an instance of the app object by using the app.use() and app.METHOD() functions, where METHOD is the HTTP method of the request that the middleware function handles (such as GET, PUT, or POST) in lowercase.

This example shows a middleware function with no mount path. The function is executed every time the app receives a request.

const express = require('express')
const app = express()

app.use((req, res, next) => {
  console.log('Time:', Date.now())
  next()
})


This example shows a middleware function mounted on the /user/:id path. The function is executed for any type of
HTTP request on the /user/:id path.

app.use('/user/:id', (req, res, next) => {
  console.log('Request Type:', req.method)
  next()
})


This example shows a route and its handler function (middleware system). The function handles GET requests to the /user/:id path.

app.get('/user/:id', (req, res, next) => {
  res.send('USER')
})


Here is an example of loading a series of middleware functions at a mount point, with a mount path.
It illustrates a middleware sub-stack that prints request info for any type of HTTP request to the /user/:id path.

app.use('/user/:id', (req, res, next) => {
  console.log('Request URL:', req.originalUrl)
  next()
}, (req, res, next) => {
  console.log('Request Type:', req.method)
  next()
})


Route handlers enable you to define multiple routes for a path. The example below defines two routes for GET requests to the /user/:id path. The second route will not cause any problems, but it will never get called because the first route ends the request-response cycle.

This example shows a middleware sub-stack that handles GET requests to the /user/:id path.

app.get('/user/:id', (req, res, next) => {
  console.log('ID:', req.params.id)
  next()
}, (req, res, next) => {
  res.send('User Info')
})

// handler for the /user/:id path, which prints the user ID
app.get('/user/:id', (req, res, next) => {
  res.send(req.params.id)
})


To skip the rest of the middleware functions from a router middleware stack, call next('route') to pass control to the next route.


   Note

  next('route') will work only in middleware functions that were loaded by using the app.METHOD() or router.METHOD() functions.



This example shows a middleware sub-stack that handles GET requests to the /user/:id path.

app.get('/user/:id', (req, res, next) => {
  // if the user ID is 0, skip to the next route
  if (req.params.id === '0') next('route')
  // otherwise pass the control to the next middleware function in this stack
  else next()
}, (req, res, next) => {
  // send a regular response
  res.send('regular')
})

// handler for the /user/:id path, which sends a special response
app.get('/user/:id', (req, res, next) => {
  res.send('special')
})


Middleware can also be declared in an array for reusability.

This example shows an array with a middleware sub-stack that handles GET requests to the /user/:id path

function logOriginalUrl (req, res, next) {
  console.log('Request URL:', req.originalUrl)
  next()
}

function logMethod (req, res, next) {
  console.log('Request Type:', req.method)
  next()
}

const logStuff = [logOriginalUrl, logMethod]
app.get('/user/:id', logStuff, (req, res, next) => {
  res.send('User Info')
})


Router-level middleware

Router-level middleware works in the same way as application-level middleware, except it is bound to an instance of express.Router().

const router = express.Router()

Load router-level middleware by using the router.use() and router.METHOD() functions.

The following example code replicates the middleware system that is shown above for application-level middleware, by using router-level middleware:

const express = require('express')
const app = express()
const router = express.Router()

// a middleware function with no mount path. This code is executed for every request to the router
router.use((req, res, next) => {
  console.log('Time:', Date.now())
  next()
})

// a middleware sub-stack shows request info for any type of HTTP request to the /user/:id path
router.use('/user/:id', (req, res, next) => {
  console.log('Request URL:', req.originalUrl)
  next()
}, (req, res, next) => {
  console.log('Request Type:', req.method)
  next()
})

// a middleware sub-stack that handles GET requests to the /user/:id path
router.get('/user/:id', (req, res, next) => {
  // if the user ID is 0, skip to the next router
  if (req.params.id === '0') next('route')
  // otherwise pass control to the next middleware function in this stack
  else next()
}, (req, res, next) => {
  // render a regular page
  res.render('regular')
})

// handler for the /user/:id path, which renders a special page
router.get('/user/:id', (req, res, next) => {
  console.log(req.params.id)
  res.render('special')
})

// mount the router on the app
app.use('/', router)


To skip the rest of the router’s middleware functions, call next('router')
to pass control back out of the router instance.

This example shows a middleware sub-stack that handles GET requests to the /user/:id path.

const express = require('express')
const app = express()
const router = express.Router()

// predicate the router with a check and bail out when needed
router.use((req, res, next) => {
  if (!req.headers['x-auth']) return next('router')
  next()
})

router.get('/user/:id', (req, res) => {
  res.send('hello, user!')
})

// use the router and 401 anything falling through
app.use('/admin', router, (req, res) => {
  res.sendStatus(401)
})


Error-handling middleware


  Error-handling middleware always takes four arguments. You must provide four arguments to identify it as an error-handling middleware function. Even if you don’t need to use the next object, you must specify it to maintain the signature. Otherwise, the next object will be interpreted as regular middleware and will fail to handle errors.


Define error-handling middleware functions in the same way as other middleware functions, except with four arguments instead of three, specifically with the signature (err, req, res, next):

app.use((err, req, res, next) => {
  console.error(err.stack)
  res.status(500).send('Something broke!')
})


For details about error-handling middleware, see: Error handling.

Built-in middleware

Starting with version 4.x, Express no longer depends on Connect. The middleware
functions that were previously included with Express are now in separate modules; see the list of middleware functions.

Express has the following built-in middleware functions:


  express.static serves static assets such as HTML files, images, and so on.
  express.json parses incoming requests with JSON payloads. NOTE: Available with Express 4.16.0+
  express.urlencoded parses incoming requests with URL-encoded payloads.  NOTE: Available with Express 4.16.0+


Third-party middleware

Use third-party middleware to add functionality to Express apps.

Install the Node.js module for the required functionality, then load it in your app at the application level or at the router level.

The following example illustrates installing and loading the cookie-parsing middleware function cookie-parser.

$ npm install cookie-parser


const express = require('express')
const app = express()
const cookieParser = require('cookie-parser')

// load the cookie-parsing middleware
app.use(cookieParser())


For a partial list of third-party middleware functions that are commonly used with Express, see: Third-party middleware.

              
    
    Edit this page\n\nUsing middleware

Express is a routing and middleware web framework that has minimal functionality of its own: An Express application is essentially a series of middleware function calls.

Middleware functions are functions that have access to the request object  (req), the response object (res), and the next middleware function in the application’s request-response cycle. The next middleware function is commonly denoted by a variable named next.

Middleware functions can perform the following tasks:


  Execute any code.
  Make changes to the request and the response objects.
  End the request-response cycle.
  Call the next middleware function in the stack.


If the current middleware function does not end the request-response cycle, it must call next() to pass control to the next middleware function. Otherwise, the request will be left hanging.

An Express application can use the following types of middleware:


  Application-level middleware
  Router-level middleware
  Error-handling middleware
  Built-in middleware
  Third-party middleware


You can load application-level and router-level middleware with an optional mount path.
You can also load a series of middleware functions together, which creates a sub-stack of the middleware system at a mount point.

Application-level middleware

Bind application-level middleware to an instance of the app object by using the app.use() and app.METHOD() functions, where METHOD is the HTTP method of the request that the middleware function handles (such as GET, PUT, or POST) in lowercase.

This example shows a middleware function with no mount path. The function is executed every time the app receives a request.

const express = require('express')
const app = express()

app.use((req, res, next) => {
  console.log('Time:', Date.now())
  next()
})


This example shows a middleware function mounted on the /user/:id path. The function is executed for any type of
HTTP request on the /user/:id path.

app.use('/user/:id', (req, res, next) => {
  console.log('Request Type:', req.method)
  next()
})


This example shows a route and its handler function (middleware system). The function handles GET requests to the /user/:id path.

app.get('/user/:id', (req, res, next) => {
  res.send('USER')
})


Here is an example of loading a series of middleware functions at a mount point, with a mount path.
It illustrates a middleware sub-stack that prints request info for any type of HTTP request to the /user/:id path.

app.use('/user/:id', (req, res, next) => {
  console.log('Request URL:', req.originalUrl)
  next()
}, (req, res, next) => {
  console.log('Request Type:', req.method)
  next()
})


Route handlers enable you to define multiple routes for a path. The example below defines two routes for GET requests to the /user/:id path. The second route will not cause any problems, but it will never get called because the first route ends the request-response cycle.

This example shows a middleware sub-stack that handles GET requests to the /user/:id path.

app.get('/user/:id', (req, res, next) => {
  console.log('ID:', req.params.id)
  next()
}, (req, res, next) => {
  res.send('User Info')
})

// handler for the /user/:id path, which prints the user ID
app.get('/user/:id', (req, res, next) => {
  res.send(req.params.id)
})


To skip the rest of the middleware functions from a router middleware stack, call next('route') to pass control to the next route.


   Note

  next('route') will work only in middleware functions that were loaded by using the app.METHOD() or router.METHOD() functions.



This example shows a middleware sub-stack that handles GET requests to the /user/:id path.

app.get('/user/:id', (req, res, next) => {
  // if the user ID is 0, skip to the next route
  if (req.params.id === '0') next('route')
  // otherwise pass the control to the next middleware function in this stack
  else next()
}, (req, res, next) => {
  // send a regular response
  res.send('regular')
})

// handler for the /user/:id path, which sends a special response
app.get('/user/:id', (req, res, next) => {
  res.send('special')
})


Middleware can also be declared in an array for reusability.

This example shows an array with a middleware sub-stack that handles GET requests to the /user/:id path

function logOriginalUrl (req, res, next) {
  console.log('Request URL:', req.originalUrl)
  next()
}

function logMethod (req, res, next) {
  console.log('Request Type:', req.method)
  next()
}

const logStuff = [logOriginalUrl, logMethod]
app.get('/user/:id', logStuff, (req, res, next) => {
  res.send('User Info')
})


Router-level middleware

Router-level middleware works in the same way as application-level middleware, except it is bound to an instance of express.Router().

const router = express.Router()

Load router-level middleware by using the router.use() and router.METHOD() functions.

The following example code replicates the middleware system that is shown above for application-level middleware, by using router-level middleware:

const express = require('express')
const app = express()
const router = express.Router()

// a middleware function with no mount path. This code is executed for every request to the router
router.use((req, res, next) => {
  console.log('Time:', Date.now())
  next()
})

// a middleware sub-stack shows request info for any type of HTTP request to the /user/:id path
router.use('/user/:id', (req, res, next) => {
  console.log('Request URL:', req.originalUrl)
  next()
}, (req, res, next) => {
  console.log('Request Type:', req.method)
  next()
})

// a middleware sub-stack that handles GET requests to the /user/:id path
router.get('/user/:id', (req, res, next) => {
  // if the user ID is 0, skip to the next router
  if (req.params.id === '0') next('route')
  // otherwise pass control to the next middleware function in this stack
  else next()
}, (req, res, next) => {
  // render a regular page
  res.render('regular')
})

// handler for the /user/:id path, which renders a special page
router.get('/user/:id', (req, res, next) => {
  console.log(req.params.id)
  res.render('special')
})

// mount the router on the app
app.use('/', router)


To skip the rest of the router’s middleware functions, call next('router')
to pass control back out of the router instance.

This example shows a middleware sub-stack that handles GET requests to the /user/:id path.

const express = require('express')
const app = express()
const router = express.Router()

// predicate the router with a check and bail out when needed
router.use((req, res, next) => {
  if (!req.headers['x-auth']) return next('router')
  next()
})

router.get('/user/:id', (req, res) => {
  res.send('hello, user!')
})

// use the router and 401 anything falling through
app.use('/admin', router, (req, res) => {
  res.sendStatus(401)
})


Error-handling middleware


  Error-handling middleware always takes four arguments. You must provide four arguments to identify it as an error-handling middleware function. Even if you don’t need to use the next object, you must specify it to maintain the signature. Otherwise, the next object will be interpreted as regular middleware and will fail to handle errors.


Define error-handling middleware functions in the same way as other middleware functions, except with four arguments instead of three, specifically with the signature (err, req, res, next):

app.use((err, req, res, next) => {
  console.error(err.stack)
  res.status(500).send('Something broke!')
})


For details about error-handling middleware, see: Error handling.

Built-in middleware

Starting with version 4.x, Express no longer depends on Connect. The middleware
functions that were previously included with Express are now in separate modules; see the list of middleware functions.

Express has the following built-in middleware functions:


  express.static serves static assets such as HTML files, images, and so on.
  express.json parses incoming requests with JSON payloads. NOTE: Available with Express 4.16.0+
  express.urlencoded parses incoming requests with URL-encoded payloads.  NOTE: Available with Express 4.16.0+


Third-party middleware

Use third-party middleware to add functionality to Express apps.

Install the Node.js module for the required functionality, then load it in your app at the application level or at the router level.

The following example illustrates installing and loading the cookie-parsing middleware function cookie-parser.

$ npm install cookie-parser


const express = require('express')
const app = express()
const cookieParser = require('cookie-parser')

// load the cookie-parsing middleware
app.use(cookieParser())


For a partial list of third-party middleware functions that are commonly used with Express, see: Third-party middleware.

              
    
    Edit this page\n\n\n\nOverriding the Express API

The Express API consists of various methods and properties on the request and response objects. These are inherited by prototype. There are two extension points for the Express API:


  The global prototypes at express.request and express.response.
  App-specific prototypes at app.request and app.response.


Altering the global prototypes will affect all loaded Express apps in the same process. If desired, alterations can be made app-specific by only altering the app-specific prototypes after creating a new app.

Methods

You can override the signature and behavior of existing methods with your own, by assigning a custom function.

Following is an example of overriding the behavior of res.sendStatus.

app.response.sendStatus = function (statusCode, type, message) {
  // code is intentionally kept simple for demonstration purpose
  return this.contentType(type)
    .status(statusCode)
    .send(message)
}


The above implementation completely changes the original signature of res.sendStatus. It now accepts a status code, encoding type, and the message to be sent to the client.

The overridden method may now be used this way:

res.sendStatus(404, 'application/json', '{"error":"resource not found"}')


Properties

Properties in the Express API are either:


  Assigned properties (ex: req.baseUrl, req.originalUrl)
  Defined as getters (ex: req.secure, req.ip)


Since properties under category 1 are dynamically assigned on the request and response objects in the context of the current request-response cycle, their behavior cannot be overridden.

Properties under category 2 can be overwritten using the Express API extensions API.

The following code rewrites how the value of req.ip is to be derived. Now, it simply returns the value of the Client-IP request header.

Object.defineProperty(app.request, 'ip', {
  configurable: true,
  enumerable: true,
  get () { return this.get('Client-IP') }
})


Prototype

In order to provide the Express API, the request/response objects passed to Express (via app(req, res), for example) need to inherit from the same prototype chain. By default, this is http.IncomingRequest.prototype for the request and http.ServerResponse.prototype for the response.

Unless necessary, it is recommended that this be done only at the application level, rather than globally. Also, take care that the prototype that is being used matches the functionality as closely as possible to the default prototypes.

// Use FakeRequest and FakeResponse in place of http.IncomingRequest and http.ServerResponse
// for the given app reference
Object.setPrototypeOf(Object.getPrototypeOf(app.request), FakeRequest.prototype)
Object.setPrototypeOf(Object.getPrototypeOf(app.response), FakeResponse.prototype)


              
    
    Edit this page\n\nOverriding the Express API

The Express API consists of various methods and properties on the request and response objects. These are inherited by prototype. There are two extension points for the Express API:


  The global prototypes at express.request and express.response.
  App-specific prototypes at app.request and app.response.


Altering the global prototypes will affect all loaded Express apps in the same process. If desired, alterations can be made app-specific by only altering the app-specific prototypes after creating a new app.

Methods

You can override the signature and behavior of existing methods with your own, by assigning a custom function.

Following is an example of overriding the behavior of res.sendStatus.

app.response.sendStatus = function (statusCode, type, message) {
  // code is intentionally kept simple for demonstration purpose
  return this.contentType(type)
    .status(statusCode)
    .send(message)
}


The above implementation completely changes the original signature of res.sendStatus. It now accepts a status code, encoding type, and the message to be sent to the client.

The overridden method may now be used this way:

res.sendStatus(404, 'application/json', '{"error":"resource not found"}')


Properties

Properties in the Express API are either:


  Assigned properties (ex: req.baseUrl, req.originalUrl)
  Defined as getters (ex: req.secure, req.ip)


Since properties under category 1 are dynamically assigned on the request and response objects in the context of the current request-response cycle, their behavior cannot be overridden.

Properties under category 2 can be overwritten using the Express API extensions API.

The following code rewrites how the value of req.ip is to be derived. Now, it simply returns the value of the Client-IP request header.

Object.defineProperty(app.request, 'ip', {
  configurable: true,
  enumerable: true,
  get () { return this.get('Client-IP') }
})


Prototype

In order to provide the Express API, the request/response objects passed to Express (via app(req, res), for example) need to inherit from the same prototype chain. By default, this is http.IncomingRequest.prototype for the request and http.ServerResponse.prototype for the response.

Unless necessary, it is recommended that this be done only at the application level, rather than globally. Also, take care that the prototype that is being used matches the functionality as closely as possible to the default prototypes.

// Use FakeRequest and FakeResponse in place of http.IncomingRequest and http.ServerResponse
// for the given app reference
Object.setPrototypeOf(Object.getPrototypeOf(app.request), FakeRequest.prototype)
Object.setPrototypeOf(Object.getPrototypeOf(app.response), FakeResponse.prototype)


              
    
    Edit this page\n\n\n\nUsing template engines with Express

A template engine enables you to use static template files in your application. At runtime, the template engine replaces
variables in a template file with actual values, and transforms the template into an HTML file sent to the client.
This approach makes it easier to design an HTML page.

The Express application generator uses Pug as its default, but it also supports Handlebars, and EJS, among others.

To render template files, set the following application setting properties, in the default app.js created by the generator:


  views, the directory where the template files are located. Eg: app.set('views', './views').
This defaults to the views directory in the application root directory.
  view engine, the template engine to use. For example, to use the Pug template engine: app.set('view engine', 'pug').


Then install the corresponding template engine npm package; for example to install Pug:

$ npm install pug --save



  Express-compliant template engines such as Pug export a function named __express(filePath, options, callback),
which res.render() calls to render the template code.

  Some template engines do not follow this convention. The @ladjs/consolidate
library follows this convention by mapping all of the popular Node.js template engines, and therefore works seamlessly within Express.


After the view engine is set, you don’t have to specify the engine or load the template engine module in your app;
Express loads the module internally, for example:

app.set('view engine', 'pug')


Then, create a Pug template file named index.pug in the views directory, with the following content:

html
  head
    title= title
  body
    h1= message


Create a route to render the index.pug file. If the view engine property is not set,
you must specify the extension of the view file. Otherwise, you can omit it.

app.get('/', (req, res) => {
  res.render('index', { title: 'Hey', message: 'Hello there!' })
})


When you make a request to the home page, the index.pug file will be rendered as HTML.

The view engine cache does not cache the contents of the template’s output, only the underlying template itself. The view is still re-rendered with every request even when the cache is on.

              
    
    Edit this page\n\nUsing template engines with Express

A template engine enables you to use static template files in your application. At runtime, the template engine replaces
variables in a template file with actual values, and transforms the template into an HTML file sent to the client.
This approach makes it easier to design an HTML page.

The Express application generator uses Pug as its default, but it also supports Handlebars, and EJS, among others.

To render template files, set the following application setting properties, in the default app.js created by the generator:


  views, the directory where the template files are located. Eg: app.set('views', './views').
This defaults to the views directory in the application root directory.
  view engine, the template engine to use. For example, to use the Pug template engine: app.set('view engine', 'pug').


Then install the corresponding template engine npm package; for example to install Pug:

$ npm install pug --save



  Express-compliant template engines such as Pug export a function named __express(filePath, options, callback),
which res.render() calls to render the template code.

  Some template engines do not follow this convention. The @ladjs/consolidate
library follows this convention by mapping all of the popular Node.js template engines, and therefore works seamlessly within Express.


After the view engine is set, you don’t have to specify the engine or load the template engine module in your app;
Express loads the module internally, for example:

app.set('view engine', 'pug')


Then, create a Pug template file named index.pug in the views directory, with the following content:

html
  head
    title= title
  body
    h1= message


Create a route to render the index.pug file. If the view engine property is not set,
you must specify the extension of the view file. Otherwise, you can omit it.

app.get('/', (req, res) => {
  res.render('index', { title: 'Hey', message: 'Hello there!' })
})


When you make a request to the home page, the index.pug file will be rendered as HTML.

The view engine cache does not cache the contents of the template’s output, only the underlying template itself. The view is still re-rendered with every request even when the cache is on.

              
    
    Edit this page\n\n\n\nError Handling

Error Handling refers to how Express catches and processes errors that
occur both synchronously and asynchronously. Express comes with a default error
handler so you don’t need to write your own to get started.

Catching Errors

It’s important to ensure that Express catches all errors that occur while
running route handlers and middleware.

Errors that occur in synchronous code inside route handlers and middleware
require no extra work. If synchronous code throws an error, then Express will
catch and process it. For example:

app.get('/', (req, res) => {
  throw new Error('BROKEN') // Express will catch this on its own.
})


For errors returned from asynchronous functions invoked by route handlers
and middleware, you must pass them to the next() function, where Express will
catch and process them.  For example:

app.get('/', (req, res, next) => {
  fs.readFile('/file-does-not-exist', (err, data) => {
    if (err) {
      next(err) // Pass errors to Express.
    } else {
      res.send(data)
    }
  })
})


Starting with Express 5, route handlers and middleware that return a Promise
will call next(value) automatically when they reject or throw an error.
For example:

app.get('/user/:id', async (req, res, next) => {
  const user = await getUserById(req.params.id)
  res.send(user)
})


If getUserById throws an error or rejects, next will be called with either
the thrown error or the rejected value. If no rejected value is provided, next
will be called with a default Error object provided by the Express router.

If you pass anything to the next() function (except the string 'route'),
Express regards the current request as being an error and will skip any
remaining non-error handling routing and middleware functions.

If the callback in a sequence provides no data, only errors, you can simplify
this code as follows:

app.get('/', [
  function (req, res, next) {
    fs.writeFile('/inaccessible-path', 'data', next)
  },
  function (req, res) {
    res.send('OK')
  }
])


In the above example, next is provided as the callback for fs.writeFile,
which is called with or without errors. If there is no error, the second
handler is executed, otherwise Express catches and processes the error.

You must catch errors that occur in asynchronous code invoked by route handlers or
middleware and pass them to Express for processing. For example:

app.get('/', (req, res, next) => {
  setTimeout(() => {
    try {
      throw new Error('BROKEN')
    } catch (err) {
      next(err)
    }
  }, 100)
})


The above example uses a try...catch block to catch errors in the
asynchronous code and pass them to Express. If the try...catch
block were omitted, Express would not catch the error since it is not part of the synchronous
handler code.

Use promises to avoid the overhead of the try...catch block or when using functions
that return promises.  For example:

app.get('/', (req, res, next) => {
  Promise.resolve().then(() => {
    throw new Error('BROKEN')
  }).catch(next) // Errors will be passed to Express.
})


Since promises automatically catch both synchronous errors and rejected promises,
you can simply provide next as the final catch handler and Express will catch errors,
because the catch handler is given the error as the first argument.

You could also use a chain of handlers to rely on synchronous error
catching, by reducing the asynchronous code to something trivial. For example:

app.get('/', [
  function (req, res, next) {
    fs.readFile('/maybe-valid-file', 'utf-8', (err, data) => {
      res.locals.data = data
      next(err)
    })
  },
  function (req, res) {
    res.locals.data = res.locals.data.split(',')[1]
    res.send(res.locals.data)
  }
])


The above example has a couple of trivial statements from the readFile
call. If readFile causes an error, then it passes the error to Express, otherwise you
quickly return to the world of synchronous error handling in the next handler
in the chain. Then, the example above tries to process the data. If this fails, then the
synchronous error handler will catch it. If you had done this processing inside
the readFile callback, then the application might exit and the Express error
handlers would not run.

Whichever method you use, if you want Express error handlers to be called in and the
application to survive, you must ensure that Express receives the error.

The default error handler

Express comes with a built-in error handler that takes care of any errors that might be encountered in the app. This default error-handling middleware function is added at the end of the middleware function stack.

If you pass an error to next() and you do not handle it in a custom error
handler, it will be handled by the built-in error handler; the error will be
written to the client with the stack trace. The stack trace is not included
in the production environment.


  Set the environment variable NODE_ENV to production, to run the app in production mode.


When an error is written, the following information is added to the
response:


  The res.statusCode is set from err.status (or err.statusCode). If
this value is outside the 4xx or 5xx range, it will be set to 500.
  The res.statusMessage is set according to the status code.
  The body will be the HTML of the status code message when in production
environment, otherwise will be err.stack.
  Any headers specified in an err.headers object.


If you call next() with an error after you have started writing the
response (for example, if you encounter an error while streaming the
response to the client), the Express default error handler closes the
connection and fails the request.

So when you add a custom error handler, you must delegate to
the default Express error handler, when the headers
have already been sent to the client:

function errorHandler (err, req, res, next) {
  if (res.headersSent) {
    return next(err)
  }
  res.status(500)
  res.render('error', { error: err })
}


Note that the default error handler can get triggered if you call next() with an error
in your code more than once, even if custom error handling middleware is in place.

Other error handling middleware can be found at Express middleware.

Writing error handlers

Define error-handling middleware functions in the same way as other middleware functions,
except error-handling functions have four arguments instead of three:
(err, req, res, next). For example:

app.use((err, req, res, next) => {
  console.error(err.stack)
  res.status(500).send('Something broke!')
})


You define error-handling middleware last, after other app.use() and routes calls; for example:

const bodyParser = require('body-parser')
const methodOverride = require('method-override')

app.use(bodyParser.urlencoded({
  extended: true
}))
app.use(bodyParser.json())
app.use(methodOverride())
app.use((err, req, res, next) => {
  // logic
})


Responses from within a middleware function can be in any format, such as an HTML error page, a simple message, or a JSON string.

For organizational (and higher-level framework) purposes, you can define
several error-handling middleware functions, much as you would with
regular middleware functions. For example, to define an error-handler
for requests made by using XHR and those without:

const bodyParser = require('body-parser')
const methodOverride = require('method-override')

app.use(bodyParser.urlencoded({
  extended: true
}))
app.use(bodyParser.json())
app.use(methodOverride())
app.use(logErrors)
app.use(clientErrorHandler)
app.use(errorHandler)


In this example, the generic logErrors might write request and
error information to stderr, for example:

function logErrors (err, req, res, next) {
  console.error(err.stack)
  next(err)
}


Also in this example, clientErrorHandler is defined as follows; in this case, the error is explicitly passed along to the next one.

Notice that when not calling “next” in an error-handling function, you are responsible for writing (and ending) the response. Otherwise, those requests will “hang” and will not be eligible for garbage collection.

function clientErrorHandler (err, req, res, next) {
  if (req.xhr) {
    res.status(500).send({ error: 'Something failed!' })
  } else {
    next(err)
  }
}


Implement the “catch-all” errorHandler function as follows (for example):

function errorHandler (err, req, res, next) {
  res.status(500)
  res.render('error', { error: err })
}


If you have a route handler with multiple callback functions, you can use the route parameter to skip to the next route handler. For example:

app.get('/a_route_behind_paywall',
  (req, res, next) => {
    if (!req.user.hasPaid) {
      // continue handling this request
      next('route')
    } else {
      next()
    }
  }, (req, res, next) => {
    PaidContent.find((err, doc) => {
      if (err) return next(err)
      res.json(doc)
    })
  })


In this example, the getPaidContent handler will be skipped but any remaining handlers in app for /a_route_behind_paywall would continue to be executed.


  Calls to next() and next(err) indicate that the current handler is complete and in what state.  next(err) will skip all remaining handlers in the chain except for those that are set up to handle errors as described above.


              
    
    Edit this page\n\nError Handling

Error Handling refers to how Express catches and processes errors that
occur both synchronously and asynchronously. Express comes with a default error
handler so you don’t need to write your own to get started.

Catching Errors

It’s important to ensure that Express catches all errors that occur while
running route handlers and middleware.

Errors that occur in synchronous code inside route handlers and middleware
require no extra work. If synchronous code throws an error, then Express will
catch and process it. For example:

app.get('/', (req, res) => {
  throw new Error('BROKEN') // Express will catch this on its own.
})


For errors returned from asynchronous functions invoked by route handlers
and middleware, you must pass them to the next() function, where Express will
catch and process them.  For example:

app.get('/', (req, res, next) => {
  fs.readFile('/file-does-not-exist', (err, data) => {
    if (err) {
      next(err) // Pass errors to Express.
    } else {
      res.send(data)
    }
  })
})


Starting with Express 5, route handlers and middleware that return a Promise
will call next(value) automatically when they reject or throw an error.
For example:

app.get('/user/:id', async (req, res, next) => {
  const user = await getUserById(req.params.id)
  res.send(user)
})


If getUserById throws an error or rejects, next will be called with either
the thrown error or the rejected value. If no rejected value is provided, next
will be called with a default Error object provided by the Express router.

If you pass anything to the next() function (except the string 'route'),
Express regards the current request as being an error and will skip any
remaining non-error handling routing and middleware functions.

If the callback in a sequence provides no data, only errors, you can simplify
this code as follows:

app.get('/', [
  function (req, res, next) {
    fs.writeFile('/inaccessible-path', 'data', next)
  },
  function (req, res) {
    res.send('OK')
  }
])


In the above example, next is provided as the callback for fs.writeFile,
which is called with or without errors. If there is no error, the second
handler is executed, otherwise Express catches and processes the error.

You must catch errors that occur in asynchronous code invoked by route handlers or
middleware and pass them to Express for processing. For example:

app.get('/', (req, res, next) => {
  setTimeout(() => {
    try {
      throw new Error('BROKEN')
    } catch (err) {
      next(err)
    }
  }, 100)
})


The above example uses a try...catch block to catch errors in the
asynchronous code and pass them to Express. If the try...catch
block were omitted, Express would not catch the error since it is not part of the synchronous
handler code.

Use promises to avoid the overhead of the try...catch block or when using functions
that return promises.  For example:

app.get('/', (req, res, next) => {
  Promise.resolve().then(() => {
    throw new Error('BROKEN')
  }).catch(next) // Errors will be passed to Express.
})


Since promises automatically catch both synchronous errors and rejected promises,
you can simply provide next as the final catch handler and Express will catch errors,
because the catch handler is given the error as the first argument.

You could also use a chain of handlers to rely on synchronous error
catching, by reducing the asynchronous code to something trivial. For example:

app.get('/', [
  function (req, res, next) {
    fs.readFile('/maybe-valid-file', 'utf-8', (err, data) => {
      res.locals.data = data
      next(err)
    })
  },
  function (req, res) {
    res.locals.data = res.locals.data.split(',')[1]
    res.send(res.locals.data)
  }
])


The above example has a couple of trivial statements from the readFile
call. If readFile causes an error, then it passes the error to Express, otherwise you
quickly return to the world of synchronous error handling in the next handler
in the chain. Then, the example above tries to process the data. If this fails, then the
synchronous error handler will catch it. If you had done this processing inside
the readFile callback, then the application might exit and the Express error
handlers would not run.

Whichever method you use, if you want Express error handlers to be called in and the
application to survive, you must ensure that Express receives the error.

The default error handler

Express comes with a built-in error handler that takes care of any errors that might be encountered in the app. This default error-handling middleware function is added at the end of the middleware function stack.

If you pass an error to next() and you do not handle it in a custom error
handler, it will be handled by the built-in error handler; the error will be
written to the client with the stack trace. The stack trace is not included
in the production environment.


  Set the environment variable NODE_ENV to production, to run the app in production mode.


When an error is written, the following information is added to the
response:


  The res.statusCode is set from err.status (or err.statusCode). If
this value is outside the 4xx or 5xx range, it will be set to 500.
  The res.statusMessage is set according to the status code.
  The body will be the HTML of the status code message when in production
environment, otherwise will be err.stack.
  Any headers specified in an err.headers object.


If you call next() with an error after you have started writing the
response (for example, if you encounter an error while streaming the
response to the client), the Express default error handler closes the
connection and fails the request.

So when you add a custom error handler, you must delegate to
the default Express error handler, when the headers
have already been sent to the client:

function errorHandler (err, req, res, next) {
  if (res.headersSent) {
    return next(err)
  }
  res.status(500)
  res.render('error', { error: err })
}


Note that the default error handler can get triggered if you call next() with an error
in your code more than once, even if custom error handling middleware is in place.

Other error handling middleware can be found at Express middleware.

Writing error handlers

Define error-handling middleware functions in the same way as other middleware functions,
except error-handling functions have four arguments instead of three:
(err, req, res, next). For example:

app.use((err, req, res, next) => {
  console.error(err.stack)
  res.status(500).send('Something broke!')
})


You define error-handling middleware last, after other app.use() and routes calls; for example:

const bodyParser = require('body-parser')
const methodOverride = require('method-override')

app.use(bodyParser.urlencoded({
  extended: true
}))
app.use(bodyParser.json())
app.use(methodOverride())
app.use((err, req, res, next) => {
  // logic
})


Responses from within a middleware function can be in any format, such as an HTML error page, a simple message, or a JSON string.

For organizational (and higher-level framework) purposes, you can define
several error-handling middleware functions, much as you would with
regular middleware functions. For example, to define an error-handler
for requests made by using XHR and those without:

const bodyParser = require('body-parser')
const methodOverride = require('method-override')

app.use(bodyParser.urlencoded({
  extended: true
}))
app.use(bodyParser.json())
app.use(methodOverride())
app.use(logErrors)
app.use(clientErrorHandler)
app.use(errorHandler)


In this example, the generic logErrors might write request and
error information to stderr, for example:

function logErrors (err, req, res, next) {
  console.error(err.stack)
  next(err)
}


Also in this example, clientErrorHandler is defined as follows; in this case, the error is explicitly passed along to the next one.

Notice that when not calling “next” in an error-handling function, you are responsible for writing (and ending) the response. Otherwise, those requests will “hang” and will not be eligible for garbage collection.

function clientErrorHandler (err, req, res, next) {
  if (req.xhr) {
    res.status(500).send({ error: 'Something failed!' })
  } else {
    next(err)
  }
}


Implement the “catch-all” errorHandler function as follows (for example):

function errorHandler (err, req, res, next) {
  res.status(500)
  res.render('error', { error: err })
}


If you have a route handler with multiple callback functions, you can use the route parameter to skip to the next route handler. For example:

app.get('/a_route_behind_paywall',
  (req, res, next) => {
    if (!req.user.hasPaid) {
      // continue handling this request
      next('route')
    } else {
      next()
    }
  }, (req, res, next) => {
    PaidContent.find((err, doc) => {
      if (err) return next(err)
      res.json(doc)
    })
  })


In this example, the getPaidContent handler will be skipped but any remaining handlers in app for /a_route_behind_paywall would continue to be executed.


  Calls to next() and next(err) indicate that the current handler is complete and in what state.  next(err) will skip all remaining handlers in the chain except for those that are set up to handle errors as described above.


              
    
    Edit this page\n\n\n\nDebugging Express

To see all the internal logs used in Express, set the DEBUG environment variable to
express:* when launching your app.

$ DEBUG=express:* node index.js


On Windows, use the corresponding command.

> $env:DEBUG = "express:*"; node index.js


Running this command on the default app generated by the express generator prints the following output:

$ DEBUG=express:* node ./bin/www
  express:router:route new / +0ms
  express:router:layer new / +1ms
  express:router:route get / +1ms
  express:router:layer new / +0ms
  express:router:route new / +1ms
  express:router:layer new / +0ms
  express:router:route get / +0ms
  express:router:layer new / +0ms
  express:application compile etag weak +1ms
  express:application compile query parser extended +0ms
  express:application compile trust proxy false +0ms
  express:application booting in development mode +1ms
  express:router use / query +0ms
  express:router:layer new / +0ms
  express:router use / expressInit +0ms
  express:router:layer new / +0ms
  express:router use / favicon +1ms
  express:router:layer new / +0ms
  express:router use / logger +0ms
  express:router:layer new / +0ms
  express:router use / jsonParser +0ms
  express:router:layer new / +1ms
  express:router use / urlencodedParser +0ms
  express:router:layer new / +0ms
  express:router use / cookieParser +0ms
  express:router:layer new / +0ms
  express:router use / stylus +90ms
  express:router:layer new / +0ms
  express:router use / serveStatic +0ms
  express:router:layer new / +0ms
  express:router use / router +0ms
  express:router:layer new / +1ms
  express:router use /users router +0ms
  express:router:layer new /users +0ms
  express:router use / &lt;anonymous&gt; +0ms
  express:router:layer new / +0ms
  express:router use / &lt;anonymous&gt; +0ms
  express:router:layer new / +0ms
  express:router use / &lt;anonymous&gt; +0ms
  express:router:layer new / +0ms


When a request is then made to the app, you will see the logs specified in the Express code:

  express:router dispatching GET / +4h
  express:router query  : / +2ms
  express:router expressInit  : / +0ms
  express:router favicon  : / +0ms
  express:router logger  : / +1ms
  express:router jsonParser  : / +0ms
  express:router urlencodedParser  : / +1ms
  express:router cookieParser  : / +0ms
  express:router stylus  : / +0ms
  express:router serveStatic  : / +2ms
  express:router router  : / +2ms
  express:router dispatching GET / +1ms
  express:view lookup "index.pug" +338ms
  express:view stat "/projects/example/views/index.pug" +0ms
  express:view render "/projects/example/views/index.pug" +1ms


To see the logs only from the router implementation, set the value of DEBUG to express:router. Likewise, to see logs only from the application implementation, set the value of DEBUG to express:application, and so on.

Applications generated by express

An application generated by the express command uses the debug module and its debug namespace is scoped to the name of the application.

For example, if you generated the app with $ express sample-app, you can enable the debug statements with the following command:

$ DEBUG=sample-app:* node ./bin/www


You can specify more than one debug namespace by assigning a comma-separated list of names:

$ DEBUG=http,mail,express:* node index.js


Advanced options

When running through Node.js, you can set a few environment variables that will change the behavior of the debug logging:


  
    
      Name
      Purpose
    
  
  
    
      DEBUG
      Enables/disables specific debugging namespaces.
    
    
      DEBUG_COLORS
      Whether or not to use colors in the debug output.
    
    
      DEBUG_DEPTH
      Object inspection depth.
    
    
      DEBUG_FD
      File descriptor to write debug output to.
    
    
      DEBUG_SHOW_HIDDEN
      Shows hidden properties on inspected objects.
    
  



   Note

  The environment variables beginning with DEBUG_ end up being
converted into an Options object that gets used with %o/%O formatters.
See the Node.js documentation for
util.inspect()
for the complete list.




              
    
    Edit this page\n\nDebugging Express

To see all the internal logs used in Express, set the DEBUG environment variable to
express:* when launching your app.

$ DEBUG=express:* node index.js


On Windows, use the corresponding command.

> $env:DEBUG = "express:*"; node index.js


Running this command on the default app generated by the express generator prints the following output:

$ DEBUG=express:* node ./bin/www
  express:router:route new / +0ms
  express:router:layer new / +1ms
  express:router:route get / +1ms
  express:router:layer new / +0ms
  express:router:route new / +1ms
  express:router:layer new / +0ms
  express:router:route get / +0ms
  express:router:layer new / +0ms
  express:application compile etag weak +1ms
  express:application compile query parser extended +0ms
  express:application compile trust proxy false +0ms
  express:application booting in development mode +1ms
  express:router use / query +0ms
  express:router:layer new / +0ms
  express:router use / expressInit +0ms
  express:router:layer new / +0ms
  express:router use / favicon +1ms
  express:router:layer new / +0ms
  express:router use / logger +0ms
  express:router:layer new / +0ms
  express:router use / jsonParser +0ms
  express:router:layer new / +1ms
  express:router use / urlencodedParser +0ms
  express:router:layer new / +0ms
  express:router use / cookieParser +0ms
  express:router:layer new / +0ms
  express:router use / stylus +90ms
  express:router:layer new / +0ms
  express:router use / serveStatic +0ms
  express:router:layer new / +0ms
  express:router use / router +0ms
  express:router:layer new / +1ms
  express:router use /users router +0ms
  express:router:layer new /users +0ms
  express:router use / &lt;anonymous&gt; +0ms
  express:router:layer new / +0ms
  express:router use / &lt;anonymous&gt; +0ms
  express:router:layer new / +0ms
  express:router use / &lt;anonymous&gt; +0ms
  express:router:layer new / +0ms


When a request is then made to the app, you will see the logs specified in the Express code:

  express:router dispatching GET / +4h
  express:router query  : / +2ms
  express:router expressInit  : / +0ms
  express:router favicon  : / +0ms
  express:router logger  : / +1ms
  express:router jsonParser  : / +0ms
  express:router urlencodedParser  : / +1ms
  express:router cookieParser  : / +0ms
  express:router stylus  : / +0ms
  express:router serveStatic  : / +2ms
  express:router router  : / +2ms
  express:router dispatching GET / +1ms
  express:view lookup "index.pug" +338ms
  express:view stat "/projects/example/views/index.pug" +0ms
  express:view render "/projects/example/views/index.pug" +1ms


To see the logs only from the router implementation, set the value of DEBUG to express:router. Likewise, to see logs only from the application implementation, set the value of DEBUG to express:application, and so on.

Applications generated by express

An application generated by the express command uses the debug module and its debug namespace is scoped to the name of the application.

For example, if you generated the app with $ express sample-app, you can enable the debug statements with the following command:

$ DEBUG=sample-app:* node ./bin/www


You can specify more than one debug namespace by assigning a comma-separated list of names:

$ DEBUG=http,mail,express:* node index.js


Advanced options

When running through Node.js, you can set a few environment variables that will change the behavior of the debug logging:


  
    
      Name
      Purpose
    
  
  
    
      DEBUG
      Enables/disables specific debugging namespaces.
    
    
      DEBUG_COLORS
      Whether or not to use colors in the debug output.
    
    
      DEBUG_DEPTH
      Object inspection depth.
    
    
      DEBUG_FD
      File descriptor to write debug output to.
    
    
      DEBUG_SHOW_HIDDEN
      Shows hidden properties on inspected objects.
    
  



   Note

  The environment variables beginning with DEBUG_ end up being
converted into an Options object that gets used with %o/%O formatters.
See the Node.js documentation for
util.inspect()
for the complete list.




              
    
    Edit this page\n\n\n\nExpress behind proxies

When running an Express app behind a reverse proxy, some of the Express APIs may return different values than expected. In order to adjust for this, the trust proxy application setting may be used to expose information provided by the reverse proxy in the Express APIs. The most common issue is express APIs that expose the client’s IP address may instead show an internal IP address of the reverse proxy.


  When configuring the trust proxy setting, it is important to understand the exact setup of the reverse proxy. Since this setting will trust values provided in the request, it is important that the combination of the setting in Express matches how the reverse proxy operates.


The application setting trust proxy may be set to one of the values listed in the following table.


  TypeValue
  
    
      Boolean

        If true, the client’s IP address is understood as the left-most entry in the X-Forwarded-For header.

        If false, the app is understood as directly facing the client and the client’s IP address is derived from req.socket.remoteAddress. This is the default setting.

        
          When setting to true, it is important to ensure that the last reverse proxy trusted is removing/overwriting all of the following HTTP headers: X-Forwarded-For, X-Forwarded-Host, and X-Forwarded-Proto, otherwise it may be possible for the client to provide any value.
        
      
    
    
      IP addresses

        An IP address, subnet, or an array of IP addresses and subnets to trust as being a reverse proxy. The following list shows the pre-configured subnet names:

        
          loopback - 127.0.0.1/8, ::1/128
          linklocal - 169.254.0.0/16, fe80::/10
          uniquelocal - 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, fc00::/7
        

        You can set IP addresses in any of the following ways:

        app.set('trust proxy', 'loopback') // specify a single subnet
app.set('trust proxy', 'loopback, 123.123.123.123') // specify a subnet and an address
app.set('trust proxy', 'loopback, linklocal, uniquelocal') // specify multiple subnets as CSV
app.set('trust proxy', ['loopback', 'linklocal', 'uniquelocal']) // specify multiple subnets as an array
        

        When specified, the IP addresses or the subnets are excluded from the address determination process, and the untrusted IP address nearest to the application server is determined as the client’s IP address. This works by checking if req.socket.remoteAddress is trusted. If so, then each address in X-Forwarded-For is checked from right to left until the first non-trusted address.
      
    
    
      Number

        Use the address that is at most n number of hops away from the Express application. req.socket.remoteAddress is the first hop, and the rest are looked for in the X-Forwarded-For header from right to left. A value of 0 means that the first untrusted address would be req.socket.remoteAddress, i.e. there is no reverse proxy.

        
          When using this setting, it is important to ensure there are not multiple, different-length paths to the Express application such that the client can be less than the configured number of hops away, otherwise it may be possible for the client to provide any value.
        
      
    
    
      Function

        Custom trust implementation.

        app.set('trust proxy', (ip) => {
  if (ip === '127.0.0.1' || ip === '123.123.123.123') return true // trusted IPs
  else return false
})
        
      
    
  


Enabling trust proxy will have the following impact:


  
    The value of req.hostname is derived from the value set in the X-Forwarded-Host header, which can be set by the client or by the proxy.
  
  
    X-Forwarded-Proto can be set by the reverse proxy to tell the app whether it is https or  http or even an invalid name. This value is reflected by req.protocol.
  
  
    The req.ip and req.ips values are populated based on the socket address and X-Forwarded-For header, starting at the first untrusted address.
  


The trust proxy setting is implemented using the proxy-addr package. For more information, see its documentation.

              
    
    Edit this page\n\nExpress behind proxies

When running an Express app behind a reverse proxy, some of the Express APIs may return different values than expected. In order to adjust for this, the trust proxy application setting may be used to expose information provided by the reverse proxy in the Express APIs. The most common issue is express APIs that expose the client’s IP address may instead show an internal IP address of the reverse proxy.


  When configuring the trust proxy setting, it is important to understand the exact setup of the reverse proxy. Since this setting will trust values provided in the request, it is important that the combination of the setting in Express matches how the reverse proxy operates.


The application setting trust proxy may be set to one of the values listed in the following table.


  TypeValue
  
    
      Boolean

        If true, the client’s IP address is understood as the left-most entry in the X-Forwarded-For header.

        If false, the app is understood as directly facing the client and the client’s IP address is derived from req.socket.remoteAddress. This is the default setting.

        
          When setting to true, it is important to ensure that the last reverse proxy trusted is removing/overwriting all of the following HTTP headers: X-Forwarded-For, X-Forwarded-Host, and X-Forwarded-Proto, otherwise it may be possible for the client to provide any value.
        
      
    
    
      IP addresses

        An IP address, subnet, or an array of IP addresses and subnets to trust as being a reverse proxy. The following list shows the pre-configured subnet names:

        
          loopback - 127.0.0.1/8, ::1/128
          linklocal - 169.254.0.0/16, fe80::/10
          uniquelocal - 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, fc00::/7
        

        You can set IP addresses in any of the following ways:

        app.set('trust proxy', 'loopback') // specify a single subnet
app.set('trust proxy', 'loopback, 123.123.123.123') // specify a subnet and an address
app.set('trust proxy', 'loopback, linklocal, uniquelocal') // specify multiple subnets as CSV
app.set('trust proxy', ['loopback', 'linklocal', 'uniquelocal']) // specify multiple subnets as an array
        

        When specified, the IP addresses or the subnets are excluded from the address determination process, and the untrusted IP address nearest to the application server is determined as the client’s IP address. This works by checking if req.socket.remoteAddress is trusted. If so, then each address in X-Forwarded-For is checked from right to left until the first non-trusted address.
      
    
    
      Number

        Use the address that is at most n number of hops away from the Express application. req.socket.remoteAddress is the first hop, and the rest are looked for in the X-Forwarded-For header from right to left. A value of 0 means that the first untrusted address would be req.socket.remoteAddress, i.e. there is no reverse proxy.

        
          When using this setting, it is important to ensure there are not multiple, different-length paths to the Express application such that the client can be less than the configured number of hops away, otherwise it may be possible for the client to provide any value.
        
      
    
    
      Function

        Custom trust implementation.

        app.set('trust proxy', (ip) => {
  if (ip === '127.0.0.1' || ip === '123.123.123.123') return true // trusted IPs
  else return false
})
        
      
    
  


Enabling trust proxy will have the following impact:


  
    The value of req.hostname is derived from the value set in the X-Forwarded-Host header, which can be set by the client or by the proxy.
  
  
    X-Forwarded-Proto can be set by the reverse proxy to tell the app whether it is https or  http or even an invalid name. This value is reflected by req.protocol.
  
  
    The req.ip and req.ips values are populated based on the socket address and X-Forwarded-For header, starting at the first untrusted address.
  


The trust proxy setting is implemented using the proxy-addr package. For more information, see its documentation.

              
    
    Edit this page\n\n\n\nMoving to Express 4

Overview

Express 4 is a breaking change from Express 3. That means an existing Express 3 app will not work if you update the Express version in its dependencies.

This article covers:


  Changes in Express 4.
  An example of migrating an Express 3 app to Express 4.
  Upgrading to the Express 4 app generator.


Changes in Express 4

There are several significant changes in Express 4:


  Changes to Express core and middleware system. The dependencies on Connect and built-in middleware were removed, so you must add middleware yourself.
  
  Changes to the routing system.
  Various other changes.


See also:


  New features in 4.x.
  Migrating from 3.x to 4.x.



Changes to Express core and middleware system


Express 4 no longer depends on Connect, and removes all built-in
middleware from its core, except for the express.static function. This means that
Express is now an independent routing and middleware web framework, and
Express versioning and releases are not affected by middleware updates.

Without built-in middleware, you must explicitly add all the
middleware that is required to run your app. Simply follow these steps:


  Install the module: npm install --save <module-name>
  In your app, require the module: require('module-name')
  Use the module according to its documentation: app.use( ... )


The following table lists Express 3 middleware and their counterparts in Express 4.


Express 3Express 4
express.bodyParser
body-parser +
multer
express.compress
compression
express.cookieSession
cookie-session
express.cookieParser
cookie-parser
express.logger
morgan
express.session
express-session
express.favicon
serve-favicon
express.responseTime
response-time
express.errorHandler
errorhandler
express.methodOverride
method-override
express.timeout
connect-timeout
express.vhost
vhost
express.csrf
csurf
express.directory
serve-index
express.static
serve-static


Here is the complete list of Express 4 middleware.

In most cases, you can simply replace the old version 3 middleware with
its Express 4 counterpart. For details, see the module documentation in
GitHub.

app.use accepts parameters

In version 4 you can use a variable parameter to define the path where middleware functions are loaded, then read the value of the parameter from the route handler.
For example:

app.use('/book/:id', (req, res, next) => {
  console.log('ID:', req.params.id)
  next()
})


The routing system


Apps now implicitly load routing middleware, so you no longer have to
worry about the order in which middleware is loaded with respect to
the router middleware.

The way you define routes is unchanged, but the routing system has two
new features to help organize your routes:


  A new method, app.route(), to create chainable route handlers for a route path.
  A new class, express.Router, to create modular mountable route handlers.


app.route() method

The new app.route() method enables you to create chainable route handlers
for a route path. Because the path is specified in a single location, creating modular routes is helpful, as is reducing redundancy and typos. For more
information about routes, see Router() documentation.

Here is an example of chained route handlers that are defined by using the app.route() function.

app.route('/book')
  .get((req, res) => {
    res.send('Get a random book')
  })
  .post((req, res) => {
    res.send('Add a book')
  })
  .put((req, res) => {
    res.send('Update the book')
  })


express.Router class

The other feature that helps to organize routes is a new class,
express.Router, that you can use to create modular mountable
route handlers. A Router instance is a complete middleware and
routing system; for this reason it is often referred to as a “mini-app”.

The following example creates a router as a module, loads middleware in
it, defines some routes, and mounts it on a path on the main app.

For example, create a router file named birds.js in the app directory,
with the following content:

var express = require('express')
var router = express.Router()

// middleware specific to this router
router.use((req, res, next) => {
  console.log('Time: ', Date.now())
  next()
})
// define the home page route
router.get('/', (req, res) => {
  res.send('Birds home page')
})
// define the about route
router.get('/about', (req, res) => {
  res.send('About birds')
})

module.exports = router


Then, load the router module in the app:

var birds = require('./birds')

// ...

app.use('/birds', birds)


The app will now be able to handle requests to the /birds and
/birds/about paths, and will call the timeLog
middleware that is specific to the route.


Other changes


The following table lists other small but important changes in Express 4:



Object
Description


Node.js
Express 4 requires Node.js 0.10.x or later and has dropped support for
Node.js 0.8.x.



      http.createServer()
    

      The http module is no longer needed, unless you need to directly work with it (socket.io/SPDY/HTTPS). The app can be started by using the
app.listen() function.
    



      app.configure()
    

      The app.configure() function has been removed.  Use the
process.env.NODE_ENV or
app.get('env') function to detect the environment and configure the app accordingly.
    



      json spaces
    

      The json spaces application property is disabled by default in Express 4.
    



      req.accepted()
    

      Use req.accepts(), req.acceptsEncodings(),
req.acceptsCharsets(), and req.acceptsLanguages().
    



      res.location()
    

      No longer resolves relative URLs.
    



      req.params
    

      Was an array; now an object.
    



      res.locals
    

      Was a function; now an object.
    



      res.headerSent
    

      Changed to res.headersSent.
    



      app.route
    

      Now available as app.mountpath.
    



      res.on('header')
    

      Removed.
    



      res.charset
    

      Removed.
    



      res.setHeader('Set-Cookie', val)
    

      Functionality is now limited to setting the basic cookie value. Use
res.cookie() for added functionality.
    



Example app migration

Here is an example of migrating an Express 3 application to Express 4.
The files of interest are app.js and package.json.


Version 3 app


app.js

Consider an Express v.3 application with the following app.js file:

var express = require('express')
var routes = require('./routes')
var user = require('./routes/user')
var http = require('http')
var path = require('path')

var app = express()

// all environments
app.set('port', process.env.PORT || 3000)
app.set('views', path.join(__dirname, 'views'))
app.set('view engine', 'pug')
app.use(express.favicon())
app.use(express.logger('dev'))
app.use(express.methodOverride())
app.use(express.session({ secret: 'your secret here' }))
app.use(express.bodyParser())
app.use(app.router)
app.use(express.static(path.join(__dirname, 'public')))

// development only
if (app.get('env') === 'development') {
  app.use(express.errorHandler())
}

app.get('/', routes.index)
app.get('/users', user.list)

http.createServer(app).listen(app.get('port'), () => {
  console.log('Express server listening on port ' + app.get('port'))
})


package.json

The accompanying version 3 package.json file might look
  something like this:

{
  "name": "application-name",
  "version": "0.0.1",
  "private": true,
  "scripts": {
    "start": "node app.js"
  },
  "dependencies": {
    "express": "3.12.0",
    "pug": "*"
  }
}



Process


Begin the migration process by installing the required middleware for the
Express 4 app and updating Express and Pug to their respective latest
version with the following command:

$ npm install serve-favicon morgan method-override express-session body-parser multer errorhandler express@latest pug@latest --save


Make the following changes to app.js:


  
    The built-in Express middleware functions express.favicon,
 express.logger, express.methodOverride,
 express.session, express.bodyParser and
 express.errorHandler are no longer available on the
 express object. You must install their alternatives
 manually and load them in the app.
  
  
    You no longer need to load the app.router function.
 It is not a valid Express 4 app object, so remove the
 app.use(app.router); code.
  
  
    Make sure that the middleware functions are loaded in the correct order - load errorHandler after loading the app routes.
  


Version 4 app

package.json

Running the above npm command will update package.json as follows:

{
  "name": "application-name",
  "version": "0.0.1",
  "private": true,
  "scripts": {
    "start": "node app.js"
  },
  "dependencies": {
    "body-parser": "^1.5.2",
    "errorhandler": "^1.1.1",
    "express": "^4.8.0",
    "express-session": "^1.7.2",
    "pug": "^2.0.0",
    "method-override": "^2.1.2",
    "morgan": "^1.2.2",
    "multer": "^0.1.3",
    "serve-favicon": "^2.0.1"
  }
}


app.js

Then, remove invalid code, load the required middleware, and make other
changes as necessary. The app.js file will look like this:

var http = require('http')
var express = require('express')
var routes = require('./routes')
var user = require('./routes/user')
var path = require('path')

var favicon = require('serve-favicon')
var logger = require('morgan')
var methodOverride = require('method-override')
var session = require('express-session')
var bodyParser = require('body-parser')
var multer = require('multer')
var errorHandler = require('errorhandler')

var app = express()

// all environments
app.set('port', process.env.PORT || 3000)
app.set('views', path.join(__dirname, 'views'))
app.set('view engine', 'pug')
app.use(favicon(path.join(__dirname, '/public/favicon.ico')))
app.use(logger('dev'))
app.use(methodOverride())
app.use(session({
  resave: true,
  saveUninitialized: true,
  secret: 'uwotm8'
}))
app.use(bodyParser.json())
app.use(bodyParser.urlencoded({ extended: true }))
app.use(multer())
app.use(express.static(path.join(__dirname, 'public')))

app.get('/', routes.index)
app.get('/users', user.list)

// error handling middleware should be loaded after the loading the routes
if (app.get('env') === 'development') {
  app.use(errorHandler())
}

var server = http.createServer(app)
server.listen(app.get('port'), () => {
  console.log('Express server listening on port ' + app.get('port'))
})



  Unless you need to work directly with the http module (socket.io/SPDY/HTTPS), loading it is not required, and the app can be simply started this way:

  app.listen(app.get('port'), () => {
  console.log('Express server listening on port ' + app.get('port'))
})
  


Run the app

The migration process is complete, and the app is now an
Express 4 app. To confirm, start the app by using the following command:

$ node .


Load http://localhost:3000
  and see the home page being rendered by Express 4.

Upgrading to the Express 4 app generator

The command-line tool to generate an Express app is still
  express, but to upgrade to the new version, you must uninstall
  the Express 3 app generator and then install the new
  express-generator.

Installing 

If you already have the Express 3 app generator installed on your system,
you must uninstall it:

$ npm uninstall -g express

Depending on how your file and directory privileges are configured,
you might need to run this command with sudo.

Now install the new generator:

$ npm install -g express-generator


Depending on how your file and directory privileges are configured,
you might need to run this command with sudo.

Now the express command on your system is updated to the
Express 4 generator.

Changes to the app generator 

Command options and use largely remain the same, with the following exceptions:


  Removed the --sessions option.
  Removed the --jshtml option.
  Added the --hogan option to support Hogan.js.


Example

Execute the following command to create an Express 4 app:

$ express app4


If you look at the contents of the app4/app.js file, you will notice
that all the middleware functions (except express.static) that are required for
the app are loaded as independent modules, and the router middleware
is no longer explicitly loaded in the app.

You will also notice that the app.js file is now a Node.js module, in contrast to the standalone app that was generated by the old generator.

After installing the dependencies, start the app by using the following command:

$ npm start


If you look at the npm start script in the package.json file,
you will notice that the actual command that starts the app is
node ./bin/www, which used to be node app.js
in Express 3.

Because the app.js file that was generated by the Express 4 generator
is now a Node.js module, it can no longer be started independently as an app
(unless you modify the code). The module must be loaded in a Node.js file
and started via the Node.js file. The Node.js file is ./bin/www
in this case.

Neither the bin directory nor the extensionless www
file is mandatory for creating an Express app or starting the app. They are
just suggestions made by the generator, so feel free to modify them to suit your
needs.

To get rid of the www directory and keep things the “Express 3 way”,
delete the line that says module.exports = app; at the end of the
app.js file, then paste the following code in its place:

app.set('port', process.env.PORT || 3000)

var server = app.listen(app.get('port'), () => {
  debug('Express server listening on port ' + server.address().port)
})


Ensure that you load the debug module at the top of the app.js file by using the following code:

var debug = require('debug')('app4')


Next, change "start": "node ./bin/www" in the package.json file to "start": "node app.js".

You have now moved the functionality of ./bin/www back to
app.js. This change is not recommended, but the exercise helps you
to understand how the ./bin/www file works, and why the app.js file
no longer starts on its own.

              
    
    Edit this page\n\nMoving to Express 4

Overview

Express 4 is a breaking change from Express 3. That means an existing Express 3 app will not work if you update the Express version in its dependencies.

This article covers:


  Changes in Express 4.
  An example of migrating an Express 3 app to Express 4.
  Upgrading to the Express 4 app generator.


Changes in Express 4

There are several significant changes in Express 4:


  Changes to Express core and middleware system. The dependencies on Connect and built-in middleware were removed, so you must add middleware yourself.
  
  Changes to the routing system.
  Various other changes.


See also:


  New features in 4.x.
  Migrating from 3.x to 4.x.



Changes to Express core and middleware system


Express 4 no longer depends on Connect, and removes all built-in
middleware from its core, except for the express.static function. This means that
Express is now an independent routing and middleware web framework, and
Express versioning and releases are not affected by middleware updates.

Without built-in middleware, you must explicitly add all the
middleware that is required to run your app. Simply follow these steps:


  Install the module: npm install --save <module-name>
  In your app, require the module: require('module-name')
  Use the module according to its documentation: app.use( ... )


The following table lists Express 3 middleware and their counterparts in Express 4.


Express 3Express 4
express.bodyParser
body-parser +
multer
express.compress
compression
express.cookieSession
cookie-session
express.cookieParser
cookie-parser
express.logger
morgan
express.session
express-session
express.favicon
serve-favicon
express.responseTime
response-time
express.errorHandler
errorhandler
express.methodOverride
method-override
express.timeout
connect-timeout
express.vhost
vhost
express.csrf
csurf
express.directory
serve-index
express.static
serve-static


Here is the complete list of Express 4 middleware.

In most cases, you can simply replace the old version 3 middleware with
its Express 4 counterpart. For details, see the module documentation in
GitHub.

app.use accepts parameters

In version 4 you can use a variable parameter to define the path where middleware functions are loaded, then read the value of the parameter from the route handler.
For example:

app.use('/book/:id', (req, res, next) => {
  console.log('ID:', req.params.id)
  next()
})


The routing system


Apps now implicitly load routing middleware, so you no longer have to
worry about the order in which middleware is loaded with respect to
the router middleware.

The way you define routes is unchanged, but the routing system has two
new features to help organize your routes:


  A new method, app.route(), to create chainable route handlers for a route path.
  A new class, express.Router, to create modular mountable route handlers.


app.route() method

The new app.route() method enables you to create chainable route handlers
for a route path. Because the path is specified in a single location, creating modular routes is helpful, as is reducing redundancy and typos. For more
information about routes, see Router() documentation.

Here is an example of chained route handlers that are defined by using the app.route() function.

app.route('/book')
  .get((req, res) => {
    res.send('Get a random book')
  })
  .post((req, res) => {
    res.send('Add a book')
  })
  .put((req, res) => {
    res.send('Update the book')
  })


express.Router class

The other feature that helps to organize routes is a new class,
express.Router, that you can use to create modular mountable
route handlers. A Router instance is a complete middleware and
routing system; for this reason it is often referred to as a “mini-app”.

The following example creates a router as a module, loads middleware in
it, defines some routes, and mounts it on a path on the main app.

For example, create a router file named birds.js in the app directory,
with the following content:

var express = require('express')
var router = express.Router()

// middleware specific to this router
router.use((req, res, next) => {
  console.log('Time: ', Date.now())
  next()
})
// define the home page route
router.get('/', (req, res) => {
  res.send('Birds home page')
})
// define the about route
router.get('/about', (req, res) => {
  res.send('About birds')
})

module.exports = router


Then, load the router module in the app:

var birds = require('./birds')

// ...

app.use('/birds', birds)


The app will now be able to handle requests to the /birds and
/birds/about paths, and will call the timeLog
middleware that is specific to the route.


Other changes


The following table lists other small but important changes in Express 4:



Object
Description


Node.js
Express 4 requires Node.js 0.10.x or later and has dropped support for
Node.js 0.8.x.



      http.createServer()
    

      The http module is no longer needed, unless you need to directly work with it (socket.io/SPDY/HTTPS). The app can be started by using the
app.listen() function.
    



      app.configure()
    

      The app.configure() function has been removed.  Use the
process.env.NODE_ENV or
app.get('env') function to detect the environment and configure the app accordingly.
    



      json spaces
    

      The json spaces application property is disabled by default in Express 4.
    



      req.accepted()
    

      Use req.accepts(), req.acceptsEncodings(),
req.acceptsCharsets(), and req.acceptsLanguages().
    



      res.location()
    

      No longer resolves relative URLs.
    



      req.params
    

      Was an array; now an object.
    



      res.locals
    

      Was a function; now an object.
    



      res.headerSent
    

      Changed to res.headersSent.
    



      app.route
    

      Now available as app.mountpath.
    



      res.on('header')
    

      Removed.
    



      res.charset
    

      Removed.
    



      res.setHeader('Set-Cookie', val)
    

      Functionality is now limited to setting the basic cookie value. Use
res.cookie() for added functionality.
    



Example app migration

Here is an example of migrating an Express 3 application to Express 4.
The files of interest are app.js and package.json.


Version 3 app


app.js

Consider an Express v.3 application with the following app.js file:

var express = require('express')
var routes = require('./routes')
var user = require('./routes/user')
var http = require('http')
var path = require('path')

var app = express()

// all environments
app.set('port', process.env.PORT || 3000)
app.set('views', path.join(__dirname, 'views'))
app.set('view engine', 'pug')
app.use(express.favicon())
app.use(express.logger('dev'))
app.use(express.methodOverride())
app.use(express.session({ secret: 'your secret here' }))
app.use(express.bodyParser())
app.use(app.router)
app.use(express.static(path.join(__dirname, 'public')))

// development only
if (app.get('env') === 'development') {
  app.use(express.errorHandler())
}

app.get('/', routes.index)
app.get('/users', user.list)

http.createServer(app).listen(app.get('port'), () => {
  console.log('Express server listening on port ' + app.get('port'))
})


package.json

The accompanying version 3 package.json file might look
  something like this:

{
  "name": "application-name",
  "version": "0.0.1",
  "private": true,
  "scripts": {
    "start": "node app.js"
  },
  "dependencies": {
    "express": "3.12.0",
    "pug": "*"
  }
}



Process


Begin the migration process by installing the required middleware for the
Express 4 app and updating Express and Pug to their respective latest
version with the following command:

$ npm install serve-favicon morgan method-override express-session body-parser multer errorhandler express@latest pug@latest --save


Make the following changes to app.js:


  
    The built-in Express middleware functions express.favicon,
 express.logger, express.methodOverride,
 express.session, express.bodyParser and
 express.errorHandler are no longer available on the
 express object. You must install their alternatives
 manually and load them in the app.
  
  
    You no longer need to load the app.router function.
 It is not a valid Express 4 app object, so remove the
 app.use(app.router); code.
  
  
    Make sure that the middleware functions are loaded in the correct order - load errorHandler after loading the app routes.
  


Version 4 app

package.json

Running the above npm command will update package.json as follows:

{
  "name": "application-name",
  "version": "0.0.1",
  "private": true,
  "scripts": {
    "start": "node app.js"
  },
  "dependencies": {
    "body-parser": "^1.5.2",
    "errorhandler": "^1.1.1",
    "express": "^4.8.0",
    "express-session": "^1.7.2",
    "pug": "^2.0.0",
    "method-override": "^2.1.2",
    "morgan": "^1.2.2",
    "multer": "^0.1.3",
    "serve-favicon": "^2.0.1"
  }
}


app.js

Then, remove invalid code, load the required middleware, and make other
changes as necessary. The app.js file will look like this:

var http = require('http')
var express = require('express')
var routes = require('./routes')
var user = require('./routes/user')
var path = require('path')

var favicon = require('serve-favicon')
var logger = require('morgan')
var methodOverride = require('method-override')
var session = require('express-session')
var bodyParser = require('body-parser')
var multer = require('multer')
var errorHandler = require('errorhandler')

var app = express()

// all environments
app.set('port', process.env.PORT || 3000)
app.set('views', path.join(__dirname, 'views'))
app.set('view engine', 'pug')
app.use(favicon(path.join(__dirname, '/public/favicon.ico')))
app.use(logger('dev'))
app.use(methodOverride())
app.use(session({
  resave: true,
  saveUninitialized: true,
  secret: 'uwotm8'
}))
app.use(bodyParser.json())
app.use(bodyParser.urlencoded({ extended: true }))
app.use(multer())
app.use(express.static(path.join(__dirname, 'public')))

app.get('/', routes.index)
app.get('/users', user.list)

// error handling middleware should be loaded after the loading the routes
if (app.get('env') === 'development') {
  app.use(errorHandler())
}

var server = http.createServer(app)
server.listen(app.get('port'), () => {
  console.log('Express server listening on port ' + app.get('port'))
})



  Unless you need to work directly with the http module (socket.io/SPDY/HTTPS), loading it is not required, and the app can be simply started this way:

  app.listen(app.get('port'), () => {
  console.log('Express server listening on port ' + app.get('port'))
})
  


Run the app

The migration process is complete, and the app is now an
Express 4 app. To confirm, start the app by using the following command:

$ node .


Load http://localhost:3000
  and see the home page being rendered by Express 4.

Upgrading to the Express 4 app generator

The command-line tool to generate an Express app is still
  express, but to upgrade to the new version, you must uninstall
  the Express 3 app generator and then install the new
  express-generator.

Installing 

If you already have the Express 3 app generator installed on your system,
you must uninstall it:

$ npm uninstall -g express

Depending on how your file and directory privileges are configured,
you might need to run this command with sudo.

Now install the new generator:

$ npm install -g express-generator


Depending on how your file and directory privileges are configured,
you might need to run this command with sudo.

Now the express command on your system is updated to the
Express 4 generator.

Changes to the app generator 

Command options and use largely remain the same, with the following exceptions:


  Removed the --sessions option.
  Removed the --jshtml option.
  Added the --hogan option to support Hogan.js.


Example

Execute the following command to create an Express 4 app:

$ express app4


If you look at the contents of the app4/app.js file, you will notice
that all the middleware functions (except express.static) that are required for
the app are loaded as independent modules, and the router middleware
is no longer explicitly loaded in the app.

You will also notice that the app.js file is now a Node.js module, in contrast to the standalone app that was generated by the old generator.

After installing the dependencies, start the app by using the following command:

$ npm start


If you look at the npm start script in the package.json file,
you will notice that the actual command that starts the app is
node ./bin/www, which used to be node app.js
in Express 3.

Because the app.js file that was generated by the Express 4 generator
is now a Node.js module, it can no longer be started independently as an app
(unless you modify the code). The module must be loaded in a Node.js file
and started via the Node.js file. The Node.js file is ./bin/www
in this case.

Neither the bin directory nor the extensionless www
file is mandatory for creating an Express app or starting the app. They are
just suggestions made by the generator, so feel free to modify them to suit your
needs.

To get rid of the www directory and keep things the “Express 3 way”,
delete the line that says module.exports = app; at the end of the
app.js file, then paste the following code in its place:

app.set('port', process.env.PORT || 3000)

var server = app.listen(app.get('port'), () => {
  debug('Express server listening on port ' + server.address().port)
})


Ensure that you load the debug module at the top of the app.js file by using the following code:

var debug = require('debug')('app4')


Next, change "start": "node ./bin/www" in the package.json file to "start": "node app.js".

You have now moved the functionality of ./bin/www back to
app.js. This change is not recommended, but the exercise helps you
to understand how the ./bin/www file works, and why the app.js file
no longer starts on its own.

              
    
    Edit this page\n\n\n\nMoving to Express 5

Overview

Express 5 is not very different from Express 4; although it maintains the same basic API, there are still changes that break compatibility with the previous version. Therefore, an application built with Express 4 might not work if you update it to use Express 5.

To install this version, you need to have a Node.js version 18 or higher. Then, execute the following command in your application directory:

npm install "express@5"


You can then run your automated tests to see what fails, and fix problems according to the updates listed below. After addressing test failures, run your app to see what errors occur. You’ll find out right away if the app uses any methods or properties that are not supported.

Express 5 Codemods

To help you migrate your express server, we have created a set of codemods that will help you automatically update your code to the latest version of Express.

Run the following command for run all the codemods available:

npx @expressjs/codemod upgrade


If you want to run a specific codemod, you can run the following command:

npx @expressjs/codemod name-of-the-codemod


You can find the list of available codemods here.

Changes in Express 5

Removed methods and properties


  app.del()
  app.param(fn)
  Pluralized method names
  Leading colon in name argument to app.param(name, fn)
  req.param(name)
  res.json(obj, status)
  res.jsonp(obj, status)
  res.redirect('back') and res.location('back')  
  res.redirect(url, status)
  res.send(body, status)
  res.send(status)
  res.sendfile()
  router.param(fn)
  express.static.mime
  express:router debug logs


Changed


  Path route matching syntax
  Rejected promises handled from middleware and handlers
  express.urlencoded
  app.listen
  app.router
  req.body
  req.host
  req.query
  res.clearCookie
  res.status
  res.vary


Improvements


  res.render()
  Brotli encoding support


Removed methods and properties

If you use any of these methods or properties in your app, it will crash. So, you’ll need to change your app after you update to version 5.

app.del()

Express 5 no longer supports the app.del() function. If you use this function, an error is thrown. For registering HTTP DELETE routes, use the app.delete() function instead.

Initially, del was used instead of delete, because delete is a reserved keyword in JavaScript. However, as of ECMAScript 6, delete and other reserved keywords can legally be used as property names.


   Note

  You can replace the deprecated signatures with the following command:

  npx @expressjs/codemod v4-deprecated-signatures




// v4
app.del('/user/:id', (req, res) => {
  res.send(`DELETE /user/${req.params.id}`)
})

// v5
app.delete('/user/:id', (req, res) => {
  res.send(`DELETE /user/${req.params.id}`)
})


app.param(fn)

The app.param(fn) signature was used for modifying the behavior of the app.param(name, fn) function. It has been deprecated since v4.11.0, and Express 5 no longer supports it at all.

Pluralized method names

The following method names have been pluralized. In Express 4, using the old methods resulted in a deprecation warning. Express 5 no longer supports them at all:

req.acceptsCharset() is replaced by req.acceptsCharsets().

req.acceptsEncoding() is replaced by req.acceptsEncodings().

req.acceptsLanguage() is replaced by req.acceptsLanguages().


   Note

  You can replace the deprecated signatures with the following command:

  npx @expressjs/codemod pluralized-methods




// v4
app.all('/', (req, res) => {
  req.acceptsCharset('utf-8')
  req.acceptsEncoding('br')
  req.acceptsLanguage('en')

  // ...
})

// v5
app.all('/', (req, res) => {
  req.acceptsCharsets('utf-8')
  req.acceptsEncodings('br')
  req.acceptsLanguages('en')

  // ...
})


Leading colon (:) in the name for app.param(name, fn)

A leading colon character (:) in the name for the app.param(name, fn) function is a remnant of Express 3, and for the sake of backwards compatibility, Express 4 supported it with a deprecation notice. Express 5 will silently ignore it and use the name parameter without prefixing it with a colon.

This should not affect your code if you follow the Express 4 documentation of app.param, as it makes no mention of the leading colon.

req.param(name)

This potentially confusing and dangerous method of retrieving form data has been removed. You will now need to specifically look for the submitted parameter name in the req.params, req.body, or req.query object.


   Note

  You can replace the deprecated signatures with the following command:

  npx @expressjs/codemod req-param




// v4
app.post('/user', (req, res) => {
  const id = req.param('id')
  const body = req.param('body')
  const query = req.param('query')

  // ...
})

// v5
app.post('/user', (req, res) => {
  const id = req.params.id
  const body = req.body
  const query = req.query

  // ...
})


res.json(obj, status)

Express 5 no longer supports the signature res.json(obj, status). Instead, set the status and then chain it to the res.json() method like this: res.status(status).json(obj).


   Note

  You can replace the deprecated signatures with the following command:

  npx @expressjs/codemod v4-deprecated-signatures




// v4
app.post('/user', (req, res) => {
  res.json({ name: 'Ruben' }, 201)
})

// v5
app.post('/user', (req, res) => {
  res.status(201).json({ name: 'Ruben' })
})


res.jsonp(obj, status)

Express 5 no longer supports the signature res.jsonp(obj, status). Instead, set the status and then chain it to the res.jsonp() method like this: res.status(status).jsonp(obj).


   Note

  You can replace the deprecated signatures with the following command:

  npx @expressjs/codemod v4-deprecated-signatures




// v4
app.post('/user', (req, res) => {
  res.jsonp({ name: 'Ruben' }, 201)
})

// v5
app.post('/user', (req, res) => {
  res.status(201).jsonp({ name: 'Ruben' })
})


res.redirect(url, status)

Express 5 no longer supports the signature res.redirect(url, status). Instead, use the following signature: res.redirect(status, url).


   Note

  You can replace the deprecated signatures with the following command:

  npx @expressjs/codemod v4-deprecated-signatures




// v4
app.get('/user', (req, res) => {
  res.redirect('/users', 301)
})

// v5
app.get('/user', (req, res) => {
  res.redirect(301, '/users')
})


res.redirect('back') and res.location('back')

Express 5 no longer supports the magic string back in the res.redirect() and res.location() methods. Instead, use the req.get('Referrer') || '/' value to redirect back to the previous page. In Express 4, the res.redirect('back') and res.location('back') methods were deprecated.


   Note

  You can replace the deprecated signatures with the following command:

  npx @expressjs/codemod magic-redirect




// v4
app.get('/user', (req, res) => {
  res.redirect('back')
})

// v5
app.get('/user', (req, res) => {
  res.redirect(req.get('Referrer') || '/')
})


res.send(body, status)

Express 5 no longer supports the signature res.send(obj, status). Instead, set the status and then chain it to the res.send() method like this: res.status(status).send(obj).


   Note

  You can replace the deprecated signatures with the following command:

  npx @expressjs/codemod v4-deprecated-signatures




// v4
app.get('/user', (req, res) => {
  res.send({ name: 'Ruben' }, 200)
})

// v5
app.get('/user', (req, res) => {
  res.status(200).send({ name: 'Ruben' })
})


res.send(status)

Express 5 no longer supports the signature res.send(status), where status is a number. Instead, use the res.sendStatus(statusCode) function, which sets the HTTP response header status code and sends the text version of the code: “Not Found”, “Internal Server Error”, and so on.
If you need to send a number by using the res.send() function, quote the number to convert it to a string, so that Express does not interpret it as an attempt to use the unsupported old signature.


   Note

  You can replace the deprecated signatures with the following command:

  npx @expressjs/codemod v4-deprecated-signatures




// v4
app.get('/user', (req, res) => {
  res.send(200)
})

// v5
app.get('/user', (req, res) => {
  res.sendStatus(200)
})


res.sendfile()

The res.sendfile() function has been replaced by a camel-cased version res.sendFile() in Express 5.


   Note

  You can replace the deprecated signatures with the following command:

  npx @expressjs/codemod v4-deprecated-signatures




// v4
app.get('/user', (req, res) => {
  res.sendfile('/path/to/file')
})

// v5
app.get('/user', (req, res) => {
  res.sendFile('/path/to/file')
})


router.param(fn)

The router.param(fn) signature was used for modifying the behavior of the router.param(name, fn) function. It has been deprecated since v4.11.0, and Express 5 no longer supports it at all.

express.static.mime

In Express 5, mime is no longer an exported property of the static field.
Use the mime-types package to work with MIME type values.

// v4
express.static.mime.lookup('json')

// v5
const mime = require('mime-types')
mime.lookup('json')


express:router debug logs

In Express 5, router handling logic is performed by a dependency. Therefore, the
debug logs for the router are no longer available under the express: namespace.
In v4, the logs were available under the namespaces express:router, express:router:layer,
and express:router:route. All of these were included under the namespace express:*.
In v5.1+, the logs are available under the namespaces router, router:layer, and router:route.
The logs from router:layer and router:route are included in the namespace router:*.
To achieve the same detail of debug logging when using express:* in v4, use a conjunction of
express:*, router, and router:*.

# v4
DEBUG=express:* node index.js

# v5
DEBUG=express:*,router,router:* node index.js


Changed

Path route matching syntax

Path route matching syntax is when a string is supplied as the first parameter to the app.all(), app.use(), app.METHOD(), router.all(), router.METHOD(), and router.use() APIs. The following changes have been made to how the path string is matched to an incoming request:


  The wildcard * must have a name, matching the behavior of parameters :, use /*splat instead of /*


// v4
app.get('/*', async (req, res) => {
  res.send('ok')
})

// v5
app.get('/*splat', async (req, res) => {
  res.send('ok')
})



   Note

  *splat matches any path without the root path. If you need to match the root path as well /, you can use /{*splat}, wrapping the wildcard in braces.

  // v5
app.get('/{*splat}', async (req, res) => {
  res.send('ok')
})
  




  The optional character ? is no longer supported, use braces instead.


// v4
app.get('/:file.:ext?', async (req, res) => {
  res.send('ok')
})

// v5
app.get('/:file{.:ext}', async (req, res) => {
  res.send('ok')
})



  Regexp characters are not supported. For example:
    app.get('/[discussion|page]/:slug', async (req, res) => {
res.status(200).send('ok')
})
    
    should be changed to:
    app.get(['/discussion/:slug', '/page/:slug'], async (req, res) => {
res.status(200).send('ok')
})
    
  
  Some characters have been reserved to avoid confusion during upgrade (()[]?+!), use \ to escape them.
  Parameter names now support valid JavaScript identifiers, or quoted like :"this".


Rejected promises handled from middleware and handlers

Request middleware and handlers that return rejected promises are now handled by forwarding the rejected value as an Error to the error handling middleware. This means that using async functions as middleware and handlers are easier than ever. When an error is thrown in an async function or a rejected promise is awaited inside an async function, those errors will be passed to the error handler as if calling next(err).

Details of how Express handles errors is covered in the error handling documentation.

express.urlencoded

The express.urlencoded method makes the extended option false by default.

app.listen

In Express 5, the app.listen method will invoke the user-provided callback function (if provided) when the server receives an error event. In Express 4, such errors would be thrown. This change shifts error-handling responsibility to the callback function in Express 5. If there is an error, it will be passed to the callback as an argument.
For example:

const server = app.listen(8080, '0.0.0.0', (error) => {
  if (error) {
    throw error // e.g. EADDRINUSE
  }
  console.log(`Listening on ${JSON.stringify(server.address())}`)
})


app.router

The app.router object, which was removed in Express 4, has made a comeback in Express 5. In the new version, this object is a just a reference to the base Express router, unlike in Express 3, where an app had to explicitly load it.

req.body

The req.body property returns undefined when the body has not been parsed. In Express 4, it returns {} by default.

req.host

In Express 4, the req.host function incorrectly stripped off the port number if it was present. In Express 5, the port number is maintained.

req.query

The req.query property is no longer a writable property and is instead a getter. The default query parser has been changed from “extended” to “simple”.

res.clearCookie

The res.clearCookie method ignores the maxAge and expires options provided by the user.

res.status

The res.status method only accepts integers in the range of 100 to 999, following the behavior defined by Node.js, and it returns an error when the status code is not an integer.

res.vary

The res.vary throws an error when the field argument is missing. In Express 4, if the argument was omitted, it gave a warning in the console

Improvements

res.render()

This method now enforces asynchronous behavior for all view engines, avoiding bugs caused by view engines that had a synchronous implementation and that violated the recommended interface.

Brotli encoding support

Express 5 supports Brotli encoding for requests received from clients that support it.

              
    
    Edit this page\n\nMoving to Express 5

Overview

Express 5 is not very different from Express 4; although it maintains the same basic API, there are still changes that break compatibility with the previous version. Therefore, an application built with Express 4 might not work if you update it to use Express 5.

To install this version, you need to have a Node.js version 18 or higher. Then, execute the following command in your application directory:

npm install "express@5"


You can then run your automated tests to see what fails, and fix problems according to the updates listed below. After addressing test failures, run your app to see what errors occur. You’ll find out right away if the app uses any methods or properties that are not supported.

Express 5 Codemods

To help you migrate your express server, we have created a set of codemods that will help you automatically update your code to the latest version of Express.

Run the following command for run all the codemods available:

npx @expressjs/codemod upgrade


If you want to run a specific codemod, you can run the following command:

npx @expressjs/codemod name-of-the-codemod


You can find the list of available codemods here.

Changes in Express 5

Removed methods and properties


  app.del()
  app.param(fn)
  Pluralized method names
  Leading colon in name argument to app.param(name, fn)
  req.param(name)
  res.json(obj, status)
  res.jsonp(obj, status)
  res.redirect('back') and res.location('back')  
  res.redirect(url, status)
  res.send(body, status)
  res.send(status)
  res.sendfile()
  router.param(fn)
  express.static.mime
  express:router debug logs


Changed


  Path route matching syntax
  Rejected promises handled from middleware and handlers
  express.urlencoded
  app.listen
  app.router
  req.body
  req.host
  req.query
  res.clearCookie
  res.status
  res.vary


Improvements


  res.render()
  Brotli encoding support


Removed methods and properties

If you use any of these methods or properties in your app, it will crash. So, you’ll need to change your app after you update to version 5.

app.del()

Express 5 no longer supports the app.del() function. If you use this function, an error is thrown. For registering HTTP DELETE routes, use the app.delete() function instead.

Initially, del was used instead of delete, because delete is a reserved keyword in JavaScript. However, as of ECMAScript 6, delete and other reserved keywords can legally be used as property names.


   Note

  You can replace the deprecated signatures with the following command:

  npx @expressjs/codemod v4-deprecated-signatures




// v4
app.del('/user/:id', (req, res) => {
  res.send(`DELETE /user/${req.params.id}`)
})

// v5
app.delete('/user/:id', (req, res) => {
  res.send(`DELETE /user/${req.params.id}`)
})


app.param(fn)

The app.param(fn) signature was used for modifying the behavior of the app.param(name, fn) function. It has been deprecated since v4.11.0, and Express 5 no longer supports it at all.

Pluralized method names

The following method names have been pluralized. In Express 4, using the old methods resulted in a deprecation warning. Express 5 no longer supports them at all:

req.acceptsCharset() is replaced by req.acceptsCharsets().

req.acceptsEncoding() is replaced by req.acceptsEncodings().

req.acceptsLanguage() is replaced by req.acceptsLanguages().


   Note

  You can replace the deprecated signatures with the following command:

  npx @expressjs/codemod pluralized-methods




// v4
app.all('/', (req, res) => {
  req.acceptsCharset('utf-8')
  req.acceptsEncoding('br')
  req.acceptsLanguage('en')

  // ...
})

// v5
app.all('/', (req, res) => {
  req.acceptsCharsets('utf-8')
  req.acceptsEncodings('br')
  req.acceptsLanguages('en')

  // ...
})


Leading colon (:) in the name for app.param(name, fn)

A leading colon character (:) in the name for the app.param(name, fn) function is a remnant of Express 3, and for the sake of backwards compatibility, Express 4 supported it with a deprecation notice. Express 5 will silently ignore it and use the name parameter without prefixing it with a colon.

This should not affect your code if you follow the Express 4 documentation of app.param, as it makes no mention of the leading colon.

req.param(name)

This potentially confusing and dangerous method of retrieving form data has been removed. You will now need to specifically look for the submitted parameter name in the req.params, req.body, or req.query object.


   Note

  You can replace the deprecated signatures with the following command:

  npx @expressjs/codemod req-param




// v4
app.post('/user', (req, res) => {
  const id = req.param('id')
  const body = req.param('body')
  const query = req.param('query')

  // ...
})

// v5
app.post('/user', (req, res) => {
  const id = req.params.id
  const body = req.body
  const query = req.query

  // ...
})


res.json(obj, status)

Express 5 no longer supports the signature res.json(obj, status). Instead, set the status and then chain it to the res.json() method like this: res.status(status).json(obj).


   Note

  You can replace the deprecated signatures with the following command:

  npx @expressjs/codemod v4-deprecated-signatures




// v4
app.post('/user', (req, res) => {
  res.json({ name: 'Ruben' }, 201)
})

// v5
app.post('/user', (req, res) => {
  res.status(201).json({ name: 'Ruben' })
})


res.jsonp(obj, status)

Express 5 no longer supports the signature res.jsonp(obj, status). Instead, set the status and then chain it to the res.jsonp() method like this: res.status(status).jsonp(obj).


   Note

  You can replace the deprecated signatures with the following command:

  npx @expressjs/codemod v4-deprecated-signatures




// v4
app.post('/user', (req, res) => {
  res.jsonp({ name: 'Ruben' }, 201)
})

// v5
app.post('/user', (req, res) => {
  res.status(201).jsonp({ name: 'Ruben' })
})


res.redirect(url, status)

Express 5 no longer supports the signature res.redirect(url, status). Instead, use the following signature: res.redirect(status, url).


   Note

  You can replace the deprecated signatures with the following command:

  npx @expressjs/codemod v4-deprecated-signatures




// v4
app.get('/user', (req, res) => {
  res.redirect('/users', 301)
})

// v5
app.get('/user', (req, res) => {
  res.redirect(301, '/users')
})


res.redirect('back') and res.location('back')

Express 5 no longer supports the magic string back in the res.redirect() and res.location() methods. Instead, use the req.get('Referrer') || '/' value to redirect back to the previous page. In Express 4, the res.redirect('back') and res.location('back') methods were deprecated.


   Note

  You can replace the deprecated signatures with the following command:

  npx @expressjs/codemod magic-redirect




// v4
app.get('/user', (req, res) => {
  res.redirect('back')
})

// v5
app.get('/user', (req, res) => {
  res.redirect(req.get('Referrer') || '/')
})


res.send(body, status)

Express 5 no longer supports the signature res.send(obj, status). Instead, set the status and then chain it to the res.send() method like this: res.status(status).send(obj).


   Note

  You can replace the deprecated signatures with the following command:

  npx @expressjs/codemod v4-deprecated-signatures




// v4
app.get('/user', (req, res) => {
  res.send({ name: 'Ruben' }, 200)
})

// v5
app.get('/user', (req, res) => {
  res.status(200).send({ name: 'Ruben' })
})


res.send(status)

Express 5 no longer supports the signature res.send(status), where status is a number. Instead, use the res.sendStatus(statusCode) function, which sets the HTTP response header status code and sends the text version of the code: “Not Found”, “Internal Server Error”, and so on.
If you need to send a number by using the res.send() function, quote the number to convert it to a string, so that Express does not interpret it as an attempt to use the unsupported old signature.


   Note

  You can replace the deprecated signatures with the following command:

  npx @expressjs/codemod v4-deprecated-signatures




// v4
app.get('/user', (req, res) => {
  res.send(200)
})

// v5
app.get('/user', (req, res) => {
  res.sendStatus(200)
})


res.sendfile()

The res.sendfile() function has been replaced by a camel-cased version res.sendFile() in Express 5.


   Note

  You can replace the deprecated signatures with the following command:

  npx @expressjs/codemod v4-deprecated-signatures




// v4
app.get('/user', (req, res) => {
  res.sendfile('/path/to/file')
})

// v5
app.get('/user', (req, res) => {
  res.sendFile('/path/to/file')
})


router.param(fn)

The router.param(fn) signature was used for modifying the behavior of the router.param(name, fn) function. It has been deprecated since v4.11.0, and Express 5 no longer supports it at all.

express.static.mime

In Express 5, mime is no longer an exported property of the static field.
Use the mime-types package to work with MIME type values.

// v4
express.static.mime.lookup('json')

// v5
const mime = require('mime-types')
mime.lookup('json')


express:router debug logs

In Express 5, router handling logic is performed by a dependency. Therefore, the
debug logs for the router are no longer available under the express: namespace.
In v4, the logs were available under the namespaces express:router, express:router:layer,
and express:router:route. All of these were included under the namespace express:*.
In v5.1+, the logs are available under the namespaces router, router:layer, and router:route.
The logs from router:layer and router:route are included in the namespace router:*.
To achieve the same detail of debug logging when using express:* in v4, use a conjunction of
express:*, router, and router:*.

# v4
DEBUG=express:* node index.js

# v5
DEBUG=express:*,router,router:* node index.js


Changed

Path route matching syntax

Path route matching syntax is when a string is supplied as the first parameter to the app.all(), app.use(), app.METHOD(), router.all(), router.METHOD(), and router.use() APIs. The following changes have been made to how the path string is matched to an incoming request:


  The wildcard * must have a name, matching the behavior of parameters :, use /*splat instead of /*


// v4
app.get('/*', async (req, res) => {
  res.send('ok')
})

// v5
app.get('/*splat', async (req, res) => {
  res.send('ok')
})



   Note

  *splat matches any path without the root path. If you need to match the root path as well /, you can use /{*splat}, wrapping the wildcard in braces.

  // v5
app.get('/{*splat}', async (req, res) => {
  res.send('ok')
})
  




  The optional character ? is no longer supported, use braces instead.


// v4
app.get('/:file.:ext?', async (req, res) => {
  res.send('ok')
})

// v5
app.get('/:file{.:ext}', async (req, res) => {
  res.send('ok')
})



  Regexp characters are not supported. For example:
    app.get('/[discussion|page]/:slug', async (req, res) => {
res.status(200).send('ok')
})
    
    should be changed to:
    app.get(['/discussion/:slug', '/page/:slug'], async (req, res) => {
res.status(200).send('ok')
})
    
  
  Some characters have been reserved to avoid confusion during upgrade (()[]?+!), use \ to escape them.
  Parameter names now support valid JavaScript identifiers, or quoted like :"this".


Rejected promises handled from middleware and handlers

Request middleware and handlers that return rejected promises are now handled by forwarding the rejected value as an Error to the error handling middleware. This means that using async functions as middleware and handlers are easier than ever. When an error is thrown in an async function or a rejected promise is awaited inside an async function, those errors will be passed to the error handler as if calling next(err).

Details of how Express handles errors is covered in the error handling documentation.

express.urlencoded

The express.urlencoded method makes the extended option false by default.

app.listen

In Express 5, the app.listen method will invoke the user-provided callback function (if provided) when the server receives an error event. In Express 4, such errors would be thrown. This change shifts error-handling responsibility to the callback function in Express 5. If there is an error, it will be passed to the callback as an argument.
For example:

const server = app.listen(8080, '0.0.0.0', (error) => {
  if (error) {
    throw error // e.g. EADDRINUSE
  }
  console.log(`Listening on ${JSON.stringify(server.address())}`)
})


app.router

The app.router object, which was removed in Express 4, has made a comeback in Express 5. In the new version, this object is a just a reference to the base Express router, unlike in Express 3, where an app had to explicitly load it.

req.body

The req.body property returns undefined when the body has not been parsed. In Express 4, it returns {} by default.

req.host

In Express 4, the req.host function incorrectly stripped off the port number if it was present. In Express 5, the port number is maintained.

req.query

The req.query property is no longer a writable property and is instead a getter. The default query parser has been changed from “extended” to “simple”.

res.clearCookie

The res.clearCookie method ignores the maxAge and expires options provided by the user.

res.status

The res.status method only accepts integers in the range of 100 to 999, following the behavior defined by Node.js, and it returns an error when the status code is not an integer.

res.vary

The res.vary throws an error when the field argument is missing. In Express 4, if the argument was omitted, it gave a warning in the console

Improvements

res.render()

This method now enforces asynchronous behavior for all view engines, avoiding bugs caused by view engines that had a synchronous implementation and that violated the recommended interface.

Brotli encoding support

Express 5 supports Brotli encoding for requests received from clients that support it.

              
    
    Edit this page\n\n\n\nDatabase integration

Adding the capability to connect databases to Express apps is just a matter of loading an appropriate Node.js driver for the database in your app. This document briefly explains how to add and use some of the most popular Node.js modules for database systems in your Express app:


  Cassandra
  Couchbase
  CouchDB
  LevelDB
  MySQL
  MongoDB
  Neo4j
  Oracle
  PostgreSQL
  Redis
  SQL Server
  SQLite
  Elasticsearch



  These database drivers are among many that are available. For other options,
search on the npm site.


Cassandra

Module: cassandra-driver

Installation

$ npm install cassandra-driver


Example

const cassandra = require('cassandra-driver')
const client = new cassandra.Client({ contactPoints: ['localhost'] })

client.execute('select key from system.local', (err, result) => {
  if (err) throw err
  console.log(result.rows[0])
})


Couchbase

Module: couchnode

Installation

$ npm install couchbase


Example

const couchbase = require('couchbase')
const bucket = (new couchbase.Cluster('http://localhost:8091')).openBucket('bucketName')

// add a document to a bucket
bucket.insert('document-key', { name: 'Matt', shoeSize: 13 }, (err, result) => {
  if (err) {
    console.log(err)
  } else {
    console.log(result)
  }
})

// get all documents with shoe size 13
const n1ql = 'SELECT d.* FROM `bucketName` d WHERE shoeSize = $1'
const query = N1qlQuery.fromString(n1ql)
bucket.query(query, [13], (err, result) => {
  if (err) {
    console.log(err)
  } else {
    console.log(result)
  }
})


CouchDB

Module: nano

Installation

$ npm install nano


Example

const nano = require('nano')('http://localhost:5984')
nano.db.create('books')
const books = nano.db.use('books')

// Insert a book document in the books database
books.insert({ name: 'The Art of war' }, null, (err, body) => {
  if (err) {
    console.log(err)
  } else {
    console.log(body)
  }
})

// Get a list of all books
books.list((err, body) => {
  if (err) {
    console.log(err)
  } else {
    console.log(body.rows)
  }
})


LevelDB

Module: levelup

Installation

$ npm install level levelup leveldown


Example

const levelup = require('levelup')
const db = levelup('./mydb')

db.put('name', 'LevelUP', (err) => {
  if (err) return console.log('Ooops!', err)

  db.get('name', (err, value) => {
    if (err) return console.log('Ooops!', err)

    console.log(`name=${value}`)
  })
})


MySQL

Module: mysql

Installation

$ npm install mysql


Example

const mysql = require('mysql')
const connection = mysql.createConnection({
  host: 'localhost',
  user: 'dbuser',
  password: 's3kreee7',
  database: 'my_db'
})

connection.connect()

connection.query('SELECT 1 + 1 AS solution', (err, rows, fields) => {
  if (err) throw err

  console.log('The solution is: ', rows[0].solution)
})

connection.end()


MongoDB

Module: mongodb

Installation

$ npm install mongodb


Example (v2.*)

const MongoClient = require('mongodb').MongoClient

MongoClient.connect('mongodb://localhost:27017/animals', (err, db) => {
  if (err) throw err

  db.collection('mammals').find().toArray((err, result) => {
    if (err) throw err

    console.log(result)
  })
})


Example (v3.*)

const MongoClient = require('mongodb').MongoClient

MongoClient.connect('mongodb://localhost:27017/animals', (err, client) => {
  if (err) throw err

  const db = client.db('animals')

  db.collection('mammals').find().toArray((err, result) => {
    if (err) throw err

    console.log(result)
  })
})


If you want an object model driver for MongoDB, look at Mongoose.

Neo4j

Module: neo4j-driver

Installation

$ npm install neo4j-driver


Example

const neo4j = require('neo4j-driver')
const driver = neo4j.driver('neo4j://localhost:7687', neo4j.auth.basic('neo4j', 'letmein'))

const session = driver.session()

session.readTransaction((tx) => {
  return tx.run('MATCH (n) RETURN count(n) AS count')
    .then((res) => {
      console.log(res.records[0].get('count'))
    })
    .catch((error) => {
      console.log(error)
    })
})


Oracle

Module: oracledb

Installation

NOTE: See installation prerequisites.

$ npm install oracledb


Example

const oracledb = require('oracledb')
const config = {
  user: '<your db user>',
  password: '<your db password>',
  connectString: 'localhost:1521/orcl'
}

async function getEmployee (empId) {
  let conn

  try {
    conn = await oracledb.getConnection(config)

    const result = await conn.execute(
      'select * from employees where employee_id = :id',
      [empId]
    )

    console.log(result.rows[0])
  } catch (err) {
    console.log('Ouch!', err)
  } finally {
    if (conn) { // conn assignment worked, need to close
      await conn.close()
    }
  }
}

getEmployee(101)


PostgreSQL

Module: pg-promise

Installation

$ npm install pg-promise


Example

const pgp = require('pg-promise')(/* options */)
const db = pgp('postgres://username:password@host:port/database')

db.one('SELECT $1 AS value', 123)
  .then((data) => {
    console.log('DATA:', data.value)
  })
  .catch((error) => {
    console.log('ERROR:', error)
  })


Redis

Module: redis

Installation

$ npm install redis


Example

const redis = require('redis')
const client = redis.createClient()

client.on('error', (err) => {
  console.log(`Error ${err}`)
})

client.set('string key', 'string val', redis.print)
client.hset('hash key', 'hashtest 1', 'some value', redis.print)
client.hset(['hash key', 'hashtest 2', 'some other value'], redis.print)

client.hkeys('hash key', (err, replies) => {
  console.log(`${replies.length} replies:`)

  replies.forEach((reply, i) => {
    console.log(`    ${i}: ${reply}`)
  })

  client.quit()
})


SQL Server

Module: tedious

Installation

$ npm install tedious


Example

const Connection = require('tedious').Connection
const Request = require('tedious').Request

const config = {
  server: 'localhost',
  authentication: {
    type: 'default',
    options: {
      userName: 'your_username', // update me
      password: 'your_password' // update me
    }
  }
}

const connection = new Connection(config)

connection.on('connect', (err) => {
  if (err) {
    console.log(err)
  } else {
    executeStatement()
  }
})

function executeStatement () {
  request = new Request("select 123, 'hello world'", (err, rowCount) => {
    if (err) {
      console.log(err)
    } else {
      console.log(`${rowCount} rows`)
    }
    connection.close()
  })

  request.on('row', (columns) => {
    columns.forEach((column) => {
      if (column.value === null) {
        console.log('NULL')
      } else {
        console.log(column.value)
      }
    })
  })

  connection.execSql(request)
}


SQLite

Module: sqlite3

Installation

$ npm install sqlite3


Example

const sqlite3 = require('sqlite3').verbose()
const db = new sqlite3.Database(':memory:')

db.serialize(() => {
  db.run('CREATE TABLE lorem (info TEXT)')
  const stmt = db.prepare('INSERT INTO lorem VALUES (?)')

  for (let i = 0; i < 10; i++) {
    stmt.run(`Ipsum ${i}`)
  }

  stmt.finalize()

  db.each('SELECT rowid AS id, info FROM lorem', (err, row) => {
    console.log(`${row.id}: ${row.info}`)
  })
})

db.close()


Elasticsearch

Module: elasticsearch

Installation

$ npm install elasticsearch


Example

const elasticsearch = require('elasticsearch')
const client = elasticsearch.Client({
  host: 'localhost:9200'
})

client.search({
  index: 'books',
  type: 'book',
  body: {
    query: {
      multi_match: {
        query: 'express js',
        fields: ['title', 'description']
      }
    }
  }
}).then((response) => {
  const hits = response.hits.hits
}, (error) => {
  console.trace(error.message)
})


              
    
    Edit this page\n\nDatabase integration

Adding the capability to connect databases to Express apps is just a matter of loading an appropriate Node.js driver for the database in your app. This document briefly explains how to add and use some of the most popular Node.js modules for database systems in your Express app:


  Cassandra
  Couchbase
  CouchDB
  LevelDB
  MySQL
  MongoDB
  Neo4j
  Oracle
  PostgreSQL
  Redis
  SQL Server
  SQLite
  Elasticsearch



  These database drivers are among many that are available. For other options,
search on the npm site.


Cassandra

Module: cassandra-driver

Installation

$ npm install cassandra-driver


Example

const cassandra = require('cassandra-driver')
const client = new cassandra.Client({ contactPoints: ['localhost'] })

client.execute('select key from system.local', (err, result) => {
  if (err) throw err
  console.log(result.rows[0])
})


Couchbase

Module: couchnode

Installation

$ npm install couchbase


Example

const couchbase = require('couchbase')
const bucket = (new couchbase.Cluster('http://localhost:8091')).openBucket('bucketName')

// add a document to a bucket
bucket.insert('document-key', { name: 'Matt', shoeSize: 13 }, (err, result) => {
  if (err) {
    console.log(err)
  } else {
    console.log(result)
  }
})

// get all documents with shoe size 13
const n1ql = 'SELECT d.* FROM `bucketName` d WHERE shoeSize = $1'
const query = N1qlQuery.fromString(n1ql)
bucket.query(query, [13], (err, result) => {
  if (err) {
    console.log(err)
  } else {
    console.log(result)
  }
})


CouchDB

Module: nano

Installation

$ npm install nano


Example

const nano = require('nano')('http://localhost:5984')
nano.db.create('books')
const books = nano.db.use('books')

// Insert a book document in the books database
books.insert({ name: 'The Art of war' }, null, (err, body) => {
  if (err) {
    console.log(err)
  } else {
    console.log(body)
  }
})

// Get a list of all books
books.list((err, body) => {
  if (err) {
    console.log(err)
  } else {
    console.log(body.rows)
  }
})


LevelDB

Module: levelup

Installation

$ npm install level levelup leveldown


Example

const levelup = require('levelup')
const db = levelup('./mydb')

db.put('name', 'LevelUP', (err) => {
  if (err) return console.log('Ooops!', err)

  db.get('name', (err, value) => {
    if (err) return console.log('Ooops!', err)

    console.log(`name=${value}`)
  })
})


MySQL

Module: mysql

Installation

$ npm install mysql


Example

const mysql = require('mysql')
const connection = mysql.createConnection({
  host: 'localhost',
  user: 'dbuser',
  password: 's3kreee7',
  database: 'my_db'
})

connection.connect()

connection.query('SELECT 1 + 1 AS solution', (err, rows, fields) => {
  if (err) throw err

  console.log('The solution is: ', rows[0].solution)
})

connection.end()


MongoDB

Module: mongodb

Installation

$ npm install mongodb


Example (v2.*)

const MongoClient = require('mongodb').MongoClient

MongoClient.connect('mongodb://localhost:27017/animals', (err, db) => {
  if (err) throw err

  db.collection('mammals').find().toArray((err, result) => {
    if (err) throw err

    console.log(result)
  })
})


Example (v3.*)

const MongoClient = require('mongodb').MongoClient

MongoClient.connect('mongodb://localhost:27017/animals', (err, client) => {
  if (err) throw err

  const db = client.db('animals')

  db.collection('mammals').find().toArray((err, result) => {
    if (err) throw err

    console.log(result)
  })
})


If you want an object model driver for MongoDB, look at Mongoose.

Neo4j

Module: neo4j-driver

Installation

$ npm install neo4j-driver


Example

const neo4j = require('neo4j-driver')
const driver = neo4j.driver('neo4j://localhost:7687', neo4j.auth.basic('neo4j', 'letmein'))

const session = driver.session()

session.readTransaction((tx) => {
  return tx.run('MATCH (n) RETURN count(n) AS count')
    .then((res) => {
      console.log(res.records[0].get('count'))
    })
    .catch((error) => {
      console.log(error)
    })
})


Oracle

Module: oracledb

Installation

NOTE: See installation prerequisites.

$ npm install oracledb


Example

const oracledb = require('oracledb')
const config = {
  user: '<your db user>',
  password: '<your db password>',
  connectString: 'localhost:1521/orcl'
}

async function getEmployee (empId) {
  let conn

  try {
    conn = await oracledb.getConnection(config)

    const result = await conn.execute(
      'select * from employees where employee_id = :id',
      [empId]
    )

    console.log(result.rows[0])
  } catch (err) {
    console.log('Ouch!', err)
  } finally {
    if (conn) { // conn assignment worked, need to close
      await conn.close()
    }
  }
}

getEmployee(101)


PostgreSQL

Module: pg-promise

Installation

$ npm install pg-promise


Example

const pgp = require('pg-promise')(/* options */)
const db = pgp('postgres://username:password@host:port/database')

db.one('SELECT $1 AS value', 123)
  .then((data) => {
    console.log('DATA:', data.value)
  })
  .catch((error) => {
    console.log('ERROR:', error)
  })


Redis

Module: redis

Installation

$ npm install redis


Example

const redis = require('redis')
const client = redis.createClient()

client.on('error', (err) => {
  console.log(`Error ${err}`)
})

client.set('string key', 'string val', redis.print)
client.hset('hash key', 'hashtest 1', 'some value', redis.print)
client.hset(['hash key', 'hashtest 2', 'some other value'], redis.print)

client.hkeys('hash key', (err, replies) => {
  console.log(`${replies.length} replies:`)

  replies.forEach((reply, i) => {
    console.log(`    ${i}: ${reply}`)
  })

  client.quit()
})


SQL Server

Module: tedious

Installation

$ npm install tedious


Example

const Connection = require('tedious').Connection
const Request = require('tedious').Request

const config = {
  server: 'localhost',
  authentication: {
    type: 'default',
    options: {
      userName: 'your_username', // update me
      password: 'your_password' // update me
    }
  }
}

const connection = new Connection(config)

connection.on('connect', (err) => {
  if (err) {
    console.log(err)
  } else {
    executeStatement()
  }
})

function executeStatement () {
  request = new Request("select 123, 'hello world'", (err, rowCount) => {
    if (err) {
      console.log(err)
    } else {
      console.log(`${rowCount} rows`)
    }
    connection.close()
  })

  request.on('row', (columns) => {
    columns.forEach((column) => {
      if (column.value === null) {
        console.log('NULL')
      } else {
        console.log(column.value)
      }
    })
  })

  connection.execSql(request)
}


SQLite

Module: sqlite3

Installation

$ npm install sqlite3


Example

const sqlite3 = require('sqlite3').verbose()
const db = new sqlite3.Database(':memory:')

db.serialize(() => {
  db.run('CREATE TABLE lorem (info TEXT)')
  const stmt = db.prepare('INSERT INTO lorem VALUES (?)')

  for (let i = 0; i < 10; i++) {
    stmt.run(`Ipsum ${i}`)
  }

  stmt.finalize()

  db.each('SELECT rowid AS id, info FROM lorem', (err, row) => {
    console.log(`${row.id}: ${row.info}`)
  })
})

db.close()


Elasticsearch

Module: elasticsearch

Installation

$ npm install elasticsearch


Example

const elasticsearch = require('elasticsearch')
const client = elasticsearch.Client({
  host: 'localhost:9200'
})

client.search({
  index: 'books',
  type: 'book',
  body: {
    query: {
      multi_match: {
        query: 'express js',
        fields: ['title', 'description']
      }
    }
  }
}).then((response) => {
  const hits = response.hits.hits
}, (error) => {
  console.trace(error.message)
})


              
    
    Edit this page\n\n\n\n5.x API

  
     Note

    Express 5.0 requires Node.js 18 or higher.
    

  

  express()

  Creates an Express application. The express() function is a top-level function exported by the express module.

  const express = require('express')
const app = express()
  

  Methods

  
    express.json([options])

    This is a built-in middleware function in Express. It parses incoming requests
with JSON payloads and is based on
body-parser.

    Returns middleware that only parses JSON and only looks at requests where
the Content-Type header matches the type option. This parser accepts any
Unicode encoding of the body and supports automatic inflation of gzip and
deflate encodings.

    A new body object containing the parsed data is populated on the request
object after the middleware (i.e. req.body), or undefined if
there was no body to parse, the Content-Type was not matched, or an error
occurred.

    
      As req.body’s shape is based on user-controlled input, all properties and
values in this object are untrusted and should be validated before trusting.
For example, req.body.foo.toString() may fail in multiple ways, for example
foo may not be there or may not be a string, and toString may not be a
function and instead a string or other user-input.
    

    The following table describes the properties of the optional options object.

    
      
        
          Property
          Description
          Type
          Default
        
      
      
        
          inflate
          Enables or disables handling deflated (compressed) bodies; when disabled, deflated bodies are rejected.
          Boolean
          true
        
        
          limit
          Controls the maximum request body size. If this is a number, then the value specifies the number of bytes; if it is a string, the value is passed to the bytes library for parsing.
          Mixed
          "100kb"
        
        
          reviver
          The reviver option is passed directly to JSON.parse as the second argument. You can find more information on this argument in the MDN documentation about JSON.parse.
          Function
          null
        
        
          strict
          Enables or disables only accepting arrays and objects; when disabled will accept anything JSON.parse accepts.
          Boolean
          true
        
        
          type
          This is used to determine what media type the middleware will parse. This option can be a string, array of strings, or a function. If not a function, type option is passed directly to the type-is library and this can be an extension name (like json), a mime type (like application/json), or a mime type with a wildcard (like */* or */json). If a function, the type option is called as fn(req) and the request is parsed if it returns a truthy value.
          Mixed
          "application/json"
        
        
          verify
          This option, if supplied, is called as verify(req, res, buf, encoding), where buf is a Buffer of the raw request body and encoding is the encoding of the request. The parsing can be aborted by throwing an error.
          Function
          undefined
        
      
    

  

  
    express.raw([options])

    This is a built-in middleware function in Express. It parses incoming request
payloads into a Buffer and is based on
body-parser.

    Returns middleware that parses all bodies as a Buffer and only looks at requests
where the Content-Type header matches the type option. This parser accepts
any Unicode encoding of the body and supports automatic inflation of gzip and
deflate encodings.

    A new body Buffer containing the parsed data is populated on the request
object after the middleware (i.e. req.body), or undefined if
there was no body to parse, the Content-Type was not matched, or an error
occurred.

    
      As req.body’s shape is based on user-controlled input, all properties and
values in this object are untrusted and should be validated before trusting.
For example, req.body.toString() may fail in multiple ways, for example
stacking multiple parsers req.body may be from a different parser. Testing
that req.body is a Buffer before calling buffer methods is recommended.
    

    The following table describes the properties of the optional options object.

    
      
        
          Property
          Description
          Type
          Default
        
      
      
        
          inflate
          Enables or disables handling deflated (compressed) bodies; when disabled, deflated bodies are rejected.
          Boolean
          true
        
        
          limit
          Controls the maximum request body size. If this is a number, then the value specifies the number of bytes; if it is a string, the value is passed to the bytes library for parsing.
          Mixed
          "100kb"
        
        
          type
          This is used to determine what media type the middleware will parse. This option can be a string, array of strings, or a function. If not a function, type option is passed directly to the type-is library and this can be an extension name (like bin), a mime type (like application/octet-stream), or a mime type with a wildcard (like */* or application/*). If a function, the type option is called as fn(req) and the request is parsed if it returns a truthy value.
          Mixed
          "application/octet-stream"
        
        
          verify
          This option, if supplied, is called as verify(req, res, buf, encoding), where buf is a Buffer of the raw request body and encoding is the encoding of the request. The parsing can be aborted by throwing an error.
          Function
          undefined
        
      
    

  

  
    express.Router([options])

    Creates a new router object.

    const router = express.Router([options])
    

    The optional options parameter specifies the behavior of the router.

    

      
        
          
            Property
            Description
            Default
            Availability
          
        
        
          
            caseSensitive
            Enable case sensitivity.
            Disabled by default, treating “/Foo” and “/foo” as the same.
             
          
          
            mergeParams
            Preserve the req.params values from the parent router. If the parent and the child have conflicting param names, the child’s value take precedence.
            false
            4.5.0+
          
          
            strict
            Enable strict routing.
            Disabled by default, “/foo” and “/foo/” are treated the same by the router.
             
          
        
      

    

    You can add middleware and HTTP method routes (such as get, put, post, and
so on) to router just like an application.

    For more information, see Router.

  

  
    express.static(root, [options])

    This is a built-in middleware function in Express.
It serves static files and is based on  serve-static.

    
      NOTE: For best results, use a reverse proxy cache to improve performance of serving static assets.
    

    The root argument specifies the root directory from which to serve static assets.
The function determines the file to serve by combining req.url with the provided root directory.
When a file is not found, instead of sending a 404 response, it instead calls next()
to move on to the next middleware, allowing for stacking and fall-backs.

    The following table describes the properties of the options object.
See also the example below.

    
      
        
          Property
          Description
          Type
          Default
        
      
      
        
          dotfiles
          Determines how dotfiles (files or directories that begin with a dot “.”) are treated.  See dotfiles below.
          String
          “ignore”
        
        
          etag
          Enable or disable etag generation NOTE: express.static always sends weak ETags.
          Boolean
          true
        
        
          extensions
          Sets file extension fallbacks: If a file is not found, search for files with the specified extensions and serve the first one found. Example: ['html', 'htm'].
          Mixed
          false
        
        
          fallthrough
          Let client errors fall-through as unhandled requests, otherwise forward a client error. See fallthrough below.
          Boolean
          true
        
        
          immutable
          Enable or disable the immutable directive in the Cache-Control response header. If enabled, the maxAge option should also be specified to enable caching. The immutable directive will prevent supported clients from making conditional requests during the life of the maxAge option to check if the file has changed.
          Boolean
          false
        
        
          index
          Sends the specified directory index file. Set to false to disable directory indexing.
          Mixed
          “index.html”
        
        
          lastModified
          Set the Last-Modified header to the last modified date of the file on the OS.
          Boolean
          true
        
        
          maxAge
          Set the max-age property of the Cache-Control header in milliseconds or a string in ms format.
          Number
          0
        
        
          redirect
          Redirect to trailing “/” when the pathname is a directory.
          Boolean
          true
        
        
          setHeaders
          Function for setting HTTP headers to serve with the file. See setHeaders below.
          Function
           
        
      
    

    For more information, see Serving static files in Express.
and Using middleware - Built-in middleware.

     dotfiles

    Possible values for this option are:

    
      “allow” - No special treatment for dotfiles.
      “deny” - Deny a request for a dotfile, respond with 403, then call next().
      “ignore” - Act as if the dotfile does not exist, respond with 404, then call next().
    

    fallthrough

    When this option is true, client errors such as a bad request or a request to a non-existent
file will cause this middleware to simply call next() to invoke the next middleware in the stack.
When false, these errors (even 404s), will invoke next(err).

    Set this option to true so you can map multiple physical directories
to the same web address or for routes to fill in non-existent files.

    Use false if you have mounted this middleware at a path designed
to be strictly a single file system directory, which allows for short-circuiting 404s
for less overhead. This middleware will also reply to all methods.

    setHeaders

    For this option, specify a function to set custom response headers. Alterations to the headers must occur synchronously.

    The signature of the function is:

    fn(res, path, stat)
    

    Arguments:

    
      res, the response object.
      path, the file path that is being sent.
      stat, the stat object of the file that is being sent.
    

    Example of express.static

    Here is an example of using the express.static middleware function with an elaborate options object:

    const options = {
  dotfiles: 'ignore',
  etag: false,
  extensions: ['htm', 'html'],
  index: false,
  maxAge: '1d',
  redirect: false,
  setHeaders (res, path, stat) {
    res.set('x-timestamp', Date.now())
  }
}

app.use(express.static('public', options))
    

  

  
    express.text([options])

    This is a built-in middleware function in Express. It parses incoming request
payloads into a string and is based on
body-parser.

    Returns middleware that parses all bodies as a string and only looks at requests
where the Content-Type header matches the type option. This parser accepts
any Unicode encoding of the body and supports automatic inflation of gzip and
deflate encodings.

    A new body string containing the parsed data is populated on the request
object after the middleware (i.e. req.body), or undefined if
there was no body to parse, the Content-Type was not matched, or an error
occurred.

    
      As req.body’s shape is based on user-controlled input, all properties and
values in this object are untrusted and should be validated before trusting.
For example, req.body.trim() may fail in multiple ways, for example
stacking multiple parsers req.body may be from a different parser. Testing
that req.body is a string before calling string methods is recommended.
    

    The following table describes the properties of the optional options object.

    
      
        
          Property
          Description
          Type
          Default
        
      
      
        
          defaultCharset
          Specify the default character set for the text content if the charset is not specified in the Content-Type header of the request.
          String
          "utf-8"
        
        
          inflate
          Enables or disables handling deflated (compressed) bodies; when disabled, deflated bodies are rejected.
          Boolean
          true
        
        
          limit
          Controls the maximum request body size. If this is a number, then the value specifies the number of bytes; if it is a string, the value is passed to the bytes library for parsing.
          Mixed
          "100kb"
        
        
          type
          This is used to determine what media type the middleware will parse. This option can be a string, array of strings, or a function. If not a function, type option is passed directly to the type-is library and this can be an extension name (like txt), a mime type (like text/plain), or a mime type with a wildcard (like */* or text/*). If a function, the type option is called as fn(req) and the request is parsed if it returns a truthy value.
          Mixed
          "text/plain"
        
        
          verify
          This option, if supplied, is called as verify(req, res, buf, encoding), where buf is a Buffer of the raw request body and encoding is the encoding of the request. The parsing can be aborted by throwing an error.
          Function
          undefined
        
      
    

  

  
    express.urlencoded([options])

    This is a built-in middleware function in Express. It parses incoming requests
with urlencoded payloads and is based on body-parser.

    Returns middleware that only parses urlencoded bodies and only looks at
requests where the Content-Type header matches the type option. This
parser accepts only UTF-8 encoding of the body and supports automatic
inflation of gzip and deflate encodings.

    A new body object containing the parsed data is populated on the request
object after the middleware (i.e. req.body), or undefined if
there was no body to parse, the Content-Type was not matched, or an error
occurred. This object will contain key-value pairs, where the value can be
a string or array (when extended is false), or any type (when extended
is true).

    
      As req.body’s shape is based on user-controlled input, all properties and
values in this object are untrusted and should be validated before trusting.
For example, req.body.foo.toString() may fail in multiple ways, for example
foo may not be there or may not be a string, and toString may not be a
function and instead a string or other user-input.
    

    The following table describes the properties of the optional options object.

    
      
        
          Property
          Description
          Type
          Default
        
      
      
        
          extended
          This option allows to choose between parsing the URL-encoded data with the querystring library (when false) or the qs library (when true). The “extended” syntax allows for rich objects and arrays to be encoded into the URL-encoded format, allowing for a JSON-like experience with URL-encoded. For more information, please see the qs library.
          Boolean
          false
        
        
          inflate
          Enables or disables handling deflated (compressed) bodies; when disabled, deflated bodies are rejected.
          Boolean
          true
        
        
          limit
          Controls the maximum request body size. If this is a number, then the value specifies the number of bytes; if it is a string, the value is passed to the bytes library for parsing.
          Mixed
          "100kb"
        
        
          parameterLimit
          This option controls the maximum number of parameters that are allowed in the URL-encoded data. If a request contains more parameters than this value, an error will be raised.
          Number
          1000
        
        
          type
          This is used to determine what media type the middleware will parse. This option can be a string, array of strings, or a function. If not a function, type option is passed directly to the type-is library and this can be an extension name (like urlencoded), a mime type (like application/x-www-form-urlencoded), or a mime type with a wildcard (like */x-www-form-urlencoded). If a function, the type option is called as fn(req) and the request is parsed if it returns a truthy value.
          Mixed
          "application/x-www-form-urlencoded"
        
        
          verify
          This option, if supplied, is called as verify(req, res, buf, encoding), where buf is a Buffer of the raw request body and encoding is the encoding of the request. The parsing can be aborted by throwing an error.
          Function
          undefined
        
      
    

  

  Application

  The app object conventionally denotes the Express application.
Create it by calling the top-level express() function exported by the Express module:

  const express = require('express')
const app = express()

app.get('/', (req, res) => {
  res.send('hello world')
})

app.listen(3000)
  

  The app object has methods for

  
    Routing HTTP requests; see for example, app.METHOD and app.param.
    Configuring middleware; see app.route.
    Rendering HTML views; see app.render.
    Registering a template engine; see app.engine.
  

  It also has settings (properties) that affect how the application behaves;
for more information, see Application settings.

  
    The Express application object can be referred from the request object and the response object as req.app, and res.app, respectively.
  

  Properties

  
    app.locals

    The app.locals object has properties that are local variables within the application,
and will be available in templates rendered with res.render.

    
      The locals object is used by view engines to render a response. The object
keys may be particularly sensitive and should not contain user-controlled
input, as it may affect the operation of the view engine or provide a path to
cross-site scripting. Consult the documentation for the used view engine for
additional considerations.
    

    console.dir(app.locals.title)
// => 'My App'

console.dir(app.locals.email)
// => '[email protected]'
    

    Once set, the value of app.locals properties persist throughout the life of the application,
in contrast with res.locals properties that
are valid only for the lifetime of the request.

    You can access local variables in templates rendered within the application.
This is useful for providing helper functions to templates, as well as application-level data.
Local variables are available in middleware via req.app.locals (see req.app)

    app.locals.title = 'My App'
app.locals.strftime = require('strftime')
app.locals.email = '[email protected]'
    

  

  
    app.mountpath

    The app.mountpath property contains one or more path patterns on which a sub-app was mounted.

    
      A sub-app is an instance of express that may be used for handling the request to a route.
    

    const express = require('express')

const app = express() // the main app
const admin = express() // the sub app

admin.get('/', (req, res) => {
  console.log(admin.mountpath) // /admin
  res.send('Admin Homepage')
})

app.use('/admin', admin) // mount the sub app
    

    It is similar to the baseUrl property of the req object, except req.baseUrl
returns the matched URL path, instead of the matched patterns.

    If a sub-app is mounted on multiple path patterns, app.mountpath returns the list of
patterns it is mounted on, as shown in the following example.

    const admin = express()

admin.get('/', (req, res) => {
  console.log(admin.mountpath) // [ '/adm{*splat}n', '/manager' ]
  res.send('Admin Homepage')
})

const secret = express()
secret.get('/', (req, res) => {
  console.log(secret.mountpath) // /secr{*splat}t
  res.send('Admin Secret')
})

admin.use('/secr{*splat}t', secret) // load the 'secret' router on '/secr{*splat}t', on the 'admin' sub app
app.use(['/adm{*splat}n', '/manager'], admin) // load the 'admin' router on '/adm{*splat}n' and '/manager', on the parent app
    

  

  
    app.router

    The application’s in-built instance of router. This is created lazily, on first access.

    const express = require('express')
const app = express()
const router = app.router

router.get('/', (req, res) => {
  res.send('hello world')
})

app.listen(3000)
    

    You can add middleware and HTTP method routes to the router just like an application.

    For more information, see Router.

  

  Events

  
    app.on('mount', callback(parent))

    The mount event is fired on a sub-app, when it is mounted on a parent app. The parent app is passed to the callback function.

    
      NOTE

      Sub-apps will:

      
        Not inherit the value of settings that have a default value. You must set the value in the sub-app.
        Inherit the value of settings with no default value.
      

      For details, see Application settings.
    

    const admin = express()

admin.on('mount', (parent) => {
  console.log('Admin Mounted')
  console.log(parent) // refers to the parent app
})

admin.get('/', (req, res) => {
  res.send('Admin Homepage')
})

app.use('/admin', admin)
    

  

  Methods

  
    app.all(path, callback [, callback ...])

    This method is like the standard app.METHOD() methods,
except it matches all HTTP verbs.

     Arguments

    

Argument 
 Description 
 Default 



path

The path for which the middleware function is invoked; can be any of:

A string representing a path.
A path pattern.
A regular expression pattern to match paths.
An array of combinations of any of the above.


For examples, see Path examples.

'/' (root path)



 callback

Callback functions; can be:

A middleware function.
A series of middleware functions (separated by commas).
An array of middleware functions.
A combination of all of the above.


You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke next('route') to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.

When a callback function throws an error or returns a rejected promise, `next(err)` will be invoked automatically.

Since router and app implement the middleware interface,
you can use them as you would any other middleware function.

For examples, see Middleware callback function examples.


 None 


    Examples

    The following callback is executed for requests to /secret whether using
GET, POST, PUT, DELETE, or any other HTTP request method:

    app.all('/secret', (req, res, next) => {
  console.log('Accessing the secret section ...')
  next() // pass control to the next handler
})
    

    The app.all() method is useful for mapping “global” logic for specific path prefixes or arbitrary matches. For example, if you put the following at the top of all other
route definitions, it requires that all routes from that point on
require authentication, and automatically load a user. Keep in mind
that these callbacks do not have to act as end-points: loadUser
can perform a task, then call next() to continue matching subsequent
routes.

    app.all('{*splat}', requireAuthentication, loadUser)
    

    Or the equivalent:

    app.all('{*splat}', requireAuthentication)
app.all('{*splat}', loadUser)
    

    Another example is white-listed “global” functionality.
The example is similar to the ones above, but it only restricts paths that start with
“/api”:

    app.all('/api/{*splat}', requireAuthentication)
    

  

  
    app.delete(path, callback [, callback ...])

    Routes HTTP DELETE requests to the specified path with the specified callback functions.
For more information, see the routing guide.

     Arguments

    

Argument 
 Description 
 Default 



path

The path for which the middleware function is invoked; can be any of:

A string representing a path.
A path pattern.
A regular expression pattern to match paths.
An array of combinations of any of the above.


For examples, see Path examples.

'/' (root path)



 callback

Callback functions; can be:

A middleware function.
A series of middleware functions (separated by commas).
An array of middleware functions.
A combination of all of the above.


You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke next('route') to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.

When a callback function throws an error or returns a rejected promise, `next(err)` will be invoked automatically.

Since router and app implement the middleware interface,
you can use them as you would any other middleware function.

For examples, see Middleware callback function examples.


 None 


    Example

    app.delete('/', (req, res) => {
  res.send('DELETE request to homepage')
})
    

  

  
    app.disable(name)

    Sets the Boolean setting name to false, where name is one of the properties from the app settings table.
Calling app.set('foo', false) for a Boolean property is the same as calling app.disable('foo').

    For example:

    app.disable('trust proxy')
app.get('trust proxy')
// => false
    

  

  
    app.disabled(name)

    Returns true if the Boolean setting name is disabled (false), where name is one of the properties from
the app settings table.

    app.disabled('trust proxy')
// => true

app.enable('trust proxy')
app.disabled('trust proxy')
// => false
    

  

  
    app.enable(name)

    Sets the Boolean setting name to true, where name is one of the properties from the app settings table.
Calling app.set('foo', true) for a Boolean property is the same as calling app.enable('foo').

    app.enable('trust proxy')
app.get('trust proxy')
// => true
    

  

  
    app.enabled(name)

    Returns true if the setting name is enabled (true), where name is one of the
properties from the app settings table.

    app.enabled('trust proxy')
// => false

app.enable('trust proxy')
app.enabled('trust proxy')
// => true
    

  

  
    app.engine(ext, callback)

    Registers the given template engine callback as ext.

    By default, Express will require() the engine based on the file extension.
For example, if you try to render a “foo.pug” file, Express invokes the
following internally, and caches the require() on subsequent calls to increase
performance.

    app.engine('pug', require('pug').__express)
    

    Use this method for engines that do not provide .__express out of the box,
or if you wish to “map” a different extension to the template engine.

    For example, to map the EJS template engine to “.html” files:

    app.engine('html', require('ejs').renderFile)
    

    In this case, EJS provides a .renderFile() method with
the same signature that Express expects: (path, options, callback),
though note that it aliases this method as ejs.__express internally
so if you’re using “.ejs” extensions you don’t need to do anything.

    Some template engines do not follow this convention.  The
consolidate.js library maps Node template engines to follow this convention,
so they work seamlessly with Express.

    const engines = require('consolidate')
app.engine('haml', engines.haml)
app.engine('html', engines.hogan)
    

  

  
    app.get(name)

    Returns the value of name app setting, where name is one of the strings in the
app settings table. For example:

    app.get('title')
// => undefined

app.set('title', 'My Site')
app.get('title')
// => "My Site"
    

  

  
    app.get(path, callback [, callback ...])

    Routes HTTP GET requests to the specified path with the specified callback functions.

     Arguments

    

Argument 
 Description 
 Default 



path

The path for which the middleware function is invoked; can be any of:

A string representing a path.
A path pattern.
A regular expression pattern to match paths.
An array of combinations of any of the above.


For examples, see Path examples.

'/' (root path)



 callback

Callback functions; can be:

A middleware function.
A series of middleware functions (separated by commas).
An array of middleware functions.
A combination of all of the above.


You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke next('route') to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.

When a callback function throws an error or returns a rejected promise, `next(err)` will be invoked automatically.

Since router and app implement the middleware interface,
you can use them as you would any other middleware function.

For examples, see Middleware callback function examples.


 None 


    For more information, see the routing guide.

    Example

    app.get('/', (req, res) => {
  res.send('GET request to homepage')
})
    

  

  
    app.listen(path, [callback])

    Starts a UNIX socket and listens for connections on the given path.
This method is identical to Node’s http.Server.listen().

    const express = require('express')
const app = express()
app.listen('/tmp/sock')
    

    app.listen([port[, host[, backlog]]][, callback])

    Binds and listens for connections on the specified host and port.
This method is identical to Node’s http.Server.listen().

    If port is omitted or is 0, the operating system will assign an arbitrary unused
port, which is useful for cases like automated tasks (tests, etc.).

    const express = require('express')
const app = express()
app.listen(3000)
    

    The app returned by express() is in fact a JavaScript
Function, designed to be passed to Node’s HTTP servers as a callback
to handle requests. This makes it easy to provide both HTTP and HTTPS versions of
your app with the same code base, as the app does not inherit from these
(it is simply a callback):

    const express = require('express')
const https = require('https')
const http = require('http')
const app = express()

http.createServer(app).listen(80)
https.createServer(options, app).listen(443)
    

    The app.listen() method returns an http.Server object and (for HTTP) is a convenience method for the following:

    app.listen = function () {
  const server = http.createServer(this)
  return server.listen.apply(server, arguments)
}
    

    
       Note
      All the forms of Node’s http.Server.listen() method are in fact actually supported.
    

  

  
    app.METHOD(path, callback [, callback ...])

    Routes an HTTP request, where METHOD is the HTTP method of the request, such as GET,
PUT, POST, and so on, in lowercase. Thus, the actual methods are app.get(),
app.post(), app.put(), and so on. See Routing methods below for the complete list.

     Arguments

    

Argument 
 Description 
 Default 



path

The path for which the middleware function is invoked; can be any of:

A string representing a path.
A path pattern.
A regular expression pattern to match paths.
An array of combinations of any of the above.


For examples, see Path examples.

'/' (root path)



 callback

Callback functions; can be:

A middleware function.
A series of middleware functions (separated by commas).
An array of middleware functions.
A combination of all of the above.


You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke next('route') to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.

When a callback function throws an error or returns a rejected promise, `next(err)` will be invoked automatically.

Since router and app implement the middleware interface,
you can use them as you would any other middleware function.

For examples, see Middleware callback function examples.


 None 


    Routing methods

    Express supports the following routing methods corresponding to the HTTP methods of the same names:

    


          
            checkout
            copy
            delete
            get
            head
            lock
            merge
            mkactivity
          
        

          
            mkcol
            move
            m-search
            notify
            options
            patch
            post
          
        

          
            purge
            put
            report
            search
            subscribe
            trace
            unlock
            unsubscribe
          
        



    The API documentation has explicit entries only for the most popular HTTP methods app.get(),
app.post(), app.put(), and app.delete().
However, the other methods listed above work in exactly the same way.

    To route methods that translate to invalid JavaScript variable names, use the bracket notation. For example, app['m-search']('/', function ....

    
      The app.get() function is automatically called for the HTTP HEAD method in addition to the GET
  method if app.head() was not called for the path before app.get().
    

    The method, app.all(), is not derived from any HTTP method and loads middleware at
the specified path for all HTTP request methods.
For more information, see app.all.

    For more information on routing, see the routing guide.

  

  
    app.param(name, callback)

    Add callback triggers to route parameters, where name is the name of the parameter or an array of them, and callback is the callback function. The parameters of the callback function are the request object, the response object, the next middleware, the value of the parameter and the name of the parameter, in that order.

    If name is an array, the callback trigger is registered for each parameter declared in it, in the order in which they are declared. Furthermore, for each declared parameter except the last one, a call to next inside the callback will call the callback for the next declared parameter. For the last parameter, a call to next will call the next middleware in place for the route currently being processed, just like it would if name were just a string.

    For example, when :user is present in a route path, you may map user loading logic to automatically provide req.user to the route, or perform validations on the parameter input.

    app.param('user', (req, res, next, id) => {
  // try to get the user details from the User model and attach it to the request object
  User.find(id, (err, user) => {
    if (err) {
      next(err)
    } else if (user) {
      req.user = user
      next()
    } else {
      next(new Error('failed to load user'))
    }
  })
})
    

    Param callback functions are local to the router on which they are defined. They are not inherited by mounted apps or routers, nor are they triggered for route parameters inherited from parent routers. Hence, param callbacks defined on app will be triggered only by route parameters defined on app routes.

    All param callbacks will be called before any handler of any route in which the param occurs, and they will each be called only once in a request-response cycle, even if the parameter is matched in multiple routes, as shown in the following examples.

    app.param('id', (req, res, next, id) => {
  console.log('CALLED ONLY ONCE')
  next()
})

app.get('/user/:id', (req, res, next) => {
  console.log('although this matches')
  next()
})

app.get('/user/:id', (req, res) => {
  console.log('and this matches too')
  res.end()
})
    

    On GET /user/42, the following is printed:

    CALLED ONLY ONCE
although this matches
and this matches too
    

    app.param(['id', 'page'], (req, res, next, value) => {
  console.log('CALLED ONLY ONCE with', value)
  next()
})

app.get('/user/:id/:page', (req, res, next) => {
  console.log('although this matches')
  next()
})

app.get('/user/:id/:page', (req, res) => {
  console.log('and this matches too')
  res.end()
})
    

    On GET /user/42/3, the following is printed:

    CALLED ONLY ONCE with 42
CALLED ONLY ONCE with 3
although this matches
and this matches too
    

  

  
    app.path()

    Returns the canonical path of the app, a string.

    const app = express()
const blog = express()
const blogAdmin = express()

app.use('/blog', blog)
blog.use('/admin', blogAdmin)

console.log(app.path()) // ''
console.log(blog.path()) // '/blog'
console.log(blogAdmin.path()) // '/blog/admin'
    

    The behavior of this method can become very complicated in complex cases of mounted apps:
it is usually better to use req.baseUrl to get the canonical path of the app.

  

  
    app.post(path, callback [, callback ...])

    Routes HTTP POST requests to the specified path with the specified callback functions.
For more information, see the routing guide.

     Arguments

    

Argument 
 Description 
 Default 



path

The path for which the middleware function is invoked; can be any of:

A string representing a path.
A path pattern.
A regular expression pattern to match paths.
An array of combinations of any of the above.


For examples, see Path examples.

'/' (root path)



 callback

Callback functions; can be:

A middleware function.
A series of middleware functions (separated by commas).
An array of middleware functions.
A combination of all of the above.


You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke next('route') to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.

When a callback function throws an error or returns a rejected promise, `next(err)` will be invoked automatically.

Since router and app implement the middleware interface,
you can use them as you would any other middleware function.

For examples, see Middleware callback function examples.


 None 


    Example

    app.post('/', (req, res) => {
  res.send('POST request to homepage')
})
    

  

  
    app.put(path, callback [, callback ...])

    Routes HTTP PUT requests to the specified path with the specified callback functions.

     Arguments

    

Argument 
 Description 
 Default 



path

The path for which the middleware function is invoked; can be any of:

A string representing a path.
A path pattern.
A regular expression pattern to match paths.
An array of combinations of any of the above.


For examples, see Path examples.

'/' (root path)



 callback

Callback functions; can be:

A middleware function.
A series of middleware functions (separated by commas).
An array of middleware functions.
A combination of all of the above.


You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke next('route') to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.

When a callback function throws an error or returns a rejected promise, `next(err)` will be invoked automatically.

Since router and app implement the middleware interface,
you can use them as you would any other middleware function.

For examples, see Middleware callback function examples.


 None 


    Example

    app.put('/', (req, res) => {
  res.send('PUT request to homepage')
})
    

  

  
    app.render(view, [locals], callback)

    Returns the rendered HTML of a view via the callback function. It accepts an optional parameter
that is an object containing local variables for the view. It is like res.render(),
except it cannot send the rendered view to the client on its own.

    
      Think of app.render() as a utility function for generating rendered view strings.
Internally res.render() uses app.render() to render views.
    

    
      The view argument performs file system operations like reading a file from
disk and evaluating Node.js modules, and as so for security reasons should not
contain input from the end-user.
    

    
      The locals object is used by view engines to render a response. The object
keys may be particularly sensitive and should not contain user-controlled
input, as it may affect the operation of the view engine or provide a path to
cross-site scripting. Consult the documentation for the used view engine for
additional considerations.
    

    
      The local variable cache is reserved for enabling view cache. Set it to true, if you want to
cache view during development; view caching is enabled in production by default.
    

    app.render('email', (err, html) => {
  // ...
})

app.render('email', { name: 'Tobi' }, (err, html) => {
  // ...
})
    

  

  
    app.route(path)

    Returns an instance of a single route, which you can then use to handle HTTP verbs with optional middleware.
Use app.route() to avoid duplicate route names (and thus typo errors).

    const app = express()

app.route('/events')
  .all((req, res, next) => {
    // runs for all HTTP verbs first
    // think of it as route specific middleware!
  })
  .get((req, res, next) => {
    res.json({})
  })
  .post((req, res, next) => {
    // maybe add a new event...
  })
    

  

  
    app.set(name, value)

    Assigns setting name to value. You may store any value that you want,
but certain names can be used to configure the behavior of the server. These
special names are listed in the app settings table.

    Calling app.set('foo', true) for a Boolean property is the same as calling
app.enable('foo'). Similarly, calling app.set('foo', false) for a Boolean
property is the same as calling app.disable('foo').

    Retrieve the value of a setting with app.get().

    app.set('title', 'My Site')
app.get('title') // "My Site"
    

    Application Settings

    The following table lists application settings.

    Note that sub-apps will:

    
      Not inherit the value of settings that have a default value. You must set the value in the sub-app.
      Inherit the value of settings with no default value; these are explicitly noted in the table below.
    

    Exceptions: Sub-apps will inherit the value of trust proxy even though it has a default value (for backward-compatibility);
Sub-apps will not inherit the value of view cache in production (when NODE_ENV is “production”).

    
  
    PropertyTypeDescriptionDefault
    
    
  
              case sensitive routing
            
      Boolean
      Enable case sensitivity.
      When enabled, "/Foo" and "/foo" are different routes.
      When disabled, "/Foo" and "/foo" are treated the same.
        NOTE: Sub-apps will inherit the value of this setting.
      
      N/A (undefined)
      
    
    
  
              env
            
      String
      Environment mode.
      Be sure to set to "production" in a production environment;
      see Production best practices: performance and reliability.
    
  
              process.env.NODE_ENV (NODE_ENV environment variable) or “development” if NODE_ENV is not set.
            
    
    
  
              etag
            
  Varied
  
              Set the ETag response header. For possible values, see the etag options table.

              More about the HTTP ETag header.
            
  
              weak
            
    
    
  
              jsonp callback name
            
      String
      Specifies the default JSONP callback name.
  
              “callback”
            
    
    
  
              json escape
            
  Boolean
  
              Enable escaping JSON responses from the res.json, res.jsonp, and res.send APIs. This will escape the characters <, >, and & as Unicode escape sequences in JSON. The purpose of this is to assist with mitigating certain types of persistent XSS attacks when clients sniff responses for HTML.
              NOTE: Sub-apps will inherit the value of this setting.
            
  N/A (undefined)
    
    
  
              json replacer
            
      Varied
      The 'replacer' argument used by `JSON.stringify`.
        NOTE: Sub-apps will inherit the value of this setting.
      
  N/A (undefined)
  
    
    
  
              json spaces
            
      Varied
      The 'space' argument used by `JSON.stringify`.
This is typically set to the number of spaces to use to indent prettified JSON.
        NOTE: Sub-apps will inherit the value of this setting.
      
      N/A (undefined)
    
    
  
              query parser
            
      Varied
  
              Disable query parsing by setting the value to false, or set the query parser to use either “simple” or “extended” or a custom query string parsing function.

              The simple query parser is based on Node’s native query parser, querystring.

              The extended query parser is based on qs.

              A custom query string parsing function will receive the complete query string, and must return an object of query keys and their values.
            
      "simple"
    
    
  
              strict routing
            
      Boolean
      Enable strict routing.
      When enabled, the router treats "/foo" and "/foo/" as different.
      Otherwise, the router treats "/foo" and "/foo/" as the same.
        NOTE: Sub-apps will inherit the value of this setting.
      
      N/A (undefined) 
    
    
  
              subdomain offset
            
      Number
      The number of dot-separated parts of the host to remove to access subdomain.
      2
    
    
  
              trust proxy
            
      Varied
  
              Indicates the app is behind a front-facing proxy, and to use the X-Forwarded-* headers to determine the connection and the IP address of the client. NOTE: X-Forwarded-* headers are easily spoofed and the detected IP addresses are unreliable.
              
  When enabled, Express attempts to determine the IP address of the client connected through the front-facing proxy, or series of proxies. The `req.ips` property, then contains an array of IP addresses the client is connected through. To enable it, use the values described in the trust proxy options table.

              
  The `trust proxy` setting is implemented using the proxy-addr package. For more information, see its documentation.

              
NOTE: Sub-apps will inherit the value of this setting, even though it has a default value.

            
  
              false (disabled)
            
    
    
  
              views
            
      String or Array
      A directory or an array of directories for the application's views. If an array, the views are looked up in the order they occur in the array.
  
              process.cwd() + '/views'
            
    
    
  
              view cache
            
      Boolean
      Enables view template compilation caching.
      NOTE: Sub-apps will not inherit the value of this setting in production (when `NODE_ENV` is "production").
      
  
              true in production, otherwise undefined.
            
    
    
  
              view engine
            
      String
      The default engine extension to use when omitted.
        NOTE: Sub-apps will inherit the value of this setting.
      
      N/A (undefined)
    
    
  
              x-powered-by
            
      Boolean
      Enables the "X-Powered-By: Express" HTTP header.
  
              true
            
    
    
  

  Options for `trust proxy` setting

  
  Read Express behind proxies for more
  information.
  

  
    TypeValue
    
      
        Boolean
  
              If true, the client’s IP address is understood as the left-most entry in the X-Forwarded-* header.

              If false, the app is understood as directly facing the Internet and the client’s IP address is derived from req.connection.remoteAddress. This is the default setting.
            
      
      
        StringString containing comma-separated valuesArray of strings 
  
              An IP address, subnet, or an array of IP addresses, and subnets to trust. Pre-configured subnet names are:

              
                loopback - 127.0.0.1/8, ::1/128
                linklocal - 169.254.0.0/16, fe80::/10
                uniquelocal - 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, fc00::/7
              

              Set IP addresses in any of the following ways:

              Specify a single subnet:

              app.set('trust proxy', 'loopback')
              

              Specify a subnet and an address:

              app.set('trust proxy', 'loopback, 123.123.123.123')
              

              Specify multiple subnets as CSV:

              app.set('trust proxy', 'loopback, linklocal, uniquelocal')
              

              Specify multiple subnets as an array:

              app.set('trust proxy', ['loopback', 'linklocal', 'uniquelocal'])
              

              When specified, the IP addresses or the subnets are excluded from the address determination process, and the untrusted IP address nearest to the application server is determined as the client’s IP address.
            
      
      
        Number
  
              Trust the nth hop from the front-facing proxy server as the client.
            
      
      
        Function
  
              Custom trust implementation. Use this only if you know what you are doing.

              app.set('trust proxy', (ip) => {
  if (ip === '127.0.0.1' || ip === '123.123.123.123') return true // trusted IPs
  else return false
})
              
            
      
    
  

  Options for `etag` setting


NOTE:  These settings apply only to dynamic files, not static files.
The express.static middleware ignores these settings.


  
  The ETag functionality is implemented using the
  etag package.
  For more information, see its documentation.
  

  
    TypeValue
    
      
        Boolean
  
              true enables weak ETag. This is the default setting.
  false disables ETag altogether.
            
      
      
        String
        
            If "strong", enables strong ETag.
            If "weak", enables weak ETag.
        
      
      
        Function
  
              Custom ETag function implementation. Use this only if you know what you are doing.

              app.set('etag', (body, encoding) => {
  return generateHash(body, encoding) // consider the function is defined
})
              
            
      
    
  


  

  
    app.use([path,] callback [, callback...])

    Mounts the specified middleware function or functions
at the specified path:
the middleware function is executed when the base of the requested path matches path.

     Arguments

    

Argument 
 Description 
 Default 



path

The path for which the middleware function is invoked; can be any of:

A string representing a path.
A path pattern.
A regular expression pattern to match paths.
An array of combinations of any of the above.


For examples, see Path examples.

'/' (root path)



 callback

Callback functions; can be:

A middleware function.
A series of middleware functions (separated by commas).
An array of middleware functions.
A combination of all of the above.


You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke next('route') to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.

When a callback function throws an error or returns a rejected promise, `next(err)` will be invoked automatically.

Since router and app implement the middleware interface,
you can use them as you would any other middleware function.

For examples, see Middleware callback function examples.


 None 


    Description

    A route will match any path that follows its path immediately with a “/”.
For example: app.use('/apple', ...) will match “/apple”, “/apple/images”,
“/apple/images/news”, and so on.

    Since path defaults to “/”, middleware mounted without a path will be executed for every request to the app.
For example, this middleware function will be executed for every request to the app:

    app.use((req, res, next) => {
  console.log('Time: %d', Date.now())
  next()
})
    

    
      NOTE

      Sub-apps will:

      
        Not inherit the value of settings that have a default value. You must set the value in the sub-app.
        Inherit the value of settings with no default value.
      

      For details, see Application settings.
    

    Middleware functions are executed sequentially, therefore the order of middleware inclusion is important.

    // this middleware will not allow the request to go beyond it
app.use((req, res, next) => {
  res.send('Hello World')
})

// requests will never reach this route
app.get('/', (req, res) => {
  res.send('Welcome')
})
    

    Error-handling middleware

    Error-handling middleware always takes four arguments. You must provide four arguments to identify it as an error-handling middleware function. Even if you don’t need to use the next object, you must specify it to maintain the signature. Otherwise, the next object will be interpreted as regular middleware and will fail to handle errors. For details about error-handling middleware, see: Error handling.

    Define error-handling middleware functions in the same way as other middleware functions, except with four arguments instead of three, specifically with the signature (err, req, res, next)):

    app.use((err, req, res, next) => {
  console.error(err.stack)
  res.status(500).send('Something broke!')
})
    

    Path examples

    The following table provides some simple examples of valid path values for
mounting middleware.

    




Type
Example






Path

              This will match paths starting with /abcd:

              app.use('/abcd', (req, res, next) => {
  next()
})
              

            



Path Pattern

              This will match paths starting with /abcd and /abd:

              app.use('/ab{c}d', (req, res, next) => {
  next()
})
              

            



Regular Expression

              This will match paths starting with /abc and /xyz:

              app.use(/\/abc|\/xyz/, (req, res, next) => {
  next()
})
              

            



Array

              This will match paths starting with /abcd, /xyza, /lmn, and /pqr:

              app.use(['/abcd', '/xyza', /\/lmn|\/pqr/], (req, res, next) => {
  next()
})
              

            







    Middleware callback function examples

    The following table provides some simple examples of middleware functions that
can be used as the callback argument to app.use(), app.METHOD(), and app.all().

    



Usage
Example





Single Middleware

            You can define and mount a middleware function locally.

            app.use((req, res, next) => {
  next()
})
            

            A router is valid middleware.

            const router = express.Router()
router.get('/', (req, res, next) => {
  next()
})
app.use(router)
            

            An Express app is valid middleware.

            const subApp = express()
subApp.get('/', (req, res, next) => {
  next()
})
app.use(subApp)
            

          



Series of Middleware

            You can specify more than one middleware function at the same mount path.

            const r1 = express.Router()
r1.get('/', (req, res, next) => {
  next()
})

const r2 = express.Router()
r2.get('/', (req, res, next) => {
  next()
})

app.use(r1, r2)
            

          



Array

            Use an array to group middleware logically.

            const r1 = express.Router()
r1.get('/', (req, res, next) => {
  next()
})

const r2 = express.Router()
r2.get('/', (req, res, next) => {
  next()
})

app.use([r1, r2])
            

          



Combination

            You can combine all the above ways of mounting middleware.

            function mw1 (req, res, next) { next() }
function mw2 (req, res, next) { next() }

const r1 = express.Router()
r1.get('/', (req, res, next) => { next() })

const r2 = express.Router()
r2.get('/', (req, res, next) => { next() })

const subApp = express()
subApp.get('/', (req, res, next) => { next() })

app.use(mw1, [mw2, r1, r2], subApp)
            

          






    Following are some examples of using the express.static
middleware in an Express app.

    Serve static content for the app from the “public” directory in the application directory:

    // GET /style.css etc
app.use(express.static(path.join(__dirname, 'public')))
    

    Mount the middleware at “/static” to serve static content only when their request path is prefixed with “/static”:

    // GET /static/style.css etc.
app.use('/static', express.static(path.join(__dirname, 'public')))
    

    Disable logging for static content requests by loading the logger middleware after the static middleware:

    app.use(express.static(path.join(__dirname, 'public')))
app.use(logger())
    

    Serve static files from multiple directories, but give precedence to “./public” over the others:

    app.use(express.static(path.join(__dirname, 'public')))
app.use(express.static(path.join(__dirname, 'files')))
app.use(express.static(path.join(__dirname, 'uploads')))
    

  

  Request

  The req object represents the HTTP request and has properties for the
request query string, parameters, body, HTTP headers, and so on. In this documentation and by convention,
the object is always referred to as req (and the HTTP response is res) but its actual name is determined
by the parameters to the callback function in which you’re working.

  For example:

  app.get('/user/:id', (req, res) => {
  res.send(`user ${req.params.id}`)
})
  

  But you could just as well have:

  app.get('/user/:id', (request, response) => {
  response.send(`user ${request.params.id}`)
})
  

  The req object is an enhanced version of Node’s own request object
and supports all built-in fields and methods.

  Properties

  
    In Express 4, req.files is no longer available on the req object by default. To access uploaded files
on the req.files object, use multipart-handling middleware like busboy, multer,
formidable,
multiparty,
connect-multiparty,
or pez.
  

  
    req.app

    This property holds a reference to the instance of the Express application that is using the middleware.

    If you follow the pattern in which you create a module that just exports a middleware function
and require() it in your main file, then the middleware can access the Express instance via req.app

    For example:

    // index.js
app.get('/viewdirectory', require('./mymiddleware.js'))
    

    // mymiddleware.js
module.exports = (req, res) => {
  res.send(`The views directory is ${req.app.get('views')}`)
}
    

  

  
    req.baseUrl

    The URL path on which a router instance was mounted.

    The req.baseUrl property is similar to the mountpath property of the app object,
except app.mountpath returns the matched path pattern(s).

    For example:

    const greet = express.Router()

greet.get('/jp', (req, res) => {
  console.log(req.baseUrl) // /greet
  res.send('Konichiwa!')
})

app.use('/greet', greet) // load the router on '/greet'
    

    Even if you use a path pattern or a set of path patterns to load the router,
the baseUrl property returns the matched string, not the pattern(s). In the
following example, the greet router is loaded on two path patterns.

    app.use(['/gre:"param"t', '/hel{l}o'], greet) // load the router on '/gre:"param"t' and '/hel{l}o'
    

    When a request is made to /greet/jp, req.baseUrl is “/greet”. When a request is
made to /hello/jp, req.baseUrl is “/hello”.

  

  
    req.body

    Contains key-value pairs of data submitted in the request body.
By default, it is undefined, and is populated when you use body-parsing middleware such
as express.json() or express.urlencoded().

    
      As req.body’s shape is based on user-controlled input, all properties and values in this object are untrusted and should be validated before trusting. For example, req.body.foo.toString() may fail in multiple ways, for example foo may not be there or may not be a string, and toString may not be a function and instead a string or other user-input.
    

    The following example shows how to use body-parsing middleware to populate req.body.

    const express = require('express')

const app = express()

app.use(express.json()) // for parsing application/json
app.use(express.urlencoded({ extended: true })) // for parsing application/x-www-form-urlencoded

app.post('/profile', (req, res, next) => {
  console.log(req.body)
  res.json(req.body)
})
    

  

  
    req.cookies

    When using cookie-parser middleware, this property is an object that
contains cookies sent by the request. If the request contains no cookies, it defaults to {}.

    // Cookie: name=tj
console.dir(req.cookies.name)
// => "tj"
    

    If the cookie has been signed, you have to use req.signedCookies.

    For more information, issues, or concerns, see cookie-parser.

  

  
    req.fresh

    When the response is still “fresh” in the client’s cache true is returned, otherwise false is returned to indicate that the client cache is now stale and the full response should be sent.

    When a client sends the Cache-Control: no-cache request header to indicate an end-to-end reload request, this module will return false to make handling these requests transparent.

    Further details for how cache validation works can be found in the
HTTP/1.1 Caching Specification.

    console.dir(req.fresh)
// => true
    

  

  
    req.host

    Contains the host derived from the Host HTTP header.

    When the trust proxy setting
does not evaluate to false, this property will instead get the value
from the X-Forwarded-Host header field. This header can be set by
the client or by the proxy.

    If there is more than one X-Forwarded-Host header in the request, the
value of the first header is used. This includes a single header with
comma-separated values, in which the first value is used.

    // Host: "example.com:3000"
console.dir(req.host)
// => 'example.com:3000'

// Host: "[::1]:3000"
console.dir(req.host)
// => '[::1]:3000'
    

  

  
    req.hostname

    Contains the hostname derived from the Host HTTP header.

    When the trust proxy setting
does not evaluate to false, this property will instead get the value
from the X-Forwarded-Host header field. This header can be set by
the client or by the proxy.

    If there is more than one X-Forwarded-Host header in the request, the
value of the first header is used. This includes a single header with
comma-separated values, in which the first value is used.

    
      Prior to Express v4.17.0, the X-Forwarded-Host could not contain multiple
values or be present more than once.
    

    // Host: "example.com:3000"
console.dir(req.hostname)
// => 'example.com'
    

  

  
    req.ip

    Contains the remote IP address of the request.

    When the trust proxy setting does not evaluate to false,
the value of this property is derived from the left-most entry in the
X-Forwarded-For header. This header can be set by the client or by the proxy.

    console.dir(req.ip)
// => "127.0.0.1"
    

  

  
    req.ips

    When the trust proxy setting does not evaluate to false,
this property contains an array of IP addresses
specified in the X-Forwarded-For request header. Otherwise, it contains an
empty array. This header can be set by the client or by the proxy.

    For example, if X-Forwarded-For is client, proxy1, proxy2, req.ips would be
["client", "proxy1", "proxy2"], where proxy2 is the furthest downstream.

  

  
    req.method

    Contains a string corresponding to the HTTP method of the request:
GET, POST, PUT, and so on.

  

  
    req.originalUrl

    
      req.url is not a native Express property, it is inherited from Node’s http module.
    

    This property is much like req.url; however, it retains the original request URL,
allowing you to rewrite req.url freely for internal routing purposes. For example,
the “mounting” feature of app.use() will rewrite req.url to strip the mount point.

    // GET /search?q=something
console.dir(req.originalUrl)
// => "/search?q=something"
    

    req.originalUrl is available both in middleware and router objects, and is a
combination of req.baseUrl and req.url. Consider following example:

    // GET 'http://www.example.com/admin/new?sort=desc'
app.use('/admin', (req, res, next) => {
  console.dir(req.originalUrl) // '/admin/new?sort=desc'
  console.dir(req.baseUrl) // '/admin'
  console.dir(req.path) // '/new'
  next()
})
    

  

  
    req.params

    This property is an object containing properties mapped to the named route “parameters”. For example, if you have the route /user/:name, then the “name” property is available as req.params.name. This object defaults to {}.

    // GET /user/tj
console.dir(req.params.name)
// => "tj"
    

    When you use a regular expression for the route definition, capture groups are provided in the array using req.params[n], where n is the nth capture group.

    app.use(/^\/file\/(.*)$/, (req, res) => {
  // GET /file/javascripts/jquery.js
  console.dir(req.params[0])
  // => "javascripts/jquery.js"
})
    

    If you need to make changes to a key in req.params, use the app.param handler. Changes are applicable only to parameters already defined in the route path.

    Any changes made to the req.params object in a middleware or route handler will be reset.

    
       Note
      Express automatically decodes the values in req.params (using decodeURIComponent).
    

  

  
    req.path

    Contains the path part of the request URL.

    // example.com/users?sort=desc
console.dir(req.path)
// => "/users"
    

    
      When called from a middleware, the mount point is not included in req.path. See app.use() for more details.
    

  

  
    req.protocol

    Contains the request protocol string: either http or (for TLS requests) https.

    When the trust proxy setting does not evaluate to false,
this property will use the value of the X-Forwarded-Proto header field if present.
This header can be set by the client or by the proxy.

    console.dir(req.protocol)
// => "http"
    

  

  
    req.query

    This property is an object containing a property for each query string parameter in the route.
When query parser is set to disabled, it is an empty object {}, otherwise it is the result of the configured query parser.

    
      As req.query’s shape is based on user-controlled input, all properties and values in this object are untrusted and should be validated before trusting. For example, req.query.foo.toString() may fail in multiple ways, for example foo may not be there or may not be a string, and toString may not be a function and instead a string or other user-input.
    

    The value of this property can be configured with the query parser application setting to work how your application needs it. A very popular query string parser is the qs module, and this is used by default. The qs module is very configurable with many settings, and it may be desirable to use different settings than the default to populate req.query:

    const qs = require('qs')
app.set('query parser',
  (str) => qs.parse(str, { /* custom options */ }))
    

    Check out the query parser application setting documentation for other customization options.

  

  
    req.res

    This property holds a reference to the response object
that relates to this request object.

  

  
    req.route

    Contains the currently-matched route, a string. For example:

    app.get('/user/{:id}', (req, res) => {
  console.dir(req.route, { depth: null })
  res.send('GET')
})
    

    Example output from the previous snippet:

    Route {
  path: '/user/{:id}',
  stack: [
    Layer {
      handle: [Function (anonymous)],
      keys: [],
      name: '<anonymous>',
      params: undefined,
      path: undefined,
      slash: false,
      matchers: [ [Function: match] ],
      method: 'get'
    }
  ],
  methods: [Object: null prototype] { get: true }
}
    

  

  
    req.secure

    A Boolean property that is true if a TLS connection is established. Equivalent to the following:

    
    req.protocol === 'https'
    

  

  
    req.signedCookies

    When using cookie-parser middleware, this property
contains signed cookies sent by the request, unsigned and ready for use. Signed cookies reside
in a different object to show developer intent; otherwise, a malicious attack could be placed on
req.cookie values (which are easy to spoof). Note that signing a cookie does not make it “hidden”
or encrypted; but simply prevents tampering (because the secret used to sign is private).

    If no signed cookies are sent, the property defaults to {}.

    // Cookie: user=tobi.CP7AWaXDfAKIRfH49dQzKJx7sKzzSoPq7/AcBBRVwlI3
console.dir(req.signedCookies.user)
// => "tobi"
    

    For more information, issues, or concerns, see cookie-parser.

  

  
    req.stale

    Indicates whether the request is “stale,” and is the opposite of req.fresh.
For more information, see req.fresh.

    console.dir(req.stale)
// => true
    

  

  
    req.subdomains

    An array of subdomains in the domain name of the request.

    // Host: "tobi.ferrets.example.com"
console.dir(req.subdomains)
// => ["ferrets", "tobi"]
    

    The application property subdomain offset, which defaults to 2, is used for determining the
beginning of the subdomain segments. To change this behavior, change its value
using app.set.

  

  
    req.xhr

    A Boolean property that is true if the request’s X-Requested-With header field is
“XMLHttpRequest”, indicating that the request was issued by a client library such as jQuery.

    console.dir(req.xhr)
// => true
    

  

  Methods

  
    req.accepts(types)

    Checks if the specified content types are acceptable, based on the request’s Accept HTTP header field.
The method returns the best match, or if none of the specified content types is acceptable, returns
false (in which case, the application should respond with 406 "Not Acceptable").

    The type value may be a single MIME type string (such as “application/json”),
an extension name such as “json”, a comma-delimited list, or an array. For a
list or array, the method returns the best match (if any).

    // Accept: text/html
req.accepts('html')
// => "html"

// Accept: text/*, application/json
req.accepts('html')
// => "html"
req.accepts('text/html')
// => "text/html"
req.accepts(['json', 'text'])
// => "json"
req.accepts('application/json')
// => "application/json"

// Accept: text/*, application/json
req.accepts('image/png')
req.accepts('png')
// => false

// Accept: text/*;q=.5, application/json
req.accepts(['html', 'json'])
// => "json"
    

    For more information, or if you have issues or concerns, see accepts.

  

  
    req.acceptsCharsets(charset [, ...])

    Returns the first accepted charset of the specified character sets,
based on the request’s Accept-Charset HTTP header field.
If none of the specified charsets is accepted, returns false.

    For more information, or if you have issues or concerns, see accepts.

  

  
    req.acceptsEncodings(encoding [, ...])

    Returns the first accepted encoding of the specified encodings,
based on the request’s Accept-Encoding HTTP header field.
If none of the specified encodings is accepted, returns false.

    For more information, or if you have issues or concerns, see accepts.

  

  
    req.acceptsLanguages([lang, ...])

    Returns the first accepted language of the specified languages,
based on the request’s Accept-Language HTTP header field.
If none of the specified languages is accepted, returns false.

    If no lang argument is given, then req.acceptsLanguages()
returns all languages from the HTTP Accept-Language header
as an Array.

    For more information, or if you have issues or concerns, see accepts.

    Express (5.x) source: request.js line 172

    Accepts (2.0) source: index.js line 195

  

  
    req.get(field)

    Returns the specified HTTP request header field (case-insensitive match).
The Referrer and Referer fields are interchangeable.

    req.get('Content-Type')
// => "text/plain"

req.get('content-type')
// => "text/plain"

req.get('Something')
// => undefined
    

    Aliased as req.header(field).

  

  
    req.is(type)

    Returns the matching content type if the incoming request’s “Content-Type” HTTP header field
matches the MIME type specified by the type parameter. If the request has no body, returns null.
Returns false otherwise.

    // With Content-Type: text/html; charset=utf-8
req.is('html') // => 'html'
req.is('text/html') // => 'text/html'
req.is('text/*') // => 'text/*'

// When Content-Type is application/json
req.is('json') // => 'json'
req.is('application/json') // => 'application/json'
req.is('application/*') // => 'application/*'

req.is('html')
// => false
    

    For more information, or if you have issues or concerns, see type-is.

  

  
    req.range(size[, options])

    Range header parser.

    The size parameter is the maximum size of the resource.

    The options parameter is an object that can have the following properties.

    
      
        
          Property
          Type
          Description
        
      
      
        
          combine
          Boolean
          Specify if overlapping & adjacent ranges should be combined, defaults to false. When true, ranges will be combined and returned as if they were specified that way in the header.
        
      
    

    An array of ranges will be returned or negative numbers indicating an error parsing.

    
      -2 signals a malformed header string
      -1 signals an unsatisfiable range
    

    // parse header from request
const range = req.range(1000)

// the type of the range
if (range.type === 'bytes') {
  // the ranges
  range.forEach((r) => {
    // do something with r.start and r.end
  })
}
    

  

  Response

  The res object represents the HTTP response that an Express app sends when it gets an HTTP request.

  In this documentation and by convention,
the object is always referred to as res (and the HTTP request is req) but its actual name is determined
by the parameters to the callback function in which you’re working.

  For example:

  app.get('/user/:id', (req, res) => {
  res.send(`user ${req.params.id}`)
})
  

  But you could just as well have:

  app.get('/user/:id', (request, response) => {
  response.send(`user ${request.params.id}`)
})
  

  The res object is an enhanced version of Node’s own response object
and supports all built-in fields and methods.

  Properties

  
    res.app

    This property holds a reference to the instance of the Express application that is using the middleware.

    res.app is identical to the req.app property in the request object.

  

  
    res.headersSent

    Boolean property that indicates if the app sent HTTP headers for the response.

    app.get('/', (req, res) => {
  console.log(res.headersSent) // false
  res.send('OK')
  console.log(res.headersSent) // true
})
    

  

  
    res.locals

    Use this property to set variables accessible in templates rendered with res.render.
The variables set on res.locals are available within a single request-response cycle, and will not
be shared between requests.

    
      The locals object is used by view engines to render a response. The object
keys may be particularly sensitive and should not contain user-controlled
input, as it may affect the operation of the view engine or provide a path to
cross-site scripting. Consult the documentation for the used view engine for
additional considerations.
    

    In order to keep local variables for use in template rendering between requests, use
app.locals instead.

    This property is useful for exposing request-level information such as the request path name,
authenticated user, user settings, and so on to templates rendered within the application.

    app.use((req, res, next) => {
  // Make `user` and `authenticated` available in templates
  res.locals.user = req.user
  res.locals.authenticated = !req.user.anonymous
  next()
})
    

  

  
    res.req

    This property holds a reference to the request object
that relates to this response object.

  

  Methods

  
    res.append(field [, value])

    
      res.append() is supported by Express v4.11.0+
    

    Appends the specified value to the HTTP response header field.  If the header is not already set,
it creates the header with the specified value. The value parameter can be a string or an array.

    
       Note
      calling res.set() after res.append() will reset the previously-set header value.
    

    res.append('Link', ['<http://localhost/>', '<http://localhost:3000/>'])
res.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly')
res.append('Warning', '199 Miscellaneous warning')
    

  

  
    res.attachment([filename])

    Sets the HTTP response Content-Disposition header field to “attachment”. If a filename is given,
then it sets the Content-Type based on the extension name via res.type(),
and sets the Content-Disposition “filename=” parameter.

    res.attachment()
// Content-Disposition: attachment

res.attachment('path/to/logo.png')
// Content-Disposition: attachment; filename="logo.png"
// Content-Type: image/png
    

  

  
    res.cookie(name, value [, options])

    Sets cookie name to value.  The value parameter may be a string or object converted to JSON.

    The options parameter is an object that can have the following properties.

    
      
        
          Property
          Type
          Description
        
      
      
        
          domain
          String
          Domain name for the cookie. Defaults to the domain name of the app.
        
        
          encode
          Function
          A synchronous function used for cookie value encoding. Defaults to encodeURIComponent.
        
        
          expires
          Date
          Expiry date of the cookie in GMT. If not specified or set to 0, creates a session cookie.
        
        
          httpOnly
          Boolean
          Flags the cookie to be accessible only by the web server.
        
        
          maxAge
          Number
          Convenient option for setting the expiry time relative to the current time in milliseconds.
        
        
          path
          String
          Path for the cookie. Defaults to “/”.
        
        
          partitioned
          Boolean
          Indicates that the cookie should be stored using partitioned storage. See Cookies Having Independent Partitioned State (CHIPS) for more details.
        
        
          priority
          String
          Value of the “Priority” Set-Cookie attribute.
        
        
          secure
          Boolean
          Marks the cookie to be used with HTTPS only.
        
        
          signed
          Boolean
          Indicates if the cookie should be signed.
        
        
          sameSite
          Boolean or String
          Value of the “SameSite” Set-Cookie attribute. More information at https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00#section-4.1.1.
        
      
    

    
      All res.cookie() does is set the HTTP Set-Cookie header with the options provided.
Any option not specified defaults to the value stated in RFC 6265.
    

    For example:

    res.cookie('name', 'tobi', { domain: '.example.com', path: '/admin', secure: true })
res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true })
    

    You can set multiple cookies in a single response by calling res.cookie multiple times, for example:

    res
  .status(201)
  .cookie('access_token', `Bearer ${token}`, {
    expires: new Date(Date.now() + 8 * 3600000) // cookie will be removed after 8 hours
  })
  .cookie('test', 'test')
  .redirect(301, '/admin')
    

    The encode option allows you to choose the function used for cookie value encoding.
Does not support asynchronous functions.

    Example use case: You need to set a domain-wide cookie for another site in your organization.
This other site (not under your administrative control) does not use URI-encoded cookie values.

    // Default encoding
res.cookie('some_cross_domain_cookie', 'http://mysubdomain.example.com', { domain: 'example.com' })
// Result: 'some_cross_domain_cookie=http%3A%2F%2Fmysubdomain.example.com; Domain=example.com; Path=/'

// Custom encoding
res.cookie('some_cross_domain_cookie', 'http://mysubdomain.example.com', { domain: 'example.com', encode: String })
// Result: 'some_cross_domain_cookie=http://mysubdomain.example.com; Domain=example.com; Path=/;'
    

    The maxAge option is a convenience option for setting “expires” relative to the current time in milliseconds.
The following is equivalent to the second example above.

    res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })
    

    You can pass an object as the value parameter; it is then serialized as JSON and parsed by bodyParser() middleware.

    res.cookie('cart', { items: [1, 2, 3] })
res.cookie('cart', { items: [1, 2, 3] }, { maxAge: 900000 })
    

    When using cookie-parser middleware, this method also
supports signed cookies. Simply include the signed option set to true.
Then, res.cookie() will use the secret passed to cookieParser(secret) to sign the value.

    res.cookie('name', 'tobi', { signed: true })
    

    Later, you may access this value through the req.signedCookies object.

  

  
    res.clearCookie(name [, options])

    Clears the cookie specified by name. For details about the options object, see res.cookie().

    
      Web browsers and other compliant clients will only clear the cookie if the given
options is identical to those given to res.cookie(), excluding
expires and maxAge.
    

    res.cookie('name', 'tobi', { path: '/admin' })
res.clearCookie('name', { path: '/admin' })
    

  

  
    res.download(path [, filename] [, options] [, fn])

    
      The optional options argument is supported by Express v4.16.0 onwards.
    

    Transfers the file at path as an “attachment”. Typically, browsers will prompt the user for download.
By default, the Content-Disposition header “filename=” parameter is derived from the path argument, but can be overridden with the filename parameter.
If path is relative, then it will be based on the current working directory of the process or
the root option, if provided.

    
      This API provides access to data on the running file system. Ensure that either (a) the way in
which the path argument was constructed is secure if it contains user input or (b) set the root
option to the absolute path of a directory to contain access within.

      When the root option is provided, Express will validate that the relative path provided as
path will resolve within the given root option.
    

    The following table provides details on the options parameter.

    
      The optional options argument is supported by Express v4.16.0 onwards.
    

    

      
        
          
            Property
            Description
            Default
            Availability
          
        
        
          
            maxAge
            Sets the max-age property of the Cache-Control header in milliseconds or a string in ms format
            0
            4.16+
          
          
            root
            Root directory for relative filenames.
             
            4.18+
          
          
            lastModified
            Sets the Last-Modified header to the last modified date of the file on the OS. Set false to disable it.
            Enabled
            4.16+
          
          
            headers
            Object containing HTTP headers to serve with the file. The header Content-Disposition will be overridden by the filename argument.
             
            4.16+
          
          
            dotfiles
            Option for serving dotfiles. Possible values are “allow”, “deny”, “ignore”.
            “ignore”
            4.16+
          
          
            acceptRanges
            Enable or disable accepting ranged requests.
            true
            4.16+
          
          
            cacheControl
            Enable or disable setting Cache-Control response header.
            true
            4.16+
          
          
            immutable
            Enable or disable the immutable directive in the Cache-Control response header. If enabled, the maxAge option should also be specified to enable caching. The immutable directive will prevent supported clients from making conditional requests during the life of the maxAge option to check if the file has changed.
            false
            4.16+
          
        
      

    

    The method invokes the callback function fn(err) when the transfer is complete
or when an error occurs. If the callback function is specified and an error occurs,
the callback function must explicitly handle the response process either by
ending the request-response cycle, or by passing control to the next route.

    res.download('/report-12345.pdf')

res.download('/report-12345.pdf', 'report.pdf')

res.download('/report-12345.pdf', 'report.pdf', (err) => {
  if (err) {
    // Handle error, but keep in mind the response may be partially-sent
    // so check res.headersSent
  } else {
    // decrement a download credit, etc.
  }
})
    

  

  
    res.end([data[, encoding]][, callback])

    Ends the response process. This method actually comes from Node core, specifically the response.end() method of http.ServerResponse.

    Use to quickly end the response without any data. If you need to respond with data, instead use methods such as res.send() and res.json().

    res.end()
res.status(404).end()
    

  

  
    res.format(object)

    Performs content-negotiation on the Accept HTTP header on the request object, when present.
It uses req.accepts() to select a handler for the request, based on the acceptable
types ordered by their quality values. If the header is not specified, the first callback is invoked.
When no match is found, the server responds with 406 “Not Acceptable”, or invokes the default callback.

    The Content-Type response header is set when a callback is selected. However, you may alter
this within the callback using methods such as res.set() or res.type().

    The following example would respond with { "message": "hey" } when the Accept header field is set
to “application/json” or “*/json” (however, if it is “*/*”, then the response will be “hey”).

    res.format({
  'text/plain' () {
    res.send('hey')
  },

  'text/html' () {
    res.send('<p>hey</p>')
  },

  'application/json' () {
    res.send({ message: 'hey' })
  },

  default () {
    // log the request and respond with 406
    res.status(406).send('Not Acceptable')
  }
})
    

    In addition to canonicalized MIME types, you may also use extension names mapped
to these types for a slightly less verbose implementation:

    res.format({
  text () {
    res.send('hey')
  },

  html () {
    res.send('<p>hey</p>')
  },

  json () {
    res.send({ message: 'hey' })
  }
})
    

  

  
    res.get(field)

    Returns the HTTP response header specified by field.
The match is case-insensitive.

    res.get('Content-Type')
// => "text/plain"
    

  

  
    res.json([body])

    Sends a JSON response. This method sends a response (with the correct content-type) that is the parameter converted to a 
JSON string using JSON.stringify().

    The parameter can be any JSON type, including object, array, string, Boolean, number, or null,
and you can also use it to convert other values to JSON.

    res.json(null)
res.json({ user: 'tobi' })
res.status(500).json({ error: 'message' })
    

  

  
    res.jsonp([body])

    Sends a JSON response with JSONP support. This method is identical to res.json(),
except that it opts-in to JSONP callback support.

    res.jsonp(null)
// => callback(null)

res.jsonp({ user: 'tobi' })
// => callback({ "user": "tobi" })

res.status(500).jsonp({ error: 'message' })
// => callback({ "error": "message" })
    

    By default, the JSONP callback name is simply callback. Override this with the
jsonp callback name setting.

    The following are some examples of JSONP responses using the same code:

    // ?callback=foo
res.jsonp({ user: 'tobi' })
// => foo({ "user": "tobi" })

app.set('jsonp callback name', 'cb')

// ?cb=foo
res.status(500).jsonp({ error: 'message' })
// => foo({ "error": "message" })
    

  

  
    res.links(links)

    Joins the links provided as properties of the parameter to populate the response’s
Link HTTP header field.

    For example, the following call:

    res.links({
  next: 'http://api.example.com/users?page=2',
  last: 'http://api.example.com/users?page=5'
})
    

    Yields the following results:

    Link: <http://api.example.com/users?page=2>; rel="next",
      <http://api.example.com/users?page=5>; rel="last"
    

  

  
    res.location(path)

    Sets the response Location HTTP header to the specified path parameter.

    res.location('/foo/bar')
res.location('http://example.com')
    

    
      After encoding the URL, if not encoded already, Express passes the specified URL to the browser in the Location header,
without any validation.

      Browsers take the responsibility of deriving the intended URL from the current URL
or the referring URL, and the URL specified in the Location header; and redirect the user accordingly.
    

  

  
    res.redirect([status,] path)

    Redirects to the URL derived from the specified path, with specified status, a positive integer
that corresponds to an HTTP status code.
If not specified, status defaults to 302 "Found".

    res.redirect('/foo/bar')
res.redirect('http://example.com')
res.redirect(301, 'http://example.com')
res.redirect('../login')
    
    Redirects can be a fully-qualified URL for redirecting to a different site:

    res.redirect('http://google.com')
    
    Redirects can be relative to the root of the host name. For example, if the
application is on http://example.com/admin/post/new, the following
would redirect to the URL http://example.com/admin:

    res.redirect('/admin')
    

    Redirects can be relative to the current URL. For example,
from http://example.com/blog/admin/ (notice the trailing slash), the following
would redirect to the URL http://example.com/blog/admin/post/new.

    res.redirect('post/new')
    

    Redirecting to post/new from http://example.com/blog/admin (no trailing slash),
will redirect to http://example.com/blog/post/new.

    If you found the above behavior confusing, think of path segments as directories
(with trailing slashes) and files, it will start to make sense.

    Path-relative redirects are also possible. If you were on
http://example.com/admin/post/new, the following would redirect to
http://example.com/admin/post:

    res.redirect('..')
    

    See also Security best practices: Prevent open redirect 
vulnerabilities.
  

  
    res.render(view [, locals] [, callback])

    Renders a view and sends the rendered HTML string to the client.
Optional parameters:

    
      locals, an object whose properties define local variables for the view.
      callback, a callback function. If provided, the method returns both the possible error and rendered string, but does not perform an automated response. When an error occurs, the method invokes next(err) internally.
    

    The view argument is a string that is the file path of the view file to render. This can be an absolute path, or a path relative to the views setting. If the path does not contain a file extension, then the view engine setting determines the file extension. If the path does contain a file extension, then Express will load the module for the specified template engine (via require()) and render it using the loaded module’s __express function.

    For more information, see Using template engines with Express.

    
       Warning
      The view argument performs file system operations like reading a file from disk and evaluating Node.js modules, and as so for security reasons should not contain input from the end-user.
    

    
       Warning
      The locals object is used by view engines to render a response. The object
keys may be particularly sensitive and should not contain user-controlled
input, as it may affect the operation of the view engine or provide a path to
cross-site scripting. Consult the documentation for the used view engine for
additional considerations.
    

    
       Caution
      The local variable cache enables view caching. Set it to true,
to cache the view during development; view caching is enabled in production by default.
    

    // send the rendered view to the client
res.render('index')

// if a callback is specified, the rendered HTML string has to be sent explicitly
res.render('index', (err, html) => {
  res.send(html)
})

// pass a local variable to the view
res.render('user', { name: 'Tobi' }, (err, html) => {
  // ...
})
    

  

  
    res.send([body])

    Sends the HTTP response.

    The body parameter can be a Buffer object, a String, an object, Boolean, or an Array.
For example:

    res.send(Buffer.from('whoop'))
res.send({ some: 'json' })
res.send('<p>some html</p>')
res.status(404).send('Sorry, we cannot find that!')
res.status(500).send({ error: 'something blew up' })
    

    This method performs many useful tasks for simple non-streaming responses:
For example, it automatically assigns the Content-Length HTTP response header field 
and provides automatic HEAD and HTTP cache freshness support.

    When the parameter is a Buffer object, the method sets the Content-Type
response header field to “application/octet-stream”, unless previously defined as shown below:

    res.set('Content-Type', 'text/html')
res.send(Buffer.from('<p>some html</p>'))
    

    When the parameter is a String, the method sets the Content-Type to “text/html”:

    res.send('<p>some html</p>')
    

    When the parameter is an Array or Object, Express responds with the JSON representation:

    res.send({ user: 'tobi' })
res.send([1, 2, 3])
    

  

  
    res.sendFile(path [, options] [, fn])

    
      res.sendFile() is supported by Express v4.8.0 onwards.
    

    Transfers the file at the given path. Sets the Content-Type response HTTP header field
based on the filename’s extension. Unless the root option is set in
the options object, path must be an absolute path to the file.

    
      This API provides access to data on the running file system. Ensure that either (a) the way in
which the path argument was constructed into an absolute path is secure if it contains user
input or (b) set the root option to the absolute path of a directory to contain access within.

      When the root option is provided, the path argument is allowed to be a relative path,
including containing ... Express will validate that the relative path provided as path will
resolve within the given root option.
    

    The following table provides details on the options parameter.

    

      
        
          
            Property
            Description
            Default
            Availability
          
        
        
          
            maxAge
            Sets the max-age property of the Cache-Control header in milliseconds or a string in ms format
            0
             
          
          
            root
            Root directory for relative filenames.
             
             
          
          
            lastModified
            Sets the Last-Modified header to the last modified date of the file on the OS. Set false to disable it.
            Enabled
            4.9.0+
          
          
            headers
            Object containing HTTP headers to serve with the file.
             
             
          
          
            dotfiles
            Option for serving dotfiles. Possible values are “allow”, “deny”, “ignore”.
            “ignore”
             
          
          
            acceptRanges
            Enable or disable accepting ranged requests.
            true
            4.14+
          
          
            cacheControl
            Enable or disable setting Cache-Control response header.
            true
            4.14+
          
          
            immutable
            Enable or disable the immutable directive in the Cache-Control response header. If enabled, the maxAge option should also be specified to enable caching. The immutable directive will prevent supported clients from making conditional requests during the life of the maxAge option to check if the file has changed.
            false
            4.16+
          
        
      

    

    The method invokes the callback function fn(err) when the transfer is complete
or when an error occurs. If the callback function is specified and an error occurs,
the callback function must explicitly handle the response process either by
ending the request-response cycle, or by passing control to the next route.

    Here is an example of using res.sendFile with all its arguments.

    app.get('/file/:name', (req, res, next) => {
  const options = {
    root: path.join(__dirname, 'public'),
    dotfiles: 'deny',
    headers: {
      'x-timestamp': Date.now(),
      'x-sent': true
    }
  }

  const fileName = req.params.name
  res.sendFile(fileName, options, (err) => {
    if (err) {
      next(err)
    } else {
      console.log('Sent:', fileName)
    }
  })
})
    

    The following example illustrates using
res.sendFile to provide fine-grained support for serving files:

    app.get('/user/:uid/photos/:file', (req, res) => {
  const uid = req.params.uid
  const file = req.params.file

  req.user.mayViewFilesFrom(uid, (yes) => {
    if (yes) {
      res.sendFile(`/uploads/${uid}/${file}`)
    } else {
      res.status(403).send("Sorry! You can't see that.")
    }
  })
})
    
    For more information, or if you have issues or concerns, see send.

  

  
    res.sendStatus(statusCode)

    Sets the response HTTP status code to statusCode and sends the registered status message as the text response body. If an unknown status code is specified, the response body will just be the code number.

    res.sendStatus(404)
    

    
      Some versions of Node.js will throw when res.statusCode is set to an
invalid HTTP status code (outside of the range 100 to 599). Consult
the HTTP server documentation for the Node.js version being used.
    

    More about HTTP Status Codes

  

  
    res.set(field [, value])

    Sets the response’s HTTP header field to value.
To set multiple fields at once, pass an object as the parameter.

    res.set('Content-Type', 'text/plain')

res.set({
  'Content-Type': 'text/plain',
  'Content-Length': '123',
  ETag: '12345'
})
    

    Aliased as res.header(field [, value]).

  

  
    res.status(code)

    Sets the HTTP status for the response.
It is a chainable alias of Node’s response.statusCode.

    res.status(403).end()
res.status(400).send('Bad Request')
res.status(404).sendFile('/absolute/path/to/404.png')
    

  

  
    res.type(type)

    Sets the Content-Type HTTP header to the MIME type as determined by the specified type. If type contains the “/” character, then it sets the Content-Type to the exact value of type, otherwise it is assumed to be a file extension and the MIME type is looked up using the contentType() method of the mime-types package.

    res.type('.html') // => 'text/html'
res.type('html') // => 'text/html'
res.type('json') // => 'application/json'
res.type('application/json') // => 'application/json'
res.type('png') // => image/png:
    

    Aliased as res.contentType(type).

  

  
    res.vary(field)

    Adds the field to the Vary response header, if it is not there already.

    res.vary('User-Agent').render('docs')
    

  

  Router

  
    A router object is an instance of middleware and routes. You can think of it
as a “mini-application,” capable only of performing middleware and routing
functions. Every Express application has a built-in app router.

    A router behaves like middleware itself, so you can use it as an argument to
app.use() or as the argument to another router’s use() method.

    The top-level express object has a Router() method that creates a new router object.

    Once you’ve created a router object, you can add middleware and HTTP method routes (such as get, put, post,
and so on) to it just like an application. For example:

    // invoked for any requests passed to this router
router.use((req, res, next) => {
  // .. some logic here .. like any other middleware
  next()
})

// will handle any request that ends in /events
// depends on where the router is "use()'d"
router.get('/events', (req, res, next) => {
  // ..
})
    

    You can then use a router for a particular root URL in this way separating your routes into files or even mini-apps.

    // only requests to /calendar/* will be sent to our "router"
app.use('/calendar', router)
    

    Keep in mind that any middleware applied to a router will run for all requests on that router’s path, even those that aren’t part of the router.

  

  Methods

  
    router.all(path, [callback, ...] callback)

    This method is just like the router.METHOD() methods, except that it matches all HTTP methods (verbs).

    This method is extremely useful for
mapping “global” logic for specific path prefixes or arbitrary matches.
For example, if you placed the following route at the top of all other
route definitions, it would require that all routes from that point on
would require authentication, and automatically load a user. Keep in mind
that these callbacks do not have to act as end points; loadUser
can perform a task, then call next() to continue matching subsequent
routes.

    router.all('{*splat}', requireAuthentication, loadUser)
    

    Or the equivalent:

    router.all('{*splat}', requireAuthentication)
router.all('{*splat}', loadUser)
    

    Another example of this is white-listed “global” functionality. Here,
the example is much like before, but it only restricts paths prefixed with
“/api”:

    router.all('/api/{*splat}', requireAuthentication)
    

  

  
    router.METHOD(path, [callback, ...] callback)

    The router.METHOD() methods provide the routing functionality in Express,
where METHOD is one of the HTTP methods, such as GET, PUT, POST, and so on,
in lowercase. Thus, the actual methods are router.get(), router.post(),
router.put(), and so on.

    
      The router.get() function is automatically called for the HTTP HEAD method in
  addition to the GET method if router.head() was not called for the
  path before router.get().
    

    You can provide multiple callbacks, and all are treated equally, and behave just
like middleware, except that these callbacks may invoke next('route')
to bypass the remaining route callback(s). You can use this mechanism to perform
pre-conditions on a route then pass control to subsequent routes when there is no
reason to proceed with the route matched.

    The following snippet illustrates the most simple route definition possible.
Express translates the path strings to regular expressions, used internally
to match incoming requests. Query strings are not considered when performing
these matches, for example “GET /” would match the following route, as would
“GET /?name=tobi”.

    router.get('/', (req, res) => {
  res.send('hello world')
})
    

    You can also use regular expressions—useful if you have very specific
constraints, for example the following would match “GET /commits/71dbb9c” as well
as “GET /commits/71dbb9c..4c084f9”.

    router.get(/^\/commits\/(\w+)(?:\.\.(\w+))?$/, (req, res) => {
  const from = req.params[0]
  const to = req.params[1] || 'HEAD'
  res.send(`commit range ${from}..${to}`)
})
    

    You can use next primitive to implement a flow control between different
middleware functions, based on a specific program state. Invoking next with
the string 'router' will cause all the remaining route callbacks on that router
to be bypassed.

    The following example illustrates next('router') usage.

    function fn (req, res, next) {
  console.log('I come here')
  next('router')
}
router.get('/foo', fn, (req, res, next) => {
  console.log('I dont come here')
})
router.get('/foo', (req, res, next) => {
  console.log('I dont come here')
})
app.get('/foo', (req, res) => {
  console.log(' I come here too')
  res.end('good')
})
    

  

  
    router.param(name, callback)

    Adds callback triggers to route parameters, where name is the name of the parameter and callback is the callback function. Although name is technically optional, using this method without it is deprecated starting with Express v4.11.0 (see below).

    The parameters of the callback function are:

    
      req, the request object.
      res, the response object.
      next, indicating the next middleware function.
      The value of the name parameter.
      The name of the parameter.
    

    
      Unlike app.param(), router.param() does not accept an array of route parameters.
    

    For example, when :user is present in a route path, you may map user loading logic to automatically provide req.user to the route, or perform validations on the parameter input.

    router.param('user', (req, res, next, id) => {
  // try to get the user details from the User model and attach it to the request object
  User.find(id, (err, user) => {
    if (err) {
      next(err)
    } else if (user) {
      req.user = user
      next()
    } else {
      next(new Error('failed to load user'))
    }
  })
})
    

    Param callback functions are local to the router on which they are defined. They are not inherited by mounted apps or routers, nor are they triggered for route parameters inherited from parent routers. Hence, param callbacks defined on router will be triggered only by route parameters defined on router routes.

    A param callback will be called only once in a request-response cycle, even if the parameter is matched in multiple routes, as shown in the following examples.

    router.param('id', (req, res, next, id) => {
  console.log('CALLED ONLY ONCE')
  next()
})

router.get('/user/:id', (req, res, next) => {
  console.log('although this matches')
  next()
})

router.get('/user/:id', (req, res) => {
  console.log('and this matches too')
  res.end()
})
    

    On GET /user/42, the following is printed:

    CALLED ONLY ONCE
although this matches
and this matches too
    

  

  
    router.route(path)

    Returns an instance of a single route which you can then use to handle HTTP verbs
with optional middleware. Use router.route() to avoid duplicate route naming and
thus typing errors.

    Building on the router.param() example above, the following code shows how to use
router.route() to specify various HTTP method handlers.

    const router = express.Router()

router.param('user_id', (req, res, next, id) => {
  // sample user, would actually fetch from DB, etc...
  req.user = {
    id,
    name: 'TJ'
  }
  next()
})

router.route('/users/:user_id')
  .all((req, res, next) => {
  // runs for all HTTP verbs first
  // think of it as route specific middleware!
    next()
  })
  .get((req, res, next) => {
    res.json(req.user)
  })
  .put((req, res, next) => {
  // just an example of maybe updating the user
    req.user.name = req.params.name
    // save user ... etc
    res.json(req.user)
  })
  .post((req, res, next) => {
    next(new Error('not implemented'))
  })
  .delete((req, res, next) => {
    next(new Error('not implemented'))
  })
    

    This approach re-uses the single /users/:user_id path and adds handlers for
various HTTP methods.

    
       Note
      When you use router.route(), middleware ordering is based on when the route is created, not when method handlers are added to the route. For this purpose, you can consider method handlers to belong to the route to which they were added.
    

  

  
    router.use([path], [function, ...] function)

    Uses the specified middleware function or functions, with optional mount path path, that defaults to “/”.

    This method is similar to app.use(). A simple example and use case is described below.
See app.use() for more information.

    Middleware is like a plumbing pipe: requests start at the first middleware function defined
and work their way “down” the middleware stack processing for each path they match.

    const express = require('express')
const app = express()
const router = express.Router()

// simple logger for this router's requests
// all requests to this router will first hit this middleware
router.use((req, res, next) => {
  console.log('%s %s %s', req.method, req.url, req.path)
  next()
})

// this will only be invoked if the path starts with /bar from the mount point
router.use('/bar', (req, res, next) => {
  // ... maybe some additional /bar logging ...
  next()
})

// always invoked
router.use((req, res, next) => {
  res.send('Hello World')
})

app.use('/foo', router)

app.listen(3000)
    

    The “mount” path is stripped and is not visible to the middleware function.
The main effect of this feature is that a mounted middleware function may operate without
code changes regardless of its “prefix” pathname.

    The order in which you define middleware with router.use() is very important.
They are invoked sequentially, thus the order defines middleware precedence. For example,
usually a logger is the very first middleware you would use, so that every request gets logged.

    const logger = require('morgan')

router.use(logger())
router.use(express.static(path.join(__dirname, 'public')))
router.use((req, res) => {
  res.send('Hello')
})
    

    Now suppose you wanted to ignore logging requests for static files, but to continue
logging routes and middleware defined after logger().  You would simply move the call to express.static() to the top,
before adding the logger middleware:

    router.use(express.static(path.join(__dirname, 'public')))
router.use(logger())
router.use((req, res) => {
  res.send('Hello')
})
    

    Another example is serving files from multiple directories,
giving precedence to “./public” over the others:

    app.use(express.static(path.join(__dirname, 'public')))
app.use(express.static(path.join(__dirname, 'files')))
app.use(express.static(path.join(__dirname, 'uploads')))
    

    The router.use() method also supports named parameters so that your mount points
for other routers can benefit from preloading using named parameters.

    NOTE: Although these middleware functions are added via a particular router, when
they run is defined by the path they are attached to (not the router). Therefore,
middleware added via one router may run for other routers if its routes
match. For example, this code shows two different routers mounted on the same path:

    const authRouter = express.Router()
const openRouter = express.Router()

authRouter.use(require('./authenticate').basic(usersdb))

authRouter.get('/:user_id/edit', (req, res, next) => {
  // ... Edit user UI ...
})
openRouter.get('/', (req, res, next) => {
  // ... List users ...
})
openRouter.get('/:user_id', (req, res, next) => {
  // ... View user ...
})

app.use('/users', authRouter)
app.use('/users', openRouter)
    

    Even though the authentication middleware was added via the authRouter it will run on the routes defined by the openRouter as well since both routers were mounted on /users. To avoid this behavior, use different paths for each router.

  



              
    
    Edit this page\n\nOn this page
          On this page ►

    express()
    
        Methods
        express.json()
        express.raw()
        express.Router()
        express.static()
        express.text()
        express.urlencoded()
    
    

    Application
        
            Properties
            
            app.locals
            
            app.mountpath
            
            app.router
            
            Events
            
            mount
            
            Methods
            
            app.all()
            
            app.delete()
            
            app.disable()
            
            app.disabled()
            
            app.enable()
            
            app.enabled()
            
            app.engine()
            
            app.get()
            
            app.get()
            
            app.listen()
            
            app.METHOD()
            
            app.param()
            
            app.path()
            
            app.post()
            
            app.put()
            
            app.render()
            
            app.route()
            
            app.set()
            
            app.use()
            
        
    
    Request
        
            Properties
            
            req.app
            
            req.baseUrl
            
            req.body
            
            req.cookies
            
            req.fresh
            
            req.host
            
            req.hostname
            
            req.ip
            
            req.ips
            
            req.method
            
            req.originalUrl
            
            req.params
            
            req.path
            
            req.protocol
            
            req.query
            
            req.res
            
            req.route
            
            req.secure
            
            req.signedCookies
            
            req.stale
            
            req.subdomains
            
            req.xhr
            
            Methods
            
            req.accepts()
            
            req.acceptsCharsets()
            
            req.acceptsEncodings()
            
            req.acceptsLanguages()
            
            req.get()
            
            req.is()
            
            req.range()
            
        
    
    Response
        
            Properties
            
            res.app      
            
            res.headersSent
            
            res.locals
            
            Methods
            
            res.append()
            
            res.attachment()
            
            res.cookie()
            
            res.clearCookie()
            
            res.download()
            
            res.end()
            
            res.format()
            
            res.get()
            
            res.json()
            
            res.jsonp()
            
            res.links()
            
            res.location()
            
            res.redirect()
            
            res.render()
            
            res.send()
            
            res.sendFile()
            
            res.sendStatus()
            
            res.set()
            
            res.status()
            
            res.type()
            
            res.vary()
            
        
    
    Router
        
            Methods
            
            router.all()
            
            router.METHOD()
            
            router.param()
            
            router.route()
            
            router.use()
            
        
    


        
      
      
        

  5.x API

  
     Note

    Express 5.0 requires Node.js 18 or higher.
    

  

  express()

  Creates an Express application. The express() function is a top-level function exported by the express module.

  const express = require('express')
const app = express()
  

  Methods

  
    express.json([options])

    This is a built-in middleware function in Express. It parses incoming requests
with JSON payloads and is based on
body-parser.

    Returns middleware that only parses JSON and only looks at requests where
the Content-Type header matches the type option. This parser accepts any
Unicode encoding of the body and supports automatic inflation of gzip and
deflate encodings.

    A new body object containing the parsed data is populated on the request
object after the middleware (i.e. req.body), or undefined if
there was no body to parse, the Content-Type was not matched, or an error
occurred.

    
      As req.body’s shape is based on user-controlled input, all properties and
values in this object are untrusted and should be validated before trusting.
For example, req.body.foo.toString() may fail in multiple ways, for example
foo may not be there or may not be a string, and toString may not be a
function and instead a string or other user-input.
    

    The following table describes the properties of the optional options object.

    
      
        
          Property
          Description
          Type
          Default
        
      
      
        
          inflate
          Enables or disables handling deflated (compressed) bodies; when disabled, deflated bodies are rejected.
          Boolean
          true
        
        
          limit
          Controls the maximum request body size. If this is a number, then the value specifies the number of bytes; if it is a string, the value is passed to the bytes library for parsing.
          Mixed
          "100kb"
        
        
          reviver
          The reviver option is passed directly to JSON.parse as the second argument. You can find more information on this argument in the MDN documentation about JSON.parse.
          Function
          null
        
        
          strict
          Enables or disables only accepting arrays and objects; when disabled will accept anything JSON.parse accepts.
          Boolean
          true
        
        
          type
          This is used to determine what media type the middleware will parse. This option can be a string, array of strings, or a function. If not a function, type option is passed directly to the type-is library and this can be an extension name (like json), a mime type (like application/json), or a mime type with a wildcard (like */* or */json). If a function, the type option is called as fn(req) and the request is parsed if it returns a truthy value.
          Mixed
          "application/json"
        
        
          verify
          This option, if supplied, is called as verify(req, res, buf, encoding), where buf is a Buffer of the raw request body and encoding is the encoding of the request. The parsing can be aborted by throwing an error.
          Function
          undefined
        
      
    

  

  
    express.raw([options])

    This is a built-in middleware function in Express. It parses incoming request
payloads into a Buffer and is based on
body-parser.

    Returns middleware that parses all bodies as a Buffer and only looks at requests
where the Content-Type header matches the type option. This parser accepts
any Unicode encoding of the body and supports automatic inflation of gzip and
deflate encodings.

    A new body Buffer containing the parsed data is populated on the request
object after the middleware (i.e. req.body), or undefined if
there was no body to parse, the Content-Type was not matched, or an error
occurred.

    
      As req.body’s shape is based on user-controlled input, all properties and
values in this object are untrusted and should be validated before trusting.
For example, req.body.toString() may fail in multiple ways, for example
stacking multiple parsers req.body may be from a different parser. Testing
that req.body is a Buffer before calling buffer methods is recommended.
    

    The following table describes the properties of the optional options object.

    
      
        
          Property
          Description
          Type
          Default
        
      
      
        
          inflate
          Enables or disables handling deflated (compressed) bodies; when disabled, deflated bodies are rejected.
          Boolean
          true
        
        
          limit
          Controls the maximum request body size. If this is a number, then the value specifies the number of bytes; if it is a string, the value is passed to the bytes library for parsing.
          Mixed
          "100kb"
        
        
          type
          This is used to determine what media type the middleware will parse. This option can be a string, array of strings, or a function. If not a function, type option is passed directly to the type-is library and this can be an extension name (like bin), a mime type (like application/octet-stream), or a mime type with a wildcard (like */* or application/*). If a function, the type option is called as fn(req) and the request is parsed if it returns a truthy value.
          Mixed
          "application/octet-stream"
        
        
          verify
          This option, if supplied, is called as verify(req, res, buf, encoding), where buf is a Buffer of the raw request body and encoding is the encoding of the request. The parsing can be aborted by throwing an error.
          Function
          undefined
        
      
    

  

  
    express.Router([options])

    Creates a new router object.

    const router = express.Router([options])
    

    The optional options parameter specifies the behavior of the router.

    

      
        
          
            Property
            Description
            Default
            Availability
          
        
        
          
            caseSensitive
            Enable case sensitivity.
            Disabled by default, treating “/Foo” and “/foo” as the same.
             
          
          
            mergeParams
            Preserve the req.params values from the parent router. If the parent and the child have conflicting param names, the child’s value take precedence.
            false
            4.5.0+
          
          
            strict
            Enable strict routing.
            Disabled by default, “/foo” and “/foo/” are treated the same by the router.
             
          
        
      

    

    You can add middleware and HTTP method routes (such as get, put, post, and
so on) to router just like an application.

    For more information, see Router.

  

  
    express.static(root, [options])

    This is a built-in middleware function in Express.
It serves static files and is based on  serve-static.

    
      NOTE: For best results, use a reverse proxy cache to improve performance of serving static assets.
    

    The root argument specifies the root directory from which to serve static assets.
The function determines the file to serve by combining req.url with the provided root directory.
When a file is not found, instead of sending a 404 response, it instead calls next()
to move on to the next middleware, allowing for stacking and fall-backs.

    The following table describes the properties of the options object.
See also the example below.

    
      
        
          Property
          Description
          Type
          Default
        
      
      
        
          dotfiles
          Determines how dotfiles (files or directories that begin with a dot “.”) are treated.  See dotfiles below.
          String
          “ignore”
        
        
          etag
          Enable or disable etag generation NOTE: express.static always sends weak ETags.
          Boolean
          true
        
        
          extensions
          Sets file extension fallbacks: If a file is not found, search for files with the specified extensions and serve the first one found. Example: ['html', 'htm'].
          Mixed
          false
        
        
          fallthrough
          Let client errors fall-through as unhandled requests, otherwise forward a client error. See fallthrough below.
          Boolean
          true
        
        
          immutable
          Enable or disable the immutable directive in the Cache-Control response header. If enabled, the maxAge option should also be specified to enable caching. The immutable directive will prevent supported clients from making conditional requests during the life of the maxAge option to check if the file has changed.
          Boolean
          false
        
        
          index
          Sends the specified directory index file. Set to false to disable directory indexing.
          Mixed
          “index.html”
        
        
          lastModified
          Set the Last-Modified header to the last modified date of the file on the OS.
          Boolean
          true
        
        
          maxAge
          Set the max-age property of the Cache-Control header in milliseconds or a string in ms format.
          Number
          0
        
        
          redirect
          Redirect to trailing “/” when the pathname is a directory.
          Boolean
          true
        
        
          setHeaders
          Function for setting HTTP headers to serve with the file. See setHeaders below.
          Function
           
        
      
    

    For more information, see Serving static files in Express.
and Using middleware - Built-in middleware.

     dotfiles

    Possible values for this option are:

    
      “allow” - No special treatment for dotfiles.
      “deny” - Deny a request for a dotfile, respond with 403, then call next().
      “ignore” - Act as if the dotfile does not exist, respond with 404, then call next().
    

    fallthrough

    When this option is true, client errors such as a bad request or a request to a non-existent
file will cause this middleware to simply call next() to invoke the next middleware in the stack.
When false, these errors (even 404s), will invoke next(err).

    Set this option to true so you can map multiple physical directories
to the same web address or for routes to fill in non-existent files.

    Use false if you have mounted this middleware at a path designed
to be strictly a single file system directory, which allows for short-circuiting 404s
for less overhead. This middleware will also reply to all methods.

    setHeaders

    For this option, specify a function to set custom response headers. Alterations to the headers must occur synchronously.

    The signature of the function is:

    fn(res, path, stat)
    

    Arguments:

    
      res, the response object.
      path, the file path that is being sent.
      stat, the stat object of the file that is being sent.
    

    Example of express.static

    Here is an example of using the express.static middleware function with an elaborate options object:

    const options = {
  dotfiles: 'ignore',
  etag: false,
  extensions: ['htm', 'html'],
  index: false,
  maxAge: '1d',
  redirect: false,
  setHeaders (res, path, stat) {
    res.set('x-timestamp', Date.now())
  }
}

app.use(express.static('public', options))
    

  

  
    express.text([options])

    This is a built-in middleware function in Express. It parses incoming request
payloads into a string and is based on
body-parser.

    Returns middleware that parses all bodies as a string and only looks at requests
where the Content-Type header matches the type option. This parser accepts
any Unicode encoding of the body and supports automatic inflation of gzip and
deflate encodings.

    A new body string containing the parsed data is populated on the request
object after the middleware (i.e. req.body), or undefined if
there was no body to parse, the Content-Type was not matched, or an error
occurred.

    
      As req.body’s shape is based on user-controlled input, all properties and
values in this object are untrusted and should be validated before trusting.
For example, req.body.trim() may fail in multiple ways, for example
stacking multiple parsers req.body may be from a different parser. Testing
that req.body is a string before calling string methods is recommended.
    

    The following table describes the properties of the optional options object.

    
      
        
          Property
          Description
          Type
          Default
        
      
      
        
          defaultCharset
          Specify the default character set for the text content if the charset is not specified in the Content-Type header of the request.
          String
          "utf-8"
        
        
          inflate
          Enables or disables handling deflated (compressed) bodies; when disabled, deflated bodies are rejected.
          Boolean
          true
        
        
          limit
          Controls the maximum request body size. If this is a number, then the value specifies the number of bytes; if it is a string, the value is passed to the bytes library for parsing.
          Mixed
          "100kb"
        
        
          type
          This is used to determine what media type the middleware will parse. This option can be a string, array of strings, or a function. If not a function, type option is passed directly to the type-is library and this can be an extension name (like txt), a mime type (like text/plain), or a mime type with a wildcard (like */* or text/*). If a function, the type option is called as fn(req) and the request is parsed if it returns a truthy value.
          Mixed
          "text/plain"
        
        
          verify
          This option, if supplied, is called as verify(req, res, buf, encoding), where buf is a Buffer of the raw request body and encoding is the encoding of the request. The parsing can be aborted by throwing an error.
          Function
          undefined
        
      
    

  

  
    express.urlencoded([options])

    This is a built-in middleware function in Express. It parses incoming requests
with urlencoded payloads and is based on body-parser.

    Returns middleware that only parses urlencoded bodies and only looks at
requests where the Content-Type header matches the type option. This
parser accepts only UTF-8 encoding of the body and supports automatic
inflation of gzip and deflate encodings.

    A new body object containing the parsed data is populated on the request
object after the middleware (i.e. req.body), or undefined if
there was no body to parse, the Content-Type was not matched, or an error
occurred. This object will contain key-value pairs, where the value can be
a string or array (when extended is false), or any type (when extended
is true).

    
      As req.body’s shape is based on user-controlled input, all properties and
values in this object are untrusted and should be validated before trusting.
For example, req.body.foo.toString() may fail in multiple ways, for example
foo may not be there or may not be a string, and toString may not be a
function and instead a string or other user-input.
    

    The following table describes the properties of the optional options object.

    
      
        
          Property
          Description
          Type
          Default
        
      
      
        
          extended
          This option allows to choose between parsing the URL-encoded data with the querystring library (when false) or the qs library (when true). The “extended” syntax allows for rich objects and arrays to be encoded into the URL-encoded format, allowing for a JSON-like experience with URL-encoded. For more information, please see the qs library.
          Boolean
          false
        
        
          inflate
          Enables or disables handling deflated (compressed) bodies; when disabled, deflated bodies are rejected.
          Boolean
          true
        
        
          limit
          Controls the maximum request body size. If this is a number, then the value specifies the number of bytes; if it is a string, the value is passed to the bytes library for parsing.
          Mixed
          "100kb"
        
        
          parameterLimit
          This option controls the maximum number of parameters that are allowed in the URL-encoded data. If a request contains more parameters than this value, an error will be raised.
          Number
          1000
        
        
          type
          This is used to determine what media type the middleware will parse. This option can be a string, array of strings, or a function. If not a function, type option is passed directly to the type-is library and this can be an extension name (like urlencoded), a mime type (like application/x-www-form-urlencoded), or a mime type with a wildcard (like */x-www-form-urlencoded). If a function, the type option is called as fn(req) and the request is parsed if it returns a truthy value.
          Mixed
          "application/x-www-form-urlencoded"
        
        
          verify
          This option, if supplied, is called as verify(req, res, buf, encoding), where buf is a Buffer of the raw request body and encoding is the encoding of the request. The parsing can be aborted by throwing an error.
          Function
          undefined
        
      
    

  

  Application

  The app object conventionally denotes the Express application.
Create it by calling the top-level express() function exported by the Express module:

  const express = require('express')
const app = express()

app.get('/', (req, res) => {
  res.send('hello world')
})

app.listen(3000)
  

  The app object has methods for

  
    Routing HTTP requests; see for example, app.METHOD and app.param.
    Configuring middleware; see app.route.
    Rendering HTML views; see app.render.
    Registering a template engine; see app.engine.
  

  It also has settings (properties) that affect how the application behaves;
for more information, see Application settings.

  
    The Express application object can be referred from the request object and the response object as req.app, and res.app, respectively.
  

  Properties

  
    app.locals

    The app.locals object has properties that are local variables within the application,
and will be available in templates rendered with res.render.

    
      The locals object is used by view engines to render a response. The object
keys may be particularly sensitive and should not contain user-controlled
input, as it may affect the operation of the view engine or provide a path to
cross-site scripting. Consult the documentation for the used view engine for
additional considerations.
    

    console.dir(app.locals.title)
// => 'My App'

console.dir(app.locals.email)
// => '[email protected]'
    

    Once set, the value of app.locals properties persist throughout the life of the application,
in contrast with res.locals properties that
are valid only for the lifetime of the request.

    You can access local variables in templates rendered within the application.
This is useful for providing helper functions to templates, as well as application-level data.
Local variables are available in middleware via req.app.locals (see req.app)

    app.locals.title = 'My App'
app.locals.strftime = require('strftime')
app.locals.email = '[email protected]'
    

  

  
    app.mountpath

    The app.mountpath property contains one or more path patterns on which a sub-app was mounted.

    
      A sub-app is an instance of express that may be used for handling the request to a route.
    

    const express = require('express')

const app = express() // the main app
const admin = express() // the sub app

admin.get('/', (req, res) => {
  console.log(admin.mountpath) // /admin
  res.send('Admin Homepage')
})

app.use('/admin', admin) // mount the sub app
    

    It is similar to the baseUrl property of the req object, except req.baseUrl
returns the matched URL path, instead of the matched patterns.

    If a sub-app is mounted on multiple path patterns, app.mountpath returns the list of
patterns it is mounted on, as shown in the following example.

    const admin = express()

admin.get('/', (req, res) => {
  console.log(admin.mountpath) // [ '/adm{*splat}n', '/manager' ]
  res.send('Admin Homepage')
})

const secret = express()
secret.get('/', (req, res) => {
  console.log(secret.mountpath) // /secr{*splat}t
  res.send('Admin Secret')
})

admin.use('/secr{*splat}t', secret) // load the 'secret' router on '/secr{*splat}t', on the 'admin' sub app
app.use(['/adm{*splat}n', '/manager'], admin) // load the 'admin' router on '/adm{*splat}n' and '/manager', on the parent app
    

  

  
    app.router

    The application’s in-built instance of router. This is created lazily, on first access.

    const express = require('express')
const app = express()
const router = app.router

router.get('/', (req, res) => {
  res.send('hello world')
})

app.listen(3000)
    

    You can add middleware and HTTP method routes to the router just like an application.

    For more information, see Router.

  

  Events

  
    app.on('mount', callback(parent))

    The mount event is fired on a sub-app, when it is mounted on a parent app. The parent app is passed to the callback function.

    
      NOTE

      Sub-apps will:

      
        Not inherit the value of settings that have a default value. You must set the value in the sub-app.
        Inherit the value of settings with no default value.
      

      For details, see Application settings.
    

    const admin = express()

admin.on('mount', (parent) => {
  console.log('Admin Mounted')
  console.log(parent) // refers to the parent app
})

admin.get('/', (req, res) => {
  res.send('Admin Homepage')
})

app.use('/admin', admin)
    

  

  Methods

  
    app.all(path, callback [, callback ...])

    This method is like the standard app.METHOD() methods,
except it matches all HTTP verbs.

     Arguments

    

Argument 
 Description 
 Default 



path

The path for which the middleware function is invoked; can be any of:

A string representing a path.
A path pattern.
A regular expression pattern to match paths.
An array of combinations of any of the above.


For examples, see Path examples.

'/' (root path)



 callback

Callback functions; can be:

A middleware function.
A series of middleware functions (separated by commas).
An array of middleware functions.
A combination of all of the above.


You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke next('route') to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.

When a callback function throws an error or returns a rejected promise, `next(err)` will be invoked automatically.

Since router and app implement the middleware interface,
you can use them as you would any other middleware function.

For examples, see Middleware callback function examples.


 None 


    Examples

    The following callback is executed for requests to /secret whether using
GET, POST, PUT, DELETE, or any other HTTP request method:

    app.all('/secret', (req, res, next) => {
  console.log('Accessing the secret section ...')
  next() // pass control to the next handler
})
    

    The app.all() method is useful for mapping “global” logic for specific path prefixes or arbitrary matches. For example, if you put the following at the top of all other
route definitions, it requires that all routes from that point on
require authentication, and automatically load a user. Keep in mind
that these callbacks do not have to act as end-points: loadUser
can perform a task, then call next() to continue matching subsequent
routes.

    app.all('{*splat}', requireAuthentication, loadUser)
    

    Or the equivalent:

    app.all('{*splat}', requireAuthentication)
app.all('{*splat}', loadUser)
    

    Another example is white-listed “global” functionality.
The example is similar to the ones above, but it only restricts paths that start with
“/api”:

    app.all('/api/{*splat}', requireAuthentication)
    

  

  
    app.delete(path, callback [, callback ...])

    Routes HTTP DELETE requests to the specified path with the specified callback functions.
For more information, see the routing guide.

     Arguments

    

Argument 
 Description 
 Default 



path

The path for which the middleware function is invoked; can be any of:

A string representing a path.
A path pattern.
A regular expression pattern to match paths.
An array of combinations of any of the above.


For examples, see Path examples.

'/' (root path)



 callback

Callback functions; can be:

A middleware function.
A series of middleware functions (separated by commas).
An array of middleware functions.
A combination of all of the above.


You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke next('route') to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.

When a callback function throws an error or returns a rejected promise, `next(err)` will be invoked automatically.

Since router and app implement the middleware interface,
you can use them as you would any other middleware function.

For examples, see Middleware callback function examples.


 None 


    Example

    app.delete('/', (req, res) => {
  res.send('DELETE request to homepage')
})
    

  

  
    app.disable(name)

    Sets the Boolean setting name to false, where name is one of the properties from the app settings table.
Calling app.set('foo', false) for a Boolean property is the same as calling app.disable('foo').

    For example:

    app.disable('trust proxy')
app.get('trust proxy')
// => false
    

  

  
    app.disabled(name)

    Returns true if the Boolean setting name is disabled (false), where name is one of the properties from
the app settings table.

    app.disabled('trust proxy')
// => true

app.enable('trust proxy')
app.disabled('trust proxy')
// => false
    

  

  
    app.enable(name)

    Sets the Boolean setting name to true, where name is one of the properties from the app settings table.
Calling app.set('foo', true) for a Boolean property is the same as calling app.enable('foo').

    app.enable('trust proxy')
app.get('trust proxy')
// => true
    

  

  
    app.enabled(name)

    Returns true if the setting name is enabled (true), where name is one of the
properties from the app settings table.

    app.enabled('trust proxy')
// => false

app.enable('trust proxy')
app.enabled('trust proxy')
// => true
    

  

  
    app.engine(ext, callback)

    Registers the given template engine callback as ext.

    By default, Express will require() the engine based on the file extension.
For example, if you try to render a “foo.pug” file, Express invokes the
following internally, and caches the require() on subsequent calls to increase
performance.

    app.engine('pug', require('pug').__express)
    

    Use this method for engines that do not provide .__express out of the box,
or if you wish to “map” a different extension to the template engine.

    For example, to map the EJS template engine to “.html” files:

    app.engine('html', require('ejs').renderFile)
    

    In this case, EJS provides a .renderFile() method with
the same signature that Express expects: (path, options, callback),
though note that it aliases this method as ejs.__express internally
so if you’re using “.ejs” extensions you don’t need to do anything.

    Some template engines do not follow this convention.  The
consolidate.js library maps Node template engines to follow this convention,
so they work seamlessly with Express.

    const engines = require('consolidate')
app.engine('haml', engines.haml)
app.engine('html', engines.hogan)
    

  

  
    app.get(name)

    Returns the value of name app setting, where name is one of the strings in the
app settings table. For example:

    app.get('title')
// => undefined

app.set('title', 'My Site')
app.get('title')
// => "My Site"
    

  

  
    app.get(path, callback [, callback ...])

    Routes HTTP GET requests to the specified path with the specified callback functions.

     Arguments

    

Argument 
 Description 
 Default 



path

The path for which the middleware function is invoked; can be any of:

A string representing a path.
A path pattern.
A regular expression pattern to match paths.
An array of combinations of any of the above.


For examples, see Path examples.

'/' (root path)



 callback

Callback functions; can be:

A middleware function.
A series of middleware functions (separated by commas).
An array of middleware functions.
A combination of all of the above.


You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke next('route') to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.

When a callback function throws an error or returns a rejected promise, `next(err)` will be invoked automatically.

Since router and app implement the middleware interface,
you can use them as you would any other middleware function.

For examples, see Middleware callback function examples.


 None 


    For more information, see the routing guide.

    Example

    app.get('/', (req, res) => {
  res.send('GET request to homepage')
})
    

  

  
    app.listen(path, [callback])

    Starts a UNIX socket and listens for connections on the given path.
This method is identical to Node’s http.Server.listen().

    const express = require('express')
const app = express()
app.listen('/tmp/sock')
    

    app.listen([port[, host[, backlog]]][, callback])

    Binds and listens for connections on the specified host and port.
This method is identical to Node’s http.Server.listen().

    If port is omitted or is 0, the operating system will assign an arbitrary unused
port, which is useful for cases like automated tasks (tests, etc.).

    const express = require('express')
const app = express()
app.listen(3000)
    

    The app returned by express() is in fact a JavaScript
Function, designed to be passed to Node’s HTTP servers as a callback
to handle requests. This makes it easy to provide both HTTP and HTTPS versions of
your app with the same code base, as the app does not inherit from these
(it is simply a callback):

    const express = require('express')
const https = require('https')
const http = require('http')
const app = express()

http.createServer(app).listen(80)
https.createServer(options, app).listen(443)
    

    The app.listen() method returns an http.Server object and (for HTTP) is a convenience method for the following:

    app.listen = function () {
  const server = http.createServer(this)
  return server.listen.apply(server, arguments)
}
    

    
       Note
      All the forms of Node’s http.Server.listen() method are in fact actually supported.
    

  

  
    app.METHOD(path, callback [, callback ...])

    Routes an HTTP request, where METHOD is the HTTP method of the request, such as GET,
PUT, POST, and so on, in lowercase. Thus, the actual methods are app.get(),
app.post(), app.put(), and so on. See Routing methods below for the complete list.

     Arguments

    

Argument 
 Description 
 Default 



path

The path for which the middleware function is invoked; can be any of:

A string representing a path.
A path pattern.
A regular expression pattern to match paths.
An array of combinations of any of the above.


For examples, see Path examples.

'/' (root path)



 callback

Callback functions; can be:

A middleware function.
A series of middleware functions (separated by commas).
An array of middleware functions.
A combination of all of the above.


You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke next('route') to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.

When a callback function throws an error or returns a rejected promise, `next(err)` will be invoked automatically.

Since router and app implement the middleware interface,
you can use them as you would any other middleware function.

For examples, see Middleware callback function examples.


 None 


    Routing methods

    Express supports the following routing methods corresponding to the HTTP methods of the same names:

    


          
            checkout
            copy
            delete
            get
            head
            lock
            merge
            mkactivity
          
        

          
            mkcol
            move
            m-search
            notify
            options
            patch
            post
          
        

          
            purge
            put
            report
            search
            subscribe
            trace
            unlock
            unsubscribe
          
        



    The API documentation has explicit entries only for the most popular HTTP methods app.get(),
app.post(), app.put(), and app.delete().
However, the other methods listed above work in exactly the same way.

    To route methods that translate to invalid JavaScript variable names, use the bracket notation. For example, app['m-search']('/', function ....

    
      The app.get() function is automatically called for the HTTP HEAD method in addition to the GET
  method if app.head() was not called for the path before app.get().
    

    The method, app.all(), is not derived from any HTTP method and loads middleware at
the specified path for all HTTP request methods.
For more information, see app.all.

    For more information on routing, see the routing guide.

  

  
    app.param(name, callback)

    Add callback triggers to route parameters, where name is the name of the parameter or an array of them, and callback is the callback function. The parameters of the callback function are the request object, the response object, the next middleware, the value of the parameter and the name of the parameter, in that order.

    If name is an array, the callback trigger is registered for each parameter declared in it, in the order in which they are declared. Furthermore, for each declared parameter except the last one, a call to next inside the callback will call the callback for the next declared parameter. For the last parameter, a call to next will call the next middleware in place for the route currently being processed, just like it would if name were just a string.

    For example, when :user is present in a route path, you may map user loading logic to automatically provide req.user to the route, or perform validations on the parameter input.

    app.param('user', (req, res, next, id) => {
  // try to get the user details from the User model and attach it to the request object
  User.find(id, (err, user) => {
    if (err) {
      next(err)
    } else if (user) {
      req.user = user
      next()
    } else {
      next(new Error('failed to load user'))
    }
  })
})
    

    Param callback functions are local to the router on which they are defined. They are not inherited by mounted apps or routers, nor are they triggered for route parameters inherited from parent routers. Hence, param callbacks defined on app will be triggered only by route parameters defined on app routes.

    All param callbacks will be called before any handler of any route in which the param occurs, and they will each be called only once in a request-response cycle, even if the parameter is matched in multiple routes, as shown in the following examples.

    app.param('id', (req, res, next, id) => {
  console.log('CALLED ONLY ONCE')
  next()
})

app.get('/user/:id', (req, res, next) => {
  console.log('although this matches')
  next()
})

app.get('/user/:id', (req, res) => {
  console.log('and this matches too')
  res.end()
})
    

    On GET /user/42, the following is printed:

    CALLED ONLY ONCE
although this matches
and this matches too
    

    app.param(['id', 'page'], (req, res, next, value) => {
  console.log('CALLED ONLY ONCE with', value)
  next()
})

app.get('/user/:id/:page', (req, res, next) => {
  console.log('although this matches')
  next()
})

app.get('/user/:id/:page', (req, res) => {
  console.log('and this matches too')
  res.end()
})
    

    On GET /user/42/3, the following is printed:

    CALLED ONLY ONCE with 42
CALLED ONLY ONCE with 3
although this matches
and this matches too
    

  

  
    app.path()

    Returns the canonical path of the app, a string.

    const app = express()
const blog = express()
const blogAdmin = express()

app.use('/blog', blog)
blog.use('/admin', blogAdmin)

console.log(app.path()) // ''
console.log(blog.path()) // '/blog'
console.log(blogAdmin.path()) // '/blog/admin'
    

    The behavior of this method can become very complicated in complex cases of mounted apps:
it is usually better to use req.baseUrl to get the canonical path of the app.

  

  
    app.post(path, callback [, callback ...])

    Routes HTTP POST requests to the specified path with the specified callback functions.
For more information, see the routing guide.

     Arguments

    

Argument 
 Description 
 Default 



path

The path for which the middleware function is invoked; can be any of:

A string representing a path.
A path pattern.
A regular expression pattern to match paths.
An array of combinations of any of the above.


For examples, see Path examples.

'/' (root path)



 callback

Callback functions; can be:

A middleware function.
A series of middleware functions (separated by commas).
An array of middleware functions.
A combination of all of the above.


You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke next('route') to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.

When a callback function throws an error or returns a rejected promise, `next(err)` will be invoked automatically.

Since router and app implement the middleware interface,
you can use them as you would any other middleware function.

For examples, see Middleware callback function examples.


 None 


    Example

    app.post('/', (req, res) => {
  res.send('POST request to homepage')
})
    

  

  
    app.put(path, callback [, callback ...])

    Routes HTTP PUT requests to the specified path with the specified callback functions.

     Arguments

    

Argument 
 Description 
 Default 



path

The path for which the middleware function is invoked; can be any of:

A string representing a path.
A path pattern.
A regular expression pattern to match paths.
An array of combinations of any of the above.


For examples, see Path examples.

'/' (root path)



 callback

Callback functions; can be:

A middleware function.
A series of middleware functions (separated by commas).
An array of middleware functions.
A combination of all of the above.


You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke next('route') to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.

When a callback function throws an error or returns a rejected promise, `next(err)` will be invoked automatically.

Since router and app implement the middleware interface,
you can use them as you would any other middleware function.

For examples, see Middleware callback function examples.


 None 


    Example

    app.put('/', (req, res) => {
  res.send('PUT request to homepage')
})
    

  

  
    app.render(view, [locals], callback)

    Returns the rendered HTML of a view via the callback function. It accepts an optional parameter
that is an object containing local variables for the view. It is like res.render(),
except it cannot send the rendered view to the client on its own.

    
      Think of app.render() as a utility function for generating rendered view strings.
Internally res.render() uses app.render() to render views.
    

    
      The view argument performs file system operations like reading a file from
disk and evaluating Node.js modules, and as so for security reasons should not
contain input from the end-user.
    

    
      The locals object is used by view engines to render a response. The object
keys may be particularly sensitive and should not contain user-controlled
input, as it may affect the operation of the view engine or provide a path to
cross-site scripting. Consult the documentation for the used view engine for
additional considerations.
    

    
      The local variable cache is reserved for enabling view cache. Set it to true, if you want to
cache view during development; view caching is enabled in production by default.
    

    app.render('email', (err, html) => {
  // ...
})

app.render('email', { name: 'Tobi' }, (err, html) => {
  // ...
})
    

  

  
    app.route(path)

    Returns an instance of a single route, which you can then use to handle HTTP verbs with optional middleware.
Use app.route() to avoid duplicate route names (and thus typo errors).

    const app = express()

app.route('/events')
  .all((req, res, next) => {
    // runs for all HTTP verbs first
    // think of it as route specific middleware!
  })
  .get((req, res, next) => {
    res.json({})
  })
  .post((req, res, next) => {
    // maybe add a new event...
  })
    

  

  
    app.set(name, value)

    Assigns setting name to value. You may store any value that you want,
but certain names can be used to configure the behavior of the server. These
special names are listed in the app settings table.

    Calling app.set('foo', true) for a Boolean property is the same as calling
app.enable('foo'). Similarly, calling app.set('foo', false) for a Boolean
property is the same as calling app.disable('foo').

    Retrieve the value of a setting with app.get().

    app.set('title', 'My Site')
app.get('title') // "My Site"
    

    Application Settings

    The following table lists application settings.

    Note that sub-apps will:

    
      Not inherit the value of settings that have a default value. You must set the value in the sub-app.
      Inherit the value of settings with no default value; these are explicitly noted in the table below.
    

    Exceptions: Sub-apps will inherit the value of trust proxy even though it has a default value (for backward-compatibility);
Sub-apps will not inherit the value of view cache in production (when NODE_ENV is “production”).

    
  
    PropertyTypeDescriptionDefault
    
    
  
              case sensitive routing
            
      Boolean
      Enable case sensitivity.
      When enabled, "/Foo" and "/foo" are different routes.
      When disabled, "/Foo" and "/foo" are treated the same.
        NOTE: Sub-apps will inherit the value of this setting.
      
      N/A (undefined)
      
    
    
  
              env
            
      String
      Environment mode.
      Be sure to set to "production" in a production environment;
      see Production best practices: performance and reliability.
    
  
              process.env.NODE_ENV (NODE_ENV environment variable) or “development” if NODE_ENV is not set.
            
    
    
  
              etag
            
  Varied
  
              Set the ETag response header. For possible values, see the etag options table.

              More about the HTTP ETag header.
            
  
              weak
            
    
    
  
              jsonp callback name
            
      String
      Specifies the default JSONP callback name.
  
              “callback”
            
    
    
  
              json escape
            
  Boolean
  
              Enable escaping JSON responses from the res.json, res.jsonp, and res.send APIs. This will escape the characters <, >, and & as Unicode escape sequences in JSON. The purpose of this is to assist with mitigating certain types of persistent XSS attacks when clients sniff responses for HTML.
              NOTE: Sub-apps will inherit the value of this setting.
            
  N/A (undefined)
    
    
  
              json replacer
            
      Varied
      The 'replacer' argument used by `JSON.stringify`.
        NOTE: Sub-apps will inherit the value of this setting.
      
  N/A (undefined)
  
    
    
  
              json spaces
            
      Varied
      The 'space' argument used by `JSON.stringify`.
This is typically set to the number of spaces to use to indent prettified JSON.
        NOTE: Sub-apps will inherit the value of this setting.
      
      N/A (undefined)
    
    
  
              query parser
            
      Varied
  
              Disable query parsing by setting the value to false, or set the query parser to use either “simple” or “extended” or a custom query string parsing function.

              The simple query parser is based on Node’s native query parser, querystring.

              The extended query parser is based on qs.

              A custom query string parsing function will receive the complete query string, and must return an object of query keys and their values.
            
      "simple"
    
    
  
              strict routing
            
      Boolean
      Enable strict routing.
      When enabled, the router treats "/foo" and "/foo/" as different.
      Otherwise, the router treats "/foo" and "/foo/" as the same.
        NOTE: Sub-apps will inherit the value of this setting.
      
      N/A (undefined) 
    
    
  
              subdomain offset
            
      Number
      The number of dot-separated parts of the host to remove to access subdomain.
      2
    
    
  
              trust proxy
            
      Varied
  
              Indicates the app is behind a front-facing proxy, and to use the X-Forwarded-* headers to determine the connection and the IP address of the client. NOTE: X-Forwarded-* headers are easily spoofed and the detected IP addresses are unreliable.
              
  When enabled, Express attempts to determine the IP address of the client connected through the front-facing proxy, or series of proxies. The `req.ips` property, then contains an array of IP addresses the client is connected through. To enable it, use the values described in the trust proxy options table.

              
  The `trust proxy` setting is implemented using the proxy-addr package. For more information, see its documentation.

              
NOTE: Sub-apps will inherit the value of this setting, even though it has a default value.

            
  
              false (disabled)
            
    
    
  
              views
            
      String or Array
      A directory or an array of directories for the application's views. If an array, the views are looked up in the order they occur in the array.
  
              process.cwd() + '/views'
            
    
    
  
              view cache
            
      Boolean
      Enables view template compilation caching.
      NOTE: Sub-apps will not inherit the value of this setting in production (when `NODE_ENV` is "production").
      
  
              true in production, otherwise undefined.
            
    
    
  
              view engine
            
      String
      The default engine extension to use when omitted.
        NOTE: Sub-apps will inherit the value of this setting.
      
      N/A (undefined)
    
    
  
              x-powered-by
            
      Boolean
      Enables the "X-Powered-By: Express" HTTP header.
  
              true
            
    
    
  

  Options for `trust proxy` setting

  
  Read Express behind proxies for more
  information.
  

  
    TypeValue
    
      
        Boolean
  
              If true, the client’s IP address is understood as the left-most entry in the X-Forwarded-* header.

              If false, the app is understood as directly facing the Internet and the client’s IP address is derived from req.connection.remoteAddress. This is the default setting.
            
      
      
        StringString containing comma-separated valuesArray of strings 
  
              An IP address, subnet, or an array of IP addresses, and subnets to trust. Pre-configured subnet names are:

              
                loopback - 127.0.0.1/8, ::1/128
                linklocal - 169.254.0.0/16, fe80::/10
                uniquelocal - 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, fc00::/7
              

              Set IP addresses in any of the following ways:

              Specify a single subnet:

              app.set('trust proxy', 'loopback')
              

              Specify a subnet and an address:

              app.set('trust proxy', 'loopback, 123.123.123.123')
              

              Specify multiple subnets as CSV:

              app.set('trust proxy', 'loopback, linklocal, uniquelocal')
              

              Specify multiple subnets as an array:

              app.set('trust proxy', ['loopback', 'linklocal', 'uniquelocal'])
              

              When specified, the IP addresses or the subnets are excluded from the address determination process, and the untrusted IP address nearest to the application server is determined as the client’s IP address.
            
      
      
        Number
  
              Trust the nth hop from the front-facing proxy server as the client.
            
      
      
        Function
  
              Custom trust implementation. Use this only if you know what you are doing.

              app.set('trust proxy', (ip) => {
  if (ip === '127.0.0.1' || ip === '123.123.123.123') return true // trusted IPs
  else return false
})
              
            
      
    
  

  Options for `etag` setting


NOTE:  These settings apply only to dynamic files, not static files.
The express.static middleware ignores these settings.


  
  The ETag functionality is implemented using the
  etag package.
  For more information, see its documentation.
  

  
    TypeValue
    
      
        Boolean
  
              true enables weak ETag. This is the default setting.
  false disables ETag altogether.
            
      
      
        String
        
            If "strong", enables strong ETag.
            If "weak", enables weak ETag.
        
      
      
        Function
  
              Custom ETag function implementation. Use this only if you know what you are doing.

              app.set('etag', (body, encoding) => {
  return generateHash(body, encoding) // consider the function is defined
})
              
            
      
    
  


  

  
    app.use([path,] callback [, callback...])

    Mounts the specified middleware function or functions
at the specified path:
the middleware function is executed when the base of the requested path matches path.

     Arguments

    

Argument 
 Description 
 Default 



path

The path for which the middleware function is invoked; can be any of:

A string representing a path.
A path pattern.
A regular expression pattern to match paths.
An array of combinations of any of the above.


For examples, see Path examples.

'/' (root path)



 callback

Callback functions; can be:

A middleware function.
A series of middleware functions (separated by commas).
An array of middleware functions.
A combination of all of the above.


You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke next('route') to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.

When a callback function throws an error or returns a rejected promise, `next(err)` will be invoked automatically.

Since router and app implement the middleware interface,
you can use them as you would any other middleware function.

For examples, see Middleware callback function examples.


 None 


    Description

    A route will match any path that follows its path immediately with a “/”.
For example: app.use('/apple', ...) will match “/apple”, “/apple/images”,
“/apple/images/news”, and so on.

    Since path defaults to “/”, middleware mounted without a path will be executed for every request to the app.
For example, this middleware function will be executed for every request to the app:

    app.use((req, res, next) => {
  console.log('Time: %d', Date.now())
  next()
})
    

    
      NOTE

      Sub-apps will:

      
        Not inherit the value of settings that have a default value. You must set the value in the sub-app.
        Inherit the value of settings with no default value.
      

      For details, see Application settings.
    

    Middleware functions are executed sequentially, therefore the order of middleware inclusion is important.

    // this middleware will not allow the request to go beyond it
app.use((req, res, next) => {
  res.send('Hello World')
})

// requests will never reach this route
app.get('/', (req, res) => {
  res.send('Welcome')
})
    

    Error-handling middleware

    Error-handling middleware always takes four arguments. You must provide four arguments to identify it as an error-handling middleware function. Even if you don’t need to use the next object, you must specify it to maintain the signature. Otherwise, the next object will be interpreted as regular middleware and will fail to handle errors. For details about error-handling middleware, see: Error handling.

    Define error-handling middleware functions in the same way as other middleware functions, except with four arguments instead of three, specifically with the signature (err, req, res, next)):

    app.use((err, req, res, next) => {
  console.error(err.stack)
  res.status(500).send('Something broke!')
})
    

    Path examples

    The following table provides some simple examples of valid path values for
mounting middleware.

    




Type
Example






Path

              This will match paths starting with /abcd:

              app.use('/abcd', (req, res, next) => {
  next()
})
              

            



Path Pattern

              This will match paths starting with /abcd and /abd:

              app.use('/ab{c}d', (req, res, next) => {
  next()
})
              

            



Regular Expression

              This will match paths starting with /abc and /xyz:

              app.use(/\/abc|\/xyz/, (req, res, next) => {
  next()
})
              

            



Array

              This will match paths starting with /abcd, /xyza, /lmn, and /pqr:

              app.use(['/abcd', '/xyza', /\/lmn|\/pqr/], (req, res, next) => {
  next()
})
              

            







    Middleware callback function examples

    The following table provides some simple examples of middleware functions that
can be used as the callback argument to app.use(), app.METHOD(), and app.all().

    



Usage
Example





Single Middleware

            You can define and mount a middleware function locally.

            app.use((req, res, next) => {
  next()
})
            

            A router is valid middleware.

            const router = express.Router()
router.get('/', (req, res, next) => {
  next()
})
app.use(router)
            

            An Express app is valid middleware.

            const subApp = express()
subApp.get('/', (req, res, next) => {
  next()
})
app.use(subApp)
            

          



Series of Middleware

            You can specify more than one middleware function at the same mount path.

            const r1 = express.Router()
r1.get('/', (req, res, next) => {
  next()
})

const r2 = express.Router()
r2.get('/', (req, res, next) => {
  next()
})

app.use(r1, r2)
            

          



Array

            Use an array to group middleware logically.

            const r1 = express.Router()
r1.get('/', (req, res, next) => {
  next()
})

const r2 = express.Router()
r2.get('/', (req, res, next) => {
  next()
})

app.use([r1, r2])
            

          



Combination

            You can combine all the above ways of mounting middleware.

            function mw1 (req, res, next) { next() }
function mw2 (req, res, next) { next() }

const r1 = express.Router()
r1.get('/', (req, res, next) => { next() })

const r2 = express.Router()
r2.get('/', (req, res, next) => { next() })

const subApp = express()
subApp.get('/', (req, res, next) => { next() })

app.use(mw1, [mw2, r1, r2], subApp)
            

          






    Following are some examples of using the express.static
middleware in an Express app.

    Serve static content for the app from the “public” directory in the application directory:

    // GET /style.css etc
app.use(express.static(path.join(__dirname, 'public')))
    

    Mount the middleware at “/static” to serve static content only when their request path is prefixed with “/static”:

    // GET /static/style.css etc.
app.use('/static', express.static(path.join(__dirname, 'public')))
    

    Disable logging for static content requests by loading the logger middleware after the static middleware:

    app.use(express.static(path.join(__dirname, 'public')))
app.use(logger())
    

    Serve static files from multiple directories, but give precedence to “./public” over the others:

    app.use(express.static(path.join(__dirname, 'public')))
app.use(express.static(path.join(__dirname, 'files')))
app.use(express.static(path.join(__dirname, 'uploads')))
    

  

  Request

  The req object represents the HTTP request and has properties for the
request query string, parameters, body, HTTP headers, and so on. In this documentation and by convention,
the object is always referred to as req (and the HTTP response is res) but its actual name is determined
by the parameters to the callback function in which you’re working.

  For example:

  app.get('/user/:id', (req, res) => {
  res.send(`user ${req.params.id}`)
})
  

  But you could just as well have:

  app.get('/user/:id', (request, response) => {
  response.send(`user ${request.params.id}`)
})
  

  The req object is an enhanced version of Node’s own request object
and supports all built-in fields and methods.

  Properties

  
    In Express 4, req.files is no longer available on the req object by default. To access uploaded files
on the req.files object, use multipart-handling middleware like busboy, multer,
formidable,
multiparty,
connect-multiparty,
or pez.
  

  
    req.app

    This property holds a reference to the instance of the Express application that is using the middleware.

    If you follow the pattern in which you create a module that just exports a middleware function
and require() it in your main file, then the middleware can access the Express instance via req.app

    For example:

    // index.js
app.get('/viewdirectory', require('./mymiddleware.js'))
    

    // mymiddleware.js
module.exports = (req, res) => {
  res.send(`The views directory is ${req.app.get('views')}`)
}
    

  

  
    req.baseUrl

    The URL path on which a router instance was mounted.

    The req.baseUrl property is similar to the mountpath property of the app object,
except app.mountpath returns the matched path pattern(s).

    For example:

    const greet = express.Router()

greet.get('/jp', (req, res) => {
  console.log(req.baseUrl) // /greet
  res.send('Konichiwa!')
})

app.use('/greet', greet) // load the router on '/greet'
    

    Even if you use a path pattern or a set of path patterns to load the router,
the baseUrl property returns the matched string, not the pattern(s). In the
following example, the greet router is loaded on two path patterns.

    app.use(['/gre:"param"t', '/hel{l}o'], greet) // load the router on '/gre:"param"t' and '/hel{l}o'
    

    When a request is made to /greet/jp, req.baseUrl is “/greet”. When a request is
made to /hello/jp, req.baseUrl is “/hello”.

  

  
    req.body

    Contains key-value pairs of data submitted in the request body.
By default, it is undefined, and is populated when you use body-parsing middleware such
as express.json() or express.urlencoded().

    
      As req.body’s shape is based on user-controlled input, all properties and values in this object are untrusted and should be validated before trusting. For example, req.body.foo.toString() may fail in multiple ways, for example foo may not be there or may not be a string, and toString may not be a function and instead a string or other user-input.
    

    The following example shows how to use body-parsing middleware to populate req.body.

    const express = require('express')

const app = express()

app.use(express.json()) // for parsing application/json
app.use(express.urlencoded({ extended: true })) // for parsing application/x-www-form-urlencoded

app.post('/profile', (req, res, next) => {
  console.log(req.body)
  res.json(req.body)
})
    

  

  
    req.cookies

    When using cookie-parser middleware, this property is an object that
contains cookies sent by the request. If the request contains no cookies, it defaults to {}.

    // Cookie: name=tj
console.dir(req.cookies.name)
// => "tj"
    

    If the cookie has been signed, you have to use req.signedCookies.

    For more information, issues, or concerns, see cookie-parser.

  

  
    req.fresh

    When the response is still “fresh” in the client’s cache true is returned, otherwise false is returned to indicate that the client cache is now stale and the full response should be sent.

    When a client sends the Cache-Control: no-cache request header to indicate an end-to-end reload request, this module will return false to make handling these requests transparent.

    Further details for how cache validation works can be found in the
HTTP/1.1 Caching Specification.

    console.dir(req.fresh)
// => true
    

  

  
    req.host

    Contains the host derived from the Host HTTP header.

    When the trust proxy setting
does not evaluate to false, this property will instead get the value
from the X-Forwarded-Host header field. This header can be set by
the client or by the proxy.

    If there is more than one X-Forwarded-Host header in the request, the
value of the first header is used. This includes a single header with
comma-separated values, in which the first value is used.

    // Host: "example.com:3000"
console.dir(req.host)
// => 'example.com:3000'

// Host: "[::1]:3000"
console.dir(req.host)
// => '[::1]:3000'
    

  

  
    req.hostname

    Contains the hostname derived from the Host HTTP header.

    When the trust proxy setting
does not evaluate to false, this property will instead get the value
from the X-Forwarded-Host header field. This header can be set by
the client or by the proxy.

    If there is more than one X-Forwarded-Host header in the request, the
value of the first header is used. This includes a single header with
comma-separated values, in which the first value is used.

    
      Prior to Express v4.17.0, the X-Forwarded-Host could not contain multiple
values or be present more than once.
    

    // Host: "example.com:3000"
console.dir(req.hostname)
// => 'example.com'
    

  

  
    req.ip

    Contains the remote IP address of the request.

    When the trust proxy setting does not evaluate to false,
the value of this property is derived from the left-most entry in the
X-Forwarded-For header. This header can be set by the client or by the proxy.

    console.dir(req.ip)
// => "127.0.0.1"
    

  

  
    req.ips

    When the trust proxy setting does not evaluate to false,
this property contains an array of IP addresses
specified in the X-Forwarded-For request header. Otherwise, it contains an
empty array. This header can be set by the client or by the proxy.

    For example, if X-Forwarded-For is client, proxy1, proxy2, req.ips would be
["client", "proxy1", "proxy2"], where proxy2 is the furthest downstream.

  

  
    req.method

    Contains a string corresponding to the HTTP method of the request:
GET, POST, PUT, and so on.

  

  
    req.originalUrl

    
      req.url is not a native Express property, it is inherited from Node’s http module.
    

    This property is much like req.url; however, it retains the original request URL,
allowing you to rewrite req.url freely for internal routing purposes. For example,
the “mounting” feature of app.use() will rewrite req.url to strip the mount point.

    // GET /search?q=something
console.dir(req.originalUrl)
// => "/search?q=something"
    

    req.originalUrl is available both in middleware and router objects, and is a
combination of req.baseUrl and req.url. Consider following example:

    // GET 'http://www.example.com/admin/new?sort=desc'
app.use('/admin', (req, res, next) => {
  console.dir(req.originalUrl) // '/admin/new?sort=desc'
  console.dir(req.baseUrl) // '/admin'
  console.dir(req.path) // '/new'
  next()
})
    

  

  
    req.params

    This property is an object containing properties mapped to the named route “parameters”. For example, if you have the route /user/:name, then the “name” property is available as req.params.name. This object defaults to {}.

    // GET /user/tj
console.dir(req.params.name)
// => "tj"
    

    When you use a regular expression for the route definition, capture groups are provided in the array using req.params[n], where n is the nth capture group.

    app.use(/^\/file\/(.*)$/, (req, res) => {
  // GET /file/javascripts/jquery.js
  console.dir(req.params[0])
  // => "javascripts/jquery.js"
})
    

    If you need to make changes to a key in req.params, use the app.param handler. Changes are applicable only to parameters already defined in the route path.

    Any changes made to the req.params object in a middleware or route handler will be reset.

    
       Note
      Express automatically decodes the values in req.params (using decodeURIComponent).
    

  

  
    req.path

    Contains the path part of the request URL.

    // example.com/users?sort=desc
console.dir(req.path)
// => "/users"
    

    
      When called from a middleware, the mount point is not included in req.path. See app.use() for more details.
    

  

  
    req.protocol

    Contains the request protocol string: either http or (for TLS requests) https.

    When the trust proxy setting does not evaluate to false,
this property will use the value of the X-Forwarded-Proto header field if present.
This header can be set by the client or by the proxy.

    console.dir(req.protocol)
// => "http"
    

  

  
    req.query

    This property is an object containing a property for each query string parameter in the route.
When query parser is set to disabled, it is an empty object {}, otherwise it is the result of the configured query parser.

    
      As req.query’s shape is based on user-controlled input, all properties and values in this object are untrusted and should be validated before trusting. For example, req.query.foo.toString() may fail in multiple ways, for example foo may not be there or may not be a string, and toString may not be a function and instead a string or other user-input.
    

    The value of this property can be configured with the query parser application setting to work how your application needs it. A very popular query string parser is the qs module, and this is used by default. The qs module is very configurable with many settings, and it may be desirable to use different settings than the default to populate req.query:

    const qs = require('qs')
app.set('query parser',
  (str) => qs.parse(str, { /* custom options */ }))
    

    Check out the query parser application setting documentation for other customization options.

  

  
    req.res

    This property holds a reference to the response object
that relates to this request object.

  

  
    req.route

    Contains the currently-matched route, a string. For example:

    app.get('/user/{:id}', (req, res) => {
  console.dir(req.route, { depth: null })
  res.send('GET')
})
    

    Example output from the previous snippet:

    Route {
  path: '/user/{:id}',
  stack: [
    Layer {
      handle: [Function (anonymous)],
      keys: [],
      name: '<anonymous>',
      params: undefined,
      path: undefined,
      slash: false,
      matchers: [ [Function: match] ],
      method: 'get'
    }
  ],
  methods: [Object: null prototype] { get: true }
}
    

  

  
    req.secure

    A Boolean property that is true if a TLS connection is established. Equivalent to the following:

    
    req.protocol === 'https'
    

  

  
    req.signedCookies

    When using cookie-parser middleware, this property
contains signed cookies sent by the request, unsigned and ready for use. Signed cookies reside
in a different object to show developer intent; otherwise, a malicious attack could be placed on
req.cookie values (which are easy to spoof). Note that signing a cookie does not make it “hidden”
or encrypted; but simply prevents tampering (because the secret used to sign is private).

    If no signed cookies are sent, the property defaults to {}.

    // Cookie: user=tobi.CP7AWaXDfAKIRfH49dQzKJx7sKzzSoPq7/AcBBRVwlI3
console.dir(req.signedCookies.user)
// => "tobi"
    

    For more information, issues, or concerns, see cookie-parser.

  

  
    req.stale

    Indicates whether the request is “stale,” and is the opposite of req.fresh.
For more information, see req.fresh.

    console.dir(req.stale)
// => true
    

  

  
    req.subdomains

    An array of subdomains in the domain name of the request.

    // Host: "tobi.ferrets.example.com"
console.dir(req.subdomains)
// => ["ferrets", "tobi"]
    

    The application property subdomain offset, which defaults to 2, is used for determining the
beginning of the subdomain segments. To change this behavior, change its value
using app.set.

  

  
    req.xhr

    A Boolean property that is true if the request’s X-Requested-With header field is
“XMLHttpRequest”, indicating that the request was issued by a client library such as jQuery.

    console.dir(req.xhr)
// => true
    

  

  Methods

  
    req.accepts(types)

    Checks if the specified content types are acceptable, based on the request’s Accept HTTP header field.
The method returns the best match, or if none of the specified content types is acceptable, returns
false (in which case, the application should respond with 406 "Not Acceptable").

    The type value may be a single MIME type string (such as “application/json”),
an extension name such as “json”, a comma-delimited list, or an array. For a
list or array, the method returns the best match (if any).

    // Accept: text/html
req.accepts('html')
// => "html"

// Accept: text/*, application/json
req.accepts('html')
// => "html"
req.accepts('text/html')
// => "text/html"
req.accepts(['json', 'text'])
// => "json"
req.accepts('application/json')
// => "application/json"

// Accept: text/*, application/json
req.accepts('image/png')
req.accepts('png')
// => false

// Accept: text/*;q=.5, application/json
req.accepts(['html', 'json'])
// => "json"
    

    For more information, or if you have issues or concerns, see accepts.

  

  
    req.acceptsCharsets(charset [, ...])

    Returns the first accepted charset of the specified character sets,
based on the request’s Accept-Charset HTTP header field.
If none of the specified charsets is accepted, returns false.

    For more information, or if you have issues or concerns, see accepts.

  

  
    req.acceptsEncodings(encoding [, ...])

    Returns the first accepted encoding of the specified encodings,
based on the request’s Accept-Encoding HTTP header field.
If none of the specified encodings is accepted, returns false.

    For more information, or if you have issues or concerns, see accepts.

  

  
    req.acceptsLanguages([lang, ...])

    Returns the first accepted language of the specified languages,
based on the request’s Accept-Language HTTP header field.
If none of the specified languages is accepted, returns false.

    If no lang argument is given, then req.acceptsLanguages()
returns all languages from the HTTP Accept-Language header
as an Array.

    For more information, or if you have issues or concerns, see accepts.

    Express (5.x) source: request.js line 172

    Accepts (2.0) source: index.js line 195

  

  
    req.get(field)

    Returns the specified HTTP request header field (case-insensitive match).
The Referrer and Referer fields are interchangeable.

    req.get('Content-Type')
// => "text/plain"

req.get('content-type')
// => "text/plain"

req.get('Something')
// => undefined
    

    Aliased as req.header(field).

  

  
    req.is(type)

    Returns the matching content type if the incoming request’s “Content-Type” HTTP header field
matches the MIME type specified by the type parameter. If the request has no body, returns null.
Returns false otherwise.

    // With Content-Type: text/html; charset=utf-8
req.is('html') // => 'html'
req.is('text/html') // => 'text/html'
req.is('text/*') // => 'text/*'

// When Content-Type is application/json
req.is('json') // => 'json'
req.is('application/json') // => 'application/json'
req.is('application/*') // => 'application/*'

req.is('html')
// => false
    

    For more information, or if you have issues or concerns, see type-is.

  

  
    req.range(size[, options])

    Range header parser.

    The size parameter is the maximum size of the resource.

    The options parameter is an object that can have the following properties.

    
      
        
          Property
          Type
          Description
        
      
      
        
          combine
          Boolean
          Specify if overlapping & adjacent ranges should be combined, defaults to false. When true, ranges will be combined and returned as if they were specified that way in the header.
        
      
    

    An array of ranges will be returned or negative numbers indicating an error parsing.

    
      -2 signals a malformed header string
      -1 signals an unsatisfiable range
    

    // parse header from request
const range = req.range(1000)

// the type of the range
if (range.type === 'bytes') {
  // the ranges
  range.forEach((r) => {
    // do something with r.start and r.end
  })
}
    

  

  Response

  The res object represents the HTTP response that an Express app sends when it gets an HTTP request.

  In this documentation and by convention,
the object is always referred to as res (and the HTTP request is req) but its actual name is determined
by the parameters to the callback function in which you’re working.

  For example:

  app.get('/user/:id', (req, res) => {
  res.send(`user ${req.params.id}`)
})
  

  But you could just as well have:

  app.get('/user/:id', (request, response) => {
  response.send(`user ${request.params.id}`)
})
  

  The res object is an enhanced version of Node’s own response object
and supports all built-in fields and methods.

  Properties

  
    res.app

    This property holds a reference to the instance of the Express application that is using the middleware.

    res.app is identical to the req.app property in the request object.

  

  
    res.headersSent

    Boolean property that indicates if the app sent HTTP headers for the response.

    app.get('/', (req, res) => {
  console.log(res.headersSent) // false
  res.send('OK')
  console.log(res.headersSent) // true
})
    

  

  
    res.locals

    Use this property to set variables accessible in templates rendered with res.render.
The variables set on res.locals are available within a single request-response cycle, and will not
be shared between requests.

    
      The locals object is used by view engines to render a response. The object
keys may be particularly sensitive and should not contain user-controlled
input, as it may affect the operation of the view engine or provide a path to
cross-site scripting. Consult the documentation for the used view engine for
additional considerations.
    

    In order to keep local variables for use in template rendering between requests, use
app.locals instead.

    This property is useful for exposing request-level information such as the request path name,
authenticated user, user settings, and so on to templates rendered within the application.

    app.use((req, res, next) => {
  // Make `user` and `authenticated` available in templates
  res.locals.user = req.user
  res.locals.authenticated = !req.user.anonymous
  next()
})
    

  

  
    res.req

    This property holds a reference to the request object
that relates to this response object.

  

  Methods

  
    res.append(field [, value])

    
      res.append() is supported by Express v4.11.0+
    

    Appends the specified value to the HTTP response header field.  If the header is not already set,
it creates the header with the specified value. The value parameter can be a string or an array.

    
       Note
      calling res.set() after res.append() will reset the previously-set header value.
    

    res.append('Link', ['<http://localhost/>', '<http://localhost:3000/>'])
res.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly')
res.append('Warning', '199 Miscellaneous warning')
    

  

  
    res.attachment([filename])

    Sets the HTTP response Content-Disposition header field to “attachment”. If a filename is given,
then it sets the Content-Type based on the extension name via res.type(),
and sets the Content-Disposition “filename=” parameter.

    res.attachment()
// Content-Disposition: attachment

res.attachment('path/to/logo.png')
// Content-Disposition: attachment; filename="logo.png"
// Content-Type: image/png
    

  

  
    res.cookie(name, value [, options])

    Sets cookie name to value.  The value parameter may be a string or object converted to JSON.

    The options parameter is an object that can have the following properties.

    
      
        
          Property
          Type
          Description
        
      
      
        
          domain
          String
          Domain name for the cookie. Defaults to the domain name of the app.
        
        
          encode
          Function
          A synchronous function used for cookie value encoding. Defaults to encodeURIComponent.
        
        
          expires
          Date
          Expiry date of the cookie in GMT. If not specified or set to 0, creates a session cookie.
        
        
          httpOnly
          Boolean
          Flags the cookie to be accessible only by the web server.
        
        
          maxAge
          Number
          Convenient option for setting the expiry time relative to the current time in milliseconds.
        
        
          path
          String
          Path for the cookie. Defaults to “/”.
        
        
          partitioned
          Boolean
          Indicates that the cookie should be stored using partitioned storage. See Cookies Having Independent Partitioned State (CHIPS) for more details.
        
        
          priority
          String
          Value of the “Priority” Set-Cookie attribute.
        
        
          secure
          Boolean
          Marks the cookie to be used with HTTPS only.
        
        
          signed
          Boolean
          Indicates if the cookie should be signed.
        
        
          sameSite
          Boolean or String
          Value of the “SameSite” Set-Cookie attribute. More information at https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00#section-4.1.1.
        
      
    

    
      All res.cookie() does is set the HTTP Set-Cookie header with the options provided.
Any option not specified defaults to the value stated in RFC 6265.
    

    For example:

    res.cookie('name', 'tobi', { domain: '.example.com', path: '/admin', secure: true })
res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true })
    

    You can set multiple cookies in a single response by calling res.cookie multiple times, for example:

    res
  .status(201)
  .cookie('access_token', `Bearer ${token}`, {
    expires: new Date(Date.now() + 8 * 3600000) // cookie will be removed after 8 hours
  })
  .cookie('test', 'test')
  .redirect(301, '/admin')
    

    The encode option allows you to choose the function used for cookie value encoding.
Does not support asynchronous functions.

    Example use case: You need to set a domain-wide cookie for another site in your organization.
This other site (not under your administrative control) does not use URI-encoded cookie values.

    // Default encoding
res.cookie('some_cross_domain_cookie', 'http://mysubdomain.example.com', { domain: 'example.com' })
// Result: 'some_cross_domain_cookie=http%3A%2F%2Fmysubdomain.example.com; Domain=example.com; Path=/'

// Custom encoding
res.cookie('some_cross_domain_cookie', 'http://mysubdomain.example.com', { domain: 'example.com', encode: String })
// Result: 'some_cross_domain_cookie=http://mysubdomain.example.com; Domain=example.com; Path=/;'
    

    The maxAge option is a convenience option for setting “expires” relative to the current time in milliseconds.
The following is equivalent to the second example above.

    res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })
    

    You can pass an object as the value parameter; it is then serialized as JSON and parsed by bodyParser() middleware.

    res.cookie('cart', { items: [1, 2, 3] })
res.cookie('cart', { items: [1, 2, 3] }, { maxAge: 900000 })
    

    When using cookie-parser middleware, this method also
supports signed cookies. Simply include the signed option set to true.
Then, res.cookie() will use the secret passed to cookieParser(secret) to sign the value.

    res.cookie('name', 'tobi', { signed: true })
    

    Later, you may access this value through the req.signedCookies object.

  

  
    res.clearCookie(name [, options])

    Clears the cookie specified by name. For details about the options object, see res.cookie().

    
      Web browsers and other compliant clients will only clear the cookie if the given
options is identical to those given to res.cookie(), excluding
expires and maxAge.
    

    res.cookie('name', 'tobi', { path: '/admin' })
res.clearCookie('name', { path: '/admin' })
    

  

  
    res.download(path [, filename] [, options] [, fn])

    
      The optional options argument is supported by Express v4.16.0 onwards.
    

    Transfers the file at path as an “attachment”. Typically, browsers will prompt the user for download.
By default, the Content-Disposition header “filename=” parameter is derived from the path argument, but can be overridden with the filename parameter.
If path is relative, then it will be based on the current working directory of the process or
the root option, if provided.

    
      This API provides access to data on the running file system. Ensure that either (a) the way in
which the path argument was constructed is secure if it contains user input or (b) set the root
option to the absolute path of a directory to contain access within.

      When the root option is provided, Express will validate that the relative path provided as
path will resolve within the given root option.
    

    The following table provides details on the options parameter.

    
      The optional options argument is supported by Express v4.16.0 onwards.
    

    

      
        
          
            Property
            Description
            Default
            Availability
          
        
        
          
            maxAge
            Sets the max-age property of the Cache-Control header in milliseconds or a string in ms format
            0
            4.16+
          
          
            root
            Root directory for relative filenames.
             
            4.18+
          
          
            lastModified
            Sets the Last-Modified header to the last modified date of the file on the OS. Set false to disable it.
            Enabled
            4.16+
          
          
            headers
            Object containing HTTP headers to serve with the file. The header Content-Disposition will be overridden by the filename argument.
             
            4.16+
          
          
            dotfiles
            Option for serving dotfiles. Possible values are “allow”, “deny”, “ignore”.
            “ignore”
            4.16+
          
          
            acceptRanges
            Enable or disable accepting ranged requests.
            true
            4.16+
          
          
            cacheControl
            Enable or disable setting Cache-Control response header.
            true
            4.16+
          
          
            immutable
            Enable or disable the immutable directive in the Cache-Control response header. If enabled, the maxAge option should also be specified to enable caching. The immutable directive will prevent supported clients from making conditional requests during the life of the maxAge option to check if the file has changed.
            false
            4.16+
          
        
      

    

    The method invokes the callback function fn(err) when the transfer is complete
or when an error occurs. If the callback function is specified and an error occurs,
the callback function must explicitly handle the response process either by
ending the request-response cycle, or by passing control to the next route.

    res.download('/report-12345.pdf')

res.download('/report-12345.pdf', 'report.pdf')

res.download('/report-12345.pdf', 'report.pdf', (err) => {
  if (err) {
    // Handle error, but keep in mind the response may be partially-sent
    // so check res.headersSent
  } else {
    // decrement a download credit, etc.
  }
})
    

  

  
    res.end([data[, encoding]][, callback])

    Ends the response process. This method actually comes from Node core, specifically the response.end() method of http.ServerResponse.

    Use to quickly end the response without any data. If you need to respond with data, instead use methods such as res.send() and res.json().

    res.end()
res.status(404).end()
    

  

  
    res.format(object)

    Performs content-negotiation on the Accept HTTP header on the request object, when present.
It uses req.accepts() to select a handler for the request, based on the acceptable
types ordered by their quality values. If the header is not specified, the first callback is invoked.
When no match is found, the server responds with 406 “Not Acceptable”, or invokes the default callback.

    The Content-Type response header is set when a callback is selected. However, you may alter
this within the callback using methods such as res.set() or res.type().

    The following example would respond with { "message": "hey" } when the Accept header field is set
to “application/json” or “*/json” (however, if it is “*/*”, then the response will be “hey”).

    res.format({
  'text/plain' () {
    res.send('hey')
  },

  'text/html' () {
    res.send('<p>hey</p>')
  },

  'application/json' () {
    res.send({ message: 'hey' })
  },

  default () {
    // log the request and respond with 406
    res.status(406).send('Not Acceptable')
  }
})
    

    In addition to canonicalized MIME types, you may also use extension names mapped
to these types for a slightly less verbose implementation:

    res.format({
  text () {
    res.send('hey')
  },

  html () {
    res.send('<p>hey</p>')
  },

  json () {
    res.send({ message: 'hey' })
  }
})
    

  

  
    res.get(field)

    Returns the HTTP response header specified by field.
The match is case-insensitive.

    res.get('Content-Type')
// => "text/plain"
    

  

  
    res.json([body])

    Sends a JSON response. This method sends a response (with the correct content-type) that is the parameter converted to a 
JSON string using JSON.stringify().

    The parameter can be any JSON type, including object, array, string, Boolean, number, or null,
and you can also use it to convert other values to JSON.

    res.json(null)
res.json({ user: 'tobi' })
res.status(500).json({ error: 'message' })
    

  

  
    res.jsonp([body])

    Sends a JSON response with JSONP support. This method is identical to res.json(),
except that it opts-in to JSONP callback support.

    res.jsonp(null)
// => callback(null)

res.jsonp({ user: 'tobi' })
// => callback({ "user": "tobi" })

res.status(500).jsonp({ error: 'message' })
// => callback({ "error": "message" })
    

    By default, the JSONP callback name is simply callback. Override this with the
jsonp callback name setting.

    The following are some examples of JSONP responses using the same code:

    // ?callback=foo
res.jsonp({ user: 'tobi' })
// => foo({ "user": "tobi" })

app.set('jsonp callback name', 'cb')

// ?cb=foo
res.status(500).jsonp({ error: 'message' })
// => foo({ "error": "message" })
    

  

  
    res.links(links)

    Joins the links provided as properties of the parameter to populate the response’s
Link HTTP header field.

    For example, the following call:

    res.links({
  next: 'http://api.example.com/users?page=2',
  last: 'http://api.example.com/users?page=5'
})
    

    Yields the following results:

    Link: <http://api.example.com/users?page=2>; rel="next",
      <http://api.example.com/users?page=5>; rel="last"
    

  

  
    res.location(path)

    Sets the response Location HTTP header to the specified path parameter.

    res.location('/foo/bar')
res.location('http://example.com')
    

    
      After encoding the URL, if not encoded already, Express passes the specified URL to the browser in the Location header,
without any validation.

      Browsers take the responsibility of deriving the intended URL from the current URL
or the referring URL, and the URL specified in the Location header; and redirect the user accordingly.
    

  

  
    res.redirect([status,] path)

    Redirects to the URL derived from the specified path, with specified status, a positive integer
that corresponds to an HTTP status code.
If not specified, status defaults to 302 "Found".

    res.redirect('/foo/bar')
res.redirect('http://example.com')
res.redirect(301, 'http://example.com')
res.redirect('../login')
    
    Redirects can be a fully-qualified URL for redirecting to a different site:

    res.redirect('http://google.com')
    
    Redirects can be relative to the root of the host name. For example, if the
application is on http://example.com/admin/post/new, the following
would redirect to the URL http://example.com/admin:

    res.redirect('/admin')
    

    Redirects can be relative to the current URL. For example,
from http://example.com/blog/admin/ (notice the trailing slash), the following
would redirect to the URL http://example.com/blog/admin/post/new.

    res.redirect('post/new')
    

    Redirecting to post/new from http://example.com/blog/admin (no trailing slash),
will redirect to http://example.com/blog/post/new.

    If you found the above behavior confusing, think of path segments as directories
(with trailing slashes) and files, it will start to make sense.

    Path-relative redirects are also possible. If you were on
http://example.com/admin/post/new, the following would redirect to
http://example.com/admin/post:

    res.redirect('..')
    

    See also Security best practices: Prevent open redirect 
vulnerabilities.
  

  
    res.render(view [, locals] [, callback])

    Renders a view and sends the rendered HTML string to the client.
Optional parameters:

    
      locals, an object whose properties define local variables for the view.
      callback, a callback function. If provided, the method returns both the possible error and rendered string, but does not perform an automated response. When an error occurs, the method invokes next(err) internally.
    

    The view argument is a string that is the file path of the view file to render. This can be an absolute path, or a path relative to the views setting. If the path does not contain a file extension, then the view engine setting determines the file extension. If the path does contain a file extension, then Express will load the module for the specified template engine (via require()) and render it using the loaded module’s __express function.

    For more information, see Using template engines with Express.

    
       Warning
      The view argument performs file system operations like reading a file from disk and evaluating Node.js modules, and as so for security reasons should not contain input from the end-user.
    

    
       Warning
      The locals object is used by view engines to render a response. The object
keys may be particularly sensitive and should not contain user-controlled
input, as it may affect the operation of the view engine or provide a path to
cross-site scripting. Consult the documentation for the used view engine for
additional considerations.
    

    
       Caution
      The local variable cache enables view caching. Set it to true,
to cache the view during development; view caching is enabled in production by default.
    

    // send the rendered view to the client
res.render('index')

// if a callback is specified, the rendered HTML string has to be sent explicitly
res.render('index', (err, html) => {
  res.send(html)
})

// pass a local variable to the view
res.render('user', { name: 'Tobi' }, (err, html) => {
  // ...
})
    

  

  
    res.send([body])

    Sends the HTTP response.

    The body parameter can be a Buffer object, a String, an object, Boolean, or an Array.
For example:

    res.send(Buffer.from('whoop'))
res.send({ some: 'json' })
res.send('<p>some html</p>')
res.status(404).send('Sorry, we cannot find that!')
res.status(500).send({ error: 'something blew up' })
    

    This method performs many useful tasks for simple non-streaming responses:
For example, it automatically assigns the Content-Length HTTP response header field 
and provides automatic HEAD and HTTP cache freshness support.

    When the parameter is a Buffer object, the method sets the Content-Type
response header field to “application/octet-stream”, unless previously defined as shown below:

    res.set('Content-Type', 'text/html')
res.send(Buffer.from('<p>some html</p>'))
    

    When the parameter is a String, the method sets the Content-Type to “text/html”:

    res.send('<p>some html</p>')
    

    When the parameter is an Array or Object, Express responds with the JSON representation:

    res.send({ user: 'tobi' })
res.send([1, 2, 3])
    

  

  
    res.sendFile(path [, options] [, fn])

    
      res.sendFile() is supported by Express v4.8.0 onwards.
    

    Transfers the file at the given path. Sets the Content-Type response HTTP header field
based on the filename’s extension. Unless the root option is set in
the options object, path must be an absolute path to the file.

    
      This API provides access to data on the running file system. Ensure that either (a) the way in
which the path argument was constructed into an absolute path is secure if it contains user
input or (b) set the root option to the absolute path of a directory to contain access within.

      When the root option is provided, the path argument is allowed to be a relative path,
including containing ... Express will validate that the relative path provided as path will
resolve within the given root option.
    

    The following table provides details on the options parameter.

    

      
        
          
            Property
            Description
            Default
            Availability
          
        
        
          
            maxAge
            Sets the max-age property of the Cache-Control header in milliseconds or a string in ms format
            0
             
          
          
            root
            Root directory for relative filenames.
             
             
          
          
            lastModified
            Sets the Last-Modified header to the last modified date of the file on the OS. Set false to disable it.
            Enabled
            4.9.0+
          
          
            headers
            Object containing HTTP headers to serve with the file.
             
             
          
          
            dotfiles
            Option for serving dotfiles. Possible values are “allow”, “deny”, “ignore”.
            “ignore”
             
          
          
            acceptRanges
            Enable or disable accepting ranged requests.
            true
            4.14+
          
          
            cacheControl
            Enable or disable setting Cache-Control response header.
            true
            4.14+
          
          
            immutable
            Enable or disable the immutable directive in the Cache-Control response header. If enabled, the maxAge option should also be specified to enable caching. The immutable directive will prevent supported clients from making conditional requests during the life of the maxAge option to check if the file has changed.
            false
            4.16+
          
        
      

    

    The method invokes the callback function fn(err) when the transfer is complete
or when an error occurs. If the callback function is specified and an error occurs,
the callback function must explicitly handle the response process either by
ending the request-response cycle, or by passing control to the next route.

    Here is an example of using res.sendFile with all its arguments.

    app.get('/file/:name', (req, res, next) => {
  const options = {
    root: path.join(__dirname, 'public'),
    dotfiles: 'deny',
    headers: {
      'x-timestamp': Date.now(),
      'x-sent': true
    }
  }

  const fileName = req.params.name
  res.sendFile(fileName, options, (err) => {
    if (err) {
      next(err)
    } else {
      console.log('Sent:', fileName)
    }
  })
})
    

    The following example illustrates using
res.sendFile to provide fine-grained support for serving files:

    app.get('/user/:uid/photos/:file', (req, res) => {
  const uid = req.params.uid
  const file = req.params.file

  req.user.mayViewFilesFrom(uid, (yes) => {
    if (yes) {
      res.sendFile(`/uploads/${uid}/${file}`)
    } else {
      res.status(403).send("Sorry! You can't see that.")
    }
  })
})
    
    For more information, or if you have issues or concerns, see send.

  

  
    res.sendStatus(statusCode)

    Sets the response HTTP status code to statusCode and sends the registered status message as the text response body. If an unknown status code is specified, the response body will just be the code number.

    res.sendStatus(404)
    

    
      Some versions of Node.js will throw when res.statusCode is set to an
invalid HTTP status code (outside of the range 100 to 599). Consult
the HTTP server documentation for the Node.js version being used.
    

    More about HTTP Status Codes

  

  
    res.set(field [, value])

    Sets the response’s HTTP header field to value.
To set multiple fields at once, pass an object as the parameter.

    res.set('Content-Type', 'text/plain')

res.set({
  'Content-Type': 'text/plain',
  'Content-Length': '123',
  ETag: '12345'
})
    

    Aliased as res.header(field [, value]).

  

  
    res.status(code)

    Sets the HTTP status for the response.
It is a chainable alias of Node’s response.statusCode.

    res.status(403).end()
res.status(400).send('Bad Request')
res.status(404).sendFile('/absolute/path/to/404.png')
    

  

  
    res.type(type)

    Sets the Content-Type HTTP header to the MIME type as determined by the specified type. If type contains the “/” character, then it sets the Content-Type to the exact value of type, otherwise it is assumed to be a file extension and the MIME type is looked up using the contentType() method of the mime-types package.

    res.type('.html') // => 'text/html'
res.type('html') // => 'text/html'
res.type('json') // => 'application/json'
res.type('application/json') // => 'application/json'
res.type('png') // => image/png:
    

    Aliased as res.contentType(type).

  

  
    res.vary(field)

    Adds the field to the Vary response header, if it is not there already.

    res.vary('User-Agent').render('docs')
    

  

  Router

  
    A router object is an instance of middleware and routes. You can think of it
as a “mini-application,” capable only of performing middleware and routing
functions. Every Express application has a built-in app router.

    A router behaves like middleware itself, so you can use it as an argument to
app.use() or as the argument to another router’s use() method.

    The top-level express object has a Router() method that creates a new router object.

    Once you’ve created a router object, you can add middleware and HTTP method routes (such as get, put, post,
and so on) to it just like an application. For example:

    // invoked for any requests passed to this router
router.use((req, res, next) => {
  // .. some logic here .. like any other middleware
  next()
})

// will handle any request that ends in /events
// depends on where the router is "use()'d"
router.get('/events', (req, res, next) => {
  // ..
})
    

    You can then use a router for a particular root URL in this way separating your routes into files or even mini-apps.

    // only requests to /calendar/* will be sent to our "router"
app.use('/calendar', router)
    

    Keep in mind that any middleware applied to a router will run for all requests on that router’s path, even those that aren’t part of the router.

  

  Methods

  
    router.all(path, [callback, ...] callback)

    This method is just like the router.METHOD() methods, except that it matches all HTTP methods (verbs).

    This method is extremely useful for
mapping “global” logic for specific path prefixes or arbitrary matches.
For example, if you placed the following route at the top of all other
route definitions, it would require that all routes from that point on
would require authentication, and automatically load a user. Keep in mind
that these callbacks do not have to act as end points; loadUser
can perform a task, then call next() to continue matching subsequent
routes.

    router.all('{*splat}', requireAuthentication, loadUser)
    

    Or the equivalent:

    router.all('{*splat}', requireAuthentication)
router.all('{*splat}', loadUser)
    

    Another example of this is white-listed “global” functionality. Here,
the example is much like before, but it only restricts paths prefixed with
“/api”:

    router.all('/api/{*splat}', requireAuthentication)
    

  

  
    router.METHOD(path, [callback, ...] callback)

    The router.METHOD() methods provide the routing functionality in Express,
where METHOD is one of the HTTP methods, such as GET, PUT, POST, and so on,
in lowercase. Thus, the actual methods are router.get(), router.post(),
router.put(), and so on.

    
      The router.get() function is automatically called for the HTTP HEAD method in
  addition to the GET method if router.head() was not called for the
  path before router.get().
    

    You can provide multiple callbacks, and all are treated equally, and behave just
like middleware, except that these callbacks may invoke next('route')
to bypass the remaining route callback(s). You can use this mechanism to perform
pre-conditions on a route then pass control to subsequent routes when there is no
reason to proceed with the route matched.

    The following snippet illustrates the most simple route definition possible.
Express translates the path strings to regular expressions, used internally
to match incoming requests. Query strings are not considered when performing
these matches, for example “GET /” would match the following route, as would
“GET /?name=tobi”.

    router.get('/', (req, res) => {
  res.send('hello world')
})
    

    You can also use regular expressions—useful if you have very specific
constraints, for example the following would match “GET /commits/71dbb9c” as well
as “GET /commits/71dbb9c..4c084f9”.

    router.get(/^\/commits\/(\w+)(?:\.\.(\w+))?$/, (req, res) => {
  const from = req.params[0]
  const to = req.params[1] || 'HEAD'
  res.send(`commit range ${from}..${to}`)
})
    

    You can use next primitive to implement a flow control between different
middleware functions, based on a specific program state. Invoking next with
the string 'router' will cause all the remaining route callbacks on that router
to be bypassed.

    The following example illustrates next('router') usage.

    function fn (req, res, next) {
  console.log('I come here')
  next('router')
}
router.get('/foo', fn, (req, res, next) => {
  console.log('I dont come here')
})
router.get('/foo', (req, res, next) => {
  console.log('I dont come here')
})
app.get('/foo', (req, res) => {
  console.log(' I come here too')
  res.end('good')
})
    

  

  
    router.param(name, callback)

    Adds callback triggers to route parameters, where name is the name of the parameter and callback is the callback function. Although name is technically optional, using this method without it is deprecated starting with Express v4.11.0 (see below).

    The parameters of the callback function are:

    
      req, the request object.
      res, the response object.
      next, indicating the next middleware function.
      The value of the name parameter.
      The name of the parameter.
    

    
      Unlike app.param(), router.param() does not accept an array of route parameters.
    

    For example, when :user is present in a route path, you may map user loading logic to automatically provide req.user to the route, or perform validations on the parameter input.

    router.param('user', (req, res, next, id) => {
  // try to get the user details from the User model and attach it to the request object
  User.find(id, (err, user) => {
    if (err) {
      next(err)
    } else if (user) {
      req.user = user
      next()
    } else {
      next(new Error('failed to load user'))
    }
  })
})
    

    Param callback functions are local to the router on which they are defined. They are not inherited by mounted apps or routers, nor are they triggered for route parameters inherited from parent routers. Hence, param callbacks defined on router will be triggered only by route parameters defined on router routes.

    A param callback will be called only once in a request-response cycle, even if the parameter is matched in multiple routes, as shown in the following examples.

    router.param('id', (req, res, next, id) => {
  console.log('CALLED ONLY ONCE')
  next()
})

router.get('/user/:id', (req, res, next) => {
  console.log('although this matches')
  next()
})

router.get('/user/:id', (req, res) => {
  console.log('and this matches too')
  res.end()
})
    

    On GET /user/42, the following is printed:

    CALLED ONLY ONCE
although this matches
and this matches too
    

  

  
    router.route(path)

    Returns an instance of a single route which you can then use to handle HTTP verbs
with optional middleware. Use router.route() to avoid duplicate route naming and
thus typing errors.

    Building on the router.param() example above, the following code shows how to use
router.route() to specify various HTTP method handlers.

    const router = express.Router()

router.param('user_id', (req, res, next, id) => {
  // sample user, would actually fetch from DB, etc...
  req.user = {
    id,
    name: 'TJ'
  }
  next()
})

router.route('/users/:user_id')
  .all((req, res, next) => {
  // runs for all HTTP verbs first
  // think of it as route specific middleware!
    next()
  })
  .get((req, res, next) => {
    res.json(req.user)
  })
  .put((req, res, next) => {
  // just an example of maybe updating the user
    req.user.name = req.params.name
    // save user ... etc
    res.json(req.user)
  })
  .post((req, res, next) => {
    next(new Error('not implemented'))
  })
  .delete((req, res, next) => {
    next(new Error('not implemented'))
  })
    

    This approach re-uses the single /users/:user_id path and adds handlers for
various HTTP methods.

    
       Note
      When you use router.route(), middleware ordering is based on when the route is created, not when method handlers are added to the route. For this purpose, you can consider method handlers to belong to the route to which they were added.
    

  

  
    router.use([path], [function, ...] function)

    Uses the specified middleware function or functions, with optional mount path path, that defaults to “/”.

    This method is similar to app.use(). A simple example and use case is described below.
See app.use() for more information.

    Middleware is like a plumbing pipe: requests start at the first middleware function defined
and work their way “down” the middleware stack processing for each path they match.

    const express = require('express')
const app = express()
const router = express.Router()

// simple logger for this router's requests
// all requests to this router will first hit this middleware
router.use((req, res, next) => {
  console.log('%s %s %s', req.method, req.url, req.path)
  next()
})

// this will only be invoked if the path starts with /bar from the mount point
router.use('/bar', (req, res, next) => {
  // ... maybe some additional /bar logging ...
  next()
})

// always invoked
router.use((req, res, next) => {
  res.send('Hello World')
})

app.use('/foo', router)

app.listen(3000)
    

    The “mount” path is stripped and is not visible to the middleware function.
The main effect of this feature is that a mounted middleware function may operate without
code changes regardless of its “prefix” pathname.

    The order in which you define middleware with router.use() is very important.
They are invoked sequentially, thus the order defines middleware precedence. For example,
usually a logger is the very first middleware you would use, so that every request gets logged.

    const logger = require('morgan')

router.use(logger())
router.use(express.static(path.join(__dirname, 'public')))
router.use((req, res) => {
  res.send('Hello')
})
    

    Now suppose you wanted to ignore logging requests for static files, but to continue
logging routes and middleware defined after logger().  You would simply move the call to express.static() to the top,
before adding the logger middleware:

    router.use(express.static(path.join(__dirname, 'public')))
router.use(logger())
router.use((req, res) => {
  res.send('Hello')
})
    

    Another example is serving files from multiple directories,
giving precedence to “./public” over the others:

    app.use(express.static(path.join(__dirname, 'public')))
app.use(express.static(path.join(__dirname, 'files')))
app.use(express.static(path.join(__dirname, 'uploads')))
    

    The router.use() method also supports named parameters so that your mount points
for other routers can benefit from preloading using named parameters.

    NOTE: Although these middleware functions are added via a particular router, when
they run is defined by the path they are attached to (not the router). Therefore,
middleware added via one router may run for other routers if its routes
match. For example, this code shows two different routers mounted on the same path:

    const authRouter = express.Router()
const openRouter = express.Router()

authRouter.use(require('./authenticate').basic(usersdb))

authRouter.get('/:user_id/edit', (req, res, next) => {
  // ... Edit user UI ...
})
openRouter.get('/', (req, res, next) => {
  // ... List users ...
})
openRouter.get('/:user_id', (req, res, next) => {
  // ... View user ...
})

app.use('/users', authRouter)
app.use('/users', openRouter)
    

    Even though the authentication middleware was added via the authRouter it will run on the routes defined by the openRouter as well since both routers were mounted on /users. To avoid this behavior, use different paths for each router.

  



              
    
    Edit this page\n\n\n\n4.x API

  
     Note

    Express 4.0 requires Node.js 0.10 or higher.
    

  

  express()

  Creates an Express application. The express() function is a top-level function exported by the express module.

  var express = require('express')
var app = express()
  

  Methods

  
    express.json([options])

    
      This middleware is available in Express v4.16.0 onwards.
    

    This is a built-in middleware function in Express. It parses incoming requests
with JSON payloads and is based on
body-parser.

    Returns middleware that only parses JSON and only looks at requests where
the Content-Type header matches the type option. This parser accepts any
Unicode encoding of the body and supports automatic inflation of gzip and
deflate encodings.

    A new body object containing the parsed data is populated on the request
object after the middleware (i.e. req.body), or an empty object ({}) if
there was no body to parse, the Content-Type was not matched, or an error
occurred.

    
      As req.body’s shape is based on user-controlled input, all properties and
values in this object are untrusted and should be validated before trusting.
For example, req.body.foo.toString() may fail in multiple ways, for example
foo may not be there or may not be a string, and toString may not be a
function and instead a string or other user-input.
    

    The following table describes the properties of the optional options object.

    
      
        
          Property
          Description
          Type
          Default
        
      
      
        
          inflate
          Enables or disables handling deflated (compressed) bodies; when disabled, deflated bodies are rejected.
          Boolean
          true
        
        
          limit
          Controls the maximum request body size. If this is a number, then the value specifies the number of bytes; if it is a string, the value is passed to the bytes library for parsing.
          Mixed
          "100kb"
        
        
          reviver
          The reviver option is passed directly to JSON.parse as the second argument. You can find more information on this argument in the MDN documentation about JSON.parse.
          Function
          null
        
        
          strict
          Enables or disables only accepting arrays and objects; when disabled will accept anything JSON.parse accepts.
          Boolean
          true
        
        
          type
          This is used to determine what media type the middleware will parse. This option can be a string, array of strings, or a function. If not a function, type option is passed directly to the type-is library and this can be an extension name (like json), a mime type (like application/json), or a mime type with a wildcard (like */* or */json). If a function, the type option is called as fn(req) and the request is parsed if it returns a truthy value.
          Mixed
          "application/json"
        
        
          verify
          This option, if supplied, is called as verify(req, res, buf, encoding), where buf is a Buffer of the raw request body and encoding is the encoding of the request. The parsing can be aborted by throwing an error.
          Function
          undefined
        
      
    

  

  
    express.raw([options])

    
      This middleware is available in Express v4.17.0 onwards.
    

    This is a built-in middleware function in Express. It parses incoming request
payloads into a Buffer and is based on
body-parser.

    Returns middleware that parses all bodies as a Buffer and only looks at requests
where the Content-Type header matches the type option. This parser accepts
any Unicode encoding of the body and supports automatic inflation of gzip and
deflate encodings.

    A new body Buffer containing the parsed data is populated on the request
object after the middleware (i.e. req.body), or an empty object ({}) if
there was no body to parse, the Content-Type was not matched, or an error
occurred.

    
      As req.body’s shape is based on user-controlled input, all properties and
values in this object are untrusted and should be validated before trusting.
For example, req.body.toString() may fail in multiple ways, for example
stacking multiple parsers req.body may be from a different parser. Testing
that req.body is a Buffer before calling buffer methods is recommended.
    

    The following table describes the properties of the optional options object.

    
      
        
          Property
          Description
          Type
          Default
        
      
      
        
          inflate
          Enables or disables handling deflated (compressed) bodies; when disabled, deflated bodies are rejected.
          Boolean
          true
        
        
          limit
          Controls the maximum request body size. If this is a number, then the value specifies the number of bytes; if it is a string, the value is passed to the bytes library for parsing.
          Mixed
          "100kb"
        
        
          type
          This is used to determine what media type the middleware will parse. This option can be a string, array of strings, or a function. If not a function, type option is passed directly to the type-is library and this can be an extension name (like bin), a mime type (like application/octet-stream), or a mime type with a wildcard (like */* or application/*). If a function, the type option is called as fn(req) and the request is parsed if it returns a truthy value.
          Mixed
          "application/octet-stream"
        
        
          verify
          This option, if supplied, is called as verify(req, res, buf, encoding), where buf is a Buffer of the raw request body and encoding is the encoding of the request. The parsing can be aborted by throwing an error.
          Function
          undefined
        
      
    

  

  
    express.Router([options])

    Creates a new router object.

    var router = express.Router([options])
    

    The optional options parameter specifies the behavior of the router.

    

      
        
          
            Property
            Description
            Default
            Availability
          
        
        
          
            caseSensitive
            Enable case sensitivity.
            Disabled by default, treating “/Foo” and “/foo” as the same.
             
          
          
            mergeParams
            Preserve the req.params values from the parent router. If the parent and the child have conflicting param names, the child’s value take precedence.
            false
            4.5.0+
          
          
            strict
            Enable strict routing.
            Disabled by default, “/foo” and “/foo/” are treated the same by the router.
             
          
        
      

    

    You can add middleware and HTTP method routes (such as get, put, post, and
so on) to router just like an application.

    For more information, see Router.

  

  
    express.static(root, [options])

    This is a built-in middleware function in Express.
It serves static files and is based on  serve-static.

    
       Note

      For best results, use a reverse proxy cache to improve performance of serving static assets.

    

    The root argument specifies the root directory from which to serve static assets.
The function determines the file to serve by combining req.url with the provided root directory.
When a file is not found, instead of sending a 404 response, it calls next()
to move on to the next middleware, allowing for stacking and fall-backs.

    The following table describes the properties of the options object.
See also the example below.

    
      
        
          Property
          Description
          Type
          Default
        
      
      
        
          dotfiles
          Determines how dotfiles (files or directories that begin with a dot “.”) are treated.  See dotfiles below.
          String
          undefined
        
        
          etag
          Enable or disable etag generation NOTE: express.static always sends weak ETags.
          Boolean
          true
        
        
          extensions
          Sets file extension fallbacks: If a file is not found, search for files with the specified extensions and serve the first one found. Example: ['html', 'htm'].
          Mixed
          false
        
        
          fallthrough
          Let client errors fall-through as unhandled requests, otherwise forward a client error. See fallthrough below.
          Boolean
          true
        
        
          immutable
          Enable or disable the immutable directive in the Cache-Control response header. If enabled, the maxAge option should also be specified to enable caching. The immutable directive will prevent supported clients from making conditional requests during the life of the maxAge option to check if the file has changed.
          Boolean
          false
        
        
          index
          Sends the specified directory index file. Set to false to disable directory indexing.
          Mixed
          “index.html”
        
        
          lastModified
          Set the Last-Modified header to the last modified date of the file on the OS.
          Boolean
          true
        
        
          maxAge
          Set the max-age property of the Cache-Control header in milliseconds or a string in ms format.
          Number
          0
        
        
          redirect
          Redirect to trailing “/” when the pathname is a directory.
          Boolean
          true
        
        
          setHeaders
          Function for setting HTTP headers to serve with the file. See setHeaders below.
          Function
           
        
      
    

    For more information, see Serving static files in Express.
and Using middleware - Built-in middleware.

    dotfiles

    Possible values for this option are:

    
      “allow” - No special treatment for dotfiles.
      “deny” - Deny a request for a dotfile, respond with 403, then call next().
      “ignore” - Act as if the dotfile does not exist, respond with 404, then call next().
      undefined - Act as ignore, except that files in a directory that begins with a dot are NOT ignored.
    

    fallthrough

    When this option is true, client errors such as a bad request or a request to a non-existent
file will cause this middleware to simply call next() to invoke the next middleware in the stack.
When false, these errors (even 404s), will invoke next(err).

    Set this option to true so you can map multiple physical directories
to the same web address or for routes to fill in non-existent files.

    Use false if you have mounted this middleware at a path designed
to be strictly a single file system directory, which allows for short-circuiting 404s
for less overhead. This middleware will also reply to all methods.

    setHeaders

    For this option, specify a function to set custom response headers. Alterations to the headers must occur synchronously.

    The signature of the function is:

    fn(res, path, stat)
    

    Arguments:

    
      res, the response object.
      path, the file path that is being sent.
      stat, the stat object of the file that is being sent.
    

    Example of express.static

    Here is an example of using the express.static middleware function with an elaborate options object:

    var options = {
  dotfiles: 'ignore',
  etag: false,
  extensions: ['htm', 'html'],
  index: false,
  maxAge: '1d',
  redirect: false,
  setHeaders: function (res, path, stat) {
    res.set('x-timestamp', Date.now())
  }
}

app.use(express.static('public', options))
    

  

  
    express.text([options])

    
      This middleware is available in Express v4.17.0 onwards.
    

    This is a built-in middleware function in Express. It parses incoming request
payloads into a string and is based on
body-parser.

    Returns middleware that parses all bodies as a string and only looks at requests
where the Content-Type header matches the type option. This parser accepts
any Unicode encoding of the body and supports automatic inflation of gzip and
deflate encodings.

    A new body string containing the parsed data is populated on the request
object after the middleware (i.e. req.body), or an empty object ({}) if
there was no body to parse, the Content-Type was not matched, or an error
occurred.

    
      As req.body’s shape is based on user-controlled input, all properties and
values in this object are untrusted and should be validated before trusting.
For example, req.body.trim() may fail in multiple ways, for example
stacking multiple parsers req.body may be from a different parser. Testing
that req.body is a string before calling string methods is recommended.
    

    The following table describes the properties of the optional options object.

    
      
        
          Property
          Description
          Type
          Default
        
      
      
        
          defaultCharset
          Specify the default character set for the text content if the charset is not specified in the Content-Type header of the request.
          String
          "utf-8"
        
        
          inflate
          Enables or disables handling deflated (compressed) bodies; when disabled, deflated bodies are rejected.
          Boolean
          true
        
        
          limit
          Controls the maximum request body size. If this is a number, then the value specifies the number of bytes; if it is a string, the value is passed to the bytes library for parsing.
          Mixed
          "100kb"
        
        
          type
          This is used to determine what media type the middleware will parse. This option can be a string, array of strings, or a function. If not a function, type option is passed directly to the type-is library and this can be an extension name (like txt), a mime type (like text/plain), or a mime type with a wildcard (like */* or text/*). If a function, the type option is called as fn(req) and the request is parsed if it returns a truthy value.
          Mixed
          "text/plain"
        
        
          verify
          This option, if supplied, is called as verify(req, res, buf, encoding), where buf is a Buffer of the raw request body and encoding is the encoding of the request. The parsing can be aborted by throwing an error.
          Function
          undefined
        
      
    

  

  
    express.urlencoded([options])

    
      This middleware is available in Express v4.16.0 onwards.
    

    This is a built-in middleware function in Express. It parses incoming requests
with urlencoded payloads and is based on body-parser.

    Returns middleware that only parses urlencoded bodies and only looks at
requests where the Content-Type header matches the type option. This
parser accepts only UTF-8 encoding of the body and supports automatic
inflation of gzip and deflate encodings.

    A new body object containing the parsed data is populated on the request
object after the middleware (i.e. req.body), or an empty object ({}) if
there was no body to parse, the Content-Type was not matched, or an error
occurred. This object will contain key-value pairs, where the value can be
a string or array (when extended is false), or any type (when extended
is true).

    
      As req.body’s shape is based on user-controlled input, all properties and
values in this object are untrusted and should be validated before trusting.
For example, req.body.foo.toString() may fail in multiple ways, for example
foo may not be there or may not be a string, and toString may not be a
function and instead a string or other user-input.
    

    The following table describes the properties of the optional options object.

    
      
        
          Property
          Description
          Type
          Default
        
      
      
        
          extended
          This option allows to choose between parsing the URL-encoded data with the querystring library (when false) or the qs library (when true). The “extended” syntax allows for rich objects and arrays to be encoded into the URL-encoded format, allowing for a JSON-like experience with URL-encoded. For more information, please see the qs library.
          Boolean
          true
        
        
          inflate
          Enables or disables handling deflated (compressed) bodies; when disabled, deflated bodies are rejected.
          Boolean
          true
        
        
          limit
          Controls the maximum request body size. If this is a number, then the value specifies the number of bytes; if it is a string, the value is passed to the bytes library for parsing.
          Mixed
          "100kb"
        
        
          parameterLimit
          This option controls the maximum number of parameters that are allowed in the URL-encoded data. If a request contains more parameters than this value, an error will be raised.
          Number
          1000
        
        
          type
          This is used to determine what media type the middleware will parse. This option can be a string, array of strings, or a function. If not a function, type option is passed directly to the type-is library and this can be an extension name (like urlencoded), a mime type (like application/x-www-form-urlencoded), or a mime type with a wildcard (like */x-www-form-urlencoded). If a function, the type option is called as fn(req) and the request is parsed if it returns a truthy value.
          Mixed
          "application/x-www-form-urlencoded"
        
        
          verify
          This option, if supplied, is called as verify(req, res, buf, encoding), where buf is a Buffer of the raw request body and encoding is the encoding of the request. The parsing can be aborted by throwing an error.
          Function
          undefined
        
      
    

  

  Application

  The app object conventionally denotes the Express application.
Create it by calling the top-level express() function exported by the Express module:

  var express = require('express')
var app = express()

app.get('/', function (req, res) {
  res.send('hello world')
})

app.listen(3000)
  

  The app object has methods for

  
    Routing HTTP requests; see for example, app.METHOD and app.param.
    Configuring middleware; see app.route.
    Rendering HTML views; see app.render.
    Registering a template engine; see app.engine.
  

  It also has settings (properties) that affect how the application behaves;
for more information, see Application settings.

  
    The Express application object can be referred from the request object and the response object as req.app, and res.app, respectively.
  

  Properties

  
    app.locals

    The app.locals object has properties that are local variables within the application,
and will be available in templates rendered with res.render.

    
      The locals object is used by view engines to render a response. The object
keys may be particularly sensitive and should not contain user-controlled
input, as it may affect the operation of the view engine or provide a path to
cross-site scripting. Consult the documentation for the used view engine for
additional considerations.
    

    console.dir(app.locals.title)
// => 'My App'

console.dir(app.locals.email)
// => '[email protected]'
    

    Once set, the value of app.locals properties persist throughout the life of the application,
in contrast with res.locals properties that
are valid only for the lifetime of the request.

    You can access local variables in templates rendered within the application.
This is useful for providing helper functions to templates, as well as application-level data.
Local variables are available in middleware via req.app.locals (see req.app)

    app.locals.title = 'My App'
app.locals.strftime = require('strftime')
app.locals.email = '[email protected]'
    

  

  
    app.mountpath

    The app.mountpath property contains one or more path patterns on which a sub-app was mounted.

    
      A sub-app is an instance of express that may be used for handling the request to a route.
    

    var express = require('express')

var app = express() // the main app
var admin = express() // the sub app

admin.get('/', function (req, res) {
  console.log(admin.mountpath) // /admin
  res.send('Admin Homepage')
})

app.use('/admin', admin) // mount the sub app
    

    It is similar to the baseUrl property of the req object, except req.baseUrl
returns the matched URL path, instead of the matched patterns.

    If a sub-app is mounted on multiple path patterns, app.mountpath returns the list of
patterns it is mounted on, as shown in the following example.

    var admin = express()

admin.get('/', function (req, res) {
  console.dir(admin.mountpath) // [ '/adm*n', '/manager' ]
  res.send('Admin Homepage')
})

var secret = express()
secret.get('/', function (req, res) {
  console.log(secret.mountpath) // /secr*t
  res.send('Admin Secret')
})

admin.use('/secr*t', secret) // load the 'secret' router on '/secr*t', on the 'admin' sub app
app.use(['/adm*n', '/manager'], admin) // load the 'admin' router on '/adm*n' and '/manager', on the parent app
    

  

  Events

  
    app.on('mount', callback(parent))

    The mount event is fired on a sub-app, when it is mounted on a parent app. The parent app is passed to the callback function.

    
      NOTE

      Sub-apps will:

      
        Not inherit the value of settings that have a default value.  You must set the value in the sub-app.
        Inherit the value of settings with no default value.
      

      For details, see Application settings.
    

    var admin = express()

admin.on('mount', function (parent) {
  console.log('Admin Mounted')
  console.log(parent) // refers to the parent app
})

admin.get('/', function (req, res) {
  res.send('Admin Homepage')
})

app.use('/admin', admin)
    

  

  Methods

  
    app.all(path, callback [, callback ...])

    This method is like the standard app.METHOD() methods,
except it matches all HTTP verbs.

     Arguments

    

Argument 
 Description 
 Default 



path

The path for which the middleware function is invoked; can be any of:

A string representing a path.
A path pattern.
A regular expression pattern to match paths.
An array of combinations of any of the above.


For examples, see Path examples.

'/' (root path)



 callback

Callback functions; can be:

A middleware function.
A series of middleware functions (separated by commas).
An array of middleware functions.
A combination of all of the above.


You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke next('route') to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.

Since router and app implement the middleware interface,
you can use them as you would any other middleware function.

For examples, see Middleware callback function examples.


 None 


    Examples

    The following callback is executed for requests to /secret whether using
GET, POST, PUT, DELETE, or any other HTTP request method:

    app.all('/secret', function (req, res, next) {
  console.log('Accessing the secret section ...')
  next() // pass control to the next handler
})
    

    The app.all() method is useful for mapping “global” logic for specific path prefixes or arbitrary matches.  For example, if you put the following at the top of all other
route definitions, it requires that all routes from that point on
require authentication, and automatically load a user. Keep in mind
that these callbacks do not have to act as end-points: loadUser
can perform a task, then call next() to continue matching subsequent
routes.

    app.all('*', requireAuthentication, loadUser)
    

    Or the equivalent:

    app.all('*', requireAuthentication)
app.all('*', loadUser)
    

    Another example is white-listed “global” functionality.
The example is similar to the ones above, but it only restricts paths that start with
“/api”:

    app.all('/api/*', requireAuthentication)
    

  

  
    app.delete(path, callback [, callback ...])

    Routes HTTP DELETE requests to the specified path with the specified callback functions.
For more information, see the routing guide.

     Arguments

    

Argument 
 Description 
 Default 



path

The path for which the middleware function is invoked; can be any of:

A string representing a path.
A path pattern.
A regular expression pattern to match paths.
An array of combinations of any of the above.


For examples, see Path examples.

'/' (root path)



 callback

Callback functions; can be:

A middleware function.
A series of middleware functions (separated by commas).
An array of middleware functions.
A combination of all of the above.


You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke next('route') to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.

Since router and app implement the middleware interface,
you can use them as you would any other middleware function.

For examples, see Middleware callback function examples.


 None 


    Example

    app.delete('/', function (req, res) {
  res.send('DELETE request to homepage')
})
    

  

  
    app.disable(name)

    Sets the Boolean setting name to false, where name is one of the properties from the app settings table.
Calling app.set('foo', false) for a Boolean property is the same as calling app.disable('foo').

    For example:

    app.disable('trust proxy')
app.get('trust proxy')
// => false
    

  

  
    app.disabled(name)

    Returns true if the Boolean setting name is disabled (false), where name is one of the properties from
the app settings table.

    app.disabled('trust proxy')
// => true

app.enable('trust proxy')
app.disabled('trust proxy')
// => false
    

  

  
    app.enable(name)

    Sets the Boolean setting name to true, where name is one of the properties from the app settings table.
Calling app.set('foo', true) for a Boolean property is the same as calling app.enable('foo').

    app.enable('trust proxy')
app.get('trust proxy')
// => true
    

  

  
    app.enabled(name)

    Returns true if the setting name is enabled (true), where name is one of the
properties from the app settings table.

    app.enabled('trust proxy')
// => false

app.enable('trust proxy')
app.enabled('trust proxy')
// => true
    

  

  
    app.engine(ext, callback)

    Registers the given template engine callback as ext.

    By default, Express will require() the engine based on the file extension.
For example, if you try to render a “foo.pug” file, Express invokes the
following internally, and caches the require() on subsequent calls to increase
performance.

    app.engine('pug', require('pug').__express)
    

    Use this method for engines that do not provide .__express out of the box,
or if you wish to “map” a different extension to the template engine.

    For example, to map the EJS template engine to “.html” files:

    app.engine('html', require('ejs').renderFile)
    

    In this case, EJS provides a .renderFile() method with
the same signature that Express expects: (path, options, callback),
though note that it aliases this method as ejs.__express internally
so if you’re using “.ejs” extensions you don’t need to do anything.

    Some template engines do not follow this convention.  The
consolidate.js library maps Node template engines to follow this convention,
so they work seamlessly with Express.

    var engines = require('consolidate')
app.engine('haml', engines.haml)
app.engine('html', engines.hogan)
    

  

  
    app.get(name)

    Returns the value of name app setting, where name is one of the strings in the
app settings table. For example:

    app.get('title')
// => undefined

app.set('title', 'My Site')
app.get('title')
// => "My Site"
    

  

  
    app.get(path, callback [, callback ...])

    Routes HTTP GET requests to the specified path with the specified callback functions.

     Arguments

    

Argument 
 Description 
 Default 



path

The path for which the middleware function is invoked; can be any of:

A string representing a path.
A path pattern.
A regular expression pattern to match paths.
An array of combinations of any of the above.


For examples, see Path examples.

'/' (root path)



 callback

Callback functions; can be:

A middleware function.
A series of middleware functions (separated by commas).
An array of middleware functions.
A combination of all of the above.


You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke next('route') to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.

Since router and app implement the middleware interface,
you can use them as you would any other middleware function.

For examples, see Middleware callback function examples.


 None 


    For more information, see the routing guide.

    Example

    app.get('/', function (req, res) {
  res.send('GET request to homepage')
})
    

  

  
    app.listen(path, [callback])

    Starts a UNIX socket and listens for connections on the given path.
This method is identical to Node’s http.Server.listen().

    var express = require('express')
var app = express()
app.listen('/tmp/sock')
    

    app.listen([port[, host[, backlog]]][, callback])

    Binds and listens for connections on the specified host and port.
This method is identical to Node’s http.Server.listen().

    If port is omitted or is 0, the operating system will assign an arbitrary unused
port, which is useful for cases like automated tasks (tests, etc.).

    var express = require('express')
var app = express()
app.listen(3000)
    

    The app returned by express() is in fact a JavaScript
Function, designed to be passed to Node’s HTTP servers as a callback
to handle requests. This makes it easy to provide both HTTP and HTTPS versions of
your app with the same code base, as the app does not inherit from these
(it is simply a callback):

    var express = require('express')
var https = require('https')
var http = require('http')
var app = express()

http.createServer(app).listen(80)
https.createServer(options, app).listen(443)
    

    The app.listen() method returns an http.Server object and (for HTTP) is a convenience method for the following:

    app.listen = function () {
  var server = http.createServer(this)
  return server.listen.apply(server, arguments)
}
    

    
       Note
      All the forms of Node’s
http.Server.listen()
method are in fact actually supported.
    

  

  
    app.METHOD(path, callback [, callback ...])

    Routes an HTTP request, where METHOD is the HTTP method of the request, such as GET,
PUT, POST, and so on, in lowercase. Thus, the actual methods are app.get(),
app.post(), app.put(), and so on.  See Routing methods below for the complete list.

     Arguments

    

Argument 
 Description 
 Default 



path

The path for which the middleware function is invoked; can be any of:

A string representing a path.
A path pattern.
A regular expression pattern to match paths.
An array of combinations of any of the above.


For examples, see Path examples.

'/' (root path)



 callback

Callback functions; can be:

A middleware function.
A series of middleware functions (separated by commas).
An array of middleware functions.
A combination of all of the above.


You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke next('route') to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.

Since router and app implement the middleware interface,
you can use them as you would any other middleware function.

For examples, see Middleware callback function examples.


 None 


    Routing methods

    Express supports the following routing methods corresponding to the HTTP methods of the same names:

    


          
            checkout
            copy
            delete
            get
            head
            lock
            merge
            mkactivity
          
        

          
            mkcol
            move
            m-search
            notify
            options
            patch
            post
          
        

          
            purge
            put
            report
            search
            subscribe
            trace
            unlock
            unsubscribe
          
        



    The API documentation has explicit entries only for the most popular HTTP methods app.get(),
app.post(), app.put(), and app.delete().
However, the other methods listed above work in exactly the same way.

    To route methods that translate to invalid JavaScript variable names, use the bracket notation. For example, app['m-search']('/', function ....

    
      The app.get() function is automatically called for the HTTP HEAD method in addition to the GET
  method if app.head() was not called for the path before app.get().
    

    The method, app.all(), is not derived from any HTTP method and loads middleware at
the specified path for all HTTP request methods.
For more information, see app.all.

    For more information on routing, see the routing guide.

  

  
    app.param([name], callback)

    Add callback triggers to route parameters, where name is the name of the parameter or an array of them, and callback is the callback function. The parameters of the callback function are the request object, the response object, the next middleware, the value of the parameter and the name of the parameter, in that order.

    If name is an array, the callback trigger is registered for each parameter declared in it, in the order in which they are declared. Furthermore, for each declared parameter except the last one, a call to next inside the callback will call the callback for the next declared parameter. For the last parameter, a call to next will call the next middleware in place for the route currently being processed, just like it would if name were just a string.

    For example, when :user is present in a route path, you may map user loading logic to automatically provide req.user to the route, or perform validations on the parameter input.

    app.param('user', function (req, res, next, id) {
  // try to get the user details from the User model and attach it to the request object
  User.find(id, function (err, user) {
    if (err) {
      next(err)
    } else if (user) {
      req.user = user
      next()
    } else {
      next(new Error('failed to load user'))
    }
  })
})
    

    Param callback functions are local to the router on which they are defined. They are not inherited by mounted apps or routers, nor are they triggered for route parameters inherited from parent routers. Hence, param callbacks defined on app will be triggered only by route parameters defined on app routes.

    All param callbacks will be called before any handler of any route in which the param occurs, and they will each be called only once in a request-response cycle, even if the parameter is matched in multiple routes, as shown in the following examples.

    app.param('id', function (req, res, next, id) {
  console.log('CALLED ONLY ONCE')
  next()
})

app.get('/user/:id', function (req, res, next) {
  console.log('although this matches')
  next()
})

app.get('/user/:id', function (req, res) {
  console.log('and this matches too')
  res.end()
})
    

    On GET /user/42, the following is printed:

    CALLED ONLY ONCE
although this matches
and this matches too
    

    app.param(['id', 'page'], function (req, res, next, value) {
  console.log('CALLED ONLY ONCE with', value)
  next()
})

app.get('/user/:id/:page', function (req, res, next) {
  console.log('although this matches')
  next()
})

app.get('/user/:id/:page', function (req, res) {
  console.log('and this matches too')
  res.end()
})
    

    On GET /user/42/3, the following is printed:

    CALLED ONLY ONCE with 42
CALLED ONLY ONCE with 3
although this matches
and this matches too
    

    
      The following section describes app.param(callback), which is deprecated as of v4.11.0.
    

    The behavior of the app.param(name, callback) method can be altered entirely by passing only a function to app.param(). This function is a custom implementation of how app.param(name, callback) should behave - it accepts two parameters and must return a middleware.

    The first parameter of this function is the name of the URL parameter that should be captured, the second parameter can be any JavaScript object which might be used for returning the middleware implementation.

    The middleware returned by the function decides the behavior of what happens when a URL parameter is captured.

    In this example, the app.param(name, callback) signature is modified to app.param(name, accessId). Instead of accepting a name and a callback, app.param() will now accept a name and a number.

    var express = require('express')
var app = express()

// customizing the behavior of app.param()
app.param(function (param, option) {
  return function (req, res, next, val) {
    if (val === option) {
      next()
    } else {
      next('route')
    }
  }
})

// using the customized app.param()
app.param('id', 1337)

// route to trigger the capture
app.get('/user/:id', function (req, res) {
  res.send('OK')
})

app.listen(3000, function () {
  console.log('Ready')
})
    

    In this example, the app.param(name, callback) signature remains the same, but instead of a middleware callback, a custom data type checking function has been defined to validate the data type of the user id.

    app.param(function (param, validator) {
  return function (req, res, next, val) {
    if (validator(val)) {
      next()
    } else {
      next('route')
    }
  }
})

app.param('id', function (candidate) {
  return !isNaN(parseFloat(candidate)) && isFinite(candidate)
})
    

    
      The ‘.’ character can’t be used to capture a character in your capturing regexp. For example you can’t use '/user-.+/' to capture 'users-gami', use [\ \\S] or [\\w\\W] instead (as in '/user-[\ \\S]+/'.

      Examples:

      // captures '1-a_6' but not '543-azser-sder'
router.get('/[0-9]+-[[\\w]]*', function (req, res, next) { next() })

// captures '1-a_6' and '543-az(ser"-sder' but not '5-a s'
router.get('/[0-9]+-[[\\S]]*', function (req, res, next) { next() })

// captures all (equivalent to '.*')
router.get('[[\ \\S]]*', function (req, res, next) { next() })
      

    

  

  
    app.path()

    Returns the canonical path of the app, a string.

    var app = express()
var blog = express()
var blogAdmin = express()

app.use('/blog', blog)
blog.use('/admin', blogAdmin)

console.dir(app.path()) // ''
console.dir(blog.path()) // '/blog'
console.dir(blogAdmin.path()) // '/blog/admin'
    

    The behavior of this method can become very complicated in complex cases of mounted apps:
it is usually better to use req.baseUrl to get the canonical path of the app.

  

  
    app.post(path, callback [, callback ...])

    Routes HTTP POST requests to the specified path with the specified callback functions.
For more information, see the routing guide.

     Arguments

    

Argument 
 Description 
 Default 



path

The path for which the middleware function is invoked; can be any of:

A string representing a path.
A path pattern.
A regular expression pattern to match paths.
An array of combinations of any of the above.


For examples, see Path examples.

'/' (root path)



 callback

Callback functions; can be:

A middleware function.
A series of middleware functions (separated by commas).
An array of middleware functions.
A combination of all of the above.


You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke next('route') to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.

Since router and app implement the middleware interface,
you can use them as you would any other middleware function.

For examples, see Middleware callback function examples.


 None 


    Example

    app.post('/', function (req, res) {
  res.send('POST request to homepage')
})
    

  

  
    app.put(path, callback [, callback ...])

    Routes HTTP PUT requests to the specified path with the specified callback functions.

     Arguments

    

Argument 
 Description 
 Default 



path

The path for which the middleware function is invoked; can be any of:

A string representing a path.
A path pattern.
A regular expression pattern to match paths.
An array of combinations of any of the above.


For examples, see Path examples.

'/' (root path)



 callback

Callback functions; can be:

A middleware function.
A series of middleware functions (separated by commas).
An array of middleware functions.
A combination of all of the above.


You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke next('route') to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.

Since router and app implement the middleware interface,
you can use them as you would any other middleware function.

For examples, see Middleware callback function examples.


 None 


    Example

    app.put('/', function (req, res) {
  res.send('PUT request to homepage')
})
    

  

  
    app.render(view, [locals], callback)

    Returns the rendered HTML of a view via the callback function. It accepts an optional parameter
that is an object containing local variables for the view. It is like res.render(),
except it cannot send the rendered view to the client on its own.

    
      Think of app.render() as a utility function for generating rendered view strings.
Internally res.render() uses app.render() to render views.
    

    
      The view argument performs file system operations like reading a file from
disk and evaluating Node.js modules, and as so for security reasons should not
contain input from the end-user.
    

    
      The locals object is used by view engines to render a response. The object
keys may be particularly sensitive and should not contain user-controlled
input, as it may affect the operation of the view engine or provide a path to
cross-site scripting. Consult the documentation for the used view engine for
additional considerations.
    

    
      The local variable cache is reserved for enabling view cache. Set it to true, if you want to
cache view during development; view caching is enabled in production by default.
    

    app.render('email', function (err, html) {
  // ...
})

app.render('email', { name: 'Tobi' }, function (err, html) {
  // ...
})
    

  

  
    app.route(path)

    Returns an instance of a single route, which you can then use to handle HTTP verbs with optional middleware.
Use app.route() to avoid duplicate route names (and thus typo errors).

    var app = express()

app.route('/events')
  .all(function (req, res, next) {
    // runs for all HTTP verbs first
    // think of it as route specific middleware!
  })
  .get(function (req, res, next) {
    res.json({})
  })
  .post(function (req, res, next) {
    // maybe add a new event...
  })
    

  

  
    app.set(name, value)

    Assigns setting name to value. You may store any value that you want,
but certain names can be used to configure the behavior of the server. These
special names are listed in the app settings table.

    Calling app.set('foo', true) for a Boolean property is the same as calling
app.enable('foo'). Similarly, calling app.set('foo', false) for a Boolean
property is the same as calling app.disable('foo').

    Retrieve the value of a setting with app.get().

    app.set('title', 'My Site')
app.get('title') // "My Site"
    

    Application Settings

    The following table lists application settings.

    Note that sub-apps will:

    
      Not inherit the value of settings that have a default value.  You must set the value in the sub-app.
      Inherit the value of settings with no default value; these are explicitly noted in the table below.
    

    Exceptions: Sub-apps will inherit the value of trust proxy even though it has a default value (for backward-compatibility);
Sub-apps will not inherit the value of view cache in production (when NODE_ENV is “production”).

    
  
    PropertyTypeDescriptionDefault
    
    
  
              case sensitive routing
            
      Boolean
      Enable case sensitivity.
      When enabled, "/Foo" and "/foo" are different routes.
      When disabled, "/Foo" and "/foo" are treated the same.
        NOTE: Sub-apps will inherit the value of this setting.
      
      N/A (undefined)
      
    
    
  
              env
            
  String
  
              Environment mode. Be sure to set to “production” in a production environment; see Production best practices: performance and reliability.
            
  
              process.env.NODE_ENV (NODE_ENV environment variable) or “development” if NODE_ENV is not set.
            
    
    
  
              etag
            
  Varied
  
              Set the ETag response header. For possible values, see the etag options table.

              More about the HTTP ETag header.
            
  
              weak
            
    
    
  
              jsonp callback name
            
      String
      Specifies the default JSONP callback name.
  
              “callback”
            
    
    
  
              json escape
            
  Boolean
  
              Enable escaping JSON responses from the res.json, res.jsonp, and res.send APIs. This will escape the characters <, >, and & as Unicode escape sequences in JSON. The purpose of this it to assist with mitigating certain types of persistent XSS attacks when clients sniff responses for HTML.
              NOTE: Sub-apps will inherit the value of this setting.
            
  N/A (undefined)
    
    
  
              json replacer
            
      Varied
      The 'replacer' argument used by `JSON.stringify`.
        NOTE: Sub-apps will inherit the value of this setting.
      
  N/A (undefined)
  
    
    
  
              json spaces
            
      Varied
      The 'space' argument used by `JSON.stringify`.
This is typically set to the number of spaces to use to indent prettified JSON.
        NOTE: Sub-apps will inherit the value of this setting.
      
      N/A (undefined)
    
    
  
              query parser
            
      Varied
  
              Disable query parsing by setting the value to false, or set the query parser to use either “simple” or “extended” or a custom query string parsing function.

              The simple query parser is based on Node’s native query parser, querystring.

              The extended query parser is based on qs.

              A custom query string parsing function will receive the complete query string, and must return an object of query keys and their values.
            
      "extended"
    
    
  
              strict routing
            
      Boolean
      Enable strict routing.
      When enabled, the router treats "/foo" and "/foo/" as different.
      Otherwise, the router treats "/foo" and "/foo/" as the same.
        NOTE: Sub-apps will inherit the value of this setting.
      
      N/A (undefined) 
    
    
  
              subdomain offset
            
      Number
      The number of dot-separated parts of the host to remove to access subdomain.
      2
    
    
  
              trust proxy
            
      Varied
  
              Indicates the app is behind a front-facing proxy, and to use the X-Forwarded-* headers to determine the connection and the IP address of the client. NOTE: X-Forwarded-* headers are easily spoofed and the detected IP addresses are unreliable.
              
  When enabled, Express attempts to determine the IP address of the client connected through the front-facing proxy, or series of proxies. The `req.ips` property, then contains an array of IP addresses the client is connected through. To enable it, use the values described in the trust proxy options table.

              
  The `trust proxy` setting is implemented using the proxy-addr package.  For more information, see its documentation.

              
NOTE: Sub-apps will inherit the value of this setting, even though it has a default value.

            
  
              false (disabled)
            
    
    
  
              views
            
      String or Array
      A directory or an array of directories for the application's views. If an array, the views are looked up in the order they occur in the array.
  
              process.cwd() + '/views'
            
    
    
  
              view cache
            
      Boolean
      Enables view template compilation caching.
      NOTE: Sub-apps will not inherit the value of this setting in production (when `NODE_ENV` is "production").
      
  
              true in production, otherwise undefined.
            
    
    
  
              view engine
            
      String
      The default engine extension to use when omitted.
        NOTE: Sub-apps will inherit the value of this setting.
      
      N/A (undefined)
    
    
  
              x-powered-by
            
      Boolean
      Enables the "X-Powered-By: Express" HTTP header.
  
              true
            
    
    
  

  Options for `trust proxy` setting

  
  Read Express behind proxies for more
  information.
  

  
    TypeValue
    
      
        Boolean
  
              If true, the client’s IP address is understood as the left-most entry in the X-Forwarded-* header.

              If false, the app is understood as directly facing the Internet and the client’s IP address is derived from req.connection.remoteAddress. This is the default setting.
            
      
      
        StringString containing comma-separated valuesArray of strings 
  
              An IP address, subnet, or an array of IP addresses, and subnets to trust. Pre-configured subnet names are:

              
                loopback - 127.0.0.1/8, ::1/128
                linklocal - 169.254.0.0/16, fe80::/10
                uniquelocal - 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, fc00::/7
              

              Set IP addresses in any of the following ways:

              Specify a single subnet:

              app.set('trust proxy', 'loopback')
              

              Specify a subnet and an address:

              app.set('trust proxy', 'loopback, 123.123.123.123')
              

              Specify multiple subnets as CSV:

              app.set('trust proxy', 'loopback, linklocal, uniquelocal')
              

              Specify multiple subnets as an array:

              app.set('trust proxy', ['loopback', 'linklocal', 'uniquelocal'])
              

              When specified, the IP addresses or the subnets are excluded from the address determination process, and the untrusted IP address nearest to the application server is determined as the client’s IP address.
            
      
      
        Number
  
              Trust the nth hop from the front-facing proxy server as the client.
            
      
      
        Function
  
              Custom trust implementation. Use this only if you know what you are doing.

              app.set('trust proxy', function (ip) {
  if (ip === '127.0.0.1' || ip === '123.123.123.123') return true // trusted IPs
  else return false
})
              
            
      
    
  

  Options for `etag` setting


NOTE:  These settings apply only to dynamic files, not static files.
The express.static middleware ignores these settings.


  
  The ETag functionality is implemented using the
  etag package.
  For more information, see its documentation.
  

  
    TypeValue
    
      
        Boolean
  
              true enables weak ETag. This is the default setting.
  false disables ETag altogether.
            
      
      
        String
        
            If "strong", enables strong ETag.
            If "weak", enables weak ETag.
        
      
      
        Function
  
              Custom ETag function implementation. Use this only if you know what you are doing.

              app.set('etag', function (body, encoding) {
  return generateHash(body, encoding) // consider the function is defined
})
              
            
      
    
  


  

  
    app.use([path,] callback [, callback...])

    Mounts the specified middleware function or functions
at the specified path:
the middleware function is executed when the base of the requested path matches path.

     Arguments

    

Argument 
 Description 
 Default 



path

The path for which the middleware function is invoked; can be any of:

A string representing a path.
A path pattern.
A regular expression pattern to match paths.
An array of combinations of any of the above.


For examples, see Path examples.

'/' (root path)



 callback

Callback functions; can be:

A middleware function.
A series of middleware functions (separated by commas).
An array of middleware functions.
A combination of all of the above.


You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke next('route') to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.

Since router and app implement the middleware interface,
you can use them as you would any other middleware function.

For examples, see Middleware callback function examples.


 None 


    Description

    A route will match any path that follows its path immediately with a “/”.
For example: app.use('/apple', ...) will match “/apple”, “/apple/images”,
“/apple/images/news”, and so on.

    Since path defaults to “/”, middleware mounted without a path will be executed for every request to the app.
For example, this middleware function will be executed for every request to the app:

    app.use(function (req, res, next) {
  console.log('Time: %d', Date.now())
  next()
})
    

    
      NOTE

      Sub-apps will:

      
        Not inherit the value of settings that have a default value.  You must set the value in the sub-app.
        Inherit the value of settings with no default value.
      

      For details, see Application settings.
    

    Middleware functions are executed sequentially, therefore the order of middleware inclusion is important.

    // this middleware will not allow the request to go beyond it
app.use(function (req, res, next) {
  res.send('Hello World')
})

// requests will never reach this route
app.get('/', function (req, res) {
  res.send('Welcome')
})
    

    Error-handling middleware

    Error-handling middleware always takes four arguments.  You must provide four arguments to identify it as an error-handling middleware function. Even if you don’t need to use the next object, you must specify it to maintain the signature. Otherwise, the next object will be interpreted as regular middleware and will fail to handle errors. For details about error-handling middleware, see: Error handling.

    Define error-handling middleware functions in the same way as other middleware functions, except with four arguments instead of three, specifically with the signature (err, req, res, next)):

    app.use(function (err, req, res, next) {
  console.error(err.stack)
  res.status(500).send('Something broke!')
})
    

    Path examples

    The following table provides some simple examples of valid path values for
mounting middleware.

    




Type
Example





Path

              This will match paths starting with /abcd:

              app.use('/abcd', function (req, res, next) {
  next()
})
              

            



Path Pattern

              This will match paths starting with /abcd and /abd:

              app.use('/abc?d', function (req, res, next) {
  next()
})
              

              This will match paths starting with /abcd, /abbcd, /abbbbbcd, and so on:

              app.use('/ab+cd', function (req, res, next) {
  next()
})
              

              This will match paths starting with /abcd, /abxcd, /abFOOcd, /abbArcd, and so on:

              app.use('/ab*cd', function (req, res, next) {
  next()
})
              

              This will match paths starting with /ad and /abcd:

              app.use('/a(bc)?d', function (req, res, next) {
  next()
})
              

            



Regular Expression

              This will match paths starting with /abc and /xyz:

              app.use(/\/abc|\/xyz/, function (req, res, next) {
  next()
})
              

            



Array

              This will match paths starting with /abcd, /xyza, /lmn, and /pqr:

              app.use(['/abcd', '/xyza', /\/lmn|\/pqr/], function (req, res, next) {
  next()
})
              

            







    Middleware callback function examples

    The following table provides some simple examples of middleware functions that
can be used as the callback argument to app.use(), app.METHOD(), and app.all().

    



Usage
Example






Single Middleware

            You can define and mount a middleware function locally.

            app.use(function (req, res, next) {
  next()
})
            

            A router is valid middleware.

            var router = express.Router()
router.get('/', function (req, res, next) {
  next()
})
app.use(router)
            

            An Express app is valid middleware.

            var subApp = express()
subApp.get('/', function (req, res, next) {
  next()
})
app.use(subApp)
            

          



Series of Middleware

            You can specify more than one middleware function at the same mount path.

            var r1 = express.Router()
r1.get('/', function (req, res, next) {
  next()
})

var r2 = express.Router()
r2.get('/', function (req, res, next) {
  next()
})

app.use(r1, r2)
            

          



Array

            Use an array to group middleware logically.

            var r1 = express.Router()
r1.get('/', function (req, res, next) {
  next()
})

var r2 = express.Router()
r2.get('/', function (req, res, next) {
  next()
})

app.use([r1, r2])
            

          



Combination

            You can combine all the above ways of mounting middleware.

            function mw1 (req, res, next) { next() }
function mw2 (req, res, next) { next() }

var r1 = express.Router()
r1.get('/', function (req, res, next) { next() })

var r2 = express.Router()
r2.get('/', function (req, res, next) { next() })

var subApp = express()
subApp.get('/', function (req, res, next) { next() })

app.use(mw1, [mw2, r1, r2], subApp)
            

          






    Following are some examples of using the express.static
middleware in an Express app.

    Serve static content for the app from the “public” directory in the application directory:

    // GET /style.css etc
app.use(express.static(path.join(__dirname, 'public')))
    

    Mount the middleware at “/static” to serve static content only when their request path is prefixed with “/static”:

    // GET /static/style.css etc.
app.use('/static', express.static(path.join(__dirname, 'public')))
    

    Disable logging for static content requests by loading the logger middleware after the static middleware:

    app.use(express.static(path.join(__dirname, 'public')))
app.use(logger())
    

    Serve static files from multiple directories, but give precedence to “./public” over the others:

    app.use(express.static(path.join(__dirname, 'public')))
app.use(express.static(path.join(__dirname, 'files')))
app.use(express.static(path.join(__dirname, 'uploads')))
    

  

  Request

  The req object represents the HTTP request and has properties for the
request query string, parameters, body, HTTP headers, and so on.  In this documentation and by convention,
the object is always referred to as req (and the HTTP response is res) but its actual name is determined
by the parameters to the callback function in which you’re working.

  For example:

  app.get('/user/:id', function (req, res) {
  res.send('user ' + req.params.id)
})
  

  But you could just as well have:

  app.get('/user/:id', function (request, response) {
  response.send('user ' + request.params.id)
})
  

  The req object is an enhanced version of Node’s own request object
and supports all built-in fields and methods.

  Properties

  
    In Express 4, req.files is no longer available on the req object by default. To access uploaded files
on the req.files object, use multipart-handling middleware like busboy, multer,
formidable,
multiparty,
connect-multiparty,
or pez.
  

  
    req.app

    This property holds a reference to the instance of the Express application that is using the middleware.

    If you follow the pattern in which you create a module that just exports a middleware function
and require() it in your main file, then the middleware can access the Express instance via req.app

    For example:

    // index.js
app.get('/viewdirectory', require('./mymiddleware.js'))
    

    // mymiddleware.js
module.exports = function (req, res) {
  res.send('The views directory is ' + req.app.get('views'))
}
    

  

  
    req.baseUrl

    The URL path on which a router instance was mounted.

    The req.baseUrl property is similar to the mountpath property of the app object,
except app.mountpath returns the matched path pattern(s).

    For example:

    var greet = express.Router()

greet.get('/jp', function (req, res) {
  console.log(req.baseUrl) // /greet
  res.send('Konnichiwa!')
})

app.use('/greet', greet) // load the router on '/greet'
    

    Even if you use a path pattern or a set of path patterns to load the router,
the baseUrl property returns the matched string, not the pattern(s). In the
following example, the greet router is loaded on two path patterns.

    app.use(['/gre+t', '/hel{2}o'], greet) // load the router on '/gre+t' and '/hel{2}o'
    

    When a request is made to /greet/jp, req.baseUrl is “/greet”.  When a request is
made to /hello/jp, req.baseUrl is “/hello”.

  

  
    req.body

    Contains key-value pairs of data submitted in the request body.
By default, it is undefined, and is populated when you use body-parsing middleware such
as express.json() or express.urlencoded().

    
      As req.body’s shape is based on user-controlled input, all properties and values in this object are untrusted and should be validated before trusting. For example, req.body.foo.toString() may fail in multiple ways, for example foo may not be there or may not be a string, and toString may not be a function and instead a string or other user-input.
    

    The following example shows how to use body-parsing middleware to populate req.body.

    var express = require('express')

var app = express()

app.use(express.json()) // for parsing application/json
app.use(express.urlencoded({ extended: true })) // for parsing application/x-www-form-urlencoded

app.post('/profile', function (req, res, next) {
  console.log(req.body)
  res.json(req.body)
})
    

  

  
    req.cookies

    When using cookie-parser middleware, this property is an object that
contains cookies sent by the request.  If the request contains no cookies, it defaults to {}.

    // Cookie: name=tj
console.dir(req.cookies.name)
// => 'tj'
    

    If the cookie has been signed, you have to use req.signedCookies.

    For more information, issues, or concerns, see cookie-parser.

  

  
    req.fresh

    When the response is still “fresh” in the client’s cache true is returned, otherwise false is returned to indicate that the client cache is now stale and the full response should be sent.

    When a client sends the Cache-Control: no-cache request header to indicate an end-to-end reload request, this module will return false to make handling these requests transparent.

    Further details for how cache validation works can be found in the
HTTP/1.1 Caching Specification.

    console.dir(req.fresh)
// => true
    

  

  
    req.hostname

    Contains the hostname derived from the Host HTTP header.

    When the trust proxy setting
does not evaluate to false, this property will instead get the value
from the X-Forwarded-Host header field. This header can be set by
the client or by the proxy.

    If there is more than one X-Forwarded-Host header in the request, the
value of the first header is used. This includes a single header with
comma-separated values, in which the first value is used.

    
      Prior to Express v4.17.0, the X-Forwarded-Host could not contain multiple
values or be present more than once.
    

    // Host: "example.com:3000"
console.dir(req.hostname)
// => 'example.com'
    

  

  
    req.ip

    Contains the remote IP address of the request.

    When the trust proxy setting does not evaluate to false,
the value of this property is derived from the left-most entry in the
X-Forwarded-For header. This header can be set by the client or by the proxy.

    console.dir(req.ip)
// => '127.0.0.1'
    

  

  
    req.ips

    When the trust proxy setting does not evaluate to false,
this property contains an array of IP addresses
specified in the X-Forwarded-For request header. Otherwise, it contains an
empty array. This header can be set by the client or by the proxy.

    For example, if X-Forwarded-For is client, proxy1, proxy2, req.ips would be
["client", "proxy1", "proxy2"], where proxy2 is the furthest downstream.

  

  
    req.method

    Contains a string corresponding to the HTTP method of the request:
GET, POST, PUT, and so on.

  

  
    req.originalUrl

    
      req.url is not a native Express property, it is inherited from Node’s http module.
    

    This property is much like req.url; however, it retains the original request URL,
allowing you to rewrite req.url freely for internal routing purposes. For example,
the “mounting” feature of app.use() will rewrite req.url to strip the mount point.

    // GET /search?q=something
console.dir(req.originalUrl)
// => '/search?q=something'
    

    req.originalUrl is available both in middleware and router objects, and is a
combination of req.baseUrl and req.url. Consider following example:

    app.use('/admin', function (req, res, next) { // GET 'http://www.example.com/admin/new?sort=desc'
  console.dir(req.originalUrl) // '/admin/new?sort=desc'
  console.dir(req.baseUrl) // '/admin'
  console.dir(req.path) // '/new'
  next()
})
    

  

  
    req.params

    This property is an object containing properties mapped to the named route “parameters”. For example, if you have the route /user/:name, then the “name” property is available as req.params.name. This object defaults to {}.

    // GET /user/tj
console.dir(req.params.name)
// => 'tj'
    

    When you use a regular expression for the route definition, capture groups are provided in the array using req.params[n], where n is the nth capture group. This rule is applied to unnamed wild card matches with string routes such as /file/*:

    // GET /file/javascripts/jquery.js
console.dir(req.params[0])
// => 'javascripts/jquery.js'
    

    If you need to make changes to a key in req.params, use the app.param handler. Changes are applicable only to parameters already defined in the route path.

    Any changes made to the req.params object in a middleware or route handler will be reset.

    
       Note
      Express automatically decodes the values in req.params (using decodeURIComponent).
    

  

  
    req.path

    Contains the path part of the request URL.

    // example.com/users?sort=desc
console.dir(req.path)
// => '/users'
    

    
      When called from a middleware, the mount point is not included in req.path. See app.use() for more details.
    

  

  
    req.protocol

    Contains the request protocol string: either http or (for TLS requests) https.

    When the trust proxy setting does not evaluate to false,
this property will use the value of the X-Forwarded-Proto header field if present.
This header can be set by the client or by the proxy.

    console.dir(req.protocol)
// => 'http'
    

  

  
    req.query

    This property is an object containing a property for each query string parameter in the route.
When query parser is set to disabled, it is an empty object {}, otherwise it is the result of the configured query parser.

    
      As req.query’s shape is based on user-controlled input, all properties and values in this object are untrusted and should be validated before trusting. For example, req.query.foo.toString() may fail in multiple ways, for example foo may not be there or may not be a string, and toString may not be a function and instead a string or other user-input.
    

    The value of this property can be configured with the query parser application setting to work how your application needs it. A very popular query string parser is the qs module, and this is used by default. The qs module is very configurable with many settings, and it may be desirable to use different settings than the default to populate req.query:

    var qs = require('qs')
app.set('query parser', function (str) {
  return qs.parse(str, { /* custom options */ })
})
    

    Check out the query parser application setting documentation for other customization options.

  

  
    req.res

    This property holds a reference to the response object
that relates to this request object.

  

  
    req.route

    Contains the currently-matched route, a string.  For example:

    app.get('/user/:id?', function userIdHandler (req, res) {
  console.log(req.route)
  res.send('GET')
})
    

    Example output from the previous snippet:

    { path: '/user/:id?',
  stack:
   [ { handle: [Function: userIdHandler],
       name: 'userIdHandler',
       params: undefined,
       path: undefined,
       keys: [],
       regexp: /^\/?$/i,
       method: 'get' } ],
  methods: { get: true } }
    

  

  
    req.secure

    A Boolean property that is true if a TLS connection is established. Equivalent to:

    console.dir(req.protocol === 'https')
// => true
    

  

  
    req.signedCookies

    When using cookie-parser middleware, this property
contains signed cookies sent by the request, unsigned and ready for use. Signed cookies reside
in a different object to show developer intent; otherwise, a malicious attack could be placed on
req.cookie values (which are easy to spoof). Note that signing a cookie does not make it “hidden”
or encrypted; but simply prevents tampering (because the secret used to sign is private).

    If no signed cookies are sent, the property defaults to {}.

    // Cookie: user=tobi.CP7AWaXDfAKIRfH49dQzKJx7sKzzSoPq7/AcBBRVwlI3
console.dir(req.signedCookies.user)
// => 'tobi'
    

    For more information, issues, or concerns, see cookie-parser.

  

  
    req.stale

    Indicates whether the request is “stale,” and is the opposite of req.fresh.
For more information, see req.fresh.

    console.dir(req.stale)
// => true
    

  

  
    req.subdomains

    An array of subdomains in the domain name of the request.

    // Host: "tobi.ferrets.example.com"
console.dir(req.subdomains)
// => ['ferrets', 'tobi']
    

    The application property subdomain offset, which defaults to 2, is used for determining the
beginning of the subdomain segments. To change this behavior, change its value
using app.set.

  

  
    req.xhr

    A Boolean property that is true if the request’s X-Requested-With header field is
“XMLHttpRequest”, indicating that the request was issued by a client library such as jQuery.

    console.dir(req.xhr)
// => true
    

  

  Methods

  
    req.accepts(types)

    Checks if the specified content types are acceptable, based on the request’s Accept HTTP header field.
The method returns the best match, or if none of the specified content types is acceptable, returns
false (in which case, the application should respond with 406 "Not Acceptable").

    The type value may be a single MIME type string (such as “application/json”),
an extension name such as “json”, a comma-delimited list, or an array. For a
list or array, the method returns the best match (if any).

    // Accept: text/html
req.accepts('html')
// => "html"

// Accept: text/*, application/json
req.accepts('html')
// => "html"
req.accepts('text/html')
// => "text/html"
req.accepts(['json', 'text'])
// => "json"
req.accepts('application/json')
// => "application/json"

// Accept: text/*, application/json
req.accepts('image/png')
req.accepts('png')
// => false

// Accept: text/*;q=.5, application/json
req.accepts(['html', 'json'])
// => "json"
    

    For more information, or if you have issues or concerns, see accepts.

  

  
    req.acceptsCharsets(charset [, ...])

    Returns the first accepted charset of the specified character sets,
based on the request’s Accept-Charset HTTP header field.
If none of the specified charsets is accepted, returns false.

    For more information, or if you have issues or concerns, see accepts.

  

  
    req.acceptsEncodings(encoding [, ...])

    Returns the first accepted encoding of the specified encodings,
based on the request’s Accept-Encoding HTTP header field.
If none of the specified encodings is accepted, returns false.

    For more information, or if you have issues or concerns, see accepts.

  

  
    req.acceptsLanguages([lang, ...])

    Returns the first accepted language of the specified languages,
based on the request’s Accept-Language HTTP header field.
If none of the specified languages is accepted, returns false.

    If no lang argument is given, then req.acceptsLanguages()
returns all languages from the HTTP Accept-Language header
as an Array.

    For more information, or if you have issues or concerns, see accepts.

    Express (4.x) source: request.js line 179

    Accepts (1.3) source: index.js line 195

  

  
    req.get(field)

    Returns the specified HTTP request header field (case-insensitive match).
The Referrer and Referer fields are interchangeable.

    req.get('Content-Type')
// => "text/plain"

req.get('content-type')
// => "text/plain"

req.get('Something')
// => undefined
    

    Aliased as req.header(field).

  

  
    req.is(type)

    Returns the matching content type if the incoming request’s “Content-Type” HTTP header field
matches the MIME type specified by the type parameter. If the request has no body, returns null.
Returns false otherwise.

    // With Content-Type: text/html; charset=utf-8
req.is('html')
// => 'html'
req.is('text/html')
// => 'text/html'
req.is('text/*')
// => 'text/*'

// When Content-Type is application/json
req.is('json')
// => 'json'
req.is('application/json')
// => 'application/json'
req.is('application/*')
// => 'application/*'

req.is('html')
// => false
    

    For more information, or if you have issues or concerns, see type-is.

  

  
    req.param(name [, defaultValue])

    
      Deprecated. Use either req.params, req.body or req.query, as applicable.
    

    Returns the value of param name when present.

    // ?name=tobi
req.param('name')
// => "tobi"

// POST name=tobi
req.param('name')
// => "tobi"

// /user/tobi for /user/:name
req.param('name')
// => "tobi"
    

    Lookup is performed in the following order:

    
      req.params
      req.body
      req.query
    

    Optionally, you can specify defaultValue to set a default value if the parameter is not found in any of the request objects.

    
      Direct access to req.body, req.params, and req.query should be favoured for clarity - unless you truly accept input from each object.

      Body-parsing middleware must be loaded for req.param() to work predictably. Refer req.body for details.
    

  

  
    req.range(size[, options])

    Range header parser.

    The size parameter is the maximum size of the resource.

    The options parameter is an object that can have the following properties.

    
      
        
          Property
          Type
          Description
        
      
      
        
          combine
          Boolean
          Specify if overlapping & adjacent ranges should be combined, defaults to false. When true, ranges will be combined and returned as if they were specified that way in the header.
        
      
    

    An array of ranges will be returned or negative numbers indicating an error parsing.

    
      -2 signals a malformed header string
      -1 signals an unsatisfiable range
    

    // parse header from request
var range = req.range(1000)

// the type of the range
if (range.type === 'bytes') {
  // the ranges
  range.forEach(function (r) {
    // do something with r.start and r.end
  })
}
    

  

  Response

  The res object represents the HTTP response that an Express app sends when it gets an HTTP request.

  In this documentation and by convention,
the object is always referred to as res (and the HTTP request is req) but its actual name is determined
by the parameters to the callback function in which you’re working.

  For example:

  app.get('/user/:id', function (req, res) {
  res.send('user ' + req.params.id)
})
  

  But you could just as well have:

  app.get('/user/:id', function (request, response) {
  response.send('user ' + request.params.id)
})
  

  The res object is an enhanced version of Node’s own response object
and supports all built-in fields and methods.

  Properties

  
    res.app

    This property holds a reference to the instance of the Express application that is using the middleware.

    res.app is identical to the req.app property in the request object.

  

  
    res.headersSent

    Boolean property that indicates if the app sent HTTP headers for the response.

    app.get('/', function (req, res) {
  console.dir(res.headersSent) // false
  res.send('OK')
  console.dir(res.headersSent) // true
})
    

  

  
    res.locals

    Use this property to set variables accessible in templates rendered with res.render.
The variables set on res.locals are available within a single request-response cycle, and will not
be shared between requests.

    
      The locals object is used by view engines to render a response. The object
keys may be particularly sensitive and should not contain user-controlled
input, as it may affect the operation of the view engine or provide a path to
cross-site scripting. Consult the documentation for the used view engine for
additional considerations.
    

    In order to keep local variables for use in template rendering between requests, use
app.locals instead.

    This property is useful for exposing request-level information such as the request path name,
authenticated user, user settings, and so on to templates rendered within the application.

    app.use(function (req, res, next) {
  // Make `user` and `authenticated` available in templates
  res.locals.user = req.user
  res.locals.authenticated = !req.user.anonymous
  next()
})
    

  

  Methods

  
    res.append(field [, value])

    
       Note
      res.append() is supported by Express v4.11.0+
    

    Appends the specified value to the HTTP response header field.  If the header is not already set,
it creates the header with the specified value.  The value parameter can be a string or an array.

    
       Note
      calling res.set() after res.append() will reset the previously-set header value.
    

    res.append('Link', ['<http://localhost/>', '<http://localhost:3000/>'])
res.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly')
res.append('Warning', '199 Miscellaneous warning')
    

  

  
    res.attachment([filename])

    Sets the HTTP response Content-Disposition header field to “attachment”. If a filename is given,
then it sets the Content-Type based on the extension name via res.type(),
and sets the Content-Disposition “filename=” parameter.

    res.attachment()
// Content-Disposition: attachment

res.attachment('path/to/logo.png')
// Content-Disposition: attachment; filename="logo.png"
// Content-Type: image/png
    

  

  
    res.cookie(name, value [, options])

    Sets cookie name to value.  The value parameter may be a string or object converted to JSON.

    The options parameter is an object that can have the following properties.

    
      
        
          Property
          Type
          Description
        
      
      
        
          domain
          String
          Domain name for the cookie. Defaults to the domain name of the app.
        
        
          encode
          Function
          A synchronous function used for cookie value encoding. Defaults to encodeURIComponent.
        
        
          expires
          Date
          Expiry date of the cookie in GMT. If not specified or set to 0, creates a session cookie.
        
        
          httpOnly
          Boolean
          Flags the cookie to be accessible only by the web server.
        
        
          maxAge
          Number
          Convenient option for setting the expiry time relative to the current time in milliseconds.
        
        
          path
          String
          Path for the cookie. Defaults to “/”.
        
        
          partitioned
          Boolean
          Indicates that the cookie should be stored using partitioned storage. See Cookies Having Independent Partitioned State (CHIPS) for more details.
        
        
          priority
          String
          Value of the “Priority” Set-Cookie attribute.
        
        
          secure
          Boolean
          Marks the cookie to be used with HTTPS only.
        
        
          signed
          Boolean
          Indicates if the cookie should be signed.
        
        
          sameSite
          Boolean or String
          Value of the “SameSite” Set-Cookie attribute. More information at https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00#section-4.1.1.
        
      
    

    
      All res.cookie() does is set the HTTP Set-Cookie header with the options provided.
Any option not specified defaults to the value stated in RFC 6265.
    

    For example:

    res.cookie('name', 'tobi', { domain: '.example.com', path: '/admin', secure: true })
res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true })
    

    You can set multiple cookies in a single response by calling res.cookie multiple times, for example:

    res
  .status(201)
  .cookie('access_token', 'Bearer ' + token, {
    expires: new Date(Date.now() + 8 * 3600000) // cookie will be removed after 8 hours
  })
  .cookie('test', 'test')
  .redirect(301, '/admin')
    

    The encode option allows you to choose the function used for cookie value encoding.
Does not support asynchronous functions.

    Example use case: You need to set a domain-wide cookie for another site in your organization.
This other site (not under your administrative control) does not use URI-encoded cookie values.

    // Default encoding
res.cookie('some_cross_domain_cookie', 'http://mysubdomain.example.com', { domain: 'example.com' })
// Result: 'some_cross_domain_cookie=http%3A%2F%2Fmysubdomain.example.com; Domain=example.com; Path=/'

// Custom encoding
res.cookie('some_cross_domain_cookie', 'http://mysubdomain.example.com', { domain: 'example.com', encode: String })
// Result: 'some_cross_domain_cookie=http://mysubdomain.example.com; Domain=example.com; Path=/;'
    

    The maxAge option is a convenience option for setting “expires” relative to the current time in milliseconds.
The following is equivalent to the second example above.

    res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })
    

    You can pass an object as the value parameter; it is then serialized as JSON and parsed by bodyParser() middleware.

    res.cookie('cart', { items: [1, 2, 3] })
res.cookie('cart', { items: [1, 2, 3] }, { maxAge: 900000 })
    

    When using cookie-parser middleware, this method also
supports signed cookies. Simply include the signed option set to true.
Then res.cookie() will use the secret passed to cookieParser(secret) to sign the value.

    res.cookie('name', 'tobi', { signed: true })
    

    Later you may access this value through the req.signedCookie object.

  

  
    res.clearCookie(name [, options])

    Clears the cookie specified by name. For details about the options object, see res.cookie().

    
      Web browsers and other compliant clients will only clear the cookie if the given
options is identical to those given to res.cookie(), excluding
expires and maxAge.
    

    res.cookie('name', 'tobi', { path: '/admin' })
res.clearCookie('name', { path: '/admin' })
    

  

  
    res.download(path [, filename] [, options] [, fn])

    Transfers the file at path as an “attachment”. Typically, browsers will prompt the user for download.
By default, the Content-Disposition header “filename=” parameter is derived from the path argument, but can be overridden with the filename parameter.
If path is relative, then it will be based on the current working directory of the process or
the root option, if provided.

    
      This API provides access to data on the running file system. Ensure that either (a) the way in
which the path argument was constructed is secure if it contains user input or (b) set the root
option to the absolute path of a directory to contain access within.

      When the root option is provided, Express will validate that the relative path provided as
path will resolve within the given root option.
    

    The following table provides details on the options parameter.

    
      The optional options argument is supported by Express v4.16.0 onwards.
    

    

      
        
          
            Property
            Description
            Default
            Availability
          
        
        
          
            maxAge
            Sets the max-age property of the Cache-Control header in milliseconds or a string in ms format
            0
            4.16+
          
          
            root
            Root directory for relative filenames.
             
            4.18+
          
          
            lastModified
            Sets the Last-Modified header to the last modified date of the file on the OS. Set false to disable it.
            Enabled
            4.16+
          
          
            headers
            Object containing HTTP headers to serve with the file. The header Content-Disposition will be overridden by the filename argument.
             
            4.16+
          
          
            dotfiles
            Option for serving dotfiles. Possible values are “allow”, “deny”, “ignore”.
            “ignore”
            4.16+
          
          
            acceptRanges
            Enable or disable accepting ranged requests.
            true
            4.16+
          
          
            cacheControl
            Enable or disable setting Cache-Control response header.
            true
            4.16+
          
          
            immutable
            Enable or disable the immutable directive in the Cache-Control response header. If enabled, the maxAge option should also be specified to enable caching. The immutable directive will prevent supported clients from making conditional requests during the life of the maxAge option to check if the file has changed.
            false
            4.16+
          
        
      

    

    The method invokes the callback function fn(err) when the transfer is complete
or when an error occurs. If the callback function is specified and an error occurs,
the callback function must explicitly handle the response process either by
ending the request-response cycle, or by passing control to the next route.

    res.download('/report-12345.pdf')

res.download('/report-12345.pdf', 'report.pdf')

res.download('/report-12345.pdf', 'report.pdf', function (err) {
  if (err) {
    // Handle error, but keep in mind the response may be partially-sent
    // so check res.headersSent
  } else {
    // decrement a download credit, etc.
  }
})
    

  

  
    res.end([data[, encoding]][, callback])

    Ends the response process. This method actually comes from Node core, specifically the response.end() method of http.ServerResponse.

    Use to quickly end the response without any data. If you need to respond with data, instead use methods such as res.send() and res.json().

    res.end()
res.status(404).end()
    

  

  
    res.format(object)

    Performs content-negotiation on the Accept HTTP header on the request object, when present.
It uses req.accepts() to select a handler for the request, based on the acceptable
types ordered by their quality values. If the header is not specified, the first callback is invoked.
When no match is found, the server responds with 406 “Not Acceptable”, or invokes the default callback.

    The Content-Type response header is set when a callback is selected. However, you may alter
this within the callback using methods such as res.set() or res.type().

    The following example would respond with { "message": "hey" } when the Accept header field is set
to “application/json” or “*/json” (however if it is “*/*”, then the response will be “hey”).

    res.format({
  'text/plain': function () {
    res.send('hey')
  },

  'text/html': function () {
    res.send('<p>hey</p>')
  },

  'application/json': function () {
    res.send({ message: 'hey' })
  },

  default: function () {
    // log the request and respond with 406
    res.status(406).send('Not Acceptable')
  }
})
    

    In addition to canonicalized MIME types, you may also use extension names mapped
to these types for a slightly less verbose implementation:

    res.format({
  text: function () {
    res.send('hey')
  },

  html: function () {
    res.send('<p>hey</p>')
  },

  json: function () {
    res.send({ message: 'hey' })
  }
})
    

  

  
    res.get(field)

    Returns the HTTP response header specified by field.
The match is case-insensitive.

    res.get('Content-Type')
// => "text/plain"
    

  

  
    res.json([body])

    Sends a JSON response. This method sends a response (with the correct content-type) that is the parameter converted to a 
JSON string using JSON.stringify().

    The parameter can be any JSON type, including object, array, string, Boolean, number, or null,
and you can also use it to convert other values to JSON.

    res.json(null)
res.json({ user: 'tobi' })
res.status(500).json({ error: 'message' })
    

  

  
    res.jsonp([body])

    Sends a JSON response with JSONP support. This method is identical to res.json(),
except that it opts-in to JSONP callback support.

    res.jsonp(null)
// => callback(null)

res.jsonp({ user: 'tobi' })
// => callback({ "user": "tobi" })

res.status(500).jsonp({ error: 'message' })
// => callback({ "error": "message" })
    

    By default, the JSONP callback name is simply callback. Override this with the
jsonp callback name setting.

    The following are some examples of JSONP responses using the same code:

    // ?callback=foo
res.jsonp({ user: 'tobi' })
// => foo({ "user": "tobi" })

app.set('jsonp callback name', 'cb')

// ?cb=foo
res.status(500).jsonp({ error: 'message' })
// => foo({ "error": "message" })
    

  

  
    res.links(links)

    Joins the links provided as properties of the parameter to populate the response’s
Link HTTP header field.

    For example, the following call:

    res.links({
  next: 'http://api.example.com/users?page=2',
  last: 'http://api.example.com/users?page=5'
})
    

    Yields the following results:

    Link: <http://api.example.com/users?page=2>; rel="next",
      <http://api.example.com/users?page=5>; rel="last"
    

  

  
    res.location(path)

    Sets the response Location HTTP header to the specified path parameter.

    res.location('/foo/bar')
res.location('http://example.com')
res.location('back')
    

    
       Note
      'back' was deprecated in 4.21.0, use req.get('Referrer') || '/' as an argument instead.
    

    A path value of “back” has a special meaning, it refers to the URL specified in the Referer header of the request. If the Referer header was not specified, it refers to “/”.

    See also Security best practices: Prevent open redirect 
vulnerabilities.

    
      After encoding the URL, if not encoded already, Express passes the specified URL to the browser in the Location header,
without any validation.

      Browsers take the responsibility of deriving the intended URL from the current URL
or the referring URL, and the URL specified in the Location header; and redirect the user accordingly.
    

  

  
    res.redirect([status,] path)

    Redirects to the URL derived from the specified path, with specified status, a positive integer
that corresponds to an HTTP status code .
If not specified, status defaults to “302 “Found”.

    res.redirect('/foo/bar')
res.redirect('http://example.com')
res.redirect(301, 'http://example.com')
res.redirect('../login')
    
    Redirects can be a fully-qualified URL for redirecting to a different site:

    res.redirect('http://google.com')
    
    Redirects can be relative to the root of the host name. For example, if the
application is on http://example.com/admin/post/new, the following
would redirect to the URL http://example.com/admin:

    res.redirect('/admin')
    

    Redirects can be relative to the current URL. For example,
from http://example.com/blog/admin/ (notice the trailing slash), the following
would redirect to the URL http://example.com/blog/admin/post/new.

    res.redirect('post/new')
    

    Redirecting to post/new from http://example.com/blog/admin (no trailing slash),
will redirect to http://example.com/blog/post/new.

    If you found the above behavior confusing, think of path segments as directories
(with trailing slashes) and files, it will start to make sense.

    Path-relative redirects are also possible. If you were on
http://example.com/admin/post/new, the following would redirect to
http://example.com/admin/post:

    res.redirect('..')
    

    A back redirection redirects the request back to the referer,
defaulting to / when the referer is missing.

    res.redirect('back')
    

    
       Note
      back redirect was deprecated in 4.21.0, use req.get('Referrer') || '/' as an argument instead.
    

    See also Security best practices: Prevent open redirect 
vulnerabilities.

  

  
    res.render(view [, locals] [, callback])

    Renders a view and sends the rendered HTML string to the client.
Optional parameters:

    
      locals, an object whose properties define local variables for the view.
      callback, a callback function. If provided, the method returns both the possible error and rendered string, but does not perform an automated response. When an error occurs, the method invokes next(err) internally.
    

    The view argument is a string that is the file path of the view file to render. This can be an absolute path, or a path relative to the views setting. If the path does not contain a file extension, then the view engine setting determines the file extension. If the path does contain a file extension, then Express will load the module for the specified template engine (via require()) and render it using the loaded module’s __express function.

    For more information, see Using template engines with Express.

    
      The view argument performs file system operations like reading a file from
disk and evaluating Node.js modules, and as so for security reasons should not
contain input from the end-user.
    

    
      The locals object is used by view engines to render a response. The object
keys may be particularly sensitive and should not contain user-controlled
input, as it may affect the operation of the view engine or provide a path to
cross-site scripting. Consult the documentation for the used view engine for
additional considerations.
    

    
      The local variable cache enables view caching. Set it to true,
to cache the view during development; view caching is enabled in production by default.
    

    // send the rendered view to the client
res.render('index')

// if a callback is specified, the rendered HTML string has to be sent explicitly
res.render('index', function (err, html) {
  res.send(html)
})

// pass a local variable to the view
res.render('user', { name: 'Tobi' }, function (err, html) {
  // ...
})
    

  

  
  res.req

This property holds a reference to the request object
that relates to this response object.



  
    res.send([body])

    Sends the HTTP response.

    The body parameter can be a Buffer object, a String, an object, Boolean, or an Array.
For example:

    res.send(Buffer.from('whoop'))
res.send({ some: 'json' })
res.send('<p>some html</p>')
res.status(404).send('Sorry, we cannot find that!')
res.status(500).send({ error: 'something blew up' })
    

    This method performs many useful tasks for simple non-streaming responses:
For example, it automatically assigns the Content-Length HTTP response header field
(unless previously defined) and provides automatic HEAD and HTTP cache freshness support.

    When the parameter is a Buffer object, the method sets the Content-Type
response header field  to “application/octet-stream”, unless previously defined as shown below:

    res.set('Content-Type', 'text/html')
res.send(Buffer.from('<p>some html</p>'))
    

    When the parameter is a String, the method sets the Content-Type to “text/html”:

    res.send('<p>some html</p>')
    

    When the parameter is an Array or Object, Express responds with the JSON representation:

    res.send({ user: 'tobi' })
res.send([1, 2, 3])
    

  

  
    res.sendFile(path [, options] [, fn])

    
      res.sendFile() is supported by Express v4.8.0 onwards.
    

    Transfers the file at the given path. Sets the Content-Type response HTTP header field
based on the filename’s extension. Unless the root option is set in
the options object, path must be an absolute path to the file.

    
      This API provides access to data on the running file system. Ensure that either (a) the way in
which the path argument was constructed into an absolute path is secure if it contains user
input or (b) set the root option to the absolute path of a directory to contain access within.

      When the root option is provided, the path argument is allowed to be a relative path,
including containing ... Express will validate that the relative path provided as path will
resolve within the given root option.
    

    The following table provides details on the options parameter.

    

      
        
          
            Property
            Description
            Default
            Availability
          
        
        
          
            maxAge
            Sets the max-age property of the Cache-Control header in milliseconds or a string in ms format
            0
             
          
          
            root
            Root directory for relative filenames.
             
             
          
          
            lastModified
            Sets the Last-Modified header to the last modified date of the file on the OS. Set false to disable it.
            Enabled
            4.9.0+
          
          
            headers
            Object containing HTTP headers to serve with the file.
             
             
          
          
            dotfiles
            Option for serving dotfiles. Possible values are “allow”, “deny”, “ignore”.
            “ignore”
             
          
          
            acceptRanges
            Enable or disable accepting ranged requests.
            true
            4.14+
          
          
            cacheControl
            Enable or disable setting Cache-Control response header.
            true
            4.14+
          
          
            immutable
            Enable or disable the immutable directive in the Cache-Control response header. If enabled, the maxAge option should also be specified to enable caching. The immutable directive will prevent supported clients from making conditional requests during the life of the maxAge option to check if the file has changed.
            false
            4.16+
          
        
      

    

    The method invokes the callback function fn(err) when the transfer is complete
or when an error occurs. If the callback function is specified and an error occurs,
the callback function must explicitly handle the response process either by
ending the request-response cycle, or by passing control to the next route.

    Here is an example of using res.sendFile with all its arguments.

    app.get('/file/:name', function (req, res, next) {
  var options = {
    root: path.join(__dirname, 'public'),
    dotfiles: 'deny',
    headers: {
      'x-timestamp': Date.now(),
      'x-sent': true
    }
  }

  var fileName = req.params.name
  res.sendFile(fileName, options, function (err) {
    if (err) {
      next(err)
    } else {
      console.log('Sent:', fileName)
    }
  })
})
    

    The following example illustrates using
res.sendFile to provide fine-grained support for serving files:

    app.get('/user/:uid/photos/:file', function (req, res) {
  var uid = req.params.uid
  var file = req.params.file

  req.user.mayViewFilesFrom(uid, function (yes) {
    if (yes) {
      res.sendFile('/uploads/' + uid + '/' + file)
    } else {
      res.status(403).send("Sorry! You can't see that.")
    }
  })
})
    
    For more information, or if you have issues or concerns, see send.

  

  
    res.sendStatus(statusCode)

    Sets the response HTTP status code to statusCode and sends the registered status message as the text response body. If an unknown status code is specified, the response body will just be the code number.

    res.sendStatus(404)
    

    
      Some versions of Node.js will throw when res.statusCode is set to an
invalid HTTP status code (outside of the range 100 to 599). Consult
the HTTP server documentation for the Node.js version being used.
    

    More about HTTP Status Codes

  

  
    res.set(field [, value])

    Sets the response’s HTTP header field to value.
To set multiple fields at once, pass an object as the parameter.

    res.set('Content-Type', 'text/plain')

res.set({
  'Content-Type': 'text/plain',
  'Content-Length': '123',
  ETag: '12345'
})
    

    Aliased as res.header(field [, value]).

  

  
    res.status(code)

    Sets the HTTP status for the response.
It is a chainable alias of Node’s response.statusCode.

    res.status(403).end()
res.status(400).send('Bad Request')
res.status(404).sendFile('/absolute/path/to/404.png')
    

  

  
    res.type(type)

    Sets the Content-Type HTTP header to the MIME type as determined by the specified type. If type contains the “/” character, then it sets the Content-Type to the exact value of type, otherwise it is assumed to be a file extension and the MIME type is looked up in a mapping using the express.static.mime.lookup() method.

    res.type('.html')
// => 'text/html'
res.type('html')
// => 'text/html'
res.type('json')
// => 'application/json'
res.type('application/json')
// => 'application/json'
res.type('png')
// => 'image/png'
    

    Aliased as res.contentType(type).

  

  
    res.vary(field)

    Adds the field to the Vary response header, if it is not there already.

    res.vary('User-Agent').render('docs')
    

  

  Router

  
    A router object is an instance of middleware and routes. You can think of it
as a “mini-application,” capable only of performing middleware and routing
functions. Every Express application has a built-in app router.

    A router behaves like middleware itself, so you can use it as an argument to
app.use() or as the argument to another router’s  use() method.

    The top-level express object has a Router() method that creates a new router object.

    Once you’ve created a router object, you can add middleware and HTTP method routes (such as get, put, post,
and so on) to it just like an application.  For example:

    // invoked for any requests passed to this router
router.use(function (req, res, next) {
  // .. some logic here .. like any other middleware
  next()
})

// will handle any request that ends in /events
// depends on where the router is "use()'d"
router.get('/events', function (req, res, next) {
  // ..
})
    

    You can then use a router for a particular root URL in this way separating your routes into files or even mini-apps.

    // only requests to /calendar/* will be sent to our "router"
app.use('/calendar', router)
    

    Keep in mind that any middleware applied to a router will run for all requests on that router’s path, even those that aren’t part of the router.

  

  Methods

  
    router.all(path, [callback, ...] callback)

    This method is just like the router.METHOD() methods, except that it matches all HTTP methods (verbs).

    This method is extremely useful for
mapping “global” logic for specific path prefixes or arbitrary matches.
For example, if you placed the following route at the top of all other
route definitions, it would require that all routes from that point on
would require authentication, and automatically load a user. Keep in mind
that these callbacks do not have to act as end points; loadUser
can perform a task, then call next() to continue matching subsequent
routes.

    router.all('*', requireAuthentication, loadUser)
    

    Or the equivalent:

    router.all('*', requireAuthentication)
router.all('*', loadUser)
    

    Another example of this is white-listed “global” functionality. Here
the example is much like before, but it only restricts paths prefixed with
“/api”:

    router.all('/api/*', requireAuthentication)
    

  

  
    router.METHOD(path, [callback, ...] callback)

    The router.METHOD() methods provide the routing functionality in Express,
where METHOD is one of the HTTP methods, such as GET, PUT, POST, and so on,
in lowercase.  Thus, the actual methods are router.get(), router.post(),
router.put(), and so on.

    
      The router.get() function is automatically called for the HTTP HEAD method in
  addition to the GET method if router.head() was not called for the
  path before router.get().
    

    You can provide multiple callbacks, and all are treated equally, and behave just
like middleware, except that these callbacks may invoke next('route')
to bypass the remaining route callback(s).  You can use this mechanism to perform
pre-conditions on a route then pass control to subsequent routes when there is no
reason to proceed with the route matched.

    The following snippet illustrates the most simple route definition possible.
Express translates the path strings to regular expressions, used internally
to match incoming requests. Query strings are not considered when performing
these matches, for example “GET /” would match the following route, as would
“GET /?name=tobi”.

    router.get('/', function (req, res) {
  res.send('hello world')
})
    

    You can also use regular expressions—useful if you have very specific
constraints, for example the following would match “GET /commits/71dbb9c” as well
as “GET /commits/71dbb9c..4c084f9”.

    router.get(/^\/commits\/(\w+)(?:\.\.(\w+))?$/, function (req, res) {
  var from = req.params[0]
  var to = req.params[1] || 'HEAD'
  res.send('commit range ' + from + '..' + to)
})
    

  

  
    router.param(name, callback)

    Adds callback triggers to route parameters, where name is the name of the parameter and callback is the callback function. Although name is technically optional, using this method without it is deprecated starting with Express v4.11.0 (see below).

    The parameters of the callback function are:

    
      req, the request object.
      res, the response object.
      next, indicating the next middleware function.
      The value of the name parameter.
      The name of the parameter.
    

    
      Unlike app.param(), router.param() does not accept an array of route parameters.
    

    For example, when :user is present in a route path, you may map user loading logic to automatically provide req.user to the route, or perform validations on the parameter input.

    router.param('user', function (req, res, next, id) {
  // try to get the user details from the User model and attach it to the request object
  User.find(id, function (err, user) {
    if (err) {
      next(err)
    } else if (user) {
      req.user = user
      next()
    } else {
      next(new Error('failed to load user'))
    }
  })
})
    

    Param callback functions are local to the router on which they are defined. They are not inherited by mounted apps or routers, nor are they triggered for route parameters inherited from parent routers. Hence, param callbacks defined on router will be triggered only by route parameters defined on router routes.

    A param callback will be called only once in a request-response cycle, even if the parameter is matched in multiple routes, as shown in the following examples.

    router.param('id', function (req, res, next, id) {
  console.log('CALLED ONLY ONCE')
  next()
})

router.get('/user/:id', function (req, res, next) {
  console.log('although this matches')
  next()
})

router.get('/user/:id', function (req, res) {
  console.log('and this matches too')
  res.end()
})
    

    On GET /user/42, the following is printed:

    CALLED ONLY ONCE
although this matches
and this matches too
    

    
      The following section describes router.param(callback), which is deprecated as of v4.11.0.
    

    The behavior of the router.param(name, callback) method can be altered entirely by passing only a function to router.param(). This function is a custom implementation of how router.param(name, callback) should behave - it accepts two parameters and must return a middleware.

    The first parameter of this function is the name of the URL parameter that should be captured, the second parameter can be any JavaScript object which might be used for returning the middleware implementation.

    The middleware returned by the function decides the behavior of what happens when a URL parameter is captured.

    In this example, the router.param(name, callback) signature is modified to router.param(name, accessId). Instead of accepting a name and a callback, router.param() will now accept a name and a number.

    var express = require('express')
var app = express()
var router = express.Router()

// customizing the behavior of router.param()
router.param(function (param, option) {
  return function (req, res, next, val) {
    if (val === option) {
      next()
    } else {
      res.sendStatus(403)
    }
  }
})

// using the customized router.param()
router.param('id', '1337')

// route to trigger the capture
router.get('/user/:id', function (req, res) {
  res.send('OK')
})

app.use(router)

app.listen(3000, function () {
  console.log('Ready')
})
    

    In this example, the router.param(name, callback) signature remains the same, but instead of a middleware callback, a custom data type checking function has been defined to validate the data type of the user id.

    router.param(function (param, validator) {
  return function (req, res, next, val) {
    if (validator(val)) {
      next()
    } else {
      res.sendStatus(403)
    }
  }
})

router.param('id', function (candidate) {
  return !isNaN(parseFloat(candidate)) && isFinite(candidate)
})
    

  

  
    router.route(path)

    Returns an instance of a single route which you can then use to handle HTTP verbs
with optional middleware. Use router.route() to avoid duplicate route naming and
thus typing errors.

    Building on the router.param() example above, the following code shows how to use
router.route() to specify various HTTP method handlers.

    var router = express.Router()

router.param('user_id', function (req, res, next, id) {
  // sample user, would actually fetch from DB, etc...
  req.user = {
    id: id,
    name: 'TJ'
  }
  next()
})

router.route('/users/:user_id')
  .all(function (req, res, next) {
    // runs for all HTTP verbs first
    // think of it as route specific middleware!
    next()
  })
  .get(function (req, res, next) {
    res.json(req.user)
  })
  .put(function (req, res, next) {
    // just an example of maybe updating the user
    req.user.name = req.params.name
    // save user ... etc
    res.json(req.user)
  })
  .post(function (req, res, next) {
    next(new Error('not implemented'))
  })
  .delete(function (req, res, next) {
    next(new Error('not implemented'))
  })
    

    This approach re-uses the single /users/:user_id path and adds handlers for
various HTTP methods.

    
       Note
      When you use router.route(), middleware ordering is based on when the route is created, not when method handlers are added to the route.  For this purpose, you can consider method handlers to belong to the route to which they were added.
    

  

  
    router.use([path], [function, ...] function)

    Uses the specified middleware function or functions, with optional mount path path, that defaults to “/”.

    This method is similar to app.use(). A simple example and use case is described below.
See app.use() for more information.

    Middleware is like a plumbing pipe: requests start at the first middleware function defined
and work their way “down” the middleware stack processing for each path they match.

    var express = require('express')
var app = express()
var router = express.Router()

// simple logger for this router's requests
// all requests to this router will first hit this middleware
router.use(function (req, res, next) {
  console.log('%s %s %s', req.method, req.url, req.path)
  next()
})

// this will only be invoked if the path starts with /bar from the mount point
router.use('/bar', function (req, res, next) {
  // ... maybe some additional /bar logging ...
  next()
})

// always invoked
router.use(function (req, res, next) {
  res.send('Hello World')
})

app.use('/foo', router)

app.listen(3000)
    

    The “mount” path is stripped and is not visible to the middleware function.
The main effect of this feature is that a mounted middleware function may operate without
code changes regardless of its “prefix” pathname.

    The order in which you define middleware with router.use() is very important.
They are invoked sequentially, thus the order defines middleware precedence. For example,
usually a logger is the very first middleware you would use, so that every request gets logged.

    var logger = require('morgan')
var path = require('path')

router.use(logger())
router.use(express.static(path.join(__dirname, 'public')))
router.use(function (req, res) {
  res.send('Hello')
})
    

    Now suppose you wanted to ignore logging requests for static files, but to continue
logging routes and middleware defined after logger().  You would simply move the call to express.static() to the top,
before adding the logger middleware:

    router.use(express.static(path.join(__dirname, 'public')))
router.use(logger())
router.use(function (req, res) {
  res.send('Hello')
})
    

    Another example is serving files from multiple directories,
giving precedence to “./public” over the others:

    router.use(express.static(path.join(__dirname, 'public')))
router.use(express.static(path.join(__dirname, 'files')))
router.use(express.static(path.join(__dirname, 'uploads')))
    

    The router.use() method also supports named parameters so that your mount points
for other routers can benefit from preloading using named parameters.

    NOTE: Although these middleware functions are added via a particular router, when
they run is defined by the path they are attached to (not the router). Therefore,
middleware added via one router may run for other routers if its routes
match. For example, this code shows two different routers mounted on the same path:

    var authRouter = express.Router()
var openRouter = express.Router()

authRouter.use(require('./authenticate').basic(usersdb))

authRouter.get('/:user_id/edit', function (req, res, next) {
  // ... Edit user UI ...
})
openRouter.get('/', function (req, res, next) {
  // ... List users ...
})
openRouter.get('/:user_id', function (req, res, next) {
  // ... View user ...
})

app.use('/users', authRouter)
app.use('/users', openRouter)
    

    Even though the authentication middleware was added via the authRouter it will run on the routes defined by the openRouter as well since both routers were mounted on /users.  To avoid this behavior, use different paths for each router.

  



              
    
    Edit this page\n\nOn this page
          On this page ►

    express()
    
        Methods
        express.json()
        express.raw()
        express.Router()
        express.static()
        express.text()
        express.urlencoded()
    
    

    Application
        
            Properties
            
            app.locals
            
            app.mountpath
            
            Events
            
            mount
            
            Methods
            
            app.all()
            
            app.delete()
            
            app.disable()
            
            app.disabled()
            
            app.enable()
            
            app.enabled()
            
            app.engine()
            
            app.get()
            
            app.get()
            
            app.listen()
            
            app.METHOD()
            
            app.param()
            
            app.path()
            
            app.post()
            
            app.put()
            
            app.render()
            
            app.route()
            
            app.set()
            
            app.use()
            
        
    
    Request
        
            Properties
            
            req.app
            
            req.baseUrl
            
            req.body
            
            req.cookies
            
            req.fresh
            
            req.hostname
            
            req.ip
            
            req.ips
            
            req.method
            
            req.originalUrl
            
            req.params
            
            req.path
            
            req.protocol
            
            req.query
            
            req.res
            
            req.route
            
            req.secure
            
            req.signedCookies
            
            req.stale
            
            req.subdomains
            
            req.xhr
            
            Methods
            
            req.accepts()
            
            req.acceptsCharsets()
            
            req.acceptsEncodings()
            
            req.acceptsLanguages()
            
            req.get()
            
            req.is()
            
            req.param()
            
            req.range()
            
        
    
    Response
        
            Properties
            
            res.app
            
            res.headersSent
            
            res.locals
            
            Methods
            
            res.append()
            
            res.attachment()
            
            res.cookie()
            
            res.clearCookie()
            
            res.download()
            
            res.end()
            
            res.format()
            
            res.get()
            
            res.json()
            
            res.jsonp()
            
            res.links()
            
            res.location()
            
            res.redirect()
            
            res.render()
            
            res.send()
            
            res.sendFile()
            
            res.sendStatus()
            
            res.set()
            
            res.status()
            
            res.type()
            
            res.vary()
            
        
    
    Router
        
            Methods
            
            router.all()
            
            router.METHOD()
            
            router.param()
            
            router.route()
            
            router.use()
            
        
    



        
      
      
        

  4.x API

  
     Note

    Express 4.0 requires Node.js 0.10 or higher.
    

  

  express()

  Creates an Express application. The express() function is a top-level function exported by the express module.

  var express = require('express')
var app = express()
  

  Methods

  
    express.json([options])

    
      This middleware is available in Express v4.16.0 onwards.
    

    This is a built-in middleware function in Express. It parses incoming requests
with JSON payloads and is based on
body-parser.

    Returns middleware that only parses JSON and only looks at requests where
the Content-Type header matches the type option. This parser accepts any
Unicode encoding of the body and supports automatic inflation of gzip and
deflate encodings.

    A new body object containing the parsed data is populated on the request
object after the middleware (i.e. req.body), or an empty object ({}) if
there was no body to parse, the Content-Type was not matched, or an error
occurred.

    
      As req.body’s shape is based on user-controlled input, all properties and
values in this object are untrusted and should be validated before trusting.
For example, req.body.foo.toString() may fail in multiple ways, for example
foo may not be there or may not be a string, and toString may not be a
function and instead a string or other user-input.
    

    The following table describes the properties of the optional options object.

    
      
        
          Property
          Description
          Type
          Default
        
      
      
        
          inflate
          Enables or disables handling deflated (compressed) bodies; when disabled, deflated bodies are rejected.
          Boolean
          true
        
        
          limit
          Controls the maximum request body size. If this is a number, then the value specifies the number of bytes; if it is a string, the value is passed to the bytes library for parsing.
          Mixed
          "100kb"
        
        
          reviver
          The reviver option is passed directly to JSON.parse as the second argument. You can find more information on this argument in the MDN documentation about JSON.parse.
          Function
          null
        
        
          strict
          Enables or disables only accepting arrays and objects; when disabled will accept anything JSON.parse accepts.
          Boolean
          true
        
        
          type
          This is used to determine what media type the middleware will parse. This option can be a string, array of strings, or a function. If not a function, type option is passed directly to the type-is library and this can be an extension name (like json), a mime type (like application/json), or a mime type with a wildcard (like */* or */json). If a function, the type option is called as fn(req) and the request is parsed if it returns a truthy value.
          Mixed
          "application/json"
        
        
          verify
          This option, if supplied, is called as verify(req, res, buf, encoding), where buf is a Buffer of the raw request body and encoding is the encoding of the request. The parsing can be aborted by throwing an error.
          Function
          undefined
        
      
    

  

  
    express.raw([options])

    
      This middleware is available in Express v4.17.0 onwards.
    

    This is a built-in middleware function in Express. It parses incoming request
payloads into a Buffer and is based on
body-parser.

    Returns middleware that parses all bodies as a Buffer and only looks at requests
where the Content-Type header matches the type option. This parser accepts
any Unicode encoding of the body and supports automatic inflation of gzip and
deflate encodings.

    A new body Buffer containing the parsed data is populated on the request
object after the middleware (i.e. req.body), or an empty object ({}) if
there was no body to parse, the Content-Type was not matched, or an error
occurred.

    
      As req.body’s shape is based on user-controlled input, all properties and
values in this object are untrusted and should be validated before trusting.
For example, req.body.toString() may fail in multiple ways, for example
stacking multiple parsers req.body may be from a different parser. Testing
that req.body is a Buffer before calling buffer methods is recommended.
    

    The following table describes the properties of the optional options object.

    
      
        
          Property
          Description
          Type
          Default
        
      
      
        
          inflate
          Enables or disables handling deflated (compressed) bodies; when disabled, deflated bodies are rejected.
          Boolean
          true
        
        
          limit
          Controls the maximum request body size. If this is a number, then the value specifies the number of bytes; if it is a string, the value is passed to the bytes library for parsing.
          Mixed
          "100kb"
        
        
          type
          This is used to determine what media type the middleware will parse. This option can be a string, array of strings, or a function. If not a function, type option is passed directly to the type-is library and this can be an extension name (like bin), a mime type (like application/octet-stream), or a mime type with a wildcard (like */* or application/*). If a function, the type option is called as fn(req) and the request is parsed if it returns a truthy value.
          Mixed
          "application/octet-stream"
        
        
          verify
          This option, if supplied, is called as verify(req, res, buf, encoding), where buf is a Buffer of the raw request body and encoding is the encoding of the request. The parsing can be aborted by throwing an error.
          Function
          undefined
        
      
    

  

  
    express.Router([options])

    Creates a new router object.

    var router = express.Router([options])
    

    The optional options parameter specifies the behavior of the router.

    

      
        
          
            Property
            Description
            Default
            Availability
          
        
        
          
            caseSensitive
            Enable case sensitivity.
            Disabled by default, treating “/Foo” and “/foo” as the same.
             
          
          
            mergeParams
            Preserve the req.params values from the parent router. If the parent and the child have conflicting param names, the child’s value take precedence.
            false
            4.5.0+
          
          
            strict
            Enable strict routing.
            Disabled by default, “/foo” and “/foo/” are treated the same by the router.
             
          
        
      

    

    You can add middleware and HTTP method routes (such as get, put, post, and
so on) to router just like an application.

    For more information, see Router.

  

  
    express.static(root, [options])

    This is a built-in middleware function in Express.
It serves static files and is based on  serve-static.

    
       Note

      For best results, use a reverse proxy cache to improve performance of serving static assets.

    

    The root argument specifies the root directory from which to serve static assets.
The function determines the file to serve by combining req.url with the provided root directory.
When a file is not found, instead of sending a 404 response, it calls next()
to move on to the next middleware, allowing for stacking and fall-backs.

    The following table describes the properties of the options object.
See also the example below.

    
      
        
          Property
          Description
          Type
          Default
        
      
      
        
          dotfiles
          Determines how dotfiles (files or directories that begin with a dot “.”) are treated.  See dotfiles below.
          String
          undefined
        
        
          etag
          Enable or disable etag generation NOTE: express.static always sends weak ETags.
          Boolean
          true
        
        
          extensions
          Sets file extension fallbacks: If a file is not found, search for files with the specified extensions and serve the first one found. Example: ['html', 'htm'].
          Mixed
          false
        
        
          fallthrough
          Let client errors fall-through as unhandled requests, otherwise forward a client error. See fallthrough below.
          Boolean
          true
        
        
          immutable
          Enable or disable the immutable directive in the Cache-Control response header. If enabled, the maxAge option should also be specified to enable caching. The immutable directive will prevent supported clients from making conditional requests during the life of the maxAge option to check if the file has changed.
          Boolean
          false
        
        
          index
          Sends the specified directory index file. Set to false to disable directory indexing.
          Mixed
          “index.html”
        
        
          lastModified
          Set the Last-Modified header to the last modified date of the file on the OS.
          Boolean
          true
        
        
          maxAge
          Set the max-age property of the Cache-Control header in milliseconds or a string in ms format.
          Number
          0
        
        
          redirect
          Redirect to trailing “/” when the pathname is a directory.
          Boolean
          true
        
        
          setHeaders
          Function for setting HTTP headers to serve with the file. See setHeaders below.
          Function
           
        
      
    

    For more information, see Serving static files in Express.
and Using middleware - Built-in middleware.

    dotfiles

    Possible values for this option are:

    
      “allow” - No special treatment for dotfiles.
      “deny” - Deny a request for a dotfile, respond with 403, then call next().
      “ignore” - Act as if the dotfile does not exist, respond with 404, then call next().
      undefined - Act as ignore, except that files in a directory that begins with a dot are NOT ignored.
    

    fallthrough

    When this option is true, client errors such as a bad request or a request to a non-existent
file will cause this middleware to simply call next() to invoke the next middleware in the stack.
When false, these errors (even 404s), will invoke next(err).

    Set this option to true so you can map multiple physical directories
to the same web address or for routes to fill in non-existent files.

    Use false if you have mounted this middleware at a path designed
to be strictly a single file system directory, which allows for short-circuiting 404s
for less overhead. This middleware will also reply to all methods.

    setHeaders

    For this option, specify a function to set custom response headers. Alterations to the headers must occur synchronously.

    The signature of the function is:

    fn(res, path, stat)
    

    Arguments:

    
      res, the response object.
      path, the file path that is being sent.
      stat, the stat object of the file that is being sent.
    

    Example of express.static

    Here is an example of using the express.static middleware function with an elaborate options object:

    var options = {
  dotfiles: 'ignore',
  etag: false,
  extensions: ['htm', 'html'],
  index: false,
  maxAge: '1d',
  redirect: false,
  setHeaders: function (res, path, stat) {
    res.set('x-timestamp', Date.now())
  }
}

app.use(express.static('public', options))
    

  

  
    express.text([options])

    
      This middleware is available in Express v4.17.0 onwards.
    

    This is a built-in middleware function in Express. It parses incoming request
payloads into a string and is based on
body-parser.

    Returns middleware that parses all bodies as a string and only looks at requests
where the Content-Type header matches the type option. This parser accepts
any Unicode encoding of the body and supports automatic inflation of gzip and
deflate encodings.

    A new body string containing the parsed data is populated on the request
object after the middleware (i.e. req.body), or an empty object ({}) if
there was no body to parse, the Content-Type was not matched, or an error
occurred.

    
      As req.body’s shape is based on user-controlled input, all properties and
values in this object are untrusted and should be validated before trusting.
For example, req.body.trim() may fail in multiple ways, for example
stacking multiple parsers req.body may be from a different parser. Testing
that req.body is a string before calling string methods is recommended.
    

    The following table describes the properties of the optional options object.

    
      
        
          Property
          Description
          Type
          Default
        
      
      
        
          defaultCharset
          Specify the default character set for the text content if the charset is not specified in the Content-Type header of the request.
          String
          "utf-8"
        
        
          inflate
          Enables or disables handling deflated (compressed) bodies; when disabled, deflated bodies are rejected.
          Boolean
          true
        
        
          limit
          Controls the maximum request body size. If this is a number, then the value specifies the number of bytes; if it is a string, the value is passed to the bytes library for parsing.
          Mixed
          "100kb"
        
        
          type
          This is used to determine what media type the middleware will parse. This option can be a string, array of strings, or a function. If not a function, type option is passed directly to the type-is library and this can be an extension name (like txt), a mime type (like text/plain), or a mime type with a wildcard (like */* or text/*). If a function, the type option is called as fn(req) and the request is parsed if it returns a truthy value.
          Mixed
          "text/plain"
        
        
          verify
          This option, if supplied, is called as verify(req, res, buf, encoding), where buf is a Buffer of the raw request body and encoding is the encoding of the request. The parsing can be aborted by throwing an error.
          Function
          undefined
        
      
    

  

  
    express.urlencoded([options])

    
      This middleware is available in Express v4.16.0 onwards.
    

    This is a built-in middleware function in Express. It parses incoming requests
with urlencoded payloads and is based on body-parser.

    Returns middleware that only parses urlencoded bodies and only looks at
requests where the Content-Type header matches the type option. This
parser accepts only UTF-8 encoding of the body and supports automatic
inflation of gzip and deflate encodings.

    A new body object containing the parsed data is populated on the request
object after the middleware (i.e. req.body), or an empty object ({}) if
there was no body to parse, the Content-Type was not matched, or an error
occurred. This object will contain key-value pairs, where the value can be
a string or array (when extended is false), or any type (when extended
is true).

    
      As req.body’s shape is based on user-controlled input, all properties and
values in this object are untrusted and should be validated before trusting.
For example, req.body.foo.toString() may fail in multiple ways, for example
foo may not be there or may not be a string, and toString may not be a
function and instead a string or other user-input.
    

    The following table describes the properties of the optional options object.

    
      
        
          Property
          Description
          Type
          Default
        
      
      
        
          extended
          This option allows to choose between parsing the URL-encoded data with the querystring library (when false) or the qs library (when true). The “extended” syntax allows for rich objects and arrays to be encoded into the URL-encoded format, allowing for a JSON-like experience with URL-encoded. For more information, please see the qs library.
          Boolean
          true
        
        
          inflate
          Enables or disables handling deflated (compressed) bodies; when disabled, deflated bodies are rejected.
          Boolean
          true
        
        
          limit
          Controls the maximum request body size. If this is a number, then the value specifies the number of bytes; if it is a string, the value is passed to the bytes library for parsing.
          Mixed
          "100kb"
        
        
          parameterLimit
          This option controls the maximum number of parameters that are allowed in the URL-encoded data. If a request contains more parameters than this value, an error will be raised.
          Number
          1000
        
        
          type
          This is used to determine what media type the middleware will parse. This option can be a string, array of strings, or a function. If not a function, type option is passed directly to the type-is library and this can be an extension name (like urlencoded), a mime type (like application/x-www-form-urlencoded), or a mime type with a wildcard (like */x-www-form-urlencoded). If a function, the type option is called as fn(req) and the request is parsed if it returns a truthy value.
          Mixed
          "application/x-www-form-urlencoded"
        
        
          verify
          This option, if supplied, is called as verify(req, res, buf, encoding), where buf is a Buffer of the raw request body and encoding is the encoding of the request. The parsing can be aborted by throwing an error.
          Function
          undefined
        
      
    

  

  Application

  The app object conventionally denotes the Express application.
Create it by calling the top-level express() function exported by the Express module:

  var express = require('express')
var app = express()

app.get('/', function (req, res) {
  res.send('hello world')
})

app.listen(3000)
  

  The app object has methods for

  
    Routing HTTP requests; see for example, app.METHOD and app.param.
    Configuring middleware; see app.route.
    Rendering HTML views; see app.render.
    Registering a template engine; see app.engine.
  

  It also has settings (properties) that affect how the application behaves;
for more information, see Application settings.

  
    The Express application object can be referred from the request object and the response object as req.app, and res.app, respectively.
  

  Properties

  
    app.locals

    The app.locals object has properties that are local variables within the application,
and will be available in templates rendered with res.render.

    
      The locals object is used by view engines to render a response. The object
keys may be particularly sensitive and should not contain user-controlled
input, as it may affect the operation of the view engine or provide a path to
cross-site scripting. Consult the documentation for the used view engine for
additional considerations.
    

    console.dir(app.locals.title)
// => 'My App'

console.dir(app.locals.email)
// => '[email protected]'
    

    Once set, the value of app.locals properties persist throughout the life of the application,
in contrast with res.locals properties that
are valid only for the lifetime of the request.

    You can access local variables in templates rendered within the application.
This is useful for providing helper functions to templates, as well as application-level data.
Local variables are available in middleware via req.app.locals (see req.app)

    app.locals.title = 'My App'
app.locals.strftime = require('strftime')
app.locals.email = '[email protected]'
    

  

  
    app.mountpath

    The app.mountpath property contains one or more path patterns on which a sub-app was mounted.

    
      A sub-app is an instance of express that may be used for handling the request to a route.
    

    var express = require('express')

var app = express() // the main app
var admin = express() // the sub app

admin.get('/', function (req, res) {
  console.log(admin.mountpath) // /admin
  res.send('Admin Homepage')
})

app.use('/admin', admin) // mount the sub app
    

    It is similar to the baseUrl property of the req object, except req.baseUrl
returns the matched URL path, instead of the matched patterns.

    If a sub-app is mounted on multiple path patterns, app.mountpath returns the list of
patterns it is mounted on, as shown in the following example.

    var admin = express()

admin.get('/', function (req, res) {
  console.dir(admin.mountpath) // [ '/adm*n', '/manager' ]
  res.send('Admin Homepage')
})

var secret = express()
secret.get('/', function (req, res) {
  console.log(secret.mountpath) // /secr*t
  res.send('Admin Secret')
})

admin.use('/secr*t', secret) // load the 'secret' router on '/secr*t', on the 'admin' sub app
app.use(['/adm*n', '/manager'], admin) // load the 'admin' router on '/adm*n' and '/manager', on the parent app
    

  

  Events

  
    app.on('mount', callback(parent))

    The mount event is fired on a sub-app, when it is mounted on a parent app. The parent app is passed to the callback function.

    
      NOTE

      Sub-apps will:

      
        Not inherit the value of settings that have a default value.  You must set the value in the sub-app.
        Inherit the value of settings with no default value.
      

      For details, see Application settings.
    

    var admin = express()

admin.on('mount', function (parent) {
  console.log('Admin Mounted')
  console.log(parent) // refers to the parent app
})

admin.get('/', function (req, res) {
  res.send('Admin Homepage')
})

app.use('/admin', admin)
    

  

  Methods

  
    app.all(path, callback [, callback ...])

    This method is like the standard app.METHOD() methods,
except it matches all HTTP verbs.

     Arguments

    

Argument 
 Description 
 Default 



path

The path for which the middleware function is invoked; can be any of:

A string representing a path.
A path pattern.
A regular expression pattern to match paths.
An array of combinations of any of the above.


For examples, see Path examples.

'/' (root path)



 callback

Callback functions; can be:

A middleware function.
A series of middleware functions (separated by commas).
An array of middleware functions.
A combination of all of the above.


You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke next('route') to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.

Since router and app implement the middleware interface,
you can use them as you would any other middleware function.

For examples, see Middleware callback function examples.


 None 


    Examples

    The following callback is executed for requests to /secret whether using
GET, POST, PUT, DELETE, or any other HTTP request method:

    app.all('/secret', function (req, res, next) {
  console.log('Accessing the secret section ...')
  next() // pass control to the next handler
})
    

    The app.all() method is useful for mapping “global” logic for specific path prefixes or arbitrary matches.  For example, if you put the following at the top of all other
route definitions, it requires that all routes from that point on
require authentication, and automatically load a user. Keep in mind
that these callbacks do not have to act as end-points: loadUser
can perform a task, then call next() to continue matching subsequent
routes.

    app.all('*', requireAuthentication, loadUser)
    

    Or the equivalent:

    app.all('*', requireAuthentication)
app.all('*', loadUser)
    

    Another example is white-listed “global” functionality.
The example is similar to the ones above, but it only restricts paths that start with
“/api”:

    app.all('/api/*', requireAuthentication)
    

  

  
    app.delete(path, callback [, callback ...])

    Routes HTTP DELETE requests to the specified path with the specified callback functions.
For more information, see the routing guide.

     Arguments

    

Argument 
 Description 
 Default 



path

The path for which the middleware function is invoked; can be any of:

A string representing a path.
A path pattern.
A regular expression pattern to match paths.
An array of combinations of any of the above.


For examples, see Path examples.

'/' (root path)



 callback

Callback functions; can be:

A middleware function.
A series of middleware functions (separated by commas).
An array of middleware functions.
A combination of all of the above.


You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke next('route') to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.

Since router and app implement the middleware interface,
you can use them as you would any other middleware function.

For examples, see Middleware callback function examples.


 None 


    Example

    app.delete('/', function (req, res) {
  res.send('DELETE request to homepage')
})
    

  

  
    app.disable(name)

    Sets the Boolean setting name to false, where name is one of the properties from the app settings table.
Calling app.set('foo', false) for a Boolean property is the same as calling app.disable('foo').

    For example:

    app.disable('trust proxy')
app.get('trust proxy')
// => false
    

  

  
    app.disabled(name)

    Returns true if the Boolean setting name is disabled (false), where name is one of the properties from
the app settings table.

    app.disabled('trust proxy')
// => true

app.enable('trust proxy')
app.disabled('trust proxy')
// => false
    

  

  
    app.enable(name)

    Sets the Boolean setting name to true, where name is one of the properties from the app settings table.
Calling app.set('foo', true) for a Boolean property is the same as calling app.enable('foo').

    app.enable('trust proxy')
app.get('trust proxy')
// => true
    

  

  
    app.enabled(name)

    Returns true if the setting name is enabled (true), where name is one of the
properties from the app settings table.

    app.enabled('trust proxy')
// => false

app.enable('trust proxy')
app.enabled('trust proxy')
// => true
    

  

  
    app.engine(ext, callback)

    Registers the given template engine callback as ext.

    By default, Express will require() the engine based on the file extension.
For example, if you try to render a “foo.pug” file, Express invokes the
following internally, and caches the require() on subsequent calls to increase
performance.

    app.engine('pug', require('pug').__express)
    

    Use this method for engines that do not provide .__express out of the box,
or if you wish to “map” a different extension to the template engine.

    For example, to map the EJS template engine to “.html” files:

    app.engine('html', require('ejs').renderFile)
    

    In this case, EJS provides a .renderFile() method with
the same signature that Express expects: (path, options, callback),
though note that it aliases this method as ejs.__express internally
so if you’re using “.ejs” extensions you don’t need to do anything.

    Some template engines do not follow this convention.  The
consolidate.js library maps Node template engines to follow this convention,
so they work seamlessly with Express.

    var engines = require('consolidate')
app.engine('haml', engines.haml)
app.engine('html', engines.hogan)
    

  

  
    app.get(name)

    Returns the value of name app setting, where name is one of the strings in the
app settings table. For example:

    app.get('title')
// => undefined

app.set('title', 'My Site')
app.get('title')
// => "My Site"
    

  

  
    app.get(path, callback [, callback ...])

    Routes HTTP GET requests to the specified path with the specified callback functions.

     Arguments

    

Argument 
 Description 
 Default 



path

The path for which the middleware function is invoked; can be any of:

A string representing a path.
A path pattern.
A regular expression pattern to match paths.
An array of combinations of any of the above.


For examples, see Path examples.

'/' (root path)



 callback

Callback functions; can be:

A middleware function.
A series of middleware functions (separated by commas).
An array of middleware functions.
A combination of all of the above.


You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke next('route') to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.

Since router and app implement the middleware interface,
you can use them as you would any other middleware function.

For examples, see Middleware callback function examples.


 None 


    For more information, see the routing guide.

    Example

    app.get('/', function (req, res) {
  res.send('GET request to homepage')
})
    

  

  
    app.listen(path, [callback])

    Starts a UNIX socket and listens for connections on the given path.
This method is identical to Node’s http.Server.listen().

    var express = require('express')
var app = express()
app.listen('/tmp/sock')
    

    app.listen([port[, host[, backlog]]][, callback])

    Binds and listens for connections on the specified host and port.
This method is identical to Node’s http.Server.listen().

    If port is omitted or is 0, the operating system will assign an arbitrary unused
port, which is useful for cases like automated tasks (tests, etc.).

    var express = require('express')
var app = express()
app.listen(3000)
    

    The app returned by express() is in fact a JavaScript
Function, designed to be passed to Node’s HTTP servers as a callback
to handle requests. This makes it easy to provide both HTTP and HTTPS versions of
your app with the same code base, as the app does not inherit from these
(it is simply a callback):

    var express = require('express')
var https = require('https')
var http = require('http')
var app = express()

http.createServer(app).listen(80)
https.createServer(options, app).listen(443)
    

    The app.listen() method returns an http.Server object and (for HTTP) is a convenience method for the following:

    app.listen = function () {
  var server = http.createServer(this)
  return server.listen.apply(server, arguments)
}
    

    
       Note
      All the forms of Node’s
http.Server.listen()
method are in fact actually supported.
    

  

  
    app.METHOD(path, callback [, callback ...])

    Routes an HTTP request, where METHOD is the HTTP method of the request, such as GET,
PUT, POST, and so on, in lowercase. Thus, the actual methods are app.get(),
app.post(), app.put(), and so on.  See Routing methods below for the complete list.

     Arguments

    

Argument 
 Description 
 Default 



path

The path for which the middleware function is invoked; can be any of:

A string representing a path.
A path pattern.
A regular expression pattern to match paths.
An array of combinations of any of the above.


For examples, see Path examples.

'/' (root path)



 callback

Callback functions; can be:

A middleware function.
A series of middleware functions (separated by commas).
An array of middleware functions.
A combination of all of the above.


You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke next('route') to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.

Since router and app implement the middleware interface,
you can use them as you would any other middleware function.

For examples, see Middleware callback function examples.


 None 


    Routing methods

    Express supports the following routing methods corresponding to the HTTP methods of the same names:

    


          
            checkout
            copy
            delete
            get
            head
            lock
            merge
            mkactivity
          
        

          
            mkcol
            move
            m-search
            notify
            options
            patch
            post
          
        

          
            purge
            put
            report
            search
            subscribe
            trace
            unlock
            unsubscribe
          
        



    The API documentation has explicit entries only for the most popular HTTP methods app.get(),
app.post(), app.put(), and app.delete().
However, the other methods listed above work in exactly the same way.

    To route methods that translate to invalid JavaScript variable names, use the bracket notation. For example, app['m-search']('/', function ....

    
      The app.get() function is automatically called for the HTTP HEAD method in addition to the GET
  method if app.head() was not called for the path before app.get().
    

    The method, app.all(), is not derived from any HTTP method and loads middleware at
the specified path for all HTTP request methods.
For more information, see app.all.

    For more information on routing, see the routing guide.

  

  
    app.param([name], callback)

    Add callback triggers to route parameters, where name is the name of the parameter or an array of them, and callback is the callback function. The parameters of the callback function are the request object, the response object, the next middleware, the value of the parameter and the name of the parameter, in that order.

    If name is an array, the callback trigger is registered for each parameter declared in it, in the order in which they are declared. Furthermore, for each declared parameter except the last one, a call to next inside the callback will call the callback for the next declared parameter. For the last parameter, a call to next will call the next middleware in place for the route currently being processed, just like it would if name were just a string.

    For example, when :user is present in a route path, you may map user loading logic to automatically provide req.user to the route, or perform validations on the parameter input.

    app.param('user', function (req, res, next, id) {
  // try to get the user details from the User model and attach it to the request object
  User.find(id, function (err, user) {
    if (err) {
      next(err)
    } else if (user) {
      req.user = user
      next()
    } else {
      next(new Error('failed to load user'))
    }
  })
})
    

    Param callback functions are local to the router on which they are defined. They are not inherited by mounted apps or routers, nor are they triggered for route parameters inherited from parent routers. Hence, param callbacks defined on app will be triggered only by route parameters defined on app routes.

    All param callbacks will be called before any handler of any route in which the param occurs, and they will each be called only once in a request-response cycle, even if the parameter is matched in multiple routes, as shown in the following examples.

    app.param('id', function (req, res, next, id) {
  console.log('CALLED ONLY ONCE')
  next()
})

app.get('/user/:id', function (req, res, next) {
  console.log('although this matches')
  next()
})

app.get('/user/:id', function (req, res) {
  console.log('and this matches too')
  res.end()
})
    

    On GET /user/42, the following is printed:

    CALLED ONLY ONCE
although this matches
and this matches too
    

    app.param(['id', 'page'], function (req, res, next, value) {
  console.log('CALLED ONLY ONCE with', value)
  next()
})

app.get('/user/:id/:page', function (req, res, next) {
  console.log('although this matches')
  next()
})

app.get('/user/:id/:page', function (req, res) {
  console.log('and this matches too')
  res.end()
})
    

    On GET /user/42/3, the following is printed:

    CALLED ONLY ONCE with 42
CALLED ONLY ONCE with 3
although this matches
and this matches too
    

    
      The following section describes app.param(callback), which is deprecated as of v4.11.0.
    

    The behavior of the app.param(name, callback) method can be altered entirely by passing only a function to app.param(). This function is a custom implementation of how app.param(name, callback) should behave - it accepts two parameters and must return a middleware.

    The first parameter of this function is the name of the URL parameter that should be captured, the second parameter can be any JavaScript object which might be used for returning the middleware implementation.

    The middleware returned by the function decides the behavior of what happens when a URL parameter is captured.

    In this example, the app.param(name, callback) signature is modified to app.param(name, accessId). Instead of accepting a name and a callback, app.param() will now accept a name and a number.

    var express = require('express')
var app = express()

// customizing the behavior of app.param()
app.param(function (param, option) {
  return function (req, res, next, val) {
    if (val === option) {
      next()
    } else {
      next('route')
    }
  }
})

// using the customized app.param()
app.param('id', 1337)

// route to trigger the capture
app.get('/user/:id', function (req, res) {
  res.send('OK')
})

app.listen(3000, function () {
  console.log('Ready')
})
    

    In this example, the app.param(name, callback) signature remains the same, but instead of a middleware callback, a custom data type checking function has been defined to validate the data type of the user id.

    app.param(function (param, validator) {
  return function (req, res, next, val) {
    if (validator(val)) {
      next()
    } else {
      next('route')
    }
  }
})

app.param('id', function (candidate) {
  return !isNaN(parseFloat(candidate)) && isFinite(candidate)
})
    

    
      The ‘.’ character can’t be used to capture a character in your capturing regexp. For example you can’t use '/user-.+/' to capture 'users-gami', use [\ \\S] or [\\w\\W] instead (as in '/user-[\ \\S]+/'.

      Examples:

      // captures '1-a_6' but not '543-azser-sder'
router.get('/[0-9]+-[[\\w]]*', function (req, res, next) { next() })

// captures '1-a_6' and '543-az(ser"-sder' but not '5-a s'
router.get('/[0-9]+-[[\\S]]*', function (req, res, next) { next() })

// captures all (equivalent to '.*')
router.get('[[\ \\S]]*', function (req, res, next) { next() })
      

    

  

  
    app.path()

    Returns the canonical path of the app, a string.

    var app = express()
var blog = express()
var blogAdmin = express()

app.use('/blog', blog)
blog.use('/admin', blogAdmin)

console.dir(app.path()) // ''
console.dir(blog.path()) // '/blog'
console.dir(blogAdmin.path()) // '/blog/admin'
    

    The behavior of this method can become very complicated in complex cases of mounted apps:
it is usually better to use req.baseUrl to get the canonical path of the app.

  

  
    app.post(path, callback [, callback ...])

    Routes HTTP POST requests to the specified path with the specified callback functions.
For more information, see the routing guide.

     Arguments

    

Argument 
 Description 
 Default 



path

The path for which the middleware function is invoked; can be any of:

A string representing a path.
A path pattern.
A regular expression pattern to match paths.
An array of combinations of any of the above.


For examples, see Path examples.

'/' (root path)



 callback

Callback functions; can be:

A middleware function.
A series of middleware functions (separated by commas).
An array of middleware functions.
A combination of all of the above.


You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke next('route') to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.

Since router and app implement the middleware interface,
you can use them as you would any other middleware function.

For examples, see Middleware callback function examples.


 None 


    Example

    app.post('/', function (req, res) {
  res.send('POST request to homepage')
})
    

  

  
    app.put(path, callback [, callback ...])

    Routes HTTP PUT requests to the specified path with the specified callback functions.

     Arguments

    

Argument 
 Description 
 Default 



path

The path for which the middleware function is invoked; can be any of:

A string representing a path.
A path pattern.
A regular expression pattern to match paths.
An array of combinations of any of the above.


For examples, see Path examples.

'/' (root path)



 callback

Callback functions; can be:

A middleware function.
A series of middleware functions (separated by commas).
An array of middleware functions.
A combination of all of the above.


You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke next('route') to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.

Since router and app implement the middleware interface,
you can use them as you would any other middleware function.

For examples, see Middleware callback function examples.


 None 


    Example

    app.put('/', function (req, res) {
  res.send('PUT request to homepage')
})
    

  

  
    app.render(view, [locals], callback)

    Returns the rendered HTML of a view via the callback function. It accepts an optional parameter
that is an object containing local variables for the view. It is like res.render(),
except it cannot send the rendered view to the client on its own.

    
      Think of app.render() as a utility function for generating rendered view strings.
Internally res.render() uses app.render() to render views.
    

    
      The view argument performs file system operations like reading a file from
disk and evaluating Node.js modules, and as so for security reasons should not
contain input from the end-user.
    

    
      The locals object is used by view engines to render a response. The object
keys may be particularly sensitive and should not contain user-controlled
input, as it may affect the operation of the view engine or provide a path to
cross-site scripting. Consult the documentation for the used view engine for
additional considerations.
    

    
      The local variable cache is reserved for enabling view cache. Set it to true, if you want to
cache view during development; view caching is enabled in production by default.
    

    app.render('email', function (err, html) {
  // ...
})

app.render('email', { name: 'Tobi' }, function (err, html) {
  // ...
})
    

  

  
    app.route(path)

    Returns an instance of a single route, which you can then use to handle HTTP verbs with optional middleware.
Use app.route() to avoid duplicate route names (and thus typo errors).

    var app = express()

app.route('/events')
  .all(function (req, res, next) {
    // runs for all HTTP verbs first
    // think of it as route specific middleware!
  })
  .get(function (req, res, next) {
    res.json({})
  })
  .post(function (req, res, next) {
    // maybe add a new event...
  })
    

  

  
    app.set(name, value)

    Assigns setting name to value. You may store any value that you want,
but certain names can be used to configure the behavior of the server. These
special names are listed in the app settings table.

    Calling app.set('foo', true) for a Boolean property is the same as calling
app.enable('foo'). Similarly, calling app.set('foo', false) for a Boolean
property is the same as calling app.disable('foo').

    Retrieve the value of a setting with app.get().

    app.set('title', 'My Site')
app.get('title') // "My Site"
    

    Application Settings

    The following table lists application settings.

    Note that sub-apps will:

    
      Not inherit the value of settings that have a default value.  You must set the value in the sub-app.
      Inherit the value of settings with no default value; these are explicitly noted in the table below.
    

    Exceptions: Sub-apps will inherit the value of trust proxy even though it has a default value (for backward-compatibility);
Sub-apps will not inherit the value of view cache in production (when NODE_ENV is “production”).

    
  
    PropertyTypeDescriptionDefault
    
    
  
              case sensitive routing
            
      Boolean
      Enable case sensitivity.
      When enabled, "/Foo" and "/foo" are different routes.
      When disabled, "/Foo" and "/foo" are treated the same.
        NOTE: Sub-apps will inherit the value of this setting.
      
      N/A (undefined)
      
    
    
  
              env
            
  String
  
              Environment mode. Be sure to set to “production” in a production environment; see Production best practices: performance and reliability.
            
  
              process.env.NODE_ENV (NODE_ENV environment variable) or “development” if NODE_ENV is not set.
            
    
    
  
              etag
            
  Varied
  
              Set the ETag response header. For possible values, see the etag options table.

              More about the HTTP ETag header.
            
  
              weak
            
    
    
  
              jsonp callback name
            
      String
      Specifies the default JSONP callback name.
  
              “callback”
            
    
    
  
              json escape
            
  Boolean
  
              Enable escaping JSON responses from the res.json, res.jsonp, and res.send APIs. This will escape the characters <, >, and & as Unicode escape sequences in JSON. The purpose of this it to assist with mitigating certain types of persistent XSS attacks when clients sniff responses for HTML.
              NOTE: Sub-apps will inherit the value of this setting.
            
  N/A (undefined)
    
    
  
              json replacer
            
      Varied
      The 'replacer' argument used by `JSON.stringify`.
        NOTE: Sub-apps will inherit the value of this setting.
      
  N/A (undefined)
  
    
    
  
              json spaces
            
      Varied
      The 'space' argument used by `JSON.stringify`.
This is typically set to the number of spaces to use to indent prettified JSON.
        NOTE: Sub-apps will inherit the value of this setting.
      
      N/A (undefined)
    
    
  
              query parser
            
      Varied
  
              Disable query parsing by setting the value to false, or set the query parser to use either “simple” or “extended” or a custom query string parsing function.

              The simple query parser is based on Node’s native query parser, querystring.

              The extended query parser is based on qs.

              A custom query string parsing function will receive the complete query string, and must return an object of query keys and their values.
            
      "extended"
    
    
  
              strict routing
            
      Boolean
      Enable strict routing.
      When enabled, the router treats "/foo" and "/foo/" as different.
      Otherwise, the router treats "/foo" and "/foo/" as the same.
        NOTE: Sub-apps will inherit the value of this setting.
      
      N/A (undefined) 
    
    
  
              subdomain offset
            
      Number
      The number of dot-separated parts of the host to remove to access subdomain.
      2
    
    
  
              trust proxy
            
      Varied
  
              Indicates the app is behind a front-facing proxy, and to use the X-Forwarded-* headers to determine the connection and the IP address of the client. NOTE: X-Forwarded-* headers are easily spoofed and the detected IP addresses are unreliable.
              
  When enabled, Express attempts to determine the IP address of the client connected through the front-facing proxy, or series of proxies. The `req.ips` property, then contains an array of IP addresses the client is connected through. To enable it, use the values described in the trust proxy options table.

              
  The `trust proxy` setting is implemented using the proxy-addr package.  For more information, see its documentation.

              
NOTE: Sub-apps will inherit the value of this setting, even though it has a default value.

            
  
              false (disabled)
            
    
    
  
              views
            
      String or Array
      A directory or an array of directories for the application's views. If an array, the views are looked up in the order they occur in the array.
  
              process.cwd() + '/views'
            
    
    
  
              view cache
            
      Boolean
      Enables view template compilation caching.
      NOTE: Sub-apps will not inherit the value of this setting in production (when `NODE_ENV` is "production").
      
  
              true in production, otherwise undefined.
            
    
    
  
              view engine
            
      String
      The default engine extension to use when omitted.
        NOTE: Sub-apps will inherit the value of this setting.
      
      N/A (undefined)
    
    
  
              x-powered-by
            
      Boolean
      Enables the "X-Powered-By: Express" HTTP header.
  
              true
            
    
    
  

  Options for `trust proxy` setting

  
  Read Express behind proxies for more
  information.
  

  
    TypeValue
    
      
        Boolean
  
              If true, the client’s IP address is understood as the left-most entry in the X-Forwarded-* header.

              If false, the app is understood as directly facing the Internet and the client’s IP address is derived from req.connection.remoteAddress. This is the default setting.
            
      
      
        StringString containing comma-separated valuesArray of strings 
  
              An IP address, subnet, or an array of IP addresses, and subnets to trust. Pre-configured subnet names are:

              
                loopback - 127.0.0.1/8, ::1/128
                linklocal - 169.254.0.0/16, fe80::/10
                uniquelocal - 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, fc00::/7
              

              Set IP addresses in any of the following ways:

              Specify a single subnet:

              app.set('trust proxy', 'loopback')
              

              Specify a subnet and an address:

              app.set('trust proxy', 'loopback, 123.123.123.123')
              

              Specify multiple subnets as CSV:

              app.set('trust proxy', 'loopback, linklocal, uniquelocal')
              

              Specify multiple subnets as an array:

              app.set('trust proxy', ['loopback', 'linklocal', 'uniquelocal'])
              

              When specified, the IP addresses or the subnets are excluded from the address determination process, and the untrusted IP address nearest to the application server is determined as the client’s IP address.
            
      
      
        Number
  
              Trust the nth hop from the front-facing proxy server as the client.
            
      
      
        Function
  
              Custom trust implementation. Use this only if you know what you are doing.

              app.set('trust proxy', function (ip) {
  if (ip === '127.0.0.1' || ip === '123.123.123.123') return true // trusted IPs
  else return false
})
              
            
      
    
  

  Options for `etag` setting


NOTE:  These settings apply only to dynamic files, not static files.
The express.static middleware ignores these settings.


  
  The ETag functionality is implemented using the
  etag package.
  For more information, see its documentation.
  

  
    TypeValue
    
      
        Boolean
  
              true enables weak ETag. This is the default setting.
  false disables ETag altogether.
            
      
      
        String
        
            If "strong", enables strong ETag.
            If "weak", enables weak ETag.
        
      
      
        Function
  
              Custom ETag function implementation. Use this only if you know what you are doing.

              app.set('etag', function (body, encoding) {
  return generateHash(body, encoding) // consider the function is defined
})
              
            
      
    
  


  

  
    app.use([path,] callback [, callback...])

    Mounts the specified middleware function or functions
at the specified path:
the middleware function is executed when the base of the requested path matches path.

     Arguments

    

Argument 
 Description 
 Default 



path

The path for which the middleware function is invoked; can be any of:

A string representing a path.
A path pattern.
A regular expression pattern to match paths.
An array of combinations of any of the above.


For examples, see Path examples.

'/' (root path)



 callback

Callback functions; can be:

A middleware function.
A series of middleware functions (separated by commas).
An array of middleware functions.
A combination of all of the above.


You can provide multiple callback functions that behave just like middleware, except
that these callbacks can invoke next('route') to bypass
the remaining route callback(s). You can use this mechanism to impose pre-conditions
on a route, then pass control to subsequent routes if there is no reason to proceed with the current route.

Since router and app implement the middleware interface,
you can use them as you would any other middleware function.

For examples, see Middleware callback function examples.


 None 


    Description

    A route will match any path that follows its path immediately with a “/”.
For example: app.use('/apple', ...) will match “/apple”, “/apple/images”,
“/apple/images/news”, and so on.

    Since path defaults to “/”, middleware mounted without a path will be executed for every request to the app.
For example, this middleware function will be executed for every request to the app:

    app.use(function (req, res, next) {
  console.log('Time: %d', Date.now())
  next()
})
    

    
      NOTE

      Sub-apps will:

      
        Not inherit the value of settings that have a default value.  You must set the value in the sub-app.
        Inherit the value of settings with no default value.
      

      For details, see Application settings.
    

    Middleware functions are executed sequentially, therefore the order of middleware inclusion is important.

    // this middleware will not allow the request to go beyond it
app.use(function (req, res, next) {
  res.send('Hello World')
})

// requests will never reach this route
app.get('/', function (req, res) {
  res.send('Welcome')
})
    

    Error-handling middleware

    Error-handling middleware always takes four arguments.  You must provide four arguments to identify it as an error-handling middleware function. Even if you don’t need to use the next object, you must specify it to maintain the signature. Otherwise, the next object will be interpreted as regular middleware and will fail to handle errors. For details about error-handling middleware, see: Error handling.

    Define error-handling middleware functions in the same way as other middleware functions, except with four arguments instead of three, specifically with the signature (err, req, res, next)):

    app.use(function (err, req, res, next) {
  console.error(err.stack)
  res.status(500).send('Something broke!')
})
    

    Path examples

    The following table provides some simple examples of valid path values for
mounting middleware.

    




Type
Example





Path

              This will match paths starting with /abcd:

              app.use('/abcd', function (req, res, next) {
  next()
})
              

            



Path Pattern

              This will match paths starting with /abcd and /abd:

              app.use('/abc?d', function (req, res, next) {
  next()
})
              

              This will match paths starting with /abcd, /abbcd, /abbbbbcd, and so on:

              app.use('/ab+cd', function (req, res, next) {
  next()
})
              

              This will match paths starting with /abcd, /abxcd, /abFOOcd, /abbArcd, and so on:

              app.use('/ab*cd', function (req, res, next) {
  next()
})
              

              This will match paths starting with /ad and /abcd:

              app.use('/a(bc)?d', function (req, res, next) {
  next()
})
              

            



Regular Expression

              This will match paths starting with /abc and /xyz:

              app.use(/\/abc|\/xyz/, function (req, res, next) {
  next()
})
              

            



Array

              This will match paths starting with /abcd, /xyza, /lmn, and /pqr:

              app.use(['/abcd', '/xyza', /\/lmn|\/pqr/], function (req, res, next) {
  next()
})
              

            







    Middleware callback function examples

    The following table provides some simple examples of middleware functions that
can be used as the callback argument to app.use(), app.METHOD(), and app.all().

    



Usage
Example






Single Middleware

            You can define and mount a middleware function locally.

            app.use(function (req, res, next) {
  next()
})
            

            A router is valid middleware.

            var router = express.Router()
router.get('/', function (req, res, next) {
  next()
})
app.use(router)
            

            An Express app is valid middleware.

            var subApp = express()
subApp.get('/', function (req, res, next) {
  next()
})
app.use(subApp)
            

          



Series of Middleware

            You can specify more than one middleware function at the same mount path.

            var r1 = express.Router()
r1.get('/', function (req, res, next) {
  next()
})

var r2 = express.Router()
r2.get('/', function (req, res, next) {
  next()
})

app.use(r1, r2)
            

          



Array

            Use an array to group middleware logically.

            var r1 = express.Router()
r1.get('/', function (req, res, next) {
  next()
})

var r2 = express.Router()
r2.get('/', function (req, res, next) {
  next()
})

app.use([r1, r2])
            

          



Combination

            You can combine all the above ways of mounting middleware.

            function mw1 (req, res, next) { next() }
function mw2 (req, res, next) { next() }

var r1 = express.Router()
r1.get('/', function (req, res, next) { next() })

var r2 = express.Router()
r2.get('/', function (req, res, next) { next() })

var subApp = express()
subApp.get('/', function (req, res, next) { next() })

app.use(mw1, [mw2, r1, r2], subApp)
            

          






    Following are some examples of using the express.static
middleware in an Express app.

    Serve static content for the app from the “public” directory in the application directory:

    // GET /style.css etc
app.use(express.static(path.join(__dirname, 'public')))
    

    Mount the middleware at “/static” to serve static content only when their request path is prefixed with “/static”:

    // GET /static/style.css etc.
app.use('/static', express.static(path.join(__dirname, 'public')))
    

    Disable logging for static content requests by loading the logger middleware after the static middleware:

    app.use(express.static(path.join(__dirname, 'public')))
app.use(logger())
    

    Serve static files from multiple directories, but give precedence to “./public” over the others:

    app.use(express.static(path.join(__dirname, 'public')))
app.use(express.static(path.join(__dirname, 'files')))
app.use(express.static(path.join(__dirname, 'uploads')))
    

  

  Request

  The req object represents the HTTP request and has properties for the
request query string, parameters, body, HTTP headers, and so on.  In this documentation and by convention,
the object is always referred to as req (and the HTTP response is res) but its actual name is determined
by the parameters to the callback function in which you’re working.

  For example:

  app.get('/user/:id', function (req, res) {
  res.send('user ' + req.params.id)
})
  

  But you could just as well have:

  app.get('/user/:id', function (request, response) {
  response.send('user ' + request.params.id)
})
  

  The req object is an enhanced version of Node’s own request object
and supports all built-in fields and methods.

  Properties

  
    In Express 4, req.files is no longer available on the req object by default. To access uploaded files
on the req.files object, use multipart-handling middleware like busboy, multer,
formidable,
multiparty,
connect-multiparty,
or pez.
  

  
    req.app

    This property holds a reference to the instance of the Express application that is using the middleware.

    If you follow the pattern in which you create a module that just exports a middleware function
and require() it in your main file, then the middleware can access the Express instance via req.app

    For example:

    // index.js
app.get('/viewdirectory', require('./mymiddleware.js'))
    

    // mymiddleware.js
module.exports = function (req, res) {
  res.send('The views directory is ' + req.app.get('views'))
}
    

  

  
    req.baseUrl

    The URL path on which a router instance was mounted.

    The req.baseUrl property is similar to the mountpath property of the app object,
except app.mountpath returns the matched path pattern(s).

    For example:

    var greet = express.Router()

greet.get('/jp', function (req, res) {
  console.log(req.baseUrl) // /greet
  res.send('Konnichiwa!')
})

app.use('/greet', greet) // load the router on '/greet'
    

    Even if you use a path pattern or a set of path patterns to load the router,
the baseUrl property returns the matched string, not the pattern(s). In the
following example, the greet router is loaded on two path patterns.

    app.use(['/gre+t', '/hel{2}o'], greet) // load the router on '/gre+t' and '/hel{2}o'
    

    When a request is made to /greet/jp, req.baseUrl is “/greet”.  When a request is
made to /hello/jp, req.baseUrl is “/hello”.

  

  
    req.body

    Contains key-value pairs of data submitted in the request body.
By default, it is undefined, and is populated when you use body-parsing middleware such
as express.json() or express.urlencoded().

    
      As req.body’s shape is based on user-controlled input, all properties and values in this object are untrusted and should be validated before trusting. For example, req.body.foo.toString() may fail in multiple ways, for example foo may not be there or may not be a string, and toString may not be a function and instead a string or other user-input.
    

    The following example shows how to use body-parsing middleware to populate req.body.

    var express = require('express')

var app = express()

app.use(express.json()) // for parsing application/json
app.use(express.urlencoded({ extended: true })) // for parsing application/x-www-form-urlencoded

app.post('/profile', function (req, res, next) {
  console.log(req.body)
  res.json(req.body)
})
    

  

  
    req.cookies

    When using cookie-parser middleware, this property is an object that
contains cookies sent by the request.  If the request contains no cookies, it defaults to {}.

    // Cookie: name=tj
console.dir(req.cookies.name)
// => 'tj'
    

    If the cookie has been signed, you have to use req.signedCookies.

    For more information, issues, or concerns, see cookie-parser.

  

  
    req.fresh

    When the response is still “fresh” in the client’s cache true is returned, otherwise false is returned to indicate that the client cache is now stale and the full response should be sent.

    When a client sends the Cache-Control: no-cache request header to indicate an end-to-end reload request, this module will return false to make handling these requests transparent.

    Further details for how cache validation works can be found in the
HTTP/1.1 Caching Specification.

    console.dir(req.fresh)
// => true
    

  

  
    req.hostname

    Contains the hostname derived from the Host HTTP header.

    When the trust proxy setting
does not evaluate to false, this property will instead get the value
from the X-Forwarded-Host header field. This header can be set by
the client or by the proxy.

    If there is more than one X-Forwarded-Host header in the request, the
value of the first header is used. This includes a single header with
comma-separated values, in which the first value is used.

    
      Prior to Express v4.17.0, the X-Forwarded-Host could not contain multiple
values or be present more than once.
    

    // Host: "example.com:3000"
console.dir(req.hostname)
// => 'example.com'
    

  

  
    req.ip

    Contains the remote IP address of the request.

    When the trust proxy setting does not evaluate to false,
the value of this property is derived from the left-most entry in the
X-Forwarded-For header. This header can be set by the client or by the proxy.

    console.dir(req.ip)
// => '127.0.0.1'
    

  

  
    req.ips

    When the trust proxy setting does not evaluate to false,
this property contains an array of IP addresses
specified in the X-Forwarded-For request header. Otherwise, it contains an
empty array. This header can be set by the client or by the proxy.

    For example, if X-Forwarded-For is client, proxy1, proxy2, req.ips would be
["client", "proxy1", "proxy2"], where proxy2 is the furthest downstream.

  

  
    req.method

    Contains a string corresponding to the HTTP method of the request:
GET, POST, PUT, and so on.

  

  
    req.originalUrl

    
      req.url is not a native Express property, it is inherited from Node’s http module.
    

    This property is much like req.url; however, it retains the original request URL,
allowing you to rewrite req.url freely for internal routing purposes. For example,
the “mounting” feature of app.use() will rewrite req.url to strip the mount point.

    // GET /search?q=something
console.dir(req.originalUrl)
// => '/search?q=something'
    

    req.originalUrl is available both in middleware and router objects, and is a
combination of req.baseUrl and req.url. Consider following example:

    app.use('/admin', function (req, res, next) { // GET 'http://www.example.com/admin/new?sort=desc'
  console.dir(req.originalUrl) // '/admin/new?sort=desc'
  console.dir(req.baseUrl) // '/admin'
  console.dir(req.path) // '/new'
  next()
})
    

  

  
    req.params

    This property is an object containing properties mapped to the named route “parameters”. For example, if you have the route /user/:name, then the “name” property is available as req.params.name. This object defaults to {}.

    // GET /user/tj
console.dir(req.params.name)
// => 'tj'
    

    When you use a regular expression for the route definition, capture groups are provided in the array using req.params[n], where n is the nth capture group. This rule is applied to unnamed wild card matches with string routes such as /file/*:

    // GET /file/javascripts/jquery.js
console.dir(req.params[0])
// => 'javascripts/jquery.js'
    

    If you need to make changes to a key in req.params, use the app.param handler. Changes are applicable only to parameters already defined in the route path.

    Any changes made to the req.params object in a middleware or route handler will be reset.

    
       Note
      Express automatically decodes the values in req.params (using decodeURIComponent).
    

  

  
    req.path

    Contains the path part of the request URL.

    // example.com/users?sort=desc
console.dir(req.path)
// => '/users'
    

    
      When called from a middleware, the mount point is not included in req.path. See app.use() for more details.
    

  

  
    req.protocol

    Contains the request protocol string: either http or (for TLS requests) https.

    When the trust proxy setting does not evaluate to false,
this property will use the value of the X-Forwarded-Proto header field if present.
This header can be set by the client or by the proxy.

    console.dir(req.protocol)
// => 'http'
    

  

  
    req.query

    This property is an object containing a property for each query string parameter in the route.
When query parser is set to disabled, it is an empty object {}, otherwise it is the result of the configured query parser.

    
      As req.query’s shape is based on user-controlled input, all properties and values in this object are untrusted and should be validated before trusting. For example, req.query.foo.toString() may fail in multiple ways, for example foo may not be there or may not be a string, and toString may not be a function and instead a string or other user-input.
    

    The value of this property can be configured with the query parser application setting to work how your application needs it. A very popular query string parser is the qs module, and this is used by default. The qs module is very configurable with many settings, and it may be desirable to use different settings than the default to populate req.query:

    var qs = require('qs')
app.set('query parser', function (str) {
  return qs.parse(str, { /* custom options */ })
})
    

    Check out the query parser application setting documentation for other customization options.

  

  
    req.res

    This property holds a reference to the response object
that relates to this request object.

  

  
    req.route

    Contains the currently-matched route, a string.  For example:

    app.get('/user/:id?', function userIdHandler (req, res) {
  console.log(req.route)
  res.send('GET')
})
    

    Example output from the previous snippet:

    { path: '/user/:id?',
  stack:
   [ { handle: [Function: userIdHandler],
       name: 'userIdHandler',
       params: undefined,
       path: undefined,
       keys: [],
       regexp: /^\/?$/i,
       method: 'get' } ],
  methods: { get: true } }
    

  

  
    req.secure

    A Boolean property that is true if a TLS connection is established. Equivalent to:

    console.dir(req.protocol === 'https')
// => true
    

  

  
    req.signedCookies

    When using cookie-parser middleware, this property
contains signed cookies sent by the request, unsigned and ready for use. Signed cookies reside
in a different object to show developer intent; otherwise, a malicious attack could be placed on
req.cookie values (which are easy to spoof). Note that signing a cookie does not make it “hidden”
or encrypted; but simply prevents tampering (because the secret used to sign is private).

    If no signed cookies are sent, the property defaults to {}.

    // Cookie: user=tobi.CP7AWaXDfAKIRfH49dQzKJx7sKzzSoPq7/AcBBRVwlI3
console.dir(req.signedCookies.user)
// => 'tobi'
    

    For more information, issues, or concerns, see cookie-parser.

  

  
    req.stale

    Indicates whether the request is “stale,” and is the opposite of req.fresh.
For more information, see req.fresh.

    console.dir(req.stale)
// => true
    

  

  
    req.subdomains

    An array of subdomains in the domain name of the request.

    // Host: "tobi.ferrets.example.com"
console.dir(req.subdomains)
// => ['ferrets', 'tobi']
    

    The application property subdomain offset, which defaults to 2, is used for determining the
beginning of the subdomain segments. To change this behavior, change its value
using app.set.

  

  
    req.xhr

    A Boolean property that is true if the request’s X-Requested-With header field is
“XMLHttpRequest”, indicating that the request was issued by a client library such as jQuery.

    console.dir(req.xhr)
// => true
    

  

  Methods

  
    req.accepts(types)

    Checks if the specified content types are acceptable, based on the request’s Accept HTTP header field.
The method returns the best match, or if none of the specified content types is acceptable, returns
false (in which case, the application should respond with 406 "Not Acceptable").

    The type value may be a single MIME type string (such as “application/json”),
an extension name such as “json”, a comma-delimited list, or an array. For a
list or array, the method returns the best match (if any).

    // Accept: text/html
req.accepts('html')
// => "html"

// Accept: text/*, application/json
req.accepts('html')
// => "html"
req.accepts('text/html')
// => "text/html"
req.accepts(['json', 'text'])
// => "json"
req.accepts('application/json')
// => "application/json"

// Accept: text/*, application/json
req.accepts('image/png')
req.accepts('png')
// => false

// Accept: text/*;q=.5, application/json
req.accepts(['html', 'json'])
// => "json"
    

    For more information, or if you have issues or concerns, see accepts.

  

  
    req.acceptsCharsets(charset [, ...])

    Returns the first accepted charset of the specified character sets,
based on the request’s Accept-Charset HTTP header field.
If none of the specified charsets is accepted, returns false.

    For more information, or if you have issues or concerns, see accepts.

  

  
    req.acceptsEncodings(encoding [, ...])

    Returns the first accepted encoding of the specified encodings,
based on the request’s Accept-Encoding HTTP header field.
If none of the specified encodings is accepted, returns false.

    For more information, or if you have issues or concerns, see accepts.

  

  
    req.acceptsLanguages([lang, ...])

    Returns the first accepted language of the specified languages,
based on the request’s Accept-Language HTTP header field.
If none of the specified languages is accepted, returns false.

    If no lang argument is given, then req.acceptsLanguages()
returns all languages from the HTTP Accept-Language header
as an Array.

    For more information, or if you have issues or concerns, see accepts.

    Express (4.x) source: request.js line 179

    Accepts (1.3) source: index.js line 195

  

  
    req.get(field)

    Returns the specified HTTP request header field (case-insensitive match).
The Referrer and Referer fields are interchangeable.

    req.get('Content-Type')
// => "text/plain"

req.get('content-type')
// => "text/plain"

req.get('Something')
// => undefined
    

    Aliased as req.header(field).

  

  
    req.is(type)

    Returns the matching content type if the incoming request’s “Content-Type” HTTP header field
matches the MIME type specified by the type parameter. If the request has no body, returns null.
Returns false otherwise.

    // With Content-Type: text/html; charset=utf-8
req.is('html')
// => 'html'
req.is('text/html')
// => 'text/html'
req.is('text/*')
// => 'text/*'

// When Content-Type is application/json
req.is('json')
// => 'json'
req.is('application/json')
// => 'application/json'
req.is('application/*')
// => 'application/*'

req.is('html')
// => false
    

    For more information, or if you have issues or concerns, see type-is.

  

  
    req.param(name [, defaultValue])

    
      Deprecated. Use either req.params, req.body or req.query, as applicable.
    

    Returns the value of param name when present.

    // ?name=tobi
req.param('name')
// => "tobi"

// POST name=tobi
req.param('name')
// => "tobi"

// /user/tobi for /user/:name
req.param('name')
// => "tobi"
    

    Lookup is performed in the following order:

    
      req.params
      req.body
      req.query
    

    Optionally, you can specify defaultValue to set a default value if the parameter is not found in any of the request objects.

    
      Direct access to req.body, req.params, and req.query should be favoured for clarity - unless you truly accept input from each object.

      Body-parsing middleware must be loaded for req.param() to work predictably. Refer req.body for details.
    

  

  
    req.range(size[, options])

    Range header parser.

    The size parameter is the maximum size of the resource.

    The options parameter is an object that can have the following properties.

    
      
        
          Property
          Type
          Description
        
      
      
        
          combine
          Boolean
          Specify if overlapping & adjacent ranges should be combined, defaults to false. When true, ranges will be combined and returned as if they were specified that way in the header.
        
      
    

    An array of ranges will be returned or negative numbers indicating an error parsing.

    
      -2 signals a malformed header string
      -1 signals an unsatisfiable range
    

    // parse header from request
var range = req.range(1000)

// the type of the range
if (range.type === 'bytes') {
  // the ranges
  range.forEach(function (r) {
    // do something with r.start and r.end
  })
}
    

  

  Response

  The res object represents the HTTP response that an Express app sends when it gets an HTTP request.

  In this documentation and by convention,
the object is always referred to as res (and the HTTP request is req) but its actual name is determined
by the parameters to the callback function in which you’re working.

  For example:

  app.get('/user/:id', function (req, res) {
  res.send('user ' + req.params.id)
})
  

  But you could just as well have:

  app.get('/user/:id', function (request, response) {
  response.send('user ' + request.params.id)
})
  

  The res object is an enhanced version of Node’s own response object
and supports all built-in fields and methods.

  Properties

  
    res.app

    This property holds a reference to the instance of the Express application that is using the middleware.

    res.app is identical to the req.app property in the request object.

  

  
    res.headersSent

    Boolean property that indicates if the app sent HTTP headers for the response.

    app.get('/', function (req, res) {
  console.dir(res.headersSent) // false
  res.send('OK')
  console.dir(res.headersSent) // true
})
    

  

  
    res.locals

    Use this property to set variables accessible in templates rendered with res.render.
The variables set on res.locals are available within a single request-response cycle, and will not
be shared between requests.

    
      The locals object is used by view engines to render a response. The object
keys may be particularly sensitive and should not contain user-controlled
input, as it may affect the operation of the view engine or provide a path to
cross-site scripting. Consult the documentation for the used view engine for
additional considerations.
    

    In order to keep local variables for use in template rendering between requests, use
app.locals instead.

    This property is useful for exposing request-level information such as the request path name,
authenticated user, user settings, and so on to templates rendered within the application.

    app.use(function (req, res, next) {
  // Make `user` and `authenticated` available in templates
  res.locals.user = req.user
  res.locals.authenticated = !req.user.anonymous
  next()
})
    

  

  Methods

  
    res.append(field [, value])

    
       Note
      res.append() is supported by Express v4.11.0+
    

    Appends the specified value to the HTTP response header field.  If the header is not already set,
it creates the header with the specified value.  The value parameter can be a string or an array.

    
       Note
      calling res.set() after res.append() will reset the previously-set header value.
    

    res.append('Link', ['<http://localhost/>', '<http://localhost:3000/>'])
res.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly')
res.append('Warning', '199 Miscellaneous warning')
    

  

  
    res.attachment([filename])

    Sets the HTTP response Content-Disposition header field to “attachment”. If a filename is given,
then it sets the Content-Type based on the extension name via res.type(),
and sets the Content-Disposition “filename=” parameter.

    res.attachment()
// Content-Disposition: attachment

res.attachment('path/to/logo.png')
// Content-Disposition: attachment; filename="logo.png"
// Content-Type: image/png
    

  

  
    res.cookie(name, value [, options])

    Sets cookie name to value.  The value parameter may be a string or object converted to JSON.

    The options parameter is an object that can have the following properties.

    
      
        
          Property
          Type
          Description
        
      
      
        
          domain
          String
          Domain name for the cookie. Defaults to the domain name of the app.
        
        
          encode
          Function
          A synchronous function used for cookie value encoding. Defaults to encodeURIComponent.
        
        
          expires
          Date
          Expiry date of the cookie in GMT. If not specified or set to 0, creates a session cookie.
        
        
          httpOnly
          Boolean
          Flags the cookie to be accessible only by the web server.
        
        
          maxAge
          Number
          Convenient option for setting the expiry time relative to the current time in milliseconds.
        
        
          path
          String
          Path for the cookie. Defaults to “/”.
        
        
          partitioned
          Boolean
          Indicates that the cookie should be stored using partitioned storage. See Cookies Having Independent Partitioned State (CHIPS) for more details.
        
        
          priority
          String
          Value of the “Priority” Set-Cookie attribute.
        
        
          secure
          Boolean
          Marks the cookie to be used with HTTPS only.
        
        
          signed
          Boolean
          Indicates if the cookie should be signed.
        
        
          sameSite
          Boolean or String
          Value of the “SameSite” Set-Cookie attribute. More information at https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00#section-4.1.1.
        
      
    

    
      All res.cookie() does is set the HTTP Set-Cookie header with the options provided.
Any option not specified defaults to the value stated in RFC 6265.
    

    For example:

    res.cookie('name', 'tobi', { domain: '.example.com', path: '/admin', secure: true })
res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true })
    

    You can set multiple cookies in a single response by calling res.cookie multiple times, for example:

    res
  .status(201)
  .cookie('access_token', 'Bearer ' + token, {
    expires: new Date(Date.now() + 8 * 3600000) // cookie will be removed after 8 hours
  })
  .cookie('test', 'test')
  .redirect(301, '/admin')
    

    The encode option allows you to choose the function used for cookie value encoding.
Does not support asynchronous functions.

    Example use case: You need to set a domain-wide cookie for another site in your organization.
This other site (not under your administrative control) does not use URI-encoded cookie values.

    // Default encoding
res.cookie('some_cross_domain_cookie', 'http://mysubdomain.example.com', { domain: 'example.com' })
// Result: 'some_cross_domain_cookie=http%3A%2F%2Fmysubdomain.example.com; Domain=example.com; Path=/'

// Custom encoding
res.cookie('some_cross_domain_cookie', 'http://mysubdomain.example.com', { domain: 'example.com', encode: String })
// Result: 'some_cross_domain_cookie=http://mysubdomain.example.com; Domain=example.com; Path=/;'
    

    The maxAge option is a convenience option for setting “expires” relative to the current time in milliseconds.
The following is equivalent to the second example above.

    res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })
    

    You can pass an object as the value parameter; it is then serialized as JSON and parsed by bodyParser() middleware.

    res.cookie('cart', { items: [1, 2, 3] })
res.cookie('cart', { items: [1, 2, 3] }, { maxAge: 900000 })
    

    When using cookie-parser middleware, this method also
supports signed cookies. Simply include the signed option set to true.
Then res.cookie() will use the secret passed to cookieParser(secret) to sign the value.

    res.cookie('name', 'tobi', { signed: true })
    

    Later you may access this value through the req.signedCookie object.

  

  
    res.clearCookie(name [, options])

    Clears the cookie specified by name. For details about the options object, see res.cookie().

    
      Web browsers and other compliant clients will only clear the cookie if the given
options is identical to those given to res.cookie(), excluding
expires and maxAge.
    

    res.cookie('name', 'tobi', { path: '/admin' })
res.clearCookie('name', { path: '/admin' })
    

  

  
    res.download(path [, filename] [, options] [, fn])

    Transfers the file at path as an “attachment”. Typically, browsers will prompt the user for download.
By default, the Content-Disposition header “filename=” parameter is derived from the path argument, but can be overridden with the filename parameter.
If path is relative, then it will be based on the current working directory of the process or
the root option, if provided.

    
      This API provides access to data on the running file system. Ensure that either (a) the way in
which the path argument was constructed is secure if it contains user input or (b) set the root
option to the absolute path of a directory to contain access within.

      When the root option is provided, Express will validate that the relative path provided as
path will resolve within the given root option.
    

    The following table provides details on the options parameter.

    
      The optional options argument is supported by Express v4.16.0 onwards.
    

    

      
        
          
            Property
            Description
            Default
            Availability
          
        
        
          
            maxAge
            Sets the max-age property of the Cache-Control header in milliseconds or a string in ms format
            0
            4.16+
          
          
            root
            Root directory for relative filenames.
             
            4.18+
          
          
            lastModified
            Sets the Last-Modified header to the last modified date of the file on the OS. Set false to disable it.
            Enabled
            4.16+
          
          
            headers
            Object containing HTTP headers to serve with the file. The header Content-Disposition will be overridden by the filename argument.
             
            4.16+
          
          
            dotfiles
            Option for serving dotfiles. Possible values are “allow”, “deny”, “ignore”.
            “ignore”
            4.16+
          
          
            acceptRanges
            Enable or disable accepting ranged requests.
            true
            4.16+
          
          
            cacheControl
            Enable or disable setting Cache-Control response header.
            true
            4.16+
          
          
            immutable
            Enable or disable the immutable directive in the Cache-Control response header. If enabled, the maxAge option should also be specified to enable caching. The immutable directive will prevent supported clients from making conditional requests during the life of the maxAge option to check if the file has changed.
            false
            4.16+
          
        
      

    

    The method invokes the callback function fn(err) when the transfer is complete
or when an error occurs. If the callback function is specified and an error occurs,
the callback function must explicitly handle the response process either by
ending the request-response cycle, or by passing control to the next route.

    res.download('/report-12345.pdf')

res.download('/report-12345.pdf', 'report.pdf')

res.download('/report-12345.pdf', 'report.pdf', function (err) {
  if (err) {
    // Handle error, but keep in mind the response may be partially-sent
    // so check res.headersSent
  } else {
    // decrement a download credit, etc.
  }
})
    

  

  
    res.end([data[, encoding]][, callback])

    Ends the response process. This method actually comes from Node core, specifically the response.end() method of http.ServerResponse.

    Use to quickly end the response without any data. If you need to respond with data, instead use methods such as res.send() and res.json().

    res.end()
res.status(404).end()
    

  

  
    res.format(object)

    Performs content-negotiation on the Accept HTTP header on the request object, when present.
It uses req.accepts() to select a handler for the request, based on the acceptable
types ordered by their quality values. If the header is not specified, the first callback is invoked.
When no match is found, the server responds with 406 “Not Acceptable”, or invokes the default callback.

    The Content-Type response header is set when a callback is selected. However, you may alter
this within the callback using methods such as res.set() or res.type().

    The following example would respond with { "message": "hey" } when the Accept header field is set
to “application/json” or “*/json” (however if it is “*/*”, then the response will be “hey”).

    res.format({
  'text/plain': function () {
    res.send('hey')
  },

  'text/html': function () {
    res.send('<p>hey</p>')
  },

  'application/json': function () {
    res.send({ message: 'hey' })
  },

  default: function () {
    // log the request and respond with 406
    res.status(406).send('Not Acceptable')
  }
})
    

    In addition to canonicalized MIME types, you may also use extension names mapped
to these types for a slightly less verbose implementation:

    res.format({
  text: function () {
    res.send('hey')
  },

  html: function () {
    res.send('<p>hey</p>')
  },

  json: function () {
    res.send({ message: 'hey' })
  }
})
    

  

  
    res.get(field)

    Returns the HTTP response header specified by field.
The match is case-insensitive.

    res.get('Content-Type')
// => "text/plain"
    

  

  
    res.json([body])

    Sends a JSON response. This method sends a response (with the correct content-type) that is the parameter converted to a 
JSON string using JSON.stringify().

    The parameter can be any JSON type, including object, array, string, Boolean, number, or null,
and you can also use it to convert other values to JSON.

    res.json(null)
res.json({ user: 'tobi' })
res.status(500).json({ error: 'message' })
    

  

  
    res.jsonp([body])

    Sends a JSON response with JSONP support. This method is identical to res.json(),
except that it opts-in to JSONP callback support.

    res.jsonp(null)
// => callback(null)

res.jsonp({ user: 'tobi' })
// => callback({ "user": "tobi" })

res.status(500).jsonp({ error: 'message' })
// => callback({ "error": "message" })
    

    By default, the JSONP callback name is simply callback. Override this with the
jsonp callback name setting.

    The following are some examples of JSONP responses using the same code:

    // ?callback=foo
res.jsonp({ user: 'tobi' })
// => foo({ "user": "tobi" })

app.set('jsonp callback name', 'cb')

// ?cb=foo
res.status(500).jsonp({ error: 'message' })
// => foo({ "error": "message" })
    

  

  
    res.links(links)

    Joins the links provided as properties of the parameter to populate the response’s
Link HTTP header field.

    For example, the following call:

    res.links({
  next: 'http://api.example.com/users?page=2',
  last: 'http://api.example.com/users?page=5'
})
    

    Yields the following results:

    Link: <http://api.example.com/users?page=2>; rel="next",
      <http://api.example.com/users?page=5>; rel="last"
    

  

  
    res.location(path)

    Sets the response Location HTTP header to the specified path parameter.

    res.location('/foo/bar')
res.location('http://example.com')
res.location('back')
    

    
       Note
      'back' was deprecated in 4.21.0, use req.get('Referrer') || '/' as an argument instead.
    

    A path value of “back” has a special meaning, it refers to the URL specified in the Referer header of the request. If the Referer header was not specified, it refers to “/”.

    See also Security best practices: Prevent open redirect 
vulnerabilities.

    
      After encoding the URL, if not encoded already, Express passes the specified URL to the browser in the Location header,
without any validation.

      Browsers take the responsibility of deriving the intended URL from the current URL
or the referring URL, and the URL specified in the Location header; and redirect the user accordingly.
    

  

  
    res.redirect([status,] path)

    Redirects to the URL derived from the specified path, with specified status, a positive integer
that corresponds to an HTTP status code .
If not specified, status defaults to “302 “Found”.

    res.redirect('/foo/bar')
res.redirect('http://example.com')
res.redirect(301, 'http://example.com')
res.redirect('../login')
    
    Redirects can be a fully-qualified URL for redirecting to a different site:

    res.redirect('http://google.com')
    
    Redirects can be relative to the root of the host name. For example, if the
application is on http://example.com/admin/post/new, the following
would redirect to the URL http://example.com/admin:

    res.redirect('/admin')
    

    Redirects can be relative to the current URL. For example,
from http://example.com/blog/admin/ (notice the trailing slash), the following
would redirect to the URL http://example.com/blog/admin/post/new.

    res.redirect('post/new')
    

    Redirecting to post/new from http://example.com/blog/admin (no trailing slash),
will redirect to http://example.com/blog/post/new.

    If you found the above behavior confusing, think of path segments as directories
(with trailing slashes) and files, it will start to make sense.

    Path-relative redirects are also possible. If you were on
http://example.com/admin/post/new, the following would redirect to
http://example.com/admin/post:

    res.redirect('..')
    

    A back redirection redirects the request back to the referer,
defaulting to / when the referer is missing.

    res.redirect('back')
    

    
       Note
      back redirect was deprecated in 4.21.0, use req.get('Referrer') || '/' as an argument instead.
    

    See also Security best practices: Prevent open redirect 
vulnerabilities.

  

  
    res.render(view [, locals] [, callback])

    Renders a view and sends the rendered HTML string to the client.
Optional parameters:

    
      locals, an object whose properties define local variables for the view.
      callback, a callback function. If provided, the method returns both the possible error and rendered string, but does not perform an automated response. When an error occurs, the method invokes next(err) internally.
    

    The view argument is a string that is the file path of the view file to render. This can be an absolute path, or a path relative to the views setting. If the path does not contain a file extension, then the view engine setting determines the file extension. If the path does contain a file extension, then Express will load the module for the specified template engine (via require()) and render it using the loaded module’s __express function.

    For more information, see Using template engines with Express.

    
      The view argument performs file system operations like reading a file from
disk and evaluating Node.js modules, and as so for security reasons should not
contain input from the end-user.
    

    
      The locals object is used by view engines to render a response. The object
keys may be particularly sensitive and should not contain user-controlled
input, as it may affect the operation of the view engine or provide a path to
cross-site scripting. Consult the documentation for the used view engine for
additional considerations.
    

    
      The local variable cache enables view caching. Set it to true,
to cache the view during development; view caching is enabled in production by default.
    

    // send the rendered view to the client
res.render('index')

// if a callback is specified, the rendered HTML string has to be sent explicitly
res.render('index', function (err, html) {
  res.send(html)
})

// pass a local variable to the view
res.render('user', { name: 'Tobi' }, function (err, html) {
  // ...
})
    

  

  
  res.req

This property holds a reference to the request object
that relates to this response object.



  
    res.send([body])

    Sends the HTTP response.

    The body parameter can be a Buffer object, a String, an object, Boolean, or an Array.
For example:

    res.send(Buffer.from('whoop'))
res.send({ some: 'json' })
res.send('<p>some html</p>')
res.status(404).send('Sorry, we cannot find that!')
res.status(500).send({ error: 'something blew up' })
    

    This method performs many useful tasks for simple non-streaming responses:
For example, it automatically assigns the Content-Length HTTP response header field
(unless previously defined) and provides automatic HEAD and HTTP cache freshness support.

    When the parameter is a Buffer object, the method sets the Content-Type
response header field  to “application/octet-stream”, unless previously defined as shown below:

    res.set('Content-Type', 'text/html')
res.send(Buffer.from('<p>some html</p>'))
    

    When the parameter is a String, the method sets the Content-Type to “text/html”:

    res.send('<p>some html</p>')
    

    When the parameter is an Array or Object, Express responds with the JSON representation:

    res.send({ user: 'tobi' })
res.send([1, 2, 3])
    

  

  
    res.sendFile(path [, options] [, fn])

    
      res.sendFile() is supported by Express v4.8.0 onwards.
    

    Transfers the file at the given path. Sets the Content-Type response HTTP header field
based on the filename’s extension. Unless the root option is set in
the options object, path must be an absolute path to the file.

    
      This API provides access to data on the running file system. Ensure that either (a) the way in
which the path argument was constructed into an absolute path is secure if it contains user
input or (b) set the root option to the absolute path of a directory to contain access within.

      When the root option is provided, the path argument is allowed to be a relative path,
including containing ... Express will validate that the relative path provided as path will
resolve within the given root option.
    

    The following table provides details on the options parameter.

    

      
        
          
            Property
            Description
            Default
            Availability
          
        
        
          
            maxAge
            Sets the max-age property of the Cache-Control header in milliseconds or a string in ms format
            0
             
          
          
            root
            Root directory for relative filenames.
             
             
          
          
            lastModified
            Sets the Last-Modified header to the last modified date of the file on the OS. Set false to disable it.
            Enabled
            4.9.0+
          
          
            headers
            Object containing HTTP headers to serve with the file.
             
             
          
          
            dotfiles
            Option for serving dotfiles. Possible values are “allow”, “deny”, “ignore”.
            “ignore”
             
          
          
            acceptRanges
            Enable or disable accepting ranged requests.
            true
            4.14+
          
          
            cacheControl
            Enable or disable setting Cache-Control response header.
            true
            4.14+
          
          
            immutable
            Enable or disable the immutable directive in the Cache-Control response header. If enabled, the maxAge option should also be specified to enable caching. The immutable directive will prevent supported clients from making conditional requests during the life of the maxAge option to check if the file has changed.
            false
            4.16+
          
        
      

    

    The method invokes the callback function fn(err) when the transfer is complete
or when an error occurs. If the callback function is specified and an error occurs,
the callback function must explicitly handle the response process either by
ending the request-response cycle, or by passing control to the next route.

    Here is an example of using res.sendFile with all its arguments.

    app.get('/file/:name', function (req, res, next) {
  var options = {
    root: path.join(__dirname, 'public'),
    dotfiles: 'deny',
    headers: {
      'x-timestamp': Date.now(),
      'x-sent': true
    }
  }

  var fileName = req.params.name
  res.sendFile(fileName, options, function (err) {
    if (err) {
      next(err)
    } else {
      console.log('Sent:', fileName)
    }
  })
})
    

    The following example illustrates using
res.sendFile to provide fine-grained support for serving files:

    app.get('/user/:uid/photos/:file', function (req, res) {
  var uid = req.params.uid
  var file = req.params.file

  req.user.mayViewFilesFrom(uid, function (yes) {
    if (yes) {
      res.sendFile('/uploads/' + uid + '/' + file)
    } else {
      res.status(403).send("Sorry! You can't see that.")
    }
  })
})
    
    For more information, or if you have issues or concerns, see send.

  

  
    res.sendStatus(statusCode)

    Sets the response HTTP status code to statusCode and sends the registered status message as the text response body. If an unknown status code is specified, the response body will just be the code number.

    res.sendStatus(404)
    

    
      Some versions of Node.js will throw when res.statusCode is set to an
invalid HTTP status code (outside of the range 100 to 599). Consult
the HTTP server documentation for the Node.js version being used.
    

    More about HTTP Status Codes

  

  
    res.set(field [, value])

    Sets the response’s HTTP header field to value.
To set multiple fields at once, pass an object as the parameter.

    res.set('Content-Type', 'text/plain')

res.set({
  'Content-Type': 'text/plain',
  'Content-Length': '123',
  ETag: '12345'
})
    

    Aliased as res.header(field [, value]).

  

  
    res.status(code)

    Sets the HTTP status for the response.
It is a chainable alias of Node’s response.statusCode.

    res.status(403).end()
res.status(400).send('Bad Request')
res.status(404).sendFile('/absolute/path/to/404.png')
    

  

  
    res.type(type)

    Sets the Content-Type HTTP header to the MIME type as determined by the specified type. If type contains the “/” character, then it sets the Content-Type to the exact value of type, otherwise it is assumed to be a file extension and the MIME type is looked up in a mapping using the express.static.mime.lookup() method.

    res.type('.html')
// => 'text/html'
res.type('html')
// => 'text/html'
res.type('json')
// => 'application/json'
res.type('application/json')
// => 'application/json'
res.type('png')
// => 'image/png'
    

    Aliased as res.contentType(type).

  

  
    res.vary(field)

    Adds the field to the Vary response header, if it is not there already.

    res.vary('User-Agent').render('docs')
    

  

  Router

  
    A router object is an instance of middleware and routes. You can think of it
as a “mini-application,” capable only of performing middleware and routing
functions. Every Express application has a built-in app router.

    A router behaves like middleware itself, so you can use it as an argument to
app.use() or as the argument to another router’s  use() method.

    The top-level express object has a Router() method that creates a new router object.

    Once you’ve created a router object, you can add middleware and HTTP method routes (such as get, put, post,
and so on) to it just like an application.  For example:

    // invoked for any requests passed to this router
router.use(function (req, res, next) {
  // .. some logic here .. like any other middleware
  next()
})

// will handle any request that ends in /events
// depends on where the router is "use()'d"
router.get('/events', function (req, res, next) {
  // ..
})
    

    You can then use a router for a particular root URL in this way separating your routes into files or even mini-apps.

    // only requests to /calendar/* will be sent to our "router"
app.use('/calendar', router)
    

    Keep in mind that any middleware applied to a router will run for all requests on that router’s path, even those that aren’t part of the router.

  

  Methods

  
    router.all(path, [callback, ...] callback)

    This method is just like the router.METHOD() methods, except that it matches all HTTP methods (verbs).

    This method is extremely useful for
mapping “global” logic for specific path prefixes or arbitrary matches.
For example, if you placed the following route at the top of all other
route definitions, it would require that all routes from that point on
would require authentication, and automatically load a user. Keep in mind
that these callbacks do not have to act as end points; loadUser
can perform a task, then call next() to continue matching subsequent
routes.

    router.all('*', requireAuthentication, loadUser)
    

    Or the equivalent:

    router.all('*', requireAuthentication)
router.all('*', loadUser)
    

    Another example of this is white-listed “global” functionality. Here
the example is much like before, but it only restricts paths prefixed with
“/api”:

    router.all('/api/*', requireAuthentication)
    

  

  
    router.METHOD(path, [callback, ...] callback)

    The router.METHOD() methods provide the routing functionality in Express,
where METHOD is one of the HTTP methods, such as GET, PUT, POST, and so on,
in lowercase.  Thus, the actual methods are router.get(), router.post(),
router.put(), and so on.

    
      The router.get() function is automatically called for the HTTP HEAD method in
  addition to the GET method if router.head() was not called for the
  path before router.get().
    

    You can provide multiple callbacks, and all are treated equally, and behave just
like middleware, except that these callbacks may invoke next('route')
to bypass the remaining route callback(s).  You can use this mechanism to perform
pre-conditions on a route then pass control to subsequent routes when there is no
reason to proceed with the route matched.

    The following snippet illustrates the most simple route definition possible.
Express translates the path strings to regular expressions, used internally
to match incoming requests. Query strings are not considered when performing
these matches, for example “GET /” would match the following route, as would
“GET /?name=tobi”.

    router.get('/', function (req, res) {
  res.send('hello world')
})
    

    You can also use regular expressions—useful if you have very specific
constraints, for example the following would match “GET /commits/71dbb9c” as well
as “GET /commits/71dbb9c..4c084f9”.

    router.get(/^\/commits\/(\w+)(?:\.\.(\w+))?$/, function (req, res) {
  var from = req.params[0]
  var to = req.params[1] || 'HEAD'
  res.send('commit range ' + from + '..' + to)
})
    

  

  
    router.param(name, callback)

    Adds callback triggers to route parameters, where name is the name of the parameter and callback is the callback function. Although name is technically optional, using this method without it is deprecated starting with Express v4.11.0 (see below).

    The parameters of the callback function are:

    
      req, the request object.
      res, the response object.
      next, indicating the next middleware function.
      The value of the name parameter.
      The name of the parameter.
    

    
      Unlike app.param(), router.param() does not accept an array of route parameters.
    

    For example, when :user is present in a route path, you may map user loading logic to automatically provide req.user to the route, or perform validations on the parameter input.

    router.param('user', function (req, res, next, id) {
  // try to get the user details from the User model and attach it to the request object
  User.find(id, function (err, user) {
    if (err) {
      next(err)
    } else if (user) {
      req.user = user
      next()
    } else {
      next(new Error('failed to load user'))
    }
  })
})
    

    Param callback functions are local to the router on which they are defined. They are not inherited by mounted apps or routers, nor are they triggered for route parameters inherited from parent routers. Hence, param callbacks defined on router will be triggered only by route parameters defined on router routes.

    A param callback will be called only once in a request-response cycle, even if the parameter is matched in multiple routes, as shown in the following examples.

    router.param('id', function (req, res, next, id) {
  console.log('CALLED ONLY ONCE')
  next()
})

router.get('/user/:id', function (req, res, next) {
  console.log('although this matches')
  next()
})

router.get('/user/:id', function (req, res) {
  console.log('and this matches too')
  res.end()
})
    

    On GET /user/42, the following is printed:

    CALLED ONLY ONCE
although this matches
and this matches too
    

    
      The following section describes router.param(callback), which is deprecated as of v4.11.0.
    

    The behavior of the router.param(name, callback) method can be altered entirely by passing only a function to router.param(). This function is a custom implementation of how router.param(name, callback) should behave - it accepts two parameters and must return a middleware.

    The first parameter of this function is the name of the URL parameter that should be captured, the second parameter can be any JavaScript object which might be used for returning the middleware implementation.

    The middleware returned by the function decides the behavior of what happens when a URL parameter is captured.

    In this example, the router.param(name, callback) signature is modified to router.param(name, accessId). Instead of accepting a name and a callback, router.param() will now accept a name and a number.

    var express = require('express')
var app = express()
var router = express.Router()

// customizing the behavior of router.param()
router.param(function (param, option) {
  return function (req, res, next, val) {
    if (val === option) {
      next()
    } else {
      res.sendStatus(403)
    }
  }
})

// using the customized router.param()
router.param('id', '1337')

// route to trigger the capture
router.get('/user/:id', function (req, res) {
  res.send('OK')
})

app.use(router)

app.listen(3000, function () {
  console.log('Ready')
})
    

    In this example, the router.param(name, callback) signature remains the same, but instead of a middleware callback, a custom data type checking function has been defined to validate the data type of the user id.

    router.param(function (param, validator) {
  return function (req, res, next, val) {
    if (validator(val)) {
      next()
    } else {
      res.sendStatus(403)
    }
  }
})

router.param('id', function (candidate) {
  return !isNaN(parseFloat(candidate)) && isFinite(candidate)
})
    

  

  
    router.route(path)

    Returns an instance of a single route which you can then use to handle HTTP verbs
with optional middleware. Use router.route() to avoid duplicate route naming and
thus typing errors.

    Building on the router.param() example above, the following code shows how to use
router.route() to specify various HTTP method handlers.

    var router = express.Router()

router.param('user_id', function (req, res, next, id) {
  // sample user, would actually fetch from DB, etc...
  req.user = {
    id: id,
    name: 'TJ'
  }
  next()
})

router.route('/users/:user_id')
  .all(function (req, res, next) {
    // runs for all HTTP verbs first
    // think of it as route specific middleware!
    next()
  })
  .get(function (req, res, next) {
    res.json(req.user)
  })
  .put(function (req, res, next) {
    // just an example of maybe updating the user
    req.user.name = req.params.name
    // save user ... etc
    res.json(req.user)
  })
  .post(function (req, res, next) {
    next(new Error('not implemented'))
  })
  .delete(function (req, res, next) {
    next(new Error('not implemented'))
  })
    

    This approach re-uses the single /users/:user_id path and adds handlers for
various HTTP methods.

    
       Note
      When you use router.route(), middleware ordering is based on when the route is created, not when method handlers are added to the route.  For this purpose, you can consider method handlers to belong to the route to which they were added.
    

  

  
    router.use([path], [function, ...] function)

    Uses the specified middleware function or functions, with optional mount path path, that defaults to “/”.

    This method is similar to app.use(). A simple example and use case is described below.
See app.use() for more information.

    Middleware is like a plumbing pipe: requests start at the first middleware function defined
and work their way “down” the middleware stack processing for each path they match.

    var express = require('express')
var app = express()
var router = express.Router()

// simple logger for this router's requests
// all requests to this router will first hit this middleware
router.use(function (req, res, next) {
  console.log('%s %s %s', req.method, req.url, req.path)
  next()
})

// this will only be invoked if the path starts with /bar from the mount point
router.use('/bar', function (req, res, next) {
  // ... maybe some additional /bar logging ...
  next()
})

// always invoked
router.use(function (req, res, next) {
  res.send('Hello World')
})

app.use('/foo', router)

app.listen(3000)
    

    The “mount” path is stripped and is not visible to the middleware function.
The main effect of this feature is that a mounted middleware function may operate without
code changes regardless of its “prefix” pathname.

    The order in which you define middleware with router.use() is very important.
They are invoked sequentially, thus the order defines middleware precedence. For example,
usually a logger is the very first middleware you would use, so that every request gets logged.

    var logger = require('morgan')
var path = require('path')

router.use(logger())
router.use(express.static(path.join(__dirname, 'public')))
router.use(function (req, res) {
  res.send('Hello')
})
    

    Now suppose you wanted to ignore logging requests for static files, but to continue
logging routes and middleware defined after logger().  You would simply move the call to express.static() to the top,
before adding the logger middleware:

    router.use(express.static(path.join(__dirname, 'public')))
router.use(logger())
router.use(function (req, res) {
  res.send('Hello')
})
    

    Another example is serving files from multiple directories,
giving precedence to “./public” over the others:

    router.use(express.static(path.join(__dirname, 'public')))
router.use(express.static(path.join(__dirname, 'files')))
router.use(express.static(path.join(__dirname, 'uploads')))
    

    The router.use() method also supports named parameters so that your mount points
for other routers can benefit from preloading using named parameters.

    NOTE: Although these middleware functions are added via a particular router, when
they run is defined by the path they are attached to (not the router). Therefore,
middleware added via one router may run for other routers if its routes
match. For example, this code shows two different routers mounted on the same path:

    var authRouter = express.Router()
var openRouter = express.Router()

authRouter.use(require('./authenticate').basic(usersdb))

authRouter.get('/:user_id/edit', function (req, res, next) {
  // ... Edit user UI ...
})
openRouter.get('/', function (req, res, next) {
  // ... List users ...
})
openRouter.get('/:user_id', function (req, res, next) {
  // ... View user ...
})

app.use('/users', authRouter)
app.use('/users', openRouter)
    

    Even though the authentication middleware was added via the authRouter it will run on the routes defined by the openRouter as well since both routers were mounted on /users.  To avoid this behavior, use different paths for each router.

  



              
    
    Edit this page\n\n\n\nExpress 3.x IS END-OF-LIFE AND NO LONGER MAINTAINED

    Known and unknown security and performance issues in 3.x have not been addressed since the last update (1 August, 2015). It is highly recommended to use the latest version of Express.

    If you are unable to upgrade past 3.x, please consider Commercial Support Options.
  

  3.x API

  express()

  Creates an Express application. The express() function is a top-level function exported by the express module.

  var express = require('express')
var app = express()

app.get('/', function (req, res) {
  res.send('hello world')
})

app.listen(3000)
  

  Application

  
    app.set(name, value)

    Assigns setting name to value.

    app.set('title', 'My Site')
app.get('title')
// => "My Site"
    

  

  
    app.get(name)

    Get setting name value.

    app.get('title')
// => undefined

app.set('title', 'My Site')
app.get('title')
// => "My Site"
    

  

  
    app.enable(name)

    Set setting name to true.

    app.enable('trust proxy')
app.get('trust proxy')
// => true
    

  

  
    app.disable(name)

    Set setting name to false.

    app.disable('trust proxy')
app.get('trust proxy')
// => false
    

  

  
    app.enabled(name)

    Check if setting name is enabled.

    app.enabled('trust proxy')
// => false

app.enable('trust proxy')
app.enabled('trust proxy')
// => true
    

  

  
    app.disabled(name)

    Check if setting name is disabled.

    app.disabled('trust proxy')
// => true

app.enable('trust proxy')
app.disabled('trust proxy')
// => false
    

  

  
    app.configure([env], callback)

    Conditionally invoke callback when env matches app.get('env'),
aka process.env.NODE_ENV. This method remains for legacy reasons, and is effectively
an if statement as illustrated in the following snippets. These functions are not
required in order to use app.set() and other configuration methods.

    // all environments
app.configure(function () {
  app.set('title', 'My Application')
})

// development only
app.configure('development', function () {
  app.set('db uri', 'localhost/dev')
})

// production only
app.configure('production', function () {
  app.set('db uri', 'n.n.n.n/prod')
})
    

    Is effectively sugar for:

    // all environments
app.set('title', 'My Application')

// development only
if (app.get('env') === 'development') {
  app.set('db uri', 'localhost/dev')
}

// production only
if (app.get('env') === 'production') {
  app.set('db uri', 'n.n.n.n/prod')
}
    

  

  
    app.use([path], function)

    Use the given middleware function, with optional mount path,
defaulting to “/”.

    var express = require('express')
var app = express()

// simple logger
app.use(function (req, res, next) {
  console.log('%s %s', req.method, req.url)
  next()
})

// respond
app.use(function (req, res, next) {
  res.send('Hello World')
})

app.listen(3000)
    

    The “mount” path is stripped and is not visible
to the middleware function. The main effect of this feature is that
mounted middleware may operate without code changes regardless of its “prefix”
pathname.

    
      A route will match any path that follows its path immediately with either a “/” or a “.”. For example: app.use('/apple', ...) will match /apple, /apple/images, /apple/images/news, /apple.html, /apple.html.txt, and so on.
    

    Here’s a concrete example, take the typical use-case of serving files in ./public
using the express.static() middleware:

    // GET /javascripts/jquery.js
// GET /style.css
// GET /favicon.ico
app.use(express.static(path.join(__dirname, 'public')))
    

    Say for example you wanted to prefix all static files with “/static”, you could
use the “mounting” feature to support this. Mounted middleware functions are not
invoked unless the req.url contains this prefix, at which point
it is stripped when the function is invoked. This affects this function only,
subsequent middleware will see req.url with “/static” included
unless they are mounted as well.

    // GET /static/javascripts/jquery.js
// GET /static/style.css
// GET /static/favicon.ico
app.use('/static', express.static(path.join(__dirname, 'public')))
    

    The order of which middleware are “defined” using app.use() is
very important, they are invoked sequentially, thus this defines middleware
precedence. For example usually express.logger() is the very
first middleware you would use, logging every request:

    app.use(express.logger())
app.use(express.static(path.join(__dirname, 'public')))
app.use(function (req, res) {
  res.send('Hello')
})
    

    Now suppose you wanted to ignore logging requests for static files, but to
continue logging routes and middleware defined after logger(),
you would simply move static() above:

    app.use(express.static(path.join(__dirname, 'public')))
app.use(express.logger())
app.use(function (req, res) {
  res.send('Hello')
})
    

    Another concrete example would be serving files from multiple directories,
giving precedence to “./public” over the others:

    app.use(express.static(path.join(__dirname, 'public')))
app.use(express.static(path.join(__dirname, 'files')))
app.use(express.static(path.join(__dirname, 'uploads')))
    

  

  
    settings

    The following settings are provided to alter how Express will behave:

    
      env Environment mode, defaults to process.env.NODE_ENV or “development”
      trust proxy Enables reverse proxy support, disabled by default
      jsonp callback name Changes the default callback name of ?callback=
      json replacer JSON replacer callback, null by default
      json spaces JSON response spaces for formatting, defaults to 2 in development, 0 in production
      case sensitive routing Enable case sensitivity, disabled by default, treating “/Foo” and “/foo” as the same
      strict routing Enable strict routing, by default “/foo” and “/foo/” are treated the same by the router
      view cache Enables view template compilation caching, enabled in production by default
      view engine The default engine extension to use when omitted
      views The view directory path, defaulting to “process.cwd() + ‘/views’”
    

  

  
    app.engine(ext, callback)

    Register the given template engine callback as ext

    By default will require() the engine based on the
file extension. For example if you try to render
a “foo.jade” file Express will invoke the following internally,
and cache the require() on subsequent calls to increase
performance.

    app.engine('jade', require('jade').__express)
    

    For engines that do not provide .__express out of the box -
or if you wish to “map” a different extension to the template engine
you may use this method. For example mapping the EJS template engine to
“.html” files:

    app.engine('html', require('ejs').renderFile)
    

    In this case EJS provides a .renderFile() method with
the same signature that Express expects: (path, options, callback),
though note that it aliases this method as ejs.__express internally
so if you’re using “.ejs” extensions you dont need to do anything.

    Some template engines do not follow this convention, the
consolidate.js
library was created to map all of node’s popular template
engines to follow this convention, thus allowing them to
work seemlessly within Express.

    var engines = require('consolidate')
app.engine('haml', engines.haml)
app.engine('html', engines.hogan)
    

  

  
    app.param([name], callback)

    Map logic to route parameters. For example when :user
is present in a route path you may map user loading logic to automatically
provide req.user to the route, or perform validations
on the parameter input.

    The following snippet illustrates how the callback
is much like middleware, thus supporting async operations, however
providing the additional value of the parameter, here named as id.
An attempt to load the user is then performed, assigning req.user,
otherwise passing an error to next(err).

    app.param('user', function (req, res, next, id) {
  User.find(id, function (err, user) {
    if (err) {
      next(err)
    } else if (user) {
      req.user = user
      next()
    } else {
      next(new Error('failed to load user'))
    }
  })
})
    

    Alternatively you may pass only a callback, in which
case you have the opportunity to alter the app.param() API.
For example the express-params
defines the following callback which allows you to restrict parameters to a given
regular expression.

    This example is a bit more advanced, checking if the second argument is a regular
expression, returning the callback which acts much like the “user” param example.

    app.param(function (name, fn) {
  if (fn instanceof RegExp) {
    return function (req, res, next, val) {
      var captures
      if ((captures = fn.exec(String(val)))) {
        req.params[name] = captures
        next()
      } else {
        next('route')
      }
    }
  }
})
    

    The method could now be used to effectively validate parameters, or also
parse them to provide capture groups:

    app.param('id', /^\d+$/)

app.get('/user/:id', function (req, res) {
  res.send('user ' + req.params.id)
})

app.param('range', /^(\w+)\.\.(\w+)?$/)

app.get('/range/:range', function (req, res) {
  var range = req.params.range
  res.send('from ' + range[1] + ' to ' + range[2])
})
    

  

  
    app.VERB(path, [callback...], callback)

    The app.VERB() methods provide the routing functionality
in Express, where VERB is one of the HTTP verbs, such
as app.post(). Multiple callbacks may be given, all are treated
equally, and behave just like middleware, with the one exception that
these callbacks may invoke next('route') to bypass the
remaining route callback(s). This mechanism can be used to perform pre-conditions
on a route then pass control to subsequent routes when there is no reason to proceed
with the route matched.

    The following snippet illustrates the most simple route definition possible. Express
translates the path strings to regular expressions, used internally to match incoming requests.
Query strings are not considered when peforming these matches, for example “GET /”
would match the following route, as would “GET /?name=tobi”.

    app.get('/', function (req, res) {
  res.send('hello world')
})
    

    Regular expressions may also be used, and can be useful
if you have very specific restraints, for example the following
would match “GET /commits/71dbb9c” as well as “GET /commits/71dbb9c..4c084f9”.

    app.get(/^\/commits\/(\w+)(?:\.\.(\w+))?$/, function (req, res) {
  var from = req.params[0]
  var to = req.params[1] || 'HEAD'
  res.send('commit range ' + from + '..' + to)
})
    

    Several callbacks may also be passed, useful for re-using middleware
that load resources, perform validations, etc.

    app.get('/user/:id', user.load, function () {
  // ...
})
    

    These callbacks may be passed within arrays as well, these arrays are
simply flattened when passed:

    var middleware = [loadForum, loadThread]

app.get('/forum/:fid/thread/:tid', middleware, function () {
  // ...
})

app.post('/forum/:fid/thread/:tid', middleware, function () {
  // ...
})
    

  

  
    app.all(path, [callback...], callback)

    This method functions just like the app.VERB() methods,
however it matches all HTTP verbs.

    This method is extremely useful for
mapping “global” logic for specific path prefixes or arbitrary matches.
For example if you placed the following route at the top of all other
route definitions, it would require that all routes from that point on
would require authentication, and automatically load a user. Keep in mind
that these callbacks do not have to act as end points, loadUser
can perform a task, then next() to continue matching subsequent
routes.

    app.all('*', requireAuthentication, loadUser)
    

    Or the equivalent:

    app.all('*', requireAuthentication)
app.all('*', loadUser)
    

    Another great example of this is white-listed “global” functionality. Here
the example is much like before, however only restricting paths prefixed with
“/api”:

    app.all('/api/*', requireAuthentication)
    

  

  
    app.locals

    Application local variables are provided to all templates
rendered within the application. This is useful for providing
helper functions to templates, as well as app-level data.

    app.locals.title = 'My App'
app.locals.strftime = require('strftime')
    

    The app.locals object is a JavaScript Function,
which when invoked with an object will merge properties into itself, providing
a simple way to expose existing objects as local variables.

    app.locals({
  title: 'My App',
  phone: '1-250-858-9990',
  email: '[email protected]'
})

console.log(app.locals.title)
// => 'My App'

console.log(app.locals.email)
// => '[email protected]'
    

    A consequence of the app.locals Object being ultimately a Javascript Function Object is that you must not reuse existing (native) named properties for your own variable names, such as name, apply, bind, call, arguments, length, constructor.

    app.locals({ name: 'My App' })

console.log(app.locals.name)
// => return 'app.locals' in place of 'My App' (app.locals is a Function !)
// => if name's variable is used in a template, a ReferenceError will be returned.
    

    The full list of native named properties can be found in many specifications. The JavaScript specification introduced original properties, some of which still recognized by modern engines, and the EcmaScript specification then built on it and normalized the set of properties, adding new ones and removing deprecated ones. Check out properties for Functions and Objects if interested.

    By default Express exposes only a single app-level local variable, settings.

    app.set('title', 'My App')
// use settings.title in a view
    

  

  
    app.render(view, [options], callback)

    Render a view with a callback responding with
the rendered string. This is the app-level variant of res.render(),
and otherwise behaves the same way.

    app.render('email', function (err, html) {
  // ...
})

app.render('email', { name: 'Tobi' }, function (err, html) {
  // ...
})
    

  

  
    app.routes

    The app.routes object houses all of the routes defined mapped
by the associated HTTP verb. This object may be used for introspection capabilities,
for example Express uses this internally not only for routing but to provide default
    OPTIONS
    behaviour unless app.options() is used. Your application
or framework may also remove routes by simply by removing them from this object.

    The output of console.log(app.routes):

    { get:
   [ { path: '/',
       method: 'get',
       callbacks: [Object],
       keys: [],
       regexp: /^\/\/?$/i },
     { path: '/user/:id',
       method: 'get',
       callbacks: [Object],
       keys: [{ name: 'id', optional: false }],
       regexp: /^\/user\/(?:([^\/]+?))\/?$/i } ],
  delete:
   [ { path: '/user/:id',
       method: 'delete',
       callbacks: [Object],
       keys: [Object],
       regexp: /^\/user\/(?:([^\/]+?))\/?$/i } ] }
    

  

  
    app.listen()

    Bind and listen for connections on the given host and port,
this method is identical to node’s http.Server#listen().

    var express = require('express')
var app = express()
app.listen(3000)
    

    The app returned by express() is in fact a JavaScript
Function, designed to be passed to node’s http servers as a callback
to handle requests. This allows you to provide both HTTP and HTTPS versions of
your app with the same codebase easily, as the app does not inherit from these,
it is simply a callback:

    var express = require('express')
var https = require('https')
var http = require('http')
var app = express()

http.createServer(app).listen(80)
https.createServer(options, app).listen(443)
    

    The app.listen() method is simply a convenience method defined as,
if you wish to use HTTPS or provide both, use the technique above.

    app.listen = function () {
  var server = http.createServer(this)
  return server.listen.apply(server, arguments)
}
    

  

  Request

  The req object is an enhanced version of Node’s own request object
and supports all built-in fields and methods.

  
    req.params

    This property is an array containing properties mapped to the named route “parameters”.
For example if you have the route /user/:name, then the “name” property
is available to you as req.params.name. This object defaults to {}.

    // GET /user/tj
console.dir(req.params.name)
// => 'tj'
    

    When a regular expression is used for the route definition, capture groups
are provided in the array using req.params[N], where N
is the nth capture group. This rule is applied to unnamed wild-card matches
with string routes such as /file/*:

    // GET /file/javascripts/jquery.js
console.dir(req.params[0])
// => 'javascripts/jquery.js'
    

  

  
    req.query

    This property is an object containing the parsed query-string,
defaulting to {}.

    // GET /search?q=tobi+ferret
console.dir(req.query.q)
// => 'tobi ferret'

// GET /shoes?order=desc&shoe[color]=blue&shoe[type]=converse
console.dir(req.query.order)
// => 'desc'

console.dir(req.query.shoe.color)
// => 'blue'

console.dir(req.query.shoe.type)
// => 'converse'
    

  

  
    req.body

    This property is an object containing the parsed request body. This feature
is provided by the bodyParser() middleware, though other body
parsing middleware may follow this convention as well. This property
defaults to {} when bodyParser() is used.

    // POST user[name]=tobi&user[email][email protected]
console.log(req.body.user.name)
// => "tobi"

console.log(req.body.user.email)
// => "[email protected]"

// POST { "name": "tobi" }
console.log(req.body.name)
// => "tobi"
    

  

  
    req.files

    This property is an object of the files uploaded. This feature
is provided by the bodyParser() middleware, though other body
parsing middleware may follow this convention as well. This property
defaults to {} when bodyParser() is used.

    For example if a file field was named “image”,
and a file was uploaded, req.files.image would contain
the following File object:

    { size: 74643,
  path: '/tmp/8ef9c52abe857867fd0a4e9a819d1876',
  name: 'edge.png',
  type: 'image/png',
  hash: false,
  lastModifiedDate: Thu Aug 09 2012 20:07:51 GMT-0700 (PDT),
  _writeStream:
   { path: '/tmp/8ef9c52abe857867fd0a4e9a819d1876',
     fd: 13,
     writable: false,
     flags: 'w',
     encoding: 'binary',
     mode: 438,
     bytesWritten: 74643,
     busy: false,
     _queue: [],
     _open: [Function],
     drainable: true },
  length: [Getter],
  filename: [Getter],
  mime: [Getter] }
    

    The bodyParser() middleware utilizes the
node-formidable
module internally, and accepts the same options. An example of this
is the keepExtensions formidable option, defaulting to false
which in this case gives you the filename “/tmp/8ef9c52abe857867fd0a4e9a819d1876” void of
the “.png” extension. To enable this, and others you may pass them to bodyParser():

    app.use(express.bodyParser({ keepExtensions: true, uploadDir: '/my/files' }))
    

  

  
    req.param(name)

    Return the value of param name when present.

    // ?name=tobi
req.param('name')
// => "tobi"

// POST name=tobi
req.param('name')
// => "tobi"

// /user/tobi for /user/:name
req.param('name')
// => "tobi"
    

    Lookup is performed in the following order:

    
      req.params
      req.body
      req.query
    

    Direct access to req.body, req.params,
and req.query should be favoured for clarity - unless
you truly accept input from each object.

  

  
    req.route

    The currently matched Route containing
several properties such as the route’s original path
string, the regexp generated, and so on.

    app.get('/user/:id?', function (req, res) {
  console.dir(req.route)
})
    

    Example output from the previous snippet:

    { path: '/user/:id?',
  method: 'get',
  callbacks: [ [Function] ],
  keys: [ { name: 'id', optional: true } ],
  regexp: /^\/user(?:\/([^\/]+?))?\/?$/i,
  params: [ id: '12' ] }
    

  

  
    req.cookies

    This object requires the cookieParser() middleware for use.
It contains cookies sent by the user-agent. If no cookies are sent, it
defaults to {}.

    // Cookie: name=tj
console.log(req.cookies.name)
// => "tj"
    

  

  
    req.signedCookies

    This object requires the cookieParser(secret) middleware for use.
It contains signed cookies sent by the user-agent, unsigned and ready for use.
Signed cookies reside in a different object to show developer intent; otherwise,
a malicious attack could be placed on req.cookie values (which are easy to spoof).
Note that signing a cookie does not make it “hidden” or encrypted; this simply
prevents tampering (because the secret used to sign is private). If no signed
cookies are sent, it defaults to {}.

    // Cookie: user=tobi.CP7AWaXDfAKIRfH49dQzKJx7sKzzSoPq7/AcBBRVwlI3
console.dir(req.signedCookies.user)
// => 'tobi'
    

  

  
    req.get(field)

    Get the case-insensitive request header field. The “Referrer” and “Referer” fields are interchangeable.

    req.get('Content-Type')
// => "text/plain"

req.get('content-type')
// => "text/plain"

req.get('Something')
// => undefined
    

    p Aliased as req.header(field).

  

  
    req.accepts(types)

    Check if the given types are acceptable, returning
the best match when true, otherwise undefined - in which
case you should respond with 406 “Not Acceptable”.

    The type value may be a single mime type string
such as “application/json”, the extension name
such as “json”, a comma-delimited list or an array. When a list
or array is given the best match, if any is returned.

    // Accept: text/html
req.accepts('html')
// => "html"

// Accept: text/*, application/json
req.accepts('html')
// => "html"
req.accepts('text/html')
// => "text/html"
req.accepts('json, text')
// => "json"
req.accepts('application/json')
// => "application/json"

// Accept: text/*, application/json
req.accepts('image/png')
req.accepts('png')
// => undefined

// Accept: text/*;q=.5, application/json
req.accepts(['html', 'json'])
req.accepts('html, json')
// => "json"
    

  

  
    req.accepted

    Return an array of Accepted media types ordered from highest quality to lowest.

    [ { value: 'application/json',
    quality: 1,
    type: 'application',
    subtype: 'json' },
   { value: 'text/html',
     quality: 0.5,
     type: 'text',
     subtype: 'html' } ]
    

  

  
    req.is(type)

    Check if the incoming request contains the “Content-Type”
header field, and it matches the give mime type.

    // With Content-Type: text/html; charset=utf-8
req.is('html')
req.is('text/html')
req.is('text/*')
// => true

// When Content-Type is application/json
req.is('json')
req.is('application/json')
req.is('application/*')
// => true

req.is('html')
// => false
    

  

  
    req.ip

    Return the remote address, or when “trust proxy”
is enabled - the upstream address.

    console.dir(req.ip)
// => '127.0.0.1'
    

  

  
    req.ips

    When “trust proxy” is true, parse
the “X-Forwarded-For” ip address list
and return an array, otherwise an empty
array is returned.

    For example if the value were “client, proxy1, proxy2”
you would receive the array ["client", "proxy1", "proxy2"]
where “proxy2” is the furthest down-stream.

  

  
    req.path

    Returns the request URL pathname.

    // example.com/users?sort=desc
console.dir(req.path)
// => '/users'
    

  

  
    req.host

    Returns the hostname from the “Host” header field (void of portno).

    // Host: "example.com:3000"
console.dir(req.host)
// => 'example.com'
    

  

  
    req.fresh

    Check if the request is fresh - aka Last-Modified and/or the ETag still match,
indicating that the resource is “fresh”.

    console.dir(req.fresh)
// => true
    

  

  
    req.stale

    Check if the request is stale - aka Last-Modified and/or the ETag do not match,
indicating that the resource is “stale”.

    console.dir(req.stale)
// => true
    

  

  
    req.xhr

    Check if the request was issued with the “X-Requested-With”
header field set to “XMLHttpRequest” (jQuery etc).

    console.dir(req.xhr)
// => true
    

  

  
    req.protocol

    Return the protocol string “http” or “https”
when requested with TLS. When the “trust proxy”
setting is enabled the “X-Forwarded-Proto” header
field will be trusted. If you’re running behind
a reverse proxy that supplies https for you this
may be enabled.

    console.dir(req.protocol)
// => 'http'
    

  

  
    req.secure

    Check if a TLS connection is established. This is a short-hand for:

    console.dir(req.protocol === 'https')
// => true
    

  

  
    req.subdomains

    Return subdomains as an array.

    // Host: "tobi.ferrets.example.com"
console.dir(req.subdomains)
// => ['ferrets', 'tobi']
    

  

  
    req.originalUrl

    This property is much like req.url, however it retains
the original request url, allowing you to rewrite req.url
freely for internal routing purposes. For example the “mounting” feature
of app.use() will rewrite req.url to
strip the mount point.

    // GET /search?q=something
console.log(req.originalUrl)
// => "/search?q=something"
    

  

  
    req.acceptedLanguages

    Return an array of Accepted languages ordered from highest quality to lowest.

    Accept-Language: en;q=.5, en-us
// => ['en-us', 'en']
    

  

  
    req.acceptedCharsets

    Return an array of Accepted charsets ordered from highest quality to lowest.

    Accept-Charset: iso-8859-5;q=.2, unicode-1-1;q=0.8
// => ['unicode-1-1', 'iso-8859-5']
    

  

  
    req.acceptsCharset(charset)

    Check if the given charset are acceptable.

  

  
    req.acceptsLanguage(lang)

    Check if the given lang are acceptable.

  

  
    req.res

    This property holds a reference to the response object
that relates to this request object.

  

  Response

  The res object is an enhanced version of Node’s own response object
and supports all built-in fields and methods.

  
    res.status(code)

    Chainable alias of node’s res.statusCode=.

    res.status(404).sendfile('path/to/404.png')
    

  

  
    res.set(field, [value])

    Set header field to value, or pass an object to set multiple fields at once.

    res.set('Content-Type', 'text/plain')

res.set({
  'Content-Type': 'text/plain',
  'Content-Length': '123',
  ETag: '12345'
})
    

    Aliased as res.header(field, [value]).

  

  
    res.get(field)

    Get the case-insensitive response header field.

    res.get('Content-Type')
// => "text/plain"
    

  

  
    res.cookie(name, value, [options])

    Set cookie name to value, which may be a string or object converted to JSON. The path
option defaults to “/”.

    res.cookie('name', 'tobi', { domain: '.example.com', path: '/admin', secure: true })
res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true })
    

    The maxAge option is a convenience option for setting “expires”
relative to the current time in milliseconds. The following is equivalent to
the previous example.

    res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })
    

    An object may be passed which is then serialized as JSON, which is
automatically parsed by the bodyParser() middleware.

    res.cookie('cart', { items: [1, 2, 3] })
res.cookie('cart', { items: [1, 2, 3] }, { maxAge: 900000 })
    

    Signed cookies are also supported through this method. Simply
pass the signed option. When given res.cookie()
will use the secret passed to express.cookieParser(secret)
to sign the value.

    res.cookie('name', 'tobi', { signed: true })
    

    Later you may access this value through the req.signedCookie
object.

  

  
    res.clearCookie(name, [options])

    Clear cookie name. The path option defaults to “/”.

    res.cookie('name', 'tobi', { path: '/admin' })
res.clearCookie('name', { path: '/admin' })
    

  

  
    res.redirect([status], url)

    Redirect to the given url with optional status code
defaulting to 302 “Found”.

    res.redirect('/foo/bar')
res.redirect('http://example.com')
res.redirect(301, 'http://example.com')
res.redirect('../login')
    

    Express supports a few forms of redirection, first being
a fully qualified URI for redirecting to a different site:

    res.redirect('http://google.com')
    

    The second form is the pathname-relative redirect, for example
if you were on http://example.com/admin/post/new, the
following redirect to /admin would land you at http://example.com/admin:

    res.redirect('/admin')
    

    This next redirect is relative to the mount point of the application. For example
if you have a blog application mounted at /blog, ideally it has no knowledge of
where it was mounted, so where a redirect of /admin/post/new would simply give you
http://example.com/admin/post/new, the following mount-relative redirect would give
you http://example.com/blog/admin/post/new:

    res.redirect('admin/post/new')
    

    Pathname relative redirects are also possible. If you were
on http://example.com/admin/post/new, the following redirect
would land you at http//example.com/admin/post:

    res.redirect('..')
    

    The final special-case is a back redirect, redirecting back to
the Referer (or Referrer), defaulting to / when missing.

    res.redirect('back')
    

  

  
    res.location

    Set the location header.

    res.location('/foo/bar')
res.location('foo/bar')
res.location('http://example.com')
res.location('../login')
res.location('back')
    

    You can use the same kind of urls as in res.redirect().

    For example, if your application is mounted at /blog,
the following would set the location header to
/blog/admin:

    res.location('admin')
    

  

  
    res.charset

    Assign the charset. Defaults to “utf-8”.

    res.charset = 'value'
res.send('<p>some html</p>')
// => Content-Type: text/html; charset=value
    

  

  
    res.send([body|status], [body])

    Send a response.

    res.send(Buffer.from('whoop'))
res.send({ some: 'json' })
res.send('<p>some html</p>')
res.send(404, 'Sorry, we cannot find that!')
res.send(500, { error: 'something blew up' })
res.send(200)
    

    This method performs a myriad of
useful tasks for simple non-streaming responses such
as automatically assigning the Content-Length unless
previously defined and providing automatic HEAD and
HTTP cache freshness support.

    When a Buffer is given
the Content-Type is set to “application/octet-stream”
unless previously defined as shown below:

    res.set('Content-Type', 'text/html')
res.send(Buffer.from('<p>some html</p>'))
    

    When a String is given the
Content-Type is set defaulted to “text/html”:

    res.send('<p>some html</p>')
    

    When an Array or Object is
given Express will respond with the JSON representation:

    res.send({ user: 'tobi' })
res.send([1, 2, 3])
    

    Finally when a Number is given without
any of the previously mentioned bodies, then a response
body string is assigned for you. For example 200 will
respond will the text “OK”, and 404 “Not Found” and so on.

    res.send(200)
res.send(404)
res.send(500)
    

  

  
    res.json([status|body], [body])

    Send a JSON response. This method is identical
to res.send() when an object or
array is passed, however it may be used for
explicit JSON conversion of non-objects (null, undefined, etc),
though these are technically not valid JSON.

    res.json(null)
res.json({ user: 'tobi' })
res.json(500, { error: 'message' })
    

  

  
    res.jsonp([status|body], [body])

    Send a JSON response with JSONP support. This method is identical
to res.json() however opts-in to JSONP callback
support.

    res.jsonp(null)
// => null

res.jsonp({ user: 'tobi' })
// => { "user": "tobi" }

res.jsonp(500, { error: 'message' })
// => { "error": "message" }
    

    By default the JSONP callback name is simply callback,
however you may alter this with the jsonp callback name
setting. The following are some examples of JSONP responses using the same
code:

    // ?callback=foo
res.jsonp({ user: 'tobi' })
// => foo({ "user": "tobi" })

app.set('jsonp callback name', 'cb')

// ?cb=foo
res.jsonp(500, { error: 'message' })
// => foo({ "error": "message" })
    

  

  
    res.type(type)

    Sets the Content-Type to the mime lookup of type,
or when “/” is present the Content-Type is simply set to this
literal value.

    res.type('.html')
res.type('html')
res.type('json')
res.type('application/json')
res.type('png')
    

    p Aliased as res.contentType(type).

  

  
    res.format(object)

    Performs content-negotiation on the request Accept header
field when present. This method uses req.accepted, an array of
acceptable types ordered by their quality values, otherwise the
first callback is invoked. When no match is performed the server
responds with 406 “Not Acceptable”, or invokes the default
callback.

    The Content-Type is set for you when a callback is selected,
however you may alter this within the callback using res.set()
or res.type() etcetera.

    The following example would respond with { "message": "hey" }
when the Accept header field is set to “application/json” or “/json”,
however if “/*” is given then “hey” will be the response.

    res.format({
  'text/plain': function () {
    res.send('hey')
  },

  'text/html': function () {
    res.send('<p>hey</p>')
  },

  'application/json': function () {
    res.send({ message: 'hey' })
  }
})
    

    In addition to canonicalized MIME types you may also
use extnames mapped to these types, providing a slightly
less verbose implementation:

    res.format({
  text: function () {
    res.send('hey')
  },

  html: function () {
    res.send('<p>hey</p>')
  },

  json: function () {
    res.send({ message: 'hey' })
  }
})
    

  

  
    res.attachment([filename])

    Sets the Content-Disposition header field to “attachment”. If
a filename is given then the Content-Type will be
automatically set based on the extname via res.type(),
and the Content-Disposition’s “filename=” parameter will be set.

    res.attachment()
// Content-Disposition: attachment

res.attachment('path/to/logo.png')
// Content-Disposition: attachment; filename="logo.png"
// Content-Type: image/png
    

  

  
    res.sendfile(path, [options], [fn]])

    Transfer the file at the given path.

    Automatically defaults the Content-Type response header field based
on the filename’s extension. The callback fn(err) is
invoked when the transfer is complete or when an error occurs.

    Options:

    
      maxAge in milliseconds defaulting to 0
      root root directory for relative filenames
    

    This method provides fine-grained support for file serving
as illustrated in the following example:

    app.get('/user/:uid/photos/:file', function (req, res) {
  var uid = req.params.uid
  var file = req.params.file

  req.user.mayViewFilesFrom(uid, function (yes) {
    if (yes) {
      res.sendfile('/uploads/' + uid + '/' + file)
    } else {
      res.send(403, 'Sorry! you cant see that.')
    }
  })
})
    

  

  
    res.download(path, [filename], [fn])

    Transfer the file at path as an “attachment”,
typically browsers will prompt the user for download. The
Content-Disposition “filename=” parameter, aka the one
that will appear in the brower dialog is set to path
by default, however you may provide an override filename.

    When an error has ocurred or transfer is complete the optional
callback fn is invoked. This method uses res.sendfile()
to transfer the file.

    res.download('/report-12345.pdf')

res.download('/report-12345.pdf', 'report.pdf')

res.download('/report-12345.pdf', 'report.pdf', function (err) {
  if (err) {
    // handle error, keep in mind the response may be partially-sent
    // so check res.headerSent
  } else {
    // decrement a download credit etc
  }
})
    

  

  
    res.links(links)

    Join the given links to populate the “Link” response header field.

    res.links({
  next: 'http://api.example.com/users?page=2',
  last: 'http://api.example.com/users?page=5'
})
    

    p yields:

    Link: <http://api.example.com/users?page=2> rel="next",
      <http://api.example.com/users?page=5> rel="last"
    

  

  
    res.locals

    Response local variables are scoped to the request, thus only
available to the view(s) rendered during that request / response
cycle, if any. Otherwise this API is identical to app.locals.

    This object is useful for exposing request-level information such as the
request pathname, authenticated user, user settings etcetera.

    app.use(function (req, res, next) {
  res.locals.user = req.user
  res.locals.authenticated = !req.user.anonymous
  next()
})
    

  

  
    res.render(view, [locals], callback)

    Render a view with a callback responding with
the rendered string. When an error occurs next(err)
is invoked internally. When a callback is provided both the possible error
and rendered string are passed, and no automated response is performed.

    res.render('index', function (err, html) {
  // ...
})

res.render('user', { name: 'Tobi' }, function (err, html) {
  // ...
})
    

  

  
    res.req

    This property holds a reference to the request object
that relates to this response object.

  

  Middleware

  
    basicAuth()

    Basic Authentication middleware, populating req.user
with the username.

    Simple username and password:

    app.use(express.basicAuth('username', 'password'))
    

    Callback verification:

    app.use(express.basicAuth(function (user, pass) {
  return user === 'tj' && pass === 'wahoo'
}))
    

    Async callback verification, accepting fn(err, user),
in this case req.user will be the user object passed.

    app.use(express.basicAuth(function (user, pass, fn) {
  User.authenticate({ user: user, pass: pass }, fn)
}))
    

  

  
    bodyParser()

    Request body parsing middleware supporting JSON, urlencoded,
and multipart requests. This middleware is simply a wrapper
for the json(), urlencoded(), and
multipart() middleware.

    app.use(express.bodyParser())

// is equivalent to:
app.use(express.json())
app.use(express.urlencoded())
app.use(express.multipart())
    

    For security sake, it’s better to disable file upload if your application
doesn’t need it. To do this, use only the needed middleware, i.e. don’t use
the bodyParser and multipart() middleware:

    app.use(express.json())
app.use(express.urlencoded())
    

    If your application needs file upload you should set up
a strategy for dealing with those files.

  

  
    compress()

    Compress response data with gzip / deflate. This middleware
should be placed “high” within the stack to ensure all
responses may be compressed.

    app.use(express.logger())
app.use(express.compress())
app.use(express.methodOverride())
app.use(express.bodyParser())
    

  

  
    cookieParser()

    Parses the Cookie header field and populates req.cookies
with an object keyed by the cookie names. Optionally you may enabled
signed cookie support by passing a secret string.

    app.use(express.cookieParser())
app.use(express.cookieParser('some secret'))
    

  

  
    cookieSession()

    Provides cookie-based sessions, and populates req.session.
This middleware takes the following options:

    
      key cookie name defaulting to connect.sess
      secret prevents cookie tampering
      cookie session cookie settings, defaulting to { path: '/', httpOnly: true, maxAge: null }
      proxy trust the reverse proxy when setting secure cookies (via “x-forwarded-proto”)
    

    app.use(express.cookieSession())
    

    To clear a cookie simply assign the session to null before responding:

    req.session = null
    

  

  
    csrf()

    CSRF protection middleware.

    By default this middleware generates a token named “_csrf”
which should be added to requests which mutate
state, within a hidden form field, query-string etc. This
token is validated against req.csrfToken().

    The default value function checks req.body generated
by the bodyParser() middleware, req.query generated
by query(), and the “X-CSRF-Token” header field.

    This middleware requires session support, thus should be added
somewhere below session().

  

  
    directory()

    Directory serving middleware, serves the given path.
This middleware may be paired with static() to serve
files, providing a full-featured file browser.

    app.use(express.directory('public'))
app.use(express.static('public'))
    

    This middleware accepts the following options:

    
      hidden display hidden (dot) files. Defaults to false.
      icons  display icons. Defaults to false.
      filter Apply this filter function to files. Defaults to false.
    

  



              
    
    Edit this page\n\nOn this page
          On this page ►

    express()
     Application
        
            app.set()
            
            app.get()
            
            app.enable()
            
            app.disable()
            
            app.enabled()
            
            app.disabled()
            
            app.configure()
            
            app.use()
            
            application settings
            
            app.engine()
            
            app.param()
            
            application routing
            
            app.all()
            
            app.locals
            
            app.render()
            
            app.routes
            
            app.listen()
            
        
    
     Request
        
            req.params
            
            req.query
            
            req.body
            
            req.files
            
            req.param()
            
            req.route
            
            req.cookies
            
            req.signedCookies
            
            req.get()
            
            req.accepts()
            
            req.accepted
            
            req.is()
            
            req.ip
            
            req.ips
            
            req.path
            
            req.host
            
            req.fresh
            
            req.stale
            
            req.xhr
            
            req.protocol
            
            req.secure
            
            req.subdomains
            
            req.originalUrl
            
            req.acceptedLanguages
            
            req.acceptedCharsets
            
            req.acceptsCharset()
            
            req.acceptsLanguage()
            
            req.res
            
        
    
     Response
        
            res.status()
            
            res.set()
            
            res.get()
            
            res.cookie()
            
            res.clearCookie()
            
            res.redirect()
            
            res.location()
            
            res.charset
            
            res.send()
            
            res.json()
            
            res.jsonp()
            
            res.type()
            
            res.format()
            
            res.attachment()
            
            res.sendfile()
            
            res.download()
            
            res.links()
            
            res.locals
            
            res.render()
            
        
    
    Middleware
        
            basicAuth()
            
            bodyParser()
            
            compress()
            
            cookieParser()
            
            cookieSession()
            
            csrf()
            
            directory()
            
        
    



        
      
      
        

  
    Express 3.x IS END-OF-LIFE AND NO LONGER MAINTAINED

    Known and unknown security and performance issues in 3.x have not been addressed since the last update (1 August, 2015). It is highly recommended to use the latest version of Express.

    If you are unable to upgrade past 3.x, please consider Commercial Support Options.
  

  3.x API

  express()

  Creates an Express application. The express() function is a top-level function exported by the express module.

  var express = require('express')
var app = express()

app.get('/', function (req, res) {
  res.send('hello world')
})

app.listen(3000)
  

  Application

  
    app.set(name, value)

    Assigns setting name to value.

    app.set('title', 'My Site')
app.get('title')
// => "My Site"
    

  

  
    app.get(name)

    Get setting name value.

    app.get('title')
// => undefined

app.set('title', 'My Site')
app.get('title')
// => "My Site"
    

  

  
    app.enable(name)

    Set setting name to true.

    app.enable('trust proxy')
app.get('trust proxy')
// => true
    

  

  
    app.disable(name)

    Set setting name to false.

    app.disable('trust proxy')
app.get('trust proxy')
// => false
    

  

  
    app.enabled(name)

    Check if setting name is enabled.

    app.enabled('trust proxy')
// => false

app.enable('trust proxy')
app.enabled('trust proxy')
// => true
    

  

  
    app.disabled(name)

    Check if setting name is disabled.

    app.disabled('trust proxy')
// => true

app.enable('trust proxy')
app.disabled('trust proxy')
// => false
    

  

  
    app.configure([env], callback)

    Conditionally invoke callback when env matches app.get('env'),
aka process.env.NODE_ENV. This method remains for legacy reasons, and is effectively
an if statement as illustrated in the following snippets. These functions are not
required in order to use app.set() and other configuration methods.

    // all environments
app.configure(function () {
  app.set('title', 'My Application')
})

// development only
app.configure('development', function () {
  app.set('db uri', 'localhost/dev')
})

// production only
app.configure('production', function () {
  app.set('db uri', 'n.n.n.n/prod')
})
    

    Is effectively sugar for:

    // all environments
app.set('title', 'My Application')

// development only
if (app.get('env') === 'development') {
  app.set('db uri', 'localhost/dev')
}

// production only
if (app.get('env') === 'production') {
  app.set('db uri', 'n.n.n.n/prod')
}
    

  

  
    app.use([path], function)

    Use the given middleware function, with optional mount path,
defaulting to “/”.

    var express = require('express')
var app = express()

// simple logger
app.use(function (req, res, next) {
  console.log('%s %s', req.method, req.url)
  next()
})

// respond
app.use(function (req, res, next) {
  res.send('Hello World')
})

app.listen(3000)
    

    The “mount” path is stripped and is not visible
to the middleware function. The main effect of this feature is that
mounted middleware may operate without code changes regardless of its “prefix”
pathname.

    
      A route will match any path that follows its path immediately with either a “/” or a “.”. For example: app.use('/apple', ...) will match /apple, /apple/images, /apple/images/news, /apple.html, /apple.html.txt, and so on.
    

    Here’s a concrete example, take the typical use-case of serving files in ./public
using the express.static() middleware:

    // GET /javascripts/jquery.js
// GET /style.css
// GET /favicon.ico
app.use(express.static(path.join(__dirname, 'public')))
    

    Say for example you wanted to prefix all static files with “/static”, you could
use the “mounting” feature to support this. Mounted middleware functions are not
invoked unless the req.url contains this prefix, at which point
it is stripped when the function is invoked. This affects this function only,
subsequent middleware will see req.url with “/static” included
unless they are mounted as well.

    // GET /static/javascripts/jquery.js
// GET /static/style.css
// GET /static/favicon.ico
app.use('/static', express.static(path.join(__dirname, 'public')))
    

    The order of which middleware are “defined” using app.use() is
very important, they are invoked sequentially, thus this defines middleware
precedence. For example usually express.logger() is the very
first middleware you would use, logging every request:

    app.use(express.logger())
app.use(express.static(path.join(__dirname, 'public')))
app.use(function (req, res) {
  res.send('Hello')
})
    

    Now suppose you wanted to ignore logging requests for static files, but to
continue logging routes and middleware defined after logger(),
you would simply move static() above:

    app.use(express.static(path.join(__dirname, 'public')))
app.use(express.logger())
app.use(function (req, res) {
  res.send('Hello')
})
    

    Another concrete example would be serving files from multiple directories,
giving precedence to “./public” over the others:

    app.use(express.static(path.join(__dirname, 'public')))
app.use(express.static(path.join(__dirname, 'files')))
app.use(express.static(path.join(__dirname, 'uploads')))
    

  

  
    settings

    The following settings are provided to alter how Express will behave:

    
      env Environment mode, defaults to process.env.NODE_ENV or “development”
      trust proxy Enables reverse proxy support, disabled by default
      jsonp callback name Changes the default callback name of ?callback=
      json replacer JSON replacer callback, null by default
      json spaces JSON response spaces for formatting, defaults to 2 in development, 0 in production
      case sensitive routing Enable case sensitivity, disabled by default, treating “/Foo” and “/foo” as the same
      strict routing Enable strict routing, by default “/foo” and “/foo/” are treated the same by the router
      view cache Enables view template compilation caching, enabled in production by default
      view engine The default engine extension to use when omitted
      views The view directory path, defaulting to “process.cwd() + ‘/views’”
    

  

  
    app.engine(ext, callback)

    Register the given template engine callback as ext

    By default will require() the engine based on the
file extension. For example if you try to render
a “foo.jade” file Express will invoke the following internally,
and cache the require() on subsequent calls to increase
performance.

    app.engine('jade', require('jade').__express)
    

    For engines that do not provide .__express out of the box -
or if you wish to “map” a different extension to the template engine
you may use this method. For example mapping the EJS template engine to
“.html” files:

    app.engine('html', require('ejs').renderFile)
    

    In this case EJS provides a .renderFile() method with
the same signature that Express expects: (path, options, callback),
though note that it aliases this method as ejs.__express internally
so if you’re using “.ejs” extensions you dont need to do anything.

    Some template engines do not follow this convention, the
consolidate.js
library was created to map all of node’s popular template
engines to follow this convention, thus allowing them to
work seemlessly within Express.

    var engines = require('consolidate')
app.engine('haml', engines.haml)
app.engine('html', engines.hogan)
    

  

  
    app.param([name], callback)

    Map logic to route parameters. For example when :user
is present in a route path you may map user loading logic to automatically
provide req.user to the route, or perform validations
on the parameter input.

    The following snippet illustrates how the callback
is much like middleware, thus supporting async operations, however
providing the additional value of the parameter, here named as id.
An attempt to load the user is then performed, assigning req.user,
otherwise passing an error to next(err).

    app.param('user', function (req, res, next, id) {
  User.find(id, function (err, user) {
    if (err) {
      next(err)
    } else if (user) {
      req.user = user
      next()
    } else {
      next(new Error('failed to load user'))
    }
  })
})
    

    Alternatively you may pass only a callback, in which
case you have the opportunity to alter the app.param() API.
For example the express-params
defines the following callback which allows you to restrict parameters to a given
regular expression.

    This example is a bit more advanced, checking if the second argument is a regular
expression, returning the callback which acts much like the “user” param example.

    app.param(function (name, fn) {
  if (fn instanceof RegExp) {
    return function (req, res, next, val) {
      var captures
      if ((captures = fn.exec(String(val)))) {
        req.params[name] = captures
        next()
      } else {
        next('route')
      }
    }
  }
})
    

    The method could now be used to effectively validate parameters, or also
parse them to provide capture groups:

    app.param('id', /^\d+$/)

app.get('/user/:id', function (req, res) {
  res.send('user ' + req.params.id)
})

app.param('range', /^(\w+)\.\.(\w+)?$/)

app.get('/range/:range', function (req, res) {
  var range = req.params.range
  res.send('from ' + range[1] + ' to ' + range[2])
})
    

  

  
    app.VERB(path, [callback...], callback)

    The app.VERB() methods provide the routing functionality
in Express, where VERB is one of the HTTP verbs, such
as app.post(). Multiple callbacks may be given, all are treated
equally, and behave just like middleware, with the one exception that
these callbacks may invoke next('route') to bypass the
remaining route callback(s). This mechanism can be used to perform pre-conditions
on a route then pass control to subsequent routes when there is no reason to proceed
with the route matched.

    The following snippet illustrates the most simple route definition possible. Express
translates the path strings to regular expressions, used internally to match incoming requests.
Query strings are not considered when peforming these matches, for example “GET /”
would match the following route, as would “GET /?name=tobi”.

    app.get('/', function (req, res) {
  res.send('hello world')
})
    

    Regular expressions may also be used, and can be useful
if you have very specific restraints, for example the following
would match “GET /commits/71dbb9c” as well as “GET /commits/71dbb9c..4c084f9”.

    app.get(/^\/commits\/(\w+)(?:\.\.(\w+))?$/, function (req, res) {
  var from = req.params[0]
  var to = req.params[1] || 'HEAD'
  res.send('commit range ' + from + '..' + to)
})
    

    Several callbacks may also be passed, useful for re-using middleware
that load resources, perform validations, etc.

    app.get('/user/:id', user.load, function () {
  // ...
})
    

    These callbacks may be passed within arrays as well, these arrays are
simply flattened when passed:

    var middleware = [loadForum, loadThread]

app.get('/forum/:fid/thread/:tid', middleware, function () {
  // ...
})

app.post('/forum/:fid/thread/:tid', middleware, function () {
  // ...
})
    

  

  
    app.all(path, [callback...], callback)

    This method functions just like the app.VERB() methods,
however it matches all HTTP verbs.

    This method is extremely useful for
mapping “global” logic for specific path prefixes or arbitrary matches.
For example if you placed the following route at the top of all other
route definitions, it would require that all routes from that point on
would require authentication, and automatically load a user. Keep in mind
that these callbacks do not have to act as end points, loadUser
can perform a task, then next() to continue matching subsequent
routes.

    app.all('*', requireAuthentication, loadUser)
    

    Or the equivalent:

    app.all('*', requireAuthentication)
app.all('*', loadUser)
    

    Another great example of this is white-listed “global” functionality. Here
the example is much like before, however only restricting paths prefixed with
“/api”:

    app.all('/api/*', requireAuthentication)
    

  

  
    app.locals

    Application local variables are provided to all templates
rendered within the application. This is useful for providing
helper functions to templates, as well as app-level data.

    app.locals.title = 'My App'
app.locals.strftime = require('strftime')
    

    The app.locals object is a JavaScript Function,
which when invoked with an object will merge properties into itself, providing
a simple way to expose existing objects as local variables.

    app.locals({
  title: 'My App',
  phone: '1-250-858-9990',
  email: '[email protected]'
})

console.log(app.locals.title)
// => 'My App'

console.log(app.locals.email)
// => '[email protected]'
    

    A consequence of the app.locals Object being ultimately a Javascript Function Object is that you must not reuse existing (native) named properties for your own variable names, such as name, apply, bind, call, arguments, length, constructor.

    app.locals({ name: 'My App' })

console.log(app.locals.name)
// => return 'app.locals' in place of 'My App' (app.locals is a Function !)
// => if name's variable is used in a template, a ReferenceError will be returned.
    

    The full list of native named properties can be found in many specifications. The JavaScript specification introduced original properties, some of which still recognized by modern engines, and the EcmaScript specification then built on it and normalized the set of properties, adding new ones and removing deprecated ones. Check out properties for Functions and Objects if interested.

    By default Express exposes only a single app-level local variable, settings.

    app.set('title', 'My App')
// use settings.title in a view
    

  

  
    app.render(view, [options], callback)

    Render a view with a callback responding with
the rendered string. This is the app-level variant of res.render(),
and otherwise behaves the same way.

    app.render('email', function (err, html) {
  // ...
})

app.render('email', { name: 'Tobi' }, function (err, html) {
  // ...
})
    

  

  
    app.routes

    The app.routes object houses all of the routes defined mapped
by the associated HTTP verb. This object may be used for introspection capabilities,
for example Express uses this internally not only for routing but to provide default
    OPTIONS
    behaviour unless app.options() is used. Your application
or framework may also remove routes by simply by removing them from this object.

    The output of console.log(app.routes):

    { get:
   [ { path: '/',
       method: 'get',
       callbacks: [Object],
       keys: [],
       regexp: /^\/\/?$/i },
     { path: '/user/:id',
       method: 'get',
       callbacks: [Object],
       keys: [{ name: 'id', optional: false }],
       regexp: /^\/user\/(?:([^\/]+?))\/?$/i } ],
  delete:
   [ { path: '/user/:id',
       method: 'delete',
       callbacks: [Object],
       keys: [Object],
       regexp: /^\/user\/(?:([^\/]+?))\/?$/i } ] }
    

  

  
    app.listen()

    Bind and listen for connections on the given host and port,
this method is identical to node’s http.Server#listen().

    var express = require('express')
var app = express()
app.listen(3000)
    

    The app returned by express() is in fact a JavaScript
Function, designed to be passed to node’s http servers as a callback
to handle requests. This allows you to provide both HTTP and HTTPS versions of
your app with the same codebase easily, as the app does not inherit from these,
it is simply a callback:

    var express = require('express')
var https = require('https')
var http = require('http')
var app = express()

http.createServer(app).listen(80)
https.createServer(options, app).listen(443)
    

    The app.listen() method is simply a convenience method defined as,
if you wish to use HTTPS or provide both, use the technique above.

    app.listen = function () {
  var server = http.createServer(this)
  return server.listen.apply(server, arguments)
}
    

  

  Request

  The req object is an enhanced version of Node’s own request object
and supports all built-in fields and methods.

  
    req.params

    This property is an array containing properties mapped to the named route “parameters”.
For example if you have the route /user/:name, then the “name” property
is available to you as req.params.name. This object defaults to {}.

    // GET /user/tj
console.dir(req.params.name)
// => 'tj'
    

    When a regular expression is used for the route definition, capture groups
are provided in the array using req.params[N], where N
is the nth capture group. This rule is applied to unnamed wild-card matches
with string routes such as /file/*:

    // GET /file/javascripts/jquery.js
console.dir(req.params[0])
// => 'javascripts/jquery.js'
    

  

  
    req.query

    This property is an object containing the parsed query-string,
defaulting to {}.

    // GET /search?q=tobi+ferret
console.dir(req.query.q)
// => 'tobi ferret'

// GET /shoes?order=desc&shoe[color]=blue&shoe[type]=converse
console.dir(req.query.order)
// => 'desc'

console.dir(req.query.shoe.color)
// => 'blue'

console.dir(req.query.shoe.type)
// => 'converse'
    

  

  
    req.body

    This property is an object containing the parsed request body. This feature
is provided by the bodyParser() middleware, though other body
parsing middleware may follow this convention as well. This property
defaults to {} when bodyParser() is used.

    // POST user[name]=tobi&user[email][email protected]
console.log(req.body.user.name)
// => "tobi"

console.log(req.body.user.email)
// => "[email protected]"

// POST { "name": "tobi" }
console.log(req.body.name)
// => "tobi"
    

  

  
    req.files

    This property is an object of the files uploaded. This feature
is provided by the bodyParser() middleware, though other body
parsing middleware may follow this convention as well. This property
defaults to {} when bodyParser() is used.

    For example if a file field was named “image”,
and a file was uploaded, req.files.image would contain
the following File object:

    { size: 74643,
  path: '/tmp/8ef9c52abe857867fd0a4e9a819d1876',
  name: 'edge.png',
  type: 'image/png',
  hash: false,
  lastModifiedDate: Thu Aug 09 2012 20:07:51 GMT-0700 (PDT),
  _writeStream:
   { path: '/tmp/8ef9c52abe857867fd0a4e9a819d1876',
     fd: 13,
     writable: false,
     flags: 'w',
     encoding: 'binary',
     mode: 438,
     bytesWritten: 74643,
     busy: false,
     _queue: [],
     _open: [Function],
     drainable: true },
  length: [Getter],
  filename: [Getter],
  mime: [Getter] }
    

    The bodyParser() middleware utilizes the
node-formidable
module internally, and accepts the same options. An example of this
is the keepExtensions formidable option, defaulting to false
which in this case gives you the filename “/tmp/8ef9c52abe857867fd0a4e9a819d1876” void of
the “.png” extension. To enable this, and others you may pass them to bodyParser():

    app.use(express.bodyParser({ keepExtensions: true, uploadDir: '/my/files' }))
    

  

  
    req.param(name)

    Return the value of param name when present.

    // ?name=tobi
req.param('name')
// => "tobi"

// POST name=tobi
req.param('name')
// => "tobi"

// /user/tobi for /user/:name
req.param('name')
// => "tobi"
    

    Lookup is performed in the following order:

    
      req.params
      req.body
      req.query
    

    Direct access to req.body, req.params,
and req.query should be favoured for clarity - unless
you truly accept input from each object.

  

  
    req.route

    The currently matched Route containing
several properties such as the route’s original path
string, the regexp generated, and so on.

    app.get('/user/:id?', function (req, res) {
  console.dir(req.route)
})
    

    Example output from the previous snippet:

    { path: '/user/:id?',
  method: 'get',
  callbacks: [ [Function] ],
  keys: [ { name: 'id', optional: true } ],
  regexp: /^\/user(?:\/([^\/]+?))?\/?$/i,
  params: [ id: '12' ] }
    

  

  
    req.cookies

    This object requires the cookieParser() middleware for use.
It contains cookies sent by the user-agent. If no cookies are sent, it
defaults to {}.

    // Cookie: name=tj
console.log(req.cookies.name)
// => "tj"
    

  

  
    req.signedCookies

    This object requires the cookieParser(secret) middleware for use.
It contains signed cookies sent by the user-agent, unsigned and ready for use.
Signed cookies reside in a different object to show developer intent; otherwise,
a malicious attack could be placed on req.cookie values (which are easy to spoof).
Note that signing a cookie does not make it “hidden” or encrypted; this simply
prevents tampering (because the secret used to sign is private). If no signed
cookies are sent, it defaults to {}.

    // Cookie: user=tobi.CP7AWaXDfAKIRfH49dQzKJx7sKzzSoPq7/AcBBRVwlI3
console.dir(req.signedCookies.user)
// => 'tobi'
    

  

  
    req.get(field)

    Get the case-insensitive request header field. The “Referrer” and “Referer” fields are interchangeable.

    req.get('Content-Type')
// => "text/plain"

req.get('content-type')
// => "text/plain"

req.get('Something')
// => undefined
    

    p Aliased as req.header(field).

  

  
    req.accepts(types)

    Check if the given types are acceptable, returning
the best match when true, otherwise undefined - in which
case you should respond with 406 “Not Acceptable”.

    The type value may be a single mime type string
such as “application/json”, the extension name
such as “json”, a comma-delimited list or an array. When a list
or array is given the best match, if any is returned.

    // Accept: text/html
req.accepts('html')
// => "html"

// Accept: text/*, application/json
req.accepts('html')
// => "html"
req.accepts('text/html')
// => "text/html"
req.accepts('json, text')
// => "json"
req.accepts('application/json')
// => "application/json"

// Accept: text/*, application/json
req.accepts('image/png')
req.accepts('png')
// => undefined

// Accept: text/*;q=.5, application/json
req.accepts(['html', 'json'])
req.accepts('html, json')
// => "json"
    

  

  
    req.accepted

    Return an array of Accepted media types ordered from highest quality to lowest.

    [ { value: 'application/json',
    quality: 1,
    type: 'application',
    subtype: 'json' },
   { value: 'text/html',
     quality: 0.5,
     type: 'text',
     subtype: 'html' } ]
    

  

  
    req.is(type)

    Check if the incoming request contains the “Content-Type”
header field, and it matches the give mime type.

    // With Content-Type: text/html; charset=utf-8
req.is('html')
req.is('text/html')
req.is('text/*')
// => true

// When Content-Type is application/json
req.is('json')
req.is('application/json')
req.is('application/*')
// => true

req.is('html')
// => false
    

  

  
    req.ip

    Return the remote address, or when “trust proxy”
is enabled - the upstream address.

    console.dir(req.ip)
// => '127.0.0.1'
    

  

  
    req.ips

    When “trust proxy” is true, parse
the “X-Forwarded-For” ip address list
and return an array, otherwise an empty
array is returned.

    For example if the value were “client, proxy1, proxy2”
you would receive the array ["client", "proxy1", "proxy2"]
where “proxy2” is the furthest down-stream.

  

  
    req.path

    Returns the request URL pathname.

    // example.com/users?sort=desc
console.dir(req.path)
// => '/users'
    

  

  
    req.host

    Returns the hostname from the “Host” header field (void of portno).

    // Host: "example.com:3000"
console.dir(req.host)
// => 'example.com'
    

  

  
    req.fresh

    Check if the request is fresh - aka Last-Modified and/or the ETag still match,
indicating that the resource is “fresh”.

    console.dir(req.fresh)
// => true
    

  

  
    req.stale

    Check if the request is stale - aka Last-Modified and/or the ETag do not match,
indicating that the resource is “stale”.

    console.dir(req.stale)
// => true
    

  

  
    req.xhr

    Check if the request was issued with the “X-Requested-With”
header field set to “XMLHttpRequest” (jQuery etc).

    console.dir(req.xhr)
// => true
    

  

  
    req.protocol

    Return the protocol string “http” or “https”
when requested with TLS. When the “trust proxy”
setting is enabled the “X-Forwarded-Proto” header
field will be trusted. If you’re running behind
a reverse proxy that supplies https for you this
may be enabled.

    console.dir(req.protocol)
// => 'http'
    

  

  
    req.secure

    Check if a TLS connection is established. This is a short-hand for:

    console.dir(req.protocol === 'https')
// => true
    

  

  
    req.subdomains

    Return subdomains as an array.

    // Host: "tobi.ferrets.example.com"
console.dir(req.subdomains)
// => ['ferrets', 'tobi']
    

  

  
    req.originalUrl

    This property is much like req.url, however it retains
the original request url, allowing you to rewrite req.url
freely for internal routing purposes. For example the “mounting” feature
of app.use() will rewrite req.url to
strip the mount point.

    // GET /search?q=something
console.log(req.originalUrl)
// => "/search?q=something"
    

  

  
    req.acceptedLanguages

    Return an array of Accepted languages ordered from highest quality to lowest.

    Accept-Language: en;q=.5, en-us
// => ['en-us', 'en']
    

  

  
    req.acceptedCharsets

    Return an array of Accepted charsets ordered from highest quality to lowest.

    Accept-Charset: iso-8859-5;q=.2, unicode-1-1;q=0.8
// => ['unicode-1-1', 'iso-8859-5']
    

  

  
    req.acceptsCharset(charset)

    Check if the given charset are acceptable.

  

  
    req.acceptsLanguage(lang)

    Check if the given lang are acceptable.

  

  
    req.res

    This property holds a reference to the response object
that relates to this request object.

  

  Response

  The res object is an enhanced version of Node’s own response object
and supports all built-in fields and methods.

  
    res.status(code)

    Chainable alias of node’s res.statusCode=.

    res.status(404).sendfile('path/to/404.png')
    

  

  
    res.set(field, [value])

    Set header field to value, or pass an object to set multiple fields at once.

    res.set('Content-Type', 'text/plain')

res.set({
  'Content-Type': 'text/plain',
  'Content-Length': '123',
  ETag: '12345'
})
    

    Aliased as res.header(field, [value]).

  

  
    res.get(field)

    Get the case-insensitive response header field.

    res.get('Content-Type')
// => "text/plain"
    

  

  
    res.cookie(name, value, [options])

    Set cookie name to value, which may be a string or object converted to JSON. The path
option defaults to “/”.

    res.cookie('name', 'tobi', { domain: '.example.com', path: '/admin', secure: true })
res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true })
    

    The maxAge option is a convenience option for setting “expires”
relative to the current time in milliseconds. The following is equivalent to
the previous example.

    res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })
    

    An object may be passed which is then serialized as JSON, which is
automatically parsed by the bodyParser() middleware.

    res.cookie('cart', { items: [1, 2, 3] })
res.cookie('cart', { items: [1, 2, 3] }, { maxAge: 900000 })
    

    Signed cookies are also supported through this method. Simply
pass the signed option. When given res.cookie()
will use the secret passed to express.cookieParser(secret)
to sign the value.

    res.cookie('name', 'tobi', { signed: true })
    

    Later you may access this value through the req.signedCookie
object.

  

  
    res.clearCookie(name, [options])

    Clear cookie name. The path option defaults to “/”.

    res.cookie('name', 'tobi', { path: '/admin' })
res.clearCookie('name', { path: '/admin' })
    

  

  
    res.redirect([status], url)

    Redirect to the given url with optional status code
defaulting to 302 “Found”.

    res.redirect('/foo/bar')
res.redirect('http://example.com')
res.redirect(301, 'http://example.com')
res.redirect('../login')
    

    Express supports a few forms of redirection, first being
a fully qualified URI for redirecting to a different site:

    res.redirect('http://google.com')
    

    The second form is the pathname-relative redirect, for example
if you were on http://example.com/admin/post/new, the
following redirect to /admin would land you at http://example.com/admin:

    res.redirect('/admin')
    

    This next redirect is relative to the mount point of the application. For example
if you have a blog application mounted at /blog, ideally it has no knowledge of
where it was mounted, so where a redirect of /admin/post/new would simply give you
http://example.com/admin/post/new, the following mount-relative redirect would give
you http://example.com/blog/admin/post/new:

    res.redirect('admin/post/new')
    

    Pathname relative redirects are also possible. If you were
on http://example.com/admin/post/new, the following redirect
would land you at http//example.com/admin/post:

    res.redirect('..')
    

    The final special-case is a back redirect, redirecting back to
the Referer (or Referrer), defaulting to / when missing.

    res.redirect('back')
    

  

  
    res.location

    Set the location header.

    res.location('/foo/bar')
res.location('foo/bar')
res.location('http://example.com')
res.location('../login')
res.location('back')
    

    You can use the same kind of urls as in res.redirect().

    For example, if your application is mounted at /blog,
the following would set the location header to
/blog/admin:

    res.location('admin')
    

  

  
    res.charset

    Assign the charset. Defaults to “utf-8”.

    res.charset = 'value'
res.send('<p>some html</p>')
// => Content-Type: text/html; charset=value
    

  

  
    res.send([body|status], [body])

    Send a response.

    res.send(Buffer.from('whoop'))
res.send({ some: 'json' })
res.send('<p>some html</p>')
res.send(404, 'Sorry, we cannot find that!')
res.send(500, { error: 'something blew up' })
res.send(200)
    

    This method performs a myriad of
useful tasks for simple non-streaming responses such
as automatically assigning the Content-Length unless
previously defined and providing automatic HEAD and
HTTP cache freshness support.

    When a Buffer is given
the Content-Type is set to “application/octet-stream”
unless previously defined as shown below:

    res.set('Content-Type', 'text/html')
res.send(Buffer.from('<p>some html</p>'))
    

    When a String is given the
Content-Type is set defaulted to “text/html”:

    res.send('<p>some html</p>')
    

    When an Array or Object is
given Express will respond with the JSON representation:

    res.send({ user: 'tobi' })
res.send([1, 2, 3])
    

    Finally when a Number is given without
any of the previously mentioned bodies, then a response
body string is assigned for you. For example 200 will
respond will the text “OK”, and 404 “Not Found” and so on.

    res.send(200)
res.send(404)
res.send(500)
    

  

  
    res.json([status|body], [body])

    Send a JSON response. This method is identical
to res.send() when an object or
array is passed, however it may be used for
explicit JSON conversion of non-objects (null, undefined, etc),
though these are technically not valid JSON.

    res.json(null)
res.json({ user: 'tobi' })
res.json(500, { error: 'message' })
    

  

  
    res.jsonp([status|body], [body])

    Send a JSON response with JSONP support. This method is identical
to res.json() however opts-in to JSONP callback
support.

    res.jsonp(null)
// => null

res.jsonp({ user: 'tobi' })
// => { "user": "tobi" }

res.jsonp(500, { error: 'message' })
// => { "error": "message" }
    

    By default the JSONP callback name is simply callback,
however you may alter this with the jsonp callback name
setting. The following are some examples of JSONP responses using the same
code:

    // ?callback=foo
res.jsonp({ user: 'tobi' })
// => foo({ "user": "tobi" })

app.set('jsonp callback name', 'cb')

// ?cb=foo
res.jsonp(500, { error: 'message' })
// => foo({ "error": "message" })
    

  

  
    res.type(type)

    Sets the Content-Type to the mime lookup of type,
or when “/” is present the Content-Type is simply set to this
literal value.

    res.type('.html')
res.type('html')
res.type('json')
res.type('application/json')
res.type('png')
    

    p Aliased as res.contentType(type).

  

  
    res.format(object)

    Performs content-negotiation on the request Accept header
field when present. This method uses req.accepted, an array of
acceptable types ordered by their quality values, otherwise the
first callback is invoked. When no match is performed the server
responds with 406 “Not Acceptable”, or invokes the default
callback.

    The Content-Type is set for you when a callback is selected,
however you may alter this within the callback using res.set()
or res.type() etcetera.

    The following example would respond with { "message": "hey" }
when the Accept header field is set to “application/json” or “/json”,
however if “/*” is given then “hey” will be the response.

    res.format({
  'text/plain': function () {
    res.send('hey')
  },

  'text/html': function () {
    res.send('<p>hey</p>')
  },

  'application/json': function () {
    res.send({ message: 'hey' })
  }
})
    

    In addition to canonicalized MIME types you may also
use extnames mapped to these types, providing a slightly
less verbose implementation:

    res.format({
  text: function () {
    res.send('hey')
  },

  html: function () {
    res.send('<p>hey</p>')
  },

  json: function () {
    res.send({ message: 'hey' })
  }
})
    

  

  
    res.attachment([filename])

    Sets the Content-Disposition header field to “attachment”. If
a filename is given then the Content-Type will be
automatically set based on the extname via res.type(),
and the Content-Disposition’s “filename=” parameter will be set.

    res.attachment()
// Content-Disposition: attachment

res.attachment('path/to/logo.png')
// Content-Disposition: attachment; filename="logo.png"
// Content-Type: image/png
    

  

  
    res.sendfile(path, [options], [fn]])

    Transfer the file at the given path.

    Automatically defaults the Content-Type response header field based
on the filename’s extension. The callback fn(err) is
invoked when the transfer is complete or when an error occurs.

    Options:

    
      maxAge in milliseconds defaulting to 0
      root root directory for relative filenames
    

    This method provides fine-grained support for file serving
as illustrated in the following example:

    app.get('/user/:uid/photos/:file', function (req, res) {
  var uid = req.params.uid
  var file = req.params.file

  req.user.mayViewFilesFrom(uid, function (yes) {
    if (yes) {
      res.sendfile('/uploads/' + uid + '/' + file)
    } else {
      res.send(403, 'Sorry! you cant see that.')
    }
  })
})
    

  

  
    res.download(path, [filename], [fn])

    Transfer the file at path as an “attachment”,
typically browsers will prompt the user for download. The
Content-Disposition “filename=” parameter, aka the one
that will appear in the brower dialog is set to path
by default, however you may provide an override filename.

    When an error has ocurred or transfer is complete the optional
callback fn is invoked. This method uses res.sendfile()
to transfer the file.

    res.download('/report-12345.pdf')

res.download('/report-12345.pdf', 'report.pdf')

res.download('/report-12345.pdf', 'report.pdf', function (err) {
  if (err) {
    // handle error, keep in mind the response may be partially-sent
    // so check res.headerSent
  } else {
    // decrement a download credit etc
  }
})
    

  

  
    res.links(links)

    Join the given links to populate the “Link” response header field.

    res.links({
  next: 'http://api.example.com/users?page=2',
  last: 'http://api.example.com/users?page=5'
})
    

    p yields:

    Link: <http://api.example.com/users?page=2> rel="next",
      <http://api.example.com/users?page=5> rel="last"
    

  

  
    res.locals

    Response local variables are scoped to the request, thus only
available to the view(s) rendered during that request / response
cycle, if any. Otherwise this API is identical to app.locals.

    This object is useful for exposing request-level information such as the
request pathname, authenticated user, user settings etcetera.

    app.use(function (req, res, next) {
  res.locals.user = req.user
  res.locals.authenticated = !req.user.anonymous
  next()
})
    

  

  
    res.render(view, [locals], callback)

    Render a view with a callback responding with
the rendered string. When an error occurs next(err)
is invoked internally. When a callback is provided both the possible error
and rendered string are passed, and no automated response is performed.

    res.render('index', function (err, html) {
  // ...
})

res.render('user', { name: 'Tobi' }, function (err, html) {
  // ...
})
    

  

  
    res.req

    This property holds a reference to the request object
that relates to this response object.

  

  Middleware

  
    basicAuth()

    Basic Authentication middleware, populating req.user
with the username.

    Simple username and password:

    app.use(express.basicAuth('username', 'password'))
    

    Callback verification:

    app.use(express.basicAuth(function (user, pass) {
  return user === 'tj' && pass === 'wahoo'
}))
    

    Async callback verification, accepting fn(err, user),
in this case req.user will be the user object passed.

    app.use(express.basicAuth(function (user, pass, fn) {
  User.authenticate({ user: user, pass: pass }, fn)
}))
    

  

  
    bodyParser()

    Request body parsing middleware supporting JSON, urlencoded,
and multipart requests. This middleware is simply a wrapper
for the json(), urlencoded(), and
multipart() middleware.

    app.use(express.bodyParser())

// is equivalent to:
app.use(express.json())
app.use(express.urlencoded())
app.use(express.multipart())
    

    For security sake, it’s better to disable file upload if your application
doesn’t need it. To do this, use only the needed middleware, i.e. don’t use
the bodyParser and multipart() middleware:

    app.use(express.json())
app.use(express.urlencoded())
    

    If your application needs file upload you should set up
a strategy for dealing with those files.

  

  
    compress()

    Compress response data with gzip / deflate. This middleware
should be placed “high” within the stack to ensure all
responses may be compressed.

    app.use(express.logger())
app.use(express.compress())
app.use(express.methodOverride())
app.use(express.bodyParser())
    

  

  
    cookieParser()

    Parses the Cookie header field and populates req.cookies
with an object keyed by the cookie names. Optionally you may enabled
signed cookie support by passing a secret string.

    app.use(express.cookieParser())
app.use(express.cookieParser('some secret'))
    

  

  
    cookieSession()

    Provides cookie-based sessions, and populates req.session.
This middleware takes the following options:

    
      key cookie name defaulting to connect.sess
      secret prevents cookie tampering
      cookie session cookie settings, defaulting to { path: '/', httpOnly: true, maxAge: null }
      proxy trust the reverse proxy when setting secure cookies (via “x-forwarded-proto”)
    

    app.use(express.cookieSession())
    

    To clear a cookie simply assign the session to null before responding:

    req.session = null
    

  

  
    csrf()

    CSRF protection middleware.

    By default this middleware generates a token named “_csrf”
which should be added to requests which mutate
state, within a hidden form field, query-string etc. This
token is validated against req.csrfToken().

    The default value function checks req.body generated
by the bodyParser() middleware, req.query generated
by query(), and the “X-CSRF-Token” header field.

    This middleware requires session support, thus should be added
somewhere below session().

  

  
    directory()

    Directory serving middleware, serves the given path.
This middleware may be paired with static() to serve
files, providing a full-featured file browser.

    app.use(express.directory('public'))
app.use(express.static('public'))
    

    This middleware accepts the following options:

    
      hidden display hidden (dot) files. Defaults to false.
      icons  display icons. Defaults to false.
      filter Apply this filter function to files. Defaults to false.
    

  



              
    
    Edit this page\n\n\n\nClick here if you are not redirected.\n\n\nDeveloping template engines for Express

Use the app.engine(ext, callback) method to create your own template engine. ext refers to the file extension, and callback is the template engine function, which accepts the following items as parameters: the location of the file, the options object, and the callback function.

The following code is an example of implementing a very simple template engine for rendering .ntl files.

const fs = require('fs') // this engine requires the fs module
app.engine('ntl', (filePath, options, callback) => { // define the template engine
  fs.readFile(filePath, (err, content) => {
    if (err) return callback(err)
    // this is an extremely simple template engine
    const rendered = content.toString()
      .replace('#title#', `<title>${options.title}</title>`)
      .replace('#message#', `<h1>${options.message}</h1>`)
    return callback(null, rendered)
  })
})
app.set('views', './views') // specify the views directory
app.set('view engine', 'ntl') // register the template engine


Your app will now be able to render .ntl files. Create a file named index.ntl in the views directory with the following content.

#title#
#message#

Then, create the following route in your app.

app.get('/', (req, res) => {
  res.render('index', { title: 'Hey', message: 'Hello there!' })
})

When you make a request to the home page, index.ntl will be rendered as HTML.

              
    
    Edit this page\n\nDeveloping template engines for Express

Use the app.engine(ext, callback) method to create your own template engine. ext refers to the file extension, and callback is the template engine function, which accepts the following items as parameters: the location of the file, the options object, and the callback function.

The following code is an example of implementing a very simple template engine for rendering .ntl files.

const fs = require('fs') // this engine requires the fs module
app.engine('ntl', (filePath, options, callback) => { // define the template engine
  fs.readFile(filePath, (err, content) => {
    if (err) return callback(err)
    // this is an extremely simple template engine
    const rendered = content.toString()
      .replace('#title#', `<title>${options.title}</title>`)
      .replace('#message#', `<h1>${options.message}</h1>`)
    return callback(null, rendered)
  })
})
app.set('views', './views') // specify the views directory
app.set('view engine', 'ntl') // register the template engine


Your app will now be able to render .ntl files. Create a file named index.ntl in the views directory with the following content.

#title#
#message#

Then, create the following route in your app.

app.get('/', (req, res) => {
  res.render('index', { title: 'Hey', message: 'Hello there!' })
})

When you make a request to the home page, index.ntl will be rendered as HTML.

              
    
    Edit this page\n\n\n\nSecurity updates


  Node.js vulnerabilities directly affect Express. Therefore, keep a watch on Node.js vulnerabilities and make sure you are using the latest stable version of Node.js.


The list below enumerates the Express vulnerabilities that were fixed in the specified version update.


   Note

  If you believe you have discovered a security vulnerability in Express, please see
Security Policies and Procedures.



4.x

  4.21.2
    
      The dependency path-to-regexp has been updated to address a vulnerability.
    
  
  4.21.1
    
      The dependency cookie has been updated to address a vulnerability, This may affect your application if you use res.cookie.
    
  
  4.20.0
    
      Fixed XSS vulnerability in res.redirect (advisory, CVE-2024-43796).
      The dependency serve-static has been updated to address a vulnerability.
      The dependency send has been updated to address a vulnerability.
      The dependency path-to-regexp has been updated to address a vulnerability.
      The dependency body-parser has been updated to addres a vulnerability, This may affect your application if you had url enconding activated.
    
  
  4.19.0, 4.19.1
    
      Fixed open redirect vulnerability in res.location and res.redirect (advisory, CVE-2024-29041).
    
  
  4.17.3
    
      The dependency qs has been updated to address a vulnerability. This may affect your application if the following APIs are used: req.query, req.body, req.param.
    
  
  4.16.0
    
      The dependency forwarded has been updated to address a vulnerability. This may affect your application if the following APIs are used: req.host, req.hostname, req.ip, req.ips, req.protocol.
      The dependency mime has been updated to address a vulnerability, but this issue does not impact Express.
      The dependency send has been updated to provide a protection against a Node.js 8.5.0 vulnerability. This only impacts running Express on the specific Node.js version 8.5.0.
    
  
  4.15.5
    
      The dependency debug has been updated to address a vulnerability, but this issue does not impact Express.
      The dependency fresh has been updated to address a vulnerability. This will affect your application if the following APIs are used: express.static, req.fresh, res.json, res.jsonp, res.send, res.sendfile res.sendFile, res.sendStatus.
    
  
  4.15.3
    
      The dependency ms has been updated to address a vulnerability. This may affect your application if untrusted string input is passed to the maxAge option in the following APIs: express.static, res.sendfile, and res.sendFile.
    
  
  4.15.2
    
      The dependency qs has been updated to address a vulnerability, but this issue does not impact Express. Updating to 4.15.2 is a good practice, but not required to address the vulnerability.
    
  
  4.11.1
    
      Fixed root path disclosure vulnerability in express.static, res.sendfile, and res.sendFile
    
  
  4.10.7
    
      Fixed open redirect vulnerability in express.static (advisory, CVE-2015-1164).
    
  
  4.8.8
    
      Fixed directory traversal vulnerabilities in express.static (advisory , CVE-2014-6394).
    
  
  4.8.4
    
      Node.js 0.10 can leak fds in certain situations that affect express.static and res.sendfile. Malicious requests could cause fds to leak and eventually lead to EMFILE errors and server unresponsiveness.
    
  
  4.8.0
    
      Sparse arrays that have extremely high indexes in the query string could cause the process to run out of memory and crash the server.
      Extremely nested query string objects could cause the process to block and make the server unresponsive temporarily.
    
  


3.x


  Express 3.x IS END-OF-LIFE AND NO LONGER MAINTAINED

  Known and unknown security and performance issues in 3.x have not been addressed since the last update (1 August, 2015). It is highly recommended to use the latest version of Express.

  If you are unable to upgrade past 3.x, please consider Commercial Support Options.



  3.19.1
    
      Fixed root path disclosure vulnerability in express.static, res.sendfile, and res.sendFile
    
  
  3.19.0
    
      Fixed open redirect vulnerability in express.static (advisory, CVE-2015-1164).
    
  
  3.16.10
    
      Fixed directory traversal vulnerabilities in express.static.
    
  
  3.16.6
    
      Node.js 0.10 can leak fds in certain situations that affect express.static and res.sendfile. Malicious requests could cause fds to leak and eventually lead to EMFILE errors and server unresponsiveness.
    
  
  3.16.0
    
      Sparse arrays that have extremely high indexes in query string could cause the process to run out of memory and crash the server.
      Extremely nested query string objects could cause the process to block and make the server unresponsive temporarily.
    
  
  3.3.0
    
      The 404 response of an unsupported method override attempt was susceptible to cross-site scripting attacks.
    
  


              
    
    Edit this page\n\nSecurity updates


  Node.js vulnerabilities directly affect Express. Therefore, keep a watch on Node.js vulnerabilities and make sure you are using the latest stable version of Node.js.


The list below enumerates the Express vulnerabilities that were fixed in the specified version update.


   Note

  If you believe you have discovered a security vulnerability in Express, please see
Security Policies and Procedures.



4.x

  4.21.2
    
      The dependency path-to-regexp has been updated to address a vulnerability.
    
  
  4.21.1
    
      The dependency cookie has been updated to address a vulnerability, This may affect your application if you use res.cookie.
    
  
  4.20.0
    
      Fixed XSS vulnerability in res.redirect (advisory, CVE-2024-43796).
      The dependency serve-static has been updated to address a vulnerability.
      The dependency send has been updated to address a vulnerability.
      The dependency path-to-regexp has been updated to address a vulnerability.
      The dependency body-parser has been updated to addres a vulnerability, This may affect your application if you had url enconding activated.
    
  
  4.19.0, 4.19.1
    
      Fixed open redirect vulnerability in res.location and res.redirect (advisory, CVE-2024-29041).
    
  
  4.17.3
    
      The dependency qs has been updated to address a vulnerability. This may affect your application if the following APIs are used: req.query, req.body, req.param.
    
  
  4.16.0
    
      The dependency forwarded has been updated to address a vulnerability. This may affect your application if the following APIs are used: req.host, req.hostname, req.ip, req.ips, req.protocol.
      The dependency mime has been updated to address a vulnerability, but this issue does not impact Express.
      The dependency send has been updated to provide a protection against a Node.js 8.5.0 vulnerability. This only impacts running Express on the specific Node.js version 8.5.0.
    
  
  4.15.5
    
      The dependency debug has been updated to address a vulnerability, but this issue does not impact Express.
      The dependency fresh has been updated to address a vulnerability. This will affect your application if the following APIs are used: express.static, req.fresh, res.json, res.jsonp, res.send, res.sendfile res.sendFile, res.sendStatus.
    
  
  4.15.3
    
      The dependency ms has been updated to address a vulnerability. This may affect your application if untrusted string input is passed to the maxAge option in the following APIs: express.static, res.sendfile, and res.sendFile.
    
  
  4.15.2
    
      The dependency qs has been updated to address a vulnerability, but this issue does not impact Express. Updating to 4.15.2 is a good practice, but not required to address the vulnerability.
    
  
  4.11.1
    
      Fixed root path disclosure vulnerability in express.static, res.sendfile, and res.sendFile
    
  
  4.10.7
    
      Fixed open redirect vulnerability in express.static (advisory, CVE-2015-1164).
    
  
  4.8.8
    
      Fixed directory traversal vulnerabilities in express.static (advisory , CVE-2014-6394).
    
  
  4.8.4
    
      Node.js 0.10 can leak fds in certain situations that affect express.static and res.sendfile. Malicious requests could cause fds to leak and eventually lead to EMFILE errors and server unresponsiveness.
    
  
  4.8.0
    
      Sparse arrays that have extremely high indexes in the query string could cause the process to run out of memory and crash the server.
      Extremely nested query string objects could cause the process to block and make the server unresponsive temporarily.
    
  


3.x


  Express 3.x IS END-OF-LIFE AND NO LONGER MAINTAINED

  Known and unknown security and performance issues in 3.x have not been addressed since the last update (1 August, 2015). It is highly recommended to use the latest version of Express.

  If you are unable to upgrade past 3.x, please consider Commercial Support Options.



  3.19.1
    
      Fixed root path disclosure vulnerability in express.static, res.sendfile, and res.sendFile
    
  
  3.19.0
    
      Fixed open redirect vulnerability in express.static (advisory, CVE-2015-1164).
    
  
  3.16.10
    
      Fixed directory traversal vulnerabilities in express.static.
    
  
  3.16.6
    
      Node.js 0.10 can leak fds in certain situations that affect express.static and res.sendfile. Malicious requests could cause fds to leak and eventually lead to EMFILE errors and server unresponsiveness.
    
  
  3.16.0
    
      Sparse arrays that have extremely high indexes in query string could cause the process to run out of memory and crash the server.
      Extremely nested query string objects could cause the process to block and make the server unresponsive temporarily.
    
  
  3.3.0
    
      The 404 response of an unsupported method override attempt was susceptible to cross-site scripting attacks.
    
  


              
    
    Edit this page\n\n\n\nProduction Best Practices: Security

Overview

The term “production” refers to the stage in the software lifecycle when an application or API is generally available to its end-users or consumers. In contrast, in the “development” stage, you’re still actively writing and testing code, and the application is not open to external access. The corresponding system environments are known as production and development environments, respectively.

Development and production environments are usually set up differently and have vastly different requirements. What’s fine in development may not be acceptable in production. For example, in a development environment you may want verbose logging of errors for debugging, while the same behavior can become a security concern in a production environment. And in development, you don’t need to worry about scalability, reliability, and performance, while those concerns become critical in production.


   Note

  If you believe you have discovered a security vulnerability in Express, please see
Security Policies and Procedures.



Security best practices for Express applications in production include:


  Production Best Practices: Security
    
      Overview
      Don’t use deprecated or vulnerable versions of Express
      Use TLS
      Do not trust user input
        
          Prevent open redirects
        
      
      Use Helmet
      Reduce fingerprinting
      Use cookies securely
        
          Don’t use the default session cookie name
          Set cookie security options
        
      
      Prevent brute-force attacks against authorization
      Ensure your dependencies are secure
        
          Avoid other known vulnerabilities
        
      
      Additional considerations
    
  


Don’t use deprecated or vulnerable versions of Express

Express 2.x and 3.x are no longer maintained. Security and performance issues in these versions won’t be fixed. Do not use them! If you haven’t moved to version 4, follow the migration guide or consider Commercial Support Options.

Also ensure you are not using any of the vulnerable Express versions listed on the Security updates page. If you are, update to one of the stable releases, preferably the latest.

Use TLS

If your app deals with or transmits sensitive data, use Transport Layer Security (TLS) to secure the connection and the data. This technology encrypts data before it is sent from the client to the server, thus preventing some common (and easy) hacks. Although Ajax and POST requests might not be visibly obvious and seem “hidden” in browsers, their network traffic is vulnerable to packet sniffing and man-in-the-middle attacks.

You may be familiar with Secure Socket Layer (SSL) encryption. TLS is simply the next progression of SSL. In other words, if you were using SSL before, consider upgrading to TLS. In general, we recommend Nginx to handle TLS. For a good reference to configure TLS on Nginx (and other servers), see Recommended Server Configurations (Mozilla Wiki).

Also, a handy tool to get a free TLS certificate is Let’s Encrypt, a free, automated, and open certificate authority (CA) provided by the Internet Security Research Group (ISRG).

Do not trust user input

For web applications, one of the most critical security requirements is proper user input validation and handling. This comes in many forms and we will not cover all of them here.
Ultimately, the responsibility for validating and correctly handling the types of user input your application accepts is yours.

Prevent open redirects

An example of potentially dangerous user input is an open redirect, where an application accepts a URL as user input (often in the URL query, for example ?url=https://example.com) and uses res.redirect to set the location header and
return a 3xx status.

An application must validate that it supports redirecting to the incoming URL to avoid sending users to malicious links such as phishing websites, among other risks.

Here is an example of checking URLs before using res.redirect or res.location:

app.use((req, res) => {
  try {
    if (new Url(req.query.url).host !== 'example.com') {
      return res.status(400).end(`Unsupported redirect to host: ${req.query.url}`)
    }
  } catch (e) {
    return res.status(400).end(`Invalid url: ${req.query.url}`)
  }
  res.redirect(req.query.url)
})


Use Helmet

Helmet can help protect your app from some well-known web vulnerabilities by setting HTTP headers appropriately.

Helmet is a middleware function that sets security-related HTTP response headers. Helmet sets the following headers by default:


  Content-Security-Policy: A powerful allow-list of what can happen on your page which mitigates many attacks
  Cross-Origin-Opener-Policy: Helps process-isolate your page
  Cross-Origin-Resource-Policy: Blocks others from loading your resources cross-origin
  Origin-Agent-Cluster: Changes process isolation to be origin-based
  Referrer-Policy: Controls the Referer header
  Strict-Transport-Security: Tells browsers to prefer HTTPS
  X-Content-Type-Options: Avoids MIME sniffing
  X-DNS-Prefetch-Control: Controls DNS prefetching
  X-Download-Options: Forces downloads to be saved (Internet Explorer only)
  X-Frame-Options: Legacy header that mitigates Clickjacking attacks
  X-Permitted-Cross-Domain-Policies: Controls cross-domain behavior for Adobe products, like Acrobat
  X-Powered-By: Info about the web server. Removed because it could be used in simple attacks
  X-XSS-Protection: Legacy header that tries to mitigate XSS attacks, but makes things worse, so Helmet disables it


Each header can be configured or disabled. To read more about it please go to its documentation website.

Install Helmet like any other module:

$ npm install helmet


Then to use it in your code:

// ...

const helmet = require('helmet')
app.use(helmet())

// ...


Reduce fingerprinting

It can help to provide an extra layer of security to reduce the ability of attackers to determine
the software that a server uses, known as “fingerprinting.” Though not a security issue itself, 
reducing the ability to fingerprint an application improves its overall security posture. 
Server software can be fingerprinted by quirks in how it responds to specific requests, for example in 
the HTTP response headers.

By default, Express sends the X-Powered-By response header that you can 
disable using the app.disable() method:

app.disable('x-powered-by')



   Note

  Disabling the X-Powered-By header does not prevent
a sophisticated attacker from determining that an app is running Express. It may
discourage a casual exploit, but there are other ways to determine an app is running
Express.



Express also sends its own formatted “404 Not Found” messages and formatter error
response messages. These can be changed by
adding your own not found handler
and
writing your own error handler:

// last app.use calls right before app.listen():

// custom 404
app.use((req, res, next) => {
  res.status(404).send("Sorry can't find that!")
})

// custom error handler
app.use((err, req, res, next) => {
  console.error(err.stack)
  res.status(500).send('Something broke!')
})


Use cookies securely

To ensure cookies don’t open your app to exploits, don’t use the default session cookie name and set cookie security options appropriately.

There are two main middleware cookie session modules:


  express-session that replaces express.session middleware built-in to Express 3.x.
  cookie-session that replaces express.cookieSession middleware built-in to Express 3.x.


The main difference between these two modules is how they save cookie session data. The express-session middleware stores session data on the server; it only saves the session ID in the cookie itself, not session data. By default, it uses in-memory storage and is not designed for a production environment. In production, you’ll need to set up a scalable session-store; see the list of compatible session stores.

In contrast, cookie-session middleware implements cookie-backed storage: it serializes the entire session to the cookie, rather than just a session key. Only use it when session data is relatively small and easily encoded as primitive values (rather than objects). Although browsers are supposed to support at least 4096 bytes per cookie, to ensure you don’t exceed the limit, don’t exceed a size of 4093 bytes per domain. Also, be aware that the cookie data will be visible to the client, so if there is any reason to keep it secure or obscure, then express-session may be a better choice.

Don’t use the default session cookie name

Using the default session cookie name can open your app to attacks. The security issue posed is similar to X-Powered-By: a potential attacker can use it to fingerprint the server and target attacks accordingly.

To avoid this problem, use generic cookie names; for example using express-session middleware:

const session = require('express-session')
app.set('trust proxy', 1) // trust first proxy
app.use(session({
  secret: 's3Cur3',
  name: 'sessionId'
}))


Set cookie security options

Set the following cookie options to enhance security:


  secure - Ensures the browser only sends the cookie over HTTPS.
  httpOnly - Ensures the cookie is sent only over HTTP(S), not client JavaScript, helping to protect against cross-site scripting attacks.
  domain - indicates the domain of the cookie; use it to compare against the domain of the server in which the URL is being requested. If they match, then check the path attribute next.
  path - indicates the path of the cookie; use it to compare against the request path. If this and domain match, then send the cookie in the request.
  expires - use to set expiration date for persistent cookies.


Here is an example using cookie-session middleware:

const session = require('cookie-session')
const express = require('express')
const app = express()

const expiryDate = new Date(Date.now() + 60 * 60 * 1000) // 1 hour
app.use(session({
  name: 'session',
  keys: ['key1', 'key2'],
  cookie: {
    secure: true,
    httpOnly: true,
    domain: 'example.com',
    path: 'foo/bar',
    expires: expiryDate
  }
}))


Prevent brute-force attacks against authorization

Make sure login endpoints are protected to make private data more secure.

A simple and powerful technique is to block authorization attempts using two metrics:

  The number of consecutive failed attempts by the same user name and IP address.
  The number of failed attempts from an IP address over some long period of time. For example, block an IP address if it makes 100 failed attempts in one day.


rate-limiter-flexible package provides tools to make this technique easy and fast. You can find an example of brute-force protection in the documentation

Ensure your dependencies are secure

Using npm to manage your application’s dependencies is powerful and convenient. But the packages that you use may contain critical security vulnerabilities that could also affect your application. The security of your app is only as strong as the “weakest link” in your dependencies.

Since npm@6, npm automatically reviews every install request. Also, you can use npm audit to analyze your dependency tree.

$ npm audit


If you want to stay more secure, consider Snyk.

Snyk offers both a command-line tool and a Github integration that checks your application against Snyk’s open source vulnerability database for any known vulnerabilities in your dependencies. Install the CLI as follows:

$ npm install -g snyk
$ cd your-app


Use this command to test your application for vulnerabilities:

$ snyk test


Avoid other known vulnerabilities

Keep an eye out for Node Security Project or Snyk advisories that may affect Express or other modules that your app uses. In general, these databases are excellent resources for knowledge and tools about Node security.

Finally, Express apps—like any other web apps—can be vulnerable to a variety of web-based attacks. Familiarize yourself with known web vulnerabilities and take precautions to avoid them.

Additional considerations

Here are some further recommendations from the excellent Node.js Security Checklist. Refer to that blog post for all the details on these recommendations:


  Always filter and sanitize user input to protect against cross-site scripting (XSS) and command injection attacks.
  Defend against SQL injection attacks by using parameterized queries or prepared statements.
  Use the open-source sqlmap tool to detect SQL injection vulnerabilities in your app.
  Use the nmap and sslyze tools to test the configuration of your SSL ciphers, keys, and renegotiation as well as the validity of your certificate.
  Use safe-regex to ensure your regular expressions are not susceptible to regular expression denial of service attacks.



              
    
    Edit this page\n\nProduction Best Practices: Security

Overview

The term “production” refers to the stage in the software lifecycle when an application or API is generally available to its end-users or consumers. In contrast, in the “development” stage, you’re still actively writing and testing code, and the application is not open to external access. The corresponding system environments are known as production and development environments, respectively.

Development and production environments are usually set up differently and have vastly different requirements. What’s fine in development may not be acceptable in production. For example, in a development environment you may want verbose logging of errors for debugging, while the same behavior can become a security concern in a production environment. And in development, you don’t need to worry about scalability, reliability, and performance, while those concerns become critical in production.


   Note

  If you believe you have discovered a security vulnerability in Express, please see
Security Policies and Procedures.



Security best practices for Express applications in production include:


  Production Best Practices: Security
    
      Overview
      Don’t use deprecated or vulnerable versions of Express
      Use TLS
      Do not trust user input
        
          Prevent open redirects
        
      
      Use Helmet
      Reduce fingerprinting
      Use cookies securely
        
          Don’t use the default session cookie name
          Set cookie security options
        
      
      Prevent brute-force attacks against authorization
      Ensure your dependencies are secure
        
          Avoid other known vulnerabilities
        
      
      Additional considerations
    
  


Don’t use deprecated or vulnerable versions of Express

Express 2.x and 3.x are no longer maintained. Security and performance issues in these versions won’t be fixed. Do not use them! If you haven’t moved to version 4, follow the migration guide or consider Commercial Support Options.

Also ensure you are not using any of the vulnerable Express versions listed on the Security updates page. If you are, update to one of the stable releases, preferably the latest.

Use TLS

If your app deals with or transmits sensitive data, use Transport Layer Security (TLS) to secure the connection and the data. This technology encrypts data before it is sent from the client to the server, thus preventing some common (and easy) hacks. Although Ajax and POST requests might not be visibly obvious and seem “hidden” in browsers, their network traffic is vulnerable to packet sniffing and man-in-the-middle attacks.

You may be familiar with Secure Socket Layer (SSL) encryption. TLS is simply the next progression of SSL. In other words, if you were using SSL before, consider upgrading to TLS. In general, we recommend Nginx to handle TLS. For a good reference to configure TLS on Nginx (and other servers), see Recommended Server Configurations (Mozilla Wiki).

Also, a handy tool to get a free TLS certificate is Let’s Encrypt, a free, automated, and open certificate authority (CA) provided by the Internet Security Research Group (ISRG).

Do not trust user input

For web applications, one of the most critical security requirements is proper user input validation and handling. This comes in many forms and we will not cover all of them here.
Ultimately, the responsibility for validating and correctly handling the types of user input your application accepts is yours.

Prevent open redirects

An example of potentially dangerous user input is an open redirect, where an application accepts a URL as user input (often in the URL query, for example ?url=https://example.com) and uses res.redirect to set the location header and
return a 3xx status.

An application must validate that it supports redirecting to the incoming URL to avoid sending users to malicious links such as phishing websites, among other risks.

Here is an example of checking URLs before using res.redirect or res.location:

app.use((req, res) => {
  try {
    if (new Url(req.query.url).host !== 'example.com') {
      return res.status(400).end(`Unsupported redirect to host: ${req.query.url}`)
    }
  } catch (e) {
    return res.status(400).end(`Invalid url: ${req.query.url}`)
  }
  res.redirect(req.query.url)
})


Use Helmet

Helmet can help protect your app from some well-known web vulnerabilities by setting HTTP headers appropriately.

Helmet is a middleware function that sets security-related HTTP response headers. Helmet sets the following headers by default:


  Content-Security-Policy: A powerful allow-list of what can happen on your page which mitigates many attacks
  Cross-Origin-Opener-Policy: Helps process-isolate your page
  Cross-Origin-Resource-Policy: Blocks others from loading your resources cross-origin
  Origin-Agent-Cluster: Changes process isolation to be origin-based
  Referrer-Policy: Controls the Referer header
  Strict-Transport-Security: Tells browsers to prefer HTTPS
  X-Content-Type-Options: Avoids MIME sniffing
  X-DNS-Prefetch-Control: Controls DNS prefetching
  X-Download-Options: Forces downloads to be saved (Internet Explorer only)
  X-Frame-Options: Legacy header that mitigates Clickjacking attacks
  X-Permitted-Cross-Domain-Policies: Controls cross-domain behavior for Adobe products, like Acrobat
  X-Powered-By: Info about the web server. Removed because it could be used in simple attacks
  X-XSS-Protection: Legacy header that tries to mitigate XSS attacks, but makes things worse, so Helmet disables it


Each header can be configured or disabled. To read more about it please go to its documentation website.

Install Helmet like any other module:

$ npm install helmet


Then to use it in your code:

// ...

const helmet = require('helmet')
app.use(helmet())

// ...


Reduce fingerprinting

It can help to provide an extra layer of security to reduce the ability of attackers to determine
the software that a server uses, known as “fingerprinting.” Though not a security issue itself, 
reducing the ability to fingerprint an application improves its overall security posture. 
Server software can be fingerprinted by quirks in how it responds to specific requests, for example in 
the HTTP response headers.

By default, Express sends the X-Powered-By response header that you can 
disable using the app.disable() method:

app.disable('x-powered-by')



   Note

  Disabling the X-Powered-By header does not prevent
a sophisticated attacker from determining that an app is running Express. It may
discourage a casual exploit, but there are other ways to determine an app is running
Express.



Express also sends its own formatted “404 Not Found” messages and formatter error
response messages. These can be changed by
adding your own not found handler
and
writing your own error handler:

// last app.use calls right before app.listen():

// custom 404
app.use((req, res, next) => {
  res.status(404).send("Sorry can't find that!")
})

// custom error handler
app.use((err, req, res, next) => {
  console.error(err.stack)
  res.status(500).send('Something broke!')
})


Use cookies securely

To ensure cookies don’t open your app to exploits, don’t use the default session cookie name and set cookie security options appropriately.

There are two main middleware cookie session modules:


  express-session that replaces express.session middleware built-in to Express 3.x.
  cookie-session that replaces express.cookieSession middleware built-in to Express 3.x.


The main difference between these two modules is how they save cookie session data. The express-session middleware stores session data on the server; it only saves the session ID in the cookie itself, not session data. By default, it uses in-memory storage and is not designed for a production environment. In production, you’ll need to set up a scalable session-store; see the list of compatible session stores.

In contrast, cookie-session middleware implements cookie-backed storage: it serializes the entire session to the cookie, rather than just a session key. Only use it when session data is relatively small and easily encoded as primitive values (rather than objects). Although browsers are supposed to support at least 4096 bytes per cookie, to ensure you don’t exceed the limit, don’t exceed a size of 4093 bytes per domain. Also, be aware that the cookie data will be visible to the client, so if there is any reason to keep it secure or obscure, then express-session may be a better choice.

Don’t use the default session cookie name

Using the default session cookie name can open your app to attacks. The security issue posed is similar to X-Powered-By: a potential attacker can use it to fingerprint the server and target attacks accordingly.

To avoid this problem, use generic cookie names; for example using express-session middleware:

const session = require('express-session')
app.set('trust proxy', 1) // trust first proxy
app.use(session({
  secret: 's3Cur3',
  name: 'sessionId'
}))


Set cookie security options

Set the following cookie options to enhance security:


  secure - Ensures the browser only sends the cookie over HTTPS.
  httpOnly - Ensures the cookie is sent only over HTTP(S), not client JavaScript, helping to protect against cross-site scripting attacks.
  domain - indicates the domain of the cookie; use it to compare against the domain of the server in which the URL is being requested. If they match, then check the path attribute next.
  path - indicates the path of the cookie; use it to compare against the request path. If this and domain match, then send the cookie in the request.
  expires - use to set expiration date for persistent cookies.


Here is an example using cookie-session middleware:

const session = require('cookie-session')
const express = require('express')
const app = express()

const expiryDate = new Date(Date.now() + 60 * 60 * 1000) // 1 hour
app.use(session({
  name: 'session',
  keys: ['key1', 'key2'],
  cookie: {
    secure: true,
    httpOnly: true,
    domain: 'example.com',
    path: 'foo/bar',
    expires: expiryDate
  }
}))


Prevent brute-force attacks against authorization

Make sure login endpoints are protected to make private data more secure.

A simple and powerful technique is to block authorization attempts using two metrics:

  The number of consecutive failed attempts by the same user name and IP address.
  The number of failed attempts from an IP address over some long period of time. For example, block an IP address if it makes 100 failed attempts in one day.


rate-limiter-flexible package provides tools to make this technique easy and fast. You can find an example of brute-force protection in the documentation

Ensure your dependencies are secure

Using npm to manage your application’s dependencies is powerful and convenient. But the packages that you use may contain critical security vulnerabilities that could also affect your application. The security of your app is only as strong as the “weakest link” in your dependencies.

Since npm@6, npm automatically reviews every install request. Also, you can use npm audit to analyze your dependency tree.

$ npm audit


If you want to stay more secure, consider Snyk.

Snyk offers both a command-line tool and a Github integration that checks your application against Snyk’s open source vulnerability database for any known vulnerabilities in your dependencies. Install the CLI as follows:

$ npm install -g snyk
$ cd your-app


Use this command to test your application for vulnerabilities:

$ snyk test


Avoid other known vulnerabilities

Keep an eye out for Node Security Project or Snyk advisories that may affect Express or other modules that your app uses. In general, these databases are excellent resources for knowledge and tools about Node security.

Finally, Express apps—like any other web apps—can be vulnerable to a variety of web-based attacks. Familiarize yourself with known web vulnerabilities and take precautions to avoid them.

Additional considerations

Here are some further recommendations from the excellent Node.js Security Checklist. Refer to that blog post for all the details on these recommendations:


  Always filter and sanitize user input to protect against cross-site scripting (XSS) and command injection attacks.
  Defend against SQL injection attacks by using parameterized queries or prepared statements.
  Use the open-source sqlmap tool to detect SQL injection vulnerabilities in your app.
  Use the nmap and sslyze tools to test the configuration of your SSL ciphers, keys, and renegotiation as well as the validity of your certificate.
  Use safe-regex to ensure your regular expressions are not susceptible to regular expression denial of service attacks.



              
    
    Edit this page\n\n\n\nProduction best practices: performance and reliability

This article discusses performance and reliability best practices for Express applications deployed to production.

This topic clearly falls into the “devops” world, spanning both traditional development and operations. Accordingly, the information is divided into two parts:


  Things to do in your code (the dev part):
    
      Use gzip compression
      Don’t use synchronous functions
      Do logging correctly
      Handle exceptions properly
    
  
  Things to do in your environment / setup (the ops part):
    
      Set NODE_ENV to “production”
      Ensure your app automatically restarts
      Run your app in a cluster
      Cache request results
      Use a load balancer
      Use a reverse proxy
    
  


Things to do in your code

Here are some things you can do in your code to improve your application’s performance:


  Use gzip compression
  Don’t use synchronous functions
  Do logging correctly
  Handle exceptions properly


Use gzip compression

Gzip compressing can greatly decrease the size of the response body and hence increase the speed of a web app. Use the compression middleware for gzip compression in your Express app. For example:

const compression = require('compression')
const express = require('express')
const app = express()

app.use(compression())


For a high-traffic website in production, the best way to put compression in place is to implement it at a reverse proxy level (see Use a reverse proxy). In that case, you do not need to use compression middleware. For details on enabling gzip compression in Nginx, see Module ngx_http_gzip_module in the Nginx documentation.

Don’t use synchronous functions

Synchronous functions and methods tie up the executing process until they return. A single call to a synchronous function might return in a few microseconds or milliseconds, however in high-traffic websites, these calls add up and reduce the performance of the app. Avoid their use in production.

Although Node and many modules provide synchronous and asynchronous versions of their functions, always use the asynchronous version in production. The only time when a synchronous function can be justified is upon initial startup.

You can use the --trace-sync-io command-line flag to print a warning and a stack trace whenever your application uses a synchronous API. Of course, you wouldn’t want to use this in production, but rather to ensure that your code is ready for production. See the node command-line options documentation for more information.

Do logging correctly

In general, there are two reasons for logging from your app: For debugging and for logging app activity (essentially, everything else). Using console.log() or console.error() to print log messages to the terminal is common practice in development. But these functions are synchronous when the destination is a terminal or a file, so they are not suitable for production, unless you pipe the output to another program.

For debugging

If you’re logging for purposes of debugging, then instead of using console.log(), use a special debugging module like debug. This module enables you to use the DEBUG environment variable to control what debug messages are sent to console.error(), if any. To keep your app purely asynchronous, you’d still want to pipe console.error() to another program. But then, you’re not really going to debug in production, are you?

For app activity

If you’re logging app activity (for example, tracking traffic or API calls), instead of using console.log(), use a logging library like Pino, which is the fastest and most efficient option available.

Handle exceptions properly

Node apps crash when they encounter an uncaught exception. Not handling exceptions and taking appropriate actions will make your Express app crash and go offline. If you follow the advice in Ensure your app automatically restarts below, then your app will recover from a crash. Fortunately, Express apps typically have a short startup time. Nevertheless, you want to avoid crashing in the first place, and to do that, you need to handle exceptions properly.

To ensure you handle all exceptions, use the following techniques:


  Use try-catch
  Use promises


Before diving into these topics, you should have a basic understanding of Node/Express error handling: using error-first callbacks, and propagating errors in middleware. Node uses an “error-first callback” convention for returning errors from asynchronous functions, where the first parameter to the callback function is the error object, followed by result data in succeeding parameters. To indicate no error, pass null as the first parameter. The callback function must correspondingly follow the error-first callback convention to meaningfully handle the error. And in Express, the best practice is to use the next() function to propagate errors through the middleware chain.

For more on the fundamentals of error handling, see:


  Error Handling in Node.js


Use try-catch

Try-catch is a JavaScript language construct that you can use to catch exceptions in synchronous code. Use try-catch, for example, to handle JSON parsing errors as shown below.

Here is an example of using try-catch to handle a potential process-crashing exception.
This middleware function accepts a query field parameter named “params” that is a JSON object.

app.get('/search', (req, res) => {
  // Simulating async operation
  setImmediate(() => {
    const jsonStr = req.query.params
    try {
      const jsonObj = JSON.parse(jsonStr)
      res.send('Success')
    } catch (e) {
      res.status(400).send('Invalid JSON string')
    }
  })
})


However, try-catch works only for synchronous code. Because the Node platform is primarily asynchronous (particularly in a production environment), try-catch won’t catch a lot of exceptions.

Use promises

When an error is thrown in an async function or a rejected promise is awaited inside an async function, those errors will be passed to the error handler as if calling next(err)

app.get('/', async (req, res, next) => {
  const data = await userData() // If this promise fails, it will automatically call `next(err)` to handle the error.

  res.send(data)
})

app.use((err, req, res, next) => {
  res.status(err.status ?? 500).send({ error: err.message })
})


Also, you can use asynchronous functions for your middleware, and the router will handle errors if the promise fails, for example:

app.use(async (req, res, next) => {
  req.locals.user = await getUser(req)

  next() // This will be called if the promise does not throw an error.
})


Best practice is to handle errors as close to the site as possible. So while this is now handled in the router, it’s best to catch the error in the middleware and handle it without relying on separate error-handling middleware.

What not to do

One thing you should not do is to listen for the uncaughtException event, emitted when an exception bubbles all the way back to the event loop. Adding an event listener for uncaughtException will change the default behavior of the process that is encountering an exception; the process will continue to run despite the exception. This might sound like a good way of preventing your app from crashing, but continuing to run the app after an uncaught exception is a dangerous practice and is not recommended, because the state of the process becomes unreliable and unpredictable.

Additionally, using uncaughtException is officially recognized as crude. So listening for uncaughtException is just a bad idea. This is why we recommend things like multiple processes and supervisors: crashing and restarting is often the most reliable way to recover from an error.

We also don’t recommend using domains. It generally doesn’t solve the problem and is a deprecated module.

Things to do in your environment / setup
{#in-environment}

Here are some things you can do in your system environment to improve your app’s performance:


  Set NODE_ENV to “production”
  Ensure your app automatically restarts
  Run your app in a cluster
  Cache request results
  Use a load balancer
  Use a reverse proxy


Set NODE_ENV to “production”

The NODE_ENV environment variable specifies the environment in which an application is running (usually, development or production). One of the simplest things you can do to improve performance is to set NODE_ENV to production.

Setting NODE_ENV to “production” makes Express:


  Cache view templates.
  Cache CSS files generated from CSS extensions.
  Generate less verbose error messages.


Tests indicate that just doing this can improve app performance by a factor of three!

If you need to write environment-specific code, you can check the value of NODE_ENV with process.env.NODE_ENV. Be aware that checking the value of any environment variable incurs a performance penalty, and so should be done sparingly.

In development, you typically set environment variables in your interactive shell, for example by using export or your .bash_profile file. But in general, you shouldn’t do that on a production server; instead, use your OS’s init system (systemd). The next section provides more details about using your init system in general, but setting NODE_ENV is so important for performance (and easy to do), that it’s highlighted here.

With systemd, use the Environment directive in your unit file. For example:

# /etc/systemd/system/myservice.service
Environment=NODE_ENV=production


For more information, see Using Environment Variables In systemd Units.

Ensure your app automatically restarts

In production, you don’t want your application to be offline, ever. This means you need to make sure it restarts both if the app crashes and if the server itself crashes. Although you hope that neither of those events occurs, realistically you must account for both eventualities by:


  Using a process manager to restart the app (and Node) when it crashes.
  Using the init system provided by your OS to restart the process manager when the OS crashes. It’s also possible to use the init system without a process manager.


Node applications crash if they encounter an uncaught exception. The foremost thing you need to do is to ensure your app is well-tested and handles all exceptions (see handle exceptions properly for details). But as a fail-safe, put a mechanism in place to ensure that if and when your app crashes, it will automatically restart.

Use a process manager

In development, you started your app simply from the command line with node server.js or something similar. But doing this in production is a recipe for disaster. If the app crashes, it will be offline until you restart it. To ensure your app restarts if it crashes, use a process manager. A process manager is a “container” for applications that facilitates deployment, provides high availability, and enables you to manage the application at runtime.

In addition to restarting your app when it crashes, a process manager can enable you to:


  Gain insights into runtime performance and resource consumption.
  Modify settings dynamically to improve performance.
  Control clustering (pm2).


Historically, it was popular to use a Node.js process manager like PM2. See their documentation if you wish to do this. However, we recommend using your init system for process management.

Use an init system

The next layer of reliability is to ensure that your app restarts when the server restarts. Systems can still go down for a variety of reasons. To ensure that your app restarts if the server crashes, use the init system built into your OS. The main init system in use today is systemd.

There are two ways to use init systems with your Express app:


  Run your app in a process manager, and install the process manager as a service with the init system. The process manager will restart your app when the app crashes, and the init system will restart the process manager when the OS restarts. This is the recommended approach.
  Run your app (and Node) directly with the init system. This is somewhat simpler, but you don’t get the additional advantages of using a process manager.


Systemd

Systemd is a Linux system and service manager. Most major Linux distributions have adopted systemd as their default init system.

A systemd service configuration file is called a unit file, with a filename ending in .service. Here’s an example unit file to manage a Node app directly. Replace the values enclosed in <angle brackets> for your system and app:

[Unit]
Description=<Awesome Express App>

[Service]
Type=simple
ExecStart=/usr/local/bin/node </projects/myapp/index.js>
WorkingDirectory=</projects/myapp>

User=nobody
Group=nogroup

# Environment variables:
Environment=NODE_ENV=production

# Allow many incoming connections
LimitNOFILE=infinity

# Allow core dumps for debugging
LimitCORE=infinity

StandardInput=null
StandardOutput=syslog
StandardError=syslog
Restart=always

[Install]
WantedBy=multi-user.target


For more information on systemd, see the systemd reference (man page).

Run your app in a cluster

In a multi-core system, you can increase the performance of a Node app by many times by launching a cluster of processes. A cluster runs multiple instances of the app, ideally one instance on each CPU core, thereby distributing the load and tasks among the instances.



IMPORTANT: Since the app instances run as separate processes, they do not share the same memory space. That is, objects are local to each instance of the app. Therefore, you cannot maintain state in the application code. However, you can use an in-memory datastore like Redis to store session-related data and state. This caveat applies to essentially all forms of horizontal scaling, whether clustering with multiple processes or multiple physical servers.

In clustered apps, worker processes can crash individually without affecting the rest of the processes. Apart from performance advantages, failure isolation is another reason to run a cluster of app processes. Whenever a worker process crashes, always make sure to log the event and spawn a new process using cluster.fork().

Using Node’s cluster module

Clustering is made possible with Node’s cluster module. This enables a master process to spawn worker processes and distribute incoming connections among the workers.

Using PM2

If you deploy your application with PM2, then you can take advantage of clustering without modifying your application code. You should ensure your application is stateless first, meaning no local data is stored in the process (such as sessions, websocket connections and the like).

When running an application with PM2, you can enable cluster mode to run it in a cluster with a number of instances of your choosing, such as the matching the number of available CPUs on the machine. You can manually change the number of processes in the cluster using the pm2 command line tool without stopping the app.

To enable cluster mode, start your application like so:

# Start 4 worker processes
$ pm2 start npm --name my-app -i 4 -- start
# Auto-detect number of available CPUs and start that many worker processes
$ pm2 start npm --name my-app -i max -- start


This can also be configured within a PM2 process file (ecosystem.config.js or similar) by setting exec_mode to cluster and instances to the number of workers to start.

Once running, the application can be scaled like so:

# Add 3 more workers
$ pm2 scale my-app +3
# Scale to a specific number of workers
$ pm2 scale my-app 2


For more information on clustering with PM2, see Cluster Mode in the PM2 documentation.

Cache request results

Another strategy to improve the performance in production is to cache the result of requests, so that your app does not repeat the operation to serve the same request repeatedly.

Use a caching server like Varnish or Nginx (see also Nginx Caching) to greatly improve the speed and performance of your app.

Use a load balancer

No matter how optimized an app is, a single instance can handle only a limited amount of load and traffic. One way to scale an app is to run multiple instances of it and distribute the traffic via a load balancer. Setting up a load balancer can improve your app’s performance and speed, and enable it to scale more than is possible with a single instance.

A load balancer is usually a reverse proxy that orchestrates traffic to and from multiple application instances and servers. You can easily set up a load balancer for your app by using Nginx or HAProxy.

With load balancing, you might have to ensure that requests that are associated with a particular session ID connect to the process that originated them. This is known as session affinity, or sticky sessions, and may be addressed by the suggestion above to use a data store such as Redis for session data (depending on your application). For a discussion, see Using multiple nodes.

Use a reverse proxy

A reverse proxy sits in front of a web app and performs supporting operations on the requests, apart from directing requests to the app. It can handle error pages, compression, caching, serving files, and load balancing among other things.

Handing over tasks that do not require knowledge of application state to a reverse proxy frees up Express to perform specialized application tasks. For this reason, it is recommended to run Express behind a reverse proxy like Nginx or HAProxy in production.

              
    
    Edit this page\n\nProduction best practices: performance and reliability

This article discusses performance and reliability best practices for Express applications deployed to production.

This topic clearly falls into the “devops” world, spanning both traditional development and operations. Accordingly, the information is divided into two parts:


  Things to do in your code (the dev part):
    
      Use gzip compression
      Don’t use synchronous functions
      Do logging correctly
      Handle exceptions properly
    
  
  Things to do in your environment / setup (the ops part):
    
      Set NODE_ENV to “production”
      Ensure your app automatically restarts
      Run your app in a cluster
      Cache request results
      Use a load balancer
      Use a reverse proxy
    
  


Things to do in your code

Here are some things you can do in your code to improve your application’s performance:


  Use gzip compression
  Don’t use synchronous functions
  Do logging correctly
  Handle exceptions properly


Use gzip compression

Gzip compressing can greatly decrease the size of the response body and hence increase the speed of a web app. Use the compression middleware for gzip compression in your Express app. For example:

const compression = require('compression')
const express = require('express')
const app = express()

app.use(compression())


For a high-traffic website in production, the best way to put compression in place is to implement it at a reverse proxy level (see Use a reverse proxy). In that case, you do not need to use compression middleware. For details on enabling gzip compression in Nginx, see Module ngx_http_gzip_module in the Nginx documentation.

Don’t use synchronous functions

Synchronous functions and methods tie up the executing process until they return. A single call to a synchronous function might return in a few microseconds or milliseconds, however in high-traffic websites, these calls add up and reduce the performance of the app. Avoid their use in production.

Although Node and many modules provide synchronous and asynchronous versions of their functions, always use the asynchronous version in production. The only time when a synchronous function can be justified is upon initial startup.

You can use the --trace-sync-io command-line flag to print a warning and a stack trace whenever your application uses a synchronous API. Of course, you wouldn’t want to use this in production, but rather to ensure that your code is ready for production. See the node command-line options documentation for more information.

Do logging correctly

In general, there are two reasons for logging from your app: For debugging and for logging app activity (essentially, everything else). Using console.log() or console.error() to print log messages to the terminal is common practice in development. But these functions are synchronous when the destination is a terminal or a file, so they are not suitable for production, unless you pipe the output to another program.

For debugging

If you’re logging for purposes of debugging, then instead of using console.log(), use a special debugging module like debug. This module enables you to use the DEBUG environment variable to control what debug messages are sent to console.error(), if any. To keep your app purely asynchronous, you’d still want to pipe console.error() to another program. But then, you’re not really going to debug in production, are you?

For app activity

If you’re logging app activity (for example, tracking traffic or API calls), instead of using console.log(), use a logging library like Pino, which is the fastest and most efficient option available.

Handle exceptions properly

Node apps crash when they encounter an uncaught exception. Not handling exceptions and taking appropriate actions will make your Express app crash and go offline. If you follow the advice in Ensure your app automatically restarts below, then your app will recover from a crash. Fortunately, Express apps typically have a short startup time. Nevertheless, you want to avoid crashing in the first place, and to do that, you need to handle exceptions properly.

To ensure you handle all exceptions, use the following techniques:


  Use try-catch
  Use promises


Before diving into these topics, you should have a basic understanding of Node/Express error handling: using error-first callbacks, and propagating errors in middleware. Node uses an “error-first callback” convention for returning errors from asynchronous functions, where the first parameter to the callback function is the error object, followed by result data in succeeding parameters. To indicate no error, pass null as the first parameter. The callback function must correspondingly follow the error-first callback convention to meaningfully handle the error. And in Express, the best practice is to use the next() function to propagate errors through the middleware chain.

For more on the fundamentals of error handling, see:


  Error Handling in Node.js


Use try-catch

Try-catch is a JavaScript language construct that you can use to catch exceptions in synchronous code. Use try-catch, for example, to handle JSON parsing errors as shown below.

Here is an example of using try-catch to handle a potential process-crashing exception.
This middleware function accepts a query field parameter named “params” that is a JSON object.

app.get('/search', (req, res) => {
  // Simulating async operation
  setImmediate(() => {
    const jsonStr = req.query.params
    try {
      const jsonObj = JSON.parse(jsonStr)
      res.send('Success')
    } catch (e) {
      res.status(400).send('Invalid JSON string')
    }
  })
})


However, try-catch works only for synchronous code. Because the Node platform is primarily asynchronous (particularly in a production environment), try-catch won’t catch a lot of exceptions.

Use promises

When an error is thrown in an async function or a rejected promise is awaited inside an async function, those errors will be passed to the error handler as if calling next(err)

app.get('/', async (req, res, next) => {
  const data = await userData() // If this promise fails, it will automatically call `next(err)` to handle the error.

  res.send(data)
})

app.use((err, req, res, next) => {
  res.status(err.status ?? 500).send({ error: err.message })
})


Also, you can use asynchronous functions for your middleware, and the router will handle errors if the promise fails, for example:

app.use(async (req, res, next) => {
  req.locals.user = await getUser(req)

  next() // This will be called if the promise does not throw an error.
})


Best practice is to handle errors as close to the site as possible. So while this is now handled in the router, it’s best to catch the error in the middleware and handle it without relying on separate error-handling middleware.

What not to do

One thing you should not do is to listen for the uncaughtException event, emitted when an exception bubbles all the way back to the event loop. Adding an event listener for uncaughtException will change the default behavior of the process that is encountering an exception; the process will continue to run despite the exception. This might sound like a good way of preventing your app from crashing, but continuing to run the app after an uncaught exception is a dangerous practice and is not recommended, because the state of the process becomes unreliable and unpredictable.

Additionally, using uncaughtException is officially recognized as crude. So listening for uncaughtException is just a bad idea. This is why we recommend things like multiple processes and supervisors: crashing and restarting is often the most reliable way to recover from an error.

We also don’t recommend using domains. It generally doesn’t solve the problem and is a deprecated module.

Things to do in your environment / setup
{#in-environment}

Here are some things you can do in your system environment to improve your app’s performance:


  Set NODE_ENV to “production”
  Ensure your app automatically restarts
  Run your app in a cluster
  Cache request results
  Use a load balancer
  Use a reverse proxy


Set NODE_ENV to “production”

The NODE_ENV environment variable specifies the environment in which an application is running (usually, development or production). One of the simplest things you can do to improve performance is to set NODE_ENV to production.

Setting NODE_ENV to “production” makes Express:


  Cache view templates.
  Cache CSS files generated from CSS extensions.
  Generate less verbose error messages.


Tests indicate that just doing this can improve app performance by a factor of three!

If you need to write environment-specific code, you can check the value of NODE_ENV with process.env.NODE_ENV. Be aware that checking the value of any environment variable incurs a performance penalty, and so should be done sparingly.

In development, you typically set environment variables in your interactive shell, for example by using export or your .bash_profile file. But in general, you shouldn’t do that on a production server; instead, use your OS’s init system (systemd). The next section provides more details about using your init system in general, but setting NODE_ENV is so important for performance (and easy to do), that it’s highlighted here.

With systemd, use the Environment directive in your unit file. For example:

# /etc/systemd/system/myservice.service
Environment=NODE_ENV=production


For more information, see Using Environment Variables In systemd Units.

Ensure your app automatically restarts

In production, you don’t want your application to be offline, ever. This means you need to make sure it restarts both if the app crashes and if the server itself crashes. Although you hope that neither of those events occurs, realistically you must account for both eventualities by:


  Using a process manager to restart the app (and Node) when it crashes.
  Using the init system provided by your OS to restart the process manager when the OS crashes. It’s also possible to use the init system without a process manager.


Node applications crash if they encounter an uncaught exception. The foremost thing you need to do is to ensure your app is well-tested and handles all exceptions (see handle exceptions properly for details). But as a fail-safe, put a mechanism in place to ensure that if and when your app crashes, it will automatically restart.

Use a process manager

In development, you started your app simply from the command line with node server.js or something similar. But doing this in production is a recipe for disaster. If the app crashes, it will be offline until you restart it. To ensure your app restarts if it crashes, use a process manager. A process manager is a “container” for applications that facilitates deployment, provides high availability, and enables you to manage the application at runtime.

In addition to restarting your app when it crashes, a process manager can enable you to:


  Gain insights into runtime performance and resource consumption.
  Modify settings dynamically to improve performance.
  Control clustering (pm2).


Historically, it was popular to use a Node.js process manager like PM2. See their documentation if you wish to do this. However, we recommend using your init system for process management.

Use an init system

The next layer of reliability is to ensure that your app restarts when the server restarts. Systems can still go down for a variety of reasons. To ensure that your app restarts if the server crashes, use the init system built into your OS. The main init system in use today is systemd.

There are two ways to use init systems with your Express app:


  Run your app in a process manager, and install the process manager as a service with the init system. The process manager will restart your app when the app crashes, and the init system will restart the process manager when the OS restarts. This is the recommended approach.
  Run your app (and Node) directly with the init system. This is somewhat simpler, but you don’t get the additional advantages of using a process manager.


Systemd

Systemd is a Linux system and service manager. Most major Linux distributions have adopted systemd as their default init system.

A systemd service configuration file is called a unit file, with a filename ending in .service. Here’s an example unit file to manage a Node app directly. Replace the values enclosed in <angle brackets> for your system and app:

[Unit]
Description=<Awesome Express App>

[Service]
Type=simple
ExecStart=/usr/local/bin/node </projects/myapp/index.js>
WorkingDirectory=</projects/myapp>

User=nobody
Group=nogroup

# Environment variables:
Environment=NODE_ENV=production

# Allow many incoming connections
LimitNOFILE=infinity

# Allow core dumps for debugging
LimitCORE=infinity

StandardInput=null
StandardOutput=syslog
StandardError=syslog
Restart=always

[Install]
WantedBy=multi-user.target


For more information on systemd, see the systemd reference (man page).

Run your app in a cluster

In a multi-core system, you can increase the performance of a Node app by many times by launching a cluster of processes. A cluster runs multiple instances of the app, ideally one instance on each CPU core, thereby distributing the load and tasks among the instances.



IMPORTANT: Since the app instances run as separate processes, they do not share the same memory space. That is, objects are local to each instance of the app. Therefore, you cannot maintain state in the application code. However, you can use an in-memory datastore like Redis to store session-related data and state. This caveat applies to essentially all forms of horizontal scaling, whether clustering with multiple processes or multiple physical servers.

In clustered apps, worker processes can crash individually without affecting the rest of the processes. Apart from performance advantages, failure isolation is another reason to run a cluster of app processes. Whenever a worker process crashes, always make sure to log the event and spawn a new process using cluster.fork().

Using Node’s cluster module

Clustering is made possible with Node’s cluster module. This enables a master process to spawn worker processes and distribute incoming connections among the workers.

Using PM2

If you deploy your application with PM2, then you can take advantage of clustering without modifying your application code. You should ensure your application is stateless first, meaning no local data is stored in the process (such as sessions, websocket connections and the like).

When running an application with PM2, you can enable cluster mode to run it in a cluster with a number of instances of your choosing, such as the matching the number of available CPUs on the machine. You can manually change the number of processes in the cluster using the pm2 command line tool without stopping the app.

To enable cluster mode, start your application like so:

# Start 4 worker processes
$ pm2 start npm --name my-app -i 4 -- start
# Auto-detect number of available CPUs and start that many worker processes
$ pm2 start npm --name my-app -i max -- start


This can also be configured within a PM2 process file (ecosystem.config.js or similar) by setting exec_mode to cluster and instances to the number of workers to start.

Once running, the application can be scaled like so:

# Add 3 more workers
$ pm2 scale my-app +3
# Scale to a specific number of workers
$ pm2 scale my-app 2


For more information on clustering with PM2, see Cluster Mode in the PM2 documentation.

Cache request results

Another strategy to improve the performance in production is to cache the result of requests, so that your app does not repeat the operation to serve the same request repeatedly.

Use a caching server like Varnish or Nginx (see also Nginx Caching) to greatly improve the speed and performance of your app.

Use a load balancer

No matter how optimized an app is, a single instance can handle only a limited amount of load and traffic. One way to scale an app is to run multiple instances of it and distribute the traffic via a load balancer. Setting up a load balancer can improve your app’s performance and speed, and enable it to scale more than is possible with a single instance.

A load balancer is usually a reverse proxy that orchestrates traffic to and from multiple application instances and servers. You can easily set up a load balancer for your app by using Nginx or HAProxy.

With load balancing, you might have to ensure that requests that are associated with a particular session ID connect to the process that originated them. This is known as session affinity, or sticky sessions, and may be addressed by the suggestion above to use a data store such as Redis for session data (depending on your application). For a discussion, see Using multiple nodes.

Use a reverse proxy

A reverse proxy sits in front of a web app and performs supporting operations on the requests, apart from directing requests to the app. It can handle error pages, compression, caching, serving files, and load balancing among other things.

Handing over tasks that do not require knowledge of application state to a reverse proxy frees up Express to perform specialized application tasks. For this reason, it is recommended to run Express behind a reverse proxy like Nginx or HAProxy in production.

              
    
    Edit this page\n\n\n\nHealth Checks and Graceful Shutdown

Graceful shutdown

When you deploy a new version of your application, you must replace the previous version. The process manager you’re using will first send a SIGTERM signal to the application to notify it that it will be killed. Once the application gets this signal, it should stop accepting new requests, finish all the ongoing requests, clean up the resources it used,  including database connections and file locks then exit.

Example

const server = app.listen(port)

process.on('SIGTERM', () => {
  debug('SIGTERM signal received: closing HTTP server')
  server.close(() => {
    debug('HTTP server closed')
  })
})


Health checks

A load balancer uses health checks to determine if an application instance is healthy and can accept requests. For example, Kubernetes has two health checks:


  liveness, that determines when to restart a container.
  readiness, that determines when a container is ready to start accepting traffic. When a pod is not ready, it is removed from the service load balancers.


              
    
    Edit this page\n\nHealth Checks and Graceful Shutdown

Graceful shutdown

When you deploy a new version of your application, you must replace the previous version. The process manager you’re using will first send a SIGTERM signal to the application to notify it that it will be killed. Once the application gets this signal, it should stop accepting new requests, finish all the ongoing requests, clean up the resources it used,  including database connections and file locks then exit.

Example

const server = app.listen(port)

process.on('SIGTERM', () => {
  debug('SIGTERM signal received: closing HTTP server')
  server.close(() => {
    debug('HTTP server closed')
  })
})


Health checks

A load balancer uses health checks to determine if an application instance is healthy and can accept requests. For example, Kubernetes has two health checks:


  liveness, that determines when to restart a container.
  readiness, that determines when a container is ready to start accepting traffic. When a pod is not ready, it is removed from the service load balancers.


              
    
    Edit this page\n\n\n\nGlossary

application

In general, one or more programs that are designed to carry out operations for a specific purpose.  In the context of Express, a program that uses the Express API running on the Node.js platform.  Might also refer to an app object.

API

Application programming interface. Spell out the abbreviation when it is first used.

Express

A fast, un-opinionated, minimalist web framework for Node.js applications. In general, “Express” is preferred to “Express.js,” though the latter is acceptable.

libuv

A multi-platform support library which focuses on asynchronous I/O, primarily developed for use by Node.js.

middleware

A function that is invoked by the Express routing layer before the final request handler, and thus sits in the middle between a raw request and the final intended route. A few fine points of terminology around middleware:


  var foo = require('middleware') is called requiring or using a Node.js module. Then the statement var mw = foo() typically returns the middleware.
  app.use(mw) is called adding the middleware to the global processing stack.
  app.get('/foo', mw, function (req, res) { ... }) is called adding the middleware to the “GET /foo” processing stack.


Node.js

A software platform that is used to build scalable network applications. Node.js uses JavaScript as its scripting language, and achieves high throughput via non-blocking I/O and a single-threaded event loop. See nodejs.org. Usage note: Initially, “Node.js,” thereafter “Node”.

open-source, open source

When used as an adjective, hyphenate; for example: “This is open-source software.” See Open-source software on Wikipedia.


   Note

  Although it is common not to hyphenate this term, we are using the standard English rules for hyphenating a compound adjective.



request

An HTTP request. A client submits an HTTP request message to a server, which returns a response.  The request must use one of several request methods such as GET, POST, and so on.

response

An HTTP response. A server returns an HTTP response message to the client. The response contains completion status information about the request and might also contain requested content in its message body.

route

Part of a URL that identifies a resource. For example, in http://foo.com/products/id, “/products/id” is the route.

router

See router in the API reference.

              
    
    Edit this page\n\nGlossary

application

In general, one or more programs that are designed to carry out operations for a specific purpose.  In the context of Express, a program that uses the Express API running on the Node.js platform.  Might also refer to an app object.

API

Application programming interface. Spell out the abbreviation when it is first used.

Express

A fast, un-opinionated, minimalist web framework for Node.js applications. In general, “Express” is preferred to “Express.js,” though the latter is acceptable.

libuv

A multi-platform support library which focuses on asynchronous I/O, primarily developed for use by Node.js.

middleware

A function that is invoked by the Express routing layer before the final request handler, and thus sits in the middle between a raw request and the final intended route. A few fine points of terminology around middleware:


  var foo = require('middleware') is called requiring or using a Node.js module. Then the statement var mw = foo() typically returns the middleware.
  app.use(mw) is called adding the middleware to the global processing stack.
  app.get('/foo', mw, function (req, res) { ... }) is called adding the middleware to the “GET /foo” processing stack.


Node.js

A software platform that is used to build scalable network applications. Node.js uses JavaScript as its scripting language, and achieves high throughput via non-blocking I/O and a single-threaded event loop. See nodejs.org. Usage note: Initially, “Node.js,” thereafter “Node”.

open-source, open source

When used as an adjective, hyphenate; for example: “This is open-source software.” See Open-source software on Wikipedia.


   Note

  Although it is common not to hyphenate this term, we are using the standard English rules for hyphenating a compound adjective.



request

An HTTP request. A client submits an HTTP request message to a server, which returns a response.  The request must use one of several request methods such as GET, POST, and so on.

response

An HTTP response. A server returns an HTTP response message to the client. The response contains completion status information about the request and might also contain requested content in its message body.

route

Part of a URL that identifies a resource. For example, in http://foo.com/products/id, “/products/id” is the route.

router

See router in the API reference.

              
    
    Edit this page\n\n\n\nCommunity

Technical committee

The Express technical committee meets online every two weeks (as needed) to discuss development and maintenance of Express,
and other issues relevant to the Express project. Each meeting is typically announced in an
expressjs/discussions issue with a link to join or view the meeting, which is
open to all observers.

The meetings are recorded; for a list of the recordings, see the Express.js YouTube channel.

Members of the Express technical committee are:

Active:


  @blakeembrey - Blake Embrey
  @crandmck - Rand McKinney
  @LinusU - Linus Unnebäck
  @ulisesgascon - Ulises Gascón
  @sheplu - Jean Burellier
  @wesleytodd - Wes Todd
  @jonchurch - Jon Church
  @ctcpip - Chris de Almeida


Inactive:


  @dougwilson - Douglas Wilson
  @hacksparrow - Hage Yaapa
  @jonathanong - jongleberry
  @niftylettuce - niftylettuce
  @troygoode - Troy Goode


Express is made of many modules

Our vibrant community has created a large variety of extensions,
middleware modules and higher-level frameworks.

Additionally, the Express community maintains modules in these two GitHub orgs:


  jshttp modules providing useful utility functions; see Utility modules.
  pillarjs: low-level modules that Express uses internally.


To keep up with what is going on in the whole community, check out the ExpressJS StatusBoard.

Issues

If you’ve come across what you think is a bug, or just want to make
a feature request open a ticket in the issue queue.

Examples

View dozens of Express application examples
in the repository covering everything from API design and authentication to template engine integration.

Github Discussions

The GitHub Discussions section is an excellent space to engage in conversations about the development and maintenance of Express, as well as to share ideas and discuss topics related to its usage.

Branding of Express.js

Express.js Logo

Express is a project of the OpenJS Foundation. Please review the trademark policy for information about permissible use of Express.js logos and marks.


    
        Logotype
        
            
        
        
            
        
    
    
        Logomark
        
            
        
        
            
        
    




              
    
    Edit this page\n\nCommunity

Technical committee

The Express technical committee meets online every two weeks (as needed) to discuss development and maintenance of Express,
and other issues relevant to the Express project. Each meeting is typically announced in an
expressjs/discussions issue with a link to join or view the meeting, which is
open to all observers.

The meetings are recorded; for a list of the recordings, see the Express.js YouTube channel.

Members of the Express technical committee are:

Active:


  @blakeembrey - Blake Embrey
  @crandmck - Rand McKinney
  @LinusU - Linus Unnebäck
  @ulisesgascon - Ulises Gascón
  @sheplu - Jean Burellier
  @wesleytodd - Wes Todd
  @jonchurch - Jon Church
  @ctcpip - Chris de Almeida


Inactive:


  @dougwilson - Douglas Wilson
  @hacksparrow - Hage Yaapa
  @jonathanong - jongleberry
  @niftylettuce - niftylettuce
  @troygoode - Troy Goode


Express is made of many modules

Our vibrant community has created a large variety of extensions,
middleware modules and higher-level frameworks.

Additionally, the Express community maintains modules in these two GitHub orgs:


  jshttp modules providing useful utility functions; see Utility modules.
  pillarjs: low-level modules that Express uses internally.


To keep up with what is going on in the whole community, check out the ExpressJS StatusBoard.

Issues

If you’ve come across what you think is a bug, or just want to make
a feature request open a ticket in the issue queue.

Examples

View dozens of Express application examples
in the repository covering everything from API design and authentication to template engine integration.

Github Discussions

The GitHub Discussions section is an excellent space to engage in conversations about the development and maintenance of Express, as well as to share ideas and discuss topics related to its usage.

Branding of Express.js

Express.js Logo

Express is a project of the OpenJS Foundation. Please review the trademark policy for information about permissible use of Express.js logos and marks.


    
        Logotype
        
            
        
        
            
        
    
    
        Logomark
        
            
        
        
            
        
    




              
    
    Edit this page\n\n\n\nExpress middleware

The Express middleware modules listed here are maintained by the
Expressjs team.


  
    
      Middleware module
      Description
    
  
  
    
      body-parser
      Parse HTTP request body.
    
    
      compression
      Compress HTTP responses.
    
    
      connect-rid
      Generate unique request ID.
    
    
      cookie-parser
      Parse cookie header and populate req.cookies. See also cookies.
    
    
      cookie-session
      Establish cookie-based sessions.
    
    
      cors
      Enable cross-origin resource sharing (CORS) with various options.
    
    
      errorhandler
      Development error-handling/debugging.
    
    
      method-override
      Override HTTP methods using header.
    
    
      morgan
      HTTP request logger.
    
    
      multer
      Handle multi-part form data.
    
    
      response-time
      Record HTTP response time.
    
    
      serve-favicon
      Serve a favicon.
    
    
      serve-index
      Serve directory listing for a given path.
    
    
      serve-static
      Serve static files.
    
    
      session
      Establish server-based sessions (development only).
    
    
      timeout
      Set a timeout perioHTTP request processing.
    
    
      vhost
      Create virtual domains.
    
  


Additional middleware modules

These are some additional popular middleware modules.


   Warning

  This information refers to third-party sites, products, or modules that are not maintained by the Expressjs team. Listing here does not constitute an endorsement or recommendation from the Expressjs project team.




  
    
      Middleware module
      Description
    
  
  
    
      helmet
      Helps secure your apps by setting various HTTP headers.
    
    
      passport
      Authentication using “strategies” such as OAuth, OpenID and many others.  See passportjs.org for more information.\n\nMiddlewares
    Middlewares ►
    
        
        
  body-parser
  compression
  connect-rid
  cookie-parser
  cookie-session
  cors
  errorhandler
  method-override
  morgan
  multer
  response-time
  serve-favicon
  serve-index
  serve-static
  session
  timeout
  vhost


    
  



        
      Express middleware

The Express middleware modules listed here are maintained by the
Expressjs team.


  
    
      Middleware module
      Description
    
  
  
    
      body-parser
      Parse HTTP request body.
    
    
      compression
      Compress HTTP responses.
    
    
      connect-rid
      Generate unique request ID.
    
    
      cookie-parser
      Parse cookie header and populate req.cookies. See also cookies.
    
    
      cookie-session
      Establish cookie-based sessions.
    
    
      cors
      Enable cross-origin resource sharing (CORS) with various options.
    
    
      errorhandler
      Development error-handling/debugging.
    
    
      method-override
      Override HTTP methods using header.
    
    
      morgan
      HTTP request logger.
    
    
      multer
      Handle multi-part form data.
    
    
      response-time
      Record HTTP response time.
    
    
      serve-favicon
      Serve a favicon.
    
    
      serve-index
      Serve directory listing for a given path.
    
    
      serve-static
      Serve static files.
    
    
      session
      Establish server-based sessions (development only).
    
    
      timeout
      Set a timeout perioHTTP request processing.
    
    
      vhost
      Create virtual domains.
    
  


Additional middleware modules

These are some additional popular middleware modules.


   Warning

  This information refers to third-party sites, products, or modules that are not maintained by the Expressjs team. Listing here does not constitute an endorsement or recommendation from the Expressjs project team.




  
    
      Middleware module
      Description
    
  
  
    
      helmet
      Helps secure your apps by setting various HTTP headers.
    
    
      passport
      Authentication using “strategies” such as OAuth, OpenID and many others.  See passportjs.org for more information.\n\n\n\nExpress utility functions

The pillarjs GitHub organization contains a number of modules
for utility functions that may be generally useful.


  
    
      Utility modules
      Description
    
  
  
    
      cookies
      Get and set HTTP(S) cookies that can be signed to prevent tampering, using Keygrip. Can be used with the Node.js HTTP library or as Express middleware.
    
    
      csrf
      Contains the logic behind CSRF token creation and verification.  Use this module to create custom CSRF middleware.
    
    
      finalhandler
      Function to invoke as the final step to respond to HTTP request.
    
    
      parseurl
      Parse a URL with caching.
    
    
      path-to-regexp
      Turn an Express-style path string such as ``/user/:name` into a regular expression.
    
    
      resolve-path
      Resolves a relative path against a root path with validation.
    
    
      router
      Simple middleware-style router.
    
    
      send
      Library for streaming files as a HTTP response, with support for partial responses (ranges), conditional-GET negotiation, and granular events.
    
  


For additional low-level HTTP-related modules, see jshttp.

              
    
    Edit this page\n\nExpress utility functions

The pillarjs GitHub organization contains a number of modules
for utility functions that may be generally useful.


  
    
      Utility modules
      Description
    
  
  
    
      cookies
      Get and set HTTP(S) cookies that can be signed to prevent tampering, using Keygrip. Can be used with the Node.js HTTP library or as Express middleware.
    
    
      csrf
      Contains the logic behind CSRF token creation and verification.  Use this module to create custom CSRF middleware.
    
    
      finalhandler
      Function to invoke as the final step to respond to HTTP request.
    
    
      parseurl
      Parse a URL with caching.
    
    
      path-to-regexp
      Turn an Express-style path string such as ``/user/:name` into a regular expression.
    
    
      resolve-path
      Resolves a relative path against a root path with validation.
    
    
      router
      Simple middleware-style router.
    
    
      send
      Library for streaming files as a HTTP response, with support for partial responses (ranges), conditional-GET negotiation, and granular events.
    
  


For additional low-level HTTP-related modules, see jshttp.

              
    
    Edit this page\n\n\n\nContributing to Express

Looking to contribute to Expressjs.com? Click here.

Express and the other projects in the expressjs organization on GitHub are projects of the OpenJs Foundation.
These projects are governed under the general policies and guidelines of the Node.js Foundation along with the additional guidelines below.


  Technical committee
  Community contributing guide
  Collaborator’s guide
  Security policies and procedures


Technical committee

The Express technical committee consists of active project members, and guides development and maintenance of the Express project. For more information, see Express Community - Technical committee.

Community contributing guide



The goal of this document is to create a contribution process that:


  Encourages new contributions.
  Encourages contributors to remain involved.
  Avoids unnecessary processes and bureaucracy whenever possible.
  Creates a transparent decision making process that makes it clear how
contributors can be involved in decision making.


Vocabulary


  A Contributor is any individual creating or commenting on an issue or pull request.
  A Committer is a subset of contributors who have been given write access to the repository.
  A Project Captain is the lead maintainer of a repository.
  A TC (Technical Committee) is a group of committers representing the required technical
expertise to resolve rare disputes.
  A Triager is a subset of contributors who have been given triage access to the repository.


Logging Issues

Log an issue for any question or problem you might have. When in doubt, log an issue, and
any additional policies about what to include will be provided in the responses. The only
exception is security disclosures which should be sent privately.

Committers may direct you to another repository, ask for additional clarifications, and
add appropriate metadata before the issue is addressed.

Please be courteous and respectful. Every participant is expected to follow the
project’s Code of Conduct.

Contributions

Any change to resources in this repository must be through pull requests. This applies to all changes
to documentation, code, binary files, etc. Even long term committers and TC members must use
pull requests.

No pull request can be merged without being reviewed.

For non-trivial contributions, pull requests should sit for at least 36 hours to ensure that
contributors in other timezones have time to review. Consideration should also be given to
weekends and other holiday periods to ensure active committers all have reasonable time to
become involved in the discussion and review process if they wish.

The default for each contribution is that it is accepted once no committer has an objection.
During a review, committers may also request that a specific contributor who is most versed in a
particular area gives a “LGTM” before the PR can be merged. There is no additional “sign off”
process for contributions to land. Once all issues brought by committers are addressed it can
be landed by any committer.

In the case of an objection being raised in a pull request by another committer, all involved
committers should seek to arrive at a consensus by way of addressing concerns being expressed
by discussion, compromise on the proposed change, or withdrawal of the proposed change.

If a contribution is controversial and committers cannot agree about how to get it to land
or if it should land then it should be escalated to the TC. TC members should regularly
discuss pending contributions in order to find a resolution. It is expected that only a
small minority of issues be brought to the TC for resolution and that discussion and
compromise among committers be the default resolution mechanism.

Becoming a Triager

Anyone can become a triager! Read more about the process of being a triager in
the triage process document.

Currently, any existing organization member can nominate
a new triager. If you are interested in becoming a triager, our best advice is to actively participate
in the community by helping triaging issues and pull requests. As well we recommend
to engage in other community activities like attending the TC meetings, and participating in the Slack
discussions. If you feel ready and have been helping triage some issues, reach out to an active member of the organization to ask if they’d
be willing to support you. If they agree, they can create a pull request to formalize your nomination. In the case of an objection to the nomination, the triage team is responsible for working with the individuals involved and finding a resolution.

You can also reach out to any of the organization members
if you have questions or need guidance.

Becoming a Committer

All contributors who have landed significant and valuable contributions should be onboarded in a timely manner,
and added as a committer, and be given write access to the repository.

Committers are expected to follow this policy and continue to send pull requests, go through
proper review, and have other committers merge their pull requests.

TC Process

The TC uses a “consensus seeking” process for issues that are escalated to the TC.
The group tries to find a resolution that has no open objections among TC members.
If a consensus cannot be reached that has no objections then a majority wins vote
is called. It is also expected that the majority of decisions made by the TC are via
a consensus seeking process and that voting is only used as a last-resort.

Resolution may involve returning the issue to project captains with suggestions on
how to move forward towards a consensus. It is not expected that a meeting of the TC
will resolve all issues on its agenda during that meeting and may prefer to continue
the discussion happening among the project captains.

Members can be added to the TC at any time. Any TC member can nominate another committer
to the TC and the TC uses its standard consensus seeking process to evaluate whether or
not to add this new member. The TC will consist of a minimum of 3 active members and a
maximum of 10. If the TC should drop below 5 members the active TC members should nominate
someone new. If a TC member is stepping down, they are encouraged (but not required) to
nominate someone to take their place.

TC members will be added as admin’s on the Github orgs, npm orgs, and other resources as
necessary to be effective in the role.

To remain “active” a TC member should have participation within the last 12 months and miss
no more than six consecutive TC meetings. Our goal is to increase participation, not punish
people for any lack of participation, this guideline should be only be used as such
(replace an inactive member with a new active one, for example). Members who do not meet this
are expected to step down. If A TC member does not step down, an issue can be opened in the
discussions repo to move them to inactive status. TC members who step down or are removed due
to inactivity will be moved into inactive status.

Inactive status members can become active members by self nomination if the TC is not already
larger than the maximum of 10. They will also be given preference if, while at max size, an
active member steps down.

Project Captains

The Express TC can designate captains for individual projects/repos in the
organizations. These captains are responsible for being the primary
day-to-day maintainers of the repo on a technical and community front.
Repo captains are empowered with repo ownership and package publication rights.
When there are conflicts, especially on topics that effect the Express project
at large, captains are responsible to raise it up to the TC and drive
those conflicts to resolution. Captains are also responsible for making sure
community members follow the community guidelines, maintaining the repo
and the published package, as well as in providing user support.

Like TC members, Repo captains are a subset of committers.

To become a captain for a project the candidate is expected to participate in that
project for at least 6 months as a committer prior to the request. They should have
helped with code contributions as well as triaging issues. They are also required to
have 2FA enabled on both their GitHub and npm accounts.

Any TC member or an existing captain on the same repo can nominate another committer 
to the captain role. To do so, they should submit a PR to this document, updating the 
Active Project Captains section (while maintaining the sort order) with the project 
name, the nominee’s GitHub handle, and their npm username (if different).

  Repos can have as many captains as make sense for the scope of work.
  A TC member or an existing repo captain on the same project can nominate a new captain. 
Repo captains from other projects should not nominate captains for a different project.


The PR will require at least 2 approvals from TC members and 2 weeks hold time to allow 
for comment and/or dissent.  When the PR is merged, a TC member will add them to the 
proper GitHub/npm groups.

Active Projects and Captains


  expressjs/badgeboard: @wesleytodd
  expressjs/basic-auth-connect: @ulisesGascon
  expressjs/body-parser: @wesleytodd, @jonchurch, @ulisesGascon
  expressjs/compression: @ulisesGascon
  expressjs/connect-multiparty: @ulisesGascon
  expressjs/cookie-parser: @wesleytodd, @UlisesGascon
  expressjs/cookie-session: @ulisesGascon
  expressjs/cors: @jonchurch, @ulisesGascon
  expressjs/discussions: @wesleytodd
  expressjs/errorhandler: @ulisesGascon
  expressjs/express-paginate: @ulisesGascon
  expressjs/express: @wesleytodd, @ulisesGascon
  expressjs/expressjs.com: @crandmck, @jonchurch, @bjohansebas
  expressjs/flash: @ulisesGascon
  expressjs/generator: @wesleytodd
  expressjs/method-override: @ulisesGascon
  expressjs/morgan: @jonchurch, @ulisesGascon
  expressjs/multer: @LinusU, @ulisesGascon
  expressjs/response-time: @UlisesGascon
  expressjs/serve-favicon: @ulisesGascon
  expressjs/serve-index: @ulisesGascon
  expressjs/serve-static: @ulisesGascon
  expressjs/session: @ulisesGascon
  expressjs/statusboard: @wesleytodd
  expressjs/timeout: @ulisesGascon
  expressjs/vhost: @ulisesGascon
  jshttp/accepts: @blakeembrey
  jshttp/basic-auth: @blakeembrey
  jshttp/compressible: @blakeembrey
  jshttp/content-disposition: @blakeembrey
  jshttp/content-type: @blakeembrey
  jshttp/cookie: @blakeembrey
  jshttp/etag: @blakeembrey
  jshttp/forwarded: @blakeembrey
  jshttp/fresh: @blakeembrey
  jshttp/http-assert: @wesleytodd, @jonchurch, @ulisesGascon
  jshttp/http-errors: @wesleytodd, @jonchurch, @ulisesGascon
  jshttp/media-typer: @blakeembrey
  jshttp/methods: @blakeembrey
  jshttp/mime-db: @blakeembrey, @UlisesGascon
  jshttp/mime-types: @blakeembrey, @UlisesGascon
  jshttp/negotiator: @blakeembrey
  jshttp/on-finished: @wesleytodd, @ulisesGascon
  jshttp/on-headers: @blakeembrey
  jshttp/proxy-addr: @wesleytodd, @ulisesGascon
  jshttp/range-parser: @blakeembrey
  jshttp/statuses: @blakeembrey
  jshttp/type-is: @blakeembrey
  jshttp/vary: @blakeembrey
  pillarjs/cookies: @blakeembrey
  pillarjs/csrf: @ulisesGascon
  pillarjs/encodeurl: @blakeembrey
  pillarjs/finalhandler: @wesleytodd, @ulisesGascon
  pillarjs/hbs: @ulisesGascon
  pillarjs/multiparty: @blakeembrey
  pillarjs/parseurl: @blakeembrey
  pillarjs/path-to-regexp: @blakeembrey
  pillarjs/request: @wesleytodd
  pillarjs/resolve-path: @blakeembrey
  pillarjs/router: @wesleytodd, @ulisesGascon
  pillarjs/send: @blakeembrey
  pillarjs/understanding-csrf: @ulisesGascon


Current Initiative Captains


  Triage team ref: @UlisesGascon


Developer’s Certificate of Origin 1.1

By making a contribution to this project, I certify that:

 (a) The contribution was created in whole or in part by me and I
     have the right to submit it under the open source license
     indicated in the file; or

 (b) The contribution is based upon previous work that, to the best
     of my knowledge, is covered under an appropriate open source
     license and I have the right under that license to submit that
     work with modifications, whether created in whole or in part
     by me, under the same open source license (unless I am
     permitted to submit under a different license), as indicated
     in the file; or

 (c) The contribution was provided directly to me by some other
     person who certified (a), (b) or (c) and I have not modified
     it.

 (d) I understand and agree that this project and the contribution
     are public and that a record of the contribution (including all
     personal information I submit with it, including my sign-off) is
     maintained indefinitely and may be redistributed consistent with
     this project or the open source license(s) involved.


Collaborator’s guide



Website Issues

Open issues for the expressjs.com website in https://github.com/expressjs/expressjs.com.

PRs and Code contributions


  Tests must pass.
  Follow the JavaScript Standard Style and npm run lint.
  If you fix a bug, add a test.


Branches

Use the master branch for bug fixes or minor work that is intended for the
current release stream.

Use the correspondingly named branch, e.g. 5.0, for anything intended for
a future release of Express.

Steps for contributing


  Create an issue for the
bug you want to fix or the feature that you want to add.
  Create your own fork on GitHub, then
checkout your fork.
  Write your code in your local copy. It’s good practice to create a branch for
each new issue you work on, although not compulsory.
  To run the test suite, first install the dependencies by running npm install,
then run npm test.
  Ensure your code is linted by running npm run lint – fix any issue you
see listed.
  If the tests pass, you can commit your changes to your fork and then create
a pull request from there. Make sure to reference your issue from the pull
request comments by including the issue number e.g. #123.


Issues which are questions

We will typically close any vague issues or questions that are specific to some
app you are writing. Please double check the docs and other references before
being trigger happy with posting a question issue.

Things that will help get your question issue looked at:


  Full and runnable JS code.
  Clear description of the problem or unexpected behavior.
  Clear description of the expected result.
  Steps you have taken to debug it yourself.


If you post a question and do not outline the above items or make it easy for
us to understand and reproduce your issue, it will be closed.

Security Policies and Procedures



This document outlines security procedures and general policies for the Express
project.


  Reporting a Bug
  Disclosure Policy
  Comments on this Policy


Reporting a Bug

The Express team and community take all security bugs in Express seriously.
Thank you for improving the security of Express. We appreciate your efforts and
responsible disclosure and will make every effort to acknowledge your
contributions.

Report security bugs by emailing [email protected].

To ensure the timely response to your report, please ensure that the entirety
of the report is contained within the email body and not solely behind a web
link or an attachment.

The lead maintainer will acknowledge your email within 48 hours, and will send a
more detailed response within 48 hours indicating the next steps in handling
your report. After the initial reply to your report, the security team will
endeavor to keep you informed of the progress towards a fix and full
announcement, and may ask for additional information or guidance.

Report security bugs in third-party modules to the person or team maintaining
the module.

Pre-release Versions

Alpha and Beta releases are unstable and not suitable for production use.
Vulnerabilities found in pre-releases should be reported according to the Reporting a Bug section.
Due to the unstable nature of the branch it is not guaranteed that any fixes will be released in the next pre-release.

Disclosure Policy

When the security team receives a security bug report, they will assign it to a
primary handler. This person will coordinate the fix and release process,
involving the following steps:


  Confirm the problem and determine the affected versions.
  Audit code to find any potential similar problems.
  Prepare fixes for all releases still under maintenance. These fixes will be
released as fast as possible to npm.


The Express Threat Model

We are currently working on a new version of the security model, the most updated version can be found here

Comments on this Policy

If you have suggestions on how this process could be improved please submit a
pull request.


Contributing to Expressjs.com


The Official Documentation of the Express JS Framework

This is the contribution documentation for the Expressjs.com website.

Need some ideas? These are some typical issues.


  
    Website issues: 
If you see anything on the site that could use a tune-up, think about how to fix it.

    
      Display or screen sizing problems
      Mobile responsiveness issues
      Missing or broken accessibility features
      Website outages
      Broken links
      Page structure or user interface enhancements
    
  
  Content Issues: 
Fix anything related to site content or typos.
    
      Spelling errors
      Incorrect/outdated Express JS documentation
      Missing content
    
  
  Translation Issues: Fix any translation errors or contribute new content.
    
      Fix spelling errors
      Fix incorrect/poorly translated words
      Translate new content
        
          IMPORTANT: 
All translation submissions are currently paused. See this notice for more information.
        
      
      Check out the Contributing translations section below for a contributing guide.
    
  


Want to work on a backlog issue?

We often have bugs or enhancements that need work. You can find these under our repo’s Issues tab. Check out the tags to find something that’s a good match for you.

Have an idea? Found a bug?

If you’ve found a bug or a typo, or if you have an idea for an enhancement, you can:

  Submit a new issue on our repo. Do this for larger proposals, or if you’d like to discuss or get feedback first.
  Make a Github pull request. If you have already done work and it’s ready to go, feel free to send it our way.


Getting Started

The steps below will guide you through the Expressjs.com contribution process.

Step 1: (OPTIONAL) Open a New Issue
So you’ve found a problem that you want to fix, or have a site enhancement you want to make.

  If you want to get feedback or discuss, open a discussion issue prior to starting work. This is not required, but encouraged for larger proposals.
    
      While we highly encourage this step, it is only for submissions proposing significant change. It  helps us to clarify and focus the work, and ensure it aligns with overall project priorities.
      For submissions proposing minor improvements or corrections, this is not needed. You can skip this step.
      When opening an issue please give it a title and fill in the description section. The more details you provide, the more feedback we can give.
    
  
  After receiving your issue the Express JS documentation team will respond with feedback. We read every submission and always try to respond quickly with feedback.
    
      For submissions proposing significant change, we encourage you to follow the review process before starting work.
    
  


Step 2: Get the Application Code Base

Clone the repo and get the code:

git clone https://github.com/expressjs/expressjs.com.git


After you’ve got the code you’re ready to start making your changes!

But just in case you need a little extra explanation, this section below outlines the main sections of the code base, where most changes are likely to be made.

Markdown Page Files:

  These files render to html and make up the individual pages of the site. Most of the site’s documentation text content is written in md files.
  Change these to make changes to individual pages’ content/text or markup.
  Each language has its own complete set of pages, located under their respective language directories - all the Spanish markdown content is found in the es directory, for example.


Includes Partials and Layout Templates

  _includes are partials that are imported and reused across multiple pages.
    
      These are used to import text content for reuse across pages, such as the API documentation, e.g., _includes > api > en > 5x, which is included in every language.
      These are used to include the page components that make up site-wide user interface and periphery structure, e.g., Header, Footer, etc.
    
  
  _layouts are the templates used to wrap the site’s individual pages.
    
      These are used to display the structure of the site’s periphery, such as the header and footer, and for injecting and displaying individual markdown pages inside the content tag.
    
  


Blog Markdown Files

  These files make up the individual blog posts. If you want to contribute a blog post please
follow the specific instructions for How to write a blog post.
  Located under the _posts directory.


CSS or Javascript

  All css and js files are kept in css and js folders on the project root.


The Express JS website is build using Jeykyll and is hosted on Github Pages.

Step 3: Running the Application

Now you’ll need a way to see your changes, which means you’ll need a running version of the application. You have two options.

  Run Locally: This gets the local version of the application up and running on your machine. Follow our Local Setup Guide to use this option.
    
      This is the recommended option for moderate to complex work.
    
  
  Run using Deploy Preview: Use this option if you don’t want to bother with a local installation. Part of our continuous integration pipeline includes Netlify Deploy Preview.
    
      To use this you’ll need to get your changes online - after you’ve made your first commit on your feature branch, make a draft pull request.
      After the build steps are complete, you’ll have access to a Deploy Preview tab that will run your changes on the web, rebuilding after each commit is pushed.
      After you are completely done your work and it’s ready for review, remove the draft status on your pull request and submit your work.
    
  


Contributing translations

Notice: We have paused all translation contributions.

  IMPORTANT: 
We are currently working toward a more streamlined translations workflow. As long as this notice is posted, we will not be accepting any translation submissions.


We highly encourage community translations! We no longer have professional translations, and we believe in the power of our community to provide accurate and helpful translations.

The documentation is translated into these languages:

  English (en)
  Spanish (es)
  French (fr)
  Italian (it)
  Indonesian (id)
  Japanese (ja)
  Korean (ko)
  Brazilian Portuguese (pt-br)
  Russian (ru)
  Slovak (sk)
  Thai (th)
  Turkish (tr)
  Ukrainian (uk)
  Uzbek (uz)
  Simplified Chinese (zh-cn)
  Traditional Chinese (zh-tw)


Adding New Full Site Translations

If you find a translation is missing from the list you can create a new one.

To translate Expressjs.com into a new language, follow these steps:


  Clone the expressjs.com repository.
  Create a directory for the language of your choice using its ISO 639-1 code as its name.
  Copy index.md, api.md, starter/, guide/, advanced/, resources/, 4x/, and 3x/, to the language directory.
  Remove the link to 2.x docs from the “API Reference” menu.
  Update the lang variable in the copied markdown files.
  Update the title variable in the copied markdown files.
  Create the header, footer, notice, and announcement file for the language in the _includes/ directory, in the respective directories, and make necessary edits to the contents.
  Create the announcement file for the language in the _includes/ directory.
  Make sure to append /en to all the links within the site.
  Update the CONTRIBUTING.md  and the .github/workflows/translation.yml files with the new language.


Adding Page and Section Translations

Many site translations are still missing pages. To find which ones we need help with, you can filter for merged PRs that include the tag for your language, such as requires-translation-es for requires Spanish translation.

If you contribute a page or section translation, please reference the original PR. This helps the person merging your translation to remove the tag from the original PR.

              
    
    Edit this page\n\nContributing to Express

Looking to contribute to Expressjs.com? Click here.

Express and the other projects in the expressjs organization on GitHub are projects of the OpenJs Foundation.
These projects are governed under the general policies and guidelines of the Node.js Foundation along with the additional guidelines below.


  Technical committee
  Community contributing guide
  Collaborator’s guide
  Security policies and procedures


Technical committee

The Express technical committee consists of active project members, and guides development and maintenance of the Express project. For more information, see Express Community - Technical committee.

Community contributing guide



The goal of this document is to create a contribution process that:


  Encourages new contributions.
  Encourages contributors to remain involved.
  Avoids unnecessary processes and bureaucracy whenever possible.
  Creates a transparent decision making process that makes it clear how
contributors can be involved in decision making.


Vocabulary


  A Contributor is any individual creating or commenting on an issue or pull request.
  A Committer is a subset of contributors who have been given write access to the repository.
  A Project Captain is the lead maintainer of a repository.
  A TC (Technical Committee) is a group of committers representing the required technical
expertise to resolve rare disputes.
  A Triager is a subset of contributors who have been given triage access to the repository.


Logging Issues

Log an issue for any question or problem you might have. When in doubt, log an issue, and
any additional policies about what to include will be provided in the responses. The only
exception is security disclosures which should be sent privately.

Committers may direct you to another repository, ask for additional clarifications, and
add appropriate metadata before the issue is addressed.

Please be courteous and respectful. Every participant is expected to follow the
project’s Code of Conduct.

Contributions

Any change to resources in this repository must be through pull requests. This applies to all changes
to documentation, code, binary files, etc. Even long term committers and TC members must use
pull requests.

No pull request can be merged without being reviewed.

For non-trivial contributions, pull requests should sit for at least 36 hours to ensure that
contributors in other timezones have time to review. Consideration should also be given to
weekends and other holiday periods to ensure active committers all have reasonable time to
become involved in the discussion and review process if they wish.

The default for each contribution is that it is accepted once no committer has an objection.
During a review, committers may also request that a specific contributor who is most versed in a
particular area gives a “LGTM” before the PR can be merged. There is no additional “sign off”
process for contributions to land. Once all issues brought by committers are addressed it can
be landed by any committer.

In the case of an objection being raised in a pull request by another committer, all involved
committers should seek to arrive at a consensus by way of addressing concerns being expressed
by discussion, compromise on the proposed change, or withdrawal of the proposed change.

If a contribution is controversial and committers cannot agree about how to get it to land
or if it should land then it should be escalated to the TC. TC members should regularly
discuss pending contributions in order to find a resolution. It is expected that only a
small minority of issues be brought to the TC for resolution and that discussion and
compromise among committers be the default resolution mechanism.

Becoming a Triager

Anyone can become a triager! Read more about the process of being a triager in
the triage process document.

Currently, any existing organization member can nominate
a new triager. If you are interested in becoming a triager, our best advice is to actively participate
in the community by helping triaging issues and pull requests. As well we recommend
to engage in other community activities like attending the TC meetings, and participating in the Slack
discussions. If you feel ready and have been helping triage some issues, reach out to an active member of the organization to ask if they’d
be willing to support you. If they agree, they can create a pull request to formalize your nomination. In the case of an objection to the nomination, the triage team is responsible for working with the individuals involved and finding a resolution.

You can also reach out to any of the organization members
if you have questions or need guidance.

Becoming a Committer

All contributors who have landed significant and valuable contributions should be onboarded in a timely manner,
and added as a committer, and be given write access to the repository.

Committers are expected to follow this policy and continue to send pull requests, go through
proper review, and have other committers merge their pull requests.

TC Process

The TC uses a “consensus seeking” process for issues that are escalated to the TC.
The group tries to find a resolution that has no open objections among TC members.
If a consensus cannot be reached that has no objections then a majority wins vote
is called. It is also expected that the majority of decisions made by the TC are via
a consensus seeking process and that voting is only used as a last-resort.

Resolution may involve returning the issue to project captains with suggestions on
how to move forward towards a consensus. It is not expected that a meeting of the TC
will resolve all issues on its agenda during that meeting and may prefer to continue
the discussion happening among the project captains.

Members can be added to the TC at any time. Any TC member can nominate another committer
to the TC and the TC uses its standard consensus seeking process to evaluate whether or
not to add this new member. The TC will consist of a minimum of 3 active members and a
maximum of 10. If the TC should drop below 5 members the active TC members should nominate
someone new. If a TC member is stepping down, they are encouraged (but not required) to
nominate someone to take their place.

TC members will be added as admin’s on the Github orgs, npm orgs, and other resources as
necessary to be effective in the role.

To remain “active” a TC member should have participation within the last 12 months and miss
no more than six consecutive TC meetings. Our goal is to increase participation, not punish
people for any lack of participation, this guideline should be only be used as such
(replace an inactive member with a new active one, for example). Members who do not meet this
are expected to step down. If A TC member does not step down, an issue can be opened in the
discussions repo to move them to inactive status. TC members who step down or are removed due
to inactivity will be moved into inactive status.

Inactive status members can become active members by self nomination if the TC is not already
larger than the maximum of 10. They will also be given preference if, while at max size, an
active member steps down.

Project Captains

The Express TC can designate captains for individual projects/repos in the
organizations. These captains are responsible for being the primary
day-to-day maintainers of the repo on a technical and community front.
Repo captains are empowered with repo ownership and package publication rights.
When there are conflicts, especially on topics that effect the Express project
at large, captains are responsible to raise it up to the TC and drive
those conflicts to resolution. Captains are also responsible for making sure
community members follow the community guidelines, maintaining the repo
and the published package, as well as in providing user support.

Like TC members, Repo captains are a subset of committers.

To become a captain for a project the candidate is expected to participate in that
project for at least 6 months as a committer prior to the request. They should have
helped with code contributions as well as triaging issues. They are also required to
have 2FA enabled on both their GitHub and npm accounts.

Any TC member or an existing captain on the same repo can nominate another committer 
to the captain role. To do so, they should submit a PR to this document, updating the 
Active Project Captains section (while maintaining the sort order) with the project 
name, the nominee’s GitHub handle, and their npm username (if different).

  Repos can have as many captains as make sense for the scope of work.
  A TC member or an existing repo captain on the same project can nominate a new captain. 
Repo captains from other projects should not nominate captains for a different project.


The PR will require at least 2 approvals from TC members and 2 weeks hold time to allow 
for comment and/or dissent.  When the PR is merged, a TC member will add them to the 
proper GitHub/npm groups.

Active Projects and Captains


  expressjs/badgeboard: @wesleytodd
  expressjs/basic-auth-connect: @ulisesGascon
  expressjs/body-parser: @wesleytodd, @jonchurch, @ulisesGascon
  expressjs/compression: @ulisesGascon
  expressjs/connect-multiparty: @ulisesGascon
  expressjs/cookie-parser: @wesleytodd, @UlisesGascon
  expressjs/cookie-session: @ulisesGascon
  expressjs/cors: @jonchurch, @ulisesGascon
  expressjs/discussions: @wesleytodd
  expressjs/errorhandler: @ulisesGascon
  expressjs/express-paginate: @ulisesGascon
  expressjs/express: @wesleytodd, @ulisesGascon
  expressjs/expressjs.com: @crandmck, @jonchurch, @bjohansebas
  expressjs/flash: @ulisesGascon
  expressjs/generator: @wesleytodd
  expressjs/method-override: @ulisesGascon
  expressjs/morgan: @jonchurch, @ulisesGascon
  expressjs/multer: @LinusU, @ulisesGascon
  expressjs/response-time: @UlisesGascon
  expressjs/serve-favicon: @ulisesGascon
  expressjs/serve-index: @ulisesGascon
  expressjs/serve-static: @ulisesGascon
  expressjs/session: @ulisesGascon
  expressjs/statusboard: @wesleytodd
  expressjs/timeout: @ulisesGascon
  expressjs/vhost: @ulisesGascon
  jshttp/accepts: @blakeembrey
  jshttp/basic-auth: @blakeembrey
  jshttp/compressible: @blakeembrey
  jshttp/content-disposition: @blakeembrey
  jshttp/content-type: @blakeembrey
  jshttp/cookie: @blakeembrey
  jshttp/etag: @blakeembrey
  jshttp/forwarded: @blakeembrey
  jshttp/fresh: @blakeembrey
  jshttp/http-assert: @wesleytodd, @jonchurch, @ulisesGascon
  jshttp/http-errors: @wesleytodd, @jonchurch, @ulisesGascon
  jshttp/media-typer: @blakeembrey
  jshttp/methods: @blakeembrey
  jshttp/mime-db: @blakeembrey, @UlisesGascon
  jshttp/mime-types: @blakeembrey, @UlisesGascon
  jshttp/negotiator: @blakeembrey
  jshttp/on-finished: @wesleytodd, @ulisesGascon
  jshttp/on-headers: @blakeembrey
  jshttp/proxy-addr: @wesleytodd, @ulisesGascon
  jshttp/range-parser: @blakeembrey
  jshttp/statuses: @blakeembrey
  jshttp/type-is: @blakeembrey
  jshttp/vary: @blakeembrey
  pillarjs/cookies: @blakeembrey
  pillarjs/csrf: @ulisesGascon
  pillarjs/encodeurl: @blakeembrey
  pillarjs/finalhandler: @wesleytodd, @ulisesGascon
  pillarjs/hbs: @ulisesGascon
  pillarjs/multiparty: @blakeembrey
  pillarjs/parseurl: @blakeembrey
  pillarjs/path-to-regexp: @blakeembrey
  pillarjs/request: @wesleytodd
  pillarjs/resolve-path: @blakeembrey
  pillarjs/router: @wesleytodd, @ulisesGascon
  pillarjs/send: @blakeembrey
  pillarjs/understanding-csrf: @ulisesGascon


Current Initiative Captains


  Triage team ref: @UlisesGascon


Developer’s Certificate of Origin 1.1

By making a contribution to this project, I certify that:

 (a) The contribution was created in whole or in part by me and I
     have the right to submit it under the open source license
     indicated in the file; or

 (b) The contribution is based upon previous work that, to the best
     of my knowledge, is covered under an appropriate open source
     license and I have the right under that license to submit that
     work with modifications, whether created in whole or in part
     by me, under the same open source license (unless I am
     permitted to submit under a different license), as indicated
     in the file; or

 (c) The contribution was provided directly to me by some other
     person who certified (a), (b) or (c) and I have not modified
     it.

 (d) I understand and agree that this project and the contribution
     are public and that a record of the contribution (including all
     personal information I submit with it, including my sign-off) is
     maintained indefinitely and may be redistributed consistent with
     this project or the open source license(s) involved.


Collaborator’s guide



Website Issues

Open issues for the expressjs.com website in https://github.com/expressjs/expressjs.com.

PRs and Code contributions


  Tests must pass.
  Follow the JavaScript Standard Style and npm run lint.
  If you fix a bug, add a test.


Branches

Use the master branch for bug fixes or minor work that is intended for the
current release stream.

Use the correspondingly named branch, e.g. 5.0, for anything intended for
a future release of Express.

Steps for contributing


  Create an issue for the
bug you want to fix or the feature that you want to add.
  Create your own fork on GitHub, then
checkout your fork.
  Write your code in your local copy. It’s good practice to create a branch for
each new issue you work on, although not compulsory.
  To run the test suite, first install the dependencies by running npm install,
then run npm test.
  Ensure your code is linted by running npm run lint – fix any issue you
see listed.
  If the tests pass, you can commit your changes to your fork and then create
a pull request from there. Make sure to reference your issue from the pull
request comments by including the issue number e.g. #123.


Issues which are questions

We will typically close any vague issues or questions that are specific to some
app you are writing. Please double check the docs and other references before
being trigger happy with posting a question issue.

Things that will help get your question issue looked at:


  Full and runnable JS code.
  Clear description of the problem or unexpected behavior.
  Clear description of the expected result.
  Steps you have taken to debug it yourself.


If you post a question and do not outline the above items or make it easy for
us to understand and reproduce your issue, it will be closed.

Security Policies and Procedures



This document outlines security procedures and general policies for the Express
project.


  Reporting a Bug
  Disclosure Policy
  Comments on this Policy


Reporting a Bug

The Express team and community take all security bugs in Express seriously.
Thank you for improving the security of Express. We appreciate your efforts and
responsible disclosure and will make every effort to acknowledge your
contributions.

Report security bugs by emailing [email protected].

To ensure the timely response to your report, please ensure that the entirety
of the report is contained within the email body and not solely behind a web
link or an attachment.

The lead maintainer will acknowledge your email within 48 hours, and will send a
more detailed response within 48 hours indicating the next steps in handling
your report. After the initial reply to your report, the security team will
endeavor to keep you informed of the progress towards a fix and full
announcement, and may ask for additional information or guidance.

Report security bugs in third-party modules to the person or team maintaining
the module.

Pre-release Versions

Alpha and Beta releases are unstable and not suitable for production use.
Vulnerabilities found in pre-releases should be reported according to the Reporting a Bug section.
Due to the unstable nature of the branch it is not guaranteed that any fixes will be released in the next pre-release.

Disclosure Policy

When the security team receives a security bug report, they will assign it to a
primary handler. This person will coordinate the fix and release process,
involving the following steps:


  Confirm the problem and determine the affected versions.
  Audit code to find any potential similar problems.
  Prepare fixes for all releases still under maintenance. These fixes will be
released as fast as possible to npm.


The Express Threat Model

We are currently working on a new version of the security model, the most updated version can be found here

Comments on this Policy

If you have suggestions on how this process could be improved please submit a
pull request.


Contributing to Expressjs.com


The Official Documentation of the Express JS Framework

This is the contribution documentation for the Expressjs.com website.

Need some ideas? These are some typical issues.


  
    Website issues: 
If you see anything on the site that could use a tune-up, think about how to fix it.

    
      Display or screen sizing problems
      Mobile responsiveness issues
      Missing or broken accessibility features
      Website outages
      Broken links
      Page structure or user interface enhancements
    
  
  Content Issues: 
Fix anything related to site content or typos.
    
      Spelling errors
      Incorrect/outdated Express JS documentation
      Missing content
    
  
  Translation Issues: Fix any translation errors or contribute new content.
    
      Fix spelling errors
      Fix incorrect/poorly translated words
      Translate new content
        
          IMPORTANT: 
All translation submissions are currently paused. See this notice for more information.
        
      
      Check out the Contributing translations section below for a contributing guide.
    
  


Want to work on a backlog issue?

We often have bugs or enhancements that need work. You can find these under our repo’s Issues tab. Check out the tags to find something that’s a good match for you.

Have an idea? Found a bug?

If you’ve found a bug or a typo, or if you have an idea for an enhancement, you can:

  Submit a new issue on our repo. Do this for larger proposals, or if you’d like to discuss or get feedback first.
  Make a Github pull request. If you have already done work and it’s ready to go, feel free to send it our way.


Getting Started

The steps below will guide you through the Expressjs.com contribution process.

Step 1: (OPTIONAL) Open a New Issue
So you’ve found a problem that you want to fix, or have a site enhancement you want to make.

  If you want to get feedback or discuss, open a discussion issue prior to starting work. This is not required, but encouraged for larger proposals.
    
      While we highly encourage this step, it is only for submissions proposing significant change. It  helps us to clarify and focus the work, and ensure it aligns with overall project priorities.
      For submissions proposing minor improvements or corrections, this is not needed. You can skip this step.
      When opening an issue please give it a title and fill in the description section. The more details you provide, the more feedback we can give.
    
  
  After receiving your issue the Express JS documentation team will respond with feedback. We read every submission and always try to respond quickly with feedback.
    
      For submissions proposing significant change, we encourage you to follow the review process before starting work.
    
  


Step 2: Get the Application Code Base

Clone the repo and get the code:

git clone https://github.com/expressjs/expressjs.com.git


After you’ve got the code you’re ready to start making your changes!

But just in case you need a little extra explanation, this section below outlines the main sections of the code base, where most changes are likely to be made.

Markdown Page Files:

  These files render to html and make up the individual pages of the site. Most of the site’s documentation text content is written in md files.
  Change these to make changes to individual pages’ content/text or markup.
  Each language has its own complete set of pages, located under their respective language directories - all the Spanish markdown content is found in the es directory, for example.


Includes Partials and Layout Templates

  _includes are partials that are imported and reused across multiple pages.
    
      These are used to import text content for reuse across pages, such as the API documentation, e.g., _includes > api > en > 5x, which is included in every language.
      These are used to include the page components that make up site-wide user interface and periphery structure, e.g., Header, Footer, etc.
    
  
  _layouts are the templates used to wrap the site’s individual pages.
    
      These are used to display the structure of the site’s periphery, such as the header and footer, and for injecting and displaying individual markdown pages inside the content tag.
    
  


Blog Markdown Files

  These files make up the individual blog posts. If you want to contribute a blog post please
follow the specific instructions for How to write a blog post.
  Located under the _posts directory.


CSS or Javascript

  All css and js files are kept in css and js folders on the project root.


The Express JS website is build using Jeykyll and is hosted on Github Pages.

Step 3: Running the Application

Now you’ll need a way to see your changes, which means you’ll need a running version of the application. You have two options.

  Run Locally: This gets the local version of the application up and running on your machine. Follow our Local Setup Guide to use this option.
    
      This is the recommended option for moderate to complex work.
    
  
  Run using Deploy Preview: Use this option if you don’t want to bother with a local installation. Part of our continuous integration pipeline includes Netlify Deploy Preview.
    
      To use this you’ll need to get your changes online - after you’ve made your first commit on your feature branch, make a draft pull request.
      After the build steps are complete, you’ll have access to a Deploy Preview tab that will run your changes on the web, rebuilding after each commit is pushed.
      After you are completely done your work and it’s ready for review, remove the draft status on your pull request and submit your work.
    
  


Contributing translations

Notice: We have paused all translation contributions.

  IMPORTANT: 
We are currently working toward a more streamlined translations workflow. As long as this notice is posted, we will not be accepting any translation submissions.


We highly encourage community translations! We no longer have professional translations, and we believe in the power of our community to provide accurate and helpful translations.

The documentation is translated into these languages:

  English (en)
  Spanish (es)
  French (fr)
  Italian (it)
  Indonesian (id)
  Japanese (ja)
  Korean (ko)
  Brazilian Portuguese (pt-br)
  Russian (ru)
  Slovak (sk)
  Thai (th)
  Turkish (tr)
  Ukrainian (uk)
  Uzbek (uz)
  Simplified Chinese (zh-cn)
  Traditional Chinese (zh-tw)


Adding New Full Site Translations

If you find a translation is missing from the list you can create a new one.

To translate Expressjs.com into a new language, follow these steps:


  Clone the expressjs.com repository.
  Create a directory for the language of your choice using its ISO 639-1 code as its name.
  Copy index.md, api.md, starter/, guide/, advanced/, resources/, 4x/, and 3x/, to the language directory.
  Remove the link to 2.x docs from the “API Reference” menu.
  Update the lang variable in the copied markdown files.
  Update the title variable in the copied markdown files.
  Create the header, footer, notice, and announcement file for the language in the _includes/ directory, in the respective directories, and make necessary edits to the contents.
  Create the announcement file for the language in the _includes/ directory.
  Make sure to append /en to all the links within the site.
  Update the CONTRIBUTING.md  and the .github/workflows/translation.yml files with the new language.


Adding Page and Section Translations

Many site translations are still missing pages. To find which ones we need help with, you can filter for merged PRs that include the tag for your language, such as requires-translation-es for requires Spanish translation.

If you contribute a page or section translation, please reference the original PR. This helps the person merging your translation to remove the tag from the original PR.

              
    
    Edit this page\n\n\n\nVersions
    Versions ►
    
      
      
        
  5.x
  4.x


      
    
  




  Release changelog

  All the latest updates, improvements, and fixes to Express

  Express v5

  5.1.0 - Release date: 2025-03-31

  The 5.1.0 minor release includes some new features and improvements:

  
    Support for sending responses as Uint8Array
    Added support for ETag option in res.sendFile()
    Added support for adding multiple links with the same rel with res.links()
    Performance: Use loop for acceptParams
    [email protected]
      
        Remove legacy node.js support checks for Brotli & AsyncLocalStorage
        Remove unpipe & destroy
      
    
    [email protected]
      
        Restore debug. Now with the router scope instead of express.
        Remove legacy node.js support checks for setImmediate
        Deprecate non-native promise support
        Remove after, safe-buffer, array-flatten, setprotoypeof, methods, utils-merge
      
    
    [email protected]
      
        Remove legacy node.js support checks for headersSent, setImmediate, & http2 support
        Remove unpipe
      
    
    Transitioned all remaining dependencies to use ^ ranges instead of locked versions
    Add package.json funding field to highlight our OpenCollective
    See Changelog v5.1.0
      5.0.1 - Release date: 2024-10-08
    
  

  The 5.0.1 patch release includes one security fix:

  
    Update jshttps/cookie to address a vulnerability.
  

  5.0.0 - Release date: 2024-09-09

  Check the migration guide with all the changes in this new version of Express.

  Express v4

  4.21.2 - Release date: 2024-11-06

  The 4.21.2 patch release includes one security fix:

  
    Update pillajs/path-to-regexp to address a vulnerability.
  

  4.21.1 - Release date: 2024-10-08

  The 4.21.1 patch release includes one security fix:

  
    Update jshttps/cookie to address a vulnerability.
  

  4.21.0 - Release date: 2024-09-11

  The 4.21.0 minor release includes one new feature:

  
    Deprecate res.location("back") and res.redirect("back") magic string
  

  4.20.0 - Release date: 2024-09-10

  The 4.20.0 minor release includes bug fixes and some new features, including:

  
    The res.clearCookie() method deprecates options.maxAge and options.expires options.
    The res.redirect() method removes HTML link rendering.
    The express.urlencoded() method method now has a depth level of 32, whereas it was previously Infinity.
    Adds support for named matching groups in the routes using a regex
    Removes encoding of \, |, and ^ to align better with URL spec
  

  For a complete list of changes in this release, see History.md

  4.19.2 - Release date: 2024-03-25

  
    Improved fix for open redirect allow list bypass
  

  For a complete list of changes in this release, see History.md

  4.19.1 - Release date: 2024-03-20

  
    Allow passing non-strings to res.location with new encoding handling checks
  

  For a complete list of changes in this release, see History.md

  4.19.0 - Release date: 2024-03-20

  
    Prevent open redirect allow list bypass due to encodeurl
    deps: [email protected]
  

  For a complete list of changes in this release, see History.md

  4.18.3 - Release date: 2024-02-29

  The 4.18.3 patch release includes the following bug fix:

  
  
      Fix routing requests without method. (commit)
    


  For a complete list of changes in this release, see History.md

  4.18.2 - Release date: 2022-10-08

  The 4.18.2 patch release includes the following bug fix:

  
  
      Fix regression routing a large stack in a single route. (commit)
    


  For a complete list of changes in this release, see History.md

  4.18.1 - Release date: 2022-04-29

  The 4.18.1 patch release includes the following bug fix:

  
  
      Fix the condition where if an Express application is created with a very large stack of routes, and all of those routes are sync (call next() synchronously), then the request processing may hang.
    


  For a complete list of changes in this release, see History.md.

  4.18.0 - Release date: 2022-04-25

  The 4.18.0 minor release includes bug fixes and some new features, including:

  
  
      The app.get() method and the app.set() method now ignores properties directly on Object.prototype when getting a setting value.
    

  
      The res.cookie() method now accepts a “priority” option to set the Priority attribute on the Set-Cookie response header.
    

  
      The res.cookie() method now rejects an Invalid Date object provided as the “expires” option.
    

  
      The res.cookie() method now works when null or undefined is explicitly provided as the “maxAge” argument.
    

  
      Starting with this version, Express supports Node.js 18.x.
    

  
      The res.download() method now accepts a “root” option to match res.sendFile().
    

  
      The res.download() method can be supplied with an options object without providing a filename argument, simplifying calls when the default filename is desired.
    

  
      The res.format() method now invokes the provided “default” handler with the same arguments as the type handlers (req, res, and next).
    

  
      The res.send() method will not attempt to send a response body when the response code is set to 205.
    

  
      The default error handler will now remove certain response headers that will break the error response rendering, if they were set previously.
    

  
      The status code 425 is now represented as the standard “Too Early” instead of “Unordered Collection”.
    


  For a complete list of changes in this release, see History.md.

  4.17.3 - Release date: 2022-02-16

  The 4.17.3 patch release includes one bug fix:

  
  
      Update to qs module for a fix around parsing __proto__ properties.
    


  For a complete list of changes in this release, see History.md.

  4.17.2 - Release date: 2021-12-16

  The 4.17.2 patch release includes the following bug fixes:

  
  
      Fix handling of undefined in res.jsonp when a callback is provided.
    

  
      Fix handling of undefined in res.json and res.jsonp when "json escape" is enabled.
    

  
      Fix handling of invalid values to the maxAge option of res.cookie().
    

  
      Update to jshttp/proxy-addr module to use req.socket over deprecated req.connection.
    

  
      Starting with this version, Express supports Node.js 14.x.
    



  For a complete list of changes in this release, see History.md.

  4.17.1 - Release date: 2019-05-25

  The 4.17.1 patch release includes one bug fix:

  
  
      The change to the res.status() API has been reverted due to causing regressions in existing Express 4 applications.
    


  For a complete list of changes in this release, see History.md.

  4.17.0 - Release date: 2019-05-16

  The 4.17.0 minor release includes bug fixes and some new features, including:

  
  
      The express.raw() and express.text() middleware have been added to provide request body parsing for more raw request payloads. This uses the expressjs/body-parser module module underneath, so apps that are currently requiring the module separately can switch to the built-in parsers.
    

  
      The res.cookie() API now supports the "none" value for the sameSite option.
    

  
      When the "trust proxy" setting is enabled, the req.hostname now supports multiple X-Forwarded-For headers in a request.
    

  
      Starting with this version, Express supports Node.js 10.x and 12.x.
    

  
      The res.sendFile() API now provides and more immediate and easier to understand error when a non-string is passed as the path argument.
    

  
      The res.status() API now provides and more immediate and easier to understand error when null or undefined is passed as the argument.
    


  For a complete list of changes in this release, see History.md.

  4.16.4 - Release date: 2018-10-10

  The 4.16.4 patch release includes various bug fixes:

  
  
      Fix issue where "Request aborted" may be logged in res.sendfile.
    


  For a complete list of changes in this release, see History.md.

  4.16.3 - Release date: 2018-03-12

  The 4.16.3 patch release includes various bug fixes:

  
  
      Fix issue where a plain % at the end of the url in the res.location method or the res.redirect method would not get encoded as %25.
    

  
      Fix issue where a blank req.url value can result in a thrown error within the default 404 handling.
    

  
      Fix the generated HTML document for express.static redirect responses to properly include </html>.
    


  For a complete list of changes in this release, see History.md.

  4.16.2 - Release date: 2017-10-09

  The 4.16.2 patch release includes a regression bug fix:

  
  
      Fix a TypeError that can occur in the res.send method when a Buffer is passed to res.send and the ETag header is already set on the response.
    


  For a complete list of changes in this release, see History.md.

  4.16.1 - Release date: 2017-09-29

  The 4.16.1 patch release includes a regression bug fix:

  
  
      Update to pillarjs/send module to fix an edge case scenario regression that affected certain users of express.static.
    


  For a complete list of changes in this release, see History.md.

  4.16.0 - Release date: 2017-09-28

  The 4.16.0 minor release includes security updates, bug fixes, performance enhancements, and some new features, including:

  
  
      Update to jshttp/forwarded module to address a vulnerability. This may affect your application if the following APIs are used: req.host, req.hostname, req.ip, req.ips, req.protocol.
    

  
      Update a dependency of the pillarjs/send module to address a vulnerability in the mime dependency. This may affect your application if untrusted string input is passed to the following APIs: res.type().
    

  
      The pillarjs/send module has implemented a protection against the Node.js 8.5.0 vulnerability. Using any prior version of Express with Node.js 8.5.0 (that specific Node.js version) will make the following APIs vulnerable: express.static, res.sendfile, and res.sendFile.
    

  
      Starting with this version, Express supports Node.js 8.x.
    

  
      The new setting "json escape" can be enabled to escape characters in res.json(), res.jsonp() and res.send() responses that can trigger clients to sniff the response as HTML instead of honoring the Content-Type. This can help protect an Express app from a class of persistent XSS-based attacks.
    

  
      The res.download() method now accepts an optional options object.
    

  
      The express.json() and express.urlencoded() middleware have been added to provide request body parsing support out-of-the-box. This uses the expressjs/body-parser module module underneath, so apps that are currently requiring the module separately can switch to the built-in parsers.
    

  
      The express.static() middleware and res.sendFile() method now support setting the immutable directive on the Cache-Control header. Setting this header with an appropriate maxAge will prevent supporting web browsers from sending any request to the server when the file is still in their cache.
    

  
      The pillarjs/send module has an updated list of MIME types to better set the Content-Type of more files. There are 70 new types for file extensions.
    


  For a complete list of changes in this release, see History.md.

  4.15.5 - Release date: 2017-09-24

  The 4.15.5 patch release includes security updates, some minor performance enhancements, and a bug fix:

  
  
      Update to debug module to address a vulnerability, but this issue does not impact Express.
    

  
      Update to jshttp/fresh module to address a vulnerability. This will affect your application if the following APIs are used: express.static, req.fresh, res.json, res.jsonp, res.send, res.sendfile res.sendFile, res.sendStatus.
    

  
      Update to jshttp/fresh module fixes handling of modified headers with invalid dates and makes parsing conditional headers (like If-None-Match) faster.
    


  For a complete list of changes in this release, see History.md.

  4.15.4 - Release date: 2017-08-06

  The 4.15.4 patch release includes some minor bug fixes:

  
  
      Fix array being set for "trust proxy" value being manipulated in certain conditions.
    


  For a complete list of changes in this release, see History.md.

  4.15.3 - Release date: 2017-05-16

  The 4.15.3 patch release includes a security update and some minor bug fixes:

  
  
      Update a dependency of the pillarjs/send module to address a vulnerability. This may affect your application if untrusted string input is passed to the maxAge option in the following APIs: express.static, res.sendfile, and res.sendFile.
    

  
      Fix error when res.set cannot add charset to Content-Type.
    

  
      Fix missing </html> in HTML document.
    


  For a complete list of changes in this release, see History.md.

  4.15.2 - Release date: 2017-03-06

  The 4.15.2 patch release includes a minor bug fix:

  
  
      Fix regression parsing keys starting with [ in the extended  (default) query parser.
    


  For a complete list of changes in this release, see History.md.

  4.15.1 - Release date: 2017-03-05

  The 4.15.1 patch release includes a minor bug fix:

  
  
      Fix compatibility issue when using the datejs 1.x library where the express.static() middleware and res.sendFile() method would incorrectly respond with 412 Precondition Failed.
    


  For a complete list of changes in this release, see History.md.

  4.15.0 - Release date: 2017-03-01

  The 4.15.0 minor release includes bug fixes, performance improvements, and other minor feature additions, including:

  
  
      Starting with this version, Express supports Node.js 7.x.
    

  
      The express.static() middleware and res.sendFile() method now support the If-Match and If-Unmodified-Since request headers.
    

  
      Update to jshttp/etag module to generate the default ETags for responses which work when Node.js has FIPS-compliant crypto enabled.
    

  
      Various auto-generated HTML responses like the default not found and error handlers will respond with complete HTML 5 documents and additional security headers.
    


  For a complete list of changes in this release, see History.md.

  4.14.1 - Release date: 2017-01-28

  The 4.14.1 patch release includes bug fixes and performance improvements, including:

  
  
      Update to pillarjs/finalhandler module fixes an exception when Express handles an Error object which has a headers property that is not an object.
    


  For a complete list of changes in this release, see History.md.

  4.14.0 - Release date: 2016-06-16

  The 4.14.0 minor release includes bug fixes, security update, performance improvements, and other minor feature additions, including:

  
  
      Starting with this version, Express supports Node.js 6.x.
    

  
      Update to jshttp/negotiator module fixes a regular expression denial of service vulnerability.
    

  
      The res.sendFile() method now accepts two new options: acceptRanges and cacheControl.

      
        
          acceptRanges (defaut is true), enables or disables accepting ranged requests. When disabled, the response does not send the Accept-Ranges header and ignores the contents of the Range request header.
        
        
          cacheControl, (default is true), enables or disables the Cache-Control response header. Disabling it will ignore the maxAge option.
        
        
          res.sendFile has also been updated to handle Range header and redirections better.
        
      
    

  
      The res.location() method and res.redirect() method will now URL-encode the URL string, if it is not already encoded.
    

  
      The performance of the res.json() method and res.jsonp() method have been improved in the common cases.
    

  
      The jshttp/cookie module (in addition to a number of other improvements) has been updated and now the res.cookie() method supports the sameSite option to let you specify the SameSite cookie attribute.

      
         Note

        This attribute has not yet been fully standardized, may change in the future, and many clients may ignore it.
        

      

      The possible value for the sameSite option are:

      
        true, which sets the SameSite attribute to Strict for strict same site enforcement.
        false, which does not set the SameSite attribute.
        'lax', which sets the SameSite attribute to Lax for lax same site enforcement.
        'strict', which sets the SameSite attribute to Strict for strict same site enforcement.
      
    

  
      Absolute path checking on Windows, which was incorrect for some cases, has been fixed.
    

  
      IP address resolution with proxies has been greatly improved.
    

  
      The req.range() method options object now supports a combine option (false by default), which when true, combines overlapping and adjacent ranges and returns them as if they were specified that way in the header.
    


  For a complete list of changes in this release, see History.md.



              
    
    Edit this page\n\nVersions
    Versions ►
    
      
      
        
  5.x
  4.x


      
    
  




  Release changelog

  All the latest updates, improvements, and fixes to Express

  Express v5

  5.1.0 - Release date: 2025-03-31

  The 5.1.0 minor release includes some new features and improvements:

  
    Support for sending responses as Uint8Array
    Added support for ETag option in res.sendFile()
    Added support for adding multiple links with the same rel with res.links()
    Performance: Use loop for acceptParams
    [email protected]
      
        Remove legacy node.js support checks for Brotli & AsyncLocalStorage
        Remove unpipe & destroy
      
    
    [email protected]
      
        Restore debug. Now with the router scope instead of express.
        Remove legacy node.js support checks for setImmediate
        Deprecate non-native promise support
        Remove after, safe-buffer, array-flatten, setprotoypeof, methods, utils-merge
      
    
    [email protected]
      
        Remove legacy node.js support checks for headersSent, setImmediate, & http2 support
        Remove unpipe
      
    
    Transitioned all remaining dependencies to use ^ ranges instead of locked versions
    Add package.json funding field to highlight our OpenCollective
    See Changelog v5.1.0
      5.0.1 - Release date: 2024-10-08
    
  

  The 5.0.1 patch release includes one security fix:

  
    Update jshttps/cookie to address a vulnerability.
  

  5.0.0 - Release date: 2024-09-09

  Check the migration guide with all the changes in this new version of Express.

  Express v4

  4.21.2 - Release date: 2024-11-06

  The 4.21.2 patch release includes one security fix:

  
    Update pillajs/path-to-regexp to address a vulnerability.
  

  4.21.1 - Release date: 2024-10-08

  The 4.21.1 patch release includes one security fix:

  
    Update jshttps/cookie to address a vulnerability.
  

  4.21.0 - Release date: 2024-09-11

  The 4.21.0 minor release includes one new feature:

  
    Deprecate res.location("back") and res.redirect("back") magic string
  

  4.20.0 - Release date: 2024-09-10

  The 4.20.0 minor release includes bug fixes and some new features, including:

  
    The res.clearCookie() method deprecates options.maxAge and options.expires options.
    The res.redirect() method removes HTML link rendering.
    The express.urlencoded() method method now has a depth level of 32, whereas it was previously Infinity.
    Adds support for named matching groups in the routes using a regex
    Removes encoding of \, |, and ^ to align better with URL spec
  

  For a complete list of changes in this release, see History.md

  4.19.2 - Release date: 2024-03-25

  
    Improved fix for open redirect allow list bypass
  

  For a complete list of changes in this release, see History.md

  4.19.1 - Release date: 2024-03-20

  
    Allow passing non-strings to res.location with new encoding handling checks
  

  For a complete list of changes in this release, see History.md

  4.19.0 - Release date: 2024-03-20

  
    Prevent open redirect allow list bypass due to encodeurl
    deps: [email protected]
  

  For a complete list of changes in this release, see History.md

  4.18.3 - Release date: 2024-02-29

  The 4.18.3 patch release includes the following bug fix:

  
  
      Fix routing requests without method. (commit)
    


  For a complete list of changes in this release, see History.md

  4.18.2 - Release date: 2022-10-08

  The 4.18.2 patch release includes the following bug fix:

  
  
      Fix regression routing a large stack in a single route. (commit)
    


  For a complete list of changes in this release, see History.md

  4.18.1 - Release date: 2022-04-29

  The 4.18.1 patch release includes the following bug fix:

  
  
      Fix the condition where if an Express application is created with a very large stack of routes, and all of those routes are sync (call next() synchronously), then the request processing may hang.
    


  For a complete list of changes in this release, see History.md.

  4.18.0 - Release date: 2022-04-25

  The 4.18.0 minor release includes bug fixes and some new features, including:

  
  
      The app.get() method and the app.set() method now ignores properties directly on Object.prototype when getting a setting value.
    

  
      The res.cookie() method now accepts a “priority” option to set the Priority attribute on the Set-Cookie response header.
    

  
      The res.cookie() method now rejects an Invalid Date object provided as the “expires” option.
    

  
      The res.cookie() method now works when null or undefined is explicitly provided as the “maxAge” argument.
    

  
      Starting with this version, Express supports Node.js 18.x.
    

  
      The res.download() method now accepts a “root” option to match res.sendFile().
    

  
      The res.download() method can be supplied with an options object without providing a filename argument, simplifying calls when the default filename is desired.
    

  
      The res.format() method now invokes the provided “default” handler with the same arguments as the type handlers (req, res, and next).
    

  
      The res.send() method will not attempt to send a response body when the response code is set to 205.
    

  
      The default error handler will now remove certain response headers that will break the error response rendering, if they were set previously.
    

  
      The status code 425 is now represented as the standard “Too Early” instead of “Unordered Collection”.
    


  For a complete list of changes in this release, see History.md.

  4.17.3 - Release date: 2022-02-16

  The 4.17.3 patch release includes one bug fix:

  
  
      Update to qs module for a fix around parsing __proto__ properties.
    


  For a complete list of changes in this release, see History.md.

  4.17.2 - Release date: 2021-12-16

  The 4.17.2 patch release includes the following bug fixes:

  
  
      Fix handling of undefined in res.jsonp when a callback is provided.
    

  
      Fix handling of undefined in res.json and res.jsonp when "json escape" is enabled.
    

  
      Fix handling of invalid values to the maxAge option of res.cookie().
    

  
      Update to jshttp/proxy-addr module to use req.socket over deprecated req.connection.
    

  
      Starting with this version, Express supports Node.js 14.x.
    



  For a complete list of changes in this release, see History.md.

  4.17.1 - Release date: 2019-05-25

  The 4.17.1 patch release includes one bug fix:

  
  
      The change to the res.status() API has been reverted due to causing regressions in existing Express 4 applications.
    


  For a complete list of changes in this release, see History.md.

  4.17.0 - Release date: 2019-05-16

  The 4.17.0 minor release includes bug fixes and some new features, including:

  
  
      The express.raw() and express.text() middleware have been added to provide request body parsing for more raw request payloads. This uses the expressjs/body-parser module module underneath, so apps that are currently requiring the module separately can switch to the built-in parsers.
    

  
      The res.cookie() API now supports the "none" value for the sameSite option.
    

  
      When the "trust proxy" setting is enabled, the req.hostname now supports multiple X-Forwarded-For headers in a request.
    

  
      Starting with this version, Express supports Node.js 10.x and 12.x.
    

  
      The res.sendFile() API now provides and more immediate and easier to understand error when a non-string is passed as the path argument.
    

  
      The res.status() API now provides and more immediate and easier to understand error when null or undefined is passed as the argument.
    


  For a complete list of changes in this release, see History.md.

  4.16.4 - Release date: 2018-10-10

  The 4.16.4 patch release includes various bug fixes:

  
  
      Fix issue where "Request aborted" may be logged in res.sendfile.
    


  For a complete list of changes in this release, see History.md.

  4.16.3 - Release date: 2018-03-12

  The 4.16.3 patch release includes various bug fixes:

  
  
      Fix issue where a plain % at the end of the url in the res.location method or the res.redirect method would not get encoded as %25.
    

  
      Fix issue where a blank req.url value can result in a thrown error within the default 404 handling.
    

  
      Fix the generated HTML document for express.static redirect responses to properly include </html>.
    


  For a complete list of changes in this release, see History.md.

  4.16.2 - Release date: 2017-10-09

  The 4.16.2 patch release includes a regression bug fix:

  
  
      Fix a TypeError that can occur in the res.send method when a Buffer is passed to res.send and the ETag header is already set on the response.
    


  For a complete list of changes in this release, see History.md.

  4.16.1 - Release date: 2017-09-29

  The 4.16.1 patch release includes a regression bug fix:

  
  
      Update to pillarjs/send module to fix an edge case scenario regression that affected certain users of express.static.
    


  For a complete list of changes in this release, see History.md.

  4.16.0 - Release date: 2017-09-28

  The 4.16.0 minor release includes security updates, bug fixes, performance enhancements, and some new features, including:

  
  
      Update to jshttp/forwarded module to address a vulnerability. This may affect your application if the following APIs are used: req.host, req.hostname, req.ip, req.ips, req.protocol.
    

  
      Update a dependency of the pillarjs/send module to address a vulnerability in the mime dependency. This may affect your application if untrusted string input is passed to the following APIs: res.type().
    

  
      The pillarjs/send module has implemented a protection against the Node.js 8.5.0 vulnerability. Using any prior version of Express with Node.js 8.5.0 (that specific Node.js version) will make the following APIs vulnerable: express.static, res.sendfile, and res.sendFile.
    

  
      Starting with this version, Express supports Node.js 8.x.
    

  
      The new setting "json escape" can be enabled to escape characters in res.json(), res.jsonp() and res.send() responses that can trigger clients to sniff the response as HTML instead of honoring the Content-Type. This can help protect an Express app from a class of persistent XSS-based attacks.
    

  
      The res.download() method now accepts an optional options object.
    

  
      The express.json() and express.urlencoded() middleware have been added to provide request body parsing support out-of-the-box. This uses the expressjs/body-parser module module underneath, so apps that are currently requiring the module separately can switch to the built-in parsers.
    

  
      The express.static() middleware and res.sendFile() method now support setting the immutable directive on the Cache-Control header. Setting this header with an appropriate maxAge will prevent supporting web browsers from sending any request to the server when the file is still in their cache.
    

  
      The pillarjs/send module has an updated list of MIME types to better set the Content-Type of more files. There are 70 new types for file extensions.
    


  For a complete list of changes in this release, see History.md.

  4.15.5 - Release date: 2017-09-24

  The 4.15.5 patch release includes security updates, some minor performance enhancements, and a bug fix:

  
  
      Update to debug module to address a vulnerability, but this issue does not impact Express.
    

  
      Update to jshttp/fresh module to address a vulnerability. This will affect your application if the following APIs are used: express.static, req.fresh, res.json, res.jsonp, res.send, res.sendfile res.sendFile, res.sendStatus.
    

  
      Update to jshttp/fresh module fixes handling of modified headers with invalid dates and makes parsing conditional headers (like If-None-Match) faster.
    


  For a complete list of changes in this release, see History.md.

  4.15.4 - Release date: 2017-08-06

  The 4.15.4 patch release includes some minor bug fixes:

  
  
      Fix array being set for "trust proxy" value being manipulated in certain conditions.
    


  For a complete list of changes in this release, see History.md.

  4.15.3 - Release date: 2017-05-16

  The 4.15.3 patch release includes a security update and some minor bug fixes:

  
  
      Update a dependency of the pillarjs/send module to address a vulnerability. This may affect your application if untrusted string input is passed to the maxAge option in the following APIs: express.static, res.sendfile, and res.sendFile.
    

  
      Fix error when res.set cannot add charset to Content-Type.
    

  
      Fix missing </html> in HTML document.
    


  For a complete list of changes in this release, see History.md.

  4.15.2 - Release date: 2017-03-06

  The 4.15.2 patch release includes a minor bug fix:

  
  
      Fix regression parsing keys starting with [ in the extended  (default) query parser.
    


  For a complete list of changes in this release, see History.md.

  4.15.1 - Release date: 2017-03-05

  The 4.15.1 patch release includes a minor bug fix:

  
  
      Fix compatibility issue when using the datejs 1.x library where the express.static() middleware and res.sendFile() method would incorrectly respond with 412 Precondition Failed.
    


  For a complete list of changes in this release, see History.md.

  4.15.0 - Release date: 2017-03-01

  The 4.15.0 minor release includes bug fixes, performance improvements, and other minor feature additions, including:

  
  
      Starting with this version, Express supports Node.js 7.x.
    

  
      The express.static() middleware and res.sendFile() method now support the If-Match and If-Unmodified-Since request headers.
    

  
      Update to jshttp/etag module to generate the default ETags for responses which work when Node.js has FIPS-compliant crypto enabled.
    

  
      Various auto-generated HTML responses like the default not found and error handlers will respond with complete HTML 5 documents and additional security headers.
    


  For a complete list of changes in this release, see History.md.

  4.14.1 - Release date: 2017-01-28

  The 4.14.1 patch release includes bug fixes and performance improvements, including:

  
  
      Update to pillarjs/finalhandler module fixes an exception when Express handles an Error object which has a headers property that is not an object.
    


  For a complete list of changes in this release, see History.md.

  4.14.0 - Release date: 2016-06-16

  The 4.14.0 minor release includes bug fixes, security update, performance improvements, and other minor feature additions, including:

  
  
      Starting with this version, Express supports Node.js 6.x.
    

  
      Update to jshttp/negotiator module fixes a regular expression denial of service vulnerability.
    

  
      The res.sendFile() method now accepts two new options: acceptRanges and cacheControl.

      
        
          acceptRanges (defaut is true), enables or disables accepting ranged requests. When disabled, the response does not send the Accept-Ranges header and ignores the contents of the Range request header.
        
        
          cacheControl, (default is true), enables or disables the Cache-Control response header. Disabling it will ignore the maxAge option.
        
        
          res.sendFile has also been updated to handle Range header and redirections better.
        
      
    

  
      The res.location() method and res.redirect() method will now URL-encode the URL string, if it is not already encoded.
    

  
      The performance of the res.json() method and res.jsonp() method have been improved in the common cases.
    

  
      The jshttp/cookie module (in addition to a number of other improvements) has been updated and now the res.cookie() method supports the sameSite option to let you specify the SameSite cookie attribute.

      
         Note

        This attribute has not yet been fully standardized, may change in the future, and many clients may ignore it.
        

      

      The possible value for the sameSite option are:

      
        true, which sets the SameSite attribute to Strict for strict same site enforcement.
        false, which does not set the SameSite attribute.
        'lax', which sets the SameSite attribute to Lax for lax same site enforcement.
        'strict', which sets the SameSite attribute to Strict for strict same site enforcement.
      
    

  
      Absolute path checking on Windows, which was incorrect for some cases, has been fixed.
    

  
      IP address resolution with proxies has been greatly improved.
    

  
      The req.range() method options object now supports a combine option (false by default), which when true, combines overlapping and adjacent ranges and returns them as if they were specified that way in the header.
    


  For a complete list of changes in this release, see History.md.



              
    
    Edit this page\n\n\n\nVersion Support

Only the latest version of any given major release line is supported.

Versions that are EOL (end-of-life) may receive updates for critical security vulnerabilities, but the Express team offers no guarantee and does not plan to address or release fixes for any issues found.


  
    
      Major Version
      Minimum Node.js Version
      Support Start Date
      Support End Date
    
  
  
    
      v5.x
      18
      September 2024
      ongoing
    
    
      v4.x
      0.10.0
      April 2014
      ongoing
    
    
      v3.x
      0.8.0
      October 2012
      July 2015
    
    
      v2.x
      0.4.1
      March 2011
      July 2012
    
    
      v1.x
      0.2.0
      December 2010
      March 2011
    
    
      v0.14.x
      0.1.98
      December 2010
      December 2010
    
  


Commercial Support Options

If you are unable to update to a supported version of Express, please contact one of our partners to receive security updates:


  HeroDevs Never-Ending Support


              
    
    Edit this page\n\nVersion Support

Only the latest version of any given major release line is supported.

Versions that are EOL (end-of-life) may receive updates for critical security vulnerabilities, but the Express team offers no guarantee and does not plan to address or release fixes for any issues found.


  
    
      Major Version
      Minimum Node.js Version
      Support Start Date
      Support End Date
    
  
  
    
      v5.x
      18
      September 2024
      ongoing
    
    
      v4.x
      0.10.0
      April 2014
      ongoing
    
    
      v3.x
      0.8.0
      October 2012
      July 2015
    
    
      v2.x
      0.4.1
      March 2011
      July 2012
    
    
      v1.x
      0.2.0
      December 2010
      March 2011
    
    
      v0.14.x
      0.1.98
      December 2010
      December 2010
    
  


Commercial Support Options

If you are unable to update to a supported version of Express, please contact one of our partners to receive security updates:


  HeroDevs Never-Ending Support


              
    
    Edit this page\n\n\n\n[email protected]: Now the Default on npm with LTS Timeline
           
          
          
            
            By Express Technical Committee
            
            31 Mar 2025
          
        Express v5.0.0 was released on September 9th last year, but we didn’t make it the latest release on npm. Many asked us
why and when it would be, and frankly we were not ready at the time to take that jump. If you have not followed the news
from the project this past year, we have been hard at work reviving the project
and when we pushed the initial v5 release there were many loose ends still hanging. So first lets quickly go over some
of those loose ends.

Documentation updates

We had not updated the docs, provided migration guides, or even fully reviewed some of the stagnated v4/5 docs in a long
time. Since then we have had tons of great contributors help get things into better shape. As with any volunteer based
Open Source project, we love contributions to help us improve so as you upgrade please continue to open PRs to fix
anything we missed.

You can find our v5 docs and our migration guide on the website.

Migration Support

We know that migrating between versions can be challenging, especially when it involves significant changes in a widely used framework like Express. That’s why we have worked on a solution to simplify part of the process and reduce the impact on developers.

Thanks to the incredible efforts of Sebastian and Filip, we have developed a new codemod package specifically designed to facilitate the transition from Express v4 to v5, as well as future major versions. This package automates many of the necessary code changes, minimizing manual effort and making the upgrade as smooth and efficient as possible.

However, we understand that not all changes can be automated. Some breaking changes, such as the new Path Route Matching syntax, require manual modifications by developers.  You can read more about all of the breaking changes which came with v5 in our original release announcement.

For more details on the migration process and how to use the codemod package, check the repository’s README and the migration guide.

Ecosystem compatibility

The Express ecosystem is one of its strongest assets. It goes back to the early days of Node.js and is the backbone
that keeps express popular. When it goes 10 years without a major release
everything from middleware to documentation needed updates. We wanted to make sure folks had
some time to get all of that updated before we had everyone moving over. Particularly we care about our very large
beginner user base who may not know the blog post they are reading is not compatible with what they get from
npm i express.

We recognize that some friction is inevitable during major upgrades, but thanks to work from ecosystem partners
like Kamil from NestJS working to update express before we went latest
we will hopefully be ahead of the curve. And as I said above, we always welcome help to make this transition easier for
those who follow after you, PRs are the best support you can give.

Long Term Support

We had been discussing how to support v4 now that v5 was out, but we had not defined a clear guideline or expectation,
and we had (still don’t have) end user docs on our plans here. While we still have progress to make here, we have a
proposed LTS strategy  which will be the basis for our forthcoming
docs. Input is very welcome on this so we can make sure it is clearly communicated and acceptable to the community.

Additionally since then we have announced a partnership with HeroDevs to help companies who are less capable of
updating. More information on how this will work when v4 EOL will come when we get closer to that time.



Support Phases and Going latest

What does it mean to “go latest”? If you are unfamiliar with how npm dist-tags work, the latest tag is what users
will get when they run npm install express. This is important because it means it is the “default installed version”
and will trigger the transition of nearly 17 million weekly downloads from our current latest v4.21.2 to v5. As we start
this transition we want users, companies, and other organizations to know exactly what it means for support. To help
with this we have developed an LTS strategy which defines our 3 support phases and set’s target dates for when v4 will
enter EOL.

Express major versions will go through three supported phases:


  CURRENT: A new major version is designated as CURRENT upon release. It is available but not the latest version
on npm for a minimum of 3 months.
  ACTIVE: After the minimum 3 month period and the TC agrees it is stable and secure, the ACTIVE version is
tagged latest on npm for a minimum of 12 months.
  MAINTENANCE: When a new major version becomes ACTIVE, the previous major version enters MAINTENANCE for 12 months.


CURRENT


  New majors will go through a short period of hardening to ensure stability, security, and ecosystem libraries/resources
compatibility.
  We will strive to ensure no breaking changes are included, but reserve the right to make security or high priority
fixes of breaking nature within this period.
  CURRENT lines will receive all types of active work including: bug fixes, security patches, new features, and
deprecation notices.
  Users are recommended to use  CURRENT lines and to upgrade as quickly as their risk profile allows


ACTIVE


  ACTIVE lines will receive all types of active work including: bug fixes, security patches, new features, and
deprecation notices.
  For users, ACTIVE lines are considered the most stable and well supported version at any given time.


MAINTENANCE


  MAINTENANCE lines will only receive security patches or high priority bug fixes.
  Users are highly encouraged to upgrade to a CURRENT or ACTIVE release.


Proposed Schedule

For the existing release lines, we will set the following phase dates:



  
    
      
        Major
        CURRENT
        ACTIVE
        MAINTENANCE
        EOL
      
    
    
      
        4.x
         
         
        2025-04-01
        *no sooner than 2026-10-01
      
      
        5.x
        2024-09-11
        2025-03-31
        **no sooner than 2026-04-01
        **no sooner than 2027-04-01
      
      
        6.x
        ***no sooner than 2026-01-01
         
         
         
      
    
  



As you can see, this means that v5.1.0 being tagged latest indicates that we moved from CURRENT to ACTIVE which
starts the clock on EOL for v4 by moving it to MAINTENANCE. We recognize that v4 is a special case having been the
only major version for most of the history of Node.js itself. Because of this, we want to remain flexible and also
provide a bit longer support. We want to do what is best for the ecosystem, so consider these goals not commitments.

*: v4 is a special case, and we may extend MAINTENENCE support
**: v5 MAINTENENCE and EOL dates are determined by when v6 is released, these dates reflect the earliest dates if we
were to ship v6 on 2025-10-01
*** : v6 work has not officially started yet, this is simply the earliest date we can ship based on our proposed policy



Finally, what changed in v5.1.0

This release primarily focused on tech debt from supporting so many old Node.js versions and other things that stagnated but were not landed before v5.0.0 went out.

Express 5.1.0 Main Changes


  Add support for Uint8Array in res.send()
  Transitioned all remaining dependencies to use ^ ranges instead of locked versions
  Add package.json funding field to highlight our OpenCollective
  Added support for ETag option in res.sendFile()
  Added support for adding multiple links with the same rel with res.links()
  Performance: Use loop for acceptParams
  See Changelog v5.1.0


Dependencies updated

We also invested time to prepare several releases in the packages that Express depend on. Most of this packages are used by other libraries and framework as individual libraries.


  [email protected]
    
      Remove legacy node.js support checks for Brotli & AsyncLocalStorage
      Remove unpipe & destroy
    
  
  [email protected]
    
      Restore debug. Now with the router scope instead of express.
      Remove legacy node.js support checks for setImmediate
      Deprecate non-native promise support
      Remove after, safe-buffer, array-flatten, setprotoypeof, methods, utils-merge
    
  
  [email protected]
    
      Remove legacy node.js support checks for headersSent, setImmediate, & http2 support
      Remove unpipe
    
  
  [email protected]




Thanks and What’s Next

Thanks so much to everyone involved in Express over the past year, the work all our contributors have put in is
incredible, and we couldn’t do it without them. If you are not able to become a contributor yourself, please consider
asking your companies to support the project financially on OpenCollective.

As we look ahead, we’re excited to keep building momentum. If you haven’t read it yet, our Rewind 2024 + 2025 Vision blog post lays out where we’ve been and where we’re headed. This includes performances scoped packages, better automation, security hardening, and more.

One major initiative is our new Performance Working Group, focused on identifying and fixing long-standing bottlenecks in Express. We’re grateful to be kicking this off with support from the Sovereign Tech Fund (STF), who are helping us invest in long-term sustainability and performance of core infrastructure. Additionally, we will be working to improve our Typescript DX and taking next steps to improve the website.

And yes, v6 discussions are already starting to heat up. Keep an eye out for updates, and as always, see you in the issues!

Big thanks to @wesleytodd, @blakeembrey, @bjohansebas, @UlisesGascon, @Phillip9587, @carpasse, @jonchurch, @ctcpip, @inigomarquinez, @carlosstenzel, @crandmck, @chrisdel101, @dpopp07, @Ayoub-Mabrouk, @jonkoops, @IamLizu, @marco-ippolito, @ipreencekmr, @ShubhamOulkar, @raksbisht, @jeffreybaird, @dougwilson, @mertcanaltin, @GeorgeShvab, @RobinTail, @EvanHahn, @rhodgkins, @cengizcmataraci, @Shantanugupta43, @italojs, @ljharb, @MaoShizhong, @aroyan, @Binilkks, @danielgindi, @papandreou, @jsoref, @bigbigDreamer, @broofa, @CommanderRoot, @andvea, @juanarbol, @agungjati, @alexandercerutti, @pr4j3sh, @hamirmahal, @slagiewka, @Abdel-Monaam-Aouini, @sazk07, @bhavya3024, @joshbuker, @almic, @FDrag0n, @Dmitry-Kondar, @attrid, @kristof-low, @gireeshpunathil, @UzairJ99, @choi2021, @hayden36, @joharkhan99, @peterh-capella, @johnburnett, @nicolasgandrade, @axhuwastaken, @abhijeetpandit7, @peterdanwan, @rehmansheikh222, @corydalis10, @mgsantos177, @wilyJ80, @LuiGeeDev, @juliogarciape, @aelmardhi, @Ahmed1monm, @erensarac, @tomasz13nocon, @tianbuyung, @GreyTearsDev, @aastha-cse, @krzysdz, @Miguelrom, @bnoordhuis, @MehfoozurRehman, @EasonLin0716, @grjan7, @mishrasur7, @gregfenton, @zareefhasan, @Tejas150, @jpricardo, @nikeee, @dotnetCarpenter, @engpetermwangi, @msimerson, @fetsorn, @manoharreddyporeddy, @lancatlin, @mifi, @meowingwhitey, @sheplu, @krsriq, @ravibisht, @wojtekmaj, @aqeelat, @melikhov-dev, @alexstrat, @isnifer, @TorstenDittmann, @Uzlopak, @gurgunday, @kurtextrem, @hdtmccallie, @proudparrot2, @bewinsnw, @jonboulle, @alexander-akait, @alxndrsn, @DimitriPapadopoulos, @greggman, @jkbach, @julien-c, @risu729, @JohnSimumatik, @dhouck, @pedro-php, @aminerol, @robertsky, @ipetrouchtchak-fi, @tinhochu, @Lord-Kamina, @joshkel, @raiandexter0607, @NateEag, @rmhaiderali, @ljeda

              
    
    Edit this page\n\nBlog posts
          All Blogs ►

  
    
      
    
      [email protected]: Now the Default on npm with LTS Timeline
    
      
    
      A New Chapter for Express.js: Triumphs of 2024 and an ambitious 2025
    
      
    
      Express.js Security Audit: A Milestone Achievement
    
      
    
      Introducing Express v5: A New Era for the Node.js Framework
    
      
    
      Express Never Ending Support Launched by HeroDevs and Express.js
    
      
    
      September 2024 Security Releases
    
      
    
      Welcome to The Express Blog!
    
      
  
  
 

        
      
      
          
          [email protected]: Now the Default on npm with LTS Timeline
           
          
          
            
            By Express Technical Committee
            
            31 Mar 2025
          
        Express v5.0.0 was released on September 9th last year, but we didn’t make it the latest release on npm. Many asked us
why and when it would be, and frankly we were not ready at the time to take that jump. If you have not followed the news
from the project this past year, we have been hard at work reviving the project
and when we pushed the initial v5 release there were many loose ends still hanging. So first lets quickly go over some
of those loose ends.

Documentation updates

We had not updated the docs, provided migration guides, or even fully reviewed some of the stagnated v4/5 docs in a long
time. Since then we have had tons of great contributors help get things into better shape. As with any volunteer based
Open Source project, we love contributions to help us improve so as you upgrade please continue to open PRs to fix
anything we missed.

You can find our v5 docs and our migration guide on the website.

Migration Support

We know that migrating between versions can be challenging, especially when it involves significant changes in a widely used framework like Express. That’s why we have worked on a solution to simplify part of the process and reduce the impact on developers.

Thanks to the incredible efforts of Sebastian and Filip, we have developed a new codemod package specifically designed to facilitate the transition from Express v4 to v5, as well as future major versions. This package automates many of the necessary code changes, minimizing manual effort and making the upgrade as smooth and efficient as possible.

However, we understand that not all changes can be automated. Some breaking changes, such as the new Path Route Matching syntax, require manual modifications by developers.  You can read more about all of the breaking changes which came with v5 in our original release announcement.

For more details on the migration process and how to use the codemod package, check the repository’s README and the migration guide.

Ecosystem compatibility

The Express ecosystem is one of its strongest assets. It goes back to the early days of Node.js and is the backbone
that keeps express popular. When it goes 10 years without a major release
everything from middleware to documentation needed updates. We wanted to make sure folks had
some time to get all of that updated before we had everyone moving over. Particularly we care about our very large
beginner user base who may not know the blog post they are reading is not compatible with what they get from
npm i express.

We recognize that some friction is inevitable during major upgrades, but thanks to work from ecosystem partners
like Kamil from NestJS working to update express before we went latest
we will hopefully be ahead of the curve. And as I said above, we always welcome help to make this transition easier for
those who follow after you, PRs are the best support you can give.

Long Term Support

We had been discussing how to support v4 now that v5 was out, but we had not defined a clear guideline or expectation,
and we had (still don’t have) end user docs on our plans here. While we still have progress to make here, we have a
proposed LTS strategy  which will be the basis for our forthcoming
docs. Input is very welcome on this so we can make sure it is clearly communicated and acceptable to the community.

Additionally since then we have announced a partnership with HeroDevs to help companies who are less capable of
updating. More information on how this will work when v4 EOL will come when we get closer to that time.



Support Phases and Going latest

What does it mean to “go latest”? If you are unfamiliar with how npm dist-tags work, the latest tag is what users
will get when they run npm install express. This is important because it means it is the “default installed version”
and will trigger the transition of nearly 17 million weekly downloads from our current latest v4.21.2 to v5. As we start
this transition we want users, companies, and other organizations to know exactly what it means for support. To help
with this we have developed an LTS strategy which defines our 3 support phases and set’s target dates for when v4 will
enter EOL.

Express major versions will go through three supported phases:


  CURRENT: A new major version is designated as CURRENT upon release. It is available but not the latest version
on npm for a minimum of 3 months.
  ACTIVE: After the minimum 3 month period and the TC agrees it is stable and secure, the ACTIVE version is
tagged latest on npm for a minimum of 12 months.
  MAINTENANCE: When a new major version becomes ACTIVE, the previous major version enters MAINTENANCE for 12 months.


CURRENT


  New majors will go through a short period of hardening to ensure stability, security, and ecosystem libraries/resources
compatibility.
  We will strive to ensure no breaking changes are included, but reserve the right to make security or high priority
fixes of breaking nature within this period.
  CURRENT lines will receive all types of active work including: bug fixes, security patches, new features, and
deprecation notices.
  Users are recommended to use  CURRENT lines and to upgrade as quickly as their risk profile allows


ACTIVE


  ACTIVE lines will receive all types of active work including: bug fixes, security patches, new features, and
deprecation notices.
  For users, ACTIVE lines are considered the most stable and well supported version at any given time.


MAINTENANCE


  MAINTENANCE lines will only receive security patches or high priority bug fixes.
  Users are highly encouraged to upgrade to a CURRENT or ACTIVE release.


Proposed Schedule

For the existing release lines, we will set the following phase dates:



  
    
      
        Major
        CURRENT
        ACTIVE
        MAINTENANCE
        EOL
      
    
    
      
        4.x
         
         
        2025-04-01
        *no sooner than 2026-10-01
      
      
        5.x
        2024-09-11
        2025-03-31
        **no sooner than 2026-04-01
        **no sooner than 2027-04-01
      
      
        6.x
        ***no sooner than 2026-01-01
         
         
         
      
    
  



As you can see, this means that v5.1.0 being tagged latest indicates that we moved from CURRENT to ACTIVE which
starts the clock on EOL for v4 by moving it to MAINTENANCE. We recognize that v4 is a special case having been the
only major version for most of the history of Node.js itself. Because of this, we want to remain flexible and also
provide a bit longer support. We want to do what is best for the ecosystem, so consider these goals not commitments.

*: v4 is a special case, and we may extend MAINTENENCE support
**: v5 MAINTENENCE and EOL dates are determined by when v6 is released, these dates reflect the earliest dates if we
were to ship v6 on 2025-10-01
*** : v6 work has not officially started yet, this is simply the earliest date we can ship based on our proposed policy



Finally, what changed in v5.1.0

This release primarily focused on tech debt from supporting so many old Node.js versions and other things that stagnated but were not landed before v5.0.0 went out.

Express 5.1.0 Main Changes


  Add support for Uint8Array in res.send()
  Transitioned all remaining dependencies to use ^ ranges instead of locked versions
  Add package.json funding field to highlight our OpenCollective
  Added support for ETag option in res.sendFile()
  Added support for adding multiple links with the same rel with res.links()
  Performance: Use loop for acceptParams
  See Changelog v5.1.0


Dependencies updated

We also invested time to prepare several releases in the packages that Express depend on. Most of this packages are used by other libraries and framework as individual libraries.


  [email protected]
    
      Remove legacy node.js support checks for Brotli & AsyncLocalStorage
      Remove unpipe & destroy
    
  
  [email protected]
    
      Restore debug. Now with the router scope instead of express.
      Remove legacy node.js support checks for setImmediate
      Deprecate non-native promise support
      Remove after, safe-buffer, array-flatten, setprotoypeof, methods, utils-merge
    
  
  [email protected]
    
      Remove legacy node.js support checks for headersSent, setImmediate, & http2 support
      Remove unpipe
    
  
  [email protected]




Thanks and What’s Next

Thanks so much to everyone involved in Express over the past year, the work all our contributors have put in is
incredible, and we couldn’t do it without them. If you are not able to become a contributor yourself, please consider
asking your companies to support the project financially on OpenCollective.

As we look ahead, we’re excited to keep building momentum. If you haven’t read it yet, our Rewind 2024 + 2025 Vision blog post lays out where we’ve been and where we’re headed. This includes performances scoped packages, better automation, security hardening, and more.

One major initiative is our new Performance Working Group, focused on identifying and fixing long-standing bottlenecks in Express. We’re grateful to be kicking this off with support from the Sovereign Tech Fund (STF), who are helping us invest in long-term sustainability and performance of core infrastructure. Additionally, we will be working to improve our Typescript DX and taking next steps to improve the website.

And yes, v6 discussions are already starting to heat up. Keep an eye out for updates, and as always, see you in the issues!

Big thanks to @wesleytodd, @blakeembrey, @bjohansebas, @UlisesGascon, @Phillip9587, @carpasse, @jonchurch, @ctcpip, @inigomarquinez, @carlosstenzel, @crandmck, @chrisdel101, @dpopp07, @Ayoub-Mabrouk, @jonkoops, @IamLizu, @marco-ippolito, @ipreencekmr, @ShubhamOulkar, @raksbisht, @jeffreybaird, @dougwilson, @mertcanaltin, @GeorgeShvab, @RobinTail, @EvanHahn, @rhodgkins, @cengizcmataraci, @Shantanugupta43, @italojs, @ljharb, @MaoShizhong, @aroyan, @Binilkks, @danielgindi, @papandreou, @jsoref, @bigbigDreamer, @broofa, @CommanderRoot, @andvea, @juanarbol, @agungjati, @alexandercerutti, @pr4j3sh, @hamirmahal, @slagiewka, @Abdel-Monaam-Aouini, @sazk07, @bhavya3024, @joshbuker, @almic, @FDrag0n, @Dmitry-Kondar, @attrid, @kristof-low, @gireeshpunathil, @UzairJ99, @choi2021, @hayden36, @joharkhan99, @peterh-capella, @johnburnett, @nicolasgandrade, @axhuwastaken, @abhijeetpandit7, @peterdanwan, @rehmansheikh222, @corydalis10, @mgsantos177, @wilyJ80, @LuiGeeDev, @juliogarciape, @aelmardhi, @Ahmed1monm, @erensarac, @tomasz13nocon, @tianbuyung, @GreyTearsDev, @aastha-cse, @krzysdz, @Miguelrom, @bnoordhuis, @MehfoozurRehman, @EasonLin0716, @grjan7, @mishrasur7, @gregfenton, @zareefhasan, @Tejas150, @jpricardo, @nikeee, @dotnetCarpenter, @engpetermwangi, @msimerson, @fetsorn, @manoharreddyporeddy, @lancatlin, @mifi, @meowingwhitey, @sheplu, @krsriq, @ravibisht, @wojtekmaj, @aqeelat, @melikhov-dev, @alexstrat, @isnifer, @TorstenDittmann, @Uzlopak, @gurgunday, @kurtextrem, @hdtmccallie, @proudparrot2, @bewinsnw, @jonboulle, @alexander-akait, @alxndrsn, @DimitriPapadopoulos, @greggman, @jkbach, @julien-c, @risu729, @JohnSimumatik, @dhouck, @pedro-php, @aminerol, @robertsky, @ipetrouchtchak-fi, @tinhochu, @Lord-Kamina, @joshkel, @raiandexter0607, @NateEag, @rmhaiderali, @ljeda

              
    
    Edit this page\n\n\n\nExpress Blog Posts
           
          
          
            
            
          
        Want to write a post? See the submission guidelines.



  
      
         [email protected]: Now the Default on npm with LTS Timeline
      
      
        By Express Technical Committee 
        Mar 31, 2025 
         
       Express v5.0.0 was released on September 9th last year, but we didn’t make it the latest release on npm. Many asked us
why and when it would be, and frankly we were not ready a...

 
  

  
      
         A New Chapter for Express.js: Triumphs of 2024 and an ambitious 2025
      
      
        By Express Technical Committee 
        Jan 09, 2025 
         
       As we step into the new year, it’s almost impossible to ignore the unmistakable energy coursing through the Express.js community. The past twelve months have proven both foundational and forward-looking: an era of governance overhauls...

 
  

  
      
         Express.js Security Audit: A Milestone Achievement
      
      
        By Express Technical Committee 
        Oct 22, 2024 
         
       We are thrilled to announce the successful completion of a comprehensive security audit for Express.js, conducted by Ada Logics and facilitated by OSTIF. This exten...

 
  

  
      
         Introducing Express v5: A New Era for the Node.js Framework
      
      
        By Wes Todd and the Express Technical Committee 
        Oct 15, 2024 
         
       Ten years ago (July 2014) the Express v5 release pull request was opened, and now at long last it’s been merged and published!

 
  

  
      
         Express Never Ending Support Launched by HeroDevs and Express.js
      
      
        By Express Technical Committee 
        Oct 01, 2024 
         
       The Express.js team is pleased to announce a partnership with HeroDevs to launch Express Never-Ending Support (NES), providing long-term support for applications built with le...

 
  

  
      
         September 2024 Security Releases
      
      
        By Ulises Gascón 
        Sep 29, 2024 
         
       Recently, the Express team has been made aware of a number of security vulnerabilities in the Express project.  We have released a number of patches to address these vulnerabilities.

 
  

  
      
         Welcome to The Express Blog!
      
      
        By Rand McKinney and Chris Del 
        Jul 16, 2024 
         
       Welcome to the new Express blog!  The blog is meant to be a primary means of communication for the Express technical committee (TC).  While we currently have other channels such as X, LinkedIn, and of course GitHub, there’s no authori...

 
  




              
    
    Edit this page\n\nBlog posts
          All Blogs ►

  
    
      
    
      [email protected]: Now the Default on npm with LTS Timeline
    
      
    
      A New Chapter for Express.js: Triumphs of 2024 and an ambitious 2025
    
      
    
      Express.js Security Audit: A Milestone Achievement
    
      
    
      Introducing Express v5: A New Era for the Node.js Framework
    
      
    
      Express Never Ending Support Launched by HeroDevs and Express.js
    
      
    
      September 2024 Security Releases
    
      
    
      Welcome to The Express Blog!
    
      
  
  
 

        
      
      
          
          Express Blog Posts
           
          
          
            
            
          
        Want to write a post? See the submission guidelines.



  
      
         [email protected]: Now the Default on npm with LTS Timeline
      
      
        By Express Technical Committee 
        Mar 31, 2025 
         
       Express v5.0.0 was released on September 9th last year, but we didn’t make it the latest release on npm. Many asked us
why and when it would be, and frankly we were not ready a...

 
  

  
      
         A New Chapter for Express.js: Triumphs of 2024 and an ambitious 2025
      
      
        By Express Technical Committee 
        Jan 09, 2025 
         
       As we step into the new year, it’s almost impossible to ignore the unmistakable energy coursing through the Express.js community. The past twelve months have proven both foundational and forward-looking: an era of governance overhauls...

 
  

  
      
         Express.js Security Audit: A Milestone Achievement
      
      
        By Express Technical Committee 
        Oct 22, 2024 
         
       We are thrilled to announce the successful completion of a comprehensive security audit for Express.js, conducted by Ada Logics and facilitated by OSTIF. This exten...

 
  

  
      
         Introducing Express v5: A New Era for the Node.js Framework
      
      
        By Wes Todd and the Express Technical Committee 
        Oct 15, 2024 
         
       Ten years ago (July 2014) the Express v5 release pull request was opened, and now at long last it’s been merged and published!

 
  

  
      
         Express Never Ending Support Launched by HeroDevs and Express.js
      
      
        By Express Technical Committee 
        Oct 01, 2024 
         
       The Express.js team is pleased to announce a partnership with HeroDevs to launch Express Never-Ending Support (NES), providing long-term support for applications built with le...

 
  

  
      
         September 2024 Security Releases
      
      
        By Ulises Gascón 
        Sep 29, 2024 
         
       Recently, the Express team has been made aware of a number of security vulnerabilities in the Express project.  We have released a number of patches to address these vulnerabilities.

 
  

  
      
         Welcome to The Express Blog!
      
      
        By Rand McKinney and Chris Del 
        Jul 16, 2024 
         
       Welcome to the new Express blog!  The blog is meant to be a primary means of communication for the Express technical committee (TC).  While we currently have other channels such as X, LinkedIn, and of course GitHub, there’s no authori...

 
  




              
    
    Edit this page\n\n[email protected]: Now the Default on npm with LTS Timeline
      
      
        By Express Technical Committee 
        Mar 31, 2025 
         
       Express v5.0.0 was released on September 9th last year, but we didn’t make it the latest release on npm. Many asked us
why and when it would be, and frankly we were not ready a...

 
  
      
         A New Chapter for Express.js: Triumphs of 2024 and an ambitious 2025
      
      
        By Express Technical Committee 
        Jan 09, 2025 
         
       As we step into the new year, it’s almost impossible to ignore the unmistakable energy coursing through the Express.js community. The past twelve months have proven both foundational and forward-looking: an era of governance overhauls...

 
  
      
         Express.js Security Audit: A Milestone Achievement
      
      
        By Express Technical Committee 
        Oct 22, 2024 
         
       We are thrilled to announce the successful completion of a comprehensive security audit for Express.js, conducted by Ada Logics and facilitated by OSTIF. This exten...

 
  
      
         Introducing Express v5: A New Era for the Node.js Framework
      
      
        By Wes Todd and the Express Technical Committee 
        Oct 15, 2024 
         
       Ten years ago (July 2014) the Express v5 release pull request was opened, and now at long last it’s been merged and published!

 
  
      
         Express Never Ending Support Launched by HeroDevs and Express.js
      
      
        By Express Technical Committee 
        Oct 01, 2024 
         
       The Express.js team is pleased to announce a partnership with HeroDevs to launch Express Never-Ending Support (NES), providing long-term support for applications built with le...

 
  
      
         September 2024 Security Releases
      
      
        By Ulises Gascón 
        Sep 29, 2024 
         
       Recently, the Express team has been made aware of a number of security vulnerabilities in the Express project.  We have released a number of patches to address these vulnerabilities.

 
  
      
         Welcome to The Express Blog!
      
      
        By Rand McKinney and Chris Del 
        Jul 16, 2024 
         
       Welcome to the new Express blog!  The blog is meant to be a primary means of communication for the Express technical committee (TC).  While we currently have other channels such as X, LinkedIn, and of course GitHub, there’s no authori...\n\n\n\nHow to write a blog post
           
          
          
            
            
          
        

If you have an idea for a blog post, follow these steps to propose it and potentially get it published!


  
    Propose your post
    Before taking the time to write a post, please confirm that we will be able to publish it. We’re looking for topics specifically related to Express, and so we want to pre-approve all posts. For the moment, this means we aren’t accepting any unsolicited posts. To propose a blog post, open an issue entitled  Blog post proposal: <your idea>.
  
  
    Fork the repository
    If the Express TC accepts your proposal, start to write your post by forking the expressjs.com repository and cloning it to your local machine. Once you open a pull request, you’ll be able to preview your post on GitHub. See step six below.

    Optional: To run the site locally and preview your post before opening a PR, see the setup instructions in the README.
  
  
    Create a new file
    Create a new file in the _posts directory named using following the format: YYYY-MM-DD-title.md.
  
  
    Add the required front matter
    Copy the following front matter, including the dotted lines, and paste it at the top of file you just created. Replace the placeholder values with as desired.

     ---
 title: <your-title>
 sub_title: <your-optional-sub-title>
 description: <description-of-your-post>
 tags: <white-space-separated-topics>
 author: <your-name>
 ---
    
  
  
    Add your content
    Finally, start writing your content below the front matter.  Use standard markdown formatting.
  
  
    Open a pull request (PR)
    Once you open a PR, you will be able to preview your results: There will be a section on the page entitled Deploy Preview for expressjscom-preview ready! Click the link to see the site rendered from your fork/branch.

    You can use this feature over multiple commits to refine your post by making a draft pull request. Once it’s ready for review, switch it to a formal PR.
  



              
    
    Edit this page\n\nBlog posts
          All Blogs ►

  
    
      
    
      [email protected]: Now the Default on npm with LTS Timeline
    
      
    
      A New Chapter for Express.js: Triumphs of 2024 and an ambitious 2025
    
      
    
      Express.js Security Audit: A Milestone Achievement
    
      
    
      Introducing Express v5: A New Era for the Node.js Framework
    
      
    
      Express Never Ending Support Launched by HeroDevs and Express.js
    
      
    
      September 2024 Security Releases
    
      
    
      Welcome to The Express Blog!
    
      
  
  
 

        
      
      
          
          How to write a blog post
           
          
          
            
            
          
        

If you have an idea for a blog post, follow these steps to propose it and potentially get it published!


  
    Propose your post
    Before taking the time to write a post, please confirm that we will be able to publish it. We’re looking for topics specifically related to Express, and so we want to pre-approve all posts. For the moment, this means we aren’t accepting any unsolicited posts. To propose a blog post, open an issue entitled  Blog post proposal: <your idea>.
  
  
    Fork the repository
    If the Express TC accepts your proposal, start to write your post by forking the expressjs.com repository and cloning it to your local machine. Once you open a pull request, you’ll be able to preview your post on GitHub. See step six below.

    Optional: To run the site locally and preview your post before opening a PR, see the setup instructions in the README.
  
  
    Create a new file
    Create a new file in the _posts directory named using following the format: YYYY-MM-DD-title.md.
  
  
    Add the required front matter
    Copy the following front matter, including the dotted lines, and paste it at the top of file you just created. Replace the placeholder values with as desired.

     ---
 title: <your-title>
 sub_title: <your-optional-sub-title>
 description: <description-of-your-post>
 tags: <white-space-separated-topics>
 author: <your-name>
 ---
    
  
  
    Add your content
    Finally, start writing your content below the front matter.  Use standard markdown formatting.
  
  
    Open a pull request (PR)
    Once you open a PR, you will be able to preview your results: There will be a section on the page entitled Deploy Preview for expressjscom-preview ready! Click the link to see the site rendered from your fork/branch.

    You can use this feature over multiple commits to refine your post by making a draft pull request. Once it’s ready for review, switch it to a formal PR.
  



              
    
    Edit this page\n\n\n\nClick here if you are not redirected.\n\n\nExpress
        Infrastructure Web minimaliste, souple et rapide pour Node.js
    
    $ npm install express --save
  
  
    
  






  
      
          Applications Web Express est une infrastructure d'applications Web Node.js minimaliste et flexible qui fournit un ensemble de fonctionnalités robuste pour les applications Web et mobiles.
      

      
          API Grâce à une foule de méthodes utilitaires HTTP et de middleware mise à votre disposition, la création d'une API robuste est simple et rapide.
      

      
          Performance Express apporte une couche fine de fonctionnalités d'application Web fondamentales, sans masquer les fonctionnalités de Node.js que vous connaissez et appréciez.
      

      
          LoopBack Développez des applications pilotées par des modèles à l'aide d'une infrastructure basée sur Express.Pour en savoir plus, allez sur loopback.io.\n\n\n\nExpress
        Schnelles, offenes, unkompliziertes Web-Framework für Node.js
    
    $ npm install express --save
  
  
    
  






  
      
          Webanwendungen Express ist ein einfaches und flexibles Node.js-Framework von Webanwendungen, das zahlreiche leistungsfähige Features und Funktionen für Webanwendungen und mobile Anwendungen bereitstellt.


      
          APIs Mithilfe unzähliger HTTP-Dienstprogrammmethoden und Middlewarefunktionen gestaltet sich das Erstellen einer leistungsfähigen API schnell und einfach. 

      
          Leistung Express bietet eine Thin-Layer-Ebene mit grundlegenden Webanwendungsfunktionen, ohne die bekannten Node.js-Features zu überlagern. 

      
          LoopBack Entwickeln Sie modellorientierte Anwendungen mit einem Express-basierten Framework.Weitere Informationen finden Sie unter loopback.io.\n\n\n\nExpress
        Infraestructura web rápida, minimalista y flexible para Node.js
    
    $ npm install express --save
  
  
    
  






  
      
          Aplicaciones web Express es una infraestructura de aplicaciones web Node.js mínima y flexible que proporciona un conjunto sólido de características para las aplicaciones web y móviles.
      

      
          API Con miles de métodos de programa de utilidad HTTP y middleware a su disposición, la creación de una API sólida es rápida y sencilla.
      

      
          Rendimiento Express proporciona una delgada capa de características de aplicación web básicas, que no ocultan las características de Node.js que tanto ama y conoce.
      

      
          LoopBack Desarrolle aplicaciones basadas en modelos con una infraestructura basada en Express.Encontrará más información en loopback.io.\n\n\n\nExpress
        Framework web veloce, non categorico e minimalista per Node.js
    
    $ npm install express --save
  
  
    
  







  
      
          Applicazioni web Express è un framework per applicazioni web Node.js flessibile e leggero che fornisce una serie di funzioni avanzate per le applicazioni web e per dispositivi mobili.
      

      
          API Con una miriade di metodi di utilità HTTP e middleware a disposizione, la creazione di un'API affidabile è un processo facile e veloce.
      

      
          Prestazioni Express fornisce uno strato sottile di funzionalità di base per le applicazioni web, senza nascondere le funzioni Node.js che conosci e ami.
      

      
          LoopBack Sviluppare applicazioni basate sul modello con un framework basato su Express.Ulteriori informazioni su loopback.io.\n\n\n\nExpress
        Node.js のための高速で、革新的な、最小限のWebフレームワーク
    
    $ npm install express --save
  
  
    
  




  Express の資料は、他の言語 (スペイン語、日本語、ロシア語、中国語、韓国語、ポルトガル語) でも提供されています。





  
      
          Web アプリケーション Express は、Web アプリケーションとモバイル・アプリケーション向けの一連の堅固な機能を提供する最小限で柔軟な Node.js Web アプリケーション・フレームワークです。
      

      
          API 無数の HTTP ユーティリティー・メソッドとミドルウェアを自由に使用できるため、堅固な API を迅速かつ容易に作成できます。
      

      
          パフォーマンス Express は、ユーザーが使い慣れている Node.js の機能をわかりやすくし、基礎的な Web アプリケーション機能をシンプルな階層で提供します。
      

      
          LoopBack Express ベースのフレームワークを使用して、モデル駆動型アプリケーションを開発します。詳細については、loopback.io を参照してください。\n\n\n\nExpress
        Быстрый, гибкий, минималистичный веб-фреймворк для приложений Node.js
    
    $ npm install express --save
  
  
    
  






  
      
          Веб-приложения Express - это минималистичный и гибкий веб-фреймворк для приложений Node.js, предоставляющий обширный набор функций для мобильных и веб-приложений.
      

      
          API Имея в своем распоряжении множество служебных методов HTTP и промежуточных обработчиков, создать надежный API можно быстро и легко.
      

      
          Производительность Express предоставляет тонкий слой фундаментальных функций веб-приложений, которые не мешают вам работать с давно знакомыми и любимыми вами функциями Node.js.
      

      
          LoopBack Разработка приложений, управляемых моделями, с помощью фреймворка на основе Express.Дополнительную информацию можно найти на странице loopback.io.\n\n\n\nExpress
        高度包容、快速而极简的 Node.js Web 框架
    
    $ npm install express --save
  
  
    
  






  
      
          Web 应用程序 Express 是一种保持最低程度规模的灵活 Node.js Web 应用程序框架，为 Web 和移动应用程序提供一组强大的功能。

      
          API 使用您提议的各种 HTTP 实用程序方法和中间件，快速方便地创建强大的 API。

      
          性能 Express 提供精简的基本 Web 应用程序功能，而不会隐藏您了解和青睐的 Node.js 功能。\n\n\n\nExpress
        快速、集思廣益、極簡的 Node.js Web 架構
    
    $ npm install express --save
  
  
    
  



  Express 文件提供其他語言版本：西班牙文、日文、俄文、
中文、韓文、葡萄牙文。



  
      
          Web 應用程式 Express 是最小又靈活的 Node.js Web 應用程式架構，為 Web 與行動式應用程式提供一組健全的特性。

      
          API 大量的 HTTP 公用程式方法與中介軟體供您支配，能夠快速又輕鬆的建立完整的 API。

      
          效能 Express 既提供精簡的基礎 Web 應用程式特性，又不使您所認識及喜好的 Node.js 失色。
      

      
          LoopBack 使用基於 Express 的架構來開發模型驅動的應用程式。在 loopback.io 取得更多資訊。\n\n\n\nExpress5.1.0
        Node.js를 위한 빠르고 개방적인 간결한 웹 프레임워크
    
    $ npm install express --save
  




  
    
      웹 애플리케이션 Express는 웹 및 모바일 애플리케이션을 위한 일련의 강력한 기능을 제공하는 간결하고 유연한 Node.js 웹 애플리케이션 프레임워크입니다.
    

    
      API 자유롭게 활용할 수 있는 수많은 HTTP 유틸리티 메소드 및 미들웨어를 통해 쉽고 빠르게 강력한 API를 작성할 수 있습니다.
    

    
      성능 Express는 기본적인 웹 애플리케이션 기능으로 구성된 얇은 계층을 제공하여, 여러분이 알고 있고 선호하는 Node.js 기능을 모호하게 만들지 않습니다.\n\n\n\nExpress5.1.0
        Framework web rápido, flexível e minimalista para Node.js
    
    $ npm install express --save
  
  
  

    const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Olá Mundo!')
})

app.listen(port, () => {
  console.log(`App de exemplo esta rodando na porta ${port}`)
})
    
  




  
      
          Aplicativos da Web O Express é um framework para aplicativo da web do Node.js mínimo e flexível que fornece um conjunto robusto de recursos para aplicativos web e móveis.
      

      
          APIs Com uma infinidade de métodos utilitários HTTP e middleware à sua disposição, criar uma API robusta é rápido e fácil.
      

      
          Desempenho O Express fornece uma camada fina de recursos fundamentais para aplicativos da web, sem obscurecer os recursos do Node.js que você conhece e ama.
      

    
      Middleware
      Express é uma estrutura de roteamento leve e flexível com recursos básicos e mínimos que devem ser 
      aumentados por meio do uso do módulo Express middleware.\n\n\n\nExpress
        Rýchly, jednoduchý a minimalistický webový aplikačný framework pre Node.js
    
    $ npm install express --save
  
  
    
  




  
      
        Webové aplikácie Express je minimalistický, flexibilný, webový Node.js framework poskytujúci robustnú škálu funkcionality pre webové a mobilné aplikácie.
      

      
        API S nespočetným množstvom dostupných HTTP utilít a middlewarov je tvorba robustného API rýchla a jednoduchá.
      

      
        Vyhotovenie Express predstavuje tenkú vrstvu elementárnych prvkov webovej aplikácie bez skrývania Node.js prvkov, ktoré poznáte a milujete.\n\n\n\nExpress
        Швидкий, гнучкий, мінімалістичний фреймворк для веб-застосунків, побудованих на Node.js
    
    $ npm install express --save
  
  
    
  




  
      
          Веб-застосунки Express - це мінімалістичний та гнучкий фреймворк для веб-застосунків, побудованих на Node.js, що надає широкий набір функціональності.
      

      
          API Маючи в свому розпорядженні безліч допоміжних HTTP-методів та проміжних обробників, створювати надійні API можна легко і швидко.
      

      
          Продуктивність Express забезпечує тонкий прошарок базової функціональності для веб-застосунків, що не спотворює звичну та зручну функціональність Node.js.
      

      
        Проміжні модулі
        Express — це легкий та гнучкий фреймворк для маршрутизації з мінімальним набором функцій, покликаний бути розширеним використовуючи проміжні Express-модулі.\n\n\n\nExpress
         Node.js uchun tezkor, moslashuvchan, minimalistik web-freymvork.
    
    $ npm install express --save
  
  
    
  



    

        
            Web dasturlar Express, Node.jsda web-dasturlarni yaratishda keng ko'lamda yordam beruvchi, minimalistik va moslashuvchan freymvorkdir.
        

        
            APIs Ko'plab HTTP metodlar, oraliq qayta ishlovchi(middleware)lar yordamida, ishonchli tezkor va oson API server yaratish mumkin bo'ladi.
        

        
            Ishlab chiqaruvchanlik Express Nodedagi siz bilgan va sevgan imkoniyatlarni cheklamagan holda web-dasturlardagi eng asosiy imkoniyatlar bilan ta'minlab beradi.\n\n\n\nExpress5.1.0
        Node.js için hızlı, kolay, sade web çatısı
    
    $ npm install express --save
  
  
    
  




  
    
      Web Uygulamaları
	  Express, Web ve Mobil uygulamalar için sağlam özellikler sağlayan sade ve esnek bir Node.js web uygulama çatısıdır.
    

    
      API'ler 
	  Sınırsız HTTP yardımcı araç ve katmanlar sayesinde sağlam bir API oluşturmak hızlı ve kolaydır.
    

    
      Performans Express, bildiğiniz ve sevdiğiniz Node.js özelliklerini gizlemeden ince bir temel web uygulaması özellikleri katmanı sağlar.\n\n\n\nExpress5.1.0
        เว็บแอปพลิเคชันเฟรมเวอร์คที่ รวดเร็ว คล่องตัว และ เรียบง่าย สำหรับ Node.js
    
    $ npm install express --save
  
  
    
  




  
    
      เว็บแอปพลิเคชัน Express เป็น Node.js เว็บแอปพลิเคชันเฟรมเวอร์คที่เรียบง่ายและคล่องตัว สำหรับเว็บและแอปพลิเคชันบนมือถือ ที่มีชุดของคุณสมบัติที่สมบูรณ์
    

    
      APIs ด้วยเครืองมือสำหรับ HTTP method ที่นับไม่ถ่วน และ ที่จัดการมิดเดิลแวร์ ให้คุณ ทำให้คุณสามารถสร้าง API ที่สมบูรณ์ได้อย่างง่ายและรวดเร็ว
    

    
      ประสิทธิภาพ Express มีชั้นบางๆ ของคุณลักษณะพื้นฐานของเว็บแอปพลิเคชัน โดยไม่ปิดบังคุณสมบัติของ Node.js ที่คุณคุ้นเคยและชื่นชอบ\n\n\n\nExpress5.1.0
        Kerangka web yang cepat, tidak beropini, dan minimalis untuk Node.js
    
    $ npm install express --save
  
  
    
  




  
    
      Aplikasi Web Express adalah kerangka kerja aplikasi web Node.js yang minimalis dan fleksibel serta menyediakan serangkaian fitur tangguh untuk pembuatan aplikasi web dan seluler.
    

    
      APIs dengan segudang metode untuk utilitas HTTP dan middleware yang sesuai dengan keinginan Anda, maka membuat API yang kuat dapat dilakukan dengan cepat dan mudah.
    

    
      Kinerja Express menyediakan selapis tipis fitur dasar aplikasi web, tanpa mengaburkan fitur Node.js yang Anda kenal dan sukai.
    

    
      Middleware
      Express memiliki kerangka perutean yang ringan dan fleksibel dengan fitur inti yang minimalis
      hal ini dimaksudkan dapat ditingkatkan melalui penggunaan modul dari Express middleware.\n\n\n\nClick here if you are not redirected.\n\n\nPlease enable cookies.
    
      
        Email Protection
        You are unable to access this email address expressjs.com
      

      
        
          
            The website from which you got to this page is protected by Cloudflare. Email addresses on that page have been hidden in order to keep them from being accessed by malicious bots. You must enable Javascript in your browser in order to decode the e-mail address.
            If you have a website and are interested in protecting it in a similar way, you can sign up for Cloudflare.
          

          
            
              
                  
                      
                        How does Cloudflare protect email addresses on website from spammers?
                        Can I sign up for Cloudflare?
                    
                
              
            
          
        
      

      
  
    Cloudflare Ray ID: 93d7397e5b8e1949
    •
    
      Your IP:
      Click to reveal
      52.234.42.151
      •
    
    Performance & security by Cloudflare\nPlease enable cookies.\nEmail Protection
        You are unable to access this email address expressjs.com
      

      
        
          
            The website from which you got to this page is protected by Cloudflare. Email addresses on that page have been hidden in order to keep them from being accessed by malicious bots. You must enable Javascript in your browser in order to decode the e-mail address.
            If you have a website and are interested in protecting it in a similar way, you can sign up for Cloudflare.
          

          
            
              
                  
                      
                        How does Cloudflare protect email addresses on website from spammers?
                        Can I sign up for Cloudflare?
                    
                
              
            
          
        
      

      
  
    Cloudflare Ray ID: 93d7397e5b8e1949
    •
    
      Your IP:
      Click to reveal
      52.234.42.151
      •
    
    Performance & security by Cloudflare\nEmail Protection
        You are unable to access this email address expressjs.com\nYou are unable to access this email address expressjs.com\nYou are unable to access this email address\nThe website from which you got to this page is protected by Cloudflare. Email addresses on that page have been hidden in order to keep them from being accessed by malicious bots. You must enable Javascript in your browser in order to decode the e-mail address.
            If you have a website and are interested in protecting it in a similar way, you can sign up for Cloudflare.
          

          
            
              
                  
                      
                        How does Cloudflare protect email addresses on website from spammers?
                        Can I sign up for Cloudflare?\nThe website from which you got to this page is protected by Cloudflare. Email addresses on that page have been hidden in order to keep them from being accessed by malicious bots. You must enable Javascript in your browser in order to decode the e-mail address.
            If you have a website and are interested in protecting it in a similar way, you can sign up for Cloudflare.
          

          
            
              
                  
                      
                        How does Cloudflare protect email addresses on website from spammers?
                        Can I sign up for Cloudflare?\nThe website from which you got to this page is protected by Cloudflare. Email addresses on that page have been hidden in order to keep them from being accessed by malicious bots. You must enable Javascript in your browser in order to decode the e-mail address.
            If you have a website and are interested in protecting it in a similar way, you can sign up for Cloudflare.\nThe website from which you got to this page is protected by Cloudflare. Email addresses on that page have been hidden in order to keep them from being accessed by malicious bots. You must enable Javascript in your browser in order to decode the e-mail address.\nIf you have a website and are interested in protecting it in a similar way, you can sign up for Cloudflare.\nsign up for Cloudflare\nHow does Cloudflare protect email addresses on website from spammers?
                        Can I sign up for Cloudflare?\nHow does Cloudflare protect email addresses on website from spammers?
                        Can I sign up for Cloudflare?\nHow does Cloudflare protect email addresses on website from spammers?
                        Can I sign up for Cloudflare?\nHow does Cloudflare protect email addresses on website from spammers?
                        Can I sign up for Cloudflare?\nHow does Cloudflare protect email addresses on website from spammers?\nHow does Cloudflare protect email addresses on website from spammers?\nCan I sign up for Cloudflare?\nCan I sign up for Cloudflare?\nCloudflare Ray ID: 93d7397e5b8e1949
    •
    
      Your IP:
      Click to reveal
      52.234.42.151
      •
    
    Performance & security by Cloudflare\nCloudflare Ray ID: 93d7397e5b8e1949
    •
    
      Your IP:
      Click to reveal
      52.234.42.151
      •
    
    Performance & security by Cloudflare\nCloudflare Ray ID: 93d7397e5b8e1949\nYour IP:
      Click to reveal
      52.234.42.151
      •\nPerformance & security by Cloudflare\nPerformance & security by\n\n\nExpress5.1.0
        Fast, unopinionated, minimalist web framework for Node.js
    
    $ npm install express --save
  

  

    const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})
    

  



  
    
       [email protected]: Now the Default on npm with LTS Timeline
      
        Express 5.1.0 is now the default on npm, and we’re introducing an official LTS schedule for the v4 and v5 release lines. Check out our latest blog for more information.
      
    

  




  
    
      Web Applications Express is a minimal and flexible Node.js web application framework that provides a robust set of features for web and mobile applications.
    

    
      APIs With a myriad of HTTP utility methods and middleware at your disposal, creating a robust API is quick and easy.
    

    
      Performance Express provides a thin layer of fundamental web application features, without obscuring Node.js features that you know and love.
    

    
      Middleware 
      Express is a lightweight and flexible routing framework with minimal core features 
      meant to be augmented through the use of Express middleware modules.\n\n\n\nInstallation

En supposant que Node.js est déjà installé, créez un répertoire pour héberger votre application et faites-en votre répertoire de travail.

$ mkdir myapp
$ cd myapp


Utilisez la commande npm init afin de créer un fichier package.json pour votre application.
Pour plus d’informations sur le fonctionnement du fichier package.json, voir Specifics of npm’s package.json handling.

$ npm init


Cette commande vous invite à fournir un certain nombre d’informations, telles que le nom et la version de votre application.
Pour le moment, vous pouvez simplement appuyer sur la touche RETURN pour accepter les valeurs par défaut, à l’exception de ce qui suit :

entry point: (index.js)


Entrez app.js ou un nom de votre choix pour le fichier principal. Si vous souhaitez que le nom soit index.js, appuyez sur la touche RETURN pour accepter le nom de fichier par défaut suggéré.

Installez ensuite Express dans le répertoire myapp, puis sauvegardez-le dans la liste des dépendances. Par exemple :

$ npm install express --save


Pour installer Express de façon temporaire et ne pas l’ajouter à la liste des dépendances, omettez l’option --save :

$ npm install express



  Les modules Node.js installés à l’aide de l’option --save sont ajoutés à la liste des dépendances dependencies, dans le fichier package.json.
Par défaut, depuis la version 5.0, npm install <package-name> ajoute automatiquement le module Node.js à la liste des dépendances.
Par la suite, l’exécution de npm install dans le répertoire de l’application installera automatiquement les modules présents dans la liste des dépendances.


              
    
    Edit this page\n\nInstallation

En supposant que Node.js est déjà installé, créez un répertoire pour héberger votre application et faites-en votre répertoire de travail.

$ mkdir myapp
$ cd myapp


Utilisez la commande npm init afin de créer un fichier package.json pour votre application.
Pour plus d’informations sur le fonctionnement du fichier package.json, voir Specifics of npm’s package.json handling.

$ npm init


Cette commande vous invite à fournir un certain nombre d’informations, telles que le nom et la version de votre application.
Pour le moment, vous pouvez simplement appuyer sur la touche RETURN pour accepter les valeurs par défaut, à l’exception de ce qui suit :

entry point: (index.js)


Entrez app.js ou un nom de votre choix pour le fichier principal. Si vous souhaitez que le nom soit index.js, appuyez sur la touche RETURN pour accepter le nom de fichier par défaut suggéré.

Installez ensuite Express dans le répertoire myapp, puis sauvegardez-le dans la liste des dépendances. Par exemple :

$ npm install express --save


Pour installer Express de façon temporaire et ne pas l’ajouter à la liste des dépendances, omettez l’option --save :

$ npm install express



  Les modules Node.js installés à l’aide de l’option --save sont ajoutés à la liste des dépendances dependencies, dans le fichier package.json.
Par défaut, depuis la version 5.0, npm install <package-name> ajoute automatiquement le module Node.js à la liste des dépendances.
Par la suite, l’exécution de npm install dans le répertoire de l’application installera automatiquement les modules présents dans la liste des dépendances.


              
    
    Edit this page\n\n\n\nInstallation

Angenommen, Sie haben Node.js bereits installiert. Erstellen Sie ein Verzeichnis für Ihre Anwendung und definieren Sie dieses Verzeichnis als Ihr Arbeitsverzeichnis.

$ mkdir myapp
$ cd myapp


Erstellen Sie mit dem Befehl npm init eine Datei namens package.json für Ihre Anwendung. Weitere Informationen zur Funktionsweise von package.json finden Sie in den Angaben zur Handhabung der npm-Datei package.json.

$ npm init


Dieser Befehl fordert Sie zur Eingabe verschiedener Angaben wie Name und Version Ihrer Anwendung auf. Für den Moment reicht es, die Eingabetaste zu drücken und die Standardwerte für die meisten Angaben zu akzeptieren. Es gilt jedoch folgende Ausnahme:

entry point: (index.js)


Geben Sie app.js oder einen Namen Ihrer Vorstellung als Namen für die Hauptdatei ein. Wenn dieser Name index.js lauten soll, drücken Sie die Eingabetaste, um den vorgeschlagenen Standarddateinamen zu akzeptieren.

Installieren Sie jetzt Express im Verzeichnis myapp und speichern Sie es in der Abhängigkeitsliste. Beispiel:

$ npm install express --save


Wenn Sie Express vorübergehend installieren und nicht zur Abhängigkeitsliste hinzufügen wollen, geben Sie die Option --save nicht an:

$ npm install express



  Node-Module, die mit der Option --save installiert werden, werden zur Abhängigkeitsliste in der Datei package.json hinzugefügt. Danach werden bei der Ausführung von npm install im Verzeichnis app automatisch alle Module in der Abhängigkeitsliste installiert.


              
    
    Edit this page\n\nInstallation

Angenommen, Sie haben Node.js bereits installiert. Erstellen Sie ein Verzeichnis für Ihre Anwendung und definieren Sie dieses Verzeichnis als Ihr Arbeitsverzeichnis.

$ mkdir myapp
$ cd myapp


Erstellen Sie mit dem Befehl npm init eine Datei namens package.json für Ihre Anwendung. Weitere Informationen zur Funktionsweise von package.json finden Sie in den Angaben zur Handhabung der npm-Datei package.json.

$ npm init


Dieser Befehl fordert Sie zur Eingabe verschiedener Angaben wie Name und Version Ihrer Anwendung auf. Für den Moment reicht es, die Eingabetaste zu drücken und die Standardwerte für die meisten Angaben zu akzeptieren. Es gilt jedoch folgende Ausnahme:

entry point: (index.js)


Geben Sie app.js oder einen Namen Ihrer Vorstellung als Namen für die Hauptdatei ein. Wenn dieser Name index.js lauten soll, drücken Sie die Eingabetaste, um den vorgeschlagenen Standarddateinamen zu akzeptieren.

Installieren Sie jetzt Express im Verzeichnis myapp und speichern Sie es in der Abhängigkeitsliste. Beispiel:

$ npm install express --save


Wenn Sie Express vorübergehend installieren und nicht zur Abhängigkeitsliste hinzufügen wollen, geben Sie die Option --save nicht an:

$ npm install express



  Node-Module, die mit der Option --save installiert werden, werden zur Abhängigkeitsliste in der Datei package.json hinzugefügt. Danach werden bei der Ausführung von npm install im Verzeichnis app automatisch alle Module in der Abhängigkeitsliste installiert.


              
    
    Edit this page\n\n\n\nInstalación

Suponiendo que ya ha instalado Node.js, cree un directorio para que contenga la aplicación y conviértalo en el directorio de trabajo.

$ mkdir myapp
$ cd myapp


Utilice el mandato npm init para crear un archivo package.json para la aplicación.
Para obtener más información sobre cómo funciona package.json, consulte Specifics of npm’s package.json handling.

$ npm init


Este mandato solicita varios elementos como, por ejemplo, el nombre y la versión de la aplicación.
Por ahora, sólo tiene que pulsar INTRO para aceptar los valores predeterminados para la mayoría de ellos, con la siguiente excepción:

entry point: (index.js)


Especifique app.js o el nombre que desee para el archivo principal. Si desea que sea index.js, pulse INTRO para aceptar el nombre de archivo predeterminado recomendado.

A continuación, instale Express en el directorio myapp y guárdelo en la lista de dependencias. Por ejemplo:

$ npm install express --save


Para instalar Express temporalmente y no añadirlo a la lista de dependencias, omita la opción --save:

$ npm install express



  Los módulos de Node que se instalan con la opción --save se añaden a la lista dependencies en el archivo package.json.
Posteriormente, si ejecuta npm install en el directorio app, los módulos se instalarán automáticamente en la lista de dependencias.


              
    
    Edit this page\n\nInstalación

Suponiendo que ya ha instalado Node.js, cree un directorio para que contenga la aplicación y conviértalo en el directorio de trabajo.

$ mkdir myapp
$ cd myapp


Utilice el mandato npm init para crear un archivo package.json para la aplicación.
Para obtener más información sobre cómo funciona package.json, consulte Specifics of npm’s package.json handling.

$ npm init


Este mandato solicita varios elementos como, por ejemplo, el nombre y la versión de la aplicación.
Por ahora, sólo tiene que pulsar INTRO para aceptar los valores predeterminados para la mayoría de ellos, con la siguiente excepción:

entry point: (index.js)


Especifique app.js o el nombre que desee para el archivo principal. Si desea que sea index.js, pulse INTRO para aceptar el nombre de archivo predeterminado recomendado.

A continuación, instale Express en el directorio myapp y guárdelo en la lista de dependencias. Por ejemplo:

$ npm install express --save


Para instalar Express temporalmente y no añadirlo a la lista de dependencias, omita la opción --save:

$ npm install express



  Los módulos de Node que se instalan con la opción --save se añaden a la lista dependencies en el archivo package.json.
Posteriormente, si ejecuta npm install en el directorio app, los módulos se instalarán automáticamente en la lista de dependencias.


              
    
    Edit this page\n\n\n\nInstallazione

Presumendo che sia stato già installato Node.js, creare una directory in cui conservare l’applicazione e renderla la directory di lavoro.

$ mkdir myapp
$ cd myapp


Utilizzare il comando npm init per creare un file package.json per l’applicazione.
Per ulteriori informazioni sul funzionamento di package.json, consultare Informazioni specifiche sulla gestione di package.json di npm.

$ npm init


Questo comando richiede di specificare alcune informazioni, ad esempio il nome e la versione dell’applicazione.
Per il momento, è possibile semplicemente premere il tasto INVIO per accettare i valori di default per molti di esse, ad eccezione di quanto segue:

entry point: (index.js)


Immettere app.js o qualsiasi altra cosa come nome del file principale. Se si desidera che sia index.js, premere il tasto INVIO per accettare il nome file predefinito consigliato.

Quindi installare Express nella directory myapp e salvarlo nell’elenco delle dipendenze. Ad esempio:

$ npm install express --save


Per installare momentaneamente Express e non aggiungerlo all’elenco di dipendenze, omettere l’opzione --save:

$ npm install express



  I moduli Node installati con l’opzione --save vengono aggiunti all’elenco dependencies nel file package.json.
Successivamente, l’esecuzione di npm install nella directory app installerà automaticamente i moduli nell’elenco di dipendenze.


              
    
    Edit this page\n\nInstallazione

Presumendo che sia stato già installato Node.js, creare una directory in cui conservare l’applicazione e renderla la directory di lavoro.

$ mkdir myapp
$ cd myapp


Utilizzare il comando npm init per creare un file package.json per l’applicazione.
Per ulteriori informazioni sul funzionamento di package.json, consultare Informazioni specifiche sulla gestione di package.json di npm.

$ npm init


Questo comando richiede di specificare alcune informazioni, ad esempio il nome e la versione dell’applicazione.
Per il momento, è possibile semplicemente premere il tasto INVIO per accettare i valori di default per molti di esse, ad eccezione di quanto segue:

entry point: (index.js)


Immettere app.js o qualsiasi altra cosa come nome del file principale. Se si desidera che sia index.js, premere il tasto INVIO per accettare il nome file predefinito consigliato.

Quindi installare Express nella directory myapp e salvarlo nell’elenco delle dipendenze. Ad esempio:

$ npm install express --save


Per installare momentaneamente Express e non aggiungerlo all’elenco di dipendenze, omettere l’opzione --save:

$ npm install express



  I moduli Node installati con l’opzione --save vengono aggiunti all’elenco dependencies nel file package.json.
Successivamente, l’esecuzione di npm install nella directory app installerà automaticamente i moduli nell’elenco di dipendenze.


              
    
    Edit this page\n\n\n\nインストール

既に Node.js をインストールしてあることを想定して、ここではアプリケーションを作成するディレクトリーを作り、それを作業ディレクトリーにします。

$ mkdir myapp
$ cd myapp


npm init コマンドを使用して、アプリケーション用の package.json ファイルを作成します。
package.json の機能について詳しくは、Specifics of npm’s package.json handling を参照してください。

$ npm init


次のコマンドは、アプリケーションの名前やバージョンなど、いくつかのことを要求します。
ここでは、以下の例外を除いて、RETURN キーを押して単にそれらのデフォルトのほとんどを受け入れることができます。

entry point: (index.js)


app.js と入力するか、メインファイルの名前にしたいものを何か入力してください。もしそれを index.js にしたいのなら、RETURN キーを押して提案されたデフォルトのファイル名を受け入れてください。

Expressを myapp ディレクトリにインストールし、それを依存関係リストに保存してください。例えば：

$ npm install express


Express を一時的にインストールし、それを依存関係リストに追加しないようにするには、次のようにします。

$ npm install express --no-save



  npm 5.0 以降のデフォルトでは、npm install はモジュールを package.json ファイルの dependencies リストに追加します。以前のバージョンの npm では、--save オプションを明示的に指定しなければなりません。その後、app ディレクトリで npm install を実行すると、依存関係リストにモジュールが自動的にインストールされます。


Next: Hello World 

              
    
    Edit this page\n\nインストール

既に Node.js をインストールしてあることを想定して、ここではアプリケーションを作成するディレクトリーを作り、それを作業ディレクトリーにします。

$ mkdir myapp
$ cd myapp


npm init コマンドを使用して、アプリケーション用の package.json ファイルを作成します。
package.json の機能について詳しくは、Specifics of npm’s package.json handling を参照してください。

$ npm init


次のコマンドは、アプリケーションの名前やバージョンなど、いくつかのことを要求します。
ここでは、以下の例外を除いて、RETURN キーを押して単にそれらのデフォルトのほとんどを受け入れることができます。

entry point: (index.js)


app.js と入力するか、メインファイルの名前にしたいものを何か入力してください。もしそれを index.js にしたいのなら、RETURN キーを押して提案されたデフォルトのファイル名を受け入れてください。

Expressを myapp ディレクトリにインストールし、それを依存関係リストに保存してください。例えば：

$ npm install express


Express を一時的にインストールし、それを依存関係リストに追加しないようにするには、次のようにします。

$ npm install express --no-save



  npm 5.0 以降のデフォルトでは、npm install はモジュールを package.json ファイルの dependencies リストに追加します。以前のバージョンの npm では、--save オプションを明示的に指定しなければなりません。その後、app ディレクトリで npm install を実行すると、依存関係リストにモジュールが自動的にインストールされます。


Next: Hello World 

              
    
    Edit this page\n\n\n\nУстановка

Предположим, вы уже установили Node.js. Создайте каталог для своего приложения и сделайте его своим рабочим каталогом.

$ mkdir myapp
$ cd myapp


С помощью команды npm init создайте файл package.json для своего приложения.
Дополнительную информацию о работе package.json можно найти в разделе Специфика работы с npm package.json.

$ npm init


Эта команда выдает целый ряд приглашений, например, приглашение указать имя и версию вашего приложения.
На данный момент, достаточно просто нажать клавишу ВВОД, чтобы принять предлагаемые значения по умолчанию для большинства пунктов, кроме следующего:

entry point: (index.js)


Введите app.js или любое другое имя главного файла по своему желанию. Если вас устраивает index.js, нажмите клавишу ВВОД, чтобы принять предложенное имя файла по умолчанию.

Теперь установите Express в каталоге myapp и сохраните его в списке зависимостей. Например:

$ npm install express --save


Для временной установки Express, без добавления его в список зависимостей, не указывайте опцию --save:

$ npm install express



  Модули Node, установленные с опцией --save, добавляются в список dependencies в файле package.json.
В дальнейшем, при запуске npm install в каталоге app установка модулей из списка зависимостей будет выполняться автоматически.


              
    
    Edit this page\n\nУстановка

Предположим, вы уже установили Node.js. Создайте каталог для своего приложения и сделайте его своим рабочим каталогом.

$ mkdir myapp
$ cd myapp


С помощью команды npm init создайте файл package.json для своего приложения.
Дополнительную информацию о работе package.json можно найти в разделе Специфика работы с npm package.json.

$ npm init


Эта команда выдает целый ряд приглашений, например, приглашение указать имя и версию вашего приложения.
На данный момент, достаточно просто нажать клавишу ВВОД, чтобы принять предлагаемые значения по умолчанию для большинства пунктов, кроме следующего:

entry point: (index.js)


Введите app.js или любое другое имя главного файла по своему желанию. Если вас устраивает index.js, нажмите клавишу ВВОД, чтобы принять предложенное имя файла по умолчанию.

Теперь установите Express в каталоге myapp и сохраните его в списке зависимостей. Например:

$ npm install express --save


Для временной установки Express, без добавления его в список зависимостей, не указывайте опцию --save:

$ npm install express



  Модули Node, установленные с опцией --save, добавляются в список dependencies в файле package.json.
В дальнейшем, при запуске npm install в каталоге app установка модулей из списка зависимостей будет выполняться автоматически.


              
    
    Edit this page\n\n\n\n安装

假设您已经安装了 Node.js，创建目录以保存应用程序，并将其设置为工作目录。

$ mkdir myapp
$ cd myapp


使用 npm init 命令为应用程序创建 package.json 文件。
有关 package.json 工作方式的更多信息，请参阅 Specifics of npm’s package.json handling。

$ npm init


此命令提示您输入若干项，例如应用程序的名称和版本。
现在，只需按回车键以接受其中大多数项的缺省值，但以下情况例外：

entry point: (index.js)


输入 app.js，或者您希望使用的任何主文件名称。如果希望文件名为 index.js，请按回车键以接受建议的缺省文件名。

在 myapp 目录中安装 Express，然后将其保存在依赖项列表中。例如：

$ npm install express


要暂时安装 Express 而不将其添加到依赖项列表中：

$ npm install express --no-save



  默认情况下，版本为 npm 5.0+ 的 npm install 将模块添加到 package.json 文件中的 dependencies 列表；对于较早版本的 npm，必须显式指定 --save 选项。
今后运行 app 目录中的 npm install 将自动安装依赖项列表中的模块。


              
    
    Edit this page\n\n安装

假设您已经安装了 Node.js，创建目录以保存应用程序，并将其设置为工作目录。

$ mkdir myapp
$ cd myapp


使用 npm init 命令为应用程序创建 package.json 文件。
有关 package.json 工作方式的更多信息，请参阅 Specifics of npm’s package.json handling。

$ npm init


此命令提示您输入若干项，例如应用程序的名称和版本。
现在，只需按回车键以接受其中大多数项的缺省值，但以下情况例外：

entry point: (index.js)


输入 app.js，或者您希望使用的任何主文件名称。如果希望文件名为 index.js，请按回车键以接受建议的缺省文件名。

在 myapp 目录中安装 Express，然后将其保存在依赖项列表中。例如：

$ npm install express


要暂时安装 Express 而不将其添加到依赖项列表中：

$ npm install express --no-save



  默认情况下，版本为 npm 5.0+ 的 npm install 将模块添加到 package.json 文件中的 dependencies 列表；对于较早版本的 npm，必须显式指定 --save 选项。
今后运行 app 目录中的 npm install 将自动安装依赖项列表中的模块。


              
    
    Edit this page\n\n\n\n安裝

假設您已安裝 Node.js，請建立目錄來保留您的應用程式，並使它成為您的工作目錄。

$ mkdir myapp
$ cd myapp


使用 npm init 指令，為您的應用程式建立 package.json 檔。如需 package.json 如何運作的相關資訊，請參閱 Specifics of npm’s package.json handling。

$ npm init


這個指令會提示您提供一些事項，例如：您應用程式的名稱和版本。現在，您只需按下 RETURN 鍵，接受大部分的預設值，但下列除外：

entry point: (index.js)


輸入 app.js，或您所要的主要檔名稱。如果您希望其名稱是 index.js，請按 RETURN 鍵，接受建議的預設檔名。

現在，將 Express 安裝在 myapp 目錄中，並儲存在相依關係清單中。例如：

$ npm install express --save


如果只想暫時安裝 Express，而不新增至相依關係清單，請省略 --save 選項：

$ npm install express



  安裝 Node 模組時，如果指定了 --save 選項，則會將這些模組新增至 package.json 檔中的 dependencies 清單。之後，當您在 app 目錄中執行 npm install 時，就會自動安裝相依關係清單中的模組。


              
    
    Edit this page\n\n安裝

假設您已安裝 Node.js，請建立目錄來保留您的應用程式，並使它成為您的工作目錄。

$ mkdir myapp
$ cd myapp


使用 npm init 指令，為您的應用程式建立 package.json 檔。如需 package.json 如何運作的相關資訊，請參閱 Specifics of npm’s package.json handling。

$ npm init


這個指令會提示您提供一些事項，例如：您應用程式的名稱和版本。現在，您只需按下 RETURN 鍵，接受大部分的預設值，但下列除外：

entry point: (index.js)


輸入 app.js，或您所要的主要檔名稱。如果您希望其名稱是 index.js，請按 RETURN 鍵，接受建議的預設檔名。

現在，將 Express 安裝在 myapp 目錄中，並儲存在相依關係清單中。例如：

$ npm install express --save


如果只想暫時安裝 Express，而不新增至相依關係清單，請省略 --save 選項：

$ npm install express



  安裝 Node 模組時，如果指定了 --save 選項，則會將這些模組新增至 package.json 檔中的 dependencies 清單。之後，當您在 app 目錄中執行 npm install 時，就會自動安裝相依關係清單中的模組。


              
    
    Edit this page\n\n\n\n설치

Node.js가 이미 설치되었다고 가정한 상태에서, 애플리케이션을 보관할 디렉토리를 작성하고 그 디렉토리를 작업 디렉토리로 설정하십시오.

$ mkdir myapp
$ cd myapp


npm init 명령을 이용하여 애플리케이션에 대한 package.json 파일을 작성하십시오.
package.json의 작동 원리에 대한 자세한 정보는 Specifics of npm’s package.json handling을 참조하십시오.

$ npm init


이 명령을 실행하면 애플리케이션의 이름 및 버전과 같은 몇 가지 정보에 대해 프롬프트합니다.
지금은 다음의 항목을 제외한 대부분의 항목에서 ENTER 키를 눌러 기본값을 수락할 수 있습니다.

entry point: (index.js)


기본 파일의 이름을 app.js로 입력하거나 자유롭게 입력하십시오. 기본 파일의 이름을 index.js로 입력하기 원하는 경우에는 ENTER 키를 눌러 제안된 기본 파일 이름을 수락하십시오.

이제 myapp 디렉토리에 Express를 설치한 후 종속 항목 목록에 저장하십시오. 예를 들면 다음과 같습니다.

$ npm install express --save


Express를 임시로 설치하고 종속 항목 목록에 추가하지 않으려면, 다음과 같이 --save 옵션을 생략하십시오.

$ npm install express



  --save 옵션을 통해 설치된 Node 모듈은 package.json 파일 내의 dependencies 목록에 추가됩니다.
이후 app 디렉토리에서 npm install을 실행하면 종속 항목 목록 내의 모듈이 자동으로 설치됩니다.


              
    
    Edit this page\n\n설치

Node.js가 이미 설치되었다고 가정한 상태에서, 애플리케이션을 보관할 디렉토리를 작성하고 그 디렉토리를 작업 디렉토리로 설정하십시오.

$ mkdir myapp
$ cd myapp


npm init 명령을 이용하여 애플리케이션에 대한 package.json 파일을 작성하십시오.
package.json의 작동 원리에 대한 자세한 정보는 Specifics of npm’s package.json handling을 참조하십시오.

$ npm init


이 명령을 실행하면 애플리케이션의 이름 및 버전과 같은 몇 가지 정보에 대해 프롬프트합니다.
지금은 다음의 항목을 제외한 대부분의 항목에서 ENTER 키를 눌러 기본값을 수락할 수 있습니다.

entry point: (index.js)


기본 파일의 이름을 app.js로 입력하거나 자유롭게 입력하십시오. 기본 파일의 이름을 index.js로 입력하기 원하는 경우에는 ENTER 키를 눌러 제안된 기본 파일 이름을 수락하십시오.

이제 myapp 디렉토리에 Express를 설치한 후 종속 항목 목록에 저장하십시오. 예를 들면 다음과 같습니다.

$ npm install express --save


Express를 임시로 설치하고 종속 항목 목록에 추가하지 않으려면, 다음과 같이 --save 옵션을 생략하십시오.

$ npm install express



  --save 옵션을 통해 설치된 Node 모듈은 package.json 파일 내의 dependencies 목록에 추가됩니다.
이후 app 디렉토리에서 npm install을 실행하면 종속 항목 목록 내의 모듈이 자동으로 설치됩니다.


              
    
    Edit this page\n\n\n\nInstalação

Assumindo que já tenha instalado o Node.js, crie um diretório
para conter o seu aplicativo, e torne-o seu diretório ativo.

$ mkdir myapp
$ cd myapp


Use o comando npm init para criar um arquivo package.json para o seu aplicativo.
Para obter mais informações sobre como o package.json funciona,
consulte Detalhes do tratamento de package.json do npm.

$ npm init


Este comando solicita por várias coisas, como o nome e versão do seu aplicativo.
Por enquanto, é possível simplesmente pressionar RETURN para aceitar
os padrões para a maioria deles, com as seguintes exceções:

entry point: (index.js)


Insira app.js, ou qualquer nome que deseje
para o arquivo principal. Se desejar que seja index.js, pressione RETURN para aceitar o nome de
arquivo padrão sugerido.

Agora instale o Express no diretório myapp
e salve-o na lista de dependências. Por exemplo:

$ npm install express --save


Para instalar o Express temporariamente não o inclua na lista
de dependências, omita a opção --save:

$ npm install express



  Módulos do Node instalados com a opção --save
são incluídas na lista dependencies no arquivo
package.json.
Posteriormente, executando npm install no diretório
app irá automaticamente instalar os módulos na
lista de dependências.


              
    
    Edit this page\n\nInstalação

Assumindo que já tenha instalado o Node.js, crie um diretório
para conter o seu aplicativo, e torne-o seu diretório ativo.

$ mkdir myapp
$ cd myapp


Use o comando npm init para criar um arquivo package.json para o seu aplicativo.
Para obter mais informações sobre como o package.json funciona,
consulte Detalhes do tratamento de package.json do npm.

$ npm init


Este comando solicita por várias coisas, como o nome e versão do seu aplicativo.
Por enquanto, é possível simplesmente pressionar RETURN para aceitar
os padrões para a maioria deles, com as seguintes exceções:

entry point: (index.js)


Insira app.js, ou qualquer nome que deseje
para o arquivo principal. Se desejar que seja index.js, pressione RETURN para aceitar o nome de
arquivo padrão sugerido.

Agora instale o Express no diretório myapp
e salve-o na lista de dependências. Por exemplo:

$ npm install express --save


Para instalar o Express temporariamente não o inclua na lista
de dependências, omita a opção --save:

$ npm install express



  Módulos do Node instalados com a opção --save
são incluídas na lista dependencies no arquivo
package.json.
Posteriormente, executando npm install no diretório
app irá automaticamente instalar os módulos na
lista de dependências.


              
    
    Edit this page\n\n\n\nInštalácia

Za predpokladu, že už máte nainštalovaný Node.js, vytvorte priečinok pre vašu aplikáciu a presuňte sa tam.

$ mkdir myapp
$ cd myapp


Pomocou príkazu npm init vytvorte pre vašu aplikáciu súbor package.json.
Viac informácií o tom, ako funguje package.json sa dozviete po prečítaní Specifics of npm’s package.json handling.

$ npm init


Tento príkaz vás vyzve k zadaniu viacerých informácií, ako sú napr. názov a verzia vašej aplikácie.
Teraz, kvôli zjednodušeniu, stlačte len ENTER k potvrdeniu defaultných hodnôt väčšiny z nich, okrem bodu:

entry point: (index.js)


Zadajte app.js, prípadne akýkoľvek iný názov hlavného súboru vašej aplikácie. Ak ho chcete nazvať index.js, stlačte ENTER k potvrdeniu navrhovaného názvu súboru.

Teraz v myapp priečinku nainštalujte Express a pridajte ho ako dependenciu do package.json. Takto:

$ npm install express --save


Ak chcete nainštalovať Express bez toho, aby bol pridaný ako dependencia, vynechajte prepínač --save

$ npm install express



  Node moduly inštalované s prepínačom --save sú automaticky pridané do dependencies zoznamu v súbore package.json.
Následne spustením príkazu npm install v app priečinku sa všetky dependencie zo zoznamu automaticky nainštalujú.


              
    
    Edit this page\n\nInštalácia

Za predpokladu, že už máte nainštalovaný Node.js, vytvorte priečinok pre vašu aplikáciu a presuňte sa tam.

$ mkdir myapp
$ cd myapp


Pomocou príkazu npm init vytvorte pre vašu aplikáciu súbor package.json.
Viac informácií o tom, ako funguje package.json sa dozviete po prečítaní Specifics of npm’s package.json handling.

$ npm init


Tento príkaz vás vyzve k zadaniu viacerých informácií, ako sú napr. názov a verzia vašej aplikácie.
Teraz, kvôli zjednodušeniu, stlačte len ENTER k potvrdeniu defaultných hodnôt väčšiny z nich, okrem bodu:

entry point: (index.js)


Zadajte app.js, prípadne akýkoľvek iný názov hlavného súboru vašej aplikácie. Ak ho chcete nazvať index.js, stlačte ENTER k potvrdeniu navrhovaného názvu súboru.

Teraz v myapp priečinku nainštalujte Express a pridajte ho ako dependenciu do package.json. Takto:

$ npm install express --save


Ak chcete nainštalovať Express bez toho, aby bol pridaný ako dependencia, vynechajte prepínač --save

$ npm install express



  Node moduly inštalované s prepínačom --save sú automaticky pridané do dependencies zoznamu v súbore package.json.
Následne spustením príkazu npm install v app priečinku sa všetky dependencie zo zoznamu automaticky nainštalujú.


              
    
    Edit this page\n\n\n\nВстановлення

Припускаючи, що у вас вже встановлено Node.js, створіть робочу директорію, де буде ваш застосунок:

$ mkdir myapp
$ cd myapp


Використовуйте команду npm init для створення файлу package.json.
Більш докладно про роботу package.json написано в Specifics of npm’s package.json handling.

$ npm init


Під час виконання цієї команди, у вас спитається про деякі моменти (ім’я та версія вашого застосунку і т.д.).
Ви можете просто натискати Enter, щоб приймати запропоновані початкові варіанти для більшості пунктів, за виключенням цього:

entry point: (index.js)


Введіть app.js, або будь-яке інше ім’я для головного файла. Якщо ви хочете залишити запропоноване ім’я index.js,
натискайте Enter.

Тепер встановіть Express в новоствореній директорії та збережіть його в списку залежностей:

$ npm install express --save


Щоб встановити Express без додавання його в список залежностей, не передавайте параметр --save:

$ npm install express



  Модулі Node.js, встановлені з параметром --save, додаються до списку залежностей у файл package.json, що знаходиться в корені робочого каталогу.
Цей список використовується при запуску команди npm install щоб автоматично встановлювати вказані там модулі.


              
    
    Edit this page\n\nВстановлення

Припускаючи, що у вас вже встановлено Node.js, створіть робочу директорію, де буде ваш застосунок:

$ mkdir myapp
$ cd myapp


Використовуйте команду npm init для створення файлу package.json.
Більш докладно про роботу package.json написано в Specifics of npm’s package.json handling.

$ npm init


Під час виконання цієї команди, у вас спитається про деякі моменти (ім’я та версія вашого застосунку і т.д.).
Ви можете просто натискати Enter, щоб приймати запропоновані початкові варіанти для більшості пунктів, за виключенням цього:

entry point: (index.js)


Введіть app.js, або будь-яке інше ім’я для головного файла. Якщо ви хочете залишити запропоноване ім’я index.js,
натискайте Enter.

Тепер встановіть Express в новоствореній директорії та збережіть його в списку залежностей:

$ npm install express --save


Щоб встановити Express без додавання його в список залежностей, не передавайте параметр --save:

$ npm install express



  Модулі Node.js, встановлені з параметром --save, додаються до списку залежностей у файл package.json, що знаходиться в корені робочого каталогу.
Цей список використовується при запуску команди npm install щоб автоматично встановлювати вказані там модулі.


              
    
    Edit this page\n\n\n\nO’rnatish

Avval, agar ish direktoryasini yaratmagan bo’lsangiz, uni yarating va ish direktoriyasiga aylantiring.

$ mkdir myapp
$ cd myapp


Agar sizning direktoriyangizda package.json fayli mavjud bo’lmasa, uni npm init buyrug’i orqali yarating.

$ npm init


Expressni dastur direktoriyangizga o’rnating va uning kerakli modullarini saqlab qo’ying:

$ npm install express --save


Expressni vaqtinchalik o’rnatish uchun va uning kerakli modullarni saqlab qo’ymaslik uchun --save qo’shimchasini olib tashlang::

$ npm install express



  Agar --save orqali modullarni o’rnatsangiz u package.json faylidagi dependencies ro’yxatidagi qo’shiladi.
Dastur direktoriyasida npm install buyurug’ini bajarsangiz, dasturning barcha kerakli modullarni avtomatik tarzda o’rnatib beradi.


              
    
    Edit this page\n\nO’rnatish

Avval, agar ish direktoryasini yaratmagan bo’lsangiz, uni yarating va ish direktoriyasiga aylantiring.

$ mkdir myapp
$ cd myapp


Agar sizning direktoriyangizda package.json fayli mavjud bo’lmasa, uni npm init buyrug’i orqali yarating.

$ npm init


Expressni dastur direktoriyangizga o’rnating va uning kerakli modullarini saqlab qo’ying:

$ npm install express --save


Expressni vaqtinchalik o’rnatish uchun va uning kerakli modullarni saqlab qo’ymaslik uchun --save qo’shimchasini olib tashlang::

$ npm install express



  Agar --save orqali modullarni o’rnatsangiz u package.json faylidagi dependencies ro’yxatidagi qo’shiladi.
Dastur direktoriyasida npm install buyurug’ini bajarsangiz, dasturning barcha kerakli modullarni avtomatik tarzda o’rnatib beradi.


              
    
    Edit this page\n\n\n\nKurulum

Node.js‘in kurulu olduğunu varsayarak, uygulamanızı
barındıracak bir dizin oluşturun ve o dizine geçiş yapın.

$ mkdir myapp
$ cd myapp


Uygulamanız için package.json dosyasını oluşturmak için npm init komutunu
çalıştırın. 
package.json dosyasının nasıl çalıştığı hakkında daha fazla bilgi edinmek için Specifics of npm’s package.json handling adresini kullanın.

$ npm init


Bu komut size uygulamanızın adı ve versiyonu gibi bir kaç soru yöneltecektir.
Şimdilik, çoğu soru için ENTER tuşuna basıp varsayılan ayarları uygulayabilirsiniz, aşağıdaki hariç:

entry point: (index.js)


app.js ya da ana dosyanıza vermek istediğiniz ismi girin. Eğer ana dosyanızın index.js olmasını istiyorsanız, ENTER tuşu ile varsayılanı uygulayabilirsiniz.

Şimdi Express’i myapp dizinine kurun ve bağımlı uygulamalar listesine ekleyin. Örneğin:

$ npm install express


Express’i geçici olarak kurmak ve bağımlı uygulamalar listesine eklememek istiyorsanız:

$ npm install express --no-save



  npm 5.0+ versiyonları için npm install komutu, kurulacak modülü varsayılan olarak package.json içindeki bağımlılıklar listesine ekler; daha eski npm versiyonları için --save ayrıca belirtilmelidir. Daha sonrasında, uygulama dizininde npm install komutunu çalıştırmak, bağımlılık listesindeki uygulamaları otomatik olarak yükler.


Sonraki: Merhaba Dünya 

              
    
    Edit this page\n\nKurulum

Node.js‘in kurulu olduğunu varsayarak, uygulamanızı
barındıracak bir dizin oluşturun ve o dizine geçiş yapın.

$ mkdir myapp
$ cd myapp


Uygulamanız için package.json dosyasını oluşturmak için npm init komutunu
çalıştırın. 
package.json dosyasının nasıl çalıştığı hakkında daha fazla bilgi edinmek için Specifics of npm’s package.json handling adresini kullanın.

$ npm init


Bu komut size uygulamanızın adı ve versiyonu gibi bir kaç soru yöneltecektir.
Şimdilik, çoğu soru için ENTER tuşuna basıp varsayılan ayarları uygulayabilirsiniz, aşağıdaki hariç:

entry point: (index.js)


app.js ya da ana dosyanıza vermek istediğiniz ismi girin. Eğer ana dosyanızın index.js olmasını istiyorsanız, ENTER tuşu ile varsayılanı uygulayabilirsiniz.

Şimdi Express’i myapp dizinine kurun ve bağımlı uygulamalar listesine ekleyin. Örneğin:

$ npm install express


Express’i geçici olarak kurmak ve bağımlı uygulamalar listesine eklememek istiyorsanız:

$ npm install express --no-save



  npm 5.0+ versiyonları için npm install komutu, kurulacak modülü varsayılan olarak package.json içindeki bağımlılıklar listesine ekler; daha eski npm versiyonları için --save ayrıca belirtilmelidir. Daha sonrasında, uygulama dizininde npm install komutunu çalıştırmak, bağımlılık listesindeki uygulamaları otomatik olarak yükler.


Sonraki: Merhaba Dünya 

              
    
    Edit this page\n\n\n\nการติดตั้ง

สมมุติว่าคุณได้ติดตั้ง Node.js ในเครื่องคุณเรียบร้อยแล้ว ใช้คำสั่งข้างล่างนี้เพื่อสร้างไดเรกทอรีสำหรับเก็บแอปพลิเคชันของคุณ และใช้เป็นเก็บไฟล์ที่จะสร้างขึ้นต่อไป

$ mkdir myapp
$ cd myapp


ใช้คำสั่ง npm init เพื่อสร้างไฟล์ package.json สำหรับแอปพลิเคชันของคุณ

สำหรับข้อมูลเพิ่มเติมว่า package.json ทำงานอย่างไร สำมารถดูได้ที่ Specifics of npm’s package.json handling

$ npm init


หลังจากใส่คำสั่งนี้จะมีข้อความพร้อมรับให้คุณใส่ข้อมูลต่างๆ สำหรับการสร้างแอปพลิเคชัน เช่น ชื่อและรุ่นของแอปพลิเคชันของคุณ
สำหรับตอนนี้ คุณเพียงแต่กดปุ่ม ENTER เพื่อใช้ค่าเริ่มต้นของข้อมูลส่วนต่างๆ ยกเว้นข้อมูลดังต่อไปนี้

entry point: (index.js)


ใส่ app.js หรือชื่ออะไรก็ตามที่คุณต้องการสำหรับไฟล์หลักที่จะสร้าง ถ้าคุณต้องการใช้ค่าเริ่มต้นเป็น index.js เพียงกดปุ่ม ENTER เพื่อรับค่าเริ่มต้นของไฟล์หลักที่แนะนำ

ต่อไปเป็นการติดตั้ง Express ในไดเรกเทอรี myapp และบันทึกไว้ในรายการเกี่ยวโยง (dependencies list) ตัวอย่างเช่น:

$ npm install express

สามารถติดตั้ง Express ชั่วคราวได้โดยไม่ใส่ไว้ในรายการเกี่ยวโยง ด้วยคำสั่ง:

$ npm install express --no-save



  โดยค่าเริ่มต้นของ npm รุ่นที่ 5.0 ขึ้นไป คำสั่ง npm install เพิ่มโมดูลต่างๆ ไปที่รายการ dependencies ในไฟล์ package.json ถ้าเป็นรุ่นแรกๆ ของ npm คุณจำเป็นต้องใส่คำสั่ง --save ไปพร้อมกับคำสั่ง npm install ซึ่อหลังจากนี้ใช้คำสั่ง npm install ในไดเรกเทอรีของคุณ จะติดตั้งโมดูลที่อยู่ในรายการ dependencies โดยอัตโนมัติ


              
    
    Edit this page\n\nการติดตั้ง

สมมุติว่าคุณได้ติดตั้ง Node.js ในเครื่องคุณเรียบร้อยแล้ว ใช้คำสั่งข้างล่างนี้เพื่อสร้างไดเรกทอรีสำหรับเก็บแอปพลิเคชันของคุณ และใช้เป็นเก็บไฟล์ที่จะสร้างขึ้นต่อไป

$ mkdir myapp
$ cd myapp


ใช้คำสั่ง npm init เพื่อสร้างไฟล์ package.json สำหรับแอปพลิเคชันของคุณ

สำหรับข้อมูลเพิ่มเติมว่า package.json ทำงานอย่างไร สำมารถดูได้ที่ Specifics of npm’s package.json handling

$ npm init


หลังจากใส่คำสั่งนี้จะมีข้อความพร้อมรับให้คุณใส่ข้อมูลต่างๆ สำหรับการสร้างแอปพลิเคชัน เช่น ชื่อและรุ่นของแอปพลิเคชันของคุณ
สำหรับตอนนี้ คุณเพียงแต่กดปุ่ม ENTER เพื่อใช้ค่าเริ่มต้นของข้อมูลส่วนต่างๆ ยกเว้นข้อมูลดังต่อไปนี้

entry point: (index.js)


ใส่ app.js หรือชื่ออะไรก็ตามที่คุณต้องการสำหรับไฟล์หลักที่จะสร้าง ถ้าคุณต้องการใช้ค่าเริ่มต้นเป็น index.js เพียงกดปุ่ม ENTER เพื่อรับค่าเริ่มต้นของไฟล์หลักที่แนะนำ

ต่อไปเป็นการติดตั้ง Express ในไดเรกเทอรี myapp และบันทึกไว้ในรายการเกี่ยวโยง (dependencies list) ตัวอย่างเช่น:

$ npm install express

สามารถติดตั้ง Express ชั่วคราวได้โดยไม่ใส่ไว้ในรายการเกี่ยวโยง ด้วยคำสั่ง:

$ npm install express --no-save



  โดยค่าเริ่มต้นของ npm รุ่นที่ 5.0 ขึ้นไป คำสั่ง npm install เพิ่มโมดูลต่างๆ ไปที่รายการ dependencies ในไฟล์ package.json ถ้าเป็นรุ่นแรกๆ ของ npm คุณจำเป็นต้องใส่คำสั่ง --save ไปพร้อมกับคำสั่ง npm install ซึ่อหลังจากนี้ใช้คำสั่ง npm install ในไดเรกเทอรีของคุณ จะติดตั้งโมดูลที่อยู่ในรายการ dependencies โดยอัตโนมัติ


              
    
    Edit this page\n\n\n\nMenginstal

Kami asumsikan Anda telah menginstal Node.js, buatlah direktori untuk menyimpan aplikasi Anda, dan jadikan itu sebagai direktori kerja Anda.


  Express versi 4.x memerlukan Node.js versi 0.10 atau yang lebih tinggi.
  Express versi 5.x memerlukan Node.js versi 18 atau yang lebih tinggi.


$ mkdir myapp
$ cd myapp


Gunakan perintah npm init untuk membuat file package.json untuk aplikasi Anda.
Untuk informasi selengkapnya tentang cara kerja package.json, lihat Spesifikasi penggunaan package.json dari npm.

$ npm init


Perintah ini menanyakan beberapa hal, seperti nama dan versi aplikasi Anda.
Untuk saat ini, Anda cukup menekan RETURN/ENTER untuk menerima default sebagian besar, dengan pengecualian berikut:

entry point: (index.js)


Masukan app.js, atau apa pun nama file utamanya yang Anda inginkan. Jika Anda menginginkannya menjadi index.js, tekan RETURN/ENTER untuk menerima nama file default yang disarankan.

Sekarang, instal Express di direktori myapp dan simpan di daftar dependensi. Misalnya:

$ npm install express


Untuk menginstal Express secara sementara dan tidak menambahkannya ke daftar dependensi, jalankan perintah berikut:

$ npm install express --no-save



  Secara default versi npm 5.0+, ketika menjalankan perintah npm install akan menambahkan modul ke daftar dependencies di file package.json; sedangkan untuk versi npm sebelumnya, Anda harus menentukan opsi --save secara eksplisit. Kemudian, setelah itu, menjalankan npm install --save di direktori aplikasi akan secara otomatis menginstal modul dalam daftar dependensi.


Next: Hello World 

              
    
    Edit this page\n\nMenginstal

Kami asumsikan Anda telah menginstal Node.js, buatlah direktori untuk menyimpan aplikasi Anda, dan jadikan itu sebagai direktori kerja Anda.


  Express versi 4.x memerlukan Node.js versi 0.10 atau yang lebih tinggi.
  Express versi 5.x memerlukan Node.js versi 18 atau yang lebih tinggi.


$ mkdir myapp
$ cd myapp


Gunakan perintah npm init untuk membuat file package.json untuk aplikasi Anda.
Untuk informasi selengkapnya tentang cara kerja package.json, lihat Spesifikasi penggunaan package.json dari npm.

$ npm init


Perintah ini menanyakan beberapa hal, seperti nama dan versi aplikasi Anda.
Untuk saat ini, Anda cukup menekan RETURN/ENTER untuk menerima default sebagian besar, dengan pengecualian berikut:

entry point: (index.js)


Masukan app.js, atau apa pun nama file utamanya yang Anda inginkan. Jika Anda menginginkannya menjadi index.js, tekan RETURN/ENTER untuk menerima nama file default yang disarankan.

Sekarang, instal Express di direktori myapp dan simpan di daftar dependensi. Misalnya:

$ npm install express


Untuk menginstal Express secara sementara dan tidak menambahkannya ke daftar dependensi, jalankan perintah berikut:

$ npm install express --no-save



  Secara default versi npm 5.0+, ketika menjalankan perintah npm install akan menambahkan modul ke daftar dependencies di file package.json; sedangkan untuk versi npm sebelumnya, Anda harus menentukan opsi --save secara eksplisit. Kemudian, setelah itu, menjalankan npm install --save di direktori aplikasi akan secara otomatis menginstal modul dalam daftar dependensi.


Next: Hello World 

              
    
    Edit this page\n\n\n\nInstalling

Assuming you’ve already installed Node.js, create a directory to hold your application, and make that your working directory.


  Express 4.x requires Node.js 0.10 or higher.
  Express 5.x requires Node.js 18 or higher.


$ mkdir myapp
$ cd myapp


Use the npm init command to create a package.json file for your application.
For more information on how package.json works, see Specifics of npm’s package.json handling.

$ npm init


This command prompts you for a number of things, such as the name and version of your application.
For now, you can simply hit RETURN to accept the defaults for most of them, with the following exception:

entry point: (index.js)


Enter app.js, or whatever you want the name of the main file to be. If you want it to be index.js, hit RETURN to accept the suggested default file name.

Now, install Express in the myapp directory and save it in the dependencies list. For example:

$ npm install express


To install Express temporarily and not add it to the dependencies list:

$ npm install express --no-save



  By default with version npm 5.0+, npm install adds the module to the dependencies list in the package.json file; with earlier versions of npm, you must specify the --save option explicitly. Then, afterwards, running npm install in the app directory will automatically install modules in the dependencies list.


Next: Hello World 

              
    
    Edit this page\n\nInstalling

Assuming you’ve already installed Node.js, create a directory to hold your application, and make that your working directory.


  Express 4.x requires Node.js 0.10 or higher.
  Express 5.x requires Node.js 18 or higher.


$ mkdir myapp
$ cd myapp


Use the npm init command to create a package.json file for your application.
For more information on how package.json works, see Specifics of npm’s package.json handling.

$ npm init


This command prompts you for a number of things, such as the name and version of your application.
For now, you can simply hit RETURN to accept the defaults for most of them, with the following exception:

entry point: (index.js)


Enter app.js, or whatever you want the name of the main file to be. If you want it to be index.js, hit RETURN to accept the suggested default file name.

Now, install Express in the myapp directory and save it in the dependencies list. For example:

$ npm install express


To install Express temporarily and not add it to the dependencies list:

$ npm install express --no-save



  By default with version npm 5.0+, npm install adds the module to the dependencies list in the package.json file; with earlier versions of npm, you must specify the --save option explicitly. Then, afterwards, running npm install in the app directory will automatically install modules in the dependencies list.


Next: Hello World 

              
    
    Edit this page\n\n\n\nExemple Hello world


  Il s’agit de l’application Express la plus simple que vous puissiez créer. Cette application ne contient qu’un seul fichier, c’est-à-dire tout l’inverse de ce que vous obtiendriez avec le
générateur Express, qui crée l’échafaudage d’une application entière, avec des fichiers JavaScript, des modèles Pug et des sous-répertoires pour divers motifs.


Premièrement, créez un répertoire appelé myapp, rendez-vous dedans et exécutez la commande npm init.
Ensuite, installez express en tant que dépendance en suivant les instructions du guide d’installation.

Dans le répertoire myapp, créez un fichier appelé app.js et ajoutez le code suivant :

const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


L’application démarre un serveur et écoute le port 3000 à la recherche de connexions. L’application répond “Hello World!” aux demandes adressées
à l’URL racine (/) ou à la route racine. Pour tous les autres chemins d’accès, elle répondra par 404 Not Found.


  Les objets req (demande) et res (réponse) sont exactement les mêmes que ceux que Node fournit, vous pouvez donc appeler
req.pipe(), req.on('data', callback) et tout autre objet sans recourir à Express.


Exécutez l’application avec la commande suivante :

$ node app.js


Puis chargez http://localhost:3000/ dans un navigateur pour consulter le résultat.


              
    
    Edit this page\n\nExemple Hello world


  Il s’agit de l’application Express la plus simple que vous puissiez créer. Cette application ne contient qu’un seul fichier, c’est-à-dire tout l’inverse de ce que vous obtiendriez avec le
générateur Express, qui crée l’échafaudage d’une application entière, avec des fichiers JavaScript, des modèles Pug et des sous-répertoires pour divers motifs.


Premièrement, créez un répertoire appelé myapp, rendez-vous dedans et exécutez la commande npm init.
Ensuite, installez express en tant que dépendance en suivant les instructions du guide d’installation.

Dans le répertoire myapp, créez un fichier appelé app.js et ajoutez le code suivant :

const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


L’application démarre un serveur et écoute le port 3000 à la recherche de connexions. L’application répond “Hello World!” aux demandes adressées
à l’URL racine (/) ou à la route racine. Pour tous les autres chemins d’accès, elle répondra par 404 Not Found.


  Les objets req (demande) et res (réponse) sont exactement les mêmes que ceux que Node fournit, vous pouvez donc appeler
req.pipe(), req.on('data', callback) et tout autre objet sans recourir à Express.


Exécutez l’application avec la commande suivante :

$ node app.js


Puis chargez http://localhost:3000/ dans un navigateur pour consulter le résultat.


              
    
    Edit this page\n\n\n\nBeispiel “Hello World”


  Dies ist wohl die einfachste Express-Anwendung, die Sie erstellen können. Es handelt sich um eine Anwendung mit nur einer Datei und — nicht das, was Sie mit dem Express Generator erhalten würden. Mit dem Generator würde das Gerüst für eine vollständige Anwendung mit zahlreichen JavaScript-Dateien, Jade-Vorlagen und Unterverzeichnissen für verschiedene Zwecke erstellt werden.


Erstellen Sie zunächst ein Verzeichnis namens myapp, wechseln Sie in das Verzeichnis und führen Sie npm init aus. Installieren Sie dann express als Abhängigkeit, wie im Installationshandbuch beschrieben.

Erstellen Sie im Verzeichnis myapp eine Datei namens app.js und fügen Sie den folgenden Code hinzu:

const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


Die Anwendung startet einen Server und ist an Port 3000 empfangsbereit für Verbindungen. Die Anwendung antwortet mit “Hello World!” auf Anforderungen zur Stamm-URL (/) oder zu route. Bei jedem anderen Pfad lautet die Antwort 404 Not Found.


  req (Anforderung) und res (Antwort) sind genau dieselben Objekte, die Node bereitstellt. Sie können also req.pipe(), req.on('data', callback) und alle anderen Tasks, die Sie ausführen wollen, ohne Express ausführen.


Führen Sie die Anwendung mit dem folgenden Befehl aus:

$ node app.js


Laden Sie dann http://localhost:3000/ in einen Browser, um die Ausgabe zu sehen.


              
    
    Edit this page\n\nBeispiel “Hello World”


  Dies ist wohl die einfachste Express-Anwendung, die Sie erstellen können. Es handelt sich um eine Anwendung mit nur einer Datei und — nicht das, was Sie mit dem Express Generator erhalten würden. Mit dem Generator würde das Gerüst für eine vollständige Anwendung mit zahlreichen JavaScript-Dateien, Jade-Vorlagen und Unterverzeichnissen für verschiedene Zwecke erstellt werden.


Erstellen Sie zunächst ein Verzeichnis namens myapp, wechseln Sie in das Verzeichnis und führen Sie npm init aus. Installieren Sie dann express als Abhängigkeit, wie im Installationshandbuch beschrieben.

Erstellen Sie im Verzeichnis myapp eine Datei namens app.js und fügen Sie den folgenden Code hinzu:

const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


Die Anwendung startet einen Server und ist an Port 3000 empfangsbereit für Verbindungen. Die Anwendung antwortet mit “Hello World!” auf Anforderungen zur Stamm-URL (/) oder zu route. Bei jedem anderen Pfad lautet die Antwort 404 Not Found.


  req (Anforderung) und res (Antwort) sind genau dieselben Objekte, die Node bereitstellt. Sie können also req.pipe(), req.on('data', callback) und alle anderen Tasks, die Sie ausführen wollen, ohne Express ausführen.


Führen Sie die Anwendung mit dem folgenden Befehl aus:

$ node app.js


Laden Sie dann http://localhost:3000/ in einen Browser, um die Ausgabe zu sehen.


              
    
    Edit this page\n\n\n\nEjemplo Hello world


  Esta es básicamente la aplicación Express más sencilla que puede crear. Es una aplicación de archivo simple — no lo que obtendrá si utiliza el generador de Express, que crea el andamiaje para una aplicación completa con varios archivos JavaScript, plantillas Jade y subdirectorios para distintos propósitos.


En primer lugar, cree un directorio denominado myapp, cámbielo y ejecute npm init. A continuación, instale express como una dependencia, según se describe en la guía de instalación.

En el directorio myapp, cree un archivo denominado app.js y añada el código siguiente:

const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


La aplicación inicia un servidor y escucha las conexiones en el puerto 3000. La aplicación responde con “Hello World!” para las solicitudes al URL raíz (/) o a la ruta raíz. Para cada vía de acceso diferente, responderá con un error 404 Not Found.


  req (solicitud) y res (respuesta) son exactamente los mismos objetos que proporciona Node, por lo que puede invocar req.pipe(), req.on('data', callback) y cualquier otro objeto que invocaría sin estar Express implicado.


Ejecute la aplicación con el siguiente mandato:

$ node app.js


A continuación, cargue http://localhost:3000/ en un navegador para ver la salida.


              
    
    Edit this page\n\nEjemplo Hello world


  Esta es básicamente la aplicación Express más sencilla que puede crear. Es una aplicación de archivo simple — no lo que obtendrá si utiliza el generador de Express, que crea el andamiaje para una aplicación completa con varios archivos JavaScript, plantillas Jade y subdirectorios para distintos propósitos.


En primer lugar, cree un directorio denominado myapp, cámbielo y ejecute npm init. A continuación, instale express como una dependencia, según se describe en la guía de instalación.

En el directorio myapp, cree un archivo denominado app.js y añada el código siguiente:

const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


La aplicación inicia un servidor y escucha las conexiones en el puerto 3000. La aplicación responde con “Hello World!” para las solicitudes al URL raíz (/) o a la ruta raíz. Para cada vía de acceso diferente, responderá con un error 404 Not Found.


  req (solicitud) y res (respuesta) son exactamente los mismos objetos que proporciona Node, por lo que puede invocar req.pipe(), req.on('data', callback) y cualquier otro objeto que invocaría sin estar Express implicado.


Ejecute la aplicación con el siguiente mandato:

$ node app.js


A continuación, cargue http://localhost:3000/ en un navegador para ver la salida.


              
    
    Edit this page\n\n\n\nEsempio di Hello world


  In sostanza, questa sarà l’applicazione Express più semplice che è possibile creare. È un’applicazione a singolo file — e non quello che si ottiene se si utilizza il Programma di creazione Express, il quale crea le fondamenta per un’applicazione completa con molti file JavaScript, template Jade e sotto directory per diversi scopi.


Per prima cosa creare una directory denominata myapp, passare a quest’ultima ed eseguire npm init. Quindi installare express come dipendenza, come descritto nella Guida all’installazione.

Nella directory myapp, creare un file denominato app.js e aggiungere il seguente codice:

const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


L’applicazione avvia un server e resta in ascolto sulla porta 3000 per le connessioni. L’applicazione risponde con “Hello World!” per le richieste
all’URL root (/) o route. Per qualsiasi altro percorso, risponderà con il messaggio 404 Non trovato.


  I valori req (richiesta) e res (risposta) sono esattamente gli stessi oggetti forniti da Node, quindi è possibile richiamare
req.pipe(), req.on('data', callback) e qualsiasi cosa che si farebbe senza il coinvolgimento di Express.


Eseguire l’applicazione con il seguente comando:

$ node app.js


Successivamente, caricare http://localhost:3000/ su un browser per visualizzare l’output.


              
    
    Edit this page\n\nEsempio di Hello world


  In sostanza, questa sarà l’applicazione Express più semplice che è possibile creare. È un’applicazione a singolo file — e non quello che si ottiene se si utilizza il Programma di creazione Express, il quale crea le fondamenta per un’applicazione completa con molti file JavaScript, template Jade e sotto directory per diversi scopi.


Per prima cosa creare una directory denominata myapp, passare a quest’ultima ed eseguire npm init. Quindi installare express come dipendenza, come descritto nella Guida all’installazione.

Nella directory myapp, creare un file denominato app.js e aggiungere il seguente codice:

const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


L’applicazione avvia un server e resta in ascolto sulla porta 3000 per le connessioni. L’applicazione risponde con “Hello World!” per le richieste
all’URL root (/) o route. Per qualsiasi altro percorso, risponderà con il messaggio 404 Non trovato.


  I valori req (richiesta) e res (risposta) sono esattamente gli stessi oggetti forniti da Node, quindi è possibile richiamare
req.pipe(), req.on('data', callback) e qualsiasi cosa che si farebbe senza il coinvolgimento di Express.


Eseguire l’applicazione con il seguente comando:

$ node app.js


Successivamente, caricare http://localhost:3000/ su un browser per visualizzare l’output.


              
    
    Edit this page\n\n\n\nHello World の例


  ここで紹介するのは基本的に、作成できる最も単純な Express アプリケーションです。このアプリケーションは単一ファイル・アプリケーションであり、Express ジェネレーター を使用して得られるものでは ありません 。このジェネレーターは、さまざまな目的で多数の JavaScript ファイル、Jade テンプレート、サブディレクトリーを使用する完全なアプリケーション用のスキャフォールディングを作成します。


最初に、myapp という名前のディレクトリーを作成して、そのディレクトリーに移動し、npm init を実行します。次に、インストール・ガイドに従い、依存関係として express をインストールします。

myapp ディレクトリーで、app.js というファイルを作成して、以下のコードを追加します。

const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


アプリケーションは、サーバーを始動して、ポート 3000 で接続を listen します。アプリケーションは、ルート URL (/) またはルート に対する要求に「Hello World!」と応答します。その他すべてのパスについては、「404 Not Found」と応答します。


  req (要求) と res (応答) は、Node が提供するのとまったく同じオブジェクトであるため、Express が関与しない場合と同じように、req.pipe()、req.on('data', callback) などを呼び出すことができます。


次のコマンドを使用してアプリケーションを実行します。

$ node app.js


次に、ブラウザーに http://localhost:3000/ をロードして、出力を確認します。


              
    
    Edit this page\n\nHello World の例


  ここで紹介するのは基本的に、作成できる最も単純な Express アプリケーションです。このアプリケーションは単一ファイル・アプリケーションであり、Express ジェネレーター を使用して得られるものでは ありません 。このジェネレーターは、さまざまな目的で多数の JavaScript ファイル、Jade テンプレート、サブディレクトリーを使用する完全なアプリケーション用のスキャフォールディングを作成します。


最初に、myapp という名前のディレクトリーを作成して、そのディレクトリーに移動し、npm init を実行します。次に、インストール・ガイドに従い、依存関係として express をインストールします。

myapp ディレクトリーで、app.js というファイルを作成して、以下のコードを追加します。

const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


アプリケーションは、サーバーを始動して、ポート 3000 で接続を listen します。アプリケーションは、ルート URL (/) またはルート に対する要求に「Hello World!」と応答します。その他すべてのパスについては、「404 Not Found」と応答します。


  req (要求) と res (応答) は、Node が提供するのとまったく同じオブジェクトであるため、Express が関与しない場合と同じように、req.pipe()、req.on('data', callback) などを呼び出すことができます。


次のコマンドを使用してアプリケーションを実行します。

$ node app.js


次に、ブラウザーに http://localhost:3000/ をロードして、出力を確認します。


              
    
    Edit this page\n\n\n\nПример “Hello world”


  Ниже приведен пример самого простого приложения, которое можно создать с помощью Express. Оно состоит из одного файла, в отличие от приложений, генерируемых с помощью генератора приложений Express, который обеспечивает создание основы для полноценного приложения с многочисленными файлами на JavaScript, шаблонами Jade и вложенными каталогами различного предназначения.


Вначале создайте каталог с именем myapp, перейдите в него и запустите команду npm init. Затем установите express как зависимость, следуя указаниям, приведенным в руководстве по установке.

В каталоге myapp создайте файл с именем app.js и добавьте следующий код:

const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


Приложение запускает сервер и слушает соединения на порте 3000. Приложение выдает ответ “Hello World!” на запросы, адресованные корневому URL (/) или маршруту. Для всех остальных путей ответом будет 404 Not Found.


  req (запрос) и res (ответ) являются теми же объектами, которые предоставляет Node,  поэтому можно вызвать req.pipe(), req.on('data', callback) и выполнить любые другие действия, не требующие участия Express.


Запустите приложение с помощью следующей команды:

$ node app.js


После этого откройте в браузере страницу http://localhost:3000/, чтобы просмотреть результат.


              
    
    Edit this page\n\nПример “Hello world”


  Ниже приведен пример самого простого приложения, которое можно создать с помощью Express. Оно состоит из одного файла, в отличие от приложений, генерируемых с помощью генератора приложений Express, который обеспечивает создание основы для полноценного приложения с многочисленными файлами на JavaScript, шаблонами Jade и вложенными каталогами различного предназначения.


Вначале создайте каталог с именем myapp, перейдите в него и запустите команду npm init. Затем установите express как зависимость, следуя указаниям, приведенным в руководстве по установке.

В каталоге myapp создайте файл с именем app.js и добавьте следующий код:

const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


Приложение запускает сервер и слушает соединения на порте 3000. Приложение выдает ответ “Hello World!” на запросы, адресованные корневому URL (/) или маршруту. Для всех остальных путей ответом будет 404 Not Found.


  req (запрос) и res (ответ) являются теми же объектами, которые предоставляет Node,  поэтому можно вызвать req.pipe(), req.on('data', callback) и выполнить любые другие действия, не требующие участия Express.


Запустите приложение с помощью следующей команды:

$ node app.js


После этого откройте в браузере страницу http://localhost:3000/, чтобы просмотреть результат.


              
    
    Edit this page\n\n\n\nHello world 示例


  这基本上是您可以创建的最简单的 Express 应用程序。这是单个文件应用程序 — 根本不需要动用 Express 生成器。Express 生成器的作用就像是为完整的应用程序建立一个“脚手架”，包含各种用途的 JavaScript 文件、Jade 模板和子目录。


首先创建名为 myapp 的目录，切换到此目录，然后运行 npm init。根据安装指南将 express 安装为依赖项。

在 myapp 目录中，创建名为 app.js 的文件，然后添加以下代码：

const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


应用程序会启动服务器，并在端口 3000 上侦听连接。此应用程序以“Hello World!”响应针对根 URL (/) 或路由的请求。对于其他所有路径，它将以 404 Not Found 进行响应。


  req（请求）和 res（响应）与 Node 提供的对象完全相同，所以您可以在不涉及 Express 的情况下调用 req.pipe()、req.on('data', callback) 和要执行的其他任何函数。


使用以下命令运行应用程序：

$ node app.js


然后，在浏览器中输入 http://localhost:3000/ 以查看输出。


              
    
    Edit this page\n\nHello world 示例


  这基本上是您可以创建的最简单的 Express 应用程序。这是单个文件应用程序 — 根本不需要动用 Express 生成器。Express 生成器的作用就像是为完整的应用程序建立一个“脚手架”，包含各种用途的 JavaScript 文件、Jade 模板和子目录。


首先创建名为 myapp 的目录，切换到此目录，然后运行 npm init。根据安装指南将 express 安装为依赖项。

在 myapp 目录中，创建名为 app.js 的文件，然后添加以下代码：

const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


应用程序会启动服务器，并在端口 3000 上侦听连接。此应用程序以“Hello World!”响应针对根 URL (/) 或路由的请求。对于其他所有路径，它将以 404 Not Found 进行响应。


  req（请求）和 res（响应）与 Node 提供的对象完全相同，所以您可以在不涉及 Express 的情况下调用 req.pipe()、req.on('data', callback) 和要执行的其他任何函数。


使用以下命令运行应用程序：

$ node app.js


然后，在浏览器中输入 http://localhost:3000/ 以查看输出。


              
    
    Edit this page\n\n\n\nHello world 範例


  本質上，這是您所能建立的最簡易 Express 應用程式。它是單一檔案應用程式 — 與您使用 Express 產生器所產生的結果不同，Express 產生器會建立完整應用程式框架，其中含有眾多 JavaScript 檔案、Jade 範本，以及各種用途的子目錄。


首先請建立一個名為 myapp 的目錄，切換至該目錄，並執行 npm init。然後按照安裝手冊，將 express 安裝成一個相依關係。

在 myapp 目錄中，建立名為 app.js 的檔案，並新增下列程式碼：

const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


應用程式會啟動伺服器，並在埠 3000 接聽連線。應用程式對指向根 URL (/) 或路由的要求，以 “Hello World!” 回應。對於其他每一個路徑，它的回應是 404 找不到。


  req（要求）和 res（回應）與 Node 提供的物件完全相同，因此您可以呼叫 req.pipe()、req.on('data', callback)，以及任何您要執行的項目，而不需要 Express 涉及。


使用下列指令來執行應用程式：

$ node app.js


然後在瀏覽器中載入 http://localhost:3000/，以查看輸出。


              
    
    Edit this page\n\nHello world 範例


  本質上，這是您所能建立的最簡易 Express 應用程式。它是單一檔案應用程式 — 與您使用 Express 產生器所產生的結果不同，Express 產生器會建立完整應用程式框架，其中含有眾多 JavaScript 檔案、Jade 範本，以及各種用途的子目錄。


首先請建立一個名為 myapp 的目錄，切換至該目錄，並執行 npm init。然後按照安裝手冊，將 express 安裝成一個相依關係。

在 myapp 目錄中，建立名為 app.js 的檔案，並新增下列程式碼：

const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


應用程式會啟動伺服器，並在埠 3000 接聽連線。應用程式對指向根 URL (/) 或路由的要求，以 “Hello World!” 回應。對於其他每一個路徑，它的回應是 404 找不到。


  req（要求）和 res（回應）與 Node 提供的物件完全相同，因此您可以呼叫 req.pipe()、req.on('data', callback)，以及任何您要執行的項目，而不需要 Express 涉及。


使用下列指令來執行應用程式：

$ node app.js


然後在瀏覽器中載入 http://localhost:3000/，以查看輸出。


              
    
    Edit this page\n\n\n\nHello world 예제


  기본적으로 이 앱은 여러분이 작성할 수 있는 가장 간단한 Express 앱일 것입니다. 이 앱은 하나의 파일로 된 앱이며 Express 생성기를 통해 얻게 되는 앱과는 같지 않습니다. (이 예제와 달리 Express 생성기를 통해 얻게 되는 앱은 다양한 목적을 위한 여러 JavaScript 파일, Jade 템플리트 및 하위 디렉토리를 포함하는 전체 앱에 대한 스캐폴딩을 작성합니다.)


먼저, myapp이라는 이름의 디렉토리를 작성한 후 이 디렉토리로 이동하여 npm init를 실행하십시오. 이후 설치 안내서에 따라 express를 종속 항목으로서 설치하십시오.

myapp 디렉토리에 app.js라는 이름의 파일을 작성한 후 다음과 같은 코드를 추가하십시오.

const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


앱은 서버를 시작하며 3000번 포트에서 연결을 청취합니다. 앱은 루트 URL(/) 또는 라우트에
대한 요청에 “Hello World!”로 응답합니다. 다른 모든 경로에 대해서는 404 Not Found로 응답합니다.


  req(요청) 및 res(응답)는 Node가 제공하는 동일한 오브젝트이며, 따라서
req.pipe(), req.on('data', callback) 그리고 Express의 관여가 필요 없는 다른 모든 항목을 호출할 수 있습니다.


다음의 명령을 이용하여 앱을 실행하십시오.

$ node app.js


이후 브라우저에서 http://localhost:3000/을 로드하여 결과물을 확인하십시오.


              
    
    Edit this page\n\nHello world 예제


  기본적으로 이 앱은 여러분이 작성할 수 있는 가장 간단한 Express 앱일 것입니다. 이 앱은 하나의 파일로 된 앱이며 Express 생성기를 통해 얻게 되는 앱과는 같지 않습니다. (이 예제와 달리 Express 생성기를 통해 얻게 되는 앱은 다양한 목적을 위한 여러 JavaScript 파일, Jade 템플리트 및 하위 디렉토리를 포함하는 전체 앱에 대한 스캐폴딩을 작성합니다.)


먼저, myapp이라는 이름의 디렉토리를 작성한 후 이 디렉토리로 이동하여 npm init를 실행하십시오. 이후 설치 안내서에 따라 express를 종속 항목으로서 설치하십시오.

myapp 디렉토리에 app.js라는 이름의 파일을 작성한 후 다음과 같은 코드를 추가하십시오.

const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


앱은 서버를 시작하며 3000번 포트에서 연결을 청취합니다. 앱은 루트 URL(/) 또는 라우트에
대한 요청에 “Hello World!”로 응답합니다. 다른 모든 경로에 대해서는 404 Not Found로 응답합니다.


  req(요청) 및 res(응답)는 Node가 제공하는 동일한 오브젝트이며, 따라서
req.pipe(), req.on('data', callback) 그리고 Express의 관여가 필요 없는 다른 모든 항목을 호출할 수 있습니다.


다음의 명령을 이용하여 앱을 실행하십시오.

$ node app.js


이후 브라우저에서 http://localhost:3000/을 로드하여 결과물을 확인하십시오.


              
    
    Edit this page\n\n\n\nExemplo Hello World


  Este é essencialmente o aplicativo mais simples do Express que é possível criar. Ele
é um aplicativo de arquivo único — não é o que você iria obter usando o Gerador Express,
que cria a estrutura para um aplicativo completo com inúmeros arquivos JavaScript, modelos Jade, e subdiretórios para vários
propósitos.


Primeiro crie um diretório chamado myapp,
mude para ele e execute o npm init. Em seguida
instale o express como uma dependência, de acordo com o guia de instalação.

No diretório myapp, crie um arquivo chamado app.js e inclua o seguinte código:

const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


O aplicativo inicia um servidor e escuta a porta 3000 por
conexões. O aplicativo responde com “Hello World!” à solicitações
para a URL raiz (/) ou rota. Para
todos os outros caminhos, ele irá responder com um 404 Não Encontrado.


  O req (solicitação) e res
(resposta) são os mesmos objetos que o Node fornece, para que seja
possível chamar o req.pipe(),
req.on('data', callback), e qualquer outra coisa
que desejaria fazer sem o envolvimento do Express.


Execute o aplicativo com o seguinte comando:

$ node app.js


Em seguida, carregue http://localhost:3000/ em
um navegador para visualizar a saída


              
    
    Edit this page\n\nExemplo Hello World


  Este é essencialmente o aplicativo mais simples do Express que é possível criar. Ele
é um aplicativo de arquivo único — não é o que você iria obter usando o Gerador Express,
que cria a estrutura para um aplicativo completo com inúmeros arquivos JavaScript, modelos Jade, e subdiretórios para vários
propósitos.


Primeiro crie um diretório chamado myapp,
mude para ele e execute o npm init. Em seguida
instale o express como uma dependência, de acordo com o guia de instalação.

No diretório myapp, crie um arquivo chamado app.js e inclua o seguinte código:

const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


O aplicativo inicia um servidor e escuta a porta 3000 por
conexões. O aplicativo responde com “Hello World!” à solicitações
para a URL raiz (/) ou rota. Para
todos os outros caminhos, ele irá responder com um 404 Não Encontrado.


  O req (solicitação) e res
(resposta) são os mesmos objetos que o Node fornece, para que seja
possível chamar o req.pipe(),
req.on('data', callback), e qualquer outra coisa
que desejaria fazer sem o envolvimento do Express.


Execute o aplicativo com o seguinte comando:

$ node app.js


Em seguida, carregue http://localhost:3000/ em
um navegador para visualizar a saída


              
    
    Edit this page\n\n\n\nHello world príklad


  Toto bude v podstate najjednoduchšia Express aplikácia akú možete vytvoriť. Aplikácia s jedným súborom — nie taká, ako keby ste použili Express generátor, ktorý vytvorí základnú štruktúru pre plnohodnotnú aplikáciu s niekoľkými JavaScript súbormi, Jade templatami a pod-adresármi pre rôzne účely.


Najskôr si vytvorte priečinok s názvom myapp, presuňte sa tam a spustite príkaz npm init. Potom nainštalujte express ako dependenciu podľa inštalačnej príručky.

V priečinku myapp vytvorte súbor s názvom app.js a vložte do neho nasledovný kód:

const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


Aplikácia naštartuje server a na porte 3000 začne počúvať na pripojenia. Aplikácia odpovie “Hello World!” na request na hlavnú URL (/) alebo route. Pre každú inú URL odpovie prostredníctvom 404 Not Found.


  Request (požiadavka) req a response (odpoveď) res sú presne rovnaké objekty, ktoré Node štandardne poskytuje, takže môžete spraviť req.pipe(), req.on('data', callback) a hocičo iné, čo by ste spravili v prípade, ak by ste nepoužili Express.


Spustite aplikáciu pomocou nasledujúceho príkazu:

$ node app.js


Potom v prehliadači zadajte http://localhost:3000/ a pozrite si výstup.


              
    
    Edit this page\n\nHello world príklad


  Toto bude v podstate najjednoduchšia Express aplikácia akú možete vytvoriť. Aplikácia s jedným súborom — nie taká, ako keby ste použili Express generátor, ktorý vytvorí základnú štruktúru pre plnohodnotnú aplikáciu s niekoľkými JavaScript súbormi, Jade templatami a pod-adresármi pre rôzne účely.


Najskôr si vytvorte priečinok s názvom myapp, presuňte sa tam a spustite príkaz npm init. Potom nainštalujte express ako dependenciu podľa inštalačnej príručky.

V priečinku myapp vytvorte súbor s názvom app.js a vložte do neho nasledovný kód:

const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


Aplikácia naštartuje server a na porte 3000 začne počúvať na pripojenia. Aplikácia odpovie “Hello World!” na request na hlavnú URL (/) alebo route. Pre každú inú URL odpovie prostredníctvom 404 Not Found.


  Request (požiadavka) req a response (odpoveď) res sú presne rovnaké objekty, ktoré Node štandardne poskytuje, takže môžete spraviť req.pipe(), req.on('data', callback) a hocičo iné, čo by ste spravili v prípade, ak by ste nepoužili Express.


Spustite aplikáciu pomocou nasledujúceho príkazu:

$ node app.js


Potom v prehliadači zadajte http://localhost:3000/ a pozrite si výstup.


              
    
    Edit this page\n\n\n\nПриклад виводу “Hello world”


  Далі показано дуже спрощений варіант створення застосунку Express. Тут використовується єдиний файл — тобто не те, що ви отримуєте в результаті роботи генератора Express, який створює каркас для повноцінного, хоча й мінімалістичного застосунку, з декількома файлами JavaScript, шаблонами Jade,
та субдиректоріями для деяких потреб.


Для початку, створіть директорію з ім’ям myapp, перейдіть в неї та запустіть npm init. Потім встановіть express як залежність,
так як це показано в керівництві встановлення.

В директорії myapp, створіть файл з ім’ям app.js та додайте наступний код:

const express = require('express')
const app = express()

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(3000, () => {
  console.log('Приклад застосунку, який прослуховує 3000-ий порт!')
})


Цей скрипт запускає сервер та прослуховує з’єднання на 3000-му порті. В результаті виводиться “Hello World!”,
коли запити адресуються до кореневого URL (/) або кореневого маршруту. Для усіх інших адрес формується відповідь 404 Not Found.


  Змінні req (request) та res (response) містять ті ж об’єкти, які надає Node.js, тобто ви можете викликати
req.pipe(), req.on('data', callback), та виконувати будь-які інші дії без участі Express.


Запустіть застосунок наступною командою:

$ node app.js


Після чого, відкрийте браузер за адресою http://localhost:3000/ щоб побачити результат.

              
    
    Edit this page\n\nПриклад виводу “Hello world”


  Далі показано дуже спрощений варіант створення застосунку Express. Тут використовується єдиний файл — тобто не те, що ви отримуєте в результаті роботи генератора Express, який створює каркас для повноцінного, хоча й мінімалістичного застосунку, з декількома файлами JavaScript, шаблонами Jade,
та субдиректоріями для деяких потреб.


Для початку, створіть директорію з ім’ям myapp, перейдіть в неї та запустіть npm init. Потім встановіть express як залежність,
так як це показано в керівництві встановлення.

В директорії myapp, створіть файл з ім’ям app.js та додайте наступний код:

const express = require('express')
const app = express()

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(3000, () => {
  console.log('Приклад застосунку, який прослуховує 3000-ий порт!')
})


Цей скрипт запускає сервер та прослуховує з’єднання на 3000-му порті. В результаті виводиться “Hello World!”,
коли запити адресуються до кореневого URL (/) або кореневого маршруту. Для усіх інших адрес формується відповідь 404 Not Found.


  Змінні req (request) та res (response) містять ті ж об’єкти, які надає Node.js, тобто ви можете викликати
req.pipe(), req.on('data', callback), та виконувати будь-які інші дії без участі Express.


Запустіть застосунок наступною командою:

$ node app.js


Після чого, відкрийте браузер за адресою http://localhost:3000/ щоб побачити результат.

              
    
    Edit this page\n\n\n\nHello world

Bu yerda Express dasturga eng sodda misol keltirilgan.

const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})



  req (request) va res (response) Node taqdim etayotgan obyektlar hisoblanadi, shuning uchun
req.pipe(), req.on('data', callback) Express talab qilmaydigan boshqa obyektlar.


Dastur serverni ishga tushuradi va 3000 portdagi aloqani eshitib turadi. Javob sifatida bosh sahifaga “Hello World!” so’zi jo’natiladi. Qolgan barcha sahifalarga esa 404 Not Found javobi jo’natiladi.

Kodni yozib, app.js faylida saqlab qoying. Uni ishga tushurish uchun quyidagi buyruqni ishga tushiring:

$ node app.js


Natijani ko’rish uchun, brauzerdan http://localhost:3000/ manziliga kiring.

              
    
    Edit this page\n\nHello world

Bu yerda Express dasturga eng sodda misol keltirilgan.

const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})



  req (request) va res (response) Node taqdim etayotgan obyektlar hisoblanadi, shuning uchun
req.pipe(), req.on('data', callback) Express talab qilmaydigan boshqa obyektlar.


Dastur serverni ishga tushuradi va 3000 portdagi aloqani eshitib turadi. Javob sifatida bosh sahifaga “Hello World!” so’zi jo’natiladi. Qolgan barcha sahifalarga esa 404 Not Found javobi jo’natiladi.

Kodni yozib, app.js faylida saqlab qoying. Uni ishga tushurish uchun quyidagi buyruqni ishga tushiring:

$ node app.js


Natijani ko’rish uchun, brauzerdan http://localhost:3000/ manziliga kiring.

              
    
    Edit this page\n\n\n\nMerhaba Dünya Örneği


  Aşağıda verilmiş olan, Express ile oluşturabileceğiniz en basit uygulamadır. Bu, birçok JavaScript dosyası, Jade şablonları ve çeşitli alt dizinler içeren Express generator ile oluşturacağınız projelerin aksine tek dosyadan oluşan bir projedir.


const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Merhaba Dünya!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


Bu uygulama bir sunucu çalıştırır ve gelen bağlantılar için 3000 portunu dinler. (/) kök dizinine gelen isteklere “Hello World!” ile yanıt verir. Bunun haricindeki tüm adreslere, 404 Not Found hatası verecektir.

Bilgisayarınızda Çalıştırmak

İlk olarak myapp adında bir dizin oluşturun, o dizine geçin ve npm init komutunu çalıştırın. Sonra expressi bu sayfada gösterildiği gibi bir bağımlılık olarak kurun.

myapp dizininde app.js adında bir dosya oluşturun ve yukarıdaki kodu bu dosyaya kopyalayın.


  req (request/istek) ve res (response/cevap) objeleri Node’da bulunanlar ile birebir aynıdır, bu yüzden
req.pipe(), req.on('data', callback), gibi komutları Express dahil olmadan kullanabilirsiniz.


Uygulamayı aşağıdaki komutla çalıştırın:

$ node app.js


Sonucu görmek için sunucunuzda http://localhost:3000/ adresini ziyaret edin.

Önceki: Kurulum     Sonraki: Express Oluşturucu 


              
    
    Edit this page\n\nMerhaba Dünya Örneği


  Aşağıda verilmiş olan, Express ile oluşturabileceğiniz en basit uygulamadır. Bu, birçok JavaScript dosyası, Jade şablonları ve çeşitli alt dizinler içeren Express generator ile oluşturacağınız projelerin aksine tek dosyadan oluşan bir projedir.


const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Merhaba Dünya!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


Bu uygulama bir sunucu çalıştırır ve gelen bağlantılar için 3000 portunu dinler. (/) kök dizinine gelen isteklere “Hello World!” ile yanıt verir. Bunun haricindeki tüm adreslere, 404 Not Found hatası verecektir.

Bilgisayarınızda Çalıştırmak

İlk olarak myapp adında bir dizin oluşturun, o dizine geçin ve npm init komutunu çalıştırın. Sonra expressi bu sayfada gösterildiği gibi bir bağımlılık olarak kurun.

myapp dizininde app.js adında bir dosya oluşturun ve yukarıdaki kodu bu dosyaya kopyalayın.


  req (request/istek) ve res (response/cevap) objeleri Node’da bulunanlar ile birebir aynıdır, bu yüzden
req.pipe(), req.on('data', callback), gibi komutları Express dahil olmadan kullanabilirsiniz.


Uygulamayı aşağıdaki komutla çalıştırın:

$ node app.js


Sonucu görmek için sunucunuzda http://localhost:3000/ adresini ziyaret edin.

Önceki: Kurulum     Sonraki: Express Oluşturucu 


              
    
    Edit this page\n\n\n\nตัวอย่าง Hello world


  โค้ดด้านล่างนี้เป็นแอปพลิเคชัน Express จำเป็นแบบง่ายที่สุดที่คุณสามารถสร้างขึ้นได้ โดยเป็นไฟล์ app ไฟล์เดียว — ไม่ใช้ โค้ดที่ได้จาก Express generator ที่สร้างโครงสร้างเริ่มต้นสำหรับแอปพลิเคชันตัวเต็มที่มีไฟล์ JavaScript มากมาย และไดเรทอรีย่อยสำหรับวัตถุประสงค์ต่างๆ


const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


app นี้จะเริ่มต้นเซิร์ฟเวอร์และเฝ้าตรวจสอบ (listen) การเชื่อมต่อที่พอร์ต 3000 โดยที่ app จะตอบสนองด้วงคำว่า “Hello World!” สำหรับการร้องขอ
มายัง root URL (/) หรือ route แต่สำหรับ path อื่นๆ app จะตอบสนองด้วย 404 Not Found

รันบนเครื่องของคุณ

เริ่มต้นด้วยการสร้างไดเรกทอรีชื่อว่า myapp เปลี่ยนไปที่ไดเรกทอรีที่สร้างขึ้นแล้วใสคำสั่ง npm init แล้วติดตั้ง express และ dependency ต่างๆ ดังขั้นตอนการติดตั้ง

ในไดเรกทอรี myapp สร้างไฟล์ app.js ขึ้นมาและคัดลอกโค้ดจากตัวอย่างข้างบนมากใส่ในไฟล์


  req (คำร้องขอ) และ res (คำตอบสนอง) เป็นอ็อบเจกต์เดียวกันที่จัดให้โดย Node ซึ่งคุณสมารถเรียกใช้ req.pip() req.on('data', callback) และอื่นๆ โดยไม่ต้องเรียกใช้ Express


รัน app ด้วยคำสั่งนี้:

$ node app.js


แล้วโหลด http://localhost:3000/ ในเว็บเบราว์เซอร์เพื่อดูผลลัพธ์

              
    
    Edit this page\n\nตัวอย่าง Hello world


  โค้ดด้านล่างนี้เป็นแอปพลิเคชัน Express จำเป็นแบบง่ายที่สุดที่คุณสามารถสร้างขึ้นได้ โดยเป็นไฟล์ app ไฟล์เดียว — ไม่ใช้ โค้ดที่ได้จาก Express generator ที่สร้างโครงสร้างเริ่มต้นสำหรับแอปพลิเคชันตัวเต็มที่มีไฟล์ JavaScript มากมาย และไดเรทอรีย่อยสำหรับวัตถุประสงค์ต่างๆ


const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


app นี้จะเริ่มต้นเซิร์ฟเวอร์และเฝ้าตรวจสอบ (listen) การเชื่อมต่อที่พอร์ต 3000 โดยที่ app จะตอบสนองด้วงคำว่า “Hello World!” สำหรับการร้องขอ
มายัง root URL (/) หรือ route แต่สำหรับ path อื่นๆ app จะตอบสนองด้วย 404 Not Found

รันบนเครื่องของคุณ

เริ่มต้นด้วยการสร้างไดเรกทอรีชื่อว่า myapp เปลี่ยนไปที่ไดเรกทอรีที่สร้างขึ้นแล้วใสคำสั่ง npm init แล้วติดตั้ง express และ dependency ต่างๆ ดังขั้นตอนการติดตั้ง

ในไดเรกทอรี myapp สร้างไฟล์ app.js ขึ้นมาและคัดลอกโค้ดจากตัวอย่างข้างบนมากใส่ในไฟล์


  req (คำร้องขอ) และ res (คำตอบสนอง) เป็นอ็อบเจกต์เดียวกันที่จัดให้โดย Node ซึ่งคุณสมารถเรียกใช้ req.pip() req.on('data', callback) และอื่นๆ โดยไม่ต้องเรียกใช้ Express


รัน app ด้วยคำสั่งนี้:

$ node app.js


แล้วโหลด http://localhost:3000/ ในเว็บเบราว์เซอร์เพื่อดูผลลัพธ์

              
    
    Edit this page\n\n\n\nContoh hello world


  Contoh di bawah ini pada dasarnya adalah aplikasi Express paling sederhana yang dapat Anda buat. Ini adalah aplikasi file tunggal — bukan apa yang akan Anda dapatkan jika menggunakan Generator Express, yang membuat struktur untuk aplikasi lengkap dengan banyak file JavaScript, dengan templat Jade, dan sub- direktori untuk berbagai tujuan.


const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


Aplikasi ini memulai server dan mendengarkan koneksi pada port 3000. Aplikasi merespon dengan “Hello World!” untuk request
ke URL root (/) atau route. Untuk setiap jalur lainnya, ia akan merespons dengan 404 Not Found.

Berjalan secara Lokal

Pertama buat direktori bernama myapp, masuk ke direktori tersebut dan jalankan npm init. Kemudian, instal express sebagai dependensi, sesuai dengan panduan instalasi.

Di direktori myapp, buat file bernama app.js dan salin kode dari contoh di atas.


  req (request) dan res (response) adalah objects yang sama persis dengan yang disediakan Node, sehingga Anda dapat memanggilnya
req.pipe(), req.on('data', callback), dan apa pun yang akan Anda lakukan tanpa melibatkan Express.


Jalankan aplikasi dengan perintah berikut:

$ node app.js


Kemudian, kunjungi http://localhost:3000/ di browser untuk melihat hasilnya.

Previous: Installing     Next: Express Generator 

              
    
    Edit this page\n\nContoh hello world


  Contoh di bawah ini pada dasarnya adalah aplikasi Express paling sederhana yang dapat Anda buat. Ini adalah aplikasi file tunggal — bukan apa yang akan Anda dapatkan jika menggunakan Generator Express, yang membuat struktur untuk aplikasi lengkap dengan banyak file JavaScript, dengan templat Jade, dan sub- direktori untuk berbagai tujuan.


const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


Aplikasi ini memulai server dan mendengarkan koneksi pada port 3000. Aplikasi merespon dengan “Hello World!” untuk request
ke URL root (/) atau route. Untuk setiap jalur lainnya, ia akan merespons dengan 404 Not Found.

Berjalan secara Lokal

Pertama buat direktori bernama myapp, masuk ke direktori tersebut dan jalankan npm init. Kemudian, instal express sebagai dependensi, sesuai dengan panduan instalasi.

Di direktori myapp, buat file bernama app.js dan salin kode dari contoh di atas.


  req (request) dan res (response) adalah objects yang sama persis dengan yang disediakan Node, sehingga Anda dapat memanggilnya
req.pipe(), req.on('data', callback), dan apa pun yang akan Anda lakukan tanpa melibatkan Express.


Jalankan aplikasi dengan perintah berikut:

$ node app.js


Kemudian, kunjungi http://localhost:3000/ di browser untuk melihat hasilnya.

Previous: Installing     Next: Express Generator 

              
    
    Edit this page\n\n\n\nHello world example


  Embedded below is essentially the simplest Express app you can create. It is a single file app — not what you’d get if you use the Express generator, which creates the scaffolding for a full app with numerous JavaScript files, Jade templates, and sub-directories for various purposes.


const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


This app starts a server and listens on port 3000 for connections. The app responds with “Hello World!” for requests
to the root URL (/) or route. For every other path, it will respond with a 404 Not Found.

Running Locally

First create a directory named myapp, change to it and run npm init. Then, install express as a dependency, as per the installation guide.

In the myapp directory, create a file named app.js and copy the code from the example above.


  The req (request) and res (response) are the exact same objects that Node provides, so you can invoke
req.pipe(), req.on('data', callback), and anything else you would do without Express involved.


Run the app with the following command:

$ node app.js


Then, load http://localhost:3000/ in a browser to see the output.

Previous: Installing     Next: Express Generator 

              
    
    Edit this page\n\nHello world example


  Embedded below is essentially the simplest Express app you can create. It is a single file app — not what you’d get if you use the Express generator, which creates the scaffolding for a full app with numerous JavaScript files, Jade templates, and sub-directories for various purposes.


const express = require('express')
const app = express()
const port = 3000

app.get('/', (req, res) => {
  res.send('Hello World!')
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})


This app starts a server and listens on port 3000 for connections. The app responds with “Hello World!” for requests
to the root URL (/) or route. For every other path, it will respond with a 404 Not Found.

Running Locally

First create a directory named myapp, change to it and run npm init. Then, install express as a dependency, as per the installation guide.

In the myapp directory, create a file named app.js and copy the code from the example above.


  The req (request) and res (response) are the exact same objects that Node provides, so you can invoke
req.pipe(), req.on('data', callback), and anything else you would do without Express involved.


Run the app with the following command:

$ node app.js


Then, load http://localhost:3000/ in a browser to see the output.

Previous: Installing     Next: Express Generator 

              
    
    Edit this page\n\n\n\nGénérateur d’applications Express

Utilisez l’outil de générateur d’applications, express, pour créer rapidement un squelette d’application.

Installez express à l’aide de la commande suivante :

$ npm install express-generator -g


Affichez les options de commande à l’aide de l’option -h :

$ express -h

  Usage: express [options][dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view &lt;engine&gt; add view &lt;engine&gt; support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


Par exemple, ce code crée une application Express nomée myapp. L’application sera crée dans le dossier myapp, lui meme placé dans le repertoir de travail courant. Le moteur de vue sera configuré avec Pug:

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


Ensuite, installez les dépendances :

$ cd myapp
$ npm install


Sous MacOS ou Linux, exécutez l’application à l’aide de la commande suivante :

$ DEBUG=myapp:* npm start


Sous Windows, utilisez la commande suivante :

> set DEBUG=myapp:* & npm start


Ensuite, chargez ‘http://hôte_local:3000/’ dans votre navigateur pour accéder à l’application.

L’application générée possède la structure de répertoire suivante :

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  La structure d’application créée par le générateur est l’une des nombreuses manières possibles de structurer les applications Express. Vous avez toute latitude pour l’utiliser ou la modifier en fonction de vos besoins.


              
    
    Edit this page\n\nGénérateur d’applications Express

Utilisez l’outil de générateur d’applications, express, pour créer rapidement un squelette d’application.

Installez express à l’aide de la commande suivante :

$ npm install express-generator -g


Affichez les options de commande à l’aide de l’option -h :

$ express -h

  Usage: express [options][dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view &lt;engine&gt; add view &lt;engine&gt; support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


Par exemple, ce code crée une application Express nomée myapp. L’application sera crée dans le dossier myapp, lui meme placé dans le repertoir de travail courant. Le moteur de vue sera configuré avec Pug:

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


Ensuite, installez les dépendances :

$ cd myapp
$ npm install


Sous MacOS ou Linux, exécutez l’application à l’aide de la commande suivante :

$ DEBUG=myapp:* npm start


Sous Windows, utilisez la commande suivante :

> set DEBUG=myapp:* & npm start


Ensuite, chargez ‘http://hôte_local:3000/’ dans votre navigateur pour accéder à l’application.

L’application générée possède la structure de répertoire suivante :

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  La structure d’application créée par le générateur est l’une des nombreuses manières possibles de structurer les applications Express. Vous avez toute latitude pour l’utiliser ou la modifier en fonction de vos besoins.


              
    
    Edit this page\n\n\n\nExpress-Anwendungsgenerator

Mit dem Application Generator Tool express können Sie innerhalb kürzester Zeit ein Anwendungsgerüst erstellen.

Installieren Sie express mit dem folgenden Befehl:

$ npm install express-generator -g


Zeigen Sie die Befehlsoptionen mit der Option -h an:

$ express -h

  Usage: express [options][dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view &lt;engine&gt; add view &lt;engine&gt; support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


Im folgenden Beispiel wird eine Express-Anwendung mit dem Namen myapp im aktuellen Arbeitsverzeichnis erstellt:

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


Installieren Sie dann Abhängigkeiten:

$ cd myapp
$ npm install


Führen Sie unter MacOS oder Linux die Anwendung mit diesem Befehl aus:

$ DEBUG=myapp:* npm start


Verwenden Sie unter Windows diesen Befehl:

> set DEBUG=myapp:* & npm start


Laden Sie dann http://localhost:3000/ in Ihren Browser, um auf die Anwendung zuzugreifen.

Die erstellte Anwendung hat die folgende Verzeichnisstruktur:

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  Die vom Generator erstellte Anwendungsstruktur ist nur eine der vielen Möglichkeiten, Express-Anwendungen zu strukturieren. Sie können diese Struktur verwenden oder sie an Ihre Anforderungen anpassen.


              
    
    Edit this page\n\nExpress-Anwendungsgenerator

Mit dem Application Generator Tool express können Sie innerhalb kürzester Zeit ein Anwendungsgerüst erstellen.

Installieren Sie express mit dem folgenden Befehl:

$ npm install express-generator -g


Zeigen Sie die Befehlsoptionen mit der Option -h an:

$ express -h

  Usage: express [options][dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view &lt;engine&gt; add view &lt;engine&gt; support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


Im folgenden Beispiel wird eine Express-Anwendung mit dem Namen myapp im aktuellen Arbeitsverzeichnis erstellt:

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


Installieren Sie dann Abhängigkeiten:

$ cd myapp
$ npm install


Führen Sie unter MacOS oder Linux die Anwendung mit diesem Befehl aus:

$ DEBUG=myapp:* npm start


Verwenden Sie unter Windows diesen Befehl:

> set DEBUG=myapp:* & npm start


Laden Sie dann http://localhost:3000/ in Ihren Browser, um auf die Anwendung zuzugreifen.

Die erstellte Anwendung hat die folgende Verzeichnisstruktur:

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  Die vom Generator erstellte Anwendungsstruktur ist nur eine der vielen Möglichkeiten, Express-Anwendungen zu strukturieren. Sie können diese Struktur verwenden oder sie an Ihre Anforderungen anpassen.


              
    
    Edit this page\n\n\n\nGenerador de aplicaciones Express

Utilice la herramienta de generador de aplicaciones, express, para crear rápidamente un esqueleto de aplicación.

Instale express con el siguiente mandato:

$ npm install express-generator -g


Muestre las opciones de mandato con la opción -h:

$ express -h

  Usage: express [options][dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view &lt;engine&gt; add view &lt;engine&gt; support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


Por ejemplo, el código siguiente crea una aplicación Express denominada myapp. La aplicación será creada en una carpeta llamada myapp en el directorio de trabajo actual y el motor de vistas será asignado a Pug:

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


A continuación, instale las dependencias:

$ cd myapp
$ npm install


En MacOS o Linux, ejecute la aplicación con este mandato:

$ DEBUG=myapp:* npm start


En Windows, utilice este mandato:

> set DEBUG=myapp:* & npm start


A continuación, cargue http://localhost:3000/ en el navegador para acceder a la aplicación.

La aplicación generada tiene la siguiente estructura de directorios:

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  La estructura de la aplicación creada por el generador es sólo una de las muchas formas de estructurar las aplicaciones Express. Puede utilizar esta estructura o modificarla según sus necesidades.


              
    
    Edit this page\n\nGenerador de aplicaciones Express

Utilice la herramienta de generador de aplicaciones, express, para crear rápidamente un esqueleto de aplicación.

Instale express con el siguiente mandato:

$ npm install express-generator -g


Muestre las opciones de mandato con la opción -h:

$ express -h

  Usage: express [options][dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view &lt;engine&gt; add view &lt;engine&gt; support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


Por ejemplo, el código siguiente crea una aplicación Express denominada myapp. La aplicación será creada en una carpeta llamada myapp en el directorio de trabajo actual y el motor de vistas será asignado a Pug:

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


A continuación, instale las dependencias:

$ cd myapp
$ npm install


En MacOS o Linux, ejecute la aplicación con este mandato:

$ DEBUG=myapp:* npm start


En Windows, utilice este mandato:

> set DEBUG=myapp:* & npm start


A continuación, cargue http://localhost:3000/ en el navegador para acceder a la aplicación.

La aplicación generada tiene la siguiente estructura de directorios:

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  La estructura de la aplicación creada por el generador es sólo una de las muchas formas de estructurar las aplicaciones Express. Puede utilizar esta estructura o modificarla según sus necesidades.


              
    
    Edit this page\n\n\n\nProgramma di creazione applicazione Express

Utilizzare lo strumento di creazione dell’applicazione, express, per creare velocemente una struttura dell’applicazione.

Installare express con il seguente comando:

$ npm install express-generator -g


Visualizzare le opzioni del comando con l’opzione -h:

$ express -h

  Usage: express [options][dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view &lt;engine&gt; add view &lt;engine&gt; support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


Ad esempio, quanto segue crea un’applicazione Express denominata myapp nella directory di lavoro corrente:

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


Successivamente, installare le dipendenze:

$ cd myapp
$ npm install


Su MacOS o Linux, eseguire l’applicazione con il seguente comando:

$ DEBUG=myapp:* npm start


Su Windows, utilizzare questo comando:

> set DEBUG=myapp:* & npm start


Quindi caricare http://localhost:3000/ sul browser per accedere all’applicazione.

L’applicazione creata dispone della seguente struttura per la directory:

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  La struttura dell’applicazione creata dal programma di creazione è solo uno dei tanti modi disponibili per creare la struttura delle applicazioni Express. È possibile utilizzare questa struttura o modificarla a seconda delle proprie necessità.


              
    
    Edit this page\n\nProgramma di creazione applicazione Express

Utilizzare lo strumento di creazione dell’applicazione, express, per creare velocemente una struttura dell’applicazione.

Installare express con il seguente comando:

$ npm install express-generator -g


Visualizzare le opzioni del comando con l’opzione -h:

$ express -h

  Usage: express [options][dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view &lt;engine&gt; add view &lt;engine&gt; support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


Ad esempio, quanto segue crea un’applicazione Express denominata myapp nella directory di lavoro corrente:

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


Successivamente, installare le dipendenze:

$ cd myapp
$ npm install


Su MacOS o Linux, eseguire l’applicazione con il seguente comando:

$ DEBUG=myapp:* npm start


Su Windows, utilizzare questo comando:

> set DEBUG=myapp:* & npm start


Quindi caricare http://localhost:3000/ sul browser per accedere all’applicazione.

L’applicazione creata dispone della seguente struttura per la directory:

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  La struttura dell’applicazione creata dal programma di creazione è solo uno dei tanti modi disponibili per creare la struttura delle applicazioni Express. È possibile utilizzare questa struttura o modificarla a seconda delle proprie necessità.


              
    
    Edit this page\n\n\n\nExpress のアプリケーション生成プログラム

アプリケーション生成プログラム・ツールの express を使用すると、アプリケーション・スケルトンを素早く作成できます。

次のコマンドを使用して、express をインストールします。

$ npm install express-generator -g


-h オプションを指定してコマンド・オプションを表示します。

$ express -h

  Usage: express [options][dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view &lt;engine&gt; add view &lt;engine&gt; support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


例えば、以下のコマンドでは、現行作業ディレクトリーに myapp という Express アプリケーションを作成します。

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


次に、依存関係をインストールします。

$ cd myapp
$ npm install


MacOS または Linux では、次のコマンドによってアプリケーションを実行します。

$ DEBUG=myapp:* npm start


Windows では、次のコマンドを使用します。

> set DEBUG=myapp:* & npm start


次に、ブラウザーに http://localhost:3000/ をロードして、アプリケーションにアクセスします。

生成されたアプリケーションには、以下のディレクトリー構造があります。

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  ここで生成プログラムによって作成されたアプリケーション構造は、Express アプリケーションを作成するための数多くの方法の 1 つにすぎません。この構造を自由に使用したり、ニーズに合わせて変更したりしてください。


              
    
    Edit this page\n\nExpress のアプリケーション生成プログラム

アプリケーション生成プログラム・ツールの express を使用すると、アプリケーション・スケルトンを素早く作成できます。

次のコマンドを使用して、express をインストールします。

$ npm install express-generator -g


-h オプションを指定してコマンド・オプションを表示します。

$ express -h

  Usage: express [options][dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view &lt;engine&gt; add view &lt;engine&gt; support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


例えば、以下のコマンドでは、現行作業ディレクトリーに myapp という Express アプリケーションを作成します。

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


次に、依存関係をインストールします。

$ cd myapp
$ npm install


MacOS または Linux では、次のコマンドによってアプリケーションを実行します。

$ DEBUG=myapp:* npm start


Windows では、次のコマンドを使用します。

> set DEBUG=myapp:* & npm start


次に、ブラウザーに http://localhost:3000/ をロードして、アプリケーションにアクセスします。

生成されたアプリケーションには、以下のディレクトリー構造があります。

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  ここで生成プログラムによって作成されたアプリケーション構造は、Express アプリケーションを作成するための数多くの方法の 1 つにすぎません。この構造を自由に使用したり、ニーズに合わせて変更したりしてください。


              
    
    Edit this page\n\n\n\nГенератор приложений Express

Для быстрого создания “скелета” приложения используется инструмент для генерации приложений express.

Установите express с помощью следующей команды:

$ npm install express-generator -g


Для просмотра опций команды воспользуйтесь опцией -h:

$ express -h

  Usage: express [options][dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view &lt;engine&gt; add view &lt;engine&gt; support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


Например, следующая команда создает приложение Express с именем myapp в текущем рабочем каталоге:

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


Затем установите зависимости:

$ cd myapp
$ npm install


В MacOS или Linux запустите приложение с помощью следующей команды:

$ DEBUG=myapp:* npm start


В Windows используется следующая команда:

> set DEBUG=myapp:* & npm start


Затем откройте страницу http://localhost:3000/ в браузере для доступа к приложению.

Структура каталогов сгенерированного приложения выглядит следующим образом:

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  Структура приложения, сгенерированная с помощью генератора, является всего лишь одним из множества способов организации структуры приложений Express. Вы можете использовать данную структуру или изменять ее в соответствии со своими потребностями.


              
    
    Edit this page\n\nГенератор приложений Express

Для быстрого создания “скелета” приложения используется инструмент для генерации приложений express.

Установите express с помощью следующей команды:

$ npm install express-generator -g


Для просмотра опций команды воспользуйтесь опцией -h:

$ express -h

  Usage: express [options][dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view &lt;engine&gt; add view &lt;engine&gt; support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


Например, следующая команда создает приложение Express с именем myapp в текущем рабочем каталоге:

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


Затем установите зависимости:

$ cd myapp
$ npm install


В MacOS или Linux запустите приложение с помощью следующей команды:

$ DEBUG=myapp:* npm start


В Windows используется следующая команда:

> set DEBUG=myapp:* & npm start


Затем откройте страницу http://localhost:3000/ в браузере для доступа к приложению.

Структура каталогов сгенерированного приложения выглядит следующим образом:

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  Структура приложения, сгенерированная с помощью генератора, является всего лишь одним из множества способов организации структуры приложений Express. Вы можете использовать данную структуру или изменять ее в соответствии со своими потребностями.


              
    
    Edit this page\n\n\n\nExpress 应用程序生成器

可使用应用程序生成器工具 (express-generator) 快速创建应用程序框架。

您可以使用 npx 命令（在 Node.js 8.2.0 中可用）运行应用程序生成器。

$ npx express-generator


对于早期的 Node 版本，可将应用程序生成器作为全局 npm 软件包安装，然后启动它。

$ npm install -g express-generator
$ express


使用 -h 选项显示命令选项：

$ express -h

  Usage: express [options][dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view &lt;engine&gt; add view &lt;engine&gt; support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


例如，以下语句在当前工作目录中创建名为 myapp 的 Express 应用程序并将视图引擎将设置为 Pug ：

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


然后安装依赖项：

$ cd myapp
$ npm install


在 MacOS 或 Linux 上，采用以下命令运行此应用程序：

$ DEBUG=myapp:* npm start


在 Windows 命令提示符上，使用以下命令：

> set DEBUG=myapp:* & npm start


在 Windows PowerShell 上，使用以下命令：

PS> $env:DEBUG='myapp:*'; npm start


然后在浏览器中输入 http://localhost:3000/ 以访问此应用程序。

生成的应用程序具有以下目录结构：

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  生成器创建的应用程序结构只是构造 Express 应用程序的众多方法之一。请随意使用此结构或者对其进行修改以最大程度满足自己的需求。


              
    
    Edit this page\n\nExpress 应用程序生成器

可使用应用程序生成器工具 (express-generator) 快速创建应用程序框架。

您可以使用 npx 命令（在 Node.js 8.2.0 中可用）运行应用程序生成器。

$ npx express-generator


对于早期的 Node 版本，可将应用程序生成器作为全局 npm 软件包安装，然后启动它。

$ npm install -g express-generator
$ express


使用 -h 选项显示命令选项：

$ express -h

  Usage: express [options][dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view &lt;engine&gt; add view &lt;engine&gt; support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


例如，以下语句在当前工作目录中创建名为 myapp 的 Express 应用程序并将视图引擎将设置为 Pug ：

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


然后安装依赖项：

$ cd myapp
$ npm install


在 MacOS 或 Linux 上，采用以下命令运行此应用程序：

$ DEBUG=myapp:* npm start


在 Windows 命令提示符上，使用以下命令：

> set DEBUG=myapp:* & npm start


在 Windows PowerShell 上，使用以下命令：

PS> $env:DEBUG='myapp:*'; npm start


然后在浏览器中输入 http://localhost:3000/ 以访问此应用程序。

生成的应用程序具有以下目录结构：

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  生成器创建的应用程序结构只是构造 Express 应用程序的众多方法之一。请随意使用此结构或者对其进行修改以最大程度满足自己的需求。


              
    
    Edit this page\n\n\n\nExpress 應用程式產生器

使用應用程式產生器工具 express，快速建立應用程式架構。

使用下列指令來安裝 express：

$ npm install express-generator -g


使用 -h 選項來顯示指令選項：

$ express -h

  Usage: express [options][dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view &lt;engine&gt; add view &lt;engine&gt; support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


舉例來說，以下是在現行工作目錄中建立一個名為 myapp 的 Express 應用程式：

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


然後安裝相依項目：

$ cd myapp
$ npm install


在 MacOS 或 Linux 中，使用下列指令來執行應用程式：

$ DEBUG=myapp:* npm start


在 Windows 中，使用下列指令：

> set DEBUG=myapp:* & npm start


然後在瀏覽器中載入 http://localhost:3000/，以存取應用程式。

產生的應用程式具有如下的目錄結構：

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  使用產生器來建立應用程式結構，只是多種用來建立 Express 應用程式結構的其中一種方式。您有權使用這種結構，或是加以修改盡量符合您的需求。


              
    
    Edit this page\n\nExpress 應用程式產生器

使用應用程式產生器工具 express，快速建立應用程式架構。

使用下列指令來安裝 express：

$ npm install express-generator -g


使用 -h 選項來顯示指令選項：

$ express -h

  Usage: express [options][dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view &lt;engine&gt; add view &lt;engine&gt; support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


舉例來說，以下是在現行工作目錄中建立一個名為 myapp 的 Express 應用程式：

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


然後安裝相依項目：

$ cd myapp
$ npm install


在 MacOS 或 Linux 中，使用下列指令來執行應用程式：

$ DEBUG=myapp:* npm start


在 Windows 中，使用下列指令：

> set DEBUG=myapp:* & npm start


然後在瀏覽器中載入 http://localhost:3000/，以存取應用程式。

產生的應用程式具有如下的目錄結構：

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  使用產生器來建立應用程式結構，只是多種用來建立 Express 應用程式結構的其中一種方式。您有權使用這種結構，或是加以修改盡量符合您的需求。


              
    
    Edit this page\n\n\n\nExpress 애플리케이션 생성기

애플리케이션의 골격을 신속하게 작성하려면 애플리케이션 생성기 도구인 express를 사용하십시오.

다음의 명령을 이용해 express를 설치하십시오.

$ npm install express-generator -g


다음과 같이 -h 옵션을 이용해 명령의 옵션을 표시하십시오.

$ express -h

  Usage: express [options][dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view &lt;engine&gt; add view &lt;engine&gt; support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


예를 들면, 다음의 예에서는 _myapp_라는 이름의 Express 앱을 현재 작업 디렉토리에 작성합니다.

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


이후 다음과 같이 종속 항목을 설치하십시오.

$ cd myapp
$ npm install


MacOS 또는 Linux에서는 다음 명령을 사용하여 앱을 실행하십시오.

$ DEBUG=myapp:* npm start


Windows에서는 다음 명령을 사용하십시오.

> set DEBUG=myapp:* & npm start


이후 브라우저에서 http://localhost:3000/을 로드하여 앱에 액세스하십시오.

생성된 앱은 다음과 같은 디렉토리 구조를 갖습니다.

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  생성기에 의해 작성된 앱 구조는 Express 앱을 구조화하는 여러 방법 중 하나에 불과합니다. 이러한 구조를 사용하거나 사용자의 요구사항에 가장 적합하도록 구조를 수정하십시오.


              
    
    Edit this page\n\nExpress 애플리케이션 생성기

애플리케이션의 골격을 신속하게 작성하려면 애플리케이션 생성기 도구인 express를 사용하십시오.

다음의 명령을 이용해 express를 설치하십시오.

$ npm install express-generator -g


다음과 같이 -h 옵션을 이용해 명령의 옵션을 표시하십시오.

$ express -h

  Usage: express [options][dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view &lt;engine&gt; add view &lt;engine&gt; support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


예를 들면, 다음의 예에서는 _myapp_라는 이름의 Express 앱을 현재 작업 디렉토리에 작성합니다.

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


이후 다음과 같이 종속 항목을 설치하십시오.

$ cd myapp
$ npm install


MacOS 또는 Linux에서는 다음 명령을 사용하여 앱을 실행하십시오.

$ DEBUG=myapp:* npm start


Windows에서는 다음 명령을 사용하십시오.

> set DEBUG=myapp:* & npm start


이후 브라우저에서 http://localhost:3000/을 로드하여 앱에 액세스하십시오.

생성된 앱은 다음과 같은 디렉토리 구조를 갖습니다.

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  생성기에 의해 작성된 앱 구조는 Express 앱을 구조화하는 여러 방법 중 하나에 불과합니다. 이러한 구조를 사용하거나 사용자의 요구사항에 가장 적합하도록 구조를 수정하십시오.


              
    
    Edit this page\n\n\n\nGerador de aplicativos do Express

Use a ferramenta geradora de aplicativos, express,
para rapidamente criar uma estrutura básica de aplicativo.

Instale o express com o comando a seguir:

$ npm install express-generator -g


Exiba as opções de comando com a opção -h:

$ express -h

  Usage: express [options][dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view &lt;engine&gt; add view &lt;engine&gt; support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


Por exemplo, o seguinte cria um aplicativo do Express chamado myapp
no diretório atualmente em funcionamento:

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


Em seguida instale as dependências:

$ cd myapp
$ npm install


No MacOS ou Linux, execute o aplicativo com este comando:

$ DEBUG=myapp:* npm start


No Windows, use este comando:

> set DEBUG=myapp:* & npm start


Em seguida carregue http://localhost:3000/ no seu navegador para acessar o aplicativo.

O aplicativo gerado possui a seguinte estrutura de diretórios:

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  A estrutura de aplicativo criada pelo gerador é apenas uma das várias maneiras de estruturar aplicativos do Express.
É possível utilizar esta estrutura ou modificá-la para melhor se adequar às suas necessidades.


              
    
    Edit this page\n\nGerador de aplicativos do Express

Use a ferramenta geradora de aplicativos, express,
para rapidamente criar uma estrutura básica de aplicativo.

Instale o express com o comando a seguir:

$ npm install express-generator -g


Exiba as opções de comando com a opção -h:

$ express -h

  Usage: express [options][dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view &lt;engine&gt; add view &lt;engine&gt; support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


Por exemplo, o seguinte cria um aplicativo do Express chamado myapp
no diretório atualmente em funcionamento:

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


Em seguida instale as dependências:

$ cd myapp
$ npm install


No MacOS ou Linux, execute o aplicativo com este comando:

$ DEBUG=myapp:* npm start


No Windows, use este comando:

> set DEBUG=myapp:* & npm start


Em seguida carregue http://localhost:3000/ no seu navegador para acessar o aplicativo.

O aplicativo gerado possui a seguinte estrutura de diretórios:

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  A estrutura de aplicativo criada pelo gerador é apenas uma das várias maneiras de estruturar aplicativos do Express.
É possível utilizar esta estrutura ou modificá-la para melhor se adequar às suas necessidades.


              
    
    Edit this page\n\n\n\nExpress generátor

Pre rýchle vygenerovanie skeletonu aplikácie môžete použit nástroj express-generator.

Nainštalujte express-generator pomocou nasledujúceho príkazu:

$ npm install express-generator -g


Pre zobrazenie ďalších možností príkazu zadajte prepínač -h:

$ express -h

  Usage: express [options] [dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view &lt;engine&gt; add view &lt;engine&gt; support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


Nasledujúci príkaz vytvorí v aktuálnom priečinku Express aplikáciu s názvom myapp:

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


Potom nainštalujte dependencie:

$ cd myapp
$ npm install


Na MacOS príp. Linux, spustíte aplikáciu príkazom:

$ DEBUG=myapp:* npm start


Na Windows, príkazom:

> set DEBUG=myapp:* & npm start


Potom v prehliadači zadajte http://localhost:3000/.

Vygenerovaná aplikácia má naslednovnú štruktúru priečinkov:

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  Takáto štruktúra aplikácie je len jedným z mnohých spôsobov usporiadania Express aplikácie. Môžete ju použit, alebo ju zmeniť tak, ako vám bude najlepšie vyhovovať.


              
    
    Edit this page\n\nExpress generátor

Pre rýchle vygenerovanie skeletonu aplikácie môžete použit nástroj express-generator.

Nainštalujte express-generator pomocou nasledujúceho príkazu:

$ npm install express-generator -g


Pre zobrazenie ďalších možností príkazu zadajte prepínač -h:

$ express -h

  Usage: express [options] [dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view &lt;engine&gt; add view &lt;engine&gt; support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


Nasledujúci príkaz vytvorí v aktuálnom priečinku Express aplikáciu s názvom myapp:

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


Potom nainštalujte dependencie:

$ cd myapp
$ npm install


Na MacOS príp. Linux, spustíte aplikáciu príkazom:

$ DEBUG=myapp:* npm start


Na Windows, príkazom:

> set DEBUG=myapp:* & npm start


Potom v prehliadači zadajte http://localhost:3000/.

Vygenerovaná aplikácia má naslednovnú štruktúru priečinkov:

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  Takáto štruktúra aplikácie je len jedným z mnohých spôsobov usporiadania Express aplikácie. Môžete ju použit, alebo ju zmeniť tak, ako vám bude najlepšie vyhovovať.


              
    
    Edit this page\n\n\n\nГенератор структури застосунків Express

Можна використовувати інструмент express-generator, для швидкого створення каркасу застосунку.

Встановлюється express-generator наступною командою:

$ npm install express-generator -g


З параметром -h можна проглянути доступні опції:

$ express -h

  Usage: express [options] [dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view &lt;engine&gt; add view &lt;engine&gt; support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


В наступному прикладі створюється каркас застосунку Express з іменем myapp в поточній директорії:

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


Після чого треба встановити залежності:

$ cd myapp
$ npm install


На MacOS чи Linux, запустіть застосунок такою командою:

$ DEBUG=myapp:* npm start


На Windows, запускайте так:

> set DEBUG=myapp:* & npm start


Тепер вводьте в адресному рядку браузера http://localhost:3000/.

Згенерований застосунок має наступну структуру директорій:

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  Створена структура за допомогою генератора є лише однією із багатьох можливих варіантів структури застосунків Express.
Не обмежуйте себе лише такою структурою, змінюйте її під свої потреби.


              
    
    Edit this page\n\nГенератор структури застосунків Express

Можна використовувати інструмент express-generator, для швидкого створення каркасу застосунку.

Встановлюється express-generator наступною командою:

$ npm install express-generator -g


З параметром -h можна проглянути доступні опції:

$ express -h

  Usage: express [options] [dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view &lt;engine&gt; add view &lt;engine&gt; support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


В наступному прикладі створюється каркас застосунку Express з іменем myapp в поточній директорії:

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


Після чого треба встановити залежності:

$ cd myapp
$ npm install


На MacOS чи Linux, запустіть застосунок такою командою:

$ DEBUG=myapp:* npm start


На Windows, запускайте так:

> set DEBUG=myapp:* & npm start


Тепер вводьте в адресному рядку браузера http://localhost:3000/.

Згенерований застосунок має наступну структуру директорій:

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  Створена структура за допомогою генератора є лише однією із багатьох можливих варіантів структури застосунків Express.
Не обмежуйте себе лише такою структурою, змінюйте її під свої потреби.


              
    
    Edit this page\n\n\n\nExpress dasturlar generatori

Dastur generatsiya qilish uchun express buyrug’idan foydalanishgiz mumkin, u dasturning asosiy qismini yaratib beradi.

Uni o’rnatish uchun quyidagi buyruqlardan foydalaning.

$ npm install express-generator -g


Qo’shimcha amallarda foydalanish uchun -h qo’shimchasini yozing:

$ express -h

  Usage: express [options] [dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view &lt;engine&gt; add view &lt;engine&gt; support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


Masalan, quyidagi buyruq myapp nomi dasturni yaratadi.

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


Keyin dasturning kerakli modullarni o’rnatish kerak bo’ladi:

$ cd myapp
$ npm install


Dasturni ishga tushurish (MacOS va Linux):

$ DEBUG=myapp ./bin/www


Windowsda esa, quyidagicha:

> set DEBUG=myapp & node .\bin\www


Undan keyin brauzerda http://localhost:3000/ manziligaa kirib dastur ishalayotganini tekshiring.

Generatsiya qilingan dasturning strukturasi quyidagicha bo’ladi.

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  Generator yordamida generatsiya qilingan struktra, Express dasturda yaratish mumkin bo’lgan strukturalardan bir usuli hisoblanadi. Siz bu strukturadan foydalanmasligingiz mumkin, o’zingizga kerakli ko’rinishda yaratishingiz mumkin.


              
    
    Edit this page\n\nExpress dasturlar generatori

Dastur generatsiya qilish uchun express buyrug’idan foydalanishgiz mumkin, u dasturning asosiy qismini yaratib beradi.

Uni o’rnatish uchun quyidagi buyruqlardan foydalaning.

$ npm install express-generator -g


Qo’shimcha amallarda foydalanish uchun -h qo’shimchasini yozing:

$ express -h

  Usage: express [options] [dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view &lt;engine&gt; add view &lt;engine&gt; support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


Masalan, quyidagi buyruq myapp nomi dasturni yaratadi.

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


Keyin dasturning kerakli modullarni o’rnatish kerak bo’ladi:

$ cd myapp
$ npm install


Dasturni ishga tushurish (MacOS va Linux):

$ DEBUG=myapp ./bin/www


Windowsda esa, quyidagicha:

> set DEBUG=myapp & node .\bin\www


Undan keyin brauzerda http://localhost:3000/ manziligaa kirib dastur ishalayotganini tekshiring.

Generatsiya qilingan dasturning strukturasi quyidagicha bo’ladi.

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  Generator yordamida generatsiya qilingan struktra, Express dasturda yaratish mumkin bo’lgan strukturalardan bir usuli hisoblanadi. Siz bu strukturadan foydalanmasligingiz mumkin, o’zingizga kerakli ko’rinishda yaratishingiz mumkin.


              
    
    Edit this page\n\n\n\nExpress uygulama oluşturucu

Çabukça bir uygulama iskeleti oluşturmak için, express-generator aracını kullanın.

express-generator paketi express komut-satır aracını kurar. Bunu yapmak için aşağıdaki komutu çalıştırın:

$ npm install express-generator -g


Komut seçeneklerini -h opsiyonu ile görüntüleyin:

$ express -h

  Usage: express [options] [dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view <engine> add view <engine> support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css <engine>  add stylesheet <engine> support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


aşağıdaki örnek, myapp adında bir Express uygulaması yaratır. Uygulama myapp dizininde barınacak ve görünüm (view) motoru Pug olarak ayarlanacaktır.

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


Daha sonrasında bağımlılıkları kurun:

$ cd myapp
$ npm install


MacOS veya Linux için uygulamayı bu komut ile çalıştırın:

$ DEBUG=myapp:* npm start


Windows için bu komutu kullanın:

> set DEBUG=myapp:* & npm start


Uygulamaya erişmek için tarayıcınızda http://localhost:3000/ adresini ziyaret edin.

Oluşturulan uygulamanın dizini aşağıdaki yapıda olacaktır:

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  Burada oluşturulan dizin yapısı, Express uygulamasını yapılandırabileceğiniz birçok seçenekten sadece birisidir. İhtiyacınıza en uygun şekilde bu yapıyı kullanabilir ya da düzenleyebilirsiniz.


Önceki: Merhaba Dünya     Sonraki: Basit Yol Atama

              
    
    Edit this page\n\nExpress uygulama oluşturucu

Çabukça bir uygulama iskeleti oluşturmak için, express-generator aracını kullanın.

express-generator paketi express komut-satır aracını kurar. Bunu yapmak için aşağıdaki komutu çalıştırın:

$ npm install express-generator -g


Komut seçeneklerini -h opsiyonu ile görüntüleyin:

$ express -h

  Usage: express [options] [dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view <engine> add view <engine> support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css <engine>  add stylesheet <engine> support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


aşağıdaki örnek, myapp adında bir Express uygulaması yaratır. Uygulama myapp dizininde barınacak ve görünüm (view) motoru Pug olarak ayarlanacaktır.

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


Daha sonrasında bağımlılıkları kurun:

$ cd myapp
$ npm install


MacOS veya Linux için uygulamayı bu komut ile çalıştırın:

$ DEBUG=myapp:* npm start


Windows için bu komutu kullanın:

> set DEBUG=myapp:* & npm start


Uygulamaya erişmek için tarayıcınızda http://localhost:3000/ adresini ziyaret edin.

Oluşturulan uygulamanın dizini aşağıdaki yapıda olacaktır:

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  Burada oluşturulan dizin yapısı, Express uygulamasını yapılandırabileceğiniz birçok seçenekten sadece birisidir. İhtiyacınıza en uygun şekilde bu yapıyı kullanabilir ya da düzenleyebilirsiniz.


Önceki: Merhaba Dünya     Sonraki: Basit Yol Atama

              
    
    Edit this page\n\n\n\nเครื่องมือสร้าง Express

ใช้เครื่องมือสร้าง โดยพินพ์คำสั่ง express-generator เพื่อสร้างโครงสร้างหลักของแอปพลิเคชันอย่างรวดเร็ว

express-generator ติดตั้งแพ็กเกจไปยังชุดคำสั่ง express  ใช้คำสั่งด้านล่างนี้เพื่อติดตั้ง:

$ npm install express-generator -g

แสดงตัวเลือกคำสั่งทั้งหมดด้วย h:

$ express -h

  Usage: express [options] [dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view <engine> add view <engine> support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css <engine>  add stylesheet <engine> support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory

สำหรับตัวอย่าง คำสั่งข้างล่างนี้เพื่อสร้าง Express app ที่ชื่อว่า myapp โดยจะสร้างโฟล์เดอร์ชื่อ myapp ในไดเรกเทอรีที่ใช้งานอยู่ และตั้ง view engine เป็น Pug:

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www

แล้วติดตั้งโมดูลเกี่ยวโยง (dependencies):

$ cd myapp
$ npm install


บน MacOS หรือ Linux รัน app ด้วยคำสั่งนี้:

$ DEBUG=myapp:* npm start


บน Windows ใช้คำสั่งนี้:

> set DEBUG=myapp:* & npm start


แล้วโหลด http://localhost:3000/ ในเว็บเบราว์เซอร์ของคุณเพื่อเข้าถึง app

หลังจากสร้าง app แล้วจะได้โครงสร้างไดเรกทอรีดังนี้:

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  โครงสร้าง app ที่สร้างโดยเครื่องมือสร้างเป็นเพียงวิธีหนึ่งของอีกหลายวิธี ของการสร้างโครงสร้าง app ของ Express สามารถใช้โครงสร้างนี้ได้ หรือว่าจะแก้ไขเพื่อให้เหมาะสมที่สุดสำหรับความต้องการของคุณ


              
    
    Edit this page\n\nเครื่องมือสร้าง Express

ใช้เครื่องมือสร้าง โดยพินพ์คำสั่ง express-generator เพื่อสร้างโครงสร้างหลักของแอปพลิเคชันอย่างรวดเร็ว

express-generator ติดตั้งแพ็กเกจไปยังชุดคำสั่ง express  ใช้คำสั่งด้านล่างนี้เพื่อติดตั้ง:

$ npm install express-generator -g

แสดงตัวเลือกคำสั่งทั้งหมดด้วย h:

$ express -h

  Usage: express [options] [dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view <engine> add view <engine> support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css <engine>  add stylesheet <engine> support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory

สำหรับตัวอย่าง คำสั่งข้างล่างนี้เพื่อสร้าง Express app ที่ชื่อว่า myapp โดยจะสร้างโฟล์เดอร์ชื่อ myapp ในไดเรกเทอรีที่ใช้งานอยู่ และตั้ง view engine เป็น Pug:

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www

แล้วติดตั้งโมดูลเกี่ยวโยง (dependencies):

$ cd myapp
$ npm install


บน MacOS หรือ Linux รัน app ด้วยคำสั่งนี้:

$ DEBUG=myapp:* npm start


บน Windows ใช้คำสั่งนี้:

> set DEBUG=myapp:* & npm start


แล้วโหลด http://localhost:3000/ ในเว็บเบราว์เซอร์ของคุณเพื่อเข้าถึง app

หลังจากสร้าง app แล้วจะได้โครงสร้างไดเรกทอรีดังนี้:

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  โครงสร้าง app ที่สร้างโดยเครื่องมือสร้างเป็นเพียงวิธีหนึ่งของอีกหลายวิธี ของการสร้างโครงสร้าง app ของ Express สามารถใช้โครงสร้างนี้ได้ หรือว่าจะแก้ไขเพื่อให้เหมาะสมที่สุดสำหรับความต้องการของคุณ


              
    
    Edit this page\n\n\n\nGenerator aplikasi Express

Gunakan alat generator aplikasi, express-generator, untuk membuat kerangka aplikasi dengan cepat.

Anda dapat menjalankan generator aplikasi dengan perintah npx (tersedia di Node.js versi 8.2.0).

$ npx express-generator


Untuk versi Node sebelumnya, instal generator aplikasi sebagai paket npm secara global lalu jalankan:

$ npm install -g express-generator
$ express


Tampilkan daftar opsi perintah dengan opsi -h:

$ express -h

  Usage: express [options] [dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view <engine> add view <engine> support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css <engine>  add stylesheet <engine> support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


Misal, tutorial berikut ini kita akan membuat aplikasi Express bernama myapp. Aplikasi akan dibuat dalam folder bernama myapp di direktori kerja saat ini dan view engine yang akan digunakan adalah Pug:

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


Kemudian instal semua dependensi project:

$ cd myapp
$ npm install


Di MacOS atau Linux, jalankan aplikasi dengan perintah ini:

$ DEBUG=myapp:* npm start


Di Command Prompt Windows, gunakan perintah ini:

> set DEBUG=myapp:* & npm start


Di PowerShell Windows, gunakan perintah ini:

PS> $env:DEBUG='myapp:*'; npm start


Kemudian, kunjungi http://localhost:3000/ di browser Anda untuk mengakses aplikasi.

Aplikasi yang dihasilkan memiliki struktur direktori sebagai berikut:

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  Struktur aplikasi yang dibuat oleh generator hanyalah salah satu dari banyak cara untuk membuat struktur aplikasi Express. Jangan ragu untuk menggunakan struktur ini atau memodifikasinya agar sesuai dengan kebutuhan Anda.


Previous: Hello World     Next: Basic routing

              
    
    Edit this page\n\nGenerator aplikasi Express

Gunakan alat generator aplikasi, express-generator, untuk membuat kerangka aplikasi dengan cepat.

Anda dapat menjalankan generator aplikasi dengan perintah npx (tersedia di Node.js versi 8.2.0).

$ npx express-generator


Untuk versi Node sebelumnya, instal generator aplikasi sebagai paket npm secara global lalu jalankan:

$ npm install -g express-generator
$ express


Tampilkan daftar opsi perintah dengan opsi -h:

$ express -h

  Usage: express [options] [dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view <engine> add view <engine> support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css <engine>  add stylesheet <engine> support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


Misal, tutorial berikut ini kita akan membuat aplikasi Express bernama myapp. Aplikasi akan dibuat dalam folder bernama myapp di direktori kerja saat ini dan view engine yang akan digunakan adalah Pug:

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


Kemudian instal semua dependensi project:

$ cd myapp
$ npm install


Di MacOS atau Linux, jalankan aplikasi dengan perintah ini:

$ DEBUG=myapp:* npm start


Di Command Prompt Windows, gunakan perintah ini:

> set DEBUG=myapp:* & npm start


Di PowerShell Windows, gunakan perintah ini:

PS> $env:DEBUG='myapp:*'; npm start


Kemudian, kunjungi http://localhost:3000/ di browser Anda untuk mengakses aplikasi.

Aplikasi yang dihasilkan memiliki struktur direktori sebagai berikut:

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  Struktur aplikasi yang dibuat oleh generator hanyalah salah satu dari banyak cara untuk membuat struktur aplikasi Express. Jangan ragu untuk menggunakan struktur ini atau memodifikasinya agar sesuai dengan kebutuhan Anda.


Previous: Hello World     Next: Basic routing

              
    
    Edit this page\n\n\n\nExpress application generator

Use the application generator tool, express-generator, to quickly create an application skeleton.

You can run the application generator with the npx command (available in Node.js 8.2.0).

$ npx express-generator


For earlier Node versions, install the application generator as a global npm package and then launch it:

$ npm install -g express-generator
$ express


Display the command options with the -h option:

$ express -h

  Usage: express [options] [dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view <engine> add view <engine> support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css <engine>  add stylesheet <engine> support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


For example, the following creates an Express app named myapp. The app will be created in a folder named myapp in the current working directory and the view engine will be set to Pug:

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


Then install dependencies:

$ cd myapp
$ npm install


On MacOS or Linux, run the app with this command:

$ DEBUG=myapp:* npm start


On Windows Command Prompt, use this command:

> set DEBUG=myapp:* & npm start


On Windows PowerShell, use this command:

PS> $env:DEBUG='myapp:*'; npm start


Then, load http://localhost:3000/ in your browser to access the app.

The generated app has the following directory structure:

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  The app structure created by the generator is just one of many ways to structure Express apps. Feel free to use this structure or modify it to best suit your needs.


Previous: Hello World     Next: Basic routing

              
    
    Edit this page\n\nExpress application generator

Use the application generator tool, express-generator, to quickly create an application skeleton.

You can run the application generator with the npx command (available in Node.js 8.2.0).

$ npx express-generator


For earlier Node versions, install the application generator as a global npm package and then launch it:

$ npm install -g express-generator
$ express


Display the command options with the -h option:

$ express -h

  Usage: express [options] [dir]

  Options:

    -h, --help          output usage information
        --version       output the version number
    -e, --ejs           add ejs engine support
        --hbs           add handlebars engine support
        --pug           add pug engine support
    -H, --hogan         add hogan.js engine support
        --no-view       generate without view engine
    -v, --view <engine> add view <engine> support (ejs|hbs|hjs|jade|pug|twig|vash) (defaults to jade)
    -c, --css <engine>  add stylesheet <engine> support (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory


For example, the following creates an Express app named myapp. The app will be created in a folder named myapp in the current working directory and the view engine will be set to Pug:

$ express --view=pug myapp

   create : myapp
   create : myapp/package.json
   create : myapp/app.js
   create : myapp/public
   create : myapp/public/javascripts
   create : myapp/public/images
   create : myapp/routes
   create : myapp/routes/index.js
   create : myapp/routes/users.js
   create : myapp/public/stylesheets
   create : myapp/public/stylesheets/style.css
   create : myapp/views
   create : myapp/views/index.pug
   create : myapp/views/layout.pug
   create : myapp/views/error.pug
   create : myapp/bin
   create : myapp/bin/www


Then install dependencies:

$ cd myapp
$ npm install


On MacOS or Linux, run the app with this command:

$ DEBUG=myapp:* npm start


On Windows Command Prompt, use this command:

> set DEBUG=myapp:* & npm start


On Windows PowerShell, use this command:

PS> $env:DEBUG='myapp:*'; npm start


Then, load http://localhost:3000/ in your browser to access the app.

The generated app has the following directory structure:

.
├── app.js
├── bin
│   └── www
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.pug
    ├── index.pug
    └── layout.pug

7 directories, 9 files



  The app structure created by the generator is just one of many ways to structure Express apps. Feel free to use this structure or modify it to best suit your needs.


Previous: Hello World     Next: Basic routing

              
    
    Edit this page\n\n\n\nRoutage de base

Routage fait référence à la détermination de la façon dont une application répond à un 
nœud final spécifique, c’est-à-dire un URI (ou chemin) et une méthode de requête HTTP (GET, POST, etc.).

Chaque route peut avoir une ou plusieurs fonctions de gestionnaire, qui sont exécutées lorsque la route est mise en correspondance.

La définition de la route utilise la structure suivante :
app.METHOD(PATH, HANDLER)


Où :


  app est une instance d’express.
  METHOD est une méthode de demande HTTP.
  PATH est un chemin sur le serveur.
  HANDLER est la fonction exécutée lorsque la route est mise en correspondance.



  Ce tutoriel suppose qu’une instance d’express appelée app soit créée et que le serveur soit en cours d’exécution.
Si vous ne savez pas créer et démarrer une application, reportez-vous à l’exemple Hello world.


Les exemples suivants illustrent la définition de routes simples.

Réponse Hello World! sur la page d’accueil :

app.get('/', (req, res) => {
  res.send('Hello World!')
})


Réponse à une demande POST sur la route racine (/), sur la page d’accueil de l’application :

app.post('/', (req, res) => {
  res.send('Got a POST request')
})


Réponse à une demande PUT sur la route /user :

app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})


Réponse à une demande DELETE sur la route /user :

app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})


Pour plus de détails sur le routage, reportez-vous au guide de routage.

              
    
    Edit this page\n\nRoutage de base

Routage fait référence à la détermination de la façon dont une application répond à un 
nœud final spécifique, c’est-à-dire un URI (ou chemin) et une méthode de requête HTTP (GET, POST, etc.).

Chaque route peut avoir une ou plusieurs fonctions de gestionnaire, qui sont exécutées lorsque la route est mise en correspondance.

La définition de la route utilise la structure suivante :
app.METHOD(PATH, HANDLER)


Où :


  app est une instance d’express.
  METHOD est une méthode de demande HTTP.
  PATH est un chemin sur le serveur.
  HANDLER est la fonction exécutée lorsque la route est mise en correspondance.



  Ce tutoriel suppose qu’une instance d’express appelée app soit créée et que le serveur soit en cours d’exécution.
Si vous ne savez pas créer et démarrer une application, reportez-vous à l’exemple Hello world.


Les exemples suivants illustrent la définition de routes simples.

Réponse Hello World! sur la page d’accueil :

app.get('/', (req, res) => {
  res.send('Hello World!')
})


Réponse à une demande POST sur la route racine (/), sur la page d’accueil de l’application :

app.post('/', (req, res) => {
  res.send('Got a POST request')
})


Réponse à une demande PUT sur la route /user :

app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})


Réponse à une demande DELETE sur la route /user :

app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})


Pour plus de détails sur le routage, reportez-vous au guide de routage.

              
    
    Edit this page\n\n\n\nBasisrouting

Per Routing wird bestimmt, wie eine Antwort auf eine Clientanforderung an einem bestimmten Endpunkt antwortet. Dies ist eine URI (oder ein Pfad) und eine bestimmte HTTP-Anforderungsmethode (GET, POST usw.).

Jede Weiterleitung (Route) kann eine oder mehrere Handlerfunktionen haben, die ausgeführt werden, wenn die Weiterleitung abgeglichen wird.

Weiterleitungsdefinitionen haben die folgende Struktur:
app.METHOD(PATH, HANDLER)


Bedeutung:


  app ist eine Instanz von express.
  METHOD ist eine HTTP-Anforderungsmethode.
  PATH ist ein Pfad auf dem Server.
  HANDLER ist die Funktion, die ausgeführt wird, wenn die Weiterleitung abgeglichen wird.



  In diesem Lernprogramm wird vorausgesetzt, dass eine Instanz von express namens app erstellt und der Server ausgeführt wird. Wenn Sie mit dem Erstellen und Starten von Anwendungen nicht vertraut sind, spielen Sie das Beispiel “Hello World” durch.


Die folgenden Beispiele veranschaulichen das Definieren einfacher Weiterleitungen.

Antworten Sie mit Hello World! auf der Homepage:

app.get('/', (req, res) => {
  res.send('Hello World!')
})


Antworten Sie auf POST-Anforderungen auf die Weiterleitung zum Stammverzeichnis (/), der Homepage der Anwendung:

app.post('/', (req, res) => {
  res.send('Got a POST request')
})


Antworten Sie auf eine PUT-Anforderung zur Weiterleitung /user:

app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})


Antworten Sie auf eine DELETE-Anforderung zur Weiterleitung /user:

app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})


Details zum Thema Routing finden Sie in der entsprechenden Routinganleitung.

              
    
    Edit this page\n\nBasisrouting

Per Routing wird bestimmt, wie eine Antwort auf eine Clientanforderung an einem bestimmten Endpunkt antwortet. Dies ist eine URI (oder ein Pfad) und eine bestimmte HTTP-Anforderungsmethode (GET, POST usw.).

Jede Weiterleitung (Route) kann eine oder mehrere Handlerfunktionen haben, die ausgeführt werden, wenn die Weiterleitung abgeglichen wird.

Weiterleitungsdefinitionen haben die folgende Struktur:
app.METHOD(PATH, HANDLER)


Bedeutung:


  app ist eine Instanz von express.
  METHOD ist eine HTTP-Anforderungsmethode.
  PATH ist ein Pfad auf dem Server.
  HANDLER ist die Funktion, die ausgeführt wird, wenn die Weiterleitung abgeglichen wird.



  In diesem Lernprogramm wird vorausgesetzt, dass eine Instanz von express namens app erstellt und der Server ausgeführt wird. Wenn Sie mit dem Erstellen und Starten von Anwendungen nicht vertraut sind, spielen Sie das Beispiel “Hello World” durch.


Die folgenden Beispiele veranschaulichen das Definieren einfacher Weiterleitungen.

Antworten Sie mit Hello World! auf der Homepage:

app.get('/', (req, res) => {
  res.send('Hello World!')
})


Antworten Sie auf POST-Anforderungen auf die Weiterleitung zum Stammverzeichnis (/), der Homepage der Anwendung:

app.post('/', (req, res) => {
  res.send('Got a POST request')
})


Antworten Sie auf eine PUT-Anforderung zur Weiterleitung /user:

app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})


Antworten Sie auf eine DELETE-Anforderung zur Weiterleitung /user:

app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})


Details zum Thema Routing finden Sie in der entsprechenden Routinganleitung.

              
    
    Edit this page\n\n\n\nDireccionamiento básico

El direccionamiento hace referencia a la determinación de cómo responde una aplicación a una solicitud de cliente en un determinado punto final, que es un URI (o una vía de acceso) y un método de solicitud HTTP específico (GET, POST, etc.).

Cada ruta puede tener una o varias funciones de manejador, que se excluyen cuando se correlaciona la ruta.

La definición de ruta tiene la siguiente estructura:
app.METHOD(PATH, HANDLER)


Donde:


  app es una instancia de express.
  METHOD es un método de solicitud HTTP.
  PATH es una vía de acceso en el servidor.
  HANDLER es la función que se ejecuta cuando se correlaciona la ruta.



  En esta guía de aprendizaje se supone que se crea una instancia de express denominada app y que el servidor está en ejecución. Si no está familiarizado con la creación y el inicio de una aplicación, consulte el Ejemplo Hello world.


El siguiente ejemplo ilustra la definición de rutas simples.

Responda con Hello World! en la página inicial:

app.get('/', (req, res) => {
  res.send('Hello World!')
})


Responda a la solicitud POST en la ruta raíz (/), la página de inicio de la aplicación:

app.post('/', (req, res) => {
  res.send('Got a POST request')
})


Responda a una solicitud PUT en la ruta /user:

app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})


Responda a una solicitud DELETE en la ruta /user:

app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})


Para obtener más detalles sobre el direccionamiento, consulte la guía de direccionamiento.

              
    
    Edit this page\n\nDireccionamiento básico

El direccionamiento hace referencia a la determinación de cómo responde una aplicación a una solicitud de cliente en un determinado punto final, que es un URI (o una vía de acceso) y un método de solicitud HTTP específico (GET, POST, etc.).

Cada ruta puede tener una o varias funciones de manejador, que se excluyen cuando se correlaciona la ruta.

La definición de ruta tiene la siguiente estructura:
app.METHOD(PATH, HANDLER)


Donde:


  app es una instancia de express.
  METHOD es un método de solicitud HTTP.
  PATH es una vía de acceso en el servidor.
  HANDLER es la función que se ejecuta cuando se correlaciona la ruta.



  En esta guía de aprendizaje se supone que se crea una instancia de express denominada app y que el servidor está en ejecución. Si no está familiarizado con la creación y el inicio de una aplicación, consulte el Ejemplo Hello world.


El siguiente ejemplo ilustra la definición de rutas simples.

Responda con Hello World! en la página inicial:

app.get('/', (req, res) => {
  res.send('Hello World!')
})


Responda a la solicitud POST en la ruta raíz (/), la página de inicio de la aplicación:

app.post('/', (req, res) => {
  res.send('Got a POST request')
})


Responda a una solicitud PUT en la ruta /user:

app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})


Responda a una solicitud DELETE en la ruta /user:

app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})


Para obtener más detalles sobre el direccionamiento, consulte la guía de direccionamiento.

              
    
    Edit this page\n\n\n\nRouting di base

Per Routing si intende determinare come un’applicazione risponde a una richiesta client a un endpoint particolare, il quale è un URI (o percorso) e un metodo di richiesta HTTP specifico (GET, POST e così via).

Ciascuna route può disporre di una o più funzioni dell’handler, le quali vengono eseguite quando si trova una corrispondenza per la route.

La definizione della route ha la seguente struttura:
app.METHOD(PATH, HANDLER)


Dove:


  app è un’istanza di express.
  METHOD è un metodo di richiesta HTTP.
  PATH è un percorso sul server.
  HANDLER è la funzione eseguita quando si trova una corrispondenza per la route.



  Questo tutorial presume che un’istanza di express denominata app sia stata creata e che il server sia in esecuzione. Se non si è in grado di creare un’applicazione e avviarla, consultare la sezione Esempio di Hello world.


I seguenti esempi mostrano come definire route semplici.

Rispondere con Hello World! sulla homepage:

app.get('/', (req, res) => {
  res.send('Hello World!')
})


Rispondere alla richiesta POST sulla route principale (/), la home page dell’applicazione:

app.post('/', (req, res) => {
  res.send('Got a POST request')
})


Rispondere a una richiesta PUT alla route /user:

app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})


Rispondere a una richiesta DELETE alla route /user:

app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})


Per ulteriori dettagli sul routing, consultare il Manuale routing.

              
    
    Edit this page\n\nRouting di base

Per Routing si intende determinare come un’applicazione risponde a una richiesta client a un endpoint particolare, il quale è un URI (o percorso) e un metodo di richiesta HTTP specifico (GET, POST e così via).

Ciascuna route può disporre di una o più funzioni dell’handler, le quali vengono eseguite quando si trova una corrispondenza per la route.

La definizione della route ha la seguente struttura:
app.METHOD(PATH, HANDLER)


Dove:


  app è un’istanza di express.
  METHOD è un metodo di richiesta HTTP.
  PATH è un percorso sul server.
  HANDLER è la funzione eseguita quando si trova una corrispondenza per la route.



  Questo tutorial presume che un’istanza di express denominata app sia stata creata e che il server sia in esecuzione. Se non si è in grado di creare un’applicazione e avviarla, consultare la sezione Esempio di Hello world.


I seguenti esempi mostrano come definire route semplici.

Rispondere con Hello World! sulla homepage:

app.get('/', (req, res) => {
  res.send('Hello World!')
})


Rispondere alla richiesta POST sulla route principale (/), la home page dell’applicazione:

app.post('/', (req, res) => {
  res.send('Got a POST request')
})


Rispondere a una richiesta PUT alla route /user:

app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})


Rispondere a una richiesta DELETE alla route /user:

app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})


Per ulteriori dettagli sul routing, consultare il Manuale routing.

              
    
    Edit this page\n\n\n\n基本的なルーティング

ルーティング とは、アプリケーションが特定のエンドポイントに対するクライアント要求に応答する方法として、URI (またはパス) と特定の HTTP 要求メソッド (GET、POST など) を決定することです。

各ルートには、1 つ以上のハンドラー関数があり、それらはルートが一致したときに実行されます。

ルート定義では、次の構造を使用します。
app.METHOD(PATH, HANDLER)


各部分の意味は次のとおりです。


  app は、express のインスタンスです。
  METHOD は、HTTP 要求メソッド です。
  PATH は、サーバー上のパスです。
  HANDLER は、ルートが一致したときに実行される関数です。



  このチュートリアルでは、app という名前の express のインスタンスが作成されていて、サーバーが稼働中であることを想定しています。アプリケーションの作成と開始に慣れていない場合は、Hello World の例 を参照してください。


以下の例は、単純なルートの定義を示しています。

ホーム・ページで Hello World! と応答します。

app.get('/', (req, res) => {
  res.send('Hello World!')
})


アプリケーションのホーム・ページであるルートのルート (/) で POST 要求に応答します。

app.post('/', (req, res) => {
  res.send('Got a POST request')
})


/user ルートに対する PUT 要求に応答します。

app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})


/user ルートに対する DELETE 要求に応答します。

app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})


ルーティングについて詳しくは、ルーティング・ガイドを参照してください。

              
    
    Edit this page\n\n基本的なルーティング

ルーティング とは、アプリケーションが特定のエンドポイントに対するクライアント要求に応答する方法として、URI (またはパス) と特定の HTTP 要求メソッド (GET、POST など) を決定することです。

各ルートには、1 つ以上のハンドラー関数があり、それらはルートが一致したときに実行されます。

ルート定義では、次の構造を使用します。
app.METHOD(PATH, HANDLER)


各部分の意味は次のとおりです。


  app は、express のインスタンスです。
  METHOD は、HTTP 要求メソッド です。
  PATH は、サーバー上のパスです。
  HANDLER は、ルートが一致したときに実行される関数です。



  このチュートリアルでは、app という名前の express のインスタンスが作成されていて、サーバーが稼働中であることを想定しています。アプリケーションの作成と開始に慣れていない場合は、Hello World の例 を参照してください。


以下の例は、単純なルートの定義を示しています。

ホーム・ページで Hello World! と応答します。

app.get('/', (req, res) => {
  res.send('Hello World!')
})


アプリケーションのホーム・ページであるルートのルート (/) で POST 要求に応答します。

app.post('/', (req, res) => {
  res.send('Got a POST request')
})


/user ルートに対する PUT 要求に応答します。

app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})


/user ルートに対する DELETE 要求に応答します。

app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})


ルーティングについて詳しくは、ルーティング・ガイドを参照してください。

              
    
    Edit this page\n\n\n\nОсновы маршрутизации

Маршрутизация определяет, как приложение отвечает на клиентский запрос к конкретному адресу (конечной точке), которым является URI (или путь), и определенному методу запроса HTTP (GET, POST и т.д.).

Каждый маршрут может иметь одну или несколько функций обработки, которые выполняются при сопоставлении маршрута.

Определение маршрута имеет следующую структуру:
app.METHOD(PATH, HANDLER)


Где:


  app - это экземпляр express.
  METHOD - метод запроса HTTP.
  PATH - путь на сервере.
  HANDLER - функция, выполняемая при сопоставлении маршрута.



  В этом учебнике мы исходим из предположения о том, что экземпляр express с именем app уже создан, и сервер работает. Если вы не знакомы со способами создания и запуска приложения, обратитесь к разделу Пример “Hello world”.


Приведенные ниже элементарные примеры иллюстрируют способ определения простых маршрутов.

Ответ Hello World! на домашней странице:

app.get('/', (req, res) => {
  res.send('Hello World!')
})


Ответ на запрос POST в корневом маршруте (/), на домашней странице приложения:

app.post('/', (req, res) => {
  res.send('Got a POST request')
})


Ответ на запрос PUT, адресованный маршруту /user:

app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})


Ответ на запрос DELETE, адресованный маршруту /user:

app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})


Дополнительная информация о маршрутизации приведена в руководстве по маршрутизации.

              
    
    Edit this page\n\nОсновы маршрутизации

Маршрутизация определяет, как приложение отвечает на клиентский запрос к конкретному адресу (конечной точке), которым является URI (или путь), и определенному методу запроса HTTP (GET, POST и т.д.).

Каждый маршрут может иметь одну или несколько функций обработки, которые выполняются при сопоставлении маршрута.

Определение маршрута имеет следующую структуру:
app.METHOD(PATH, HANDLER)


Где:


  app - это экземпляр express.
  METHOD - метод запроса HTTP.
  PATH - путь на сервере.
  HANDLER - функция, выполняемая при сопоставлении маршрута.



  В этом учебнике мы исходим из предположения о том, что экземпляр express с именем app уже создан, и сервер работает. Если вы не знакомы со способами создания и запуска приложения, обратитесь к разделу Пример “Hello world”.


Приведенные ниже элементарные примеры иллюстрируют способ определения простых маршрутов.

Ответ Hello World! на домашней странице:

app.get('/', (req, res) => {
  res.send('Hello World!')
})


Ответ на запрос POST в корневом маршруте (/), на домашней странице приложения:

app.post('/', (req, res) => {
  res.send('Got a POST request')
})


Ответ на запрос PUT, адресованный маршруту /user:

app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})


Ответ на запрос DELETE, адресованный маршруту /user:

app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})


Дополнительная информация о маршрутизации приведена в руководстве по маршрутизации.

              
    
    Edit this page\n\n\n\n基本路由

路由用于确定应用程序如何响应对特定端点的客户机请求，包含一个 URI（或路径）和一个特定的 HTTP 请求方法（GET、POST 等）。

每个路由可以具有一个或多个处理程序函数，这些函数在路由匹配时执行。

路由定义采用以下结构：
app.METHOD(PATH, HANDLER)


其中：


  app 是 express 的实例。
  METHOD 是 HTTP 请求方法。
  PATH 是服务器上的路径。
  HANDLER 是在路由匹配时执行的函数。



  本教程假定创建了名为 app 的 express 实例且服务器正在运行。如果您对创建和启动应用程序并不熟悉，请参阅 Hello world 示例。


以下示例演示了如何定义简单路由。

以主页上的 Hello World! 进行响应：

app.get('/', (req, res) => {
  res.send('Hello World!')
})


在根路由 (/) 上（应用程序的主页）对 POST 请求进行响应：

app.post('/', (req, res) => {
  res.send('Got a POST request')
})


对 /user 路由的 PUT 请求进行响应：

app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})


对 /user 路由的 DELETE 请求进行响应：

app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})


有关路由的更多详细信息，请参阅路由指南。

              
    
    Edit this page\n\n基本路由

路由用于确定应用程序如何响应对特定端点的客户机请求，包含一个 URI（或路径）和一个特定的 HTTP 请求方法（GET、POST 等）。

每个路由可以具有一个或多个处理程序函数，这些函数在路由匹配时执行。

路由定义采用以下结构：
app.METHOD(PATH, HANDLER)


其中：


  app 是 express 的实例。
  METHOD 是 HTTP 请求方法。
  PATH 是服务器上的路径。
  HANDLER 是在路由匹配时执行的函数。



  本教程假定创建了名为 app 的 express 实例且服务器正在运行。如果您对创建和启动应用程序并不熟悉，请参阅 Hello world 示例。


以下示例演示了如何定义简单路由。

以主页上的 Hello World! 进行响应：

app.get('/', (req, res) => {
  res.send('Hello World!')
})


在根路由 (/) 上（应用程序的主页）对 POST 请求进行响应：

app.post('/', (req, res) => {
  res.send('Got a POST request')
})


对 /user 路由的 PUT 请求进行响应：

app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})


对 /user 路由的 DELETE 请求进行响应：

app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})


有关路由的更多详细信息，请参阅路由指南。

              
    
    Edit this page\n\n\n\n基本路由

路由是指判斷應用程式如何回應用戶端對特定端點的要求，而這個特定端點是一個 URI（或路徑）與一個特定的 HTTP 要求方法（GET、POST 等）。

每一個路由可以有一或多個處理程式函數，當路由相符時，就會執行這些函數。

路由定義的結構如下：
app.METHOD(PATH, HANDLER)


其中：


  app 是 express 的實例。
  METHOD 是 HTTP 要求方法。
  PATH 是伺服器上的路徑。
  HANDLER 是當路由相符時要執行的函數。



  這項指導教學假設已建立名稱為 app 的 express 實例，且伺服器正在執行。如果您不熟悉如何建立和啟動應用程式，請參閱 Hello world 範例。


下列範例說明如何定義簡單的路由。

首頁中以 Hello World! 回應。

app.get('/', (req, res) => {
  res.send('Hello World!')
})


對根路由 (/)（應用程式的首頁）發出 POST 要求時的回應：

app.post('/', (req, res) => {
  res.send('Got a POST request')
})


對 /user 路由發出 PUT 要求時的回應：

app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})


對 /user 路由發出 DELETE 要求時的回應：

app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})


如需路由的詳細資料，請參閱路由手冊。

              
    
    Edit this page\n\n基本路由

路由是指判斷應用程式如何回應用戶端對特定端點的要求，而這個特定端點是一個 URI（或路徑）與一個特定的 HTTP 要求方法（GET、POST 等）。

每一個路由可以有一或多個處理程式函數，當路由相符時，就會執行這些函數。

路由定義的結構如下：
app.METHOD(PATH, HANDLER)


其中：


  app 是 express 的實例。
  METHOD 是 HTTP 要求方法。
  PATH 是伺服器上的路徑。
  HANDLER 是當路由相符時要執行的函數。



  這項指導教學假設已建立名稱為 app 的 express 實例，且伺服器正在執行。如果您不熟悉如何建立和啟動應用程式，請參閱 Hello world 範例。


下列範例說明如何定義簡單的路由。

首頁中以 Hello World! 回應。

app.get('/', (req, res) => {
  res.send('Hello World!')
})


對根路由 (/)（應用程式的首頁）發出 POST 要求時的回應：

app.post('/', (req, res) => {
  res.send('Got a POST request')
})


對 /user 路由發出 PUT 要求時的回應：

app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})


對 /user 路由發出 DELETE 要求時的回應：

app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})


如需路由的詳細資料，請參閱路由手冊。

              
    
    Edit this page\n\n\n\n기본 라우팅

라우팅은 URI(또는 경로) 및 특정한 HTTP 요청 메소드(GET, POST 등)인 특정 엔드포인트에 대한 클라이언트 요청에 애플리케이션이 응답하는 방법을 결정하는 것을 말합니다.

각 라우트는 하나 이상의 핸들러 함수를 가질 수 있으며, 이러한 함수는 라우트가 일치할 때 실행됩니다.

라우트 정의에는 다음과 같은 구조가 필요합니다.
app.METHOD(PATH, HANDLER)


여기서,


  app은 express의 인스턴스입니다.
  METHOD는 HTTP 요청 메소드입니다.
  PATH는 서버에서의 경로입니다.
  HANDLER는 라우트가 일치할 때 실행되는 함수입니다.



  이 학습서에서는 app이라는 이름의 express 인스턴스가 작성되며 서버가 실행 중인 것으로 가정합니다. 앱의 작성 및 시작에 익숙하지 않은 경우에는 Hello world 예제를 참조하십시오.


다음 예에서는 간단한 라우트의 정의를 설명합니다.

홈 페이지에서 Hello World!로 응답:

app.get('/', (req, res) => {
  res.send('Hello World!')
})


애플리케이션의 홈 페이지인 루트 라우트(/)에서 POST 요청에 응답:

app.post('/', (req, res) => {
  res.send('Got a POST request')
})


/user 라우트에 대한 PUT 요청에 응답:

app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})


/user 라우트에 대한 DELETE 요청에 응답:

app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})


라우팅에 대한 자세한 내용을 확인하려면 라우팅 안내서를 참조하십시오.

              
    
    Edit this page\n\n기본 라우팅

라우팅은 URI(또는 경로) 및 특정한 HTTP 요청 메소드(GET, POST 등)인 특정 엔드포인트에 대한 클라이언트 요청에 애플리케이션이 응답하는 방법을 결정하는 것을 말합니다.

각 라우트는 하나 이상의 핸들러 함수를 가질 수 있으며, 이러한 함수는 라우트가 일치할 때 실행됩니다.

라우트 정의에는 다음과 같은 구조가 필요합니다.
app.METHOD(PATH, HANDLER)


여기서,


  app은 express의 인스턴스입니다.
  METHOD는 HTTP 요청 메소드입니다.
  PATH는 서버에서의 경로입니다.
  HANDLER는 라우트가 일치할 때 실행되는 함수입니다.



  이 학습서에서는 app이라는 이름의 express 인스턴스가 작성되며 서버가 실행 중인 것으로 가정합니다. 앱의 작성 및 시작에 익숙하지 않은 경우에는 Hello world 예제를 참조하십시오.


다음 예에서는 간단한 라우트의 정의를 설명합니다.

홈 페이지에서 Hello World!로 응답:

app.get('/', (req, res) => {
  res.send('Hello World!')
})


애플리케이션의 홈 페이지인 루트 라우트(/)에서 POST 요청에 응답:

app.post('/', (req, res) => {
  res.send('Got a POST request')
})


/user 라우트에 대한 PUT 요청에 응답:

app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})


/user 라우트에 대한 DELETE 요청에 응답:

app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})


라우팅에 대한 자세한 내용을 확인하려면 라우팅 안내서를 참조하십시오.

              
    
    Edit this page\n\n\n\nRoteamento Básico

O Roteamento refere-se à determinação de como um
aplicativo responde a uma solicitação do cliente por um endpoint
específico, que é uma URI (ou caminho) e um método de solicitação HTTP
específico (GET, POST, e assim por diante).

Cada rota pode ter uma ou mais funções de manipulação, que são
executadas quando a rota é correspondida.

A definição de rotas aceita a seguinte estrutura:
app.METHOD(PATH, HANDLER)


Onde:


  app é uma instância do express.
  METHOD é um método de solicitação HTTP.
  PATH é um caminho no servidor.
  HANDLER é a função executada quando a rota é correspondida.



  Este tutorial assume que uma instância de express
chamada app está criada e o servidor está em
execução. Caso não tenha familiaridade com a criação e inicialização
de um aplicativo, consulte o exemplo Hello world.


Os seguintes exemplos ilustram a definição de rotas simples.

Responder com Hello World! na página inicial:

app.get('/', (req, res) => {
  res.send('Hello World!')
})


Responder a uma solicitação POST na rota raiz (/) com a página inicial do aplicativo:

app.post('/', (req, res) => {
  res.send('Got a POST request')
})


Responder a uma solicitação PUT para a rota /user:

app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})


Responder a uma solicitação DELETE para a rota /user:

app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})


Para obter mais detalhes  sobre roteamento, consulte o guia de roteamento.

              
    
    Edit this page\n\nRoteamento Básico

O Roteamento refere-se à determinação de como um
aplicativo responde a uma solicitação do cliente por um endpoint
específico, que é uma URI (ou caminho) e um método de solicitação HTTP
específico (GET, POST, e assim por diante).

Cada rota pode ter uma ou mais funções de manipulação, que são
executadas quando a rota é correspondida.

A definição de rotas aceita a seguinte estrutura:
app.METHOD(PATH, HANDLER)


Onde:


  app é uma instância do express.
  METHOD é um método de solicitação HTTP.
  PATH é um caminho no servidor.
  HANDLER é a função executada quando a rota é correspondida.



  Este tutorial assume que uma instância de express
chamada app está criada e o servidor está em
execução. Caso não tenha familiaridade com a criação e inicialização
de um aplicativo, consulte o exemplo Hello world.


Os seguintes exemplos ilustram a definição de rotas simples.

Responder com Hello World! na página inicial:

app.get('/', (req, res) => {
  res.send('Hello World!')
})


Responder a uma solicitação POST na rota raiz (/) com a página inicial do aplicativo:

app.post('/', (req, res) => {
  res.send('Got a POST request')
})


Responder a uma solicitação PUT para a rota /user:

app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})


Responder a uma solicitação DELETE para a rota /user:

app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})


Para obter mais detalhes  sobre roteamento, consulte o guia de roteamento.

              
    
    Edit this page\n\n\n\nZákladný routing

Routing rozhoduje o tom, ako aplikácia odpovedá na požiadavky (requesty) klientov na jednotlivých koncových bodoch (endpointoch) reprezentovaných pomocou URI (alebo cesty) a špecifickej HTTP request metódy (GET, POST, atď.).

Každý definovaný route môže mať jednu, alebo viacero handler funkcií, ktoré sa vykonajú v prípade, ak je route spárovaný s požiadavkou klienta.

Route definícia má nasledovnú štruktúru:
app.METHOD(PATH, HANDLER)


Kde:


  app je express inštancia.
  METHOD je HTTP request metóda.
  PATH je cesta na serveri.
  HANDLER je funkcia, ktorá sa vykoná, ak je route spárovaný.



  Tento tutoriál predpokladá, že existuje inštancia express aplikácie s názvom app a server je spustený. Ak nie ste oboznámení s vytváraním a spuštaním aplikácií, začnite Hello world prikladom.


Nasledujúce priklady ilustrujú definovanie jednoduchých route-ov.

Odpoveď s textom Hello World! na hlavnej stránke:

app.get('/', (req, res) => {
  res.send('Hello World!')
})


Odpoveď na POST request na hlavný route (/), hlavnú stránku aplikácie:

app.post('/', (req, res) => {
  res.send('Got a POST request')
})


Odpoveď na PUT request na route /user:

app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})


Odpoveď na DELETE request na route /user:

app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})


Viac informácií ohľadom routing-u nájdete v routing príručke.

              
    
    Edit this page\n\nZákladný routing

Routing rozhoduje o tom, ako aplikácia odpovedá na požiadavky (requesty) klientov na jednotlivých koncových bodoch (endpointoch) reprezentovaných pomocou URI (alebo cesty) a špecifickej HTTP request metódy (GET, POST, atď.).

Každý definovaný route môže mať jednu, alebo viacero handler funkcií, ktoré sa vykonajú v prípade, ak je route spárovaný s požiadavkou klienta.

Route definícia má nasledovnú štruktúru:
app.METHOD(PATH, HANDLER)


Kde:


  app je express inštancia.
  METHOD je HTTP request metóda.
  PATH je cesta na serveri.
  HANDLER je funkcia, ktorá sa vykoná, ak je route spárovaný.



  Tento tutoriál predpokladá, že existuje inštancia express aplikácie s názvom app a server je spustený. Ak nie ste oboznámení s vytváraním a spuštaním aplikácií, začnite Hello world prikladom.


Nasledujúce priklady ilustrujú definovanie jednoduchých route-ov.

Odpoveď s textom Hello World! na hlavnej stránke:

app.get('/', (req, res) => {
  res.send('Hello World!')
})


Odpoveď na POST request na hlavný route (/), hlavnú stránku aplikácie:

app.post('/', (req, res) => {
  res.send('Got a POST request')
})


Odpoveď na PUT request na route /user:

app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})


Odpoveď na DELETE request na route /user:

app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})


Viac informácií ohľadom routing-u nájdete v routing príručke.

              
    
    Edit this page\n\n\n\nБазова маршрутизація

Маршрутизація визначає: яку саме відповідь застосунок буде видавати клієнту,
коли від клієнта йде запит з використанням певного HTTP-методу (GET, POST, і т.д.) та по конкретному URI.

Кожен маршрут може мати одну чи більше функцій-обробників, що виконуються, коли даний маршрут затверджено як співпадаючий.

Визначення маршрутів має наступну структуру:
app.METHOD(PATH, HANDLER)


Де:


  app є екземпляром express.
  METHOD є методом HTTP-запиту.
  PATH є шляхом на сервері.
  HANDLER є функцією-обробником, що спрацьовує, коли даний маршрут затверджено як співпадаючий.



  В цьому керівництві припускається, що у вас вже створено та запущено екземпляр веб-сервера express і його передано у змінну з іменем app.
Якщо ви ще не вмієте створювати екземпляри застосунків та запускати їх, прогляньте Приклад Hello world.


В наступних прикладах продемонстровано визначення простих маршрутів.

Визначення маршруту, що відповідає на GET-запити до головної сторінки, в результаті чого друкується Hello World!:

app.get('/', (req, res) => {
  res.send('Hello World!')
})


Визначення маршруту, що відповідає на POST-запити до кореневого маршруту (/), тобто до головної сторінки:

app.post('/', (req, res) => {
  res.send('Маємо POST-запит')
})


Визначення маршруту, що відповідає на PUT-запити до /user:

app.put('/user', (req, res) => {
  res.send('Маємо PUT-запит до /user')
})


Визначення маршруту, що відповідає на DELETE-запити до /user:

app.delete('/user', (req, res) => {
  res.send('Маємо DELETE-запит до /user')
})


Більш детально про маршрутизацію описано на сторінці гід маршрутизації.

              
    
    Edit this page\n\nБазова маршрутизація

Маршрутизація визначає: яку саме відповідь застосунок буде видавати клієнту,
коли від клієнта йде запит з використанням певного HTTP-методу (GET, POST, і т.д.) та по конкретному URI.

Кожен маршрут може мати одну чи більше функцій-обробників, що виконуються, коли даний маршрут затверджено як співпадаючий.

Визначення маршрутів має наступну структуру:
app.METHOD(PATH, HANDLER)


Де:


  app є екземпляром express.
  METHOD є методом HTTP-запиту.
  PATH є шляхом на сервері.
  HANDLER є функцією-обробником, що спрацьовує, коли даний маршрут затверджено як співпадаючий.



  В цьому керівництві припускається, що у вас вже створено та запущено екземпляр веб-сервера express і його передано у змінну з іменем app.
Якщо ви ще не вмієте створювати екземпляри застосунків та запускати їх, прогляньте Приклад Hello world.


В наступних прикладах продемонстровано визначення простих маршрутів.

Визначення маршруту, що відповідає на GET-запити до головної сторінки, в результаті чого друкується Hello World!:

app.get('/', (req, res) => {
  res.send('Hello World!')
})


Визначення маршруту, що відповідає на POST-запити до кореневого маршруту (/), тобто до головної сторінки:

app.post('/', (req, res) => {
  res.send('Маємо POST-запит')
})


Визначення маршруту, що відповідає на PUT-запити до /user:

app.put('/user', (req, res) => {
  res.send('Маємо PUT-запит до /user')
})


Визначення маршруту, що відповідає на DELETE-запити до /user:

app.delete('/user', (req, res) => {
  res.send('Маємо DELETE-запит до /user')
})


Більш детально про маршрутизацію описано на сторінці гід маршрутизації.

              
    
    Edit this page\n\n\n\nAsosiy marshrutizatsiya
Ushbu material Expressda asosiy marshrutizatsiyalar bilan ishlash haqidadir. Marshrutizatsiya dasturda HTTP so’rovlarga (GET, POST va b.sh) murojat qilinganda, ma’lum bir manzilga(endpoint) qanday javob berishini aniqlaydi.

Har bir marshrut(route) bir yoki ko’plar qayta ishlovchi funksiyalarga ega.

Marshrutni aniqlash quyidagi ko’rinishga ega app.METHOD(PATH, HANDLER), bu yerda app expressning ekzamplyari, METHOD esa HTTP request method, PATH esa saytdagi manzili va HANDLER esa marshrut chaqirilganda bajariladinga funksiya.

  Ushbu qo’llanmani foydalanishdan oldin express obyektidan ekzamplyar olib, uni app deb atang va serverni ishga tushuring.  Agar siz bu bilan tanish bo’lmasangiz, unda Hello world misol qo’llanmanisini o’qib chiqing.


Quyidagi kodlar marshrutizatsiyaga bir necha misollar keltirilgan.

// Bosh sahifada "Hello World!" javobini qaytaradi.
app.get('/', (req, res) => {
  res.send('Hello World!')
})

// Bosh sahifada POST so'rovni qabul qilish.
app.post('/', (req, res) => {
  res.send('Got a POST request')
})

// /user manzilida PUT so'rovni qabul qilish.
app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})

// /user mazilida DELETE so'rovni qabul qilish.
app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})


Marshrutizatsiya haqida to’liq ma’lumot olish uchun, ma’lumotnoma orqali Marshrutizatsiya bo’limini o’qib chiqing.

              
    
    Edit this page\n\nAsosiy marshrutizatsiya
Ushbu material Expressda asosiy marshrutizatsiyalar bilan ishlash haqidadir. Marshrutizatsiya dasturda HTTP so’rovlarga (GET, POST va b.sh) murojat qilinganda, ma’lum bir manzilga(endpoint) qanday javob berishini aniqlaydi.

Har bir marshrut(route) bir yoki ko’plar qayta ishlovchi funksiyalarga ega.

Marshrutni aniqlash quyidagi ko’rinishga ega app.METHOD(PATH, HANDLER), bu yerda app expressning ekzamplyari, METHOD esa HTTP request method, PATH esa saytdagi manzili va HANDLER esa marshrut chaqirilganda bajariladinga funksiya.

  Ushbu qo’llanmani foydalanishdan oldin express obyektidan ekzamplyar olib, uni app deb atang va serverni ishga tushuring.  Agar siz bu bilan tanish bo’lmasangiz, unda Hello world misol qo’llanmanisini o’qib chiqing.


Quyidagi kodlar marshrutizatsiyaga bir necha misollar keltirilgan.

// Bosh sahifada "Hello World!" javobini qaytaradi.
app.get('/', (req, res) => {
  res.send('Hello World!')
})

// Bosh sahifada POST so'rovni qabul qilish.
app.post('/', (req, res) => {
  res.send('Got a POST request')
})

// /user manzilida PUT so'rovni qabul qilish.
app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})

// /user mazilida DELETE so'rovni qabul qilish.
app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})


Marshrutizatsiya haqida to’liq ma’lumot olish uchun, ma’lumotnoma orqali Marshrutizatsiya bo’limini o’qib chiqing.

              
    
    Edit this page\n\n\n\nBasit yol atama

Yol atama, bir uygulamanın belrili bir adreste belirli bir HTTP methodu ile (GET, POST gibi) gelen isteğe ne şekilde cevap vereceğine karşılık gelir.

Her yol, girilen adres eşleştiğinde bir veya daha fazla fonksiyon tarafından işlenebilir.

Yol tanımları aşağıdaki şekilde yapılanmıştır:

app.METHOD(PATH, HANDLER)


Burada:


  app, express‘in bir örneği.
  METHOD, HTTP istek methodu, küçük harflerle.
  PATH, sunucuda bulunan yol.
  HANDLER, adres bu yol ile eşleştiğinde çalıştırılan fonksiyon.



  Bu konu express ve app örneklerinin bulunduğunu ve sunucunun çalıştığını varsayar. Eğer bir uygulama oluşturup çalıştırmak hakkında bir bilginiz yoksa, Merhaba Dünya örneği sayfasını ziyaret edin.


Aşağıdaki örnekler nasıl basit bir şekilde yol tanımlayabileceğinizi gösterir.

Anasayfada Merhaba Dünya! ile cevap verin:

app.get('/', (req, res) => {
  res.send('Merhaba Dünya!')
})


Kök dizine (/) gelen POST isteğine bir cevap verin:

app.post('/', (req, res) => {
  res.send('POST isteği geldi!')
})


/user yoluna gelen PUT isteği:

app.put('/user', (req, res) => {
  res.send('/user adresinde bir PUT isteği')
})


/user yoluna gelen DELETE isteği:

app.delete('/user', (req, res) => {
  res.send('/user adresinde bir DELETE isteği')
})


Yol atama ile ilgili daha fazla detay için, yol atama sayfasını ziyaret edin.

Previous: Express application generator     Next: Serving static files in Express 

              
    
    Edit this page\n\nBasit yol atama

Yol atama, bir uygulamanın belrili bir adreste belirli bir HTTP methodu ile (GET, POST gibi) gelen isteğe ne şekilde cevap vereceğine karşılık gelir.

Her yol, girilen adres eşleştiğinde bir veya daha fazla fonksiyon tarafından işlenebilir.

Yol tanımları aşağıdaki şekilde yapılanmıştır:

app.METHOD(PATH, HANDLER)


Burada:


  app, express‘in bir örneği.
  METHOD, HTTP istek methodu, küçük harflerle.
  PATH, sunucuda bulunan yol.
  HANDLER, adres bu yol ile eşleştiğinde çalıştırılan fonksiyon.



  Bu konu express ve app örneklerinin bulunduğunu ve sunucunun çalıştığını varsayar. Eğer bir uygulama oluşturup çalıştırmak hakkında bir bilginiz yoksa, Merhaba Dünya örneği sayfasını ziyaret edin.


Aşağıdaki örnekler nasıl basit bir şekilde yol tanımlayabileceğinizi gösterir.

Anasayfada Merhaba Dünya! ile cevap verin:

app.get('/', (req, res) => {
  res.send('Merhaba Dünya!')
})


Kök dizine (/) gelen POST isteğine bir cevap verin:

app.post('/', (req, res) => {
  res.send('POST isteği geldi!')
})


/user yoluna gelen PUT isteği:

app.put('/user', (req, res) => {
  res.send('/user adresinde bir PUT isteği')
})


/user yoluna gelen DELETE isteği:

app.delete('/user', (req, res) => {
  res.send('/user adresinde bir DELETE isteği')
})


Yol atama ile ilgili daha fazla detay için, yol atama sayfasını ziyaret edin.

Previous: Express application generator     Next: Serving static files in Express 

              
    
    Edit this page\n\n\n\nเส้นทางเบื้องต้น

เส้นทาง (Routing) เป็นการกำหนดการอ้างอิงว่าแอปพลิเคชันจะตอบสนองต่อคำร้องขอของเครื่องลูกข่ายที่มายังปลายทาง (endpoint) โดยเฉพาะได้อย่างไร ซึ่งเป็น URI (หรือ path) และวิธีการร้องขอ HTTP (GET, POST, และ อื่นๆ)

แต่ละเส้นทางสามารถมีได้มากกว่าหนึ่งฟังชันส์จัดการ (handler function) ซึ่งสามารถดำเนินการเมื่อเส้นทางถูกจับคู่

การกำหนดเส้นทางใช้โครงสร้างดังนี้:

app.METHOD(PATH, HANDLER)


เมื่อ:


  app เป็นอินสแตนซ์ของ express.
  METHOD เป็น HTTP request method, เป็นตัวพิมพ์เล็ก.
  PATH เป็นเส้นทางบนเซิร์ฟเวอร์.
  HANDLER เป็นฟังชันส์ที่กระทำเมื่อเส้นทางถูกจับคู่.



  การสอนนี้จะสมมติว่าอินสแตนซ์ของ express ชื่อว่า app จะถูกสร้างขึ้นเมื่อรันเซิร์ฟเวอร์ ถ้าไม่คุ้นเคยกับการสร้าง app และโครงสร้างของมัน ดูเพิ่มเติมได้ที่ ตัวอย่าง Hello world


ตัวอย่างดังต่อไปนี้จะแสดงให้เห็นการกำหนดเส้นทางอย่างง่าย

ตอบสนองด้วยข้อความ Hello World! บนเพจหลัก:

app.get('/', (req, res) => {
  res.send('Hello World!')
})


ตอบสนองต่อการร้องขอด้วยวิธี POST บนเส้นทาง root (/) บนเพจหลักของแอปพลิเคชัน:

app.post('/', (req, res) => {
  res.send('Got a POST request')
})


ตอบสนองต่อการร้องขอด้วยวิธี PUT บนเส้นทาง /user:

app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})


ตอบสนองต่อการร้องขอด้วยวิธี DELETE บนเส้นทาง /user:

app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})

สำหรับข้อมูลเพิ่มเติมเกี่ยวกับการกำหนดเส้นทาง ดูได้ที่ คำแนะนำการกำหนดเส้นทาง

              
    
    Edit this page\n\nเส้นทางเบื้องต้น

เส้นทาง (Routing) เป็นการกำหนดการอ้างอิงว่าแอปพลิเคชันจะตอบสนองต่อคำร้องขอของเครื่องลูกข่ายที่มายังปลายทาง (endpoint) โดยเฉพาะได้อย่างไร ซึ่งเป็น URI (หรือ path) และวิธีการร้องขอ HTTP (GET, POST, และ อื่นๆ)

แต่ละเส้นทางสามารถมีได้มากกว่าหนึ่งฟังชันส์จัดการ (handler function) ซึ่งสามารถดำเนินการเมื่อเส้นทางถูกจับคู่

การกำหนดเส้นทางใช้โครงสร้างดังนี้:

app.METHOD(PATH, HANDLER)


เมื่อ:


  app เป็นอินสแตนซ์ของ express.
  METHOD เป็น HTTP request method, เป็นตัวพิมพ์เล็ก.
  PATH เป็นเส้นทางบนเซิร์ฟเวอร์.
  HANDLER เป็นฟังชันส์ที่กระทำเมื่อเส้นทางถูกจับคู่.



  การสอนนี้จะสมมติว่าอินสแตนซ์ของ express ชื่อว่า app จะถูกสร้างขึ้นเมื่อรันเซิร์ฟเวอร์ ถ้าไม่คุ้นเคยกับการสร้าง app และโครงสร้างของมัน ดูเพิ่มเติมได้ที่ ตัวอย่าง Hello world


ตัวอย่างดังต่อไปนี้จะแสดงให้เห็นการกำหนดเส้นทางอย่างง่าย

ตอบสนองด้วยข้อความ Hello World! บนเพจหลัก:

app.get('/', (req, res) => {
  res.send('Hello World!')
})


ตอบสนองต่อการร้องขอด้วยวิธี POST บนเส้นทาง root (/) บนเพจหลักของแอปพลิเคชัน:

app.post('/', (req, res) => {
  res.send('Got a POST request')
})


ตอบสนองต่อการร้องขอด้วยวิธี PUT บนเส้นทาง /user:

app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})


ตอบสนองต่อการร้องขอด้วยวิธี DELETE บนเส้นทาง /user:

app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})

สำหรับข้อมูลเพิ่มเติมเกี่ยวกับการกำหนดเส้นทาง ดูได้ที่ คำแนะนำการกำหนดเส้นทาง

              
    
    Edit this page\n\n\n\nDasar routing

Routing mengacu pada cara menentukan bagaimana aplikasi merespons permintaan klien ke titik akhir (endpoint) tertentu, yang merupakan URI (atau jalur) dan mengirimkan metode permintaan HTTP tertentu (GET, POST, dan seterusnya).

Setiap rute dapat memiliki satu atau lebih fungsi pengendali, yang dijalankan ketika rute yang dipanggil tersebut cocok.

Definisi rute tersebut mengambil struktur sebagai berikut:

app.METHOD(PATH, HANDLER)


Dimana:


  app adalah sebuah class dari express.
  METHOD adalah sebuah Metode HTTP request, dalam huruf kecil.
  PATH adalah path atau jalur yang didefinisikan di server.
  HANDLER adalah function yang dijalankan ketika rute yang dipanggil cocok.



  Pada tutorial ini mengasumsikan bahwa class dari express bernama app telah dibuat dan server sedang berjalan. Jika Anda belum terbiasa dalam membuat sebuah aplikasi dan memulainya, Anda dapat melihat Contoh hello world.


Contoh berikut ini akan mengilustrasikan cara pendefinisian rute secara sederhana.

Respons dengan Hello World! di halaman home:

app.get('/', (req, res) => {
  res.send('Hello World!')
})


Respons dengan metode request POST pada rute root (/), halaman home aplikasi:

app.post('/', (req, res) => {
  res.send('Got a POST request')
})


Respons dengan metode request PUT pada rute /user:

app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})


Respons dengan metode request DELETE pada rute /user:

app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})


Untuk detail lebih lanjut tentang perutean, Anda dapat melihat panduan routing.

Previous: Express application generator     Next: Serving static files in Express 

              
    
    Edit this page\n\nDasar routing

Routing mengacu pada cara menentukan bagaimana aplikasi merespons permintaan klien ke titik akhir (endpoint) tertentu, yang merupakan URI (atau jalur) dan mengirimkan metode permintaan HTTP tertentu (GET, POST, dan seterusnya).

Setiap rute dapat memiliki satu atau lebih fungsi pengendali, yang dijalankan ketika rute yang dipanggil tersebut cocok.

Definisi rute tersebut mengambil struktur sebagai berikut:

app.METHOD(PATH, HANDLER)


Dimana:


  app adalah sebuah class dari express.
  METHOD adalah sebuah Metode HTTP request, dalam huruf kecil.
  PATH adalah path atau jalur yang didefinisikan di server.
  HANDLER adalah function yang dijalankan ketika rute yang dipanggil cocok.



  Pada tutorial ini mengasumsikan bahwa class dari express bernama app telah dibuat dan server sedang berjalan. Jika Anda belum terbiasa dalam membuat sebuah aplikasi dan memulainya, Anda dapat melihat Contoh hello world.


Contoh berikut ini akan mengilustrasikan cara pendefinisian rute secara sederhana.

Respons dengan Hello World! di halaman home:

app.get('/', (req, res) => {
  res.send('Hello World!')
})


Respons dengan metode request POST pada rute root (/), halaman home aplikasi:

app.post('/', (req, res) => {
  res.send('Got a POST request')
})


Respons dengan metode request PUT pada rute /user:

app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})


Respons dengan metode request DELETE pada rute /user:

app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})


Untuk detail lebih lanjut tentang perutean, Anda dapat melihat panduan routing.

Previous: Express application generator     Next: Serving static files in Express 

              
    
    Edit this page\n\n\n\nBasic routing

Routing refers to determining how an application responds to a client request to a particular endpoint, which is a URI (or path) and a specific HTTP request method (GET, POST, and so on).

Each route can have one or more handler functions, which are executed when the route is matched.

Route definition takes the following structure:

app.METHOD(PATH, HANDLER)


Where:


  app is an instance of express.
  METHOD is an HTTP request method, in lowercase.
  PATH is a path on the server.
  HANDLER is the function executed when the route is matched.



  This tutorial assumes that an instance of express named app is created and the server is running. If you are not familiar with creating an app and starting it, see the Hello world example.


The following examples illustrate defining simple routes.

Respond with Hello World! on the homepage:

app.get('/', (req, res) => {
  res.send('Hello World!')
})


Respond to POST request on the root route (/), the application’s home page:

app.post('/', (req, res) => {
  res.send('Got a POST request')
})


Respond to a PUT request to the /user route:

app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})


Respond to a DELETE request to the /user route:

app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})


For more details about routing, see the routing guide.

Previous: Express application generator     Next: Serving static files in Express 

              
    
    Edit this page\n\nBasic routing

Routing refers to determining how an application responds to a client request to a particular endpoint, which is a URI (or path) and a specific HTTP request method (GET, POST, and so on).

Each route can have one or more handler functions, which are executed when the route is matched.

Route definition takes the following structure:

app.METHOD(PATH, HANDLER)


Where:


  app is an instance of express.
  METHOD is an HTTP request method, in lowercase.
  PATH is a path on the server.
  HANDLER is the function executed when the route is matched.



  This tutorial assumes that an instance of express named app is created and the server is running. If you are not familiar with creating an app and starting it, see the Hello world example.


The following examples illustrate defining simple routes.

Respond with Hello World! on the homepage:

app.get('/', (req, res) => {
  res.send('Hello World!')
})


Respond to POST request on the root route (/), the application’s home page:

app.post('/', (req, res) => {
  res.send('Got a POST request')
})


Respond to a PUT request to the /user route:

app.put('/user', (req, res) => {
  res.send('Got a PUT request at /user')
})


Respond to a DELETE request to the /user route:

app.delete('/user', (req, res) => {
  res.send('Got a DELETE request at /user')
})


For more details about routing, see the routing guide.

Previous: Express application generator     Next: Serving static files in Express 

              
    
    Edit this page\n\n\n\nServir des fichiers statiques dans Express

Pour servir des fichiers statiques tels que les images, les
fichiers CSS et les fichiers JavaScript, utilisez la fonction de
logiciel intermédiaire intégré express.static dans Express.

Passez le nom du répertoire qui contient les actifs
statiques dans la fonction de logiciel intermédiaire
express.static afin de commencer à servir
les fichiers directement. Par exemple, utilisez le code suivant pour
servir des images, des fichiers CSS et des fichiers JavaScript dans
un répertoire nommé public :

app.use(express.static('public'))


Maintenant, vous pouvez charger les fichiers qui sont dans le
répertoire public :

http://localhost:3000/images/kitten.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/app.js
http://localhost:3000/images/bg.png
http://localhost:3000/hello.html



Express recherche les fichiers relatifs au répertoire statique, donc
le nom du répertoire statique ne fait pas partie de l'URL.


Pour utiliser plusieurs répertoires statiques actifs,
utilisez la fonction middleware
express.static plusieurs fois :

app.use(express.static('public'))
app.use(express.static('files'))


Express recherche les fichiers dans l’ordre dans lequel vous
avez établi les répertoires statiques avec la fonction middleware express.static.

Pour créer un préfixe de chemin d’accès virtuel (dans lequel le
chemin d’accès n’existe pas vraiment dans le système de fichiers)
pour les fichiers qui sont servis par la fonction
express.static, indiquez un
chemin de montage pour le répertoire statique, comme démontré
ci-dessous :

app.use('/static', express.static('public'))


Maintenant, vous pouvez charger les fichiers qui sont dans le
répertoire public à partir du préfixe de chemin
d’accès /static.

http://localhost:3000/static/images/kitten.jpg
http://localhost:3000/static/css/style.css
http://localhost:3000/static/js/app.js
http://localhost:3000/static/images/bg.png
http://localhost:3000/static/hello.html


Cependant, le chemin d’accès que vous fournissez à la
fonction express.static est en rapport avec
le répertoire à partir duquel vous lancez votre processus node. Si
vous exécutez l’application express à partir d’un autre répertoire, il
est plus sûr d’utiliser le chemin d’accès absolu que vous voulez
servir :

const path = require('path')
app.use('/static', express.static(path.join(__dirname, 'public')))


              
    
    Edit this page\n\nServir des fichiers statiques dans Express

Pour servir des fichiers statiques tels que les images, les
fichiers CSS et les fichiers JavaScript, utilisez la fonction de
logiciel intermédiaire intégré express.static dans Express.

Passez le nom du répertoire qui contient les actifs
statiques dans la fonction de logiciel intermédiaire
express.static afin de commencer à servir
les fichiers directement. Par exemple, utilisez le code suivant pour
servir des images, des fichiers CSS et des fichiers JavaScript dans
un répertoire nommé public :

app.use(express.static('public'))


Maintenant, vous pouvez charger les fichiers qui sont dans le
répertoire public :

http://localhost:3000/images/kitten.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/app.js
http://localhost:3000/images/bg.png
http://localhost:3000/hello.html



Express recherche les fichiers relatifs au répertoire statique, donc
le nom du répertoire statique ne fait pas partie de l'URL.


Pour utiliser plusieurs répertoires statiques actifs,
utilisez la fonction middleware
express.static plusieurs fois :

app.use(express.static('public'))
app.use(express.static('files'))


Express recherche les fichiers dans l’ordre dans lequel vous
avez établi les répertoires statiques avec la fonction middleware express.static.

Pour créer un préfixe de chemin d’accès virtuel (dans lequel le
chemin d’accès n’existe pas vraiment dans le système de fichiers)
pour les fichiers qui sont servis par la fonction
express.static, indiquez un
chemin de montage pour le répertoire statique, comme démontré
ci-dessous :

app.use('/static', express.static('public'))


Maintenant, vous pouvez charger les fichiers qui sont dans le
répertoire public à partir du préfixe de chemin
d’accès /static.

http://localhost:3000/static/images/kitten.jpg
http://localhost:3000/static/css/style.css
http://localhost:3000/static/js/app.js
http://localhost:3000/static/images/bg.png
http://localhost:3000/static/hello.html


Cependant, le chemin d’accès que vous fournissez à la
fonction express.static est en rapport avec
le répertoire à partir duquel vous lancez votre processus node. Si
vous exécutez l’application express à partir d’un autre répertoire, il
est plus sûr d’utiliser le chemin d’accès absolu que vous voulez
servir :

const path = require('path')
app.use('/static', express.static(path.join(__dirname, 'public')))


              
    
    Edit this page\n\n\n\nStatische Dateien in Express bereitstellen

Wenn Sie statische Dateien wie Bilder, CSS-Dateien und JavaScript-Dateien bereitstellen wollen, verwenden Sie die in Express integrierte Middlewarefunktion express.static.

Übergeben Sie den Namen des Verzeichnisses mit den statischen Assets an die Middlewarefunktion express.static, um direkt mit dem Bereitstellen der Dateien zu beginnen. Beispiel: Verwenden Sie den folgenden Code, um Bilder, CSS-Dateien und JavaScript-Dateien in einem Verzeichnis namens public bereitzustellen:

app.use(express.static('public'))


Jetzt können Sie die Dateien laden, die sich im Verzeichnis public befinden:

http://localhost:3000/images/kitten.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/app.js
http://localhost:3000/images/bg.png
http://localhost:3000/hello.html



Express sucht nach den Dateien, die sich auf das Verzeichnis mit den statischen Assets beziehen. Der Name dieses Verzeichnisses ist also nicht Teil der URL. 

Wenn Sie mehrere Verzeichnisse mit statischen Assets verwenden wollen, rufen Sie die Middlewarefunktion express.static mehrmals auf:

app.use(express.static('public'))
app.use(express.static('files'))


Express sucht in der Reihenfolge nach den Dateien, in der sie die Verzeichnisse mit den statischen Assets über die Middlewarefunktion express.static festgelegt haben.

Wenn Sie ein Präfix für einen virtuellen Pfad (in dem der Pfad nicht wirklich im Dateisystem existiert) für Dateien festlegen wollen, die über die Funktion express.static bereitgestellt werden, müssen Sie einen Mountpfad für das Verzeichnis mit den statischen Assets wie unten gezeigt angeben:

app.use('/static', express.static('public'))


Jetzt können Sie die Dateien, die sich im Verzeichnis public befinden, aus dem Pfadpräfix /static laden.

http://localhost:3000/static/images/kitten.jpg
http://localhost:3000/static/css/style.css
http://localhost:3000/static/js/app.js
http://localhost:3000/static/images/bg.png
http://localhost:3000/static/hello.html


Der Pfad, den Sie für die Funktion express.static angeben, ist jedoch relativ zum Verzeichnis, aus dem Sie Ihren Prozess node starten. Wenn Sie die Express-Anwendung aus einem anderen Verzeichnis ausführen, ist es sicherer, den absoluten Pfad des Verzeichnisses zu verwenden, das Sie bereitstellen wollen:

const path = require('path')
app.use('/static', express.static(path.join(__dirname, 'public')))


              
    
    Edit this page\n\nStatische Dateien in Express bereitstellen

Wenn Sie statische Dateien wie Bilder, CSS-Dateien und JavaScript-Dateien bereitstellen wollen, verwenden Sie die in Express integrierte Middlewarefunktion express.static.

Übergeben Sie den Namen des Verzeichnisses mit den statischen Assets an die Middlewarefunktion express.static, um direkt mit dem Bereitstellen der Dateien zu beginnen. Beispiel: Verwenden Sie den folgenden Code, um Bilder, CSS-Dateien und JavaScript-Dateien in einem Verzeichnis namens public bereitzustellen:

app.use(express.static('public'))


Jetzt können Sie die Dateien laden, die sich im Verzeichnis public befinden:

http://localhost:3000/images/kitten.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/app.js
http://localhost:3000/images/bg.png
http://localhost:3000/hello.html



Express sucht nach den Dateien, die sich auf das Verzeichnis mit den statischen Assets beziehen. Der Name dieses Verzeichnisses ist also nicht Teil der URL. 

Wenn Sie mehrere Verzeichnisse mit statischen Assets verwenden wollen, rufen Sie die Middlewarefunktion express.static mehrmals auf:

app.use(express.static('public'))
app.use(express.static('files'))


Express sucht in der Reihenfolge nach den Dateien, in der sie die Verzeichnisse mit den statischen Assets über die Middlewarefunktion express.static festgelegt haben.

Wenn Sie ein Präfix für einen virtuellen Pfad (in dem der Pfad nicht wirklich im Dateisystem existiert) für Dateien festlegen wollen, die über die Funktion express.static bereitgestellt werden, müssen Sie einen Mountpfad für das Verzeichnis mit den statischen Assets wie unten gezeigt angeben:

app.use('/static', express.static('public'))


Jetzt können Sie die Dateien, die sich im Verzeichnis public befinden, aus dem Pfadpräfix /static laden.

http://localhost:3000/static/images/kitten.jpg
http://localhost:3000/static/css/style.css
http://localhost:3000/static/js/app.js
http://localhost:3000/static/images/bg.png
http://localhost:3000/static/hello.html


Der Pfad, den Sie für die Funktion express.static angeben, ist jedoch relativ zum Verzeichnis, aus dem Sie Ihren Prozess node starten. Wenn Sie die Express-Anwendung aus einem anderen Verzeichnis ausführen, ist es sicherer, den absoluten Pfad des Verzeichnisses zu verwenden, das Sie bereitstellen wollen:

const path = require('path')
app.use('/static', express.static(path.join(__dirname, 'public')))


              
    
    Edit this page\n\n\n\nServicio de archivos estáticos en Express

Para el servicio de archivos estáticos como, por ejemplo, imágenes, archivos CSS y archivos JavaScript, utilice la función de middleware incorporado express.static de Express.

Pase el nombre del directorio que contiene los activos estáticos a la función de middleware express.static para empezar directamente el servicio de los archivos. Por ejemplo, utilice el siguiente código para el servicio de imágenes, archivos CSS y archivos JavaScript en un directorio denominado public:

app.use(express.static('public'))


Ahora, puede cargar los archivos que hay en el directorio public:

http://localhost:3000/images/kitten.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/app.js
http://localhost:3000/images/bg.png
http://localhost:3000/hello.html



Express busca los archivos relativos al directorio estático, por lo que el nombre del directorio estático no forma parte del URL.


Para utilizar varios directorios de activos estáticos, invoque la función de middleware express.static varias veces:

app.use(express.static('public'))
app.use(express.static('files'))


Express busca los archivos en el orden en el que se definen los directorios estáticos con la función de middleware express.static.

Para crear un prefijo de vía de acceso virtual (donde la vía de acceso no existe realmente en el sistema de archivos) para los archivos a los que da servicio la función express.static, especifique una vía de acceso de montaje para el directorio estático, como se muestra a continuación:

app.use('/static', express.static('public'))


Ahora, puede cargar los archivos que hay en el directorio public desde el prefijo de vía de acceso /static.

http://localhost:3000/static/images/kitten.jpg
http://localhost:3000/static/css/style.css
http://localhost:3000/static/js/app.js
http://localhost:3000/static/images/bg.png
http://localhost:3000/static/hello.html


No obstante, la vía de acceso que proporciona a la función express.static es relativa al directorio desde donde inicia el proceso node. Si ejecuta la aplicación Express desde cualquier otro directorio, es más seguro utilizar la vía de acceso absoluta del directorio al que desea dar servicio:

const path = require('path')
app.use('/static', express.static(path.join(__dirname, 'public')))


              
    
    Edit this page\n\nServicio de archivos estáticos en Express

Para el servicio de archivos estáticos como, por ejemplo, imágenes, archivos CSS y archivos JavaScript, utilice la función de middleware incorporado express.static de Express.

Pase el nombre del directorio que contiene los activos estáticos a la función de middleware express.static para empezar directamente el servicio de los archivos. Por ejemplo, utilice el siguiente código para el servicio de imágenes, archivos CSS y archivos JavaScript en un directorio denominado public:

app.use(express.static('public'))


Ahora, puede cargar los archivos que hay en el directorio public:

http://localhost:3000/images/kitten.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/app.js
http://localhost:3000/images/bg.png
http://localhost:3000/hello.html



Express busca los archivos relativos al directorio estático, por lo que el nombre del directorio estático no forma parte del URL.


Para utilizar varios directorios de activos estáticos, invoque la función de middleware express.static varias veces:

app.use(express.static('public'))
app.use(express.static('files'))


Express busca los archivos en el orden en el que se definen los directorios estáticos con la función de middleware express.static.

Para crear un prefijo de vía de acceso virtual (donde la vía de acceso no existe realmente en el sistema de archivos) para los archivos a los que da servicio la función express.static, especifique una vía de acceso de montaje para el directorio estático, como se muestra a continuación:

app.use('/static', express.static('public'))


Ahora, puede cargar los archivos que hay en el directorio public desde el prefijo de vía de acceso /static.

http://localhost:3000/static/images/kitten.jpg
http://localhost:3000/static/css/style.css
http://localhost:3000/static/js/app.js
http://localhost:3000/static/images/bg.png
http://localhost:3000/static/hello.html


No obstante, la vía de acceso que proporciona a la función express.static es relativa al directorio desde donde inicia el proceso node. Si ejecuta la aplicación Express desde cualquier otro directorio, es más seguro utilizar la vía de acceso absoluta del directorio al que desea dar servicio:

const path = require('path')
app.use('/static', express.static(path.join(__dirname, 'public')))


              
    
    Edit this page\n\n\n\nGestione dei file statici in Express

Per gestire i file statici, quali immagini, file CSS e file JavaScript, utilizzare la funzione middleware integrata express.static in Express.

Fornire il nome della directory che contiene gli asset statici alla funzione middleware express.static per iniziare a gestire i file direttamente. Ad esempio, utilizzare il seguente codice per gestire le immagini, i file CSS e i file JavaScript nella directory denominata public:

app.use(express.static('public'))


Ora, è possibile caricare i file che si trovano nella directory public:

http://localhost:3000/images/kitten.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/app.js
http://localhost:3000/images/bg.png
http://localhost:3000/hello.html



Express ricerca i file relativi alla directory statica, pertanto il nome della directory statica non è parte dell'URL.


Per utilizzare più directory di asset statiche, richiamare la funzione middleware express.static più volte:

app.use(express.static('public'))
app.use(express.static('files'))


Express ricerca i file nell’ordine in cui sono state impostate le directory statiche con la funzione middleware express.static.

Per creare un prefisso per il percorso virtuale (in cui il percorso non esiste effettivamente nel file system) per i file gestiti dalla funzione express.static, specificare un percorso di caricamento per la directory statica, come mostrato di seguito:

app.use('/static', express.static('public'))


Ora, è possibile caricare i file che si trovano nella directory public dal prefisso del percorso /static.

http://localhost:3000/static/images/kitten.jpg
http://localhost:3000/static/css/style.css
http://localhost:3000/static/js/app.js
http://localhost:3000/static/images/bg.png
http://localhost:3000/static/hello.html


Tuttavia, il percorso fornito per la funzione express.static è relativo alla directory dalla quale è possibile avviare il processo node. Se si esegue l’applicazione express da un’altra directory, è preferibile utilizzare il percorso assoluto della directory che si desidera gestire:

const path = require('path')
app.use('/static', express.static(path.join(__dirname, 'public')))


              
    
    Edit this page\n\nGestione dei file statici in Express

Per gestire i file statici, quali immagini, file CSS e file JavaScript, utilizzare la funzione middleware integrata express.static in Express.

Fornire il nome della directory che contiene gli asset statici alla funzione middleware express.static per iniziare a gestire i file direttamente. Ad esempio, utilizzare il seguente codice per gestire le immagini, i file CSS e i file JavaScript nella directory denominata public:

app.use(express.static('public'))


Ora, è possibile caricare i file che si trovano nella directory public:

http://localhost:3000/images/kitten.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/app.js
http://localhost:3000/images/bg.png
http://localhost:3000/hello.html



Express ricerca i file relativi alla directory statica, pertanto il nome della directory statica non è parte dell'URL.


Per utilizzare più directory di asset statiche, richiamare la funzione middleware express.static più volte:

app.use(express.static('public'))
app.use(express.static('files'))


Express ricerca i file nell’ordine in cui sono state impostate le directory statiche con la funzione middleware express.static.

Per creare un prefisso per il percorso virtuale (in cui il percorso non esiste effettivamente nel file system) per i file gestiti dalla funzione express.static, specificare un percorso di caricamento per la directory statica, come mostrato di seguito:

app.use('/static', express.static('public'))


Ora, è possibile caricare i file che si trovano nella directory public dal prefisso del percorso /static.

http://localhost:3000/static/images/kitten.jpg
http://localhost:3000/static/css/style.css
http://localhost:3000/static/js/app.js
http://localhost:3000/static/images/bg.png
http://localhost:3000/static/hello.html


Tuttavia, il percorso fornito per la funzione express.static è relativo alla directory dalla quale è possibile avviare il processo node. Se si esegue l’applicazione express da un’altra directory, è preferibile utilizzare il percorso assoluto della directory che si desidera gestire:

const path = require('path')
app.use('/static', express.static(path.join(__dirname, 'public')))


              
    
    Edit this page\n\n\n\nExpress での静的ファイルの提供

イメージ、CSS ファイル、JavaScript ファイルなどの静的ファイルを提供するには、Express に標準実装されている express.static ミドルウェア関数を使用します。

静的アセットファイルを格納しているディレクトリーの名前を express.static ミドルウェア関数に渡して、ファイルの直接提供を開始します。例えば、public というディレクトリー内のイメージ、CSS ファイル、JavaScript ファイルを提供するには、次のコードを使用します。

app.use(express.static('public'))


これで、public ディレクトリーに入っているファイルをロードできます。

http://localhost:3000/images/kitten.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/app.js
http://localhost:3000/images/bg.png
http://localhost:3000/hello.html



Express は、静的ディレクトリーから相対的なファイルを検索するため、静的ディレクトリーの名前は URL の一部ではありません。


複数の静的アセットディレクトリーを使用するには、express.static ミドルウェア関数を複数回呼び出します。

app.use(express.static('public'))
app.use(express.static('files'))


Express は、express.static ミドルウェア関数に静的ディレクトリーが設定された順序でファイルを検索します。

express.static 関数によって提供されるファイルの仮想パスのプレフィックス (パスは実際にはファイル・システムに存在しません) を作成するには、次に示すように、静的ディレクトリーのマウント・パスを指定します。

app.use('/static', express.static('public'))


これで、public ディレクトリー内のファイルを /static パス・プレフィックスからロードできます。

http://localhost:3000/static/images/kitten.jpg
http://localhost:3000/static/css/style.css
http://localhost:3000/static/js/app.js
http://localhost:3000/static/images/bg.png
http://localhost:3000/static/hello.html


ただし、express.static 関数に指定するパスは、node プロセスを起動するディレクトリーに対して相対的です。別のディレクトリーから Express アプリケーションを実行する場合は、提供するディレクトリーの絶対パスを使用する方が安全です。

const path = require('path')
app.use('/static', express.static(path.join(__dirname, 'public')))


              
    
    Edit this page\n\nExpress での静的ファイルの提供

イメージ、CSS ファイル、JavaScript ファイルなどの静的ファイルを提供するには、Express に標準実装されている express.static ミドルウェア関数を使用します。

静的アセットファイルを格納しているディレクトリーの名前を express.static ミドルウェア関数に渡して、ファイルの直接提供を開始します。例えば、public というディレクトリー内のイメージ、CSS ファイル、JavaScript ファイルを提供するには、次のコードを使用します。

app.use(express.static('public'))


これで、public ディレクトリーに入っているファイルをロードできます。

http://localhost:3000/images/kitten.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/app.js
http://localhost:3000/images/bg.png
http://localhost:3000/hello.html



Express は、静的ディレクトリーから相対的なファイルを検索するため、静的ディレクトリーの名前は URL の一部ではありません。


複数の静的アセットディレクトリーを使用するには、express.static ミドルウェア関数を複数回呼び出します。

app.use(express.static('public'))
app.use(express.static('files'))


Express は、express.static ミドルウェア関数に静的ディレクトリーが設定された順序でファイルを検索します。

express.static 関数によって提供されるファイルの仮想パスのプレフィックス (パスは実際にはファイル・システムに存在しません) を作成するには、次に示すように、静的ディレクトリーのマウント・パスを指定します。

app.use('/static', express.static('public'))


これで、public ディレクトリー内のファイルを /static パス・プレフィックスからロードできます。

http://localhost:3000/static/images/kitten.jpg
http://localhost:3000/static/css/style.css
http://localhost:3000/static/js/app.js
http://localhost:3000/static/images/bg.png
http://localhost:3000/static/hello.html


ただし、express.static 関数に指定するパスは、node プロセスを起動するディレクトリーに対して相対的です。別のディレクトリーから Express アプリケーションを実行する場合は、提供するディレクトリーの絶対パスを使用する方が安全です。

const path = require('path')
app.use('/static', express.static(path.join(__dirname, 'public')))


              
    
    Edit this page\n\n\n\nПредоставление статических файлов в Express

Для предоставления статических файлов, например, изображений, файлов CSS и JavaScript в Express используется функция промежуточной обработки express.static.

Для того чтобы начать непосредственное предоставление файлов, необходимо передать имя каталога, в котором находятся статические ресурсы, в функцию промежуточной обработки express.static. Например, воспользуйтесь приведенным ниже кодом для предоставления изображений, файлов CSS и JavaScript, расположенных в каталоге public:

app.use(express.static('public'))


Теперь можно загрузить файлы, находящиеся в каталоге public directory:

http://localhost:3000/images/kitten.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/app.js
http://localhost:3000/images/bg.png
http://localhost:3000/hello.html



Express выполняет поиск файлов относительно статического каталога, поэтому имя статического каталога не является частью URL.


Для использования нескольких каталогов, содержащих статические ресурсы, необходимо вызвать функцию промежуточной обработки express.static несколько раз:

app.use(express.static('public'))
app.use(express.static('files'))


Express выполняет поиск файлов в том порядке, в котором указаны статические каталоги в функции промежуточной обработки express.static.

Для того чтобы создать префикс виртуального пути (то есть, пути, фактически не существующего в файловой системе) для файлов, предоставляемых с помощью функции express.static, необходимо указать путь монтирования для статического каталога, как показано ниже:

app.use('/static', express.static('public'))


Теперь можно загрузить файлы, находящиеся в каталоге public, указанного в префиксе пути /static.

http://localhost:3000/static/images/kitten.jpg
http://localhost:3000/static/css/style.css
http://localhost:3000/static/js/app.js
http://localhost:3000/static/images/bg.png
http://localhost:3000/static/hello.html


Тем не менее, путь, переданный в функцию express.static, указан относительно каталога, из которого запускается процесс node. В случае запуска приложения Express из другого каталога, безопаснее использовать абсолютный путь к каталогу для предоставления файлов:

const path = require('path')
app.use('/static', express.static(path.join(__dirname, 'public')))


              
    
    Edit this page\n\nПредоставление статических файлов в Express

Для предоставления статических файлов, например, изображений, файлов CSS и JavaScript в Express используется функция промежуточной обработки express.static.

Для того чтобы начать непосредственное предоставление файлов, необходимо передать имя каталога, в котором находятся статические ресурсы, в функцию промежуточной обработки express.static. Например, воспользуйтесь приведенным ниже кодом для предоставления изображений, файлов CSS и JavaScript, расположенных в каталоге public:

app.use(express.static('public'))


Теперь можно загрузить файлы, находящиеся в каталоге public directory:

http://localhost:3000/images/kitten.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/app.js
http://localhost:3000/images/bg.png
http://localhost:3000/hello.html



Express выполняет поиск файлов относительно статического каталога, поэтому имя статического каталога не является частью URL.


Для использования нескольких каталогов, содержащих статические ресурсы, необходимо вызвать функцию промежуточной обработки express.static несколько раз:

app.use(express.static('public'))
app.use(express.static('files'))


Express выполняет поиск файлов в том порядке, в котором указаны статические каталоги в функции промежуточной обработки express.static.

Для того чтобы создать префикс виртуального пути (то есть, пути, фактически не существующего в файловой системе) для файлов, предоставляемых с помощью функции express.static, необходимо указать путь монтирования для статического каталога, как показано ниже:

app.use('/static', express.static('public'))


Теперь можно загрузить файлы, находящиеся в каталоге public, указанного в префиксе пути /static.

http://localhost:3000/static/images/kitten.jpg
http://localhost:3000/static/css/style.css
http://localhost:3000/static/js/app.js
http://localhost:3000/static/images/bg.png
http://localhost:3000/static/hello.html


Тем не менее, путь, переданный в функцию express.static, указан относительно каталога, из которого запускается процесс node. В случае запуска приложения Express из другого каталога, безопаснее использовать абсолютный путь к каталогу для предоставления файлов:

const path = require('path')
app.use('/static', express.static(path.join(__dirname, 'public')))


              
    
    Edit this page\n\n\n\n在 Express 中提供静态文件

为了提供诸如图像、CSS 文件和 JavaScript 文件之类的静态文件，请使用 Express 中的 express.static 内置中间件函数。

将包含静态资源的目录的名称传递给 express.static 中间件函数，以便开始直接提供这些文件。例如，使用以下代码在名为 public 的目录中提供图像、CSS 文件和 JavaScript 文件：

app.use(express.static('public'))


现在，可以访问位于 public 目录中的文件：

http://localhost:3000/images/kitten.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/app.js
http://localhost:3000/images/bg.png
http://localhost:3000/hello.html



Express 相对于静态目录查找文件，因此静态目录的名称不是此 URL 的一部分。


要使用多个静态资源目录，请多次调用 express.static 中间件函数：

app.use(express.static('public'))
app.use(express.static('files'))


Express 以您使用 express.static 中间件函数设置静态目录的顺序来查找文件。

要为 express.static 函数提供的文件创建虚拟路径前缀（路径并不实际存在于文件系统中），请为静态目录指定安装路径，如下所示：

app.use('/static', express.static('public'))


现在，可以访问具有 /static 路径前缀的 public 目录中的文件。

http://localhost:3000/static/images/kitten.jpg
http://localhost:3000/static/css/style.css
http://localhost:3000/static/js/app.js
http://localhost:3000/static/images/bg.png
http://localhost:3000/static/hello.html


然而，向 express.static 函数提供的路径相对于您在其中启动 node 进程的目录。如果从另一个目录运行 Express 应用程序，那么对于提供资源的目录使用绝对路径会更安全：

const path = require('path')
app.use('/static', express.static(path.join(__dirname, 'public')))


              
    
    Edit this page\n\n在 Express 中提供静态文件

为了提供诸如图像、CSS 文件和 JavaScript 文件之类的静态文件，请使用 Express 中的 express.static 内置中间件函数。

将包含静态资源的目录的名称传递给 express.static 中间件函数，以便开始直接提供这些文件。例如，使用以下代码在名为 public 的目录中提供图像、CSS 文件和 JavaScript 文件：

app.use(express.static('public'))


现在，可以访问位于 public 目录中的文件：

http://localhost:3000/images/kitten.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/app.js
http://localhost:3000/images/bg.png
http://localhost:3000/hello.html



Express 相对于静态目录查找文件，因此静态目录的名称不是此 URL 的一部分。


要使用多个静态资源目录，请多次调用 express.static 中间件函数：

app.use(express.static('public'))
app.use(express.static('files'))


Express 以您使用 express.static 中间件函数设置静态目录的顺序来查找文件。

要为 express.static 函数提供的文件创建虚拟路径前缀（路径并不实际存在于文件系统中），请为静态目录指定安装路径，如下所示：

app.use('/static', express.static('public'))


现在，可以访问具有 /static 路径前缀的 public 目录中的文件。

http://localhost:3000/static/images/kitten.jpg
http://localhost:3000/static/css/style.css
http://localhost:3000/static/js/app.js
http://localhost:3000/static/images/bg.png
http://localhost:3000/static/hello.html


然而，向 express.static 函数提供的路径相对于您在其中启动 node 进程的目录。如果从另一个目录运行 Express 应用程序，那么对于提供资源的目录使用绝对路径会更安全：

const path = require('path')
app.use('/static', express.static(path.join(__dirname, 'public')))


              
    
    Edit this page\n\n\n\n在 Express 中提供靜態檔案

如果要提供影像、CSS 檔案和 JavaScript 檔案等之類的靜態檔案，請使用 Express 中的 express.static 內建中介軟體函數。

將含有靜態資產的目錄名稱傳遞給 express.static 中介軟體函數，就能直接開始提供檔案。舉例來說，使用下列程式碼在名稱是 public 的目錄中，提供影像、CSS 檔案和 JavaScript 檔案：

app.use(express.static('public'))


現在，您可以載入位於 public 目錄中的檔案：

http://localhost:3000/images/kitten.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/app.js
http://localhost:3000/images/bg.png
http://localhost:3000/hello.html



Express 會查閱靜態目錄的相對檔案，因此靜態目錄的名稱不是 URL 的一部分。


如果要使用多個靜態資產目錄，請呼叫 express.static 中介軟體函數多次：

app.use(express.static('public'))
app.use(express.static('files'))


Express 在查閱檔案時，會依照您使用 express.static 中介軟體函數來設定靜態目錄的順序。

如果要為 express.static 函數所提供的檔案，建立虛擬路徑字首（其中的路徑事實上不存在於檔案系統中），請為靜態目錄指定裝載路徑，如下所示：

app.use('/static', express.static('public'))


現在，您可以透過 /static 路徑字首，來載入 public 目錄中的檔案。

http://localhost:3000/static/images/kitten.jpg
http://localhost:3000/static/css/style.css
http://localhost:3000/static/js/app.js
http://localhost:3000/static/images/bg.png
http://localhost:3000/static/hello.html


不過，您提供給 express.static 函數的路徑，是相對於您從中啟動 node 程序的目錄。如果您是從另一個目錄執行 Express 應用程式，保險作法是使用您想提供之目錄的絕對路徑：

const path = require('path')
app.use('/static', express.static(path.join(__dirname, 'public')))


              
    
    Edit this page\n\n在 Express 中提供靜態檔案

如果要提供影像、CSS 檔案和 JavaScript 檔案等之類的靜態檔案，請使用 Express 中的 express.static 內建中介軟體函數。

將含有靜態資產的目錄名稱傳遞給 express.static 中介軟體函數，就能直接開始提供檔案。舉例來說，使用下列程式碼在名稱是 public 的目錄中，提供影像、CSS 檔案和 JavaScript 檔案：

app.use(express.static('public'))


現在，您可以載入位於 public 目錄中的檔案：

http://localhost:3000/images/kitten.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/app.js
http://localhost:3000/images/bg.png
http://localhost:3000/hello.html



Express 會查閱靜態目錄的相對檔案，因此靜態目錄的名稱不是 URL 的一部分。


如果要使用多個靜態資產目錄，請呼叫 express.static 中介軟體函數多次：

app.use(express.static('public'))
app.use(express.static('files'))


Express 在查閱檔案時，會依照您使用 express.static 中介軟體函數來設定靜態目錄的順序。

如果要為 express.static 函數所提供的檔案，建立虛擬路徑字首（其中的路徑事實上不存在於檔案系統中），請為靜態目錄指定裝載路徑，如下所示：

app.use('/static', express.static('public'))


現在，您可以透過 /static 路徑字首，來載入 public 目錄中的檔案。

http://localhost:3000/static/images/kitten.jpg
http://localhost:3000/static/css/style.css
http://localhost:3000/static/js/app.js
http://localhost:3000/static/images/bg.png
http://localhost:3000/static/hello.html


不過，您提供給 express.static 函數的路徑，是相對於您從中啟動 node 程序的目錄。如果您是從另一個目錄執行 Express 應用程式，保險作法是使用您想提供之目錄的絕對路徑：

const path = require('path')
app.use('/static', express.static(path.join(__dirname, 'public')))


              
    
    Edit this page\n\n\n\nExpress에서 정적 파일 제공

이미지, CSS 파일 및 JavaScript 파일과 같은 정적 파일을 제공하려면 Express의 기본 제공 미들웨어 함수인 express.static을 사용하십시오.

정적 자산이 포함된 디렉토리의 이름을 express.static 미들웨어 함수에 전달하면 파일의 직접적인 제공을 시작할 수 있습니다. 예를 들면, 다음과 같은 코드를 이용하여 public이라는 이름의 디렉토리에 포함된 이미지, CSS 파일 및 JavaScript 파일을 제공하십시오.

app.use(express.static('public'))


이제 다음과 같이 public 디렉토리에 포함된 파일을 로드할 수 있습니다.

http://localhost:3000/images/kitten.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/app.js
http://localhost:3000/images/bg.png
http://localhost:3000/hello.html



Express는 정적 디렉토리에 대해 상대적으로 파일을 검색하며, 따라서 정적 디렉토리의 이름은 URL의 일부가 아닙니다.


여러 개의 정적 자산 디렉토리를 이용하려면 다음과 같이 express.static 미들웨어 함수를 여러 번 호출하십시오.

app.use(express.static('public'))
app.use(express.static('files'))


Express는 express.static 미들웨어 함수를 이용해 정적 디렉토리를 설정한 순서대로 파일을 검색합니다.

express.static 함수를 통해 제공되는 파일에 대한 가상 경로 접두부(파일 시스템 내에 해당 경로가 실제로 존재하지 않는 경우)를 작성하려면, 아래에 표시된 것과 같이 정적 디렉토리에 대한 마운트 경로를 지정하십시오.

app.use('/static', express.static('public'))


이제 /static 경로 접두부를 통해 public 디렉토리에 포함된 파일을 로드할 수 있습니다.

http://localhost:3000/static/images/kitten.jpg
http://localhost:3000/static/css/style.css
http://localhost:3000/static/js/app.js
http://localhost:3000/static/images/bg.png
http://localhost:3000/static/hello.html


그러나 express.static 함수에 제공되는 경로는 node 프로세스가 실행되는 디렉토리에 대해 상대적입니다. Express 앱을 다른 디렉토리에서 실행하는 경우에는 다음과 같이 제공하기 원하는 디렉토리의 절대 경로를 사용하는 것이 더 안전합니다.

const path = require('path')
app.use('/static', express.static(path.join(__dirname, 'public')))


              
    
    Edit this page\n\nExpress에서 정적 파일 제공

이미지, CSS 파일 및 JavaScript 파일과 같은 정적 파일을 제공하려면 Express의 기본 제공 미들웨어 함수인 express.static을 사용하십시오.

정적 자산이 포함된 디렉토리의 이름을 express.static 미들웨어 함수에 전달하면 파일의 직접적인 제공을 시작할 수 있습니다. 예를 들면, 다음과 같은 코드를 이용하여 public이라는 이름의 디렉토리에 포함된 이미지, CSS 파일 및 JavaScript 파일을 제공하십시오.

app.use(express.static('public'))


이제 다음과 같이 public 디렉토리에 포함된 파일을 로드할 수 있습니다.

http://localhost:3000/images/kitten.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/app.js
http://localhost:3000/images/bg.png
http://localhost:3000/hello.html



Express는 정적 디렉토리에 대해 상대적으로 파일을 검색하며, 따라서 정적 디렉토리의 이름은 URL의 일부가 아닙니다.


여러 개의 정적 자산 디렉토리를 이용하려면 다음과 같이 express.static 미들웨어 함수를 여러 번 호출하십시오.

app.use(express.static('public'))
app.use(express.static('files'))


Express는 express.static 미들웨어 함수를 이용해 정적 디렉토리를 설정한 순서대로 파일을 검색합니다.

express.static 함수를 통해 제공되는 파일에 대한 가상 경로 접두부(파일 시스템 내에 해당 경로가 실제로 존재하지 않는 경우)를 작성하려면, 아래에 표시된 것과 같이 정적 디렉토리에 대한 마운트 경로를 지정하십시오.

app.use('/static', express.static('public'))


이제 /static 경로 접두부를 통해 public 디렉토리에 포함된 파일을 로드할 수 있습니다.

http://localhost:3000/static/images/kitten.jpg
http://localhost:3000/static/css/style.css
http://localhost:3000/static/js/app.js
http://localhost:3000/static/images/bg.png
http://localhost:3000/static/hello.html


그러나 express.static 함수에 제공되는 경로는 node 프로세스가 실행되는 디렉토리에 대해 상대적입니다. Express 앱을 다른 디렉토리에서 실행하는 경우에는 다음과 같이 제공하기 원하는 디렉토리의 절대 경로를 사용하는 것이 더 안전합니다.

const path = require('path')
app.use('/static', express.static(path.join(__dirname, 'public')))


              
    
    Edit this page\n\n\n\nEntregando arquivos estáticos no Express

Para entregar arquivos estáticos como imagens, arquivos CSS, e
arquivos JavaScript, use a função de middleware express.static
integrada no Express.

Passe o nome do diretório que contém os ativos estáticos para a
função de middleware express.static para iniciar a
entregar os arquivos diretamente. Por exemplo, use o código a seguir
para entregar imagens, arquivos CSS, e arquivos JavaScript em um
diretório chamado public:

app.use(express.static('public'))


Agora, é possível carregar os arquivos que estão no diretório public:

http://localhost:3000/images/kitten.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/app.js
http://localhost:3000/images/bg.png
http://localhost:3000/hello.html



O Express consulta os arquivos em relação ao diretório estático, para
que o nome do diretório estático não faça parte da URL.


Para usar vários diretórios de ativos estáticos, chame a função
de middleware express.static várias vezes:

app.use(express.static('public'))
app.use(express.static('files'))


O Express consulta os arquivos na ordem em que você configurar
os diretórios estáticos com a função de middleware
express.static.

Para criar um prefixo de caminho virtual (onde o caminho não
existe realmente no sistema de arquivos) para arquivos que são
entregues pela função express.static,
especifique um caminho de montagem para o
diretório estático, como mostrado abaixo:

app.use('/static', express.static('public'))


Agora, é possível carregar os arquivos que estão no diretório
public a partir do prefixo do caminho /static.

http://localhost:3000/static/images/kitten.jpg
http://localhost:3000/static/css/style.css
http://localhost:3000/static/js/app.js
http://localhost:3000/static/images/bg.png
http://localhost:3000/static/hello.html


Entretanto, o caminho fornecido para a função
express.static é relativa ao diretório a partir do
qual você inicia o seu node de processo. Se você
executar o aplicativo express a partir de outro diretório, é mais
seguro utilizar o caminho absoluto do diretório para o qual deseja
entregar.

const path = require('path')
app.use('/static', express.static(path.join(__dirname, 'public')))


              
    
    Edit this page\n\nEntregando arquivos estáticos no Express

Para entregar arquivos estáticos como imagens, arquivos CSS, e
arquivos JavaScript, use a função de middleware express.static
integrada no Express.

Passe o nome do diretório que contém os ativos estáticos para a
função de middleware express.static para iniciar a
entregar os arquivos diretamente. Por exemplo, use o código a seguir
para entregar imagens, arquivos CSS, e arquivos JavaScript em um
diretório chamado public:

app.use(express.static('public'))


Agora, é possível carregar os arquivos que estão no diretório public:

http://localhost:3000/images/kitten.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/app.js
http://localhost:3000/images/bg.png
http://localhost:3000/hello.html



O Express consulta os arquivos em relação ao diretório estático, para
que o nome do diretório estático não faça parte da URL.


Para usar vários diretórios de ativos estáticos, chame a função
de middleware express.static várias vezes:

app.use(express.static('public'))
app.use(express.static('files'))


O Express consulta os arquivos na ordem em que você configurar
os diretórios estáticos com a função de middleware
express.static.

Para criar um prefixo de caminho virtual (onde o caminho não
existe realmente no sistema de arquivos) para arquivos que são
entregues pela função express.static,
especifique um caminho de montagem para o
diretório estático, como mostrado abaixo:

app.use('/static', express.static('public'))


Agora, é possível carregar os arquivos que estão no diretório
public a partir do prefixo do caminho /static.

http://localhost:3000/static/images/kitten.jpg
http://localhost:3000/static/css/style.css
http://localhost:3000/static/js/app.js
http://localhost:3000/static/images/bg.png
http://localhost:3000/static/hello.html


Entretanto, o caminho fornecido para a função
express.static é relativa ao diretório a partir do
qual você inicia o seu node de processo. Se você
executar o aplicativo express a partir de outro diretório, é mais
seguro utilizar o caminho absoluto do diretório para o qual deseja
entregar.

const path = require('path')
app.use('/static', express.static(path.join(__dirname, 'public')))


              
    
    Edit this page\n\n\n\n