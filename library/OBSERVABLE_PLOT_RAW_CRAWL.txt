MarksPlot doesn’t have chart types. Instead, it has layered geometric shapes such as bars, dots, and lines.ScalesScales map an abstract value such as time or temperature to a visual value such as position or color.TransformsDerive data on-the-fly while plotting, say to bin quantitative values or compute a rolling average.FacetsSmall multiples facilitate comparison by repeating a plot across partitions of data.ProjectionsPlot supports GeoJSON and D3’s spherical projection system for geographic maps.Built with D3Plot is built by the same team as D3. If you know some D3, you’ll be right at home with Plot.Visit D3 Plot without codeWith Observable’s chart cell, quickly create plots with a GUI, then eject to code to customize.Try chart cell Built by ObservablePlot is developed by Observable, the platform for collaborative data analysis.Visit Observable\n\nSearchK0.6.17GitHub️ 4.6k\n\nObservable PlotThe JavaScript library for exploratory data visualizationCreate expressive charts with concise codeGet startedWhat is Plot?Examples\n\n\n\nMarksPlot doesn’t have chart types. Instead, it has layered geometric shapes such as bars, dots, and lines.ScalesScales map an abstract value such as time or temperature to a visual value such as position or color.TransformsDerive data on-the-fly while plotting, say to bin quantitative values or compute a rolling average.FacetsSmall multiples facilitate comparison by repeating a plot across partitions of data.ProjectionsPlot supports GeoJSON and D3’s spherical projection system for geographic maps.Built with D3Plot is built by the same team as D3. If you know some D3, you’ll be right at home with Plot.Visit D3 Plot without codeWith Observable’s chart cell, quickly create plots with a GUI, then eject to code to customize.Try chart cell Built by ObservablePlot is developed by Observable, the platform for collaborative data analysis.Visit Observable\n\nSearchK0.6.17GitHub️ 4.6k\n\nObservable PlotThe JavaScript library for exploratory data visualizationCreate expressive charts with concise codeGet startedWhat is Plot?Examples\n\n\n\nMarksPlot doesn’t have chart types. Instead, it has layered geometric shapes such as bars, dots, and lines.ScalesScales map an abstract value such as time or temperature to a visual value such as position or color.TransformsDerive data on-the-fly while plotting, say to bin quantitative values or compute a rolling average.FacetsSmall multiples facilitate comparison by repeating a plot across partitions of data.ProjectionsPlot supports GeoJSON and D3’s spherical projection system for geographic maps.Built with D3Plot is built by the same team as D3. If you know some D3, you’ll be right at home with Plot.Visit D3 Plot without codeWith Observable’s chart cell, quickly create plots with a GUI, then eject to code to customize.Try chart cell Built by ObservablePlot is developed by Observable, the platform for collaborative data analysis.Visit Observable\n\nSearchK0.6.17GitHub️ 4.6k\n\nObservable PlotThe JavaScript library for exploratory data visualizationCreate expressive charts with concise codeGet startedWhat is Plot?Examples\n\n\n\nGetting started ​Observable Plot supports a variety of environments.Try Plot online ​The fastest way to get started (and get help) with Observable Plot is on Observable! Plot is available by default in notebooks as part of Observable’s standard library. To use Plot, simply return the generated plot from a cell like so:ForkjsPlot.rectY({length: 10000}, Plot.binX({y: "count"}, {x: d3.randomNormal()})).plot()Observable includes a variety of Plot snippets when you click + to add a cell, as well as convenient sample datasets to try out Plot features. Or upload a CSV or JSON file to start playing with your data. You can even use Observable’s chart cell, which uses Plot’s auto mark under the hood, to create quick charts without writing code! You can then eject to JavaScript by clicking + to see the equivalent Plot code.Observable’s chart cell lets you quickly create charts and then eject to Plot code.Observable is free for public use. Sign up for a Pro account to connect to private databases, collaborate on private notebooks, and more.Plot in vanilla HTML ​In vanilla HTML, you can load Plot from a CDN such as jsDelivr or you can download it locally. We recommend using the CDN-hosted ES module bundle as it automatically loads Plot’s dependency on D3. But for those who need it, we also provide a UMD bundle that exports the Plot global when loaded as a plain script.ESM + CDNUMD + CDNUMD + localhtml<!DOCTYPE html>
<div id="myplot"></div>
<script type="module">

import * as Plot from "https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm";

const plot = Plot.rectY({length: 10000}, Plot.binX({y: "count"}, {x: Math.random})).plot();
const div = document.querySelector("#myplot");
div.append(plot);

</script>html<!DOCTYPE html>
<div id="myplot"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script src="https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6"></script>
<script type="module">

const plot = Plot.rectY({length: 10000}, Plot.binX({y: "count"}, {x: Math.random})).plot();
const div = document.querySelector("#myplot");
div.append(plot);

</script>html<!DOCTYPE html>
<div id="myplot"></div>
<script src="d3.js"></script>
<script src="plot.js"></script>
<script type="module">

const plot = Plot.rectY({length: 10000}, Plot.binX({y: "count"}, {x: Math.random})).plot();
const div = document.querySelector("#myplot");
div.append(plot);

</script>Plot returns a detached DOM element — either an SVG or HTML figure element. In vanilla web development, this means you need to insert the generated plot into the page to see it. Typically this is done by selecting a DOM element (such as a DIV with a unique identifier, like myplot above), and then calling element.append.If you’d prefer to run Plot locally (or entirely offline), you can download the UMD bundle of Plot along with its dependency, D3, here:d3.jsplot.jsThen, create an index.html file as shown above in the UMD + local tab. If you prefer smaller minified files, you can download d3.min.js and plot.min.js, and then update the src attributes above accordingly.Installing from npm ​If you’re developing a web application using Node, you can install Plot via yarn, npm, pnpm, or your preferred package manager.yarnnpmpnpmbashyarn add @observablehq/plotbashnpm install @observablehq/plotbashpnpm add @observablehq/plotYou can then load Plot into your app as:jsimport * as Plot from "@observablehq/plot";You can instead import specific symbols if you prefer:jsimport {barY, groupX} from "@observablehq/plot";Plot includes TypeScript declarations with extensive documentation. We highly recommend using an editor with enhanced code completion such as Visual Studio Code or Observable.Modern editors surface documentation and type hints as you write Plot code.Plot in React ​We recommend two approaches for Plot in React depending on your needs.The first is to server-side render (SSR) plots. This minimizes distracting reflow on page load, improving the user experience. For this approach, use the document plot option to tell Plot to render with React’s virtual DOM. For example, here is a PlotFigure component:PlotFigure.jsjsimport * as Plot from "@observablehq/plot";
import {createElement as h} from "react";

export default function PlotFigure({options}) {
  return Plot.plot({...options, document: new Document()}).toHyperScript();
}INFOFor brevity, the virtual Document implementation is not shown. You’ll find it linked below.Then, to use:App.jsxjsximport * as Plot from "@observablehq/plot";
import PlotFigure from "./PlotFigure.js";
import penguins from "./penguins.json";

export default function App() {
  return (
    <div>
      <h1>Penguins</h1>
      <PlotFigure
        options={{
          marks: [
            Plot.dot(penguins, {x: "culmen_length_mm", y: "culmen_depth_mm"})
          ]
        }}
      />
    </div>
  );
}See our Plot + React CodeSandbox for details.Server-side rendering is only practical for simple plots of small data; complex plots, such as geographic maps or charts with thousands of elements, are better rendered on the client because the serialized SVG is large. For this second approach, use useRef to get a reference to a DOM element, and then useEffect to generate and insert your plot.App.jsxjsximport * as Plot from "@observablehq/plot";
import * as d3 from "d3";
import {useEffect, useRef, useState} from "react";

export default function App() {
  const containerRef = useRef();
  const [data, setData] = useState();

  useEffect(() => {
    d3.csv("/gistemp.csv", d3.autoType).then(setData);
  }, []);

  useEffect(() => {
    if (data === undefined) return;
    const plot = Plot.plot({
      y: {grid: true},
      color: {scheme: "burd"},
      marks: [
        Plot.ruleY([0]),
        Plot.dot(data, {x: "Date", y: "Anomaly", stroke: "Anomaly"})
      ]
    });
    containerRef.current.append(plot);
    return () => plot.remove();
  }, [data]);

  return <div ref={containerRef} />;
}This example also demonstrates asynchronously loading CSV data with useState. If you want to update your plot, say because your data has changed, simply throw away the old plot using element.remove and then replace it with a new one. That’s done above in the useEffect’s cleanup function.Plot in Vue ​As with React, you can use either server- or client-side rendering with Plot and Vue.For server-side rendering (SSR), use the document plot option to render to Vue’s virtual DOM. For example, here is a PlotFigure component:PlotFigure.jsjsimport * as Plot from "@observablehq/plot";
import {h} from "vue";

export default {
  props: {
    options: Object
  },
  render() {
    return Plot.plot({
      ...this.options,
      document: new Document()
    }).toHyperScript();
  }
};INFOFor brevity, the virtual Document implementation is not shown. You’ll find it linked below.Then, to use:App.vuevue<script setup>
import * as Plot from "@observablehq/plot";
import PlotFigure from "./components/PlotFigure.js";
import penguins from "./assets/penguins.json";
</script>

<template>
  <h1>Plot + Vue</h1>
  <PlotFigure
    :options="{
      marks: [
        Plot.dot(penguins, {x: 'culmen_length_mm', y: 'culmen_depth_mm'}),
      ],
    }"
  />
</template>See our Plot + Vue CodeSandbox for details.For client-side rendering, use a render function with a mounted lifecycle directive. After the component mounts, render the plot and then insert it into the page.jsimport * as Plot from "@observablehq/plot";
import {h, withDirectives} from "vue";

export default {
  props: ["options"],
  render() {
    const {options} = this;
    return withDirectives(h("div"), [
      [
        {
          mounted(el) {
            el.append(Plot.plot(options));
          }
        }
      ]
    ]);
  }
};As with React, to update your plot for whatever reason, simply render a new one and replace the old one. You can find more examples on our GitHub as this documentation site is built with VitePress and uses both client- and server-side rendering for plots!Plot in Svelte ​Here’s an example of client-side rendering in Svelte. For server-side rendering, see #1759.App.sveltesvelte<script lang="ts">
  import * as Plot from '@observablehq/plot';
  import * as d3 from 'd3';

  let div: HTMLElement | undefined = $state();
  let data = $state(d3.ticks(-2, 2, 200).map(Math.sin));

  function onMousemove(event: MouseEvent) {
    const [x, y] = d3.pointer(event);
    data = data.slice(-200).concat(Math.atan2(x, y));
  }

  $effect(() => {
    div?.firstChild?.remove(); // remove old chart, if any
    div?.append(Plot.lineY(data).plot({ grid: true })); // add the new chart
  });
</script>

<div onmousemove={onMousemove} bind:this={div} role="img"></div>See our Plot + Svelte REPL for details.Plot in Node.js ​You can use Plot to server-side render SVG or PNG in Node.js. Use JSDOM for a DOM implementation via the document option, then serialize the generated plot using outerHTML.jsimport {readFile} from "node:fs/promises";
import * as Plot from "@observablehq/plot";
import * as d3 from "d3";
import {JSDOM} from "jsdom";

const penguins = d3.csvParse(await readFile("./penguins.csv", "utf-8"), d3.autoType);

const plot = Plot.plot({
  document: new JSDOM("").window.document,
  marks: [
    Plot.dot(penguins, {x: "culmen_length_mm", y: "culmen_depth_mm", stroke: "species"})
  ]
});

plot.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns", "http://www.w3.org/2000/svg");
plot.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");

process.stdout.write(plot.outerHTML);To rasterize SVG as PNG, you could use canvg and node-canvas, or sharp:jsprocess.stdout.write(await sharp(Buffer.from(plot.outerHTML, "utf-8")).png().toBuffer());For better font rendering, consider Puppeteer.\n\nSearchK0.6.17GitHub️ 4.6kOn this pageGetting started ​Observable Plot supports a variety of environments.Try Plot online ​The fastest way to get started (and get help) with Observable Plot is on Observable! Plot is available by default in notebooks as part of Observable’s standard library. To use Plot, simply return the generated plot from a cell like so:ForkjsPlot.rectY({length: 10000}, Plot.binX({y: "count"}, {x: d3.randomNormal()})).plot()Observable includes a variety of Plot snippets when you click + to add a cell, as well as convenient sample datasets to try out Plot features. Or upload a CSV or JSON file to start playing with your data. You can even use Observable’s chart cell, which uses Plot’s auto mark under the hood, to create quick charts without writing code! You can then eject to JavaScript by clicking + to see the equivalent Plot code.Observable’s chart cell lets you quickly create charts and then eject to Plot code.Observable is free for public use. Sign up for a Pro account to connect to private databases, collaborate on private notebooks, and more.Plot in vanilla HTML ​In vanilla HTML, you can load Plot from a CDN such as jsDelivr or you can download it locally. We recommend using the CDN-hosted ES module bundle as it automatically loads Plot’s dependency on D3. But for those who need it, we also provide a UMD bundle that exports the Plot global when loaded as a plain script.ESM + CDNUMD + CDNUMD + localhtml<!DOCTYPE html>
<div id="myplot"></div>
<script type="module">

import * as Plot from "https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm";

const plot = Plot.rectY({length: 10000}, Plot.binX({y: "count"}, {x: Math.random})).plot();
const div = document.querySelector("#myplot");
div.append(plot);

</script>html<!DOCTYPE html>
<div id="myplot"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script src="https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6"></script>
<script type="module">

const plot = Plot.rectY({length: 10000}, Plot.binX({y: "count"}, {x: Math.random})).plot();
const div = document.querySelector("#myplot");
div.append(plot);

</script>html<!DOCTYPE html>
<div id="myplot"></div>
<script src="d3.js"></script>
<script src="plot.js"></script>
<script type="module">

const plot = Plot.rectY({length: 10000}, Plot.binX({y: "count"}, {x: Math.random})).plot();
const div = document.querySelector("#myplot");
div.append(plot);

</script>Plot returns a detached DOM element — either an SVG or HTML figure element. In vanilla web development, this means you need to insert the generated plot into the page to see it. Typically this is done by selecting a DOM element (such as a DIV with a unique identifier, like myplot above), and then calling element.append.If you’d prefer to run Plot locally (or entirely offline), you can download the UMD bundle of Plot along with its dependency, D3, here:d3.jsplot.jsThen, create an index.html file as shown above in the UMD + local tab. If you prefer smaller minified files, you can download d3.min.js and plot.min.js, and then update the src attributes above accordingly.Installing from npm ​If you’re developing a web application using Node, you can install Plot via yarn, npm, pnpm, or your preferred package manager.yarnnpmpnpmbashyarn add @observablehq/plotbashnpm install @observablehq/plotbashpnpm add @observablehq/plotYou can then load Plot into your app as:jsimport * as Plot from "@observablehq/plot";You can instead import specific symbols if you prefer:jsimport {barY, groupX} from "@observablehq/plot";Plot includes TypeScript declarations with extensive documentation. We highly recommend using an editor with enhanced code completion such as Visual Studio Code or Observable.Modern editors surface documentation and type hints as you write Plot code.Plot in React ​We recommend two approaches for Plot in React depending on your needs.The first is to server-side render (SSR) plots. This minimizes distracting reflow on page load, improving the user experience. For this approach, use the document plot option to tell Plot to render with React’s virtual DOM. For example, here is a PlotFigure component:PlotFigure.jsjsimport * as Plot from "@observablehq/plot";
import {createElement as h} from "react";

export default function PlotFigure({options}) {
  return Plot.plot({...options, document: new Document()}).toHyperScript();
}INFOFor brevity, the virtual Document implementation is not shown. You’ll find it linked below.Then, to use:App.jsxjsximport * as Plot from "@observablehq/plot";
import PlotFigure from "./PlotFigure.js";
import penguins from "./penguins.json";

export default function App() {
  return (
    <div>
      <h1>Penguins</h1>
      <PlotFigure
        options={{
          marks: [
            Plot.dot(penguins, {x: "culmen_length_mm", y: "culmen_depth_mm"})
          ]
        }}
      />
    </div>
  );
}See our Plot + React CodeSandbox for details.Server-side rendering is only practical for simple plots of small data; complex plots, such as geographic maps or charts with thousands of elements, are better rendered on the client because the serialized SVG is large. For this second approach, use useRef to get a reference to a DOM element, and then useEffect to generate and insert your plot.App.jsxjsximport * as Plot from "@observablehq/plot";
import * as d3 from "d3";
import {useEffect, useRef, useState} from "react";

export default function App() {
  const containerRef = useRef();
  const [data, setData] = useState();

  useEffect(() => {
    d3.csv("/gistemp.csv", d3.autoType).then(setData);
  }, []);

  useEffect(() => {
    if (data === undefined) return;
    const plot = Plot.plot({
      y: {grid: true},
      color: {scheme: "burd"},
      marks: [
        Plot.ruleY([0]),
        Plot.dot(data, {x: "Date", y: "Anomaly", stroke: "Anomaly"})
      ]
    });
    containerRef.current.append(plot);
    return () => plot.remove();
  }, [data]);

  return <div ref={containerRef} />;
}This example also demonstrates asynchronously loading CSV data with useState. If you want to update your plot, say because your data has changed, simply throw away the old plot using element.remove and then replace it with a new one. That’s done above in the useEffect’s cleanup function.Plot in Vue ​As with React, you can use either server- or client-side rendering with Plot and Vue.For server-side rendering (SSR), use the document plot option to render to Vue’s virtual DOM. For example, here is a PlotFigure component:PlotFigure.jsjsimport * as Plot from "@observablehq/plot";
import {h} from "vue";

export default {
  props: {
    options: Object
  },
  render() {
    return Plot.plot({
      ...this.options,
      document: new Document()
    }).toHyperScript();
  }
};INFOFor brevity, the virtual Document implementation is not shown. You’ll find it linked below.Then, to use:App.vuevue<script setup>
import * as Plot from "@observablehq/plot";
import PlotFigure from "./components/PlotFigure.js";
import penguins from "./assets/penguins.json";
</script>

<template>
  <h1>Plot + Vue</h1>
  <PlotFigure
    :options="{
      marks: [
        Plot.dot(penguins, {x: 'culmen_length_mm', y: 'culmen_depth_mm'}),
      ],
    }"
  />
</template>See our Plot + Vue CodeSandbox for details.For client-side rendering, use a render function with a mounted lifecycle directive. After the component mounts, render the plot and then insert it into the page.jsimport * as Plot from "@observablehq/plot";
import {h, withDirectives} from "vue";

export default {
  props: ["options"],
  render() {
    const {options} = this;
    return withDirectives(h("div"), [
      [
        {
          mounted(el) {
            el.append(Plot.plot(options));
          }
        }
      ]
    ]);
  }
};As with React, to update your plot for whatever reason, simply render a new one and replace the old one. You can find more examples on our GitHub as this documentation site is built with VitePress and uses both client- and server-side rendering for plots!Plot in Svelte ​Here’s an example of client-side rendering in Svelte. For server-side rendering, see #1759.App.sveltesvelte<script lang="ts">
  import * as Plot from '@observablehq/plot';
  import * as d3 from 'd3';

  let div: HTMLElement | undefined = $state();
  let data = $state(d3.ticks(-2, 2, 200).map(Math.sin));

  function onMousemove(event: MouseEvent) {
    const [x, y] = d3.pointer(event);
    data = data.slice(-200).concat(Math.atan2(x, y));
  }

  $effect(() => {
    div?.firstChild?.remove(); // remove old chart, if any
    div?.append(Plot.lineY(data).plot({ grid: true })); // add the new chart
  });
</script>

<div onmousemove={onMousemove} bind:this={div} role="img"></div>See our Plot + Svelte REPL for details.Plot in Node.js ​You can use Plot to server-side render SVG or PNG in Node.js. Use JSDOM for a DOM implementation via the document option, then serialize the generated plot using outerHTML.jsimport {readFile} from "node:fs/promises";
import * as Plot from "@observablehq/plot";
import * as d3 from "d3";
import {JSDOM} from "jsdom";

const penguins = d3.csvParse(await readFile("./penguins.csv", "utf-8"), d3.autoType);

const plot = Plot.plot({
  document: new JSDOM("").window.document,
  marks: [
    Plot.dot(penguins, {x: "culmen_length_mm", y: "culmen_depth_mm", stroke: "species"})
  ]
});

plot.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns", "http://www.w3.org/2000/svg");
plot.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");

process.stdout.write(plot.outerHTML);To rasterize SVG as PNG, you could use canvg and node-canvas, or sharp:jsprocess.stdout.write(await sharp(Buffer.from(plot.outerHTML, "utf-8")).png().toBuffer());For better font rendering, consider Puppeteer.PagerPrevious pageWhy Plot?Next pagePlots\n\nGetting started ​Observable Plot supports a variety of environments.Try Plot online ​The fastest way to get started (and get help) with Observable Plot is on Observable! Plot is available by default in notebooks as part of Observable’s standard library. To use Plot, simply return the generated plot from a cell like so:ForkjsPlot.rectY({length: 10000}, Plot.binX({y: "count"}, {x: d3.randomNormal()})).plot()Observable includes a variety of Plot snippets when you click + to add a cell, as well as convenient sample datasets to try out Plot features. Or upload a CSV or JSON file to start playing with your data. You can even use Observable’s chart cell, which uses Plot’s auto mark under the hood, to create quick charts without writing code! You can then eject to JavaScript by clicking + to see the equivalent Plot code.Observable’s chart cell lets you quickly create charts and then eject to Plot code.Observable is free for public use. Sign up for a Pro account to connect to private databases, collaborate on private notebooks, and more.Plot in vanilla HTML ​In vanilla HTML, you can load Plot from a CDN such as jsDelivr or you can download it locally. We recommend using the CDN-hosted ES module bundle as it automatically loads Plot’s dependency on D3. But for those who need it, we also provide a UMD bundle that exports the Plot global when loaded as a plain script.ESM + CDNUMD + CDNUMD + localhtml<!DOCTYPE html>
<div id="myplot"></div>
<script type="module">

import * as Plot from "https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm";

const plot = Plot.rectY({length: 10000}, Plot.binX({y: "count"}, {x: Math.random})).plot();
const div = document.querySelector("#myplot");
div.append(plot);

</script>html<!DOCTYPE html>
<div id="myplot"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script src="https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6"></script>
<script type="module">

const plot = Plot.rectY({length: 10000}, Plot.binX({y: "count"}, {x: Math.random})).plot();
const div = document.querySelector("#myplot");
div.append(plot);

</script>html<!DOCTYPE html>
<div id="myplot"></div>
<script src="d3.js"></script>
<script src="plot.js"></script>
<script type="module">

const plot = Plot.rectY({length: 10000}, Plot.binX({y: "count"}, {x: Math.random})).plot();
const div = document.querySelector("#myplot");
div.append(plot);

</script>Plot returns a detached DOM element — either an SVG or HTML figure element. In vanilla web development, this means you need to insert the generated plot into the page to see it. Typically this is done by selecting a DOM element (such as a DIV with a unique identifier, like myplot above), and then calling element.append.If you’d prefer to run Plot locally (or entirely offline), you can download the UMD bundle of Plot along with its dependency, D3, here:d3.jsplot.jsThen, create an index.html file as shown above in the UMD + local tab. If you prefer smaller minified files, you can download d3.min.js and plot.min.js, and then update the src attributes above accordingly.Installing from npm ​If you’re developing a web application using Node, you can install Plot via yarn, npm, pnpm, or your preferred package manager.yarnnpmpnpmbashyarn add @observablehq/plotbashnpm install @observablehq/plotbashpnpm add @observablehq/plotYou can then load Plot into your app as:jsimport * as Plot from "@observablehq/plot";You can instead import specific symbols if you prefer:jsimport {barY, groupX} from "@observablehq/plot";Plot includes TypeScript declarations with extensive documentation. We highly recommend using an editor with enhanced code completion such as Visual Studio Code or Observable.Modern editors surface documentation and type hints as you write Plot code.Plot in React ​We recommend two approaches for Plot in React depending on your needs.The first is to server-side render (SSR) plots. This minimizes distracting reflow on page load, improving the user experience. For this approach, use the document plot option to tell Plot to render with React’s virtual DOM. For example, here is a PlotFigure component:PlotFigure.jsjsimport * as Plot from "@observablehq/plot";
import {createElement as h} from "react";

export default function PlotFigure({options}) {
  return Plot.plot({...options, document: new Document()}).toHyperScript();
}INFOFor brevity, the virtual Document implementation is not shown. You’ll find it linked below.Then, to use:App.jsxjsximport * as Plot from "@observablehq/plot";
import PlotFigure from "./PlotFigure.js";
import penguins from "./penguins.json";

export default function App() {
  return (
    <div>
      <h1>Penguins</h1>
      <PlotFigure
        options={{
          marks: [
            Plot.dot(penguins, {x: "culmen_length_mm", y: "culmen_depth_mm"})
          ]
        }}
      />
    </div>
  );
}See our Plot + React CodeSandbox for details.Server-side rendering is only practical for simple plots of small data; complex plots, such as geographic maps or charts with thousands of elements, are better rendered on the client because the serialized SVG is large. For this second approach, use useRef to get a reference to a DOM element, and then useEffect to generate and insert your plot.App.jsxjsximport * as Plot from "@observablehq/plot";
import * as d3 from "d3";
import {useEffect, useRef, useState} from "react";

export default function App() {
  const containerRef = useRef();
  const [data, setData] = useState();

  useEffect(() => {
    d3.csv("/gistemp.csv", d3.autoType).then(setData);
  }, []);

  useEffect(() => {
    if (data === undefined) return;
    const plot = Plot.plot({
      y: {grid: true},
      color: {scheme: "burd"},
      marks: [
        Plot.ruleY([0]),
        Plot.dot(data, {x: "Date", y: "Anomaly", stroke: "Anomaly"})
      ]
    });
    containerRef.current.append(plot);
    return () => plot.remove();
  }, [data]);

  return <div ref={containerRef} />;
}This example also demonstrates asynchronously loading CSV data with useState. If you want to update your plot, say because your data has changed, simply throw away the old plot using element.remove and then replace it with a new one. That’s done above in the useEffect’s cleanup function.Plot in Vue ​As with React, you can use either server- or client-side rendering with Plot and Vue.For server-side rendering (SSR), use the document plot option to render to Vue’s virtual DOM. For example, here is a PlotFigure component:PlotFigure.jsjsimport * as Plot from "@observablehq/plot";
import {h} from "vue";

export default {
  props: {
    options: Object
  },
  render() {
    return Plot.plot({
      ...this.options,
      document: new Document()
    }).toHyperScript();
  }
};INFOFor brevity, the virtual Document implementation is not shown. You’ll find it linked below.Then, to use:App.vuevue<script setup>
import * as Plot from "@observablehq/plot";
import PlotFigure from "./components/PlotFigure.js";
import penguins from "./assets/penguins.json";
</script>

<template>
  <h1>Plot + Vue</h1>
  <PlotFigure
    :options="{
      marks: [
        Plot.dot(penguins, {x: 'culmen_length_mm', y: 'culmen_depth_mm'}),
      ],
    }"
  />
</template>See our Plot + Vue CodeSandbox for details.For client-side rendering, use a render function with a mounted lifecycle directive. After the component mounts, render the plot and then insert it into the page.jsimport * as Plot from "@observablehq/plot";
import {h, withDirectives} from "vue";

export default {
  props: ["options"],
  render() {
    const {options} = this;
    return withDirectives(h("div"), [
      [
        {
          mounted(el) {
            el.append(Plot.plot(options));
          }
        }
      ]
    ]);
  }
};As with React, to update your plot for whatever reason, simply render a new one and replace the old one. You can find more examples on our GitHub as this documentation site is built with VitePress and uses both client- and server-side rendering for plots!Plot in Svelte ​Here’s an example of client-side rendering in Svelte. For server-side rendering, see #1759.App.sveltesvelte<script lang="ts">
  import * as Plot from '@observablehq/plot';
  import * as d3 from 'd3';

  let div: HTMLElement | undefined = $state();
  let data = $state(d3.ticks(-2, 2, 200).map(Math.sin));

  function onMousemove(event: MouseEvent) {
    const [x, y] = d3.pointer(event);
    data = data.slice(-200).concat(Math.atan2(x, y));
  }

  $effect(() => {
    div?.firstChild?.remove(); // remove old chart, if any
    div?.append(Plot.lineY(data).plot({ grid: true })); // add the new chart
  });
</script>

<div onmousemove={onMousemove} bind:this={div} role="img"></div>See our Plot + Svelte REPL for details.Plot in Node.js ​You can use Plot to server-side render SVG or PNG in Node.js. Use JSDOM for a DOM implementation via the document option, then serialize the generated plot using outerHTML.jsimport {readFile} from "node:fs/promises";
import * as Plot from "@observablehq/plot";
import * as d3 from "d3";
import {JSDOM} from "jsdom";

const penguins = d3.csvParse(await readFile("./penguins.csv", "utf-8"), d3.autoType);

const plot = Plot.plot({
  document: new JSDOM("").window.document,
  marks: [
    Plot.dot(penguins, {x: "culmen_length_mm", y: "culmen_depth_mm", stroke: "species"})
  ]
});

plot.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns", "http://www.w3.org/2000/svg");
plot.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");

process.stdout.write(plot.outerHTML);To rasterize SVG as PNG, you could use canvg and node-canvas, or sharp:jsprocess.stdout.write(await sharp(Buffer.from(plot.outerHTML, "utf-8")).png().toBuffer());For better font rendering, consider Puppeteer.\n\n\n\nWhat is Plot? ​Observable Plot is a free, open-source, JavaScript library for visualizing tabular data, focused on accelerating exploratory data analysis. It has a concise, memorable, yet expressive interface, featuring scales and layered marks in the grammar of graphics style popularized by Leland Wilkinson and Hadley Wickham and inspired by the earlier ideas of Jacques Bertin. And there are plenty of examples to learn from and copy-paste.In the spirit of show don’t tell, here’s a scatterplot of body measurements of athletes from the 2016 Summer Olympics.ForkjsPlot
  .dot(olympians, {x: "weight", y: "height", stroke: "sex"})
  .plot({color: {legend: true}})A plot specification assigns columns of data (weight, height, and sex) to visual properties of marks (x, y, and stroke). Plot does the rest! You can configure much more, if needed, but Plot’s goal is to help you get a meaningful visualization quickly to accelerate analysis.This scatterplot suffers from overplotting: many dots are drawn in the same spot, so it’s hard to perceive density. We can fix this by applying a bin transform to group athletes of similar height and weight (and sex), and then use opacity to encode the number of athletes in the bin.ForkjsPlot.rect(olympians, Plot.bin({fillOpacity: "count"}, {x: "weight", y: "height", fill: "sex", inset: 0})).plot()Or we could try the density mark.ForkjsPlot.density(olympians, {x: "weight", y: "height", stroke: "sex"}).plot()A simpler take on this data is to focus on one dimension: weight. We can use the bin transform again to make a histogram with weight on the x-axis and frequency on the y-axis. This plot uses a rect mark and an implicit stack transform.ForkjsPlot.rectY(olympians, Plot.binX({y: "count"}, {x: "weight", fill: "sex"})).plot()Or if we’d prefer to show the two distributions separately as small multiples, we can facet the data along y (keeping the fill encoding for consistency, and adding grid lines and a rule at y = 0 to improve readability).ForkjsPlot.plot({
  grid: true,
  marks: [
    Plot.rectY(olympians, Plot.binX({y: "count"}, {x: "weight", fill: "sex", fy: "sex"})),
    Plot.ruleY([0])
  ]
})What can Plot do? ​Because marks are composable, and because you can extend Plot with custom marks, you can make almost anything with it — much more than the charts above! The following tree diagram of the documentation gives a sense of what’s ”in the box” with Plot. Peruse our gallery of examples for more inspiration.\n\nSearchK0.6.17GitHub️ 4.6kOn this pageWhat is Plot? ​Observable Plot is a free, open-source, JavaScript library for visualizing tabular data, focused on accelerating exploratory data analysis. It has a concise, memorable, yet expressive interface, featuring scales and layered marks in the grammar of graphics style popularized by Leland Wilkinson and Hadley Wickham and inspired by the earlier ideas of Jacques Bertin. And there are plenty of examples to learn from and copy-paste.In the spirit of show don’t tell, here’s a scatterplot of body measurements of athletes from the 2016 Summer Olympics.ForkjsPlot
  .dot(olympians, {x: "weight", y: "height", stroke: "sex"})
  .plot({color: {legend: true}})A plot specification assigns columns of data (weight, height, and sex) to visual properties of marks (x, y, and stroke). Plot does the rest! You can configure much more, if needed, but Plot’s goal is to help you get a meaningful visualization quickly to accelerate analysis.This scatterplot suffers from overplotting: many dots are drawn in the same spot, so it’s hard to perceive density. We can fix this by applying a bin transform to group athletes of similar height and weight (and sex), and then use opacity to encode the number of athletes in the bin.ForkjsPlot.rect(olympians, Plot.bin({fillOpacity: "count"}, {x: "weight", y: "height", fill: "sex", inset: 0})).plot()Or we could try the density mark.ForkjsPlot.density(olympians, {x: "weight", y: "height", stroke: "sex"}).plot()A simpler take on this data is to focus on one dimension: weight. We can use the bin transform again to make a histogram with weight on the x-axis and frequency on the y-axis. This plot uses a rect mark and an implicit stack transform.ForkjsPlot.rectY(olympians, Plot.binX({y: "count"}, {x: "weight", fill: "sex"})).plot()Or if we’d prefer to show the two distributions separately as small multiples, we can facet the data along y (keeping the fill encoding for consistency, and adding grid lines and a rule at y = 0 to improve readability).ForkjsPlot.plot({
  grid: true,
  marks: [
    Plot.rectY(olympians, Plot.binX({y: "count"}, {x: "weight", fill: "sex", fy: "sex"})),
    Plot.ruleY([0])
  ]
})What can Plot do? ​Because marks are composable, and because you can extend Plot with custom marks, you can make almost anything with it — much more than the charts above! The following tree diagram of the documentation gives a sense of what’s ”in the box” with Plot. Peruse our gallery of examples for more inspiration.PagerNext pageWhy Plot?\n\nWhat is Plot? ​Observable Plot is a free, open-source, JavaScript library for visualizing tabular data, focused on accelerating exploratory data analysis. It has a concise, memorable, yet expressive interface, featuring scales and layered marks in the grammar of graphics style popularized by Leland Wilkinson and Hadley Wickham and inspired by the earlier ideas of Jacques Bertin. And there are plenty of examples to learn from and copy-paste.In the spirit of show don’t tell, here’s a scatterplot of body measurements of athletes from the 2016 Summer Olympics.ForkjsPlot
  .dot(olympians, {x: "weight", y: "height", stroke: "sex"})
  .plot({color: {legend: true}})A plot specification assigns columns of data (weight, height, and sex) to visual properties of marks (x, y, and stroke). Plot does the rest! You can configure much more, if needed, but Plot’s goal is to help you get a meaningful visualization quickly to accelerate analysis.This scatterplot suffers from overplotting: many dots are drawn in the same spot, so it’s hard to perceive density. We can fix this by applying a bin transform to group athletes of similar height and weight (and sex), and then use opacity to encode the number of athletes in the bin.ForkjsPlot.rect(olympians, Plot.bin({fillOpacity: "count"}, {x: "weight", y: "height", fill: "sex", inset: 0})).plot()Or we could try the density mark.ForkjsPlot.density(olympians, {x: "weight", y: "height", stroke: "sex"}).plot()A simpler take on this data is to focus on one dimension: weight. We can use the bin transform again to make a histogram with weight on the x-axis and frequency on the y-axis. This plot uses a rect mark and an implicit stack transform.ForkjsPlot.rectY(olympians, Plot.binX({y: "count"}, {x: "weight", fill: "sex"})).plot()Or if we’d prefer to show the two distributions separately as small multiples, we can facet the data along y (keeping the fill encoding for consistency, and adding grid lines and a rule at y = 0 to improve readability).ForkjsPlot.plot({
  grid: true,
  marks: [
    Plot.rectY(olympians, Plot.binX({y: "count"}, {x: "weight", fill: "sex", fy: "sex"})),
    Plot.ruleY([0])
  ]
})What can Plot do? ​Because marks are composable, and because you can extend Plot with custom marks, you can make almost anything with it — much more than the charts above! The following tree diagram of the documentation gives a sense of what’s ”in the box” with Plot. Peruse our gallery of examples for more inspiration.\n\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited Paused42 forks154 starsPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited Paused42 forks154 stars\nPublic Edited Paused42 forks154 stars\nPublic Edited Paused42 forks154 stars\nPublic Edited Paused42 forks154 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 6 forks16 stars1Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 6 forks16 stars\nPublic Edited 6 forks16 stars\nPublic Edited 6 forks16 stars\nPublic Edited 6 forks16 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Data Visualization ExamplesBy Mike BostockEdited 16 forksImporters19 stars2Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Data Visualization ExamplesBy Mike BostockEdited 16 forksImporters19 stars\nPublic Data Visualization ExamplesBy Mike BostockEdited 16 forksImporters19 stars\nPublic Data Visualization ExamplesBy Mike BostockEdited 16 forksImporters19 stars\nPublic Data Visualization ExamplesBy Mike BostockEdited 16 forksImporters19 stars\nData Visualization Examples\nData Visualization Examples\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 8 forksImporters2 stars1Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 8 forksImporters2 stars\nPublic Edited 8 forksImporters2 stars\nPublic Edited 8 forksImporters2 stars\nPublic Edited 8 forksImporters2 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 10 forks8 starsPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 10 forks8 stars\nPublic Edited 10 forks8 stars\nPublic Edited 10 forks8 stars\nPublic Edited 10 forks8 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 3 forks1 starPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 3 forks1 star\nPublic Edited 3 forks1 star\nPublic Edited 3 forks1 star\nPublic Edited 3 forks1 star\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 25 forks4 starsPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 25 forks4 stars\nPublic Edited 25 forks4 stars\nPublic Edited 25 forks4 stars\nPublic Edited 25 forks4 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited Paused ISC2 forks16 stars1Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited Paused ISC2 forks16 stars\nPublic Edited Paused ISC2 forks16 stars\nPublic Edited Paused ISC2 forks16 stars\nPublic Edited Paused ISC2 forks16 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public By Mike BostockEdited 7 forks22 starsPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic By Mike BostockEdited 7 forks22 stars\nPublic By Mike BostockEdited 7 forks22 stars\nPublic By Mike BostockEdited 7 forks22 stars\nPublic By Mike BostockEdited 7 forks22 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 5 forks4 stars1Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 5 forks4 stars\nPublic Edited 5 forks4 stars\nPublic Edited 5 forks4 stars\nPublic Edited 5 forks4 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public By FilEdited 7 forksImporters8 stars2Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic By FilEdited 7 forksImporters8 stars\nPublic By FilEdited 7 forksImporters8 stars\nPublic By FilEdited 7 forksImporters8 stars\nPublic By FilEdited 7 forksImporters8 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 3 forks3 stars1Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 3 forks3 stars\nPublic Edited 3 forks3 stars\nPublic Edited 3 forks3 stars\nPublic Edited 3 forks3 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 5 forks4 stars1Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 5 forks4 stars\nPublic Edited 5 forks4 stars\nPublic Edited 5 forks4 stars\nPublic Edited 5 forks4 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 3 forks1 starPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 3 forks1 star\nPublic Edited 3 forks1 star\nPublic Edited 3 forks1 star\nPublic Edited 3 forks1 star\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public By Mike BostockEdited 1 starPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic By Mike BostockEdited 1 star\nPublic By Mike BostockEdited 1 star\nPublic By Mike BostockEdited 1 star\nPublic By Mike BostockEdited 1 star\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public By FilEdited 4 forks6 stars1Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic By FilEdited 4 forks6 stars\nPublic By FilEdited 4 forks6 stars\nPublic By FilEdited 4 forks6 stars\nPublic By FilEdited 4 forks6 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 2 forks1 star1Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 2 forks1 star\nPublic Edited 2 forks1 star\nPublic Edited 2 forks1 star\nPublic Edited 2 forks1 star\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public By Mike BostockEdited 2 forks1 star1Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic By Mike BostockEdited 2 forks1 star\nPublic By Mike BostockEdited 2 forks1 star\nPublic By Mike BostockEdited 2 forks1 star\nPublic By Mike BostockEdited 2 forks1 star\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public 2 collectionsBy Mike BostockEdited 26 forksImporters31 stars1Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic 2 collectionsBy Mike BostockEdited 26 forksImporters31 stars\nPublic 2 collectionsBy Mike BostockEdited 26 forksImporters31 stars\nPublic 2 collectionsBy Mike BostockEdited 26 forksImporters31 stars\nPublic 2 collectionsBy Mike BostockEdited 26 forksImporters31 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 3 forks4 stars1Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 3 forks4 stars\nPublic Edited 3 forks4 stars\nPublic Edited 3 forks4 stars\nPublic Edited 3 forks4 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Data Visualization ExamplesEdited 10 forks4 stars1Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Data Visualization ExamplesEdited 10 forks4 stars\nPublic Data Visualization ExamplesEdited 10 forks4 stars\nPublic Data Visualization ExamplesEdited 10 forks4 stars\nPublic Data Visualization ExamplesEdited 10 forks4 stars\nData Visualization Examples\nData Visualization Examples\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 3 forksImporters9 stars1Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 3 forksImporters9 stars\nPublic Edited 3 forksImporters9 stars\nPublic Edited 3 forksImporters9 stars\nPublic Edited 3 forksImporters9 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited  ISC10 forks22 starsPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited  ISC10 forks22 stars\nPublic Edited  ISC10 forks22 stars\nPublic Edited  ISC10 forks22 stars\nPublic Edited  ISC10 forks22 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 6 forks6 stars1Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 6 forks6 stars\nPublic Edited 6 forks6 stars\nPublic Edited 6 forks6 stars\nPublic Edited 6 forks6 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 6 forks7 stars2Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 6 forks7 stars\nPublic Edited 6 forks7 stars\nPublic Edited 6 forks7 stars\nPublic Edited 6 forks7 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 21 forks1 starPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 21 forks1 star\nPublic Edited 21 forks1 star\nPublic Edited 21 forks1 star\nPublic Edited 21 forks1 star\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 3 forks6 starsPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 3 forks6 stars\nPublic Edited 3 forks6 stars\nPublic Edited 3 forks6 stars\nPublic Edited 3 forks6 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 4 forks2 stars1Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 4 forks2 stars\nPublic Edited 4 forks2 stars\nPublic Edited 4 forks2 stars\nPublic Edited 4 forks2 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public By Mike BostockEdited 9 forks3 starsPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic By Mike BostockEdited 9 forks3 stars\nPublic By Mike BostockEdited 9 forks3 stars\nPublic By Mike BostockEdited 9 forks3 stars\nPublic By Mike BostockEdited 9 forks3 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 1 fork2 starsPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 1 fork2 stars\nPublic Edited 1 fork2 stars\nPublic Edited 1 fork2 stars\nPublic Edited 1 fork2 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 4 forks2 stars1Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 4 forks2 stars\nPublic Edited 4 forks2 stars\nPublic Edited 4 forks2 stars\nPublic Edited 4 forks2 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 23 forks4 stars2Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 23 forks4 stars\nPublic Edited 23 forks4 stars\nPublic Edited 23 forks4 stars\nPublic Edited 23 forks4 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 10 forksImporters5 stars1Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 10 forksImporters5 stars\nPublic Edited 10 forksImporters5 stars\nPublic Edited 10 forksImporters5 stars\nPublic Edited 10 forksImporters5 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 2 forks1 starPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 2 forks1 star\nPublic Edited 2 forks1 star\nPublic Edited 2 forks1 star\nPublic Edited 2 forks1 star\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 6 forksImporters2 stars1Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 6 forksImporters2 stars\nPublic Edited 6 forksImporters2 stars\nPublic Edited 6 forksImporters2 stars\nPublic Edited 6 forksImporters2 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 2 forks2 starsPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 2 forks2 stars\nPublic Edited 2 forks2 stars\nPublic Edited 2 forks2 stars\nPublic Edited 2 forks2 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public By Mike BostockEdited 24 forksImporters25 stars1Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic By Mike BostockEdited 24 forksImporters25 stars\nPublic By Mike BostockEdited 24 forksImporters25 stars\nPublic By Mike BostockEdited 24 forksImporters25 stars\nPublic By Mike BostockEdited 24 forksImporters25 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 2 forks2 stars1Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 2 forks2 stars\nPublic Edited 2 forks2 stars\nPublic Edited 2 forks2 stars\nPublic Edited 2 forks2 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 3 forks3 starsPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 3 forks3 stars\nPublic Edited 3 forks3 stars\nPublic Edited 3 forks3 stars\nPublic Edited 3 forks3 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 1 forkPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 16 forksImporters2 stars1Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 16 forksImporters2 stars\nPublic Edited 16 forksImporters2 stars\nPublic Edited 16 forksImporters2 stars\nPublic Edited 16 forksImporters2 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public By Mike BostockEdited  ISCFork of Phases of the Moon•5 forks20 starsPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic By Mike BostockEdited  ISCFork of Phases of the Moon•5 forks20 stars\nPublic By Mike BostockEdited  ISCFork of Phases of the Moon•5 forks20 stars\nPublic By Mike BostockEdited  ISCFork of Phases of the Moon•5 forks20 stars\nPublic By Mike BostockEdited  ISCFork of Phases of the Moon•5 forks20 stars\nFork of Phases of the Moon•5 forks\nFork of Phases of the Moon\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 15 forks2 stars1Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 15 forks2 stars\nPublic Edited 15 forks2 stars\nPublic Edited 15 forks2 stars\nPublic Edited 15 forks2 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 5 forks4 starsPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 5 forks4 stars\nPublic Edited 5 forks4 stars\nPublic Edited 5 forks4 stars\nPublic Edited 5 forks4 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 6 forks1 starPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 6 forks1 star\nPublic Edited 6 forks1 star\nPublic Edited 6 forks1 star\nPublic Edited 6 forks1 star\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 1 forkImporters1Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 1 forkImporters\nPublic Edited 1 forkImporters\nPublic Edited 1 forkImporters\nPublic Edited 1 forkImporters\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 1 fork2 stars1Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 1 fork2 stars\nPublic Edited 1 fork2 stars\nPublic Edited 1 fork2 stars\nPublic Edited 1 fork2 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 9 forks5 stars1Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 9 forks5 stars\nPublic Edited 9 forks5 stars\nPublic Edited 9 forks5 stars\nPublic Edited 9 forks5 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 3 forks1 starPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 3 forks1 star\nPublic Edited 3 forks1 star\nPublic Edited 3 forks1 star\nPublic Edited 3 forks1 star\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 4 forks2 starsPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 4 forks2 stars\nPublic Edited 4 forks2 stars\nPublic Edited 4 forks2 stars\nPublic Edited 4 forks2 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public By Mike BostockEdited 8 forksImporters5 stars1Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic By Mike BostockEdited 8 forksImporters5 stars\nPublic By Mike BostockEdited 8 forksImporters5 stars\nPublic By Mike BostockEdited 8 forksImporters5 stars\nPublic By Mike BostockEdited 8 forksImporters5 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 10 forksImporters3 stars1Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 10 forksImporters3 stars\nPublic Edited 10 forksImporters3 stars\nPublic Edited 10 forksImporters3 stars\nPublic Edited 10 forksImporters3 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited 20 forks7 stars1Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited 20 forks7 stars\nPublic Edited 20 forks7 stars\nPublic Edited 20 forks7 stars\nPublic Edited 20 forks7 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork Public Edited  ISC9 forks5 stars2Purpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn morePlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.WorkspaceFork\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nObservableThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nThe end-to-end solution for building and hosting better data apps, dashboards, and reports.\nPublic Edited  ISC9 forks5 stars\nPublic Edited  ISC9 forks5 stars\nPublic Edited  ISC9 forks5 stars\nPublic Edited  ISC9 forks5 stars\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of dataObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.Try it for freeLearn more\nPurpose-built for displays of data\nObservable is your go-to platform for exploring data and creating expressive data visualizations. Use reactive JavaScript notebooks for prototyping and a collaborative canvas for visual data exploration and dashboard creation.\nTry it for freeLearn more\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nMarks ​TIPIf you aren’t yet up and running with Plot, please read our getting started guide first. Tinkering with the code below will give a better sense of how Plot works.Plot doesn’t have chart types; instead, you construct charts by layering marks.Marks are geometric shapes ​Plot provides a variety of mark types. Think of marks as the “visual vocabulary” — the painter’s palette 🎨, but of shapes instead of colors — that you pull from when composing a chart. Each mark type produces a certain type of geometric shape.For example, the dot mark draws stroked circles (by default).ForkjsPlot.dot(gistemp, {x: "Date", y: "Anomaly"}).plot()The line mark draws connected line segments (also known as a polyline or polygonal chain).ForkjsPlot.lineY(gistemp, {x: "Date", y: "Anomaly"}).plot()And the bar mark draws rectangular bars in either a horizontal (barX→) or vertical (barY↑) orientation.ForkjsPlot.barX(alphabet, {x: "frequency", y: "letter"}).plot()So instead of looking for a chart type, consider the shape of the primary graphical elements in your chart, and look for the corresponding mark type. If a chart has only a single mark, the mark type is effectively the chart type: the bar mark is used to make a bar chart, the area mark is used to make an area chart, and so on.Marks are layered ​The big advantage of mark types over chart types is that you can compose multiple marks of different types into a single plot. For example, below an area and line are used to plot the same sequence of values, while a rule emphasizes y = 0.ForkjsPlot.plot({
  marks: [
    Plot.ruleY([0]),
    Plot.areaY(aapl, {x: "Date", y: "Close", fillOpacity: 0.2}),
    Plot.lineY(aapl, {x: "Date", y: "Close"})
  ]
})Each mark supplies its own data; a quick way to combine multiple datasets into a chart is to declare a separate mark for each. You can even use array.map to create multiple marks from nested data.ForkjsPlot.plot({
  marks: [
    [goog, aapl].map((stock) => Plot.lineY(stock, {x: "Date", y: "Close"}))
  ]
})Marks may also be a function which returns an SVG element, if you wish to insert arbitrary content. (Here we use Hypertext Literal to generate an SVG gradient.)ForkjsPlot.plot({
  marks: [
    () => htl.svg`<defs>
      <linearGradient id="gradient" gradientTransform="rotate(90)">
        <stop offset="15%" stop-color="purple" />
        <stop offset="75%" stop-color="red" />
        <stop offset="100%" stop-color="gold" />
      </linearGradient>
    </defs>`,
    Plot.barY(alphabet, {x: "letter", y: "frequency", fill: "url(#gradient)"}),
    Plot.ruleY([0])
  ]
})And marks may be null or undefined, which produce no output; this is useful for showing marks conditionally (e.g., when a box is checked). Show area: ForkjsPlot.plot({
  marks: [
    Plot.ruleY([0]),
    area ? Plot.areaY(aapl, {x: "Date", y: "Close", fillOpacity: 0.2}) : null,
    Plot.lineY(aapl, {x: "Date", y: "Close"})
  ]
})Marks use scales ​Marks are (typically) not positioned in literal pixels, or colored in literal colors, as in a conventional graphics system. Instead you provide abstract values such as time and temperature — marks are drawn “in data space” — and scales encode these into visual values such as position and color. And best of all, Plot automatically creates axes and legends to document the scales’ encodings.Data is passed through scales automatically during rendering; the mark controls which scales are used. The x and y options are typically bound to the x and y scales, respectively, while the fill and stroke options are typically bound to the color scale. Changing a scale’s definition, say by overriding its domain (the extent of abstract input values) or type, affects the appearance of all marks that use the scale.ForkjsPlot.plot({
  y: {
    type: "log",
    domain: [30, 300],
    grid: true
  },
  marks: [
    Plot.lineY(aapl, {x: "Date", y: "Close"})
  ]
})Marks have tidy data ​A single mark can draw multiple shapes. A mark generally produces a shape — such as a rectangle or circle — for each element in the data.ForkjsPlot.dot(aapl, {x: "Date", y: "Close"}).plot()It’s more complicated than that, though, since some marks produce shapes that incorporate multiple data points. Pass the same data to a line and you’ll get a single polyline.ForkjsPlot.lineY(aapl, {x: "Date", y: "Close"}).plot()And a line mark isn’t even guaranteed to produce a single polyline — there can be multiple polylines, as in a line chart with multiple series (using z).ForkjsPlot.lineY(bls, {x: "date", y: "unemployment", z: "division"}).plot()Plot favors tidy data structured as an array of objects, where each object represents an observation (a row), and each object property represents an observed value; all objects in the array should have the same property names (the columns).For example, say we have hourly readings from two sensors A and B. You can represent the sensor log as an array of objects like so:jslinedata = [
  {hour: 0, value: 8, sensor: "A"},
  {hour: 0, value: 6, sensor: "B"},
  {hour: 1, value: 7, sensor: "A"},
  {hour: 1, value: 5, sensor: "B"},
  {hour: 2, value: 3, sensor: "A"},
  {hour: 2, value: 0, sensor: "B"},
  {hour: 3, value: 9, sensor: "A"},
  {hour: 3, value: 2, sensor: "B"}
]TIPFor larger datasets, you can more efficiently pass data using an Apache Arrow table as a columnar data representation. ^0.6.16Then you can pass the data to the line mark, and extract named columns from the data for the desired options:ForkjsPlot.lineY(linedata, {x: "hour", y: "value", stroke: "sensor"}).plot()Another common way to extract a column from tabular data is an accessor function. This function is invoked for each element in the data (each row), and returns the corresponding observed value, as with array.map.ForkjsPlot.lineY(linedata, {
  x: (d) => d.hour,
  y: (d) => d.value,
  stroke: (d) => d.sensor
}).plot()For greater efficiency, Plot also supports columnar data: you can use an Apache Arrow table as data instead of an array of objects. ^0.6.16 You can even pass parallel arrays of values, or Apache Arrow vectors, to each channel.jsPlot.lineY({length: linedata.length}, {
  x: linedata.map((d) => d.hour),
  y: linedata.map((d) => d.value),
  stroke: linedata.map((d) => d.sensor)
}).plot()TIPNote that when accessor functions or parallel arrays are used instead of field names, automatic axis labels (hour and value) are lost. These can be restored using the label option on the x and y scales.Marks imply data types ​Data comes in different types: quantitative (or temporal) values can be subtracted, ordinal values can be ordered, and nominal (or categorical) values can only be the same or different.INFOBecause nominal values often need some arbitrary order for display purposes — often alphabetical — Plot uses the term ordinal to refer to both ordinal and nominal data.Some marks work with any type of data, while other marks have certain requirements or assumptions of data. For example, a line should only be used when both x and y are quantitative or temporal, and when the data is in a meaningful order (such as chronological). This is because the line mark will interpolate between adjacent points to draw line segments. If x or y is nominal — say the names of countries — it doesn’t make sense to use a line because there is no half-way point between two nominal values.ForkjsPlot.lineY(["please", "don’t", "do", "this"]).plot() // 🌶️WARNINGWhile Plot aspires to give good defaults and helpful warnings, Plot won’t prevent you from creating a meaningless chart. Only you can prevent bogus charts!In particular, beware the simple “bar”! A bar mark is used for a bar chart, but a rect mark is needed for a histogram. Plot has four different mark types for drawing rectangles:use rect when both x and y are quantitativeuse barX when x is quantitative and y is ordinaluse barY when x is ordinal and y is quantitativeuse cell when both x and y are ordinalPlot encourages you to think about data types as you visualize because data types often imply semantics. For example, do you notice anything strange about the bar chart below?ForkjsPlot
  .barY(timeseries, {x: "year", y: "population"}) // 🌶️
  .plot({x: {tickFormat: ""}})Here’s the underlying data:jstimeseries = [
  {year: 2014, population: 7295.290765},
  {year: 2015, population: 7379.797139},
  {year: 2016, population: 7464.022049},
  {year: 2017, population: 7547.858925},
  {year: 2019, population: 7713.468100},
  {year: 2020, population: 7794.798739}
]The data is missing the population for the year 2018! Because the barY mark implies an ordinal x scale, the gap is hidden. Switching to the rectY mark (with the interval option to indicate that these are annual observations) reveals the missing data.ForkjsPlot
  .rectY(timeseries, {x: "year", y: "population", interval: 1})
  .plot({x: {tickFormat: ""}})Alternatively, you can keep the barY mark and apply the interval option to the x scale.ForkjsPlot
  .barY(timeseries, {x: "year", y: "population"})
  .plot({x: {tickFormat: "", interval: 1}})Marks have options ​When constructing a mark, you can specify options to change the mark’s appearance. These options are passed as a second argument to the mark constructor. (The first argument is the required data.) For example, if you want filled dots instead of stroked ones, pass the desired color to the fill option:ForkjsPlot.dot(gistemp, {x: "Date", y: "Anomaly", fill: "red"}).plot()As the name suggests, options are generally optional; Plot tries to provide good defaults for whatever you don’t specify. Plot even has shorthand for various common forms of data. Below, we extract an array of numbers from the gistemp dataset, and use the line mark shorthand to set x = index and y = identity.ForkjsPlot.lineY(gistemp.map((d) => d.Anomaly)).plot()Some marks even provide default transforms, say for stacking!TIPBecause Plot strives to be concise, there are many default behaviors, some of which can be subtle. If Plot isn’t doing what you expect, try disabling the defaults by specifying options explicitly.In addition to the standard options such as fill and stroke that are supported by all mark types, each mark type can support options unique to that type. For example, the dot mark takes a symbol option so you can draw things other than circles. See the documentation for each mark type to see what it supports.Marks have channels ​Channels are mark options that can be used to encode data. These options allow the value to vary with the data, such as a different position or color for each dot. To use a channel, supply it with a column of data, typically as:a field (column) name,an accessor function, oran array of values of the same length and order as the data.Not all mark options can be expressed as channels. For example, stroke can be a channel but strokeDasharray cannot. This is mostly a pragmatic limitation — it would be harder to implement Plot if every option were expressible as a channel — but it also serves to guide you towards options that are intended for encoding data.TIPTo vary the definition of a constant option with data, create multiple marks with your different constant options, and then filter the data for each mark to achieve the desired result.Some options can be either a channel or a constant depending on the provided value. For example, if you set the fill option to purple, Plot interprets it as a literal color.ForkjsPlot
  .barX(timeseries, {x: "population", y: "year", fill: "purple"})
  .plot({y: {label: null, tickFormat: ""}})Whereas if the fill option is a string but not a valid CSS color, Plot assumes you mean the corresponding column of the data and interprets it as a channel.ForkjsPlot
  .barX(timeseries, {x: "population", y: "year", fill: "year"})
  .plot({y: {label: null, tickFormat: ""}})If the fill option is a function, it is interpreted as a channel.ForkjsPlot
  .barX(timeseries, {x: "population", y: "year", fill: (d) => d.year})
  .plot({y: {label: null, tickFormat: ""}})Lastly, note that while channels are normally bound to a scale, you can bypass the color scale here by supplying literal color values to the fill channel.ForkjsPlot
  .barX(timeseries, {x: "population", y: "year", fill: (d) => d.year & 1 ? "red" : "currentColor"})
  .plot({y: {label: null, tickFormat: ""}})But rather than supplying literal values, it is more semantic to provide abstract values and use scales. In addition to centralizing the encoding definition (if used by multiple marks), it allows Plot to generate a legend.evenoddForkjsPlot
  .barX(timeseries, {x: "population", y: "year", fill: (d) => d.year & 1 ? "odd" : "even"})
  .plot({y: {label: null, tickFormat: ""}, color: {legend: true}})You can then specify the color scale’s domain and range to control the encoding.Mark options ​Mark constructors take two arguments: data and options. Together these describe a tabular dataset and how to visualize it. Option values that must be the same for all of a mark’s generated shapes are known as constants, whereas option values that may vary across a mark’s generated shapes are known as channels. Channels are typically bound to scales and encode abstract data values, such as time or temperature, as visual values, such as position or color. (Channels can also be used to order ordinal domains; see the sort option.)A mark’s data is most commonly an array of objects representing a tabular dataset, such as the result of loading a CSV file, while a mark’s options bind channels (such as x and y) to columns in the data (such as units and fruit).jssales = [
  {units: 10, fruit: "peach"},
  {units: 20, fruit: "pear"},
  {units: 40, fruit: "plum"},
  {units: 30, fruit: "plum"}
]jsPlot.dot(sales, {x: "units", y: "fruit"})While a column name such as "units" is the most concise way of specifying channel values, values can also be specified as functions for greater flexibility, say to transform data or derive a new column on the fly. Channel functions are invoked for each datum (d) in the data and return the corresponding channel value. (This is similar to how D3’s selection.attr accepts functions, though note that Plot channel functions should return abstract values, not visual values.)jsPlot.dot(sales, {x: (d) => d.units * 1000, y: (d) => d.fruit})Plot also supports columnar data for greater efficiency with bigger datasets; for example, data can be specified as any array of the appropriate length (or any iterable or value compatible with Array.from), and then separate arrays of values can be passed as options.jsindex = [0, 1, 2, 3]jsunits = [10, 20, 40, 30]jsfruits = ["peach", "pear", "plum", "plum"]jsPlot.dot(index, {x: units, y: fruits})Channel values can also be specified as numbers for constant values, say for a fixed baseline with an area.jsPlot.area(aapl, {x1: "Date", y1: 0, y2: "Close"})Missing and invalid data are handled specifically for each mark type and channel. In most cases, if the provided channel value for a given datum is null, undefined, or (strictly) NaN, the mark will implicitly filter the datum and not generate a corresponding output. In some cases, such as the radius (r) of a dot, the channel value must additionally be positive. Plot.line and Plot.area will stop the path before any invalid point and start again at the next valid point, thus creating interruptions rather than interpolating between valid points. Titles will only be added if they are non-empty.All marks support the following style options:fill - fill colorfillOpacity - fill opacity (a number between 0 and 1)stroke - stroke colorstrokeWidth - stroke width (in pixels)strokeOpacity - stroke opacity (a number between 0 and 1)strokeLinejoin - how to join lines (bevel, miter, miter-clip, or round)strokeLinecap - how to cap lines (butt, round, or square)strokeMiterlimit - to limit the length of miter joinsstrokeDasharray - a comma-separated list of dash lengths (typically in pixels)strokeDashoffset - the stroke dash offset (typically in pixels)opacity - object opacity (a number between 0 and 1)mixBlendMode - the blend mode (e.g., multiply)imageFilter - a CSS filter (e.g., blur(5px)) ^0.6.7shapeRendering - the shape-rendering mode (e.g., crispEdges)paintOrder - the paint order (e.g., stroke)dx - horizontal offset (in pixels; defaults to 0)dy - vertical offset (in pixels; defaults to 0)target - link target (e.g., “_blank” for a new window); for use with the href channelclassName - the class attribute, if any (defaults to null) ^0.6.16ariaDescription - a textual description of the mark’s contentsariaHidden - if true, hide this content from the accessibility treepointerEvents - the pointer events (e.g., none)clip - whether and how to clip the marktip - whether to generate an implicit pointer tip ^0.6.7If the clip option is frame (or equivalently true), the mark is clipped to the frame’s dimensions. If the clip option is null (or equivalently false), the mark is not clipped. If the clip option is sphere, the mark will be clipped to the projected sphere (e.g., the front hemisphere when using the orthographic projection); a geographic projection is required in this case. Lastly if the clip option is a GeoJSON object ^0.6.17, the mark will be clipped to the projected geometry.If the tip option is true, a tip mark with the pointer transform will be derived from this mark and placed atop all other marks, offering details on demand. If the tip option is set to an options object, these options will be passed to the derived tip mark. If the tip option (or, if an object, its pointer option) is set to x, y, or xy, pointerX, pointerY, or pointer will be used, respectively; otherwise the pointing mode will be chosen automatically. (If the tip mark option is truthy, the title channel is no longer applied using an SVG title element as this would conflict with the tip mark.)For all marks except text, the dx and dy options are rendered as a transform property, possibly including a 0.5px offset on low-density screens.All marks support the following optional channels:fill - a fill color; bound to the color scalefillOpacity - a fill opacity; bound to the opacity scalestroke - a stroke color; bound to the color scalestrokeOpacity - a stroke opacity; bound to the opacity scalestrokeWidth - a stroke width (in pixels)opacity - an object opacity; bound to the opacity scaletitle - an accessible, short-text description (a string of text, possibly with newlines)href - a URL to link toariaLabel - a short label representing the value in the accessibility treeThe fill, fillOpacity, stroke, strokeWidth, strokeOpacity, and opacity options can be specified as either channels or constants. When the fill or stroke is specified as a function or array, it is interpreted as a channel; when the fill or stroke is specified as a string, it is interpreted as a constant if a valid CSS color and otherwise it is interpreted as a column name for a channel. Similarly when the fill opacity, stroke opacity, object opacity, stroke width, or radius is specified as a number, it is interpreted as a constant; otherwise it is interpreted as a channel.The scale associated with any channel can be overridden by specifying the channel as an object with a value property specifying the channel values and a scale property specifying the desired scale name or null for an unscaled channel. For example, to force the stroke channel to be unscaled, interpreting the associated values as literal color strings:jsPlot.dot(data, {stroke: {value: "fieldName", scale: null}})To instead force the stroke channel to be bound to the color scale regardless of the provided values, say:jsPlot.dot(data, {stroke: {value: "fieldName", scale: "color"}})The color channels (fill and stroke) are bound to the color scale by default, unless the provided values are all valid CSS color strings or nullish, in which case the values are interpreted literally and unscaled.In addition to functions of data, arrays, and column names, channel values can be specified as an object with a transform method; this transform method is passed the mark’s array of data and must return the corresponding array of channel values. (Whereas a channel value specified as a function is invoked repeatedly for each element in the mark’s data, similar to array.map, the transform method is invoked only once being passed the entire array of data.) For example, to pass the mark’s data directly to the x channel, equivalent to Plot.identity:jsPlot.dot(numbers, {x: {transform: (data) => data}})The title, href, and ariaLabel options can only be specified as channels. When these options are specified as a string, the string refers to the name of a column in the mark’s associated data. If you’d like every instance of a particular mark to have the same value, specify the option as a function that returns the desired value, e.g. () => "Hello, world!".For marks that support the frameAnchor option, it may be specified as one of the four sides (top, right, bottom, left), one of the four corners (top-left, top-right, bottom-right, bottom-left), or the middle of the frame.All marks support the following transform options:filter - apply the filter transformsort - apply the sort transformreverse - apply the reverse transformtransform - apply a custom transforminitializer - apply a custom initializerThe sort option, when not specified as a channel value (such as a field name or an accessor function), can also be used to impute ordinal scale domains.Insets ​Rect-like marks support insets: a positive inset moves the respective side in (towards the opposing side), whereas a negative inset moves the respective side out (away from the opposing side). Insets are specified in pixels using the following options:inset - shorthand for all four insetsinsetTop - inset the top edgeinsetRight - inset the right edgeinsetBottom - inset the bottom edgeinsetLeft - inset the left edgeInsets default to zero. Insets are commonly used to create a one-pixel gap between adjacent bars in histograms; the bin transform provides default insets. (Note that the band scale padding defaults to 0.1 as an alternative to insets.)Rounded corners ​Rect-like marks support rounded corners. Each corner (or side) is individually addressable ^0.6.16 using the following options:r - the radius for all four cornersrx1 - the radius for the x1-y1 and x1-y2 cornersrx2 - the radius for the x2-y1 and x2-y2 cornersry1 - the radius for the x1-y1 and x2-y1 cornersry2 - the radius for the x1-y2 and x2-y2 cornersrx1y1 - the radius for the x1-y1 cornerrx1y2 - the radius for the x1-y2 cornerrx2y1 - the radius for the x2-y1 cornerrx2y2 - the radius for the x2-y2 cornerrx - the x-radius for elliptical cornersry - the y-radius for elliptical cornersCorner radii are specified in either pixels or, for rx and ry, as percentages (strings) or the keyword auto. If the corner radii are too big, they are reduced proportionally.marks(...marks) ^0.2.0 ​jsPlot.marks(
  Plot.ruleY([0]),
  Plot.areaY(data, {fill: color, fillOpacity, ...options}),
  Plot.lineY(data, {stroke: color, ...options})
)A convenience method for composing a mark from a series of other marks. Returns an array of marks that implements the mark.plot function. See the box mark implementation for an example.\n\nSearchK0.6.17GitHub️ 4.6kOn this pageMarks ​TIPIf you aren’t yet up and running with Plot, please read our getting started guide first. Tinkering with the code below will give a better sense of how Plot works.Plot doesn’t have chart types; instead, you construct charts by layering marks.Marks are geometric shapes ​Plot provides a variety of mark types. Think of marks as the “visual vocabulary” — the painter’s palette 🎨, but of shapes instead of colors — that you pull from when composing a chart. Each mark type produces a certain type of geometric shape.For example, the dot mark draws stroked circles (by default).ForkjsPlot.dot(gistemp, {x: "Date", y: "Anomaly"}).plot()The line mark draws connected line segments (also known as a polyline or polygonal chain).ForkjsPlot.lineY(gistemp, {x: "Date", y: "Anomaly"}).plot()And the bar mark draws rectangular bars in either a horizontal (barX→) or vertical (barY↑) orientation.ForkjsPlot.barX(alphabet, {x: "frequency", y: "letter"}).plot()So instead of looking for a chart type, consider the shape of the primary graphical elements in your chart, and look for the corresponding mark type. If a chart has only a single mark, the mark type is effectively the chart type: the bar mark is used to make a bar chart, the area mark is used to make an area chart, and so on.Marks are layered ​The big advantage of mark types over chart types is that you can compose multiple marks of different types into a single plot. For example, below an area and line are used to plot the same sequence of values, while a rule emphasizes y = 0.ForkjsPlot.plot({
  marks: [
    Plot.ruleY([0]),
    Plot.areaY(aapl, {x: "Date", y: "Close", fillOpacity: 0.2}),
    Plot.lineY(aapl, {x: "Date", y: "Close"})
  ]
})Each mark supplies its own data; a quick way to combine multiple datasets into a chart is to declare a separate mark for each. You can even use array.map to create multiple marks from nested data.ForkjsPlot.plot({
  marks: [
    [goog, aapl].map((stock) => Plot.lineY(stock, {x: "Date", y: "Close"}))
  ]
})Marks may also be a function which returns an SVG element, if you wish to insert arbitrary content. (Here we use Hypertext Literal to generate an SVG gradient.)ForkjsPlot.plot({
  marks: [
    () => htl.svg`<defs>
      <linearGradient id="gradient" gradientTransform="rotate(90)">
        <stop offset="15%" stop-color="purple" />
        <stop offset="75%" stop-color="red" />
        <stop offset="100%" stop-color="gold" />
      </linearGradient>
    </defs>`,
    Plot.barY(alphabet, {x: "letter", y: "frequency", fill: "url(#gradient)"}),
    Plot.ruleY([0])
  ]
})And marks may be null or undefined, which produce no output; this is useful for showing marks conditionally (e.g., when a box is checked). Show area: ForkjsPlot.plot({
  marks: [
    Plot.ruleY([0]),
    area ? Plot.areaY(aapl, {x: "Date", y: "Close", fillOpacity: 0.2}) : null,
    Plot.lineY(aapl, {x: "Date", y: "Close"})
  ]
})Marks use scales ​Marks are (typically) not positioned in literal pixels, or colored in literal colors, as in a conventional graphics system. Instead you provide abstract values such as time and temperature — marks are drawn “in data space” — and scales encode these into visual values such as position and color. And best of all, Plot automatically creates axes and legends to document the scales’ encodings.Data is passed through scales automatically during rendering; the mark controls which scales are used. The x and y options are typically bound to the x and y scales, respectively, while the fill and stroke options are typically bound to the color scale. Changing a scale’s definition, say by overriding its domain (the extent of abstract input values) or type, affects the appearance of all marks that use the scale.ForkjsPlot.plot({
  y: {
    type: "log",
    domain: [30, 300],
    grid: true
  },
  marks: [
    Plot.lineY(aapl, {x: "Date", y: "Close"})
  ]
})Marks have tidy data ​A single mark can draw multiple shapes. A mark generally produces a shape — such as a rectangle or circle — for each element in the data.ForkjsPlot.dot(aapl, {x: "Date", y: "Close"}).plot()It’s more complicated than that, though, since some marks produce shapes that incorporate multiple data points. Pass the same data to a line and you’ll get a single polyline.ForkjsPlot.lineY(aapl, {x: "Date", y: "Close"}).plot()And a line mark isn’t even guaranteed to produce a single polyline — there can be multiple polylines, as in a line chart with multiple series (using z).ForkjsPlot.lineY(bls, {x: "date", y: "unemployment", z: "division"}).plot()Plot favors tidy data structured as an array of objects, where each object represents an observation (a row), and each object property represents an observed value; all objects in the array should have the same property names (the columns).For example, say we have hourly readings from two sensors A and B. You can represent the sensor log as an array of objects like so:jslinedata = [
  {hour: 0, value: 8, sensor: "A"},
  {hour: 0, value: 6, sensor: "B"},
  {hour: 1, value: 7, sensor: "A"},
  {hour: 1, value: 5, sensor: "B"},
  {hour: 2, value: 3, sensor: "A"},
  {hour: 2, value: 0, sensor: "B"},
  {hour: 3, value: 9, sensor: "A"},
  {hour: 3, value: 2, sensor: "B"}
]TIPFor larger datasets, you can more efficiently pass data using an Apache Arrow table as a columnar data representation. ^0.6.16Then you can pass the data to the line mark, and extract named columns from the data for the desired options:ForkjsPlot.lineY(linedata, {x: "hour", y: "value", stroke: "sensor"}).plot()Another common way to extract a column from tabular data is an accessor function. This function is invoked for each element in the data (each row), and returns the corresponding observed value, as with array.map.ForkjsPlot.lineY(linedata, {
  x: (d) => d.hour,
  y: (d) => d.value,
  stroke: (d) => d.sensor
}).plot()For greater efficiency, Plot also supports columnar data: you can use an Apache Arrow table as data instead of an array of objects. ^0.6.16 You can even pass parallel arrays of values, or Apache Arrow vectors, to each channel.jsPlot.lineY({length: linedata.length}, {
  x: linedata.map((d) => d.hour),
  y: linedata.map((d) => d.value),
  stroke: linedata.map((d) => d.sensor)
}).plot()TIPNote that when accessor functions or parallel arrays are used instead of field names, automatic axis labels (hour and value) are lost. These can be restored using the label option on the x and y scales.Marks imply data types ​Data comes in different types: quantitative (or temporal) values can be subtracted, ordinal values can be ordered, and nominal (or categorical) values can only be the same or different.INFOBecause nominal values often need some arbitrary order for display purposes — often alphabetical — Plot uses the term ordinal to refer to both ordinal and nominal data.Some marks work with any type of data, while other marks have certain requirements or assumptions of data. For example, a line should only be used when both x and y are quantitative or temporal, and when the data is in a meaningful order (such as chronological). This is because the line mark will interpolate between adjacent points to draw line segments. If x or y is nominal — say the names of countries — it doesn’t make sense to use a line because there is no half-way point between two nominal values.ForkjsPlot.lineY(["please", "don’t", "do", "this"]).plot() // 🌶️WARNINGWhile Plot aspires to give good defaults and helpful warnings, Plot won’t prevent you from creating a meaningless chart. Only you can prevent bogus charts!In particular, beware the simple “bar”! A bar mark is used for a bar chart, but a rect mark is needed for a histogram. Plot has four different mark types for drawing rectangles:use rect when both x and y are quantitativeuse barX when x is quantitative and y is ordinaluse barY when x is ordinal and y is quantitativeuse cell when both x and y are ordinalPlot encourages you to think about data types as you visualize because data types often imply semantics. For example, do you notice anything strange about the bar chart below?ForkjsPlot
  .barY(timeseries, {x: "year", y: "population"}) // 🌶️
  .plot({x: {tickFormat: ""}})Here’s the underlying data:jstimeseries = [
  {year: 2014, population: 7295.290765},
  {year: 2015, population: 7379.797139},
  {year: 2016, population: 7464.022049},
  {year: 2017, population: 7547.858925},
  {year: 2019, population: 7713.468100},
  {year: 2020, population: 7794.798739}
]The data is missing the population for the year 2018! Because the barY mark implies an ordinal x scale, the gap is hidden. Switching to the rectY mark (with the interval option to indicate that these are annual observations) reveals the missing data.ForkjsPlot
  .rectY(timeseries, {x: "year", y: "population", interval: 1})
  .plot({x: {tickFormat: ""}})Alternatively, you can keep the barY mark and apply the interval option to the x scale.ForkjsPlot
  .barY(timeseries, {x: "year", y: "population"})
  .plot({x: {tickFormat: "", interval: 1}})Marks have options ​When constructing a mark, you can specify options to change the mark’s appearance. These options are passed as a second argument to the mark constructor. (The first argument is the required data.) For example, if you want filled dots instead of stroked ones, pass the desired color to the fill option:ForkjsPlot.dot(gistemp, {x: "Date", y: "Anomaly", fill: "red"}).plot()As the name suggests, options are generally optional; Plot tries to provide good defaults for whatever you don’t specify. Plot even has shorthand for various common forms of data. Below, we extract an array of numbers from the gistemp dataset, and use the line mark shorthand to set x = index and y = identity.ForkjsPlot.lineY(gistemp.map((d) => d.Anomaly)).plot()Some marks even provide default transforms, say for stacking!TIPBecause Plot strives to be concise, there are many default behaviors, some of which can be subtle. If Plot isn’t doing what you expect, try disabling the defaults by specifying options explicitly.In addition to the standard options such as fill and stroke that are supported by all mark types, each mark type can support options unique to that type. For example, the dot mark takes a symbol option so you can draw things other than circles. See the documentation for each mark type to see what it supports.Marks have channels ​Channels are mark options that can be used to encode data. These options allow the value to vary with the data, such as a different position or color for each dot. To use a channel, supply it with a column of data, typically as:a field (column) name,an accessor function, oran array of values of the same length and order as the data.Not all mark options can be expressed as channels. For example, stroke can be a channel but strokeDasharray cannot. This is mostly a pragmatic limitation — it would be harder to implement Plot if every option were expressible as a channel — but it also serves to guide you towards options that are intended for encoding data.TIPTo vary the definition of a constant option with data, create multiple marks with your different constant options, and then filter the data for each mark to achieve the desired result.Some options can be either a channel or a constant depending on the provided value. For example, if you set the fill option to purple, Plot interprets it as a literal color.ForkjsPlot
  .barX(timeseries, {x: "population", y: "year", fill: "purple"})
  .plot({y: {label: null, tickFormat: ""}})Whereas if the fill option is a string but not a valid CSS color, Plot assumes you mean the corresponding column of the data and interprets it as a channel.ForkjsPlot
  .barX(timeseries, {x: "population", y: "year", fill: "year"})
  .plot({y: {label: null, tickFormat: ""}})If the fill option is a function, it is interpreted as a channel.ForkjsPlot
  .barX(timeseries, {x: "population", y: "year", fill: (d) => d.year})
  .plot({y: {label: null, tickFormat: ""}})Lastly, note that while channels are normally bound to a scale, you can bypass the color scale here by supplying literal color values to the fill channel.ForkjsPlot
  .barX(timeseries, {x: "population", y: "year", fill: (d) => d.year & 1 ? "red" : "currentColor"})
  .plot({y: {label: null, tickFormat: ""}})But rather than supplying literal values, it is more semantic to provide abstract values and use scales. In addition to centralizing the encoding definition (if used by multiple marks), it allows Plot to generate a legend.evenoddForkjsPlot
  .barX(timeseries, {x: "population", y: "year", fill: (d) => d.year & 1 ? "odd" : "even"})
  .plot({y: {label: null, tickFormat: ""}, color: {legend: true}})You can then specify the color scale’s domain and range to control the encoding.Mark options ​Mark constructors take two arguments: data and options. Together these describe a tabular dataset and how to visualize it. Option values that must be the same for all of a mark’s generated shapes are known as constants, whereas option values that may vary across a mark’s generated shapes are known as channels. Channels are typically bound to scales and encode abstract data values, such as time or temperature, as visual values, such as position or color. (Channels can also be used to order ordinal domains; see the sort option.)A mark’s data is most commonly an array of objects representing a tabular dataset, such as the result of loading a CSV file, while a mark’s options bind channels (such as x and y) to columns in the data (such as units and fruit).jssales = [
  {units: 10, fruit: "peach"},
  {units: 20, fruit: "pear"},
  {units: 40, fruit: "plum"},
  {units: 30, fruit: "plum"}
]jsPlot.dot(sales, {x: "units", y: "fruit"})While a column name such as "units" is the most concise way of specifying channel values, values can also be specified as functions for greater flexibility, say to transform data or derive a new column on the fly. Channel functions are invoked for each datum (d) in the data and return the corresponding channel value. (This is similar to how D3’s selection.attr accepts functions, though note that Plot channel functions should return abstract values, not visual values.)jsPlot.dot(sales, {x: (d) => d.units * 1000, y: (d) => d.fruit})Plot also supports columnar data for greater efficiency with bigger datasets; for example, data can be specified as any array of the appropriate length (or any iterable or value compatible with Array.from), and then separate arrays of values can be passed as options.jsindex = [0, 1, 2, 3]jsunits = [10, 20, 40, 30]jsfruits = ["peach", "pear", "plum", "plum"]jsPlot.dot(index, {x: units, y: fruits})Channel values can also be specified as numbers for constant values, say for a fixed baseline with an area.jsPlot.area(aapl, {x1: "Date", y1: 0, y2: "Close"})Missing and invalid data are handled specifically for each mark type and channel. In most cases, if the provided channel value for a given datum is null, undefined, or (strictly) NaN, the mark will implicitly filter the datum and not generate a corresponding output. In some cases, such as the radius (r) of a dot, the channel value must additionally be positive. Plot.line and Plot.area will stop the path before any invalid point and start again at the next valid point, thus creating interruptions rather than interpolating between valid points. Titles will only be added if they are non-empty.All marks support the following style options:fill - fill colorfillOpacity - fill opacity (a number between 0 and 1)stroke - stroke colorstrokeWidth - stroke width (in pixels)strokeOpacity - stroke opacity (a number between 0 and 1)strokeLinejoin - how to join lines (bevel, miter, miter-clip, or round)strokeLinecap - how to cap lines (butt, round, or square)strokeMiterlimit - to limit the length of miter joinsstrokeDasharray - a comma-separated list of dash lengths (typically in pixels)strokeDashoffset - the stroke dash offset (typically in pixels)opacity - object opacity (a number between 0 and 1)mixBlendMode - the blend mode (e.g., multiply)imageFilter - a CSS filter (e.g., blur(5px)) ^0.6.7shapeRendering - the shape-rendering mode (e.g., crispEdges)paintOrder - the paint order (e.g., stroke)dx - horizontal offset (in pixels; defaults to 0)dy - vertical offset (in pixels; defaults to 0)target - link target (e.g., “_blank” for a new window); for use with the href channelclassName - the class attribute, if any (defaults to null) ^0.6.16ariaDescription - a textual description of the mark’s contentsariaHidden - if true, hide this content from the accessibility treepointerEvents - the pointer events (e.g., none)clip - whether and how to clip the marktip - whether to generate an implicit pointer tip ^0.6.7If the clip option is frame (or equivalently true), the mark is clipped to the frame’s dimensions. If the clip option is null (or equivalently false), the mark is not clipped. If the clip option is sphere, the mark will be clipped to the projected sphere (e.g., the front hemisphere when using the orthographic projection); a geographic projection is required in this case. Lastly if the clip option is a GeoJSON object ^0.6.17, the mark will be clipped to the projected geometry.If the tip option is true, a tip mark with the pointer transform will be derived from this mark and placed atop all other marks, offering details on demand. If the tip option is set to an options object, these options will be passed to the derived tip mark. If the tip option (or, if an object, its pointer option) is set to x, y, or xy, pointerX, pointerY, or pointer will be used, respectively; otherwise the pointing mode will be chosen automatically. (If the tip mark option is truthy, the title channel is no longer applied using an SVG title element as this would conflict with the tip mark.)For all marks except text, the dx and dy options are rendered as a transform property, possibly including a 0.5px offset on low-density screens.All marks support the following optional channels:fill - a fill color; bound to the color scalefillOpacity - a fill opacity; bound to the opacity scalestroke - a stroke color; bound to the color scalestrokeOpacity - a stroke opacity; bound to the opacity scalestrokeWidth - a stroke width (in pixels)opacity - an object opacity; bound to the opacity scaletitle - an accessible, short-text description (a string of text, possibly with newlines)href - a URL to link toariaLabel - a short label representing the value in the accessibility treeThe fill, fillOpacity, stroke, strokeWidth, strokeOpacity, and opacity options can be specified as either channels or constants. When the fill or stroke is specified as a function or array, it is interpreted as a channel; when the fill or stroke is specified as a string, it is interpreted as a constant if a valid CSS color and otherwise it is interpreted as a column name for a channel. Similarly when the fill opacity, stroke opacity, object opacity, stroke width, or radius is specified as a number, it is interpreted as a constant; otherwise it is interpreted as a channel.The scale associated with any channel can be overridden by specifying the channel as an object with a value property specifying the channel values and a scale property specifying the desired scale name or null for an unscaled channel. For example, to force the stroke channel to be unscaled, interpreting the associated values as literal color strings:jsPlot.dot(data, {stroke: {value: "fieldName", scale: null}})To instead force the stroke channel to be bound to the color scale regardless of the provided values, say:jsPlot.dot(data, {stroke: {value: "fieldName", scale: "color"}})The color channels (fill and stroke) are bound to the color scale by default, unless the provided values are all valid CSS color strings or nullish, in which case the values are interpreted literally and unscaled.In addition to functions of data, arrays, and column names, channel values can be specified as an object with a transform method; this transform method is passed the mark’s array of data and must return the corresponding array of channel values. (Whereas a channel value specified as a function is invoked repeatedly for each element in the mark’s data, similar to array.map, the transform method is invoked only once being passed the entire array of data.) For example, to pass the mark’s data directly to the x channel, equivalent to Plot.identity:jsPlot.dot(numbers, {x: {transform: (data) => data}})The title, href, and ariaLabel options can only be specified as channels. When these options are specified as a string, the string refers to the name of a column in the mark’s associated data. If you’d like every instance of a particular mark to have the same value, specify the option as a function that returns the desired value, e.g. () => "Hello, world!".For marks that support the frameAnchor option, it may be specified as one of the four sides (top, right, bottom, left), one of the four corners (top-left, top-right, bottom-right, bottom-left), or the middle of the frame.All marks support the following transform options:filter - apply the filter transformsort - apply the sort transformreverse - apply the reverse transformtransform - apply a custom transforminitializer - apply a custom initializerThe sort option, when not specified as a channel value (such as a field name or an accessor function), can also be used to impute ordinal scale domains.Insets ​Rect-like marks support insets: a positive inset moves the respective side in (towards the opposing side), whereas a negative inset moves the respective side out (away from the opposing side). Insets are specified in pixels using the following options:inset - shorthand for all four insetsinsetTop - inset the top edgeinsetRight - inset the right edgeinsetBottom - inset the bottom edgeinsetLeft - inset the left edgeInsets default to zero. Insets are commonly used to create a one-pixel gap between adjacent bars in histograms; the bin transform provides default insets. (Note that the band scale padding defaults to 0.1 as an alternative to insets.)Rounded corners ​Rect-like marks support rounded corners. Each corner (or side) is individually addressable ^0.6.16 using the following options:r - the radius for all four cornersrx1 - the radius for the x1-y1 and x1-y2 cornersrx2 - the radius for the x2-y1 and x2-y2 cornersry1 - the radius for the x1-y1 and x2-y1 cornersry2 - the radius for the x1-y2 and x2-y2 cornersrx1y1 - the radius for the x1-y1 cornerrx1y2 - the radius for the x1-y2 cornerrx2y1 - the radius for the x2-y1 cornerrx2y2 - the radius for the x2-y2 cornerrx - the x-radius for elliptical cornersry - the y-radius for elliptical cornersCorner radii are specified in either pixels or, for rx and ry, as percentages (strings) or the keyword auto. If the corner radii are too big, they are reduced proportionally.marks(...marks) ^0.2.0 ​jsPlot.marks(
  Plot.ruleY([0]),
  Plot.areaY(data, {fill: color, fillOpacity, ...options}),
  Plot.lineY(data, {stroke: color, ...options})
)A convenience method for composing a mark from a series of other marks. Returns an array of marks that implements the mark.plot function. See the box mark implementation for an example.PagerPrevious pagePlotsNext pageScales\n\nMarks ​TIPIf you aren’t yet up and running with Plot, please read our getting started guide first. Tinkering with the code below will give a better sense of how Plot works.Plot doesn’t have chart types; instead, you construct charts by layering marks.Marks are geometric shapes ​Plot provides a variety of mark types. Think of marks as the “visual vocabulary” — the painter’s palette 🎨, but of shapes instead of colors — that you pull from when composing a chart. Each mark type produces a certain type of geometric shape.For example, the dot mark draws stroked circles (by default).ForkjsPlot.dot(gistemp, {x: "Date", y: "Anomaly"}).plot()The line mark draws connected line segments (also known as a polyline or polygonal chain).ForkjsPlot.lineY(gistemp, {x: "Date", y: "Anomaly"}).plot()And the bar mark draws rectangular bars in either a horizontal (barX→) or vertical (barY↑) orientation.ForkjsPlot.barX(alphabet, {x: "frequency", y: "letter"}).plot()So instead of looking for a chart type, consider the shape of the primary graphical elements in your chart, and look for the corresponding mark type. If a chart has only a single mark, the mark type is effectively the chart type: the bar mark is used to make a bar chart, the area mark is used to make an area chart, and so on.Marks are layered ​The big advantage of mark types over chart types is that you can compose multiple marks of different types into a single plot. For example, below an area and line are used to plot the same sequence of values, while a rule emphasizes y = 0.ForkjsPlot.plot({
  marks: [
    Plot.ruleY([0]),
    Plot.areaY(aapl, {x: "Date", y: "Close", fillOpacity: 0.2}),
    Plot.lineY(aapl, {x: "Date", y: "Close"})
  ]
})Each mark supplies its own data; a quick way to combine multiple datasets into a chart is to declare a separate mark for each. You can even use array.map to create multiple marks from nested data.ForkjsPlot.plot({
  marks: [
    [goog, aapl].map((stock) => Plot.lineY(stock, {x: "Date", y: "Close"}))
  ]
})Marks may also be a function which returns an SVG element, if you wish to insert arbitrary content. (Here we use Hypertext Literal to generate an SVG gradient.)ForkjsPlot.plot({
  marks: [
    () => htl.svg`<defs>
      <linearGradient id="gradient" gradientTransform="rotate(90)">
        <stop offset="15%" stop-color="purple" />
        <stop offset="75%" stop-color="red" />
        <stop offset="100%" stop-color="gold" />
      </linearGradient>
    </defs>`,
    Plot.barY(alphabet, {x: "letter", y: "frequency", fill: "url(#gradient)"}),
    Plot.ruleY([0])
  ]
})And marks may be null or undefined, which produce no output; this is useful for showing marks conditionally (e.g., when a box is checked). Show area: ForkjsPlot.plot({
  marks: [
    Plot.ruleY([0]),
    area ? Plot.areaY(aapl, {x: "Date", y: "Close", fillOpacity: 0.2}) : null,
    Plot.lineY(aapl, {x: "Date", y: "Close"})
  ]
})Marks use scales ​Marks are (typically) not positioned in literal pixels, or colored in literal colors, as in a conventional graphics system. Instead you provide abstract values such as time and temperature — marks are drawn “in data space” — and scales encode these into visual values such as position and color. And best of all, Plot automatically creates axes and legends to document the scales’ encodings.Data is passed through scales automatically during rendering; the mark controls which scales are used. The x and y options are typically bound to the x and y scales, respectively, while the fill and stroke options are typically bound to the color scale. Changing a scale’s definition, say by overriding its domain (the extent of abstract input values) or type, affects the appearance of all marks that use the scale.ForkjsPlot.plot({
  y: {
    type: "log",
    domain: [30, 300],
    grid: true
  },
  marks: [
    Plot.lineY(aapl, {x: "Date", y: "Close"})
  ]
})Marks have tidy data ​A single mark can draw multiple shapes. A mark generally produces a shape — such as a rectangle or circle — for each element in the data.ForkjsPlot.dot(aapl, {x: "Date", y: "Close"}).plot()It’s more complicated than that, though, since some marks produce shapes that incorporate multiple data points. Pass the same data to a line and you’ll get a single polyline.ForkjsPlot.lineY(aapl, {x: "Date", y: "Close"}).plot()And a line mark isn’t even guaranteed to produce a single polyline — there can be multiple polylines, as in a line chart with multiple series (using z).ForkjsPlot.lineY(bls, {x: "date", y: "unemployment", z: "division"}).plot()Plot favors tidy data structured as an array of objects, where each object represents an observation (a row), and each object property represents an observed value; all objects in the array should have the same property names (the columns).For example, say we have hourly readings from two sensors A and B. You can represent the sensor log as an array of objects like so:jslinedata = [
  {hour: 0, value: 8, sensor: "A"},
  {hour: 0, value: 6, sensor: "B"},
  {hour: 1, value: 7, sensor: "A"},
  {hour: 1, value: 5, sensor: "B"},
  {hour: 2, value: 3, sensor: "A"},
  {hour: 2, value: 0, sensor: "B"},
  {hour: 3, value: 9, sensor: "A"},
  {hour: 3, value: 2, sensor: "B"}
]TIPFor larger datasets, you can more efficiently pass data using an Apache Arrow table as a columnar data representation. ^0.6.16Then you can pass the data to the line mark, and extract named columns from the data for the desired options:ForkjsPlot.lineY(linedata, {x: "hour", y: "value", stroke: "sensor"}).plot()Another common way to extract a column from tabular data is an accessor function. This function is invoked for each element in the data (each row), and returns the corresponding observed value, as with array.map.ForkjsPlot.lineY(linedata, {
  x: (d) => d.hour,
  y: (d) => d.value,
  stroke: (d) => d.sensor
}).plot()For greater efficiency, Plot also supports columnar data: you can use an Apache Arrow table as data instead of an array of objects. ^0.6.16 You can even pass parallel arrays of values, or Apache Arrow vectors, to each channel.jsPlot.lineY({length: linedata.length}, {
  x: linedata.map((d) => d.hour),
  y: linedata.map((d) => d.value),
  stroke: linedata.map((d) => d.sensor)
}).plot()TIPNote that when accessor functions or parallel arrays are used instead of field names, automatic axis labels (hour and value) are lost. These can be restored using the label option on the x and y scales.Marks imply data types ​Data comes in different types: quantitative (or temporal) values can be subtracted, ordinal values can be ordered, and nominal (or categorical) values can only be the same or different.INFOBecause nominal values often need some arbitrary order for display purposes — often alphabetical — Plot uses the term ordinal to refer to both ordinal and nominal data.Some marks work with any type of data, while other marks have certain requirements or assumptions of data. For example, a line should only be used when both x and y are quantitative or temporal, and when the data is in a meaningful order (such as chronological). This is because the line mark will interpolate between adjacent points to draw line segments. If x or y is nominal — say the names of countries — it doesn’t make sense to use a line because there is no half-way point between two nominal values.ForkjsPlot.lineY(["please", "don’t", "do", "this"]).plot() // 🌶️WARNINGWhile Plot aspires to give good defaults and helpful warnings, Plot won’t prevent you from creating a meaningless chart. Only you can prevent bogus charts!In particular, beware the simple “bar”! A bar mark is used for a bar chart, but a rect mark is needed for a histogram. Plot has four different mark types for drawing rectangles:use rect when both x and y are quantitativeuse barX when x is quantitative and y is ordinaluse barY when x is ordinal and y is quantitativeuse cell when both x and y are ordinalPlot encourages you to think about data types as you visualize because data types often imply semantics. For example, do you notice anything strange about the bar chart below?ForkjsPlot
  .barY(timeseries, {x: "year", y: "population"}) // 🌶️
  .plot({x: {tickFormat: ""}})Here’s the underlying data:jstimeseries = [
  {year: 2014, population: 7295.290765},
  {year: 2015, population: 7379.797139},
  {year: 2016, population: 7464.022049},
  {year: 2017, population: 7547.858925},
  {year: 2019, population: 7713.468100},
  {year: 2020, population: 7794.798739}
]The data is missing the population for the year 2018! Because the barY mark implies an ordinal x scale, the gap is hidden. Switching to the rectY mark (with the interval option to indicate that these are annual observations) reveals the missing data.ForkjsPlot
  .rectY(timeseries, {x: "year", y: "population", interval: 1})
  .plot({x: {tickFormat: ""}})Alternatively, you can keep the barY mark and apply the interval option to the x scale.ForkjsPlot
  .barY(timeseries, {x: "year", y: "population"})
  .plot({x: {tickFormat: "", interval: 1}})Marks have options ​When constructing a mark, you can specify options to change the mark’s appearance. These options are passed as a second argument to the mark constructor. (The first argument is the required data.) For example, if you want filled dots instead of stroked ones, pass the desired color to the fill option:ForkjsPlot.dot(gistemp, {x: "Date", y: "Anomaly", fill: "red"}).plot()As the name suggests, options are generally optional; Plot tries to provide good defaults for whatever you don’t specify. Plot even has shorthand for various common forms of data. Below, we extract an array of numbers from the gistemp dataset, and use the line mark shorthand to set x = index and y = identity.ForkjsPlot.lineY(gistemp.map((d) => d.Anomaly)).plot()Some marks even provide default transforms, say for stacking!TIPBecause Plot strives to be concise, there are many default behaviors, some of which can be subtle. If Plot isn’t doing what you expect, try disabling the defaults by specifying options explicitly.In addition to the standard options such as fill and stroke that are supported by all mark types, each mark type can support options unique to that type. For example, the dot mark takes a symbol option so you can draw things other than circles. See the documentation for each mark type to see what it supports.Marks have channels ​Channels are mark options that can be used to encode data. These options allow the value to vary with the data, such as a different position or color for each dot. To use a channel, supply it with a column of data, typically as:a field (column) name,an accessor function, oran array of values of the same length and order as the data.Not all mark options can be expressed as channels. For example, stroke can be a channel but strokeDasharray cannot. This is mostly a pragmatic limitation — it would be harder to implement Plot if every option were expressible as a channel — but it also serves to guide you towards options that are intended for encoding data.TIPTo vary the definition of a constant option with data, create multiple marks with your different constant options, and then filter the data for each mark to achieve the desired result.Some options can be either a channel or a constant depending on the provided value. For example, if you set the fill option to purple, Plot interprets it as a literal color.ForkjsPlot
  .barX(timeseries, {x: "population", y: "year", fill: "purple"})
  .plot({y: {label: null, tickFormat: ""}})Whereas if the fill option is a string but not a valid CSS color, Plot assumes you mean the corresponding column of the data and interprets it as a channel.ForkjsPlot
  .barX(timeseries, {x: "population", y: "year", fill: "year"})
  .plot({y: {label: null, tickFormat: ""}})If the fill option is a function, it is interpreted as a channel.ForkjsPlot
  .barX(timeseries, {x: "population", y: "year", fill: (d) => d.year})
  .plot({y: {label: null, tickFormat: ""}})Lastly, note that while channels are normally bound to a scale, you can bypass the color scale here by supplying literal color values to the fill channel.ForkjsPlot
  .barX(timeseries, {x: "population", y: "year", fill: (d) => d.year & 1 ? "red" : "currentColor"})
  .plot({y: {label: null, tickFormat: ""}})But rather than supplying literal values, it is more semantic to provide abstract values and use scales. In addition to centralizing the encoding definition (if used by multiple marks), it allows Plot to generate a legend.evenoddForkjsPlot
  .barX(timeseries, {x: "population", y: "year", fill: (d) => d.year & 1 ? "odd" : "even"})
  .plot({y: {label: null, tickFormat: ""}, color: {legend: true}})You can then specify the color scale’s domain and range to control the encoding.Mark options ​Mark constructors take two arguments: data and options. Together these describe a tabular dataset and how to visualize it. Option values that must be the same for all of a mark’s generated shapes are known as constants, whereas option values that may vary across a mark’s generated shapes are known as channels. Channels are typically bound to scales and encode abstract data values, such as time or temperature, as visual values, such as position or color. (Channels can also be used to order ordinal domains; see the sort option.)A mark’s data is most commonly an array of objects representing a tabular dataset, such as the result of loading a CSV file, while a mark’s options bind channels (such as x and y) to columns in the data (such as units and fruit).jssales = [
  {units: 10, fruit: "peach"},
  {units: 20, fruit: "pear"},
  {units: 40, fruit: "plum"},
  {units: 30, fruit: "plum"}
]jsPlot.dot(sales, {x: "units", y: "fruit"})While a column name such as "units" is the most concise way of specifying channel values, values can also be specified as functions for greater flexibility, say to transform data or derive a new column on the fly. Channel functions are invoked for each datum (d) in the data and return the corresponding channel value. (This is similar to how D3’s selection.attr accepts functions, though note that Plot channel functions should return abstract values, not visual values.)jsPlot.dot(sales, {x: (d) => d.units * 1000, y: (d) => d.fruit})Plot also supports columnar data for greater efficiency with bigger datasets; for example, data can be specified as any array of the appropriate length (or any iterable or value compatible with Array.from), and then separate arrays of values can be passed as options.jsindex = [0, 1, 2, 3]jsunits = [10, 20, 40, 30]jsfruits = ["peach", "pear", "plum", "plum"]jsPlot.dot(index, {x: units, y: fruits})Channel values can also be specified as numbers for constant values, say for a fixed baseline with an area.jsPlot.area(aapl, {x1: "Date", y1: 0, y2: "Close"})Missing and invalid data are handled specifically for each mark type and channel. In most cases, if the provided channel value for a given datum is null, undefined, or (strictly) NaN, the mark will implicitly filter the datum and not generate a corresponding output. In some cases, such as the radius (r) of a dot, the channel value must additionally be positive. Plot.line and Plot.area will stop the path before any invalid point and start again at the next valid point, thus creating interruptions rather than interpolating between valid points. Titles will only be added if they are non-empty.All marks support the following style options:fill - fill colorfillOpacity - fill opacity (a number between 0 and 1)stroke - stroke colorstrokeWidth - stroke width (in pixels)strokeOpacity - stroke opacity (a number between 0 and 1)strokeLinejoin - how to join lines (bevel, miter, miter-clip, or round)strokeLinecap - how to cap lines (butt, round, or square)strokeMiterlimit - to limit the length of miter joinsstrokeDasharray - a comma-separated list of dash lengths (typically in pixels)strokeDashoffset - the stroke dash offset (typically in pixels)opacity - object opacity (a number between 0 and 1)mixBlendMode - the blend mode (e.g., multiply)imageFilter - a CSS filter (e.g., blur(5px)) ^0.6.7shapeRendering - the shape-rendering mode (e.g., crispEdges)paintOrder - the paint order (e.g., stroke)dx - horizontal offset (in pixels; defaults to 0)dy - vertical offset (in pixels; defaults to 0)target - link target (e.g., “_blank” for a new window); for use with the href channelclassName - the class attribute, if any (defaults to null) ^0.6.16ariaDescription - a textual description of the mark’s contentsariaHidden - if true, hide this content from the accessibility treepointerEvents - the pointer events (e.g., none)clip - whether and how to clip the marktip - whether to generate an implicit pointer tip ^0.6.7If the clip option is frame (or equivalently true), the mark is clipped to the frame’s dimensions. If the clip option is null (or equivalently false), the mark is not clipped. If the clip option is sphere, the mark will be clipped to the projected sphere (e.g., the front hemisphere when using the orthographic projection); a geographic projection is required in this case. Lastly if the clip option is a GeoJSON object ^0.6.17, the mark will be clipped to the projected geometry.If the tip option is true, a tip mark with the pointer transform will be derived from this mark and placed atop all other marks, offering details on demand. If the tip option is set to an options object, these options will be passed to the derived tip mark. If the tip option (or, if an object, its pointer option) is set to x, y, or xy, pointerX, pointerY, or pointer will be used, respectively; otherwise the pointing mode will be chosen automatically. (If the tip mark option is truthy, the title channel is no longer applied using an SVG title element as this would conflict with the tip mark.)For all marks except text, the dx and dy options are rendered as a transform property, possibly including a 0.5px offset on low-density screens.All marks support the following optional channels:fill - a fill color; bound to the color scalefillOpacity - a fill opacity; bound to the opacity scalestroke - a stroke color; bound to the color scalestrokeOpacity - a stroke opacity; bound to the opacity scalestrokeWidth - a stroke width (in pixels)opacity - an object opacity; bound to the opacity scaletitle - an accessible, short-text description (a string of text, possibly with newlines)href - a URL to link toariaLabel - a short label representing the value in the accessibility treeThe fill, fillOpacity, stroke, strokeWidth, strokeOpacity, and opacity options can be specified as either channels or constants. When the fill or stroke is specified as a function or array, it is interpreted as a channel; when the fill or stroke is specified as a string, it is interpreted as a constant if a valid CSS color and otherwise it is interpreted as a column name for a channel. Similarly when the fill opacity, stroke opacity, object opacity, stroke width, or radius is specified as a number, it is interpreted as a constant; otherwise it is interpreted as a channel.The scale associated with any channel can be overridden by specifying the channel as an object with a value property specifying the channel values and a scale property specifying the desired scale name or null for an unscaled channel. For example, to force the stroke channel to be unscaled, interpreting the associated values as literal color strings:jsPlot.dot(data, {stroke: {value: "fieldName", scale: null}})To instead force the stroke channel to be bound to the color scale regardless of the provided values, say:jsPlot.dot(data, {stroke: {value: "fieldName", scale: "color"}})The color channels (fill and stroke) are bound to the color scale by default, unless the provided values are all valid CSS color strings or nullish, in which case the values are interpreted literally and unscaled.In addition to functions of data, arrays, and column names, channel values can be specified as an object with a transform method; this transform method is passed the mark’s array of data and must return the corresponding array of channel values. (Whereas a channel value specified as a function is invoked repeatedly for each element in the mark’s data, similar to array.map, the transform method is invoked only once being passed the entire array of data.) For example, to pass the mark’s data directly to the x channel, equivalent to Plot.identity:jsPlot.dot(numbers, {x: {transform: (data) => data}})The title, href, and ariaLabel options can only be specified as channels. When these options are specified as a string, the string refers to the name of a column in the mark’s associated data. If you’d like every instance of a particular mark to have the same value, specify the option as a function that returns the desired value, e.g. () => "Hello, world!".For marks that support the frameAnchor option, it may be specified as one of the four sides (top, right, bottom, left), one of the four corners (top-left, top-right, bottom-right, bottom-left), or the middle of the frame.All marks support the following transform options:filter - apply the filter transformsort - apply the sort transformreverse - apply the reverse transformtransform - apply a custom transforminitializer - apply a custom initializerThe sort option, when not specified as a channel value (such as a field name or an accessor function), can also be used to impute ordinal scale domains.Insets ​Rect-like marks support insets: a positive inset moves the respective side in (towards the opposing side), whereas a negative inset moves the respective side out (away from the opposing side). Insets are specified in pixels using the following options:inset - shorthand for all four insetsinsetTop - inset the top edgeinsetRight - inset the right edgeinsetBottom - inset the bottom edgeinsetLeft - inset the left edgeInsets default to zero. Insets are commonly used to create a one-pixel gap between adjacent bars in histograms; the bin transform provides default insets. (Note that the band scale padding defaults to 0.1 as an alternative to insets.)Rounded corners ​Rect-like marks support rounded corners. Each corner (or side) is individually addressable ^0.6.16 using the following options:r - the radius for all four cornersrx1 - the radius for the x1-y1 and x1-y2 cornersrx2 - the radius for the x2-y1 and x2-y2 cornersry1 - the radius for the x1-y1 and x2-y1 cornersry2 - the radius for the x1-y2 and x2-y2 cornersrx1y1 - the radius for the x1-y1 cornerrx1y2 - the radius for the x1-y2 cornerrx2y1 - the radius for the x2-y1 cornerrx2y2 - the radius for the x2-y2 cornerrx - the x-radius for elliptical cornersry - the y-radius for elliptical cornersCorner radii are specified in either pixels or, for rx and ry, as percentages (strings) or the keyword auto. If the corner radii are too big, they are reduced proportionally.marks(...marks) ^0.2.0 ​jsPlot.marks(
  Plot.ruleY([0]),
  Plot.areaY(data, {fill: color, fillOpacity, ...options}),
  Plot.lineY(data, {stroke: color, ...options})
)A convenience method for composing a mark from a series of other marks. Returns an array of marks that implements the mark.plot function. See the box mark implementation for an example.\n\n\n\nScales ​Scales convert an abstract value such as time or temperature to a visual value such as x→ or y↑ position or color. For example, say we have a dataset (gistemp) containing monthly observations of global average surface temperature from 1880 to 2016, represented as the “anomaly” (or difference) relative to the 1951–1980 average. The first few rows are:DateAnomaly1880-01-01-0.31880-02-01-0.211880-03-01-0.181880-04-01-0.271880-05-01-0.141880-06-01-0.29When visualizing this data with a line, the x scale is responsible for mapping dates to horizontal↔︎ positions. For example, 1880-01-01 might be mapped to x = 40 (on the left) and 2016-12-01 might be mapped to x = 620 (on the right). Likewise, the y scale maps temperature anomalies to vertical↕︎ positions.ForkjsPlot.lineY(gistemp, {x: "Date", y: "Anomaly"}).plot()In Plot, the mark binds channels to scales; for example, the line’s x channel is bound to the x scale. The channel name and the scale name are often the same, but not always; for example, an area’s y1 and y2 channels are both bound to the y scale. (You can opt-out of a scale for a particular channel using scale overrides if needed.)Think of a scale as a function that takes an abstract value and returns the corresponding visual value. For the y scale above, that might look like this:jsfunction y(anomaly) {
  const t = (anomaly - minAnomaly) / (maxAnomaly - minAnomaly); // t in [0, 1]
  return height - marginBottom - t * (height - marginTop - marginBottom);
}The function y depends on a few additional details: the chart’s size and margins, and the minimum and maximum temperatures in the data:jsconst marginTop = 20;
const marginBottom = 30;
const height = 400;
const minAnomaly = d3.min(gistemp, (d) => d.Anomaly);
const maxAnomaly = d3.max(gistemp, (d) => d.Anomaly);Scales aren’t limited to horizontal and vertical position. They can also output to color, radius, length, opacity, and more. For example if we switch to a rule and use the stroke channel instead of y, we get a one-dimensional heatmap:ForkjsPlot.ruleX(gistemp, {x: "Date", stroke: "Anomaly"}).plot()While the resulting chart looks different, the color scale here behaves similarly to the y function above — the only difference is that it interpolates colors (using d3.interpolateTurbo) instead of numbers (the top and bottom sides of the plot frame):jsfunction color(anomaly) {
  const t = (anomaly - minAnomaly) / (maxAnomaly - minAnomaly); // t in [0, 1]
  return d3.interpolateTurbo(t);
}Within a given plot, marks share scales. For example, if a plot has two line marks, such as the lines below visualizing the daily closing price of Google and Apple stock, both share the same x and y scales for a consistent encoding.ForkjsPlot.plot({
  marks: [
    Plot.ruleY([0]),
    Plot.lineY(goog, {x: "Date", y: "Close", stroke: "red"}),
    Plot.lineY(aapl, {x: "Date", y: "Close", stroke: "blue"})
  ]
})TIPWhen comparing the performance of different stocks, we typically want to normalize the return relative to a purchase price; see the normalize transform for an example. Also, not that we recommend them, but if you are interested in dual-axis charts, please upvote #147.Plot has many different scales; we categorize them by their input (domain) and output (range).The domain is the abstract values that the scale expects as input. For quantitative or temporal data, it is typically expressed as an extent such as [start, end], [cold, hot], or [min, max]. For ordinal or nominal data, it is an array of values such as names or categories. The type of input values corresponds to the type scale option (e.g., linear or ordinal).The range is the visual values that the scale generates as output. For position scales, it is typically an extent such as [left, right] or [bottom, top]; for color scales, it might be a continuous extent [blue, red] or an array of discrete colors. The type of values that a scale outputs corresponds to the name of the scale (e.g., x or color).Let’s look at some examples to make this less abstract.Continuous scales ​The domain of a quantitative scale is a continuous extent [min, max] where min and max are numbers, such as temperatures. Below, the first domain value (x = 0) corresponds to the left side of the plot while the second (x = 100) corresponds to the right side.ForkjsPlot.plot({x: {domain: [0, 100], grid: true}})Flipping the domain reverses the scale so that +x points ←left instead of right→.ForkjsPlot.plot({x: {domain: [100, 0], grid: true}})Alternatively, use the reverse option; this is convenient when the domain is implied from data rather than specified explicitly.ForkjsPlot.plot({x: {domain: [0, 100], reverse: true, grid: true}})If the domain is dates, Plot will default to a UTC scale. This is a linear scale with ticks based on the Gregorian calendar.ForkjsPlot.plot({x: {domain: [new Date("2021-01-01"), new Date("2022-01-01")], grid: true}})To force a UTC scale, say when the data is milliseconds since UNIX epoch rather than Date instances, pass utc as the type option. Though we recommend coercing strings and numbers to more specific types when you load data, rather than relying on scales to do it.ForkjsPlot.plot({x: {type: "utc", domain: [1609459200000, 1640995200000], grid: true}})If the scale type is time, the ticks will be in local time — as with the dates below — rather than UTC.ForkjsPlot.plot({x: {type: "time", domain: [new Date(2021, 0, 1), new Date(2022, 0, 1)], grid: true}})When plotting values that vary widely, such as the luminosity of stars in an HR diagram, a log scale may improve readability. Log scales default to base-10 ticks with SI-prefix notation.ForkjsPlot.plot({x: {type: "log", domain: [1e0, 1e5], grid: true}})If you prefer conventional notation, you can specify the tickFormat option to change the behavior of the axis. The tickFormat option can either be a d3.format string or a function that takes a tick value and returns the corresponding string. Note, however, that this may result in overlapping text.ForkjsPlot.plot({x: {type: "log", domain: [1e0, 1e5], tickFormat: ",", grid: true}})Log scales also support a base option, say for powers of two. This does not affect the scale’s encoding, but it does change where ticks are shown.ForkjsPlot.plot({x: {type: "log", base: 2, domain: [1e0, 1e4], ticks: 20, grid: true}})The domain of a log scale cannot include (or cross) zero; for this, consider a bi-symmetric log scale instead.ForkjsPlot.plot({x: {type: "symlog", domain: [-10, 10], grid: true}})Power scales and square-root scales are also supported. The pow scale supports the exponent option, which defaults to 1 (for a linear scale). The sqrt scale is shorthand for a pow scale with exponent 0.5.ForkjsPlot.plot({x: {type: "sqrt", domain: [0, 100], grid: true}})ForkjsPlot.plot({x: {type: "pow", exponent: 1 / 3, domain: [0, 100], grid: true}})Continuous scales also support a clamp option which, if true, clamps input values to the scale’s domain before scaling. This is useful for preventing marks from escaping the chart area.Continuous scales support an interpolate option specified either as a function that takes a single argument t in [0, 1] and returns the corresponding value from the range, or as a two-argument function that takes a pair of values [start, end] from the range and returns the corresponding interpolator from [0, 1], typically mapping 0 to start, and 1 to end.Continuous scales support a piecewise domain specified as an array of n domain values (with n greater than or equal to two), with a corresponding range having the same number of values; each segment of the domain is mapped to the matching segment of the range using the scale’s interpolator. When the domain has n > 2 elements and the range has two elements (for example, when using the default range on a x or y scale), the latter is automatically split into n − 1 segments of equal size. Note that in addition to the domain, you must specify the scale’s continuous type since a scale specified with a domain having more than two elements otherwise defaults to an ordinal scale. (You will often have to specify the ticks manually, too.) For an example, see the Polylinear axis notebook.Discrete scales ​Sadly, not all data is continuous: some data is merely ordinal, such as t-shirt sizes; and some categorical (a.k.a. nominal), such as brands of clothing. To encode such data as position, a point or band scale is required.A point scale divides space into uniformly-spaced discrete values. It is commonly used for scatterplots (a dot mark) of ordinal data. It is the default scale type for ordinal data on the x and y scale.ForkjsPlot.plot({x: {type: "point", domain: "ABCDEFGHIJ", grid: true}})A band scale divides space into uniformly-spaced and -sized discrete intervals. It is commonly used for bar charts (bar marks). To show the bands below, we use a cell instead of a grid.ForkjsPlot
  .cell("ABCDEFGHIJ", {x: Plot.identity, stroke: "currentColor", strokeOpacity: 0.1})
  .plot({x: {type: "band", domain: "ABCDEFGHIJ"}})While point and band scales appear visually similar when only the grid is visible, the two are not identical — they differ respective to padding. Play with the options below to get a sense of their effect on the scale’s behavior.Padding:0.10Align:0.50jsPlot.plot({
  grid: true,
  marginTop: 0.5,
  x: {
    padding,
    align,
    round: false
  },
  marks: [
    Plot.frame({strokeOpacity: 0.3}),
    Plot.tickX("ABCDEFGHIJ", {x: Plot.identity, stroke: "currentColor"})
  ]
})jsPlot.plot({
  grid: true,
  marginTop: 0.5,
  x: {
    padding,
    align,
    round: false
  },
  marks: [
    Plot.frame({strokeOpacity: 0.3}),
    Plot.cell("ABCDEFGHIJ", {x: Plot.identity, stroke: "currentColor"})
  ]
})Position scales also have a round option which forces the scale to snap to integer pixels. This defaults to true for point and band scales, and false for quantitative scales. Use caution with high-cardinality ordinal domains (i.e., a point or band scale used to encode many different values), as rounding can lead to “wasted” space or even zero-width bands.Color scales ​While position is the most salient (and important) encoding, color matters too! The default quantitative color scale type is linear, and the default scheme is turbo. A wide variety of sequential, diverging, and cyclical schemes are supported, including ColorBrewer and viridis. Color scheme: BluesGreensGreysPurplesRedsOrangesTurboViridisMagmaInfernoPlasmaCividisCubehelixWarmCoolBuGnBuPuGnBuOrRdPuBuGnPuBuPuRdRdPuYlGnBuYlGnYlOrBrYlOrRdRainbowSinebowjsPlot.plot({
  axis: null,
  padding: 0,
  color: {
    scheme: schemeq
  },
  marks: [
    Plot.cell(d3.range(40), {x: Plot.identity, fill: Plot.identity, inset: -0.5})
  ]
})You can implement a custom color scheme by specifying the scale’s range, or by passing an interpolate function that takes a parameter t in [0, 1]. The interpolate option can specify a color space such as rgb, or a two-argument function that takes a pair of values from the range. Color interpolate: rgblabhclhsld3.interpolateRgb.gamma(2)(t) => `hsl(${t * 360},100%,50%)`jsPlot.plot({
  axis: null,
  padding: 0,
  color: {
    type: "linear",
    ...interpolateq === "angry-rainbow"
      ? {interpolate: (t) => `hsl(${t * 360},100%,50%)`}
      : interpolateq === "rgb-gamma"
      ? {range: ["steelblue", "orange"], interpolate: d3.interpolateRgb.gamma(2)}
      : {range: ["steelblue", "orange"], interpolate: interpolateq}
  },
  marks: [
    Plot.cell(d3.range(40), {x: Plot.identity, fill: Plot.identity, inset: -0.5})
  ]
})And like position scales, you can apply a sqrt, pow, log, or symlog transform; these are often useful when working with non-uniformly distributed data.Diverging color scales are intended to show positive and negative values, or more generally values above or below some pivot value. Diverging color scales default to the RdBu (red–blue) color scheme. The pivot defaults to zero, but you can change it with the pivot option, which should ideally be a value near the middle of the domain. Color scheme: BrBGPRGnPiYGPuOrRdBuRdGyRdYlBuRdYlGnSpectralBuRdBuYlRdjsPlot.plot({
  axis: null,
  padding: 0,
  color: {
    type: "linear",
    scheme: schemed
  },
  marks: [
    Plot.cell(d3.range(40), {x: Plot.identity, fill: Plot.identity, inset: -0.5})
  ]
})Below we again show observed global surface temperatures. The reversed BuRd color scheme is used since blue and red are semantically associated with cold and hot, respectively.ForkjsPlot.plot({
  grid: true,
  color: {
    type: "diverging",
    scheme: "BuRd"
  },
  marks: [
    Plot.ruleY([0]),
    Plot.dot(gistemp, {x: "Date", y: "Anomaly", stroke: "Anomaly"})
  ]
})Plot also provides color schemes for discrete data. Use the categorical type for categorical (nominal) unordered data, and the ordinal type for ordered data. Color scheme: AccentCategory10Dark2Observable10PairedPastel1Pastel2Set1Set2Set3Tableau10BluesGreensGreysPurplesRedsOrangesTurboViridisMagmaInfernoPlasmaCividisCubehelixWarmCoolBuGnBuPuGnBuOrRdPuBuGnPuBuPuRdRdPuYlGnBuYlGnYlOrBrYlOrRdRainbowSinebowjsPlot.plot({
  color: {
    type: "ordinal",
    scheme: schemeo
  },
  marks: [
    Plot.cell("ABCDEFGHIJ", {x: Plot.identity, fill: Plot.identity})
  ]
})CAUTIONDiscrete color schemes are intended for data that has only a few unique values. If the size of the categorical domain exceeds the number of colors in the scheme, colors will be reused; combining values into an “other” category is recommended.Other scales ​But wait, there’s more! 😅 Plot has opacity, r, symbol, and length scales, too. For example, the r scale type defaults to sqrt such that when used with the dot mark, the resulting area is proportional to the r channel value. You can adjust the effective dot size by specifying an explicit range, as below. Radius: 8.0ForkjsPlot.plot({
  r: {range: [0, radius]},
  marks: [
    Plot.dot(d3.range(1, 11), {x: Plot.identity, r: Plot.identity, fill: "currentColor"})
  ]
})The default range for the associated r scale is constructed such that a zero value maps to zero for an accurate areal encoding, while the first quartile of values is mapped to a radius of three pixels; this tends to be more stable with varying data.Type inference ​Plot strives to be concise: rather than you laboriously specifying everything, Plot can guess by inspecting the data so you don’t have to set the type, domain, and range (and for color, scheme) of scales explicitly. But for Plot’s guesses to be accurate, your data must match Plot’s expectations. Here they are.A scale’s type is most often inferred from associated marks’ channel values: strings and booleans imply an ordinal scale; dates imply a utc scale; anything else is linear. Plot assumes that your data is consistently typed, so inference is based solely on the first non-null, non-undefined value. We recommend typed CSV (passing {typed: true} to Observable’s FileAttachment csv method) or explicitly coercing types when loading data (e.g., d3.autoType).If a scale’s domain is specified explicitly, the scale’s type is inferred from the domain values rather than channels as described above. However, if the domain or range has more than two elements, the ordinal type (or point for position scales) is used.Finally, some marks declare the scale type for associated channels. For example, barX requires y to be a band scale. Further, the facet scales fx and fy are always band scales, and the r (radius) scale is implicitly a sqrt scale.If you don’t specify a quantitative scale’s domain, it is the extent (minimum and maximum) of associated channel values, except for the r (radius) scale where it goes from zero to the maximum. A quantitative domain can be extended to “nice” human-readable values with the nice option. For an ordinal scale, the domain defaults to the sorted union (all distinct values in natural order) of associated values; see the sort mark option to change the order.All position scales (x, y, fx, and fy) have implicit automatic ranges based on the chart dimensions. The x scale ranges from the left to right edge, while the y scale ranges from the bottom to top edge, accounting for margins.Scale transforms ​The transform scale option allows you to apply a function to all values before they are passed through the scale. This is convenient for transforming a scale’s data, say to convert to thousands or between temperature units.ForkjsPlot.plot({
  y: {
    grid: true,
    label: "Temperature (°C)",
    transform: (f) => (f - 32) * (5 / 9) // convert Fahrenheit to Celsius
  },
  marks: [
    Plot.ruleY([32]), // 32°F
    Plot.lineY(sftemp, Plot.windowY(7, {x: "date", y: "high"}))
  ]
})The percent scale option is shorthand for a transform that multiplies values by 100; it also adds a percent symbol (%) to the default label.ForkjsPlot.plot({
  y: {percent: true}, // convert proportion [0, 1] to percent [0, 100]
  color: {scheme: "BuRd"},
  marks: [
    Plot.rectY(gistemp, Plot.binX({y: "proportion", fill: "x"}, {x: "Anomaly", fill: "Anomaly"})),
    Plot.ruleY([0])
  ]
})CAUTIONMark transforms typically consume values before they are passed through scales (e.g., when binning). In this case the mark transforms will see the values prior to the scale transform as input, and the scale transform will apply to the output of the mark transform.The interval scale option ^0.5.1 sets an ordinal scale’s domain to the start of every interval within the extent of the data. In addition, it implicitly sets the transform of the scale to interval.floor, rounding values down to the start of each interval. For example, below we generate a time-series bar chart; when an interval is specified, missing days are visible. Use interval: ForkjsPlot.plot({
  marginBottom: 80,
  x: {
    tickRotate: -90,
    interval: intervaled ? "day" : null,
    label: null
  },
  y: {
    transform: (d) => d / 1e6,
    label: "Daily trade volume (millions)"
  },
  marks: [
    Plot.barY(aapl.slice(-40), {x: "Date", y: "Volume"}),
    Plot.ruleY([0])
  ]
})TIPAs an added bonus, the fontVariant and type options are no longer needed because Plot now understands that the x scale, despite being ordinal, represents daily observations.While the example above relies on the interval being promoted to the scale’s transform, the stack, bin, and group transforms are also interval-aware: they apply the scale’s interval, if any, before grouping values. (This results in the interval being applied twice, both before and after the mark transform, but the second application has no effect since interval application is idempotent.)The interval option can also be used for quantitative and temporal scales. This enforces uniformity, say rounding timed observations down to the nearest hour, which may be helpful for the stack transform among other uses.Scale options ​Each scale’s options are specified as a nested options object with the corresponding scale name within the top-level plot options:x - horizontal positiony - vertical positionr - radius (size)color - fill or strokeopacity - fill or stroke opacitylength - linear length (for vectors)symbol - categorical symbol (for dots)For example, to set the domain for the x scale:jsPlot.plot({x: {domain: [new Date("1880-01-01"), new Date("2016-11-01")]}})Plot supports many scale types. Some scale types are for quantitative data: values that can be added or subtracted, such as temperature or time. Other scale types are for ordinal or categorical data: unquantifiable values that can only be ordered, such as t-shirt sizes, or values with no inherent order that can only be tested for equality, such as types of fruit. Some scale types are further intended for specific visual encodings: for example, as position or color.You can set the scale type explicitly via the type scale option, though typically the scale type is inferred automatically. Some marks mandate a particular scale type: for example, barY requires that the x scale is a band scale. Some scales have a default type: for example, the r (radius) scale defaults to sqrt and the opacity scale defaults to linear. Most often, the scale type is inferred from associated data, pulled either from the domain (if specified) or from associated channels. Strings and booleans imply an ordinal scale; dates imply a UTC scale; and anything else is linear. Unless they represent text, we recommend explicitly converting strings to more specific types when loading data (e.g., with d3.autoType or Observable’s FileAttachment). For simplicity’s sake, Plot assumes that data is consistently typed; type inference is based solely on the first non-null, non-undefined value.For quantitative data (i.e. numbers), a mathematical transform may be applied to the data by changing the scale type:linear (default) - linear transform (translate and scale)pow - power (exponential) transformsqrt - square-root transform (pow transform with exponent = 0.5)log - logarithmic transformsymlog - bi-symmetric logarithmic transform per Webber et al.The appropriate transform depends on the data’s distribution and what you wish to know. A sqrt transform exaggerates differences between small values at the expense of large values; it is a special case of the pow transform which has a configurable scale.exponent (0.5 for sqrt). A log transform is suitable for comparing orders of magnitude and can only be used when the domain does not include zero. The base defaults to 10 and can be specified with the scale.base option; note that this only affects the axis ticks and not the scale’s behavior. A symlog transform is more elaborate, but works well with wide-range values that include zero; it can be configured with the scale.constant option (default 1).For temporal data (i.e. dates), two variants of a linear scale are also supported:utc (default, recommended) - UTC timetime - local timeUTC is recommended over local time as charts in UTC time are guaranteed to appear consistently to all viewers whereas charts in local time will depend on the viewer’s time zone. Due to limitations in JavaScript’s Date class, Plot does not yet support an explicit time zone other than UTC.For ordinal data (e.g., strings), use the ordinal scale type or the point or band position scale types. The categorical scale type is also supported; it is equivalent to ordinal except as a color scale, where it provides a different default color scheme. (Since position is inherently ordinal or even quantitative, categorical data must be assigned an effective order when represented as position, and hence categorical and ordinal may be considered synonymous in context.)You can opt-out of a scale using the identity scale type. This is useful if you wish to specify literal colors or pixel positions within a mark channel rather than relying on the scale to convert abstract values into visual values. For position scales (x and y), an identity scale is still quantitative and may produce an axis, yet unlike a linear scale the domain and range are fixed based on the plot layout.TIPTo opt-out of a scale for a single channel, you can specify the channel values as a {value, scale} object; see mark options.Quantitative scales, as well as identity position scales, coerce channel values to numbers; both null and undefined are coerced to NaN. Similarly, time scales coerce channel values to dates; numbers are assumed to be milliseconds since UNIX epoch, while strings are assumed to be in ISO 8601 format.A scale’s domain (the extent of its inputs, abstract values) and range (the extent of its outputs, visual values) are typically inferred automatically. You can set them explicitly using these options:domain - typically [min, max], or an array of ordinal or categorical valuesrange - typically [min, max], or an array of ordinal or categorical valuesunknown - the desired output value (defaults to undefined) for invalid input valuesreverse - reverses the domain (or the range), say to flip the chart along x or yinterval - an interval or time interval (for interval data; see below)For most quantitative scales, the default domain is the [min, max] of all values associated with the scale. For the radius and opacity scales, the default domain is [0, max] to ensure a meaningful value encoding. For ordinal scales, the default domain is the set of all distinct values associated with the scale in natural ascending order; for a different order, set the domain explicitly or add a sort option to an associated mark. For threshold scales, the default domain is [0] to separate negative and non-negative values. For quantile scales, the default domain is the set of all defined values associated with the scale. If a scale is reversed, it is equivalent to setting the domain as [max, min] instead of [min, max].The default range depends on the scale: for position scales (x, y, fx, and fy), the default range depends on the plot’s size and margins. For color scales, there are default color schemes for quantitative, ordinal, and categorical data. For opacity, the default range is [0, 1]. And for radius, the default range is designed to produce dots of “reasonable” size assuming a sqrt scale type for accurate area representation: zero maps to zero, the first quartile maps to a radius of three pixels, and other values are extrapolated. This convention for radius ensures that if the scale’s data values are all equal, dots have the default constant radius of three pixels, while if the data varies, dots will tend to be larger.The behavior of the unknown scale option depends on the scale type. For quantitative and temporal scales, the unknown value is used whenever the input value is undefined, null, or NaN. For ordinal or categorical scales, the unknown value is returned for any input value outside the domain. For band or point scales, the unknown option has no effect; it is effectively always equal to undefined. If the unknown option is set to undefined (the default), or null or NaN, then the affected input values will be considered undefined and filtered from the output.For data at regular intervals, such as integer values or daily samples, the interval option can be used to enforce uniformity. The specified interval — such as d3.utcMonth — must expose an interval.floor(value), interval.offset(value), and interval.range(start, stop) functions. The option can also be specified as a number, in which case it will be promoted to a numeric interval with the given step. The option can alternatively be specified as a string (second, minute, hour, day, week, month, quarter, half, year, monday, tuesday, wednesday, thursday, friday, saturday, sunday) ^0.6.2 naming the corresponding time interval, or a skip interval consisting of a number followed by the interval name (possibly pluralized), such as 3 months or 10 years. This option sets the default scale.transform to the given interval’s interval.floor function. In addition, the default scale.domain is an array of uniformly-spaced values spanning the extent of the values associated with the scale.Quantitative scales can be further customized with additional options:clamp - if true, clamp input values to the scale’s domainnice - if true (or a tick count), extend the domain to nice round valueszero - if true, extend the domain to include zero if neededpercent - if true, transform proportions in [0, 1] to percentages in [0, 100]Clamping is typically used in conjunction with setting an explicit domain since if the domain is inferred, no values will be outside the domain. Clamping is useful for focusing on a subset of the data while ensuring that extreme values remain visible, but use caution: clamped values may need an annotation to avoid misinterpretation. Top-level clamp, nice, and zero options are supported as shorthand for setting the respective option on all scales.The transform option allows you to apply a function to all values before they are passed through the scale. This is convenient for transforming a scale’s data, say to convert to thousands or between temperature units.jsPlot.plot({
  y: {
    label: "Temperature (°F)",
    transform: (f) => f * 9 / 5 + 32 // convert Celsius to Fahrenheit
  },
  marks: …
})Color scale options ​The normal scale types — linear, sqrt, pow, log, symlog, and ordinal — can be used to encode color. In addition, Plot supports special scale types for color:categorical - like ordinal, but defaults to observable10sequential - like linearcyclical - like linear, but defaults to rainbowthreshold - discretizes using thresholds given as the domain; defaults to rdylbuquantile - discretizes by computing quantile thresholds; defaults to rdylbuquantize - discretizes by computing uniform thresholds; defaults to rdylbu ^0.4.3diverging - like linear, but with a pivot; defaults to rdbudiverging-log - like log, but with a pivot that defaults to 1; defaults to rdbudiverging-pow - like pow, but with a pivot; defaults to rdbudiverging-sqrt - like sqrt, but with a pivot; defaults to rdbudiverging-symlog - like symlog, but with a pivot; defaults to rdbuFor a threshold scale, the domain represents n (typically numeric) thresholds which will produce a range of n + 1 output colors; the ith color of the range applies to values that are smaller than the ith element of the domain and larger or equal to the i - 1th element of the domain. For a quantile scale, the domain represents all input values to the scale, and the n option specifies how many quantiles to compute from the domain; n quantiles will produce n - 1 thresholds, and an output range of n colors. For a quantize scale, the domain will be transformed into approximately n quantized values, where n is an option that defaults to 5.By default, all diverging color scales are symmetric around the pivot; set symmetric to false if you want to cover the whole extent on both sides.Color scales support two additional options:scheme - a named color scheme in lieu of a range, such as redsinterpolate - in conjunction with a range, how to interpolate colorsFor quantile and quantize color scales, the scheme option is used in conjunction with n, which determines how many quantiles or quantized values to compute, and thus the number of elements in the scale’s range; it defaults to 5 (for quintiles in the case of a quantile scale).The following sequential scale schemes are supported for both quantitative and ordinal data:jsPlot.plot({
  width: 322,
  height: 25 * 27,
  margin: 0,
  marginRight: 70,
  padding: 0,
  x: {axis: null},
  y: {axis: "right", tickSize: 0},
  color: {type: "identity"},
  marks: [
    Plot.cell([
      ["Blues", d3.interpolateBlues],
      ["Greens", d3.interpolateGreens],
      ["Greys", d3.interpolateGreys],
      ["Purples", d3.interpolatePurples],
      ["Reds", d3.interpolateReds],
      ["Oranges", d3.interpolateOranges],
      ["Turbo", d3.interpolateTurbo],
      ["Viridis", d3.interpolateViridis],
      ["Magma", d3.interpolateMagma],
      ["Inferno", d3.interpolateInferno],
      ["Plasma", d3.interpolatePlasma],
      ["Cividis", d3.interpolateCividis],
      ["Cubehelix", d3.interpolateCubehelixDefault],
      ["Warm", d3.interpolateWarm],
      ["Cool", d3.interpolateCool],
      ["BuGn", d3.interpolateBuGn],
      ["BuPu", d3.interpolateBuPu],
      ["GnBu", d3.interpolateGnBu],
      ["OrRd", d3.interpolateOrRd],
      ["PuBuGn", d3.interpolatePuBuGn],
      ["PuBu", d3.interpolatePuBu],
      ["PuRd", d3.interpolatePuRd],
      ["RdPu", d3.interpolateRdPu],
      ["YlGnBu", d3.interpolateYlGnBu],
      ["YlGn", d3.interpolateYlGn],
      ["YlOrBr", d3.interpolateYlOrBr],
      ["YlOrRd", d3.interpolateYlOrRd],
    ].flatMap(([name, i]) => d3.ticks(0, 1, 20).map((t) => [t, name, String(i(t))])), {fill: "2", insetTop: 0.5, insetBottom: 0.5})
  ]
})The default color scheme, turbo, was chosen primarily to ensure high-contrast visibility. Color schemes such as blues make low-value marks difficult to see against a white background, for better or for worse. To use a subset of a continuous color scheme (or any single-argument interpolate function), set the scale.range property to the corresponding subset of [0, 1]; for example, to use the first half of the rainbow color scheme, use a range of [0, 0.5]. By default, the full range [0, 1] is used. If you wish to encode a quantitative value without hue, consider using opacity rather than color (e.g., use Plot.dot’s strokeOpacity instead of stroke).The following diverging scale schemes are supported:jsPlot.plot({
  width: 322,
  height: 25 * 11,
  margin: 0,
  marginRight: 70,
  padding: 0,
  x: {axis: null},
  y: {axis: "right", tickSize: 0},
  color: {type: "identity"},
  marks: [
    Plot.cell([
      ["BrBG", d3.interpolateBrBG],
      ["PRGn", d3.interpolatePRGn],
      ["PiYG", d3.interpolatePiYG],
      ["PuOr", d3.interpolatePuOr],
      ["RdBu", d3.interpolateRdBu],
      ["RdGy", d3.interpolateRdGy],
      ["RdYlBu", d3.interpolateRdYlBu],
      ["RdYlGn", d3.interpolateRdYlGn],
      ["Spectral", d3.interpolateSpectral],
      ["BuRd", (t) => d3.interpolateRdBu(1 - t)],
      ["BuYlRd", (t) => d3.interpolateRdYlBu(1 - t)],
    ].flatMap(([name, i]) => d3.ticks(0, 1, 30).map((t) => [t, name, String(i(t))])), {fill: "2", insetTop: 0.5, insetBottom: 0.5})
  ]
})Picking a diverging color scheme name defaults the scale type to diverging; set the scale type to linear to treat the color scheme as sequential instead. Diverging color scales support a scale.pivot option, which defaults to zero. Values below the pivot will use the lower half of the color scheme (e.g., reds for the rdgy scheme), while values above the pivot will use the upper half (grays for rdgy).The following cylical color schemes are supported:jsPlot.plot({
  width: 322,
  height: 25 * 2,
  margin: 0,
  marginRight: 70,
  padding: 0,
  x: {axis: null},
  y: {axis: "right", tickSize: 0},
  color: {type: "identity"},
  marks: [
    Plot.cell([
      ["rainbow", d3.interpolateRainbow],
      ["sinebow", d3.interpolateSinebow],
    ].flatMap(([name, i]) => d3.ticks(0, 1, 30).map((t) => [t, name, String(i(t))])), {fill: "2", insetTop: 0.5, insetBottom: 0.5})
  ]
})The following categorical color schemes are supported:jsPlot.plot({
  width: 322,
  height: 25 * 10,
  margin: 0,
  marginRight: 70,
  padding: 0,
  x: {axis: null},
  y: {axis: "right", tickSize: 0},
  color: {type: "identity"},
  marks: [
    Plot.cell([
      ["Accent", d3.schemeAccent],
      ["Category10", d3.schemeCategory10],
      ["Dark2", d3.schemeDark2],
      ["Observable10", Plot.scale({color: {type: "categorical"}}).range],
      ["Paired", d3.schemePaired],
      ["Pastel1", d3.schemePastel1],
      ["Pastel2", d3.schemePastel2],
      ["Set1", d3.schemeSet1],
      ["Set2", d3.schemeSet2],
      ["Set3", d3.schemeSet3],
      ["Tableau10", d3.schemeTableau10],
    ].flatMap(([name, scheme]) => scheme.map((s, i) => [i, name, s])), {fill: "2", inset: 0.5})
  ]
})The following color interpolators are supported:rgb - RGB (red, green, blue)hsl - HSL (hue, saturation, lightness)lab - CIELAB (a.k.a. “Lab”)hcl - CIELChab (a.k.a. “LCh” or “HCL”)Position scale options ​The position scales (x, y, fx, and fy) support additional options:inset - inset the default range by the specified amount in pixelsround - round the output value to the nearest integer (whole pixel)The x and fx scales support asymmetric insets for more precision. Replace inset by:insetLeft - insets the start of the default range by the specified number of pixelsinsetRight - insets the end of the default range by the specified number of pixelsSimilarly, the y and fy scales support asymmetric insets with:insetTop - insets the top of the default range by the specified number of pixelsinsetBottom - insets the bottom of the default range by the specified number of pixelsThe inset scale options can provide “breathing room” to separate marks from axes or the plot’s edge. For example, in a scatterplot with a Plot.dot with the default 3-pixel radius and 1.5-pixel stroke width, an inset of 5 pixels prevents dots from overlapping with the axes. The scale.round option is useful for crisp edges by rounding to the nearest pixel boundary.In addition to the generic ordinal scale type, which requires an explicit output range value for each input domain value, Plot supports special point and band scale types for encoding ordinal data as position. These scale types accept a [min, max] range similar to quantitative scales, and divide this continuous interval into discrete points or bands based on the number of distinct values in the domain (i.e., the domain’s cardinality). If the associated marks have no effective width along the ordinal dimension — such as a dot, rule, or tick — then use a point scale; otherwise, say for a bar, use a band scale.Ordinal position scales support additional options, all specified as proportions in [0, 1]:padding - how much of the range to reserve to inset first and last point or bandalign - where to distribute points or bands (0 = at start, 0.5 = at middle, 1 = at end)For a band scale, you can further fine-tune padding:paddingInner - how much of the range to reserve to separate adjacent bandspaddingOuter - how much of the range to reserve to inset first and last bandAlign defaults to 0.5 (centered). Band scale padding defaults to 0.1 (10% of available space reserved for separating bands), while point scale padding defaults to 0.5 (the gap between the first point and the edge is half the distance of the gap between points, and likewise for the gap between the last point and the opposite edge). Note that rounding and mark insets (e.g., for bars and rects) also affect separation between adjacent marks.Plot implicitly generates an axis mark for position scales if one is not explicitly declared. (For more control, declare the axis mark explicitly.) The following axis mark options are also available as scale options, applying to the implicit axis:axis - the axis anchor: top, bottom (x or fx); left, right (y or fy); both; null to suppressticks - the approximate number of ticks to generate, or interval, or array of valuestickSpacing - the approximate number of pixels between ticks (if ticks is not specified)tickSize - the length of each tick (in pixels; default 6 for x and y, or 0 for fx and fy)tickPadding - the separation between the tick and its label (in pixels; default 3)tickFormat - either a function or specifier string to format tick values; see FormatstickRotate - whether to rotate tick labels (an angle in degrees clockwise; default 0)fontVariant - the font-variant attribute; defaults to tabular-nums if quantitativelabel - a string to label the axislabelAnchor - the label anchor: top, right, bottom, left, or centerlabelArrow - the label arrow: auto (default), up, right, down, left, none, or true ^0.6.7labelOffset - the label position offset (in pixels; default depends on margins and orientation)ariaLabel - a short label representing the axis in the accessibility treeariaDescription - a textual description for the axisFor an implicit grid mark, use the grid option. For an implicit frame mark along one edge of the frame, use the line option.grid - whether to draw grid lines across the plot for each tickline - if true, draw the axis line (only for x and y)Top-level options are also supported as shorthand: grid (for x and y only; see facets), label, axis, inset, round, align, and padding. If the grid option is true, show a grid using currentColor; if specified as a string, show a grid with the specified color; if an approximate number of ticks, an interval, or an array of tick values, show corresponding grid lines.Sort mark option ^0.2.0 ​If an ordinal scale’s domain is not set, it defaults to natural ascending order; to order the domain by associated values in another dimension, either compute the domain manually (consider d3.groupSort) or use an associated mark’s sort option. For example, to sort bars by ascending frequency rather than alphabetically by letter:jsPlot.barY(alphabet, {x: "letter", y: "frequency", sort: {x: "y"}})The sort option is an object whose keys are ordinal scale names, such as x or fx, and whose values are mark channel names, such as y, y1, or y2. By specifying an existing channel rather than a new value, you avoid repeating the order definition and can refer to channels derived by transforms (such as stack or bin). When sorting the x domain, if no x channel is defined, x2 will be used instead if available, and similarly for y and y2; this is useful for marks that implicitly stack such as area, bar, and rect. A sort value may also be specified as width or height ^0.4.2, representing derived channels |x2 - x1| and |y2 - y1| respectively.Note that there may be multiple associated values in the secondary dimension for a given value in the primary ordinal dimension. The secondary values are therefore grouped for each associated primary value, and each group is then aggregated by applying a reducer. The default reducer is max, but may be changed by specifying the reduce option. Lastly the primary values are by default sorted based on the associated reduced value in natural ascending order to produce the domain. The above code is shorthand for:jsPlot.barY(alphabet, {x: "letter", y: "frequency", sort: {x: "y", reduce: "max", order: "ascending"}})Generally speaking, a reducer only needs to be specified when there are multiple secondary values for a given primary value. See the group transform for the list of supported reducers.For descending rather than ascending order, set the order option to descending:jsPlot.barY(alphabet, {x: "letter", y: "frequency", sort: {x: "y", order: "descending"}})Alternatively, the -channel shorthand option, which changes the default order to descending:jsPlot.barY(alphabet, {x: "letter", y: "frequency", sort: {x: "-y"}})Setting order to null will disable sorting, preserving the order of the data. (When an aggregating transform is used, such as group or bin, note that the data may already have been sorted and thus the order may differ from the input data.)Alternatively, set the reverse option to true. This produces a different result than descending order for null or unorderable values: descending order puts nulls last, whereas reversed ascending order puts nulls first.jsPlot.barY(alphabet, {x: "letter", y: "frequency", sort: {x: "y", reverse: true}})An additional limit option truncates the domain to the first n values after ordering. If limit is negative, the last n values are used instead. Hence, a positive limit with reverse = true will return the top n values in descending order. If limit is an array [lo, hi], the ith values with lo ≤ i < hi will be selected. (Note that like the basic filter transform, limiting the x domain here does not affect the computation of the y domain, which is computed independently without respect to filtering.)jsPlot.barY(alphabet, {x: "letter", y: "frequency", sort: {x: "y", limit: 5}})If different sort options are needed for different ordinal scales, the channel name can be replaced with a value object with additional per-scale options.jsPlot.barY(alphabet, {x: "letter", y: "frequency", sort: {x: {value: "y", order: "descending"}}})If the input channel is data, then the reducer is passed groups of the mark’s data; this is typically used in conjunction with a custom reducer function, as when the built-in single-channel reducers are insufficient.Note: when the value of the sort option is a string or a function, it is interpreted as a mark sort transform. To use both sort options and a mark sort transform, use Plot.sort.scale(options) ^0.4.0 ​You can also create a standalone scale with Plot.scale(options). The options object must define at least one scale; see Scale options for how to define a scale. For example, here is a categorical color scale with the Tableau10 color scheme and a domain of fruits:jsconst color = Plot.scale({color: {scheme: "Tableau10", domain: ["apple", "orange", "pear"]}});Both plot.scale and Plot.scale return scale objects. These objects represent the actual (or “materialized”) scale options used by Plot, including the domain, range, interpolate function, etc. The scale’s label, if any, is also returned; however, note that other axis properties are not currently exposed. Point and band scales also expose their materialized bandwidth and step.jscolor.domain // ["apple", "orange", "pear"]For convenience, scale objects expose a scale.apply(input) method which returns the scale’s output for the given input value. When applicable, scale objects also expose a scale.invert(output) method which returns the corresponding input value from the scale’s domain for the given output value.jscolor.apply("apple") // "#4e79a7"To apply a standalone scale object to a plot, pass it to Plot.plot as the corresponding scale options, such as color:jsPlot.cellX(["apple", "apple", "orange", "pear", "orange"]).plot({color})As another example, below are two plots with different options where the second plot uses the color scale from the first plot:jsconst plot1 = Plot.plot({...options1});
const plot2 = Plot.plot({...options2, color: plot1.scale("color")});\n\nSearchK0.6.17GitHub️ 4.6kOn this pageScales ​Scales convert an abstract value such as time or temperature to a visual value such as x→ or y↑ position or color. For example, say we have a dataset (gistemp) containing monthly observations of global average surface temperature from 1880 to 2016, represented as the “anomaly” (or difference) relative to the 1951–1980 average. The first few rows are:DateAnomaly1880-01-01-0.31880-02-01-0.211880-03-01-0.181880-04-01-0.271880-05-01-0.141880-06-01-0.29When visualizing this data with a line, the x scale is responsible for mapping dates to horizontal↔︎ positions. For example, 1880-01-01 might be mapped to x = 40 (on the left) and 2016-12-01 might be mapped to x = 620 (on the right). Likewise, the y scale maps temperature anomalies to vertical↕︎ positions.ForkjsPlot.lineY(gistemp, {x: "Date", y: "Anomaly"}).plot()In Plot, the mark binds channels to scales; for example, the line’s x channel is bound to the x scale. The channel name and the scale name are often the same, but not always; for example, an area’s y1 and y2 channels are both bound to the y scale. (You can opt-out of a scale for a particular channel using scale overrides if needed.)Think of a scale as a function that takes an abstract value and returns the corresponding visual value. For the y scale above, that might look like this:jsfunction y(anomaly) {
  const t = (anomaly - minAnomaly) / (maxAnomaly - minAnomaly); // t in [0, 1]
  return height - marginBottom - t * (height - marginTop - marginBottom);
}The function y depends on a few additional details: the chart’s size and margins, and the minimum and maximum temperatures in the data:jsconst marginTop = 20;
const marginBottom = 30;
const height = 400;
const minAnomaly = d3.min(gistemp, (d) => d.Anomaly);
const maxAnomaly = d3.max(gistemp, (d) => d.Anomaly);Scales aren’t limited to horizontal and vertical position. They can also output to color, radius, length, opacity, and more. For example if we switch to a rule and use the stroke channel instead of y, we get a one-dimensional heatmap:ForkjsPlot.ruleX(gistemp, {x: "Date", stroke: "Anomaly"}).plot()While the resulting chart looks different, the color scale here behaves similarly to the y function above — the only difference is that it interpolates colors (using d3.interpolateTurbo) instead of numbers (the top and bottom sides of the plot frame):jsfunction color(anomaly) {
  const t = (anomaly - minAnomaly) / (maxAnomaly - minAnomaly); // t in [0, 1]
  return d3.interpolateTurbo(t);
}Within a given plot, marks share scales. For example, if a plot has two line marks, such as the lines below visualizing the daily closing price of Google and Apple stock, both share the same x and y scales for a consistent encoding.ForkjsPlot.plot({
  marks: [
    Plot.ruleY([0]),
    Plot.lineY(goog, {x: "Date", y: "Close", stroke: "red"}),
    Plot.lineY(aapl, {x: "Date", y: "Close", stroke: "blue"})
  ]
})TIPWhen comparing the performance of different stocks, we typically want to normalize the return relative to a purchase price; see the normalize transform for an example. Also, not that we recommend them, but if you are interested in dual-axis charts, please upvote #147.Plot has many different scales; we categorize them by their input (domain) and output (range).The domain is the abstract values that the scale expects as input. For quantitative or temporal data, it is typically expressed as an extent such as [start, end], [cold, hot], or [min, max]. For ordinal or nominal data, it is an array of values such as names or categories. The type of input values corresponds to the type scale option (e.g., linear or ordinal).The range is the visual values that the scale generates as output. For position scales, it is typically an extent such as [left, right] or [bottom, top]; for color scales, it might be a continuous extent [blue, red] or an array of discrete colors. The type of values that a scale outputs corresponds to the name of the scale (e.g., x or color).Let’s look at some examples to make this less abstract.Continuous scales ​The domain of a quantitative scale is a continuous extent [min, max] where min and max are numbers, such as temperatures. Below, the first domain value (x = 0) corresponds to the left side of the plot while the second (x = 100) corresponds to the right side.ForkjsPlot.plot({x: {domain: [0, 100], grid: true}})Flipping the domain reverses the scale so that +x points ←left instead of right→.ForkjsPlot.plot({x: {domain: [100, 0], grid: true}})Alternatively, use the reverse option; this is convenient when the domain is implied from data rather than specified explicitly.ForkjsPlot.plot({x: {domain: [0, 100], reverse: true, grid: true}})If the domain is dates, Plot will default to a UTC scale. This is a linear scale with ticks based on the Gregorian calendar.ForkjsPlot.plot({x: {domain: [new Date("2021-01-01"), new Date("2022-01-01")], grid: true}})To force a UTC scale, say when the data is milliseconds since UNIX epoch rather than Date instances, pass utc as the type option. Though we recommend coercing strings and numbers to more specific types when you load data, rather than relying on scales to do it.ForkjsPlot.plot({x: {type: "utc", domain: [1609459200000, 1640995200000], grid: true}})If the scale type is time, the ticks will be in local time — as with the dates below — rather than UTC.ForkjsPlot.plot({x: {type: "time", domain: [new Date(2021, 0, 1), new Date(2022, 0, 1)], grid: true}})When plotting values that vary widely, such as the luminosity of stars in an HR diagram, a log scale may improve readability. Log scales default to base-10 ticks with SI-prefix notation.ForkjsPlot.plot({x: {type: "log", domain: [1e0, 1e5], grid: true}})If you prefer conventional notation, you can specify the tickFormat option to change the behavior of the axis. The tickFormat option can either be a d3.format string or a function that takes a tick value and returns the corresponding string. Note, however, that this may result in overlapping text.ForkjsPlot.plot({x: {type: "log", domain: [1e0, 1e5], tickFormat: ",", grid: true}})Log scales also support a base option, say for powers of two. This does not affect the scale’s encoding, but it does change where ticks are shown.ForkjsPlot.plot({x: {type: "log", base: 2, domain: [1e0, 1e4], ticks: 20, grid: true}})The domain of a log scale cannot include (or cross) zero; for this, consider a bi-symmetric log scale instead.ForkjsPlot.plot({x: {type: "symlog", domain: [-10, 10], grid: true}})Power scales and square-root scales are also supported. The pow scale supports the exponent option, which defaults to 1 (for a linear scale). The sqrt scale is shorthand for a pow scale with exponent 0.5.ForkjsPlot.plot({x: {type: "sqrt", domain: [0, 100], grid: true}})ForkjsPlot.plot({x: {type: "pow", exponent: 1 / 3, domain: [0, 100], grid: true}})Continuous scales also support a clamp option which, if true, clamps input values to the scale’s domain before scaling. This is useful for preventing marks from escaping the chart area.Continuous scales support an interpolate option specified either as a function that takes a single argument t in [0, 1] and returns the corresponding value from the range, or as a two-argument function that takes a pair of values [start, end] from the range and returns the corresponding interpolator from [0, 1], typically mapping 0 to start, and 1 to end.Continuous scales support a piecewise domain specified as an array of n domain values (with n greater than or equal to two), with a corresponding range having the same number of values; each segment of the domain is mapped to the matching segment of the range using the scale’s interpolator. When the domain has n > 2 elements and the range has two elements (for example, when using the default range on a x or y scale), the latter is automatically split into n − 1 segments of equal size. Note that in addition to the domain, you must specify the scale’s continuous type since a scale specified with a domain having more than two elements otherwise defaults to an ordinal scale. (You will often have to specify the ticks manually, too.) For an example, see the Polylinear axis notebook.Discrete scales ​Sadly, not all data is continuous: some data is merely ordinal, such as t-shirt sizes; and some categorical (a.k.a. nominal), such as brands of clothing. To encode such data as position, a point or band scale is required.A point scale divides space into uniformly-spaced discrete values. It is commonly used for scatterplots (a dot mark) of ordinal data. It is the default scale type for ordinal data on the x and y scale.ForkjsPlot.plot({x: {type: "point", domain: "ABCDEFGHIJ", grid: true}})A band scale divides space into uniformly-spaced and -sized discrete intervals. It is commonly used for bar charts (bar marks). To show the bands below, we use a cell instead of a grid.ForkjsPlot
  .cell("ABCDEFGHIJ", {x: Plot.identity, stroke: "currentColor", strokeOpacity: 0.1})
  .plot({x: {type: "band", domain: "ABCDEFGHIJ"}})While point and band scales appear visually similar when only the grid is visible, the two are not identical — they differ respective to padding. Play with the options below to get a sense of their effect on the scale’s behavior.Padding:0.10Align:0.50jsPlot.plot({
  grid: true,
  marginTop: 0.5,
  x: {
    padding,
    align,
    round: false
  },
  marks: [
    Plot.frame({strokeOpacity: 0.3}),
    Plot.tickX("ABCDEFGHIJ", {x: Plot.identity, stroke: "currentColor"})
  ]
})jsPlot.plot({
  grid: true,
  marginTop: 0.5,
  x: {
    padding,
    align,
    round: false
  },
  marks: [
    Plot.frame({strokeOpacity: 0.3}),
    Plot.cell("ABCDEFGHIJ", {x: Plot.identity, stroke: "currentColor"})
  ]
})Position scales also have a round option which forces the scale to snap to integer pixels. This defaults to true for point and band scales, and false for quantitative scales. Use caution with high-cardinality ordinal domains (i.e., a point or band scale used to encode many different values), as rounding can lead to “wasted” space or even zero-width bands.Color scales ​While position is the most salient (and important) encoding, color matters too! The default quantitative color scale type is linear, and the default scheme is turbo. A wide variety of sequential, diverging, and cyclical schemes are supported, including ColorBrewer and viridis. Color scheme: BluesGreensGreysPurplesRedsOrangesTurboViridisMagmaInfernoPlasmaCividisCubehelixWarmCoolBuGnBuPuGnBuOrRdPuBuGnPuBuPuRdRdPuYlGnBuYlGnYlOrBrYlOrRdRainbowSinebowjsPlot.plot({
  axis: null,
  padding: 0,
  color: {
    scheme: schemeq
  },
  marks: [
    Plot.cell(d3.range(40), {x: Plot.identity, fill: Plot.identity, inset: -0.5})
  ]
})You can implement a custom color scheme by specifying the scale’s range, or by passing an interpolate function that takes a parameter t in [0, 1]. The interpolate option can specify a color space such as rgb, or a two-argument function that takes a pair of values from the range. Color interpolate: rgblabhclhsld3.interpolateRgb.gamma(2)(t) => `hsl(${t * 360},100%,50%)`jsPlot.plot({
  axis: null,
  padding: 0,
  color: {
    type: "linear",
    ...interpolateq === "angry-rainbow"
      ? {interpolate: (t) => `hsl(${t * 360},100%,50%)`}
      : interpolateq === "rgb-gamma"
      ? {range: ["steelblue", "orange"], interpolate: d3.interpolateRgb.gamma(2)}
      : {range: ["steelblue", "orange"], interpolate: interpolateq}
  },
  marks: [
    Plot.cell(d3.range(40), {x: Plot.identity, fill: Plot.identity, inset: -0.5})
  ]
})And like position scales, you can apply a sqrt, pow, log, or symlog transform; these are often useful when working with non-uniformly distributed data.Diverging color scales are intended to show positive and negative values, or more generally values above or below some pivot value. Diverging color scales default to the RdBu (red–blue) color scheme. The pivot defaults to zero, but you can change it with the pivot option, which should ideally be a value near the middle of the domain. Color scheme: BrBGPRGnPiYGPuOrRdBuRdGyRdYlBuRdYlGnSpectralBuRdBuYlRdjsPlot.plot({
  axis: null,
  padding: 0,
  color: {
    type: "linear",
    scheme: schemed
  },
  marks: [
    Plot.cell(d3.range(40), {x: Plot.identity, fill: Plot.identity, inset: -0.5})
  ]
})Below we again show observed global surface temperatures. The reversed BuRd color scheme is used since blue and red are semantically associated with cold and hot, respectively.ForkjsPlot.plot({
  grid: true,
  color: {
    type: "diverging",
    scheme: "BuRd"
  },
  marks: [
    Plot.ruleY([0]),
    Plot.dot(gistemp, {x: "Date", y: "Anomaly", stroke: "Anomaly"})
  ]
})Plot also provides color schemes for discrete data. Use the categorical type for categorical (nominal) unordered data, and the ordinal type for ordered data. Color scheme: AccentCategory10Dark2Observable10PairedPastel1Pastel2Set1Set2Set3Tableau10BluesGreensGreysPurplesRedsOrangesTurboViridisMagmaInfernoPlasmaCividisCubehelixWarmCoolBuGnBuPuGnBuOrRdPuBuGnPuBuPuRdRdPuYlGnBuYlGnYlOrBrYlOrRdRainbowSinebowjsPlot.plot({
  color: {
    type: "ordinal",
    scheme: schemeo
  },
  marks: [
    Plot.cell("ABCDEFGHIJ", {x: Plot.identity, fill: Plot.identity})
  ]
})CAUTIONDiscrete color schemes are intended for data that has only a few unique values. If the size of the categorical domain exceeds the number of colors in the scheme, colors will be reused; combining values into an “other” category is recommended.Other scales ​But wait, there’s more! 😅 Plot has opacity, r, symbol, and length scales, too. For example, the r scale type defaults to sqrt such that when used with the dot mark, the resulting area is proportional to the r channel value. You can adjust the effective dot size by specifying an explicit range, as below. Radius: 8.0ForkjsPlot.plot({
  r: {range: [0, radius]},
  marks: [
    Plot.dot(d3.range(1, 11), {x: Plot.identity, r: Plot.identity, fill: "currentColor"})
  ]
})The default range for the associated r scale is constructed such that a zero value maps to zero for an accurate areal encoding, while the first quartile of values is mapped to a radius of three pixels; this tends to be more stable with varying data.Type inference ​Plot strives to be concise: rather than you laboriously specifying everything, Plot can guess by inspecting the data so you don’t have to set the type, domain, and range (and for color, scheme) of scales explicitly. But for Plot’s guesses to be accurate, your data must match Plot’s expectations. Here they are.A scale’s type is most often inferred from associated marks’ channel values: strings and booleans imply an ordinal scale; dates imply a utc scale; anything else is linear. Plot assumes that your data is consistently typed, so inference is based solely on the first non-null, non-undefined value. We recommend typed CSV (passing {typed: true} to Observable’s FileAttachment csv method) or explicitly coercing types when loading data (e.g., d3.autoType).If a scale’s domain is specified explicitly, the scale’s type is inferred from the domain values rather than channels as described above. However, if the domain or range has more than two elements, the ordinal type (or point for position scales) is used.Finally, some marks declare the scale type for associated channels. For example, barX requires y to be a band scale. Further, the facet scales fx and fy are always band scales, and the r (radius) scale is implicitly a sqrt scale.If you don’t specify a quantitative scale’s domain, it is the extent (minimum and maximum) of associated channel values, except for the r (radius) scale where it goes from zero to the maximum. A quantitative domain can be extended to “nice” human-readable values with the nice option. For an ordinal scale, the domain defaults to the sorted union (all distinct values in natural order) of associated values; see the sort mark option to change the order.All position scales (x, y, fx, and fy) have implicit automatic ranges based on the chart dimensions. The x scale ranges from the left to right edge, while the y scale ranges from the bottom to top edge, accounting for margins.Scale transforms ​The transform scale option allows you to apply a function to all values before they are passed through the scale. This is convenient for transforming a scale’s data, say to convert to thousands or between temperature units.ForkjsPlot.plot({
  y: {
    grid: true,
    label: "Temperature (°C)",
    transform: (f) => (f - 32) * (5 / 9) // convert Fahrenheit to Celsius
  },
  marks: [
    Plot.ruleY([32]), // 32°F
    Plot.lineY(sftemp, Plot.windowY(7, {x: "date", y: "high"}))
  ]
})The percent scale option is shorthand for a transform that multiplies values by 100; it also adds a percent symbol (%) to the default label.ForkjsPlot.plot({
  y: {percent: true}, // convert proportion [0, 1] to percent [0, 100]
  color: {scheme: "BuRd"},
  marks: [
    Plot.rectY(gistemp, Plot.binX({y: "proportion", fill: "x"}, {x: "Anomaly", fill: "Anomaly"})),
    Plot.ruleY([0])
  ]
})CAUTIONMark transforms typically consume values before they are passed through scales (e.g., when binning). In this case the mark transforms will see the values prior to the scale transform as input, and the scale transform will apply to the output of the mark transform.The interval scale option ^0.5.1 sets an ordinal scale’s domain to the start of every interval within the extent of the data. In addition, it implicitly sets the transform of the scale to interval.floor, rounding values down to the start of each interval. For example, below we generate a time-series bar chart; when an interval is specified, missing days are visible. Use interval: ForkjsPlot.plot({
  marginBottom: 80,
  x: {
    tickRotate: -90,
    interval: intervaled ? "day" : null,
    label: null
  },
  y: {
    transform: (d) => d / 1e6,
    label: "Daily trade volume (millions)"
  },
  marks: [
    Plot.barY(aapl.slice(-40), {x: "Date", y: "Volume"}),
    Plot.ruleY([0])
  ]
})TIPAs an added bonus, the fontVariant and type options are no longer needed because Plot now understands that the x scale, despite being ordinal, represents daily observations.While the example above relies on the interval being promoted to the scale’s transform, the stack, bin, and group transforms are also interval-aware: they apply the scale’s interval, if any, before grouping values. (This results in the interval being applied twice, both before and after the mark transform, but the second application has no effect since interval application is idempotent.)The interval option can also be used for quantitative and temporal scales. This enforces uniformity, say rounding timed observations down to the nearest hour, which may be helpful for the stack transform among other uses.Scale options ​Each scale’s options are specified as a nested options object with the corresponding scale name within the top-level plot options:x - horizontal positiony - vertical positionr - radius (size)color - fill or strokeopacity - fill or stroke opacitylength - linear length (for vectors)symbol - categorical symbol (for dots)For example, to set the domain for the x scale:jsPlot.plot({x: {domain: [new Date("1880-01-01"), new Date("2016-11-01")]}})Plot supports many scale types. Some scale types are for quantitative data: values that can be added or subtracted, such as temperature or time. Other scale types are for ordinal or categorical data: unquantifiable values that can only be ordered, such as t-shirt sizes, or values with no inherent order that can only be tested for equality, such as types of fruit. Some scale types are further intended for specific visual encodings: for example, as position or color.You can set the scale type explicitly via the type scale option, though typically the scale type is inferred automatically. Some marks mandate a particular scale type: for example, barY requires that the x scale is a band scale. Some scales have a default type: for example, the r (radius) scale defaults to sqrt and the opacity scale defaults to linear. Most often, the scale type is inferred from associated data, pulled either from the domain (if specified) or from associated channels. Strings and booleans imply an ordinal scale; dates imply a UTC scale; and anything else is linear. Unless they represent text, we recommend explicitly converting strings to more specific types when loading data (e.g., with d3.autoType or Observable’s FileAttachment). For simplicity’s sake, Plot assumes that data is consistently typed; type inference is based solely on the first non-null, non-undefined value.For quantitative data (i.e. numbers), a mathematical transform may be applied to the data by changing the scale type:linear (default) - linear transform (translate and scale)pow - power (exponential) transformsqrt - square-root transform (pow transform with exponent = 0.5)log - logarithmic transformsymlog - bi-symmetric logarithmic transform per Webber et al.The appropriate transform depends on the data’s distribution and what you wish to know. A sqrt transform exaggerates differences between small values at the expense of large values; it is a special case of the pow transform which has a configurable scale.exponent (0.5 for sqrt). A log transform is suitable for comparing orders of magnitude and can only be used when the domain does not include zero. The base defaults to 10 and can be specified with the scale.base option; note that this only affects the axis ticks and not the scale’s behavior. A symlog transform is more elaborate, but works well with wide-range values that include zero; it can be configured with the scale.constant option (default 1).For temporal data (i.e. dates), two variants of a linear scale are also supported:utc (default, recommended) - UTC timetime - local timeUTC is recommended over local time as charts in UTC time are guaranteed to appear consistently to all viewers whereas charts in local time will depend on the viewer’s time zone. Due to limitations in JavaScript’s Date class, Plot does not yet support an explicit time zone other than UTC.For ordinal data (e.g., strings), use the ordinal scale type or the point or band position scale types. The categorical scale type is also supported; it is equivalent to ordinal except as a color scale, where it provides a different default color scheme. (Since position is inherently ordinal or even quantitative, categorical data must be assigned an effective order when represented as position, and hence categorical and ordinal may be considered synonymous in context.)You can opt-out of a scale using the identity scale type. This is useful if you wish to specify literal colors or pixel positions within a mark channel rather than relying on the scale to convert abstract values into visual values. For position scales (x and y), an identity scale is still quantitative and may produce an axis, yet unlike a linear scale the domain and range are fixed based on the plot layout.TIPTo opt-out of a scale for a single channel, you can specify the channel values as a {value, scale} object; see mark options.Quantitative scales, as well as identity position scales, coerce channel values to numbers; both null and undefined are coerced to NaN. Similarly, time scales coerce channel values to dates; numbers are assumed to be milliseconds since UNIX epoch, while strings are assumed to be in ISO 8601 format.A scale’s domain (the extent of its inputs, abstract values) and range (the extent of its outputs, visual values) are typically inferred automatically. You can set them explicitly using these options:domain - typically [min, max], or an array of ordinal or categorical valuesrange - typically [min, max], or an array of ordinal or categorical valuesunknown - the desired output value (defaults to undefined) for invalid input valuesreverse - reverses the domain (or the range), say to flip the chart along x or yinterval - an interval or time interval (for interval data; see below)For most quantitative scales, the default domain is the [min, max] of all values associated with the scale. For the radius and opacity scales, the default domain is [0, max] to ensure a meaningful value encoding. For ordinal scales, the default domain is the set of all distinct values associated with the scale in natural ascending order; for a different order, set the domain explicitly or add a sort option to an associated mark. For threshold scales, the default domain is [0] to separate negative and non-negative values. For quantile scales, the default domain is the set of all defined values associated with the scale. If a scale is reversed, it is equivalent to setting the domain as [max, min] instead of [min, max].The default range depends on the scale: for position scales (x, y, fx, and fy), the default range depends on the plot’s size and margins. For color scales, there are default color schemes for quantitative, ordinal, and categorical data. For opacity, the default range is [0, 1]. And for radius, the default range is designed to produce dots of “reasonable” size assuming a sqrt scale type for accurate area representation: zero maps to zero, the first quartile maps to a radius of three pixels, and other values are extrapolated. This convention for radius ensures that if the scale’s data values are all equal, dots have the default constant radius of three pixels, while if the data varies, dots will tend to be larger.The behavior of the unknown scale option depends on the scale type. For quantitative and temporal scales, the unknown value is used whenever the input value is undefined, null, or NaN. For ordinal or categorical scales, the unknown value is returned for any input value outside the domain. For band or point scales, the unknown option has no effect; it is effectively always equal to undefined. If the unknown option is set to undefined (the default), or null or NaN, then the affected input values will be considered undefined and filtered from the output.For data at regular intervals, such as integer values or daily samples, the interval option can be used to enforce uniformity. The specified interval — such as d3.utcMonth — must expose an interval.floor(value), interval.offset(value), and interval.range(start, stop) functions. The option can also be specified as a number, in which case it will be promoted to a numeric interval with the given step. The option can alternatively be specified as a string (second, minute, hour, day, week, month, quarter, half, year, monday, tuesday, wednesday, thursday, friday, saturday, sunday) ^0.6.2 naming the corresponding time interval, or a skip interval consisting of a number followed by the interval name (possibly pluralized), such as 3 months or 10 years. This option sets the default scale.transform to the given interval’s interval.floor function. In addition, the default scale.domain is an array of uniformly-spaced values spanning the extent of the values associated with the scale.Quantitative scales can be further customized with additional options:clamp - if true, clamp input values to the scale’s domainnice - if true (or a tick count), extend the domain to nice round valueszero - if true, extend the domain to include zero if neededpercent - if true, transform proportions in [0, 1] to percentages in [0, 100]Clamping is typically used in conjunction with setting an explicit domain since if the domain is inferred, no values will be outside the domain. Clamping is useful for focusing on a subset of the data while ensuring that extreme values remain visible, but use caution: clamped values may need an annotation to avoid misinterpretation. Top-level clamp, nice, and zero options are supported as shorthand for setting the respective option on all scales.The transform option allows you to apply a function to all values before they are passed through the scale. This is convenient for transforming a scale’s data, say to convert to thousands or between temperature units.jsPlot.plot({
  y: {
    label: "Temperature (°F)",
    transform: (f) => f * 9 / 5 + 32 // convert Celsius to Fahrenheit
  },
  marks: …
})Color scale options ​The normal scale types — linear, sqrt, pow, log, symlog, and ordinal — can be used to encode color. In addition, Plot supports special scale types for color:categorical - like ordinal, but defaults to observable10sequential - like linearcyclical - like linear, but defaults to rainbowthreshold - discretizes using thresholds given as the domain; defaults to rdylbuquantile - discretizes by computing quantile thresholds; defaults to rdylbuquantize - discretizes by computing uniform thresholds; defaults to rdylbu ^0.4.3diverging - like linear, but with a pivot; defaults to rdbudiverging-log - like log, but with a pivot that defaults to 1; defaults to rdbudiverging-pow - like pow, but with a pivot; defaults to rdbudiverging-sqrt - like sqrt, but with a pivot; defaults to rdbudiverging-symlog - like symlog, but with a pivot; defaults to rdbuFor a threshold scale, the domain represents n (typically numeric) thresholds which will produce a range of n + 1 output colors; the ith color of the range applies to values that are smaller than the ith element of the domain and larger or equal to the i - 1th element of the domain. For a quantile scale, the domain represents all input values to the scale, and the n option specifies how many quantiles to compute from the domain; n quantiles will produce n - 1 thresholds, and an output range of n colors. For a quantize scale, the domain will be transformed into approximately n quantized values, where n is an option that defaults to 5.By default, all diverging color scales are symmetric around the pivot; set symmetric to false if you want to cover the whole extent on both sides.Color scales support two additional options:scheme - a named color scheme in lieu of a range, such as redsinterpolate - in conjunction with a range, how to interpolate colorsFor quantile and quantize color scales, the scheme option is used in conjunction with n, which determines how many quantiles or quantized values to compute, and thus the number of elements in the scale’s range; it defaults to 5 (for quintiles in the case of a quantile scale).The following sequential scale schemes are supported for both quantitative and ordinal data:jsPlot.plot({
  width: 322,
  height: 25 * 27,
  margin: 0,
  marginRight: 70,
  padding: 0,
  x: {axis: null},
  y: {axis: "right", tickSize: 0},
  color: {type: "identity"},
  marks: [
    Plot.cell([
      ["Blues", d3.interpolateBlues],
      ["Greens", d3.interpolateGreens],
      ["Greys", d3.interpolateGreys],
      ["Purples", d3.interpolatePurples],
      ["Reds", d3.interpolateReds],
      ["Oranges", d3.interpolateOranges],
      ["Turbo", d3.interpolateTurbo],
      ["Viridis", d3.interpolateViridis],
      ["Magma", d3.interpolateMagma],
      ["Inferno", d3.interpolateInferno],
      ["Plasma", d3.interpolatePlasma],
      ["Cividis", d3.interpolateCividis],
      ["Cubehelix", d3.interpolateCubehelixDefault],
      ["Warm", d3.interpolateWarm],
      ["Cool", d3.interpolateCool],
      ["BuGn", d3.interpolateBuGn],
      ["BuPu", d3.interpolateBuPu],
      ["GnBu", d3.interpolateGnBu],
      ["OrRd", d3.interpolateOrRd],
      ["PuBuGn", d3.interpolatePuBuGn],
      ["PuBu", d3.interpolatePuBu],
      ["PuRd", d3.interpolatePuRd],
      ["RdPu", d3.interpolateRdPu],
      ["YlGnBu", d3.interpolateYlGnBu],
      ["YlGn", d3.interpolateYlGn],
      ["YlOrBr", d3.interpolateYlOrBr],
      ["YlOrRd", d3.interpolateYlOrRd],
    ].flatMap(([name, i]) => d3.ticks(0, 1, 20).map((t) => [t, name, String(i(t))])), {fill: "2", insetTop: 0.5, insetBottom: 0.5})
  ]
})The default color scheme, turbo, was chosen primarily to ensure high-contrast visibility. Color schemes such as blues make low-value marks difficult to see against a white background, for better or for worse. To use a subset of a continuous color scheme (or any single-argument interpolate function), set the scale.range property to the corresponding subset of [0, 1]; for example, to use the first half of the rainbow color scheme, use a range of [0, 0.5]. By default, the full range [0, 1] is used. If you wish to encode a quantitative value without hue, consider using opacity rather than color (e.g., use Plot.dot’s strokeOpacity instead of stroke).The following diverging scale schemes are supported:jsPlot.plot({
  width: 322,
  height: 25 * 11,
  margin: 0,
  marginRight: 70,
  padding: 0,
  x: {axis: null},
  y: {axis: "right", tickSize: 0},
  color: {type: "identity"},
  marks: [
    Plot.cell([
      ["BrBG", d3.interpolateBrBG],
      ["PRGn", d3.interpolatePRGn],
      ["PiYG", d3.interpolatePiYG],
      ["PuOr", d3.interpolatePuOr],
      ["RdBu", d3.interpolateRdBu],
      ["RdGy", d3.interpolateRdGy],
      ["RdYlBu", d3.interpolateRdYlBu],
      ["RdYlGn", d3.interpolateRdYlGn],
      ["Spectral", d3.interpolateSpectral],
      ["BuRd", (t) => d3.interpolateRdBu(1 - t)],
      ["BuYlRd", (t) => d3.interpolateRdYlBu(1 - t)],
    ].flatMap(([name, i]) => d3.ticks(0, 1, 30).map((t) => [t, name, String(i(t))])), {fill: "2", insetTop: 0.5, insetBottom: 0.5})
  ]
})Picking a diverging color scheme name defaults the scale type to diverging; set the scale type to linear to treat the color scheme as sequential instead. Diverging color scales support a scale.pivot option, which defaults to zero. Values below the pivot will use the lower half of the color scheme (e.g., reds for the rdgy scheme), while values above the pivot will use the upper half (grays for rdgy).The following cylical color schemes are supported:jsPlot.plot({
  width: 322,
  height: 25 * 2,
  margin: 0,
  marginRight: 70,
  padding: 0,
  x: {axis: null},
  y: {axis: "right", tickSize: 0},
  color: {type: "identity"},
  marks: [
    Plot.cell([
      ["rainbow", d3.interpolateRainbow],
      ["sinebow", d3.interpolateSinebow],
    ].flatMap(([name, i]) => d3.ticks(0, 1, 30).map((t) => [t, name, String(i(t))])), {fill: "2", insetTop: 0.5, insetBottom: 0.5})
  ]
})The following categorical color schemes are supported:jsPlot.plot({
  width: 322,
  height: 25 * 10,
  margin: 0,
  marginRight: 70,
  padding: 0,
  x: {axis: null},
  y: {axis: "right", tickSize: 0},
  color: {type: "identity"},
  marks: [
    Plot.cell([
      ["Accent", d3.schemeAccent],
      ["Category10", d3.schemeCategory10],
      ["Dark2", d3.schemeDark2],
      ["Observable10", Plot.scale({color: {type: "categorical"}}).range],
      ["Paired", d3.schemePaired],
      ["Pastel1", d3.schemePastel1],
      ["Pastel2", d3.schemePastel2],
      ["Set1", d3.schemeSet1],
      ["Set2", d3.schemeSet2],
      ["Set3", d3.schemeSet3],
      ["Tableau10", d3.schemeTableau10],
    ].flatMap(([name, scheme]) => scheme.map((s, i) => [i, name, s])), {fill: "2", inset: 0.5})
  ]
})The following color interpolators are supported:rgb - RGB (red, green, blue)hsl - HSL (hue, saturation, lightness)lab - CIELAB (a.k.a. “Lab”)hcl - CIELChab (a.k.a. “LCh” or “HCL”)Position scale options ​The position scales (x, y, fx, and fy) support additional options:inset - inset the default range by the specified amount in pixelsround - round the output value to the nearest integer (whole pixel)The x and fx scales support asymmetric insets for more precision. Replace inset by:insetLeft - insets the start of the default range by the specified number of pixelsinsetRight - insets the end of the default range by the specified number of pixelsSimilarly, the y and fy scales support asymmetric insets with:insetTop - insets the top of the default range by the specified number of pixelsinsetBottom - insets the bottom of the default range by the specified number of pixelsThe inset scale options can provide “breathing room” to separate marks from axes or the plot’s edge. For example, in a scatterplot with a Plot.dot with the default 3-pixel radius and 1.5-pixel stroke width, an inset of 5 pixels prevents dots from overlapping with the axes. The scale.round option is useful for crisp edges by rounding to the nearest pixel boundary.In addition to the generic ordinal scale type, which requires an explicit output range value for each input domain value, Plot supports special point and band scale types for encoding ordinal data as position. These scale types accept a [min, max] range similar to quantitative scales, and divide this continuous interval into discrete points or bands based on the number of distinct values in the domain (i.e., the domain’s cardinality). If the associated marks have no effective width along the ordinal dimension — such as a dot, rule, or tick — then use a point scale; otherwise, say for a bar, use a band scale.Ordinal position scales support additional options, all specified as proportions in [0, 1]:padding - how much of the range to reserve to inset first and last point or bandalign - where to distribute points or bands (0 = at start, 0.5 = at middle, 1 = at end)For a band scale, you can further fine-tune padding:paddingInner - how much of the range to reserve to separate adjacent bandspaddingOuter - how much of the range to reserve to inset first and last bandAlign defaults to 0.5 (centered). Band scale padding defaults to 0.1 (10% of available space reserved for separating bands), while point scale padding defaults to 0.5 (the gap between the first point and the edge is half the distance of the gap between points, and likewise for the gap between the last point and the opposite edge). Note that rounding and mark insets (e.g., for bars and rects) also affect separation between adjacent marks.Plot implicitly generates an axis mark for position scales if one is not explicitly declared. (For more control, declare the axis mark explicitly.) The following axis mark options are also available as scale options, applying to the implicit axis:axis - the axis anchor: top, bottom (x or fx); left, right (y or fy); both; null to suppressticks - the approximate number of ticks to generate, or interval, or array of valuestickSpacing - the approximate number of pixels between ticks (if ticks is not specified)tickSize - the length of each tick (in pixels; default 6 for x and y, or 0 for fx and fy)tickPadding - the separation between the tick and its label (in pixels; default 3)tickFormat - either a function or specifier string to format tick values; see FormatstickRotate - whether to rotate tick labels (an angle in degrees clockwise; default 0)fontVariant - the font-variant attribute; defaults to tabular-nums if quantitativelabel - a string to label the axislabelAnchor - the label anchor: top, right, bottom, left, or centerlabelArrow - the label arrow: auto (default), up, right, down, left, none, or true ^0.6.7labelOffset - the label position offset (in pixels; default depends on margins and orientation)ariaLabel - a short label representing the axis in the accessibility treeariaDescription - a textual description for the axisFor an implicit grid mark, use the grid option. For an implicit frame mark along one edge of the frame, use the line option.grid - whether to draw grid lines across the plot for each tickline - if true, draw the axis line (only for x and y)Top-level options are also supported as shorthand: grid (for x and y only; see facets), label, axis, inset, round, align, and padding. If the grid option is true, show a grid using currentColor; if specified as a string, show a grid with the specified color; if an approximate number of ticks, an interval, or an array of tick values, show corresponding grid lines.Sort mark option ^0.2.0 ​If an ordinal scale’s domain is not set, it defaults to natural ascending order; to order the domain by associated values in another dimension, either compute the domain manually (consider d3.groupSort) or use an associated mark’s sort option. For example, to sort bars by ascending frequency rather than alphabetically by letter:jsPlot.barY(alphabet, {x: "letter", y: "frequency", sort: {x: "y"}})The sort option is an object whose keys are ordinal scale names, such as x or fx, and whose values are mark channel names, such as y, y1, or y2. By specifying an existing channel rather than a new value, you avoid repeating the order definition and can refer to channels derived by transforms (such as stack or bin). When sorting the x domain, if no x channel is defined, x2 will be used instead if available, and similarly for y and y2; this is useful for marks that implicitly stack such as area, bar, and rect. A sort value may also be specified as width or height ^0.4.2, representing derived channels |x2 - x1| and |y2 - y1| respectively.Note that there may be multiple associated values in the secondary dimension for a given value in the primary ordinal dimension. The secondary values are therefore grouped for each associated primary value, and each group is then aggregated by applying a reducer. The default reducer is max, but may be changed by specifying the reduce option. Lastly the primary values are by default sorted based on the associated reduced value in natural ascending order to produce the domain. The above code is shorthand for:jsPlot.barY(alphabet, {x: "letter", y: "frequency", sort: {x: "y", reduce: "max", order: "ascending"}})Generally speaking, a reducer only needs to be specified when there are multiple secondary values for a given primary value. See the group transform for the list of supported reducers.For descending rather than ascending order, set the order option to descending:jsPlot.barY(alphabet, {x: "letter", y: "frequency", sort: {x: "y", order: "descending"}})Alternatively, the -channel shorthand option, which changes the default order to descending:jsPlot.barY(alphabet, {x: "letter", y: "frequency", sort: {x: "-y"}})Setting order to null will disable sorting, preserving the order of the data. (When an aggregating transform is used, such as group or bin, note that the data may already have been sorted and thus the order may differ from the input data.)Alternatively, set the reverse option to true. This produces a different result than descending order for null or unorderable values: descending order puts nulls last, whereas reversed ascending order puts nulls first.jsPlot.barY(alphabet, {x: "letter", y: "frequency", sort: {x: "y", reverse: true}})An additional limit option truncates the domain to the first n values after ordering. If limit is negative, the last n values are used instead. Hence, a positive limit with reverse = true will return the top n values in descending order. If limit is an array [lo, hi], the ith values with lo ≤ i < hi will be selected. (Note that like the basic filter transform, limiting the x domain here does not affect the computation of the y domain, which is computed independently without respect to filtering.)jsPlot.barY(alphabet, {x: "letter", y: "frequency", sort: {x: "y", limit: 5}})If different sort options are needed for different ordinal scales, the channel name can be replaced with a value object with additional per-scale options.jsPlot.barY(alphabet, {x: "letter", y: "frequency", sort: {x: {value: "y", order: "descending"}}})If the input channel is data, then the reducer is passed groups of the mark’s data; this is typically used in conjunction with a custom reducer function, as when the built-in single-channel reducers are insufficient.Note: when the value of the sort option is a string or a function, it is interpreted as a mark sort transform. To use both sort options and a mark sort transform, use Plot.sort.scale(options) ^0.4.0 ​You can also create a standalone scale with Plot.scale(options). The options object must define at least one scale; see Scale options for how to define a scale. For example, here is a categorical color scale with the Tableau10 color scheme and a domain of fruits:jsconst color = Plot.scale({color: {scheme: "Tableau10", domain: ["apple", "orange", "pear"]}});Both plot.scale and Plot.scale return scale objects. These objects represent the actual (or “materialized”) scale options used by Plot, including the domain, range, interpolate function, etc. The scale’s label, if any, is also returned; however, note that other axis properties are not currently exposed. Point and band scales also expose their materialized bandwidth and step.jscolor.domain // ["apple", "orange", "pear"]For convenience, scale objects expose a scale.apply(input) method which returns the scale’s output for the given input value. When applicable, scale objects also expose a scale.invert(output) method which returns the corresponding input value from the scale’s domain for the given output value.jscolor.apply("apple") // "#4e79a7"To apply a standalone scale object to a plot, pass it to Plot.plot as the corresponding scale options, such as color:jsPlot.cellX(["apple", "apple", "orange", "pear", "orange"]).plot({color})As another example, below are two plots with different options where the second plot uses the color scale from the first plot:jsconst plot1 = Plot.plot({...options1});
const plot2 = Plot.plot({...options2, color: plot1.scale("color")});PagerPrevious pageMarksNext pageProjections\n\nScales ​Scales convert an abstract value such as time or temperature to a visual value such as x→ or y↑ position or color. For example, say we have a dataset (gistemp) containing monthly observations of global average surface temperature from 1880 to 2016, represented as the “anomaly” (or difference) relative to the 1951–1980 average. The first few rows are:DateAnomaly1880-01-01-0.31880-02-01-0.211880-03-01-0.181880-04-01-0.271880-05-01-0.141880-06-01-0.29When visualizing this data with a line, the x scale is responsible for mapping dates to horizontal↔︎ positions. For example, 1880-01-01 might be mapped to x = 40 (on the left) and 2016-12-01 might be mapped to x = 620 (on the right). Likewise, the y scale maps temperature anomalies to vertical↕︎ positions.ForkjsPlot.lineY(gistemp, {x: "Date", y: "Anomaly"}).plot()In Plot, the mark binds channels to scales; for example, the line’s x channel is bound to the x scale. The channel name and the scale name are often the same, but not always; for example, an area’s y1 and y2 channels are both bound to the y scale. (You can opt-out of a scale for a particular channel using scale overrides if needed.)Think of a scale as a function that takes an abstract value and returns the corresponding visual value. For the y scale above, that might look like this:jsfunction y(anomaly) {
  const t = (anomaly - minAnomaly) / (maxAnomaly - minAnomaly); // t in [0, 1]
  return height - marginBottom - t * (height - marginTop - marginBottom);
}The function y depends on a few additional details: the chart’s size and margins, and the minimum and maximum temperatures in the data:jsconst marginTop = 20;
const marginBottom = 30;
const height = 400;
const minAnomaly = d3.min(gistemp, (d) => d.Anomaly);
const maxAnomaly = d3.max(gistemp, (d) => d.Anomaly);Scales aren’t limited to horizontal and vertical position. They can also output to color, radius, length, opacity, and more. For example if we switch to a rule and use the stroke channel instead of y, we get a one-dimensional heatmap:ForkjsPlot.ruleX(gistemp, {x: "Date", stroke: "Anomaly"}).plot()While the resulting chart looks different, the color scale here behaves similarly to the y function above — the only difference is that it interpolates colors (using d3.interpolateTurbo) instead of numbers (the top and bottom sides of the plot frame):jsfunction color(anomaly) {
  const t = (anomaly - minAnomaly) / (maxAnomaly - minAnomaly); // t in [0, 1]
  return d3.interpolateTurbo(t);
}Within a given plot, marks share scales. For example, if a plot has two line marks, such as the lines below visualizing the daily closing price of Google and Apple stock, both share the same x and y scales for a consistent encoding.ForkjsPlot.plot({
  marks: [
    Plot.ruleY([0]),
    Plot.lineY(goog, {x: "Date", y: "Close", stroke: "red"}),
    Plot.lineY(aapl, {x: "Date", y: "Close", stroke: "blue"})
  ]
})TIPWhen comparing the performance of different stocks, we typically want to normalize the return relative to a purchase price; see the normalize transform for an example. Also, not that we recommend them, but if you are interested in dual-axis charts, please upvote #147.Plot has many different scales; we categorize them by their input (domain) and output (range).The domain is the abstract values that the scale expects as input. For quantitative or temporal data, it is typically expressed as an extent such as [start, end], [cold, hot], or [min, max]. For ordinal or nominal data, it is an array of values such as names or categories. The type of input values corresponds to the type scale option (e.g., linear or ordinal).The range is the visual values that the scale generates as output. For position scales, it is typically an extent such as [left, right] or [bottom, top]; for color scales, it might be a continuous extent [blue, red] or an array of discrete colors. The type of values that a scale outputs corresponds to the name of the scale (e.g., x or color).Let’s look at some examples to make this less abstract.Continuous scales ​The domain of a quantitative scale is a continuous extent [min, max] where min and max are numbers, such as temperatures. Below, the first domain value (x = 0) corresponds to the left side of the plot while the second (x = 100) corresponds to the right side.ForkjsPlot.plot({x: {domain: [0, 100], grid: true}})Flipping the domain reverses the scale so that +x points ←left instead of right→.ForkjsPlot.plot({x: {domain: [100, 0], grid: true}})Alternatively, use the reverse option; this is convenient when the domain is implied from data rather than specified explicitly.ForkjsPlot.plot({x: {domain: [0, 100], reverse: true, grid: true}})If the domain is dates, Plot will default to a UTC scale. This is a linear scale with ticks based on the Gregorian calendar.ForkjsPlot.plot({x: {domain: [new Date("2021-01-01"), new Date("2022-01-01")], grid: true}})To force a UTC scale, say when the data is milliseconds since UNIX epoch rather than Date instances, pass utc as the type option. Though we recommend coercing strings and numbers to more specific types when you load data, rather than relying on scales to do it.ForkjsPlot.plot({x: {type: "utc", domain: [1609459200000, 1640995200000], grid: true}})If the scale type is time, the ticks will be in local time — as with the dates below — rather than UTC.ForkjsPlot.plot({x: {type: "time", domain: [new Date(2021, 0, 1), new Date(2022, 0, 1)], grid: true}})When plotting values that vary widely, such as the luminosity of stars in an HR diagram, a log scale may improve readability. Log scales default to base-10 ticks with SI-prefix notation.ForkjsPlot.plot({x: {type: "log", domain: [1e0, 1e5], grid: true}})If you prefer conventional notation, you can specify the tickFormat option to change the behavior of the axis. The tickFormat option can either be a d3.format string or a function that takes a tick value and returns the corresponding string. Note, however, that this may result in overlapping text.ForkjsPlot.plot({x: {type: "log", domain: [1e0, 1e5], tickFormat: ",", grid: true}})Log scales also support a base option, say for powers of two. This does not affect the scale’s encoding, but it does change where ticks are shown.ForkjsPlot.plot({x: {type: "log", base: 2, domain: [1e0, 1e4], ticks: 20, grid: true}})The domain of a log scale cannot include (or cross) zero; for this, consider a bi-symmetric log scale instead.ForkjsPlot.plot({x: {type: "symlog", domain: [-10, 10], grid: true}})Power scales and square-root scales are also supported. The pow scale supports the exponent option, which defaults to 1 (for a linear scale). The sqrt scale is shorthand for a pow scale with exponent 0.5.ForkjsPlot.plot({x: {type: "sqrt", domain: [0, 100], grid: true}})ForkjsPlot.plot({x: {type: "pow", exponent: 1 / 3, domain: [0, 100], grid: true}})Continuous scales also support a clamp option which, if true, clamps input values to the scale’s domain before scaling. This is useful for preventing marks from escaping the chart area.Continuous scales support an interpolate option specified either as a function that takes a single argument t in [0, 1] and returns the corresponding value from the range, or as a two-argument function that takes a pair of values [start, end] from the range and returns the corresponding interpolator from [0, 1], typically mapping 0 to start, and 1 to end.Continuous scales support a piecewise domain specified as an array of n domain values (with n greater than or equal to two), with a corresponding range having the same number of values; each segment of the domain is mapped to the matching segment of the range using the scale’s interpolator. When the domain has n > 2 elements and the range has two elements (for example, when using the default range on a x or y scale), the latter is automatically split into n − 1 segments of equal size. Note that in addition to the domain, you must specify the scale’s continuous type since a scale specified with a domain having more than two elements otherwise defaults to an ordinal scale. (You will often have to specify the ticks manually, too.) For an example, see the Polylinear axis notebook.Discrete scales ​Sadly, not all data is continuous: some data is merely ordinal, such as t-shirt sizes; and some categorical (a.k.a. nominal), such as brands of clothing. To encode such data as position, a point or band scale is required.A point scale divides space into uniformly-spaced discrete values. It is commonly used for scatterplots (a dot mark) of ordinal data. It is the default scale type for ordinal data on the x and y scale.ForkjsPlot.plot({x: {type: "point", domain: "ABCDEFGHIJ", grid: true}})A band scale divides space into uniformly-spaced and -sized discrete intervals. It is commonly used for bar charts (bar marks). To show the bands below, we use a cell instead of a grid.ForkjsPlot
  .cell("ABCDEFGHIJ", {x: Plot.identity, stroke: "currentColor", strokeOpacity: 0.1})
  .plot({x: {type: "band", domain: "ABCDEFGHIJ"}})While point and band scales appear visually similar when only the grid is visible, the two are not identical — they differ respective to padding. Play with the options below to get a sense of their effect on the scale’s behavior.Padding:0.10Align:0.50jsPlot.plot({
  grid: true,
  marginTop: 0.5,
  x: {
    padding,
    align,
    round: false
  },
  marks: [
    Plot.frame({strokeOpacity: 0.3}),
    Plot.tickX("ABCDEFGHIJ", {x: Plot.identity, stroke: "currentColor"})
  ]
})jsPlot.plot({
  grid: true,
  marginTop: 0.5,
  x: {
    padding,
    align,
    round: false
  },
  marks: [
    Plot.frame({strokeOpacity: 0.3}),
    Plot.cell("ABCDEFGHIJ", {x: Plot.identity, stroke: "currentColor"})
  ]
})Position scales also have a round option which forces the scale to snap to integer pixels. This defaults to true for point and band scales, and false for quantitative scales. Use caution with high-cardinality ordinal domains (i.e., a point or band scale used to encode many different values), as rounding can lead to “wasted” space or even zero-width bands.Color scales ​While position is the most salient (and important) encoding, color matters too! The default quantitative color scale type is linear, and the default scheme is turbo. A wide variety of sequential, diverging, and cyclical schemes are supported, including ColorBrewer and viridis. Color scheme: BluesGreensGreysPurplesRedsOrangesTurboViridisMagmaInfernoPlasmaCividisCubehelixWarmCoolBuGnBuPuGnBuOrRdPuBuGnPuBuPuRdRdPuYlGnBuYlGnYlOrBrYlOrRdRainbowSinebowjsPlot.plot({
  axis: null,
  padding: 0,
  color: {
    scheme: schemeq
  },
  marks: [
    Plot.cell(d3.range(40), {x: Plot.identity, fill: Plot.identity, inset: -0.5})
  ]
})You can implement a custom color scheme by specifying the scale’s range, or by passing an interpolate function that takes a parameter t in [0, 1]. The interpolate option can specify a color space such as rgb, or a two-argument function that takes a pair of values from the range. Color interpolate: rgblabhclhsld3.interpolateRgb.gamma(2)(t) => `hsl(${t * 360},100%,50%)`jsPlot.plot({
  axis: null,
  padding: 0,
  color: {
    type: "linear",
    ...interpolateq === "angry-rainbow"
      ? {interpolate: (t) => `hsl(${t * 360},100%,50%)`}
      : interpolateq === "rgb-gamma"
      ? {range: ["steelblue", "orange"], interpolate: d3.interpolateRgb.gamma(2)}
      : {range: ["steelblue", "orange"], interpolate: interpolateq}
  },
  marks: [
    Plot.cell(d3.range(40), {x: Plot.identity, fill: Plot.identity, inset: -0.5})
  ]
})And like position scales, you can apply a sqrt, pow, log, or symlog transform; these are often useful when working with non-uniformly distributed data.Diverging color scales are intended to show positive and negative values, or more generally values above or below some pivot value. Diverging color scales default to the RdBu (red–blue) color scheme. The pivot defaults to zero, but you can change it with the pivot option, which should ideally be a value near the middle of the domain. Color scheme: BrBGPRGnPiYGPuOrRdBuRdGyRdYlBuRdYlGnSpectralBuRdBuYlRdjsPlot.plot({
  axis: null,
  padding: 0,
  color: {
    type: "linear",
    scheme: schemed
  },
  marks: [
    Plot.cell(d3.range(40), {x: Plot.identity, fill: Plot.identity, inset: -0.5})
  ]
})Below we again show observed global surface temperatures. The reversed BuRd color scheme is used since blue and red are semantically associated with cold and hot, respectively.ForkjsPlot.plot({
  grid: true,
  color: {
    type: "diverging",
    scheme: "BuRd"
  },
  marks: [
    Plot.ruleY([0]),
    Plot.dot(gistemp, {x: "Date", y: "Anomaly", stroke: "Anomaly"})
  ]
})Plot also provides color schemes for discrete data. Use the categorical type for categorical (nominal) unordered data, and the ordinal type for ordered data. Color scheme: AccentCategory10Dark2Observable10PairedPastel1Pastel2Set1Set2Set3Tableau10BluesGreensGreysPurplesRedsOrangesTurboViridisMagmaInfernoPlasmaCividisCubehelixWarmCoolBuGnBuPuGnBuOrRdPuBuGnPuBuPuRdRdPuYlGnBuYlGnYlOrBrYlOrRdRainbowSinebowjsPlot.plot({
  color: {
    type: "ordinal",
    scheme: schemeo
  },
  marks: [
    Plot.cell("ABCDEFGHIJ", {x: Plot.identity, fill: Plot.identity})
  ]
})CAUTIONDiscrete color schemes are intended for data that has only a few unique values. If the size of the categorical domain exceeds the number of colors in the scheme, colors will be reused; combining values into an “other” category is recommended.Other scales ​But wait, there’s more! 😅 Plot has opacity, r, symbol, and length scales, too. For example, the r scale type defaults to sqrt such that when used with the dot mark, the resulting area is proportional to the r channel value. You can adjust the effective dot size by specifying an explicit range, as below. Radius: 8.0ForkjsPlot.plot({
  r: {range: [0, radius]},
  marks: [
    Plot.dot(d3.range(1, 11), {x: Plot.identity, r: Plot.identity, fill: "currentColor"})
  ]
})The default range for the associated r scale is constructed such that a zero value maps to zero for an accurate areal encoding, while the first quartile of values is mapped to a radius of three pixels; this tends to be more stable with varying data.Type inference ​Plot strives to be concise: rather than you laboriously specifying everything, Plot can guess by inspecting the data so you don’t have to set the type, domain, and range (and for color, scheme) of scales explicitly. But for Plot’s guesses to be accurate, your data must match Plot’s expectations. Here they are.A scale’s type is most often inferred from associated marks’ channel values: strings and booleans imply an ordinal scale; dates imply a utc scale; anything else is linear. Plot assumes that your data is consistently typed, so inference is based solely on the first non-null, non-undefined value. We recommend typed CSV (passing {typed: true} to Observable’s FileAttachment csv method) or explicitly coercing types when loading data (e.g., d3.autoType).If a scale’s domain is specified explicitly, the scale’s type is inferred from the domain values rather than channels as described above. However, if the domain or range has more than two elements, the ordinal type (or point for position scales) is used.Finally, some marks declare the scale type for associated channels. For example, barX requires y to be a band scale. Further, the facet scales fx and fy are always band scales, and the r (radius) scale is implicitly a sqrt scale.If you don’t specify a quantitative scale’s domain, it is the extent (minimum and maximum) of associated channel values, except for the r (radius) scale where it goes from zero to the maximum. A quantitative domain can be extended to “nice” human-readable values with the nice option. For an ordinal scale, the domain defaults to the sorted union (all distinct values in natural order) of associated values; see the sort mark option to change the order.All position scales (x, y, fx, and fy) have implicit automatic ranges based on the chart dimensions. The x scale ranges from the left to right edge, while the y scale ranges from the bottom to top edge, accounting for margins.Scale transforms ​The transform scale option allows you to apply a function to all values before they are passed through the scale. This is convenient for transforming a scale’s data, say to convert to thousands or between temperature units.ForkjsPlot.plot({
  y: {
    grid: true,
    label: "Temperature (°C)",
    transform: (f) => (f - 32) * (5 / 9) // convert Fahrenheit to Celsius
  },
  marks: [
    Plot.ruleY([32]), // 32°F
    Plot.lineY(sftemp, Plot.windowY(7, {x: "date", y: "high"}))
  ]
})The percent scale option is shorthand for a transform that multiplies values by 100; it also adds a percent symbol (%) to the default label.ForkjsPlot.plot({
  y: {percent: true}, // convert proportion [0, 1] to percent [0, 100]
  color: {scheme: "BuRd"},
  marks: [
    Plot.rectY(gistemp, Plot.binX({y: "proportion", fill: "x"}, {x: "Anomaly", fill: "Anomaly"})),
    Plot.ruleY([0])
  ]
})CAUTIONMark transforms typically consume values before they are passed through scales (e.g., when binning). In this case the mark transforms will see the values prior to the scale transform as input, and the scale transform will apply to the output of the mark transform.The interval scale option ^0.5.1 sets an ordinal scale’s domain to the start of every interval within the extent of the data. In addition, it implicitly sets the transform of the scale to interval.floor, rounding values down to the start of each interval. For example, below we generate a time-series bar chart; when an interval is specified, missing days are visible. Use interval: ForkjsPlot.plot({
  marginBottom: 80,
  x: {
    tickRotate: -90,
    interval: intervaled ? "day" : null,
    label: null
  },
  y: {
    transform: (d) => d / 1e6,
    label: "Daily trade volume (millions)"
  },
  marks: [
    Plot.barY(aapl.slice(-40), {x: "Date", y: "Volume"}),
    Plot.ruleY([0])
  ]
})TIPAs an added bonus, the fontVariant and type options are no longer needed because Plot now understands that the x scale, despite being ordinal, represents daily observations.While the example above relies on the interval being promoted to the scale’s transform, the stack, bin, and group transforms are also interval-aware: they apply the scale’s interval, if any, before grouping values. (This results in the interval being applied twice, both before and after the mark transform, but the second application has no effect since interval application is idempotent.)The interval option can also be used for quantitative and temporal scales. This enforces uniformity, say rounding timed observations down to the nearest hour, which may be helpful for the stack transform among other uses.Scale options ​Each scale’s options are specified as a nested options object with the corresponding scale name within the top-level plot options:x - horizontal positiony - vertical positionr - radius (size)color - fill or strokeopacity - fill or stroke opacitylength - linear length (for vectors)symbol - categorical symbol (for dots)For example, to set the domain for the x scale:jsPlot.plot({x: {domain: [new Date("1880-01-01"), new Date("2016-11-01")]}})Plot supports many scale types. Some scale types are for quantitative data: values that can be added or subtracted, such as temperature or time. Other scale types are for ordinal or categorical data: unquantifiable values that can only be ordered, such as t-shirt sizes, or values with no inherent order that can only be tested for equality, such as types of fruit. Some scale types are further intended for specific visual encodings: for example, as position or color.You can set the scale type explicitly via the type scale option, though typically the scale type is inferred automatically. Some marks mandate a particular scale type: for example, barY requires that the x scale is a band scale. Some scales have a default type: for example, the r (radius) scale defaults to sqrt and the opacity scale defaults to linear. Most often, the scale type is inferred from associated data, pulled either from the domain (if specified) or from associated channels. Strings and booleans imply an ordinal scale; dates imply a UTC scale; and anything else is linear. Unless they represent text, we recommend explicitly converting strings to more specific types when loading data (e.g., with d3.autoType or Observable’s FileAttachment). For simplicity’s sake, Plot assumes that data is consistently typed; type inference is based solely on the first non-null, non-undefined value.For quantitative data (i.e. numbers), a mathematical transform may be applied to the data by changing the scale type:linear (default) - linear transform (translate and scale)pow - power (exponential) transformsqrt - square-root transform (pow transform with exponent = 0.5)log - logarithmic transformsymlog - bi-symmetric logarithmic transform per Webber et al.The appropriate transform depends on the data’s distribution and what you wish to know. A sqrt transform exaggerates differences between small values at the expense of large values; it is a special case of the pow transform which has a configurable scale.exponent (0.5 for sqrt). A log transform is suitable for comparing orders of magnitude and can only be used when the domain does not include zero. The base defaults to 10 and can be specified with the scale.base option; note that this only affects the axis ticks and not the scale’s behavior. A symlog transform is more elaborate, but works well with wide-range values that include zero; it can be configured with the scale.constant option (default 1).For temporal data (i.e. dates), two variants of a linear scale are also supported:utc (default, recommended) - UTC timetime - local timeUTC is recommended over local time as charts in UTC time are guaranteed to appear consistently to all viewers whereas charts in local time will depend on the viewer’s time zone. Due to limitations in JavaScript’s Date class, Plot does not yet support an explicit time zone other than UTC.For ordinal data (e.g., strings), use the ordinal scale type or the point or band position scale types. The categorical scale type is also supported; it is equivalent to ordinal except as a color scale, where it provides a different default color scheme. (Since position is inherently ordinal or even quantitative, categorical data must be assigned an effective order when represented as position, and hence categorical and ordinal may be considered synonymous in context.)You can opt-out of a scale using the identity scale type. This is useful if you wish to specify literal colors or pixel positions within a mark channel rather than relying on the scale to convert abstract values into visual values. For position scales (x and y), an identity scale is still quantitative and may produce an axis, yet unlike a linear scale the domain and range are fixed based on the plot layout.TIPTo opt-out of a scale for a single channel, you can specify the channel values as a {value, scale} object; see mark options.Quantitative scales, as well as identity position scales, coerce channel values to numbers; both null and undefined are coerced to NaN. Similarly, time scales coerce channel values to dates; numbers are assumed to be milliseconds since UNIX epoch, while strings are assumed to be in ISO 8601 format.A scale’s domain (the extent of its inputs, abstract values) and range (the extent of its outputs, visual values) are typically inferred automatically. You can set them explicitly using these options:domain - typically [min, max], or an array of ordinal or categorical valuesrange - typically [min, max], or an array of ordinal or categorical valuesunknown - the desired output value (defaults to undefined) for invalid input valuesreverse - reverses the domain (or the range), say to flip the chart along x or yinterval - an interval or time interval (for interval data; see below)For most quantitative scales, the default domain is the [min, max] of all values associated with the scale. For the radius and opacity scales, the default domain is [0, max] to ensure a meaningful value encoding. For ordinal scales, the default domain is the set of all distinct values associated with the scale in natural ascending order; for a different order, set the domain explicitly or add a sort option to an associated mark. For threshold scales, the default domain is [0] to separate negative and non-negative values. For quantile scales, the default domain is the set of all defined values associated with the scale. If a scale is reversed, it is equivalent to setting the domain as [max, min] instead of [min, max].The default range depends on the scale: for position scales (x, y, fx, and fy), the default range depends on the plot’s size and margins. For color scales, there are default color schemes for quantitative, ordinal, and categorical data. For opacity, the default range is [0, 1]. And for radius, the default range is designed to produce dots of “reasonable” size assuming a sqrt scale type for accurate area representation: zero maps to zero, the first quartile maps to a radius of three pixels, and other values are extrapolated. This convention for radius ensures that if the scale’s data values are all equal, dots have the default constant radius of three pixels, while if the data varies, dots will tend to be larger.The behavior of the unknown scale option depends on the scale type. For quantitative and temporal scales, the unknown value is used whenever the input value is undefined, null, or NaN. For ordinal or categorical scales, the unknown value is returned for any input value outside the domain. For band or point scales, the unknown option has no effect; it is effectively always equal to undefined. If the unknown option is set to undefined (the default), or null or NaN, then the affected input values will be considered undefined and filtered from the output.For data at regular intervals, such as integer values or daily samples, the interval option can be used to enforce uniformity. The specified interval — such as d3.utcMonth — must expose an interval.floor(value), interval.offset(value), and interval.range(start, stop) functions. The option can also be specified as a number, in which case it will be promoted to a numeric interval with the given step. The option can alternatively be specified as a string (second, minute, hour, day, week, month, quarter, half, year, monday, tuesday, wednesday, thursday, friday, saturday, sunday) ^0.6.2 naming the corresponding time interval, or a skip interval consisting of a number followed by the interval name (possibly pluralized), such as 3 months or 10 years. This option sets the default scale.transform to the given interval’s interval.floor function. In addition, the default scale.domain is an array of uniformly-spaced values spanning the extent of the values associated with the scale.Quantitative scales can be further customized with additional options:clamp - if true, clamp input values to the scale’s domainnice - if true (or a tick count), extend the domain to nice round valueszero - if true, extend the domain to include zero if neededpercent - if true, transform proportions in [0, 1] to percentages in [0, 100]Clamping is typically used in conjunction with setting an explicit domain since if the domain is inferred, no values will be outside the domain. Clamping is useful for focusing on a subset of the data while ensuring that extreme values remain visible, but use caution: clamped values may need an annotation to avoid misinterpretation. Top-level clamp, nice, and zero options are supported as shorthand for setting the respective option on all scales.The transform option allows you to apply a function to all values before they are passed through the scale. This is convenient for transforming a scale’s data, say to convert to thousands or between temperature units.jsPlot.plot({
  y: {
    label: "Temperature (°F)",
    transform: (f) => f * 9 / 5 + 32 // convert Celsius to Fahrenheit
  },
  marks: …
})Color scale options ​The normal scale types — linear, sqrt, pow, log, symlog, and ordinal — can be used to encode color. In addition, Plot supports special scale types for color:categorical - like ordinal, but defaults to observable10sequential - like linearcyclical - like linear, but defaults to rainbowthreshold - discretizes using thresholds given as the domain; defaults to rdylbuquantile - discretizes by computing quantile thresholds; defaults to rdylbuquantize - discretizes by computing uniform thresholds; defaults to rdylbu ^0.4.3diverging - like linear, but with a pivot; defaults to rdbudiverging-log - like log, but with a pivot that defaults to 1; defaults to rdbudiverging-pow - like pow, but with a pivot; defaults to rdbudiverging-sqrt - like sqrt, but with a pivot; defaults to rdbudiverging-symlog - like symlog, but with a pivot; defaults to rdbuFor a threshold scale, the domain represents n (typically numeric) thresholds which will produce a range of n + 1 output colors; the ith color of the range applies to values that are smaller than the ith element of the domain and larger or equal to the i - 1th element of the domain. For a quantile scale, the domain represents all input values to the scale, and the n option specifies how many quantiles to compute from the domain; n quantiles will produce n - 1 thresholds, and an output range of n colors. For a quantize scale, the domain will be transformed into approximately n quantized values, where n is an option that defaults to 5.By default, all diverging color scales are symmetric around the pivot; set symmetric to false if you want to cover the whole extent on both sides.Color scales support two additional options:scheme - a named color scheme in lieu of a range, such as redsinterpolate - in conjunction with a range, how to interpolate colorsFor quantile and quantize color scales, the scheme option is used in conjunction with n, which determines how many quantiles or quantized values to compute, and thus the number of elements in the scale’s range; it defaults to 5 (for quintiles in the case of a quantile scale).The following sequential scale schemes are supported for both quantitative and ordinal data:jsPlot.plot({
  width: 322,
  height: 25 * 27,
  margin: 0,
  marginRight: 70,
  padding: 0,
  x: {axis: null},
  y: {axis: "right", tickSize: 0},
  color: {type: "identity"},
  marks: [
    Plot.cell([
      ["Blues", d3.interpolateBlues],
      ["Greens", d3.interpolateGreens],
      ["Greys", d3.interpolateGreys],
      ["Purples", d3.interpolatePurples],
      ["Reds", d3.interpolateReds],
      ["Oranges", d3.interpolateOranges],
      ["Turbo", d3.interpolateTurbo],
      ["Viridis", d3.interpolateViridis],
      ["Magma", d3.interpolateMagma],
      ["Inferno", d3.interpolateInferno],
      ["Plasma", d3.interpolatePlasma],
      ["Cividis", d3.interpolateCividis],
      ["Cubehelix", d3.interpolateCubehelixDefault],
      ["Warm", d3.interpolateWarm],
      ["Cool", d3.interpolateCool],
      ["BuGn", d3.interpolateBuGn],
      ["BuPu", d3.interpolateBuPu],
      ["GnBu", d3.interpolateGnBu],
      ["OrRd", d3.interpolateOrRd],
      ["PuBuGn", d3.interpolatePuBuGn],
      ["PuBu", d3.interpolatePuBu],
      ["PuRd", d3.interpolatePuRd],
      ["RdPu", d3.interpolateRdPu],
      ["YlGnBu", d3.interpolateYlGnBu],
      ["YlGn", d3.interpolateYlGn],
      ["YlOrBr", d3.interpolateYlOrBr],
      ["YlOrRd", d3.interpolateYlOrRd],
    ].flatMap(([name, i]) => d3.ticks(0, 1, 20).map((t) => [t, name, String(i(t))])), {fill: "2", insetTop: 0.5, insetBottom: 0.5})
  ]
})The default color scheme, turbo, was chosen primarily to ensure high-contrast visibility. Color schemes such as blues make low-value marks difficult to see against a white background, for better or for worse. To use a subset of a continuous color scheme (or any single-argument interpolate function), set the scale.range property to the corresponding subset of [0, 1]; for example, to use the first half of the rainbow color scheme, use a range of [0, 0.5]. By default, the full range [0, 1] is used. If you wish to encode a quantitative value without hue, consider using opacity rather than color (e.g., use Plot.dot’s strokeOpacity instead of stroke).The following diverging scale schemes are supported:jsPlot.plot({
  width: 322,
  height: 25 * 11,
  margin: 0,
  marginRight: 70,
  padding: 0,
  x: {axis: null},
  y: {axis: "right", tickSize: 0},
  color: {type: "identity"},
  marks: [
    Plot.cell([
      ["BrBG", d3.interpolateBrBG],
      ["PRGn", d3.interpolatePRGn],
      ["PiYG", d3.interpolatePiYG],
      ["PuOr", d3.interpolatePuOr],
      ["RdBu", d3.interpolateRdBu],
      ["RdGy", d3.interpolateRdGy],
      ["RdYlBu", d3.interpolateRdYlBu],
      ["RdYlGn", d3.interpolateRdYlGn],
      ["Spectral", d3.interpolateSpectral],
      ["BuRd", (t) => d3.interpolateRdBu(1 - t)],
      ["BuYlRd", (t) => d3.interpolateRdYlBu(1 - t)],
    ].flatMap(([name, i]) => d3.ticks(0, 1, 30).map((t) => [t, name, String(i(t))])), {fill: "2", insetTop: 0.5, insetBottom: 0.5})
  ]
})Picking a diverging color scheme name defaults the scale type to diverging; set the scale type to linear to treat the color scheme as sequential instead. Diverging color scales support a scale.pivot option, which defaults to zero. Values below the pivot will use the lower half of the color scheme (e.g., reds for the rdgy scheme), while values above the pivot will use the upper half (grays for rdgy).The following cylical color schemes are supported:jsPlot.plot({
  width: 322,
  height: 25 * 2,
  margin: 0,
  marginRight: 70,
  padding: 0,
  x: {axis: null},
  y: {axis: "right", tickSize: 0},
  color: {type: "identity"},
  marks: [
    Plot.cell([
      ["rainbow", d3.interpolateRainbow],
      ["sinebow", d3.interpolateSinebow],
    ].flatMap(([name, i]) => d3.ticks(0, 1, 30).map((t) => [t, name, String(i(t))])), {fill: "2", insetTop: 0.5, insetBottom: 0.5})
  ]
})The following categorical color schemes are supported:jsPlot.plot({
  width: 322,
  height: 25 * 10,
  margin: 0,
  marginRight: 70,
  padding: 0,
  x: {axis: null},
  y: {axis: "right", tickSize: 0},
  color: {type: "identity"},
  marks: [
    Plot.cell([
      ["Accent", d3.schemeAccent],
      ["Category10", d3.schemeCategory10],
      ["Dark2", d3.schemeDark2],
      ["Observable10", Plot.scale({color: {type: "categorical"}}).range],
      ["Paired", d3.schemePaired],
      ["Pastel1", d3.schemePastel1],
      ["Pastel2", d3.schemePastel2],
      ["Set1", d3.schemeSet1],
      ["Set2", d3.schemeSet2],
      ["Set3", d3.schemeSet3],
      ["Tableau10", d3.schemeTableau10],
    ].flatMap(([name, scheme]) => scheme.map((s, i) => [i, name, s])), {fill: "2", inset: 0.5})
  ]
})The following color interpolators are supported:rgb - RGB (red, green, blue)hsl - HSL (hue, saturation, lightness)lab - CIELAB (a.k.a. “Lab”)hcl - CIELChab (a.k.a. “LCh” or “HCL”)Position scale options ​The position scales (x, y, fx, and fy) support additional options:inset - inset the default range by the specified amount in pixelsround - round the output value to the nearest integer (whole pixel)The x and fx scales support asymmetric insets for more precision. Replace inset by:insetLeft - insets the start of the default range by the specified number of pixelsinsetRight - insets the end of the default range by the specified number of pixelsSimilarly, the y and fy scales support asymmetric insets with:insetTop - insets the top of the default range by the specified number of pixelsinsetBottom - insets the bottom of the default range by the specified number of pixelsThe inset scale options can provide “breathing room” to separate marks from axes or the plot’s edge. For example, in a scatterplot with a Plot.dot with the default 3-pixel radius and 1.5-pixel stroke width, an inset of 5 pixels prevents dots from overlapping with the axes. The scale.round option is useful for crisp edges by rounding to the nearest pixel boundary.In addition to the generic ordinal scale type, which requires an explicit output range value for each input domain value, Plot supports special point and band scale types for encoding ordinal data as position. These scale types accept a [min, max] range similar to quantitative scales, and divide this continuous interval into discrete points or bands based on the number of distinct values in the domain (i.e., the domain’s cardinality). If the associated marks have no effective width along the ordinal dimension — such as a dot, rule, or tick — then use a point scale; otherwise, say for a bar, use a band scale.Ordinal position scales support additional options, all specified as proportions in [0, 1]:padding - how much of the range to reserve to inset first and last point or bandalign - where to distribute points or bands (0 = at start, 0.5 = at middle, 1 = at end)For a band scale, you can further fine-tune padding:paddingInner - how much of the range to reserve to separate adjacent bandspaddingOuter - how much of the range to reserve to inset first and last bandAlign defaults to 0.5 (centered). Band scale padding defaults to 0.1 (10% of available space reserved for separating bands), while point scale padding defaults to 0.5 (the gap between the first point and the edge is half the distance of the gap between points, and likewise for the gap between the last point and the opposite edge). Note that rounding and mark insets (e.g., for bars and rects) also affect separation between adjacent marks.Plot implicitly generates an axis mark for position scales if one is not explicitly declared. (For more control, declare the axis mark explicitly.) The following axis mark options are also available as scale options, applying to the implicit axis:axis - the axis anchor: top, bottom (x or fx); left, right (y or fy); both; null to suppressticks - the approximate number of ticks to generate, or interval, or array of valuestickSpacing - the approximate number of pixels between ticks (if ticks is not specified)tickSize - the length of each tick (in pixels; default 6 for x and y, or 0 for fx and fy)tickPadding - the separation between the tick and its label (in pixels; default 3)tickFormat - either a function or specifier string to format tick values; see FormatstickRotate - whether to rotate tick labels (an angle in degrees clockwise; default 0)fontVariant - the font-variant attribute; defaults to tabular-nums if quantitativelabel - a string to label the axislabelAnchor - the label anchor: top, right, bottom, left, or centerlabelArrow - the label arrow: auto (default), up, right, down, left, none, or true ^0.6.7labelOffset - the label position offset (in pixels; default depends on margins and orientation)ariaLabel - a short label representing the axis in the accessibility treeariaDescription - a textual description for the axisFor an implicit grid mark, use the grid option. For an implicit frame mark along one edge of the frame, use the line option.grid - whether to draw grid lines across the plot for each tickline - if true, draw the axis line (only for x and y)Top-level options are also supported as shorthand: grid (for x and y only; see facets), label, axis, inset, round, align, and padding. If the grid option is true, show a grid using currentColor; if specified as a string, show a grid with the specified color; if an approximate number of ticks, an interval, or an array of tick values, show corresponding grid lines.Sort mark option ^0.2.0 ​If an ordinal scale’s domain is not set, it defaults to natural ascending order; to order the domain by associated values in another dimension, either compute the domain manually (consider d3.groupSort) or use an associated mark’s sort option. For example, to sort bars by ascending frequency rather than alphabetically by letter:jsPlot.barY(alphabet, {x: "letter", y: "frequency", sort: {x: "y"}})The sort option is an object whose keys are ordinal scale names, such as x or fx, and whose values are mark channel names, such as y, y1, or y2. By specifying an existing channel rather than a new value, you avoid repeating the order definition and can refer to channels derived by transforms (such as stack or bin). When sorting the x domain, if no x channel is defined, x2 will be used instead if available, and similarly for y and y2; this is useful for marks that implicitly stack such as area, bar, and rect. A sort value may also be specified as width or height ^0.4.2, representing derived channels |x2 - x1| and |y2 - y1| respectively.Note that there may be multiple associated values in the secondary dimension for a given value in the primary ordinal dimension. The secondary values are therefore grouped for each associated primary value, and each group is then aggregated by applying a reducer. The default reducer is max, but may be changed by specifying the reduce option. Lastly the primary values are by default sorted based on the associated reduced value in natural ascending order to produce the domain. The above code is shorthand for:jsPlot.barY(alphabet, {x: "letter", y: "frequency", sort: {x: "y", reduce: "max", order: "ascending"}})Generally speaking, a reducer only needs to be specified when there are multiple secondary values for a given primary value. See the group transform for the list of supported reducers.For descending rather than ascending order, set the order option to descending:jsPlot.barY(alphabet, {x: "letter", y: "frequency", sort: {x: "y", order: "descending"}})Alternatively, the -channel shorthand option, which changes the default order to descending:jsPlot.barY(alphabet, {x: "letter", y: "frequency", sort: {x: "-y"}})Setting order to null will disable sorting, preserving the order of the data. (When an aggregating transform is used, such as group or bin, note that the data may already have been sorted and thus the order may differ from the input data.)Alternatively, set the reverse option to true. This produces a different result than descending order for null or unorderable values: descending order puts nulls last, whereas reversed ascending order puts nulls first.jsPlot.barY(alphabet, {x: "letter", y: "frequency", sort: {x: "y", reverse: true}})An additional limit option truncates the domain to the first n values after ordering. If limit is negative, the last n values are used instead. Hence, a positive limit with reverse = true will return the top n values in descending order. If limit is an array [lo, hi], the ith values with lo ≤ i < hi will be selected. (Note that like the basic filter transform, limiting the x domain here does not affect the computation of the y domain, which is computed independently without respect to filtering.)jsPlot.barY(alphabet, {x: "letter", y: "frequency", sort: {x: "y", limit: 5}})If different sort options are needed for different ordinal scales, the channel name can be replaced with a value object with additional per-scale options.jsPlot.barY(alphabet, {x: "letter", y: "frequency", sort: {x: {value: "y", order: "descending"}}})If the input channel is data, then the reducer is passed groups of the mark’s data; this is typically used in conjunction with a custom reducer function, as when the built-in single-channel reducers are insufficient.Note: when the value of the sort option is a string or a function, it is interpreted as a mark sort transform. To use both sort options and a mark sort transform, use Plot.sort.scale(options) ^0.4.0 ​You can also create a standalone scale with Plot.scale(options). The options object must define at least one scale; see Scale options for how to define a scale. For example, here is a categorical color scale with the Tableau10 color scheme and a domain of fruits:jsconst color = Plot.scale({color: {scheme: "Tableau10", domain: ["apple", "orange", "pear"]}});Both plot.scale and Plot.scale return scale objects. These objects represent the actual (or “materialized”) scale options used by Plot, including the domain, range, interpolate function, etc. The scale’s label, if any, is also returned; however, note that other axis properties are not currently exposed. Point and band scales also expose their materialized bandwidth and step.jscolor.domain // ["apple", "orange", "pear"]For convenience, scale objects expose a scale.apply(input) method which returns the scale’s output for the given input value. When applicable, scale objects also expose a scale.invert(output) method which returns the corresponding input value from the scale’s domain for the given output value.jscolor.apply("apple") // "#4e79a7"To apply a standalone scale object to a plot, pass it to Plot.plot as the corresponding scale options, such as color:jsPlot.cellX(["apple", "apple", "orange", "pear", "orange"]).plot({color})As another example, below are two plots with different options where the second plot uses the color scale from the first plot:jsconst plot1 = Plot.plot({...options1});
const plot2 = Plot.plot({...options2, color: plot1.scale("color")});\n\n\n\nTransforms ​Transforms derive data as part of the plot specification. This accelerates what is often the most onerous task in visualization: getting data into the right shape.For example, given a dataset of highway traffic measured as vehicles per hour by location, plotting every observation is straightforward: use a tick (or dot) and assign x = vehicles per hour and y = location. But to draw a quantifiable insight, we may want a summary statistic such as the median traffic by location. 👩‍💻 Below we use the group transform to group by location and apply a median reducer to position the red tick.ForkjsPlot.plot({
  marginLeft: 120,
  x: {label: "Vehicles per hour (thousands)", transform: (x) => x / 1000},
  y: {label: null},
  marks: [
    Plot.ruleX([0]),
    Plot.tickX(
      traffic,
      {x: "vehicles", y: "location", strokeOpacity: 0.3}
    ),
    Plot.tickX(
      traffic,
      Plot.groupY(
        {x: "median"},
        {x: "vehicles", y: "location", stroke: "red", strokeWidth: 4, sort: {y: "x"}}
      )
    )
  ]
})As you might expect, traffic varies significantly throughout the day, so perhaps it would be better to look at the median by hour by location? Instead of grouping only by y, we can group by both x and y to produce a heatmap.ForkjsPlot.plot({
  marginLeft: 120,
  padding: 0,
  y: {label: null},
  color: {scheme: "YlGnBu", legend: true, zero: true},
  marks: [
    Plot.cell(
      traffic,
      Plot.group(
        {fill: "median"},
        {x: (d) => d.date.getUTCHours(), y: "location", fill: "vehicles", inset: 0.5, sort: {y: "fill"}}
      )
    )
  ]
})Plot includes many useful transforms! For example, you can compute a rolling average to smooth a noisy signal, stack layers for a streamgraph, or dodge dots for a beeswarm. Plot’s various built-in transforms include: bin, centroid, dodge, filter, group, hexbin, interval, map, normalize, reverse, select, shuffle, sort, stack, tree, and window. If these don’t meet your needs, you can even implement a custom transform.Transforms are never required — you can always aggregate and derive data yourself outside of Plot, and then pass in the binned values. For example, we could use d3.bin to compute a histogram of athletes’ weights as an array of {x0, x1, length} objects.jsbins = d3.bin().thresholds(80).value((d) => d.weight)(olympians)We can then pass that to the rect mark, assigning to the x1, x2, and y2 channels:jsPlot.rectY(bins, {x1: "x0", x2: "x1", y2: "length"}).plot()INFOThis is for demonstration only; you wouldn’t normally bin “by hand” as shown here.But Plot’s transforms are often more convenient, especially in conjunction with Plot’s other features such as faceting and automatic grouping by z. For example, if we want to add a color encoding to our histogram, we simply add the fill option and the bin transform partitions each bin accordingly; doing this with d3.bin would be a lot more work!ForkjsPlot.rectY(olympians, Plot.binX({y: "count"}, {x: "weight", fill: "sex"})).plot({color: {legend: true}})Plot’s transforms typically take two options objects as arguments: the first object contains the transform options (above, {y: "count"}), while the second object contains mark options to be “passed through” to the mark ({x: "weight", fill: "sex"}). The transform returns a new options object representing the transformed mark options to be passed to a mark.Breaking down the above code:jsconst options = {x: "weight", fill: "sex"}; // initial mark options
const binOptions = {y: "count"}; // bin transform options
const binned = Plot.binX(binOptions, options); // transformed mark options
const rect = Plot.rectY(olympians, binned); // rect mark
const plot = rect.plot({color: {legend: true}}); // plot!TIPIf a transform isn’t doing what you expect, try inspecting the options object returned by the transform. Does it contain the options you expect?Transforms can derive channels (such as y above) as well as changing the default options. For example, the bin transform sets default insets for a one-pixel gap between adjacent rects.Transforms are composable: you can pass options through more than one transform before passing it to a mark. For example, above it’s a bit difficult to compare the weight distribution by sex because there are fewer female than male athletes in the data. We can remove this effect using the normalize transform with the sum reducer.ForkjsPlot.plot({
  y: {percent: true},
  marks: [
    Plot.rectY(
      olympians,
      Plot.normalizeY(
        "sum", // normalize each series by the sum per series
        Plot.binX(
          {y2: "count"}, // disable implicit stack transform
          {x: "weight", fill: "sex", mixBlendMode: "multiply"}
        )
      )
    )
  ]
})And, as you may have wondered above, many of Plot’s marks provide implicit transforms: for example, the rectY mark applies an implicit stackY transform if you use the y option, and the dot mark applies an implicit sort transform to mitigate the effect of occlusion by drawing the smallest dots on top.Custom transforms ​For greater control, you can also implement a custom transform function, allowing data, indexes, or channels to be derived prior to rendering. Custom transforms are rarely implemented directly; see the built-in transforms above. For example, below we implement the filter transform “by hand” as a custom transform to show the unemployment rates only in Michigan metropolitan divisions.ForkjsPlot.plot({
  y: {
    grid: true,
    label: "Unemployment (%)"
  },
  color: {
    domain: [false, true],
    range: ["#ccc", "red"]
  },
  marks: [
    Plot.ruleY([0]),
    Plot.line(bls, {
      x: "date",
      y: "unemployment",
      z: "division",
      transform: (data, facets) => ({
        data,
        facets: facets.map((facet) => {
          return facet.filter((i) => {
            return /, MI /.test(data[i].division);
          });
        })
      })
    })
  ]
})The transform function is passed three arguments, data, facets, and options representing the mark’s data and facet indexes, and the plot’s options; it must then return a {data, facets} object with the transformed data and facet indexes. The facets are represented as a nested array of arrays such as [[0, 1, 3, …], [2, 5, 10, …], …]; each element in facets specifies the zero-based indexes of elements in data that are in a given facet (i.e., have a distinct value in the associated fx or fy dimension).If the transform option is specified, it supersedes any basic transforms (i.e., the filter, sort and reverse options are ignored). However, the transform option is rarely used directly; instead one of Plot’s built-in transforms are used, and these transforms automatically compose with the basic filter, sort and reverse transforms.While transform functions often produce new data or facets, they may return the passed-in data and facets as-is, and often have a side effect of constructing derived channels. For example, the count of elements in a groupX transform might be returned as a new y channel. In this case, the transform is typically expressed as an options transform: a function that takes a mark options object and returns a new, transformed options object, where the returned options object implements the transform option. Transform functions should not mutate the input data or facets. Likewise options transforms should not mutate the input options object.When implementing a custom transform for generic usage, keep in mind that it needs to be compatible with Plot’s faceting system, which partitions the original dataset into discrete subsets.Custom initializers ^0.5.0 ​Initializers are a special class of transform; whereas transforms operate in abstract data space, initializers operate in screen space such as pixel coordinates and colors. For example, initializers can modify a marks’ positions to avoid occlusion. Initializers are invoked after the initial scales are constructed and can modify the channels or derive new channels; these in turn may (or may not, as desired) be passed to scales. Plot’s hexbin and dodge transforms are initializers.You can specify a custom initializer by specifying a function as the mark initializer option. This function is called after the scales have been computed, and receives as inputs the (possibly transformed) array of data, the facets index of elements of this array that belong to each facet, the input channels (as an object of named channels), the scales, and the dimensions. The mark itself is the this context. The initializer function must return an object with data, facets, and new channels. Any new channels are merged with existing channels, replacing channels of the same name.If an initializer desires a channel that is not supported by the downstream mark, additional channels can be declared using the mark channels option.transform(options, transform) ^0.4.3 ​jsPlot.transform(options, (data, facets) => {
  return {
    data,
    facets: facets.map((I) => I.filter(() => Math.random() > 0.5))
  };
})Given an options object that may specify some basic transforms (filter, sort, or reverse) or a custom transform function, composes those transforms if any with the given transform function, returning a new options object. If a custom transform function is present on the given options, any basic transforms are ignored. Any additional input options are passed through in the returned options object. This method facilitates applying the basic transforms prior to applying the given custom transform and is used internally by Plot’s built-in transforms.initializer(options, initializer) ^0.5.0 ​This helper composes the initializer function with any other transforms present in the options, and returns a new options object. It is used internally by Plot’s built-in initializer transforms.valueof(data, value, type) ​jsPlot.valueof(aapl, "Close")Given an iterable data and some value accessor, returns an array (a column) of the specified type with the corresponding value of each element of the data. The value accessor may be one of the following types:a string - corresponding to the field accessor ((d) => d[value])an accessor function - called as type.from(data, value)a number, Date, or boolean — resulting in an array uniformly filled with the valuean object with a transform method — called as value.transform(data)an array of values - returning the samenull or undefined - returning the sameIf type is specified, it must be Array or a similar class that implements the Array.from interface such as a typed array. When type is Array or a typed array class, the return value of valueof will be an instance of the same (or null or undefined). When type is a typed array, values will be implicitly coerced numbers, and if type is Float64Array, Float32Array, or a subclass of the same, null values will be implicitly replaced with NaN. If type is not specified, valueof may return either an array or a typed array (or null or undefined).valueof is not guaranteed to return a new array. When a transform method is used, or when the given value is an array that is compatible with the requested type, the array may be returned as-is without making a copy.column(source) ^0.4.3 ​jsconst [X, setX] = Plot.column();This helper for constructing derived columns returns a [column, setColumn] array. The column object implements column.transform, returning whatever value was most recently passed to setColumn. If setColumn is not called, then column.transform returns undefined. If a source is specified, then column.label exposes the given source’s label, if any: if source is a string as when representing a named field of data, then column.label is source; otherwise column.label propagates source.label. This allows derived columns to propagate a human-readable axis or legend label.This method is used by Plot’s transforms to derive channels; the associated columns are populated (derived) when the transform option function is invoked.identity ^0.6.2 ​jsPlot.contour(data, {width: w, height: h, fill: Plot.identity})This channel helper returns a source array as-is, avoiding an extra copy when defining a channel as being equal to the data.indexOf ^0.6.6 ​jsPlot.lineY(numbers, {x: Plot.indexOf, y: Plot.identity})This channel helper returns an array of numbers [0, 1, 2, 3, …]. It is used internally by marks with zero-based index defaults for channels.\n\nSearchK0.6.17GitHub️ 4.6kOn this pageTransforms ​Transforms derive data as part of the plot specification. This accelerates what is often the most onerous task in visualization: getting data into the right shape.For example, given a dataset of highway traffic measured as vehicles per hour by location, plotting every observation is straightforward: use a tick (or dot) and assign x = vehicles per hour and y = location. But to draw a quantifiable insight, we may want a summary statistic such as the median traffic by location. 👩‍💻 Below we use the group transform to group by location and apply a median reducer to position the red tick.ForkjsPlot.plot({
  marginLeft: 120,
  x: {label: "Vehicles per hour (thousands)", transform: (x) => x / 1000},
  y: {label: null},
  marks: [
    Plot.ruleX([0]),
    Plot.tickX(
      traffic,
      {x: "vehicles", y: "location", strokeOpacity: 0.3}
    ),
    Plot.tickX(
      traffic,
      Plot.groupY(
        {x: "median"},
        {x: "vehicles", y: "location", stroke: "red", strokeWidth: 4, sort: {y: "x"}}
      )
    )
  ]
})As you might expect, traffic varies significantly throughout the day, so perhaps it would be better to look at the median by hour by location? Instead of grouping only by y, we can group by both x and y to produce a heatmap.ForkjsPlot.plot({
  marginLeft: 120,
  padding: 0,
  y: {label: null},
  color: {scheme: "YlGnBu", legend: true, zero: true},
  marks: [
    Plot.cell(
      traffic,
      Plot.group(
        {fill: "median"},
        {x: (d) => d.date.getUTCHours(), y: "location", fill: "vehicles", inset: 0.5, sort: {y: "fill"}}
      )
    )
  ]
})Plot includes many useful transforms! For example, you can compute a rolling average to smooth a noisy signal, stack layers for a streamgraph, or dodge dots for a beeswarm. Plot’s various built-in transforms include: bin, centroid, dodge, filter, group, hexbin, interval, map, normalize, reverse, select, shuffle, sort, stack, tree, and window. If these don’t meet your needs, you can even implement a custom transform.Transforms are never required — you can always aggregate and derive data yourself outside of Plot, and then pass in the binned values. For example, we could use d3.bin to compute a histogram of athletes’ weights as an array of {x0, x1, length} objects.jsbins = d3.bin().thresholds(80).value((d) => d.weight)(olympians)We can then pass that to the rect mark, assigning to the x1, x2, and y2 channels:jsPlot.rectY(bins, {x1: "x0", x2: "x1", y2: "length"}).plot()INFOThis is for demonstration only; you wouldn’t normally bin “by hand” as shown here.But Plot’s transforms are often more convenient, especially in conjunction with Plot’s other features such as faceting and automatic grouping by z. For example, if we want to add a color encoding to our histogram, we simply add the fill option and the bin transform partitions each bin accordingly; doing this with d3.bin would be a lot more work!ForkjsPlot.rectY(olympians, Plot.binX({y: "count"}, {x: "weight", fill: "sex"})).plot({color: {legend: true}})Plot’s transforms typically take two options objects as arguments: the first object contains the transform options (above, {y: "count"}), while the second object contains mark options to be “passed through” to the mark ({x: "weight", fill: "sex"}). The transform returns a new options object representing the transformed mark options to be passed to a mark.Breaking down the above code:jsconst options = {x: "weight", fill: "sex"}; // initial mark options
const binOptions = {y: "count"}; // bin transform options
const binned = Plot.binX(binOptions, options); // transformed mark options
const rect = Plot.rectY(olympians, binned); // rect mark
const plot = rect.plot({color: {legend: true}}); // plot!TIPIf a transform isn’t doing what you expect, try inspecting the options object returned by the transform. Does it contain the options you expect?Transforms can derive channels (such as y above) as well as changing the default options. For example, the bin transform sets default insets for a one-pixel gap between adjacent rects.Transforms are composable: you can pass options through more than one transform before passing it to a mark. For example, above it’s a bit difficult to compare the weight distribution by sex because there are fewer female than male athletes in the data. We can remove this effect using the normalize transform with the sum reducer.ForkjsPlot.plot({
  y: {percent: true},
  marks: [
    Plot.rectY(
      olympians,
      Plot.normalizeY(
        "sum", // normalize each series by the sum per series
        Plot.binX(
          {y2: "count"}, // disable implicit stack transform
          {x: "weight", fill: "sex", mixBlendMode: "multiply"}
        )
      )
    )
  ]
})And, as you may have wondered above, many of Plot’s marks provide implicit transforms: for example, the rectY mark applies an implicit stackY transform if you use the y option, and the dot mark applies an implicit sort transform to mitigate the effect of occlusion by drawing the smallest dots on top.Custom transforms ​For greater control, you can also implement a custom transform function, allowing data, indexes, or channels to be derived prior to rendering. Custom transforms are rarely implemented directly; see the built-in transforms above. For example, below we implement the filter transform “by hand” as a custom transform to show the unemployment rates only in Michigan metropolitan divisions.ForkjsPlot.plot({
  y: {
    grid: true,
    label: "Unemployment (%)"
  },
  color: {
    domain: [false, true],
    range: ["#ccc", "red"]
  },
  marks: [
    Plot.ruleY([0]),
    Plot.line(bls, {
      x: "date",
      y: "unemployment",
      z: "division",
      transform: (data, facets) => ({
        data,
        facets: facets.map((facet) => {
          return facet.filter((i) => {
            return /, MI /.test(data[i].division);
          });
        })
      })
    })
  ]
})The transform function is passed three arguments, data, facets, and options representing the mark’s data and facet indexes, and the plot’s options; it must then return a {data, facets} object with the transformed data and facet indexes. The facets are represented as a nested array of arrays such as [[0, 1, 3, …], [2, 5, 10, …], …]; each element in facets specifies the zero-based indexes of elements in data that are in a given facet (i.e., have a distinct value in the associated fx or fy dimension).If the transform option is specified, it supersedes any basic transforms (i.e., the filter, sort and reverse options are ignored). However, the transform option is rarely used directly; instead one of Plot’s built-in transforms are used, and these transforms automatically compose with the basic filter, sort and reverse transforms.While transform functions often produce new data or facets, they may return the passed-in data and facets as-is, and often have a side effect of constructing derived channels. For example, the count of elements in a groupX transform might be returned as a new y channel. In this case, the transform is typically expressed as an options transform: a function that takes a mark options object and returns a new, transformed options object, where the returned options object implements the transform option. Transform functions should not mutate the input data or facets. Likewise options transforms should not mutate the input options object.When implementing a custom transform for generic usage, keep in mind that it needs to be compatible with Plot’s faceting system, which partitions the original dataset into discrete subsets.Custom initializers ^0.5.0 ​Initializers are a special class of transform; whereas transforms operate in abstract data space, initializers operate in screen space such as pixel coordinates and colors. For example, initializers can modify a marks’ positions to avoid occlusion. Initializers are invoked after the initial scales are constructed and can modify the channels or derive new channels; these in turn may (or may not, as desired) be passed to scales. Plot’s hexbin and dodge transforms are initializers.You can specify a custom initializer by specifying a function as the mark initializer option. This function is called after the scales have been computed, and receives as inputs the (possibly transformed) array of data, the facets index of elements of this array that belong to each facet, the input channels (as an object of named channels), the scales, and the dimensions. The mark itself is the this context. The initializer function must return an object with data, facets, and new channels. Any new channels are merged with existing channels, replacing channels of the same name.If an initializer desires a channel that is not supported by the downstream mark, additional channels can be declared using the mark channels option.transform(options, transform) ^0.4.3 ​jsPlot.transform(options, (data, facets) => {
  return {
    data,
    facets: facets.map((I) => I.filter(() => Math.random() > 0.5))
  };
})Given an options object that may specify some basic transforms (filter, sort, or reverse) or a custom transform function, composes those transforms if any with the given transform function, returning a new options object. If a custom transform function is present on the given options, any basic transforms are ignored. Any additional input options are passed through in the returned options object. This method facilitates applying the basic transforms prior to applying the given custom transform and is used internally by Plot’s built-in transforms.initializer(options, initializer) ^0.5.0 ​This helper composes the initializer function with any other transforms present in the options, and returns a new options object. It is used internally by Plot’s built-in initializer transforms.valueof(data, value, type) ​jsPlot.valueof(aapl, "Close")Given an iterable data and some value accessor, returns an array (a column) of the specified type with the corresponding value of each element of the data. The value accessor may be one of the following types:a string - corresponding to the field accessor ((d) => d[value])an accessor function - called as type.from(data, value)a number, Date, or boolean — resulting in an array uniformly filled with the valuean object with a transform method — called as value.transform(data)an array of values - returning the samenull or undefined - returning the sameIf type is specified, it must be Array or a similar class that implements the Array.from interface such as a typed array. When type is Array or a typed array class, the return value of valueof will be an instance of the same (or null or undefined). When type is a typed array, values will be implicitly coerced numbers, and if type is Float64Array, Float32Array, or a subclass of the same, null values will be implicitly replaced with NaN. If type is not specified, valueof may return either an array or a typed array (or null or undefined).valueof is not guaranteed to return a new array. When a transform method is used, or when the given value is an array that is compatible with the requested type, the array may be returned as-is without making a copy.column(source) ^0.4.3 ​jsconst [X, setX] = Plot.column();This helper for constructing derived columns returns a [column, setColumn] array. The column object implements column.transform, returning whatever value was most recently passed to setColumn. If setColumn is not called, then column.transform returns undefined. If a source is specified, then column.label exposes the given source’s label, if any: if source is a string as when representing a named field of data, then column.label is source; otherwise column.label propagates source.label. This allows derived columns to propagate a human-readable axis or legend label.This method is used by Plot’s transforms to derive channels; the associated columns are populated (derived) when the transform option function is invoked.identity ^0.6.2 ​jsPlot.contour(data, {width: w, height: h, fill: Plot.identity})This channel helper returns a source array as-is, avoiding an extra copy when defining a channel as being equal to the data.indexOf ^0.6.6 ​jsPlot.lineY(numbers, {x: Plot.indexOf, y: Plot.identity})This channel helper returns an array of numbers [0, 1, 2, 3, …]. It is used internally by marks with zero-based index defaults for channels.PagerPrevious pageProjectionsNext pageInteractions\n\nTransforms ​Transforms derive data as part of the plot specification. This accelerates what is often the most onerous task in visualization: getting data into the right shape.For example, given a dataset of highway traffic measured as vehicles per hour by location, plotting every observation is straightforward: use a tick (or dot) and assign x = vehicles per hour and y = location. But to draw a quantifiable insight, we may want a summary statistic such as the median traffic by location. 👩‍💻 Below we use the group transform to group by location and apply a median reducer to position the red tick.ForkjsPlot.plot({
  marginLeft: 120,
  x: {label: "Vehicles per hour (thousands)", transform: (x) => x / 1000},
  y: {label: null},
  marks: [
    Plot.ruleX([0]),
    Plot.tickX(
      traffic,
      {x: "vehicles", y: "location", strokeOpacity: 0.3}
    ),
    Plot.tickX(
      traffic,
      Plot.groupY(
        {x: "median"},
        {x: "vehicles", y: "location", stroke: "red", strokeWidth: 4, sort: {y: "x"}}
      )
    )
  ]
})As you might expect, traffic varies significantly throughout the day, so perhaps it would be better to look at the median by hour by location? Instead of grouping only by y, we can group by both x and y to produce a heatmap.ForkjsPlot.plot({
  marginLeft: 120,
  padding: 0,
  y: {label: null},
  color: {scheme: "YlGnBu", legend: true, zero: true},
  marks: [
    Plot.cell(
      traffic,
      Plot.group(
        {fill: "median"},
        {x: (d) => d.date.getUTCHours(), y: "location", fill: "vehicles", inset: 0.5, sort: {y: "fill"}}
      )
    )
  ]
})Plot includes many useful transforms! For example, you can compute a rolling average to smooth a noisy signal, stack layers for a streamgraph, or dodge dots for a beeswarm. Plot’s various built-in transforms include: bin, centroid, dodge, filter, group, hexbin, interval, map, normalize, reverse, select, shuffle, sort, stack, tree, and window. If these don’t meet your needs, you can even implement a custom transform.Transforms are never required — you can always aggregate and derive data yourself outside of Plot, and then pass in the binned values. For example, we could use d3.bin to compute a histogram of athletes’ weights as an array of {x0, x1, length} objects.jsbins = d3.bin().thresholds(80).value((d) => d.weight)(olympians)We can then pass that to the rect mark, assigning to the x1, x2, and y2 channels:jsPlot.rectY(bins, {x1: "x0", x2: "x1", y2: "length"}).plot()INFOThis is for demonstration only; you wouldn’t normally bin “by hand” as shown here.But Plot’s transforms are often more convenient, especially in conjunction with Plot’s other features such as faceting and automatic grouping by z. For example, if we want to add a color encoding to our histogram, we simply add the fill option and the bin transform partitions each bin accordingly; doing this with d3.bin would be a lot more work!ForkjsPlot.rectY(olympians, Plot.binX({y: "count"}, {x: "weight", fill: "sex"})).plot({color: {legend: true}})Plot’s transforms typically take two options objects as arguments: the first object contains the transform options (above, {y: "count"}), while the second object contains mark options to be “passed through” to the mark ({x: "weight", fill: "sex"}). The transform returns a new options object representing the transformed mark options to be passed to a mark.Breaking down the above code:jsconst options = {x: "weight", fill: "sex"}; // initial mark options
const binOptions = {y: "count"}; // bin transform options
const binned = Plot.binX(binOptions, options); // transformed mark options
const rect = Plot.rectY(olympians, binned); // rect mark
const plot = rect.plot({color: {legend: true}}); // plot!TIPIf a transform isn’t doing what you expect, try inspecting the options object returned by the transform. Does it contain the options you expect?Transforms can derive channels (such as y above) as well as changing the default options. For example, the bin transform sets default insets for a one-pixel gap between adjacent rects.Transforms are composable: you can pass options through more than one transform before passing it to a mark. For example, above it’s a bit difficult to compare the weight distribution by sex because there are fewer female than male athletes in the data. We can remove this effect using the normalize transform with the sum reducer.ForkjsPlot.plot({
  y: {percent: true},
  marks: [
    Plot.rectY(
      olympians,
      Plot.normalizeY(
        "sum", // normalize each series by the sum per series
        Plot.binX(
          {y2: "count"}, // disable implicit stack transform
          {x: "weight", fill: "sex", mixBlendMode: "multiply"}
        )
      )
    )
  ]
})And, as you may have wondered above, many of Plot’s marks provide implicit transforms: for example, the rectY mark applies an implicit stackY transform if you use the y option, and the dot mark applies an implicit sort transform to mitigate the effect of occlusion by drawing the smallest dots on top.Custom transforms ​For greater control, you can also implement a custom transform function, allowing data, indexes, or channels to be derived prior to rendering. Custom transforms are rarely implemented directly; see the built-in transforms above. For example, below we implement the filter transform “by hand” as a custom transform to show the unemployment rates only in Michigan metropolitan divisions.ForkjsPlot.plot({
  y: {
    grid: true,
    label: "Unemployment (%)"
  },
  color: {
    domain: [false, true],
    range: ["#ccc", "red"]
  },
  marks: [
    Plot.ruleY([0]),
    Plot.line(bls, {
      x: "date",
      y: "unemployment",
      z: "division",
      transform: (data, facets) => ({
        data,
        facets: facets.map((facet) => {
          return facet.filter((i) => {
            return /, MI /.test(data[i].division);
          });
        })
      })
    })
  ]
})The transform function is passed three arguments, data, facets, and options representing the mark’s data and facet indexes, and the plot’s options; it must then return a {data, facets} object with the transformed data and facet indexes. The facets are represented as a nested array of arrays such as [[0, 1, 3, …], [2, 5, 10, …], …]; each element in facets specifies the zero-based indexes of elements in data that are in a given facet (i.e., have a distinct value in the associated fx or fy dimension).If the transform option is specified, it supersedes any basic transforms (i.e., the filter, sort and reverse options are ignored). However, the transform option is rarely used directly; instead one of Plot’s built-in transforms are used, and these transforms automatically compose with the basic filter, sort and reverse transforms.While transform functions often produce new data or facets, they may return the passed-in data and facets as-is, and often have a side effect of constructing derived channels. For example, the count of elements in a groupX transform might be returned as a new y channel. In this case, the transform is typically expressed as an options transform: a function that takes a mark options object and returns a new, transformed options object, where the returned options object implements the transform option. Transform functions should not mutate the input data or facets. Likewise options transforms should not mutate the input options object.When implementing a custom transform for generic usage, keep in mind that it needs to be compatible with Plot’s faceting system, which partitions the original dataset into discrete subsets.Custom initializers ^0.5.0 ​Initializers are a special class of transform; whereas transforms operate in abstract data space, initializers operate in screen space such as pixel coordinates and colors. For example, initializers can modify a marks’ positions to avoid occlusion. Initializers are invoked after the initial scales are constructed and can modify the channels or derive new channels; these in turn may (or may not, as desired) be passed to scales. Plot’s hexbin and dodge transforms are initializers.You can specify a custom initializer by specifying a function as the mark initializer option. This function is called after the scales have been computed, and receives as inputs the (possibly transformed) array of data, the facets index of elements of this array that belong to each facet, the input channels (as an object of named channels), the scales, and the dimensions. The mark itself is the this context. The initializer function must return an object with data, facets, and new channels. Any new channels are merged with existing channels, replacing channels of the same name.If an initializer desires a channel that is not supported by the downstream mark, additional channels can be declared using the mark channels option.transform(options, transform) ^0.4.3 ​jsPlot.transform(options, (data, facets) => {
  return {
    data,
    facets: facets.map((I) => I.filter(() => Math.random() > 0.5))
  };
})Given an options object that may specify some basic transforms (filter, sort, or reverse) or a custom transform function, composes those transforms if any with the given transform function, returning a new options object. If a custom transform function is present on the given options, any basic transforms are ignored. Any additional input options are passed through in the returned options object. This method facilitates applying the basic transforms prior to applying the given custom transform and is used internally by Plot’s built-in transforms.initializer(options, initializer) ^0.5.0 ​This helper composes the initializer function with any other transforms present in the options, and returns a new options object. It is used internally by Plot’s built-in initializer transforms.valueof(data, value, type) ​jsPlot.valueof(aapl, "Close")Given an iterable data and some value accessor, returns an array (a column) of the specified type with the corresponding value of each element of the data. The value accessor may be one of the following types:a string - corresponding to the field accessor ((d) => d[value])an accessor function - called as type.from(data, value)a number, Date, or boolean — resulting in an array uniformly filled with the valuean object with a transform method — called as value.transform(data)an array of values - returning the samenull or undefined - returning the sameIf type is specified, it must be Array or a similar class that implements the Array.from interface such as a typed array. When type is Array or a typed array class, the return value of valueof will be an instance of the same (or null or undefined). When type is a typed array, values will be implicitly coerced numbers, and if type is Float64Array, Float32Array, or a subclass of the same, null values will be implicitly replaced with NaN. If type is not specified, valueof may return either an array or a typed array (or null or undefined).valueof is not guaranteed to return a new array. When a transform method is used, or when the given value is an array that is compatible with the requested type, the array may be returned as-is without making a copy.column(source) ^0.4.3 ​jsconst [X, setX] = Plot.column();This helper for constructing derived columns returns a [column, setColumn] array. The column object implements column.transform, returning whatever value was most recently passed to setColumn. If setColumn is not called, then column.transform returns undefined. If a source is specified, then column.label exposes the given source’s label, if any: if source is a string as when representing a named field of data, then column.label is source; otherwise column.label propagates source.label. This allows derived columns to propagate a human-readable axis or legend label.This method is used by Plot’s transforms to derive channels; the associated columns are populated (derived) when the transform option function is invoked.identity ^0.6.2 ​jsPlot.contour(data, {width: w, height: h, fill: Plot.identity})This channel helper returns a source array as-is, avoiding an extra copy when defining a channel as being equal to the data.indexOf ^0.6.6 ​jsPlot.lineY(numbers, {x: Plot.indexOf, y: Plot.identity})This channel helper returns an array of numbers [0, 1, 2, 3, …]. It is used internally by marks with zero-based index defaults for channels.\n\n\n\nFacets ​Faceting partitions data by ordinal or categorical value and then repeats a plot for each partition (each facet), producing small multiples for comparison. Faceting is typically enabled by declaring the horizontal↔︎ facet channel fx, the vertical↕︎ facet channel fy, or both for two-dimensional faceting.For example, below we recreate the Trellis display (“reminiscent of garden trelliswork”) of Becker et al. using the dot’s fy channel to declare vertical↕︎ facets, showing the yields of several varieties of barley across several sites for the years 1931 and 1932.ForkjsPlot.plot({
  height: 800,
  marginRight: 90,
  marginLeft: 110,
  grid: true,
  x: {nice: true},
  y: {inset: 5},
  color: {type: "categorical"},
  marks: [
    Plot.frame(),
    Plot.dot(barley, {
      x: "yield",
      y: "variety",
      fy: "site",
      stroke: "year",
      sort: {y: "-x", fy: "-x", reduce: "median"}
    })
  ]
})TIPThis plot uses the sort mark option to order the y and fy scale domains by descending median yield (the associated x values). Without this option, the domains would be sorted alphabetically.TIPUse the frame mark for stronger visual separation of facets.The chart above reveals a likely data collection error: the years appear to be reversed for the Morris site as it is the only site where the yields in 1932 were higher than in 1931. The anomaly in Morris is more obvious if we use directed arrows to show the year-over-year change. The group transform groups the observations by site and variety to compute the change.ForkjsPlot.plot({
  height: 800,
  marginLeft: 110,
  grid: true,
  x: {nice: true},
  y: {inset: 5},
  color: {scheme: "spectral", label: "Change in yield", tickFormat: "+f", legend: true},
  facet: {marginRight: 90},
  marks: [
    Plot.frame(),
    Plot.arrow(barley, Plot.groupY({
      x1: "first",
      x2: "last",
      stroke: ([x1, x2]) => x2 - x1 // year-over-year difference
    }, {
      x: "yield",
      y: "variety",
      fy: "site",
      stroke: "yield",
      strokeWidth: 2,
      sort: {y: "-x1", fy: "-x1", reduce: "median"}
    }))
  ]
})INFOHere the sort order has changed slightly: the y and fy domains are sorted by the median x1 values, which are the yields for 1931.Faceting requires ordinal or categorical data because there are a discrete number of facets; the associated fx and fy scales are band scales. Quantitative or temporal data can be made ordinal by binning, say using Math.floor. Or, use the interval scale option on the fx or fy scale. Below, we produce a box plot of the weights (in kilograms) of Olympic athletes, faceted by height binned at a 10cm (0.1 meter) interval.ForkjsPlot.plot({
  fy: {
    grid: true,
    tickFormat: ".1f",
    interval: 0.1, // 10cm
    reverse: true
  },
  marks: [
    Plot.boxX(olympians.filter((d) => d.height), {x: "weight", fy: "height"})
  ]
})TIPIf you are interested in automatic faceting for quantitative data, please upvote #14.When both fx and fy channels are specified, two-dimensional faceting results, as in the faceted scatterplot of penguin culmen measurements below. The horizontal↔︎ facet shows sex (with the rightmost column representing penguins whose sex field is null, indicating missing data), while the vertical↕︎ facet shows species.ForkjsPlot.plot({
  grid: true,
  marginRight: 60,
  facet: {label: null},
  marks: [
    Plot.frame(),
    Plot.dot(penguins, {
      x: "culmen_length_mm",
      y: "culmen_depth_mm",
      fx: "sex",
      fy: "species"
    })
  ]
})You can mix-and-match faceted and non-faceted marks within the same plot. The non-faceted marks will be repeated across all facets. This is useful for decoration marks, such as a frame, and also for context: below, the entire population of penguins is repeated in each facet as small gray dots, making it easier to see how each facet compares to the whole.ForkjsPlot.plot({
  grid: true,
  marginRight: 60,
  facet: {label: null},
  marks: [
    Plot.frame(),
    Plot.dot(penguins, {
      x: "culmen_length_mm",
      y: "culmen_depth_mm",
      fill: "#aaa",
      r: 1
    }),
    Plot.dot(penguins, {
      x: "culmen_length_mm",
      y: "culmen_depth_mm",
      fx: "sex",
      fy: "species"
    })
  ]
})TIPSet the facet mark option to exclude to draw only the dots not in the current facet.When there are many facets, facets may be small and hard to read; you may need to increase the plot’s width or height. Alternatively, you can wrap facets by computing a row and column number as fy and fx. Below, small multiples of varying unemployment counts across industries are shown in a three-column display.ForkjsPlot.plot((() => {
  const n = 3; // number of facet columns
  const keys = Array.from(d3.union(industries.map((d) => d.industry)));
  const index = new Map(keys.map((key, i) => [key, i]));
  const fx = (key) => index.get(key) % n;
  const fy = (key) => Math.floor(index.get(key) / n);
  return {
    height: 300,
    axis: null,
    y: {insetTop: 10},
    fx: {padding: 0.03},
    marks: [
      Plot.areaY(industries, Plot.normalizeY("extent", {
        x: "date",
        y: "unemployed",
        fx: (d) => fx(d.industry),
        fy: (d) => fy(d.industry)
      })),
      Plot.text(keys, {fx, fy, frameAnchor: "top-left", dx: 6, dy: 6}),
      Plot.frame()
    ]
  };
})())TIPIf you are interested in automatic facet wrapping, please upvote #277.INFOThis example uses an immediately-invoked function expression (IIFE) to declare local variables.The above chart also demonstrates faceted annotations, using a text mark to label the facet in lieu of facet axes. Below, we apply a single text annotation to the Adelie facet by setting the fy channel to a single-element array parallel to the data.ForkjsPlot.plot({
  marginLeft: 60,
  marginRight: 60,
  grid: true,
  y: {label: null},
  fy: {label: null},
  color: {legend: true},
  marks: [
    Plot.barX(penguins, Plot.groupY({x: "count"}, {fy: "species", y: "island", fill: "sex"})),
    Plot.text([`While Chinstrap and Gentoo penguins were each observed on only one island, Adelie penguins were observed on all three islands.`], {
      fy: ["Adelie"],
      frameAnchor: "top-right",
      lineWidth: 18,
      dx: -6,
      dy: 6
    }),
    Plot.frame()
  ]
})Mark facet options ​Facets can be defined for each mark via the fx or fy channels. ^0.6.1 The fx and fy channels are computed prior to the mark’s transform, if any (i.e., facet channels are not transformed). Alternatively, the facet plot option allows top-level faceting based on data.Faceting can be explicitly enabled or disabled on a mark with the facet option, which accepts the following values:auto (default) - automatically determine if this mark should be facetedinclude (or true) - draw the subset of the mark’s data in the current facetexclude - draw the subset of the mark’s data not in the current facetsuper - draw this mark in a single frame that covers all facetsnull (or false) - repeat this mark’s data across all facets (i.e., no faceting)When mark-level faceting is used, the default auto setting is equivalent to include: the mark will be faceted if either the fx or fy channel option (or both) is specified. The null or false option will disable faceting, while exclude draws the subset of the mark’s data not in the current facet. When a mark uses super faceting, it is not allowed to use position scales (x, y, fx, or fy); super faceting is intended for decorations, such as labels and legends.The facetAnchor option ^0.6.3 controls the placement of the mark with respect to the facets. Based on the value, the mark will be displayed on:null - non-empty facetstop, right, bottom, or left - the given sidetop-empty, right-empty, bottom-empty, or left-empty - adjacent empty facet or sideempty - empty facetsThe facetAnchor option defaults to null for all marks except axis marks, whose default depends on the axis orientation and associated scale.When using top-level faceting, if the mark data is parallel to the facet data (i.e., it has the same length and order), but is not strictly equal (===), you can enable faceting by specifying the facet option to include (or equivalently true). Likewise you can disable faceting by setting the facet option to null or false. Finally, the facet option supports the exclude option to select all data points that are not part of the current facet, allowing “background” marks for context.When top-level faceting is used, the default auto setting is equivalent to include when the mark data is strictly equal to the top-level facet data; otherwise it is equivalent to null. When the include or exclude facet mode is chosen, the mark data must be parallel to the top-level facet data: the data must have the same length and order. If the data are not parallel, then the wrong data may be shown in each facet. The default auto therefore requires strict equality (===) for safety, and using the facet data as mark data is recommended when using the exclude facet mode. (To construct parallel data safely, consider using array.map on the facet data.)Plot facet options ​The facet plot option provides addition control over facet position scales and axes:marginTop - the top marginmarginRight - the right marginmarginBottom - the bottom marginmarginLeft - the left marginmargin - shorthand for the four marginsgrid - if true, draw grid lines for each facetlabel - if null, disable default facet axis labelsThe facet margin options behave largely the same as the margin plot options; the only difference is the positioning of the associated scale label for the x and y scales. Likewise, the grid and label options have the same meaning as the plot options, except the facet options only apply to the fx and fy scales.The facet plot option is also an alternative to the fx and fy mark options. It is useful when multiple marks share the same data; the x and y facet channels are then shared by all marks that use the facet data. (Other marks will be repeated across facets.) For example, we can visualize the famous Anscombe’s quartet as a scatterplot with horizontal facets.ForkjsPlot.plot({
  grid: true,
  aspectRatio: 0.5,
  facet: {data: anscombe, x: "series"},
  marks: [
    Plot.frame(),
    Plot.line(anscombe, {x: "x", y: "y"}),
    Plot.dot(anscombe, {x: "x", y: "y"})
  ]
})For top-level faceting, these facet options determine the facets:data - the data to be facetedx - the horizontal↔︎ position; bound to the fx scaley - the vertical↕︎ position; bound to the fy scaleWith top-level faceting, any mark that uses the specified facet data will be faceted by default, whereas marks that use different data will be repeated across all facets. Use the mark facet option to change the behavior.Facet scales ​When faceting, two additional band scales may be configured:fx - the horizontal↔︎ position, a band scalefy - the vertical↕︎ position, a band scaleYou can adjust the space between facets using the padding, round, and align scale options.\n\nSearchK0.6.17GitHub️ 4.6kOn this pageFacets ​Faceting partitions data by ordinal or categorical value and then repeats a plot for each partition (each facet), producing small multiples for comparison. Faceting is typically enabled by declaring the horizontal↔︎ facet channel fx, the vertical↕︎ facet channel fy, or both for two-dimensional faceting.For example, below we recreate the Trellis display (“reminiscent of garden trelliswork”) of Becker et al. using the dot’s fy channel to declare vertical↕︎ facets, showing the yields of several varieties of barley across several sites for the years 1931 and 1932.ForkjsPlot.plot({
  height: 800,
  marginRight: 90,
  marginLeft: 110,
  grid: true,
  x: {nice: true},
  y: {inset: 5},
  color: {type: "categorical"},
  marks: [
    Plot.frame(),
    Plot.dot(barley, {
      x: "yield",
      y: "variety",
      fy: "site",
      stroke: "year",
      sort: {y: "-x", fy: "-x", reduce: "median"}
    })
  ]
})TIPThis plot uses the sort mark option to order the y and fy scale domains by descending median yield (the associated x values). Without this option, the domains would be sorted alphabetically.TIPUse the frame mark for stronger visual separation of facets.The chart above reveals a likely data collection error: the years appear to be reversed for the Morris site as it is the only site where the yields in 1932 were higher than in 1931. The anomaly in Morris is more obvious if we use directed arrows to show the year-over-year change. The group transform groups the observations by site and variety to compute the change.ForkjsPlot.plot({
  height: 800,
  marginLeft: 110,
  grid: true,
  x: {nice: true},
  y: {inset: 5},
  color: {scheme: "spectral", label: "Change in yield", tickFormat: "+f", legend: true},
  facet: {marginRight: 90},
  marks: [
    Plot.frame(),
    Plot.arrow(barley, Plot.groupY({
      x1: "first",
      x2: "last",
      stroke: ([x1, x2]) => x2 - x1 // year-over-year difference
    }, {
      x: "yield",
      y: "variety",
      fy: "site",
      stroke: "yield",
      strokeWidth: 2,
      sort: {y: "-x1", fy: "-x1", reduce: "median"}
    }))
  ]
})INFOHere the sort order has changed slightly: the y and fy domains are sorted by the median x1 values, which are the yields for 1931.Faceting requires ordinal or categorical data because there are a discrete number of facets; the associated fx and fy scales are band scales. Quantitative or temporal data can be made ordinal by binning, say using Math.floor. Or, use the interval scale option on the fx or fy scale. Below, we produce a box plot of the weights (in kilograms) of Olympic athletes, faceted by height binned at a 10cm (0.1 meter) interval.ForkjsPlot.plot({
  fy: {
    grid: true,
    tickFormat: ".1f",
    interval: 0.1, // 10cm
    reverse: true
  },
  marks: [
    Plot.boxX(olympians.filter((d) => d.height), {x: "weight", fy: "height"})
  ]
})TIPIf you are interested in automatic faceting for quantitative data, please upvote #14.When both fx and fy channels are specified, two-dimensional faceting results, as in the faceted scatterplot of penguin culmen measurements below. The horizontal↔︎ facet shows sex (with the rightmost column representing penguins whose sex field is null, indicating missing data), while the vertical↕︎ facet shows species.ForkjsPlot.plot({
  grid: true,
  marginRight: 60,
  facet: {label: null},
  marks: [
    Plot.frame(),
    Plot.dot(penguins, {
      x: "culmen_length_mm",
      y: "culmen_depth_mm",
      fx: "sex",
      fy: "species"
    })
  ]
})You can mix-and-match faceted and non-faceted marks within the same plot. The non-faceted marks will be repeated across all facets. This is useful for decoration marks, such as a frame, and also for context: below, the entire population of penguins is repeated in each facet as small gray dots, making it easier to see how each facet compares to the whole.ForkjsPlot.plot({
  grid: true,
  marginRight: 60,
  facet: {label: null},
  marks: [
    Plot.frame(),
    Plot.dot(penguins, {
      x: "culmen_length_mm",
      y: "culmen_depth_mm",
      fill: "#aaa",
      r: 1
    }),
    Plot.dot(penguins, {
      x: "culmen_length_mm",
      y: "culmen_depth_mm",
      fx: "sex",
      fy: "species"
    })
  ]
})TIPSet the facet mark option to exclude to draw only the dots not in the current facet.When there are many facets, facets may be small and hard to read; you may need to increase the plot’s width or height. Alternatively, you can wrap facets by computing a row and column number as fy and fx. Below, small multiples of varying unemployment counts across industries are shown in a three-column display.ForkjsPlot.plot((() => {
  const n = 3; // number of facet columns
  const keys = Array.from(d3.union(industries.map((d) => d.industry)));
  const index = new Map(keys.map((key, i) => [key, i]));
  const fx = (key) => index.get(key) % n;
  const fy = (key) => Math.floor(index.get(key) / n);
  return {
    height: 300,
    axis: null,
    y: {insetTop: 10},
    fx: {padding: 0.03},
    marks: [
      Plot.areaY(industries, Plot.normalizeY("extent", {
        x: "date",
        y: "unemployed",
        fx: (d) => fx(d.industry),
        fy: (d) => fy(d.industry)
      })),
      Plot.text(keys, {fx, fy, frameAnchor: "top-left", dx: 6, dy: 6}),
      Plot.frame()
    ]
  };
})())TIPIf you are interested in automatic facet wrapping, please upvote #277.INFOThis example uses an immediately-invoked function expression (IIFE) to declare local variables.The above chart also demonstrates faceted annotations, using a text mark to label the facet in lieu of facet axes. Below, we apply a single text annotation to the Adelie facet by setting the fy channel to a single-element array parallel to the data.ForkjsPlot.plot({
  marginLeft: 60,
  marginRight: 60,
  grid: true,
  y: {label: null},
  fy: {label: null},
  color: {legend: true},
  marks: [
    Plot.barX(penguins, Plot.groupY({x: "count"}, {fy: "species", y: "island", fill: "sex"})),
    Plot.text([`While Chinstrap and Gentoo penguins were each observed on only one island, Adelie penguins were observed on all three islands.`], {
      fy: ["Adelie"],
      frameAnchor: "top-right",
      lineWidth: 18,
      dx: -6,
      dy: 6
    }),
    Plot.frame()
  ]
})Mark facet options ​Facets can be defined for each mark via the fx or fy channels. ^0.6.1 The fx and fy channels are computed prior to the mark’s transform, if any (i.e., facet channels are not transformed). Alternatively, the facet plot option allows top-level faceting based on data.Faceting can be explicitly enabled or disabled on a mark with the facet option, which accepts the following values:auto (default) - automatically determine if this mark should be facetedinclude (or true) - draw the subset of the mark’s data in the current facetexclude - draw the subset of the mark’s data not in the current facetsuper - draw this mark in a single frame that covers all facetsnull (or false) - repeat this mark’s data across all facets (i.e., no faceting)When mark-level faceting is used, the default auto setting is equivalent to include: the mark will be faceted if either the fx or fy channel option (or both) is specified. The null or false option will disable faceting, while exclude draws the subset of the mark’s data not in the current facet. When a mark uses super faceting, it is not allowed to use position scales (x, y, fx, or fy); super faceting is intended for decorations, such as labels and legends.The facetAnchor option ^0.6.3 controls the placement of the mark with respect to the facets. Based on the value, the mark will be displayed on:null - non-empty facetstop, right, bottom, or left - the given sidetop-empty, right-empty, bottom-empty, or left-empty - adjacent empty facet or sideempty - empty facetsThe facetAnchor option defaults to null for all marks except axis marks, whose default depends on the axis orientation and associated scale.When using top-level faceting, if the mark data is parallel to the facet data (i.e., it has the same length and order), but is not strictly equal (===), you can enable faceting by specifying the facet option to include (or equivalently true). Likewise you can disable faceting by setting the facet option to null or false. Finally, the facet option supports the exclude option to select all data points that are not part of the current facet, allowing “background” marks for context.When top-level faceting is used, the default auto setting is equivalent to include when the mark data is strictly equal to the top-level facet data; otherwise it is equivalent to null. When the include or exclude facet mode is chosen, the mark data must be parallel to the top-level facet data: the data must have the same length and order. If the data are not parallel, then the wrong data may be shown in each facet. The default auto therefore requires strict equality (===) for safety, and using the facet data as mark data is recommended when using the exclude facet mode. (To construct parallel data safely, consider using array.map on the facet data.)Plot facet options ​The facet plot option provides addition control over facet position scales and axes:marginTop - the top marginmarginRight - the right marginmarginBottom - the bottom marginmarginLeft - the left marginmargin - shorthand for the four marginsgrid - if true, draw grid lines for each facetlabel - if null, disable default facet axis labelsThe facet margin options behave largely the same as the margin plot options; the only difference is the positioning of the associated scale label for the x and y scales. Likewise, the grid and label options have the same meaning as the plot options, except the facet options only apply to the fx and fy scales.The facet plot option is also an alternative to the fx and fy mark options. It is useful when multiple marks share the same data; the x and y facet channels are then shared by all marks that use the facet data. (Other marks will be repeated across facets.) For example, we can visualize the famous Anscombe’s quartet as a scatterplot with horizontal facets.ForkjsPlot.plot({
  grid: true,
  aspectRatio: 0.5,
  facet: {data: anscombe, x: "series"},
  marks: [
    Plot.frame(),
    Plot.line(anscombe, {x: "x", y: "y"}),
    Plot.dot(anscombe, {x: "x", y: "y"})
  ]
})For top-level faceting, these facet options determine the facets:data - the data to be facetedx - the horizontal↔︎ position; bound to the fx scaley - the vertical↕︎ position; bound to the fy scaleWith top-level faceting, any mark that uses the specified facet data will be faceted by default, whereas marks that use different data will be repeated across all facets. Use the mark facet option to change the behavior.Facet scales ​When faceting, two additional band scales may be configured:fx - the horizontal↔︎ position, a band scalefy - the vertical↕︎ position, a band scaleYou can adjust the space between facets using the padding, round, and align scale options.PagerPrevious pageInteractionsNext pageLegends\n\nFacets ​Faceting partitions data by ordinal or categorical value and then repeats a plot for each partition (each facet), producing small multiples for comparison. Faceting is typically enabled by declaring the horizontal↔︎ facet channel fx, the vertical↕︎ facet channel fy, or both for two-dimensional faceting.For example, below we recreate the Trellis display (“reminiscent of garden trelliswork”) of Becker et al. using the dot’s fy channel to declare vertical↕︎ facets, showing the yields of several varieties of barley across several sites for the years 1931 and 1932.ForkjsPlot.plot({
  height: 800,
  marginRight: 90,
  marginLeft: 110,
  grid: true,
  x: {nice: true},
  y: {inset: 5},
  color: {type: "categorical"},
  marks: [
    Plot.frame(),
    Plot.dot(barley, {
      x: "yield",
      y: "variety",
      fy: "site",
      stroke: "year",
      sort: {y: "-x", fy: "-x", reduce: "median"}
    })
  ]
})TIPThis plot uses the sort mark option to order the y and fy scale domains by descending median yield (the associated x values). Without this option, the domains would be sorted alphabetically.TIPUse the frame mark for stronger visual separation of facets.The chart above reveals a likely data collection error: the years appear to be reversed for the Morris site as it is the only site where the yields in 1932 were higher than in 1931. The anomaly in Morris is more obvious if we use directed arrows to show the year-over-year change. The group transform groups the observations by site and variety to compute the change.ForkjsPlot.plot({
  height: 800,
  marginLeft: 110,
  grid: true,
  x: {nice: true},
  y: {inset: 5},
  color: {scheme: "spectral", label: "Change in yield", tickFormat: "+f", legend: true},
  facet: {marginRight: 90},
  marks: [
    Plot.frame(),
    Plot.arrow(barley, Plot.groupY({
      x1: "first",
      x2: "last",
      stroke: ([x1, x2]) => x2 - x1 // year-over-year difference
    }, {
      x: "yield",
      y: "variety",
      fy: "site",
      stroke: "yield",
      strokeWidth: 2,
      sort: {y: "-x1", fy: "-x1", reduce: "median"}
    }))
  ]
})INFOHere the sort order has changed slightly: the y and fy domains are sorted by the median x1 values, which are the yields for 1931.Faceting requires ordinal or categorical data because there are a discrete number of facets; the associated fx and fy scales are band scales. Quantitative or temporal data can be made ordinal by binning, say using Math.floor. Or, use the interval scale option on the fx or fy scale. Below, we produce a box plot of the weights (in kilograms) of Olympic athletes, faceted by height binned at a 10cm (0.1 meter) interval.ForkjsPlot.plot({
  fy: {
    grid: true,
    tickFormat: ".1f",
    interval: 0.1, // 10cm
    reverse: true
  },
  marks: [
    Plot.boxX(olympians.filter((d) => d.height), {x: "weight", fy: "height"})
  ]
})TIPIf you are interested in automatic faceting for quantitative data, please upvote #14.When both fx and fy channels are specified, two-dimensional faceting results, as in the faceted scatterplot of penguin culmen measurements below. The horizontal↔︎ facet shows sex (with the rightmost column representing penguins whose sex field is null, indicating missing data), while the vertical↕︎ facet shows species.ForkjsPlot.plot({
  grid: true,
  marginRight: 60,
  facet: {label: null},
  marks: [
    Plot.frame(),
    Plot.dot(penguins, {
      x: "culmen_length_mm",
      y: "culmen_depth_mm",
      fx: "sex",
      fy: "species"
    })
  ]
})You can mix-and-match faceted and non-faceted marks within the same plot. The non-faceted marks will be repeated across all facets. This is useful for decoration marks, such as a frame, and also for context: below, the entire population of penguins is repeated in each facet as small gray dots, making it easier to see how each facet compares to the whole.ForkjsPlot.plot({
  grid: true,
  marginRight: 60,
  facet: {label: null},
  marks: [
    Plot.frame(),
    Plot.dot(penguins, {
      x: "culmen_length_mm",
      y: "culmen_depth_mm",
      fill: "#aaa",
      r: 1
    }),
    Plot.dot(penguins, {
      x: "culmen_length_mm",
      y: "culmen_depth_mm",
      fx: "sex",
      fy: "species"
    })
  ]
})TIPSet the facet mark option to exclude to draw only the dots not in the current facet.When there are many facets, facets may be small and hard to read; you may need to increase the plot’s width or height. Alternatively, you can wrap facets by computing a row and column number as fy and fx. Below, small multiples of varying unemployment counts across industries are shown in a three-column display.ForkjsPlot.plot((() => {
  const n = 3; // number of facet columns
  const keys = Array.from(d3.union(industries.map((d) => d.industry)));
  const index = new Map(keys.map((key, i) => [key, i]));
  const fx = (key) => index.get(key) % n;
  const fy = (key) => Math.floor(index.get(key) / n);
  return {
    height: 300,
    axis: null,
    y: {insetTop: 10},
    fx: {padding: 0.03},
    marks: [
      Plot.areaY(industries, Plot.normalizeY("extent", {
        x: "date",
        y: "unemployed",
        fx: (d) => fx(d.industry),
        fy: (d) => fy(d.industry)
      })),
      Plot.text(keys, {fx, fy, frameAnchor: "top-left", dx: 6, dy: 6}),
      Plot.frame()
    ]
  };
})())TIPIf you are interested in automatic facet wrapping, please upvote #277.INFOThis example uses an immediately-invoked function expression (IIFE) to declare local variables.The above chart also demonstrates faceted annotations, using a text mark to label the facet in lieu of facet axes. Below, we apply a single text annotation to the Adelie facet by setting the fy channel to a single-element array parallel to the data.ForkjsPlot.plot({
  marginLeft: 60,
  marginRight: 60,
  grid: true,
  y: {label: null},
  fy: {label: null},
  color: {legend: true},
  marks: [
    Plot.barX(penguins, Plot.groupY({x: "count"}, {fy: "species", y: "island", fill: "sex"})),
    Plot.text([`While Chinstrap and Gentoo penguins were each observed on only one island, Adelie penguins were observed on all three islands.`], {
      fy: ["Adelie"],
      frameAnchor: "top-right",
      lineWidth: 18,
      dx: -6,
      dy: 6
    }),
    Plot.frame()
  ]
})Mark facet options ​Facets can be defined for each mark via the fx or fy channels. ^0.6.1 The fx and fy channels are computed prior to the mark’s transform, if any (i.e., facet channels are not transformed). Alternatively, the facet plot option allows top-level faceting based on data.Faceting can be explicitly enabled or disabled on a mark with the facet option, which accepts the following values:auto (default) - automatically determine if this mark should be facetedinclude (or true) - draw the subset of the mark’s data in the current facetexclude - draw the subset of the mark’s data not in the current facetsuper - draw this mark in a single frame that covers all facetsnull (or false) - repeat this mark’s data across all facets (i.e., no faceting)When mark-level faceting is used, the default auto setting is equivalent to include: the mark will be faceted if either the fx or fy channel option (or both) is specified. The null or false option will disable faceting, while exclude draws the subset of the mark’s data not in the current facet. When a mark uses super faceting, it is not allowed to use position scales (x, y, fx, or fy); super faceting is intended for decorations, such as labels and legends.The facetAnchor option ^0.6.3 controls the placement of the mark with respect to the facets. Based on the value, the mark will be displayed on:null - non-empty facetstop, right, bottom, or left - the given sidetop-empty, right-empty, bottom-empty, or left-empty - adjacent empty facet or sideempty - empty facetsThe facetAnchor option defaults to null for all marks except axis marks, whose default depends on the axis orientation and associated scale.When using top-level faceting, if the mark data is parallel to the facet data (i.e., it has the same length and order), but is not strictly equal (===), you can enable faceting by specifying the facet option to include (or equivalently true). Likewise you can disable faceting by setting the facet option to null or false. Finally, the facet option supports the exclude option to select all data points that are not part of the current facet, allowing “background” marks for context.When top-level faceting is used, the default auto setting is equivalent to include when the mark data is strictly equal to the top-level facet data; otherwise it is equivalent to null. When the include or exclude facet mode is chosen, the mark data must be parallel to the top-level facet data: the data must have the same length and order. If the data are not parallel, then the wrong data may be shown in each facet. The default auto therefore requires strict equality (===) for safety, and using the facet data as mark data is recommended when using the exclude facet mode. (To construct parallel data safely, consider using array.map on the facet data.)Plot facet options ​The facet plot option provides addition control over facet position scales and axes:marginTop - the top marginmarginRight - the right marginmarginBottom - the bottom marginmarginLeft - the left marginmargin - shorthand for the four marginsgrid - if true, draw grid lines for each facetlabel - if null, disable default facet axis labelsThe facet margin options behave largely the same as the margin plot options; the only difference is the positioning of the associated scale label for the x and y scales. Likewise, the grid and label options have the same meaning as the plot options, except the facet options only apply to the fx and fy scales.The facet plot option is also an alternative to the fx and fy mark options. It is useful when multiple marks share the same data; the x and y facet channels are then shared by all marks that use the facet data. (Other marks will be repeated across facets.) For example, we can visualize the famous Anscombe’s quartet as a scatterplot with horizontal facets.ForkjsPlot.plot({
  grid: true,
  aspectRatio: 0.5,
  facet: {data: anscombe, x: "series"},
  marks: [
    Plot.frame(),
    Plot.line(anscombe, {x: "x", y: "y"}),
    Plot.dot(anscombe, {x: "x", y: "y"})
  ]
})For top-level faceting, these facet options determine the facets:data - the data to be facetedx - the horizontal↔︎ position; bound to the fx scaley - the vertical↕︎ position; bound to the fy scaleWith top-level faceting, any mark that uses the specified facet data will be faceted by default, whereas marks that use different data will be repeated across all facets. Use the mark facet option to change the behavior.Facet scales ​When faceting, two additional band scales may be configured:fx - the horizontal↔︎ position, a band scalefy - the vertical↕︎ position, a band scaleYou can adjust the space between facets using the padding, round, and align scale options.\n\n\n\nProjections ^0.6.1 ​A projection maps abstract coordinates in x and y to pixel positions on screen. Most often, abstract coordinates are spherical (degrees longitude and latitude), as when rendering a geographic map. For example, below we show earthquakes in the last seven days with a magnitude of 2.5 or higher as reported by the USGS. Use the slider to adjust the orthographic projection’s center of longitude. Longitude: 90°ForkjsPlot.plot({
  projection: {type: "orthographic", rotate: [-longitude, -30]},
  r: {transform: (d) => Math.pow(10, d)}, // convert Richter to amplitude
  marks: [
    Plot.geo(land, {fill: "currentColor", fillOpacity: 0.2}),
    Plot.sphere(),
    Plot.dot(earthquakes, {x: "longitude", y: "latitude", r: "magnitude", stroke: "red", fill: "red", fillOpacity: 0.2})
  ]
})Above, a geo mark draws polygons representing land and a sphere mark draws the outline of the globe. A dot mark draws earthquakes as circles sized by magnitude.The geo mark is “projection aware” so that it can handle all the nuances of projecting spherical polygons to the screen — leaning on d3-geo to provide adaptive sampling with configurable precision, antimeridian cutting, and clipping. The dot mark is not; instead, Plot applies the projection in place of the x and y scales. Hence, projections work with any mark that consumes continuous x and y channels — as well as marks that use x1 & y1 and x2 & y2. Each mark implementation decides whether to handle projections specially or to treat the projection as any other position scale. (For example, the line mark is projection-aware to draw geodesics.)INFOMarks that require band scales (bars, cells, and ticks) cannot be used with projections. Likewise one-dimensional marks such as rules cannot be used, though see #1164.Plot provides a variety of built-in projections. And as above, all world projections can be rotated to show a different aspect. Projection: azimuthal-equal-areaazimuthal-equidistantconic-equal-areaconic-equidistantequal-earthequirectangulargnomonicmercatororthographicstereographictransverse-mercatorForkjsPlot.plot({
  projection: "equirectangular",
  marks: [
    Plot.graticule(),
    Plot.geo(land, {fill: "currentColor"}),
    Plot.sphere()
  ]
})Why so many? Each projection has its strengths and weaknesses:conformal projections preserve angles and local shape,equal-area projections preserve area (use these for choropleths),equidistant projections preserve distance from one (or two) points,azimuthal projections expand radially from a central feature,cylindrical projections have symmetry around the axis of rotation,the stereographic projection preserves circles, andthe gnomonic projection displays all great circles as straight lines!No single projection is best at everything. It is impossible, for example, for a projection to be both conformal and equal-area.In addition to world projections, Plot provides the U.S.-centric albers-usa conic equal-area projection with an inset of Alaska and Hawaii. (Note that the scale for Alaska is diminished: it is projected at 0.35× its true relative area.)ForkjsPlot.plot({
  projection: "albers-usa",
  marks: [
    Plot.geo(nation),
    Plot.geo(statemesh, {strokeOpacity: 0.2})
  ]
})TIPUse the albers-usa projection for U.S.-centric choropleth maps.For maps that focus on a specific region, use the domain option to zoom in. This object should be a GeoJSON object. For example, you can use d3.geoCircle to generate a circle of a given radius centered at a given longitude and latitude. You can also use the inset options for a bit of padding around the domain. Radius: 30.0°ForkjsPlot.plot({
  projection: {
    type: "azimuthal-equidistant",
    rotate: [-9, -34],
    domain: circle,
    inset: 10
  },
  marks: [
    Plot.graticule(),
    Plot.geo(land, {fill: "currentColor", fillOpacity: 0.3}),
    Plot.geo(circle, {stroke: "red", strokeWidth: 2}),
    Plot.frame()
  ]
})jscircle = d3.geoCircle().center([9, 34]).radius(radius)()If none of Plot’s built-in projections meet your needs, you can use any of D3’s extended projections by specifying the projection option as a function that returns a D3 projection. Below, a map of Antarctica in a polar aspect of the azimuthal-equidistant projection.ForkjsPlot.plot({
  width: 688,
  height: 688,
  projection: ({width, height}) => d3.geoAzimuthalEquidistant()
    .rotate([0, 90])
    .translate([width / 2, height / 2])
    .scale(width)
    .clipAngle(40),
  marks: [
    Plot.graticule(),
    Plot.geo(land, {fill: "currentColor"}),
    Plot.frame()
  ]
})While this notebook mostly details spherical projections, you can use the identity projection to display planar geometry. For example, below we draw a schematic of the second floor of the Westport House in Dundee, Ireland.ForkjsPlot.geo(westport).plot({projection: {type: "identity", domain: westport}})TIPThere’s also a reflect-y projection in case y points up↑, which is often the case with projected reference systems.Naturally, Plot’s projection system is compatible with its faceting system. Below, a comic strip of sorts shows the locations of Walmart store openings in past decades.ForkjsPlot.plot({
  marginLeft: 0,
  marginRight: 0,
  projection: "albers",
  fx: {
    interval: "10 years",
    tickFormat: (d) => `${d.getUTCFullYear()}’s`,
    label: null
  },
  marks: [
    Plot.geo(statemesh, {strokeOpacity: 0.1}),
    Plot.geo(nation),
    Plot.dot(walmarts, {fx: "date", x: "longitude", y: "latitude", r: 1, fill: "currentColor"})
  ]
})INFOThis uses the interval scale option to bin temporal data into facets by decade.To learn more about mapping with Plot, see our hands-on tutorials:Build your first map with Observable PlotBuild your first choropleth map with Observable PlotProjection options ​The projection plot option applies a two-dimensional (often geographic) projection in place of x and y scales. It is typically used in conjunction with a geo mark to produce a map, but can be used with any mark that supports x and y channels, such as dot, text, arrow, and rect. For marks that use x1, y1, x2, and y2 channels, the two projected points are ⟨x1, y1⟩ and ⟨x2, y2⟩; otherwise, the projected point is ⟨x, y⟩.The following built-in named projections are supported:equirectangular - the equirectangular, or plate carrée, projectionorthographic - the orthographic projectionstereographic - the stereographic projectionmercator - the Mercator projectionequal-earth - the Equal Earth projection by Šavrič et al.azimuthal-equal-area - the azimuthal equal-area projectionazimuthal-equidistant - the azimuthal equidistant projectionconic-conformal - the conic conformal projectionconic-equal-area - the conic equal-area projectionconic-equidistant - the conic equidistant projectiongnomonic - the gnomonic projectiontransverse-mercator - the transverse Mercator projectionalbers - the Albers’ conic equal-area projectionalbers-usa - a composite Albers conic equal-area projection suitable for the United Statesidentity - the identity projection for planar geometryreflect-y - like the identity projection, but y points upnull (default) - the null projection for pre-projected geometry in screen coordinatesIn addition to these named projections, the projection option may be specified as a D3 projection, or any custom projection that implements projection.stream, or a function that receives a configuration object ({width, height, ...options}) and returns such a projection. In the last case, the width and height represent the frame dimensions minus any insets.If the projection option is specified as an object, the following additional projection options are supported:type - one of the projection names aboveparallels - the standard parallels (for conic projections only)precision - the sampling thresholdrotate - a two- or three- element array of Euler angles to rotate the spheredomain - a GeoJSON object to fit in the center of the (inset) frameinset - inset by the given amount in pixels when fitting to the frame (default zero)insetLeft - inset from the left edge of the frame (defaults to inset)insetRight - inset from the right edge of the frame (defaults to inset)insetTop - inset from the top edge of the frame (defaults to inset)insetBottom - inset from the bottom edge of the frame (defaults to inset)clip - the projection clipping methodThe following projection clipping methods are supported for clip:frame or true (default) - clip to the extent of the frame (including margins but not insets)a number - clip to a great circle of the given radius in degrees centered around the originnull or false - do not clipWhereas the clip mark option is implemented using SVG clipping, the clip projection option affects the generated geometry and typically produces smaller SVG output.\n\nSearchK0.6.17GitHub️ 4.6kOn this pageProjections ^0.6.1 ​A projection maps abstract coordinates in x and y to pixel positions on screen. Most often, abstract coordinates are spherical (degrees longitude and latitude), as when rendering a geographic map. For example, below we show earthquakes in the last seven days with a magnitude of 2.5 or higher as reported by the USGS. Use the slider to adjust the orthographic projection’s center of longitude. Longitude: 90°ForkjsPlot.plot({
  projection: {type: "orthographic", rotate: [-longitude, -30]},
  r: {transform: (d) => Math.pow(10, d)}, // convert Richter to amplitude
  marks: [
    Plot.geo(land, {fill: "currentColor", fillOpacity: 0.2}),
    Plot.sphere(),
    Plot.dot(earthquakes, {x: "longitude", y: "latitude", r: "magnitude", stroke: "red", fill: "red", fillOpacity: 0.2})
  ]
})Above, a geo mark draws polygons representing land and a sphere mark draws the outline of the globe. A dot mark draws earthquakes as circles sized by magnitude.The geo mark is “projection aware” so that it can handle all the nuances of projecting spherical polygons to the screen — leaning on d3-geo to provide adaptive sampling with configurable precision, antimeridian cutting, and clipping. The dot mark is not; instead, Plot applies the projection in place of the x and y scales. Hence, projections work with any mark that consumes continuous x and y channels — as well as marks that use x1 & y1 and x2 & y2. Each mark implementation decides whether to handle projections specially or to treat the projection as any other position scale. (For example, the line mark is projection-aware to draw geodesics.)INFOMarks that require band scales (bars, cells, and ticks) cannot be used with projections. Likewise one-dimensional marks such as rules cannot be used, though see #1164.Plot provides a variety of built-in projections. And as above, all world projections can be rotated to show a different aspect. Projection: azimuthal-equal-areaazimuthal-equidistantconic-equal-areaconic-equidistantequal-earthequirectangulargnomonicmercatororthographicstereographictransverse-mercatorForkjsPlot.plot({
  projection: "equirectangular",
  marks: [
    Plot.graticule(),
    Plot.geo(land, {fill: "currentColor"}),
    Plot.sphere()
  ]
})Why so many? Each projection has its strengths and weaknesses:conformal projections preserve angles and local shape,equal-area projections preserve area (use these for choropleths),equidistant projections preserve distance from one (or two) points,azimuthal projections expand radially from a central feature,cylindrical projections have symmetry around the axis of rotation,the stereographic projection preserves circles, andthe gnomonic projection displays all great circles as straight lines!No single projection is best at everything. It is impossible, for example, for a projection to be both conformal and equal-area.In addition to world projections, Plot provides the U.S.-centric albers-usa conic equal-area projection with an inset of Alaska and Hawaii. (Note that the scale for Alaska is diminished: it is projected at 0.35× its true relative area.)ForkjsPlot.plot({
  projection: "albers-usa",
  marks: [
    Plot.geo(nation),
    Plot.geo(statemesh, {strokeOpacity: 0.2})
  ]
})TIPUse the albers-usa projection for U.S.-centric choropleth maps.For maps that focus on a specific region, use the domain option to zoom in. This object should be a GeoJSON object. For example, you can use d3.geoCircle to generate a circle of a given radius centered at a given longitude and latitude. You can also use the inset options for a bit of padding around the domain. Radius: 30.0°ForkjsPlot.plot({
  projection: {
    type: "azimuthal-equidistant",
    rotate: [-9, -34],
    domain: circle,
    inset: 10
  },
  marks: [
    Plot.graticule(),
    Plot.geo(land, {fill: "currentColor", fillOpacity: 0.3}),
    Plot.geo(circle, {stroke: "red", strokeWidth: 2}),
    Plot.frame()
  ]
})jscircle = d3.geoCircle().center([9, 34]).radius(radius)()If none of Plot’s built-in projections meet your needs, you can use any of D3’s extended projections by specifying the projection option as a function that returns a D3 projection. Below, a map of Antarctica in a polar aspect of the azimuthal-equidistant projection.ForkjsPlot.plot({
  width: 688,
  height: 688,
  projection: ({width, height}) => d3.geoAzimuthalEquidistant()
    .rotate([0, 90])
    .translate([width / 2, height / 2])
    .scale(width)
    .clipAngle(40),
  marks: [
    Plot.graticule(),
    Plot.geo(land, {fill: "currentColor"}),
    Plot.frame()
  ]
})While this notebook mostly details spherical projections, you can use the identity projection to display planar geometry. For example, below we draw a schematic of the second floor of the Westport House in Dundee, Ireland.ForkjsPlot.geo(westport).plot({projection: {type: "identity", domain: westport}})TIPThere’s also a reflect-y projection in case y points up↑, which is often the case with projected reference systems.Naturally, Plot’s projection system is compatible with its faceting system. Below, a comic strip of sorts shows the locations of Walmart store openings in past decades.ForkjsPlot.plot({
  marginLeft: 0,
  marginRight: 0,
  projection: "albers",
  fx: {
    interval: "10 years",
    tickFormat: (d) => `${d.getUTCFullYear()}’s`,
    label: null
  },
  marks: [
    Plot.geo(statemesh, {strokeOpacity: 0.1}),
    Plot.geo(nation),
    Plot.dot(walmarts, {fx: "date", x: "longitude", y: "latitude", r: 1, fill: "currentColor"})
  ]
})INFOThis uses the interval scale option to bin temporal data into facets by decade.To learn more about mapping with Plot, see our hands-on tutorials:Build your first map with Observable PlotBuild your first choropleth map with Observable PlotProjection options ​The projection plot option applies a two-dimensional (often geographic) projection in place of x and y scales. It is typically used in conjunction with a geo mark to produce a map, but can be used with any mark that supports x and y channels, such as dot, text, arrow, and rect. For marks that use x1, y1, x2, and y2 channels, the two projected points are ⟨x1, y1⟩ and ⟨x2, y2⟩; otherwise, the projected point is ⟨x, y⟩.The following built-in named projections are supported:equirectangular - the equirectangular, or plate carrée, projectionorthographic - the orthographic projectionstereographic - the stereographic projectionmercator - the Mercator projectionequal-earth - the Equal Earth projection by Šavrič et al.azimuthal-equal-area - the azimuthal equal-area projectionazimuthal-equidistant - the azimuthal equidistant projectionconic-conformal - the conic conformal projectionconic-equal-area - the conic equal-area projectionconic-equidistant - the conic equidistant projectiongnomonic - the gnomonic projectiontransverse-mercator - the transverse Mercator projectionalbers - the Albers’ conic equal-area projectionalbers-usa - a composite Albers conic equal-area projection suitable for the United Statesidentity - the identity projection for planar geometryreflect-y - like the identity projection, but y points upnull (default) - the null projection for pre-projected geometry in screen coordinatesIn addition to these named projections, the projection option may be specified as a D3 projection, or any custom projection that implements projection.stream, or a function that receives a configuration object ({width, height, ...options}) and returns such a projection. In the last case, the width and height represent the frame dimensions minus any insets.If the projection option is specified as an object, the following additional projection options are supported:type - one of the projection names aboveparallels - the standard parallels (for conic projections only)precision - the sampling thresholdrotate - a two- or three- element array of Euler angles to rotate the spheredomain - a GeoJSON object to fit in the center of the (inset) frameinset - inset by the given amount in pixels when fitting to the frame (default zero)insetLeft - inset from the left edge of the frame (defaults to inset)insetRight - inset from the right edge of the frame (defaults to inset)insetTop - inset from the top edge of the frame (defaults to inset)insetBottom - inset from the bottom edge of the frame (defaults to inset)clip - the projection clipping methodThe following projection clipping methods are supported for clip:frame or true (default) - clip to the extent of the frame (including margins but not insets)a number - clip to a great circle of the given radius in degrees centered around the originnull or false - do not clipWhereas the clip mark option is implemented using SVG clipping, the clip projection option affects the generated geometry and typically produces smaller SVG output.PagerPrevious pageScalesNext pageTransforms\n\nProjections ^0.6.1 ​A projection maps abstract coordinates in x and y to pixel positions on screen. Most often, abstract coordinates are spherical (degrees longitude and latitude), as when rendering a geographic map. For example, below we show earthquakes in the last seven days with a magnitude of 2.5 or higher as reported by the USGS. Use the slider to adjust the orthographic projection’s center of longitude. Longitude: 90°ForkjsPlot.plot({
  projection: {type: "orthographic", rotate: [-longitude, -30]},
  r: {transform: (d) => Math.pow(10, d)}, // convert Richter to amplitude
  marks: [
    Plot.geo(land, {fill: "currentColor", fillOpacity: 0.2}),
    Plot.sphere(),
    Plot.dot(earthquakes, {x: "longitude", y: "latitude", r: "magnitude", stroke: "red", fill: "red", fillOpacity: 0.2})
  ]
})Above, a geo mark draws polygons representing land and a sphere mark draws the outline of the globe. A dot mark draws earthquakes as circles sized by magnitude.The geo mark is “projection aware” so that it can handle all the nuances of projecting spherical polygons to the screen — leaning on d3-geo to provide adaptive sampling with configurable precision, antimeridian cutting, and clipping. The dot mark is not; instead, Plot applies the projection in place of the x and y scales. Hence, projections work with any mark that consumes continuous x and y channels — as well as marks that use x1 & y1 and x2 & y2. Each mark implementation decides whether to handle projections specially or to treat the projection as any other position scale. (For example, the line mark is projection-aware to draw geodesics.)INFOMarks that require band scales (bars, cells, and ticks) cannot be used with projections. Likewise one-dimensional marks such as rules cannot be used, though see #1164.Plot provides a variety of built-in projections. And as above, all world projections can be rotated to show a different aspect. Projection: azimuthal-equal-areaazimuthal-equidistantconic-equal-areaconic-equidistantequal-earthequirectangulargnomonicmercatororthographicstereographictransverse-mercatorForkjsPlot.plot({
  projection: "equirectangular",
  marks: [
    Plot.graticule(),
    Plot.geo(land, {fill: "currentColor"}),
    Plot.sphere()
  ]
})Why so many? Each projection has its strengths and weaknesses:conformal projections preserve angles and local shape,equal-area projections preserve area (use these for choropleths),equidistant projections preserve distance from one (or two) points,azimuthal projections expand radially from a central feature,cylindrical projections have symmetry around the axis of rotation,the stereographic projection preserves circles, andthe gnomonic projection displays all great circles as straight lines!No single projection is best at everything. It is impossible, for example, for a projection to be both conformal and equal-area.In addition to world projections, Plot provides the U.S.-centric albers-usa conic equal-area projection with an inset of Alaska and Hawaii. (Note that the scale for Alaska is diminished: it is projected at 0.35× its true relative area.)ForkjsPlot.plot({
  projection: "albers-usa",
  marks: [
    Plot.geo(nation),
    Plot.geo(statemesh, {strokeOpacity: 0.2})
  ]
})TIPUse the albers-usa projection for U.S.-centric choropleth maps.For maps that focus on a specific region, use the domain option to zoom in. This object should be a GeoJSON object. For example, you can use d3.geoCircle to generate a circle of a given radius centered at a given longitude and latitude. You can also use the inset options for a bit of padding around the domain. Radius: 30.0°ForkjsPlot.plot({
  projection: {
    type: "azimuthal-equidistant",
    rotate: [-9, -34],
    domain: circle,
    inset: 10
  },
  marks: [
    Plot.graticule(),
    Plot.geo(land, {fill: "currentColor", fillOpacity: 0.3}),
    Plot.geo(circle, {stroke: "red", strokeWidth: 2}),
    Plot.frame()
  ]
})jscircle = d3.geoCircle().center([9, 34]).radius(radius)()If none of Plot’s built-in projections meet your needs, you can use any of D3’s extended projections by specifying the projection option as a function that returns a D3 projection. Below, a map of Antarctica in a polar aspect of the azimuthal-equidistant projection.ForkjsPlot.plot({
  width: 688,
  height: 688,
  projection: ({width, height}) => d3.geoAzimuthalEquidistant()
    .rotate([0, 90])
    .translate([width / 2, height / 2])
    .scale(width)
    .clipAngle(40),
  marks: [
    Plot.graticule(),
    Plot.geo(land, {fill: "currentColor"}),
    Plot.frame()
  ]
})While this notebook mostly details spherical projections, you can use the identity projection to display planar geometry. For example, below we draw a schematic of the second floor of the Westport House in Dundee, Ireland.ForkjsPlot.geo(westport).plot({projection: {type: "identity", domain: westport}})TIPThere’s also a reflect-y projection in case y points up↑, which is often the case with projected reference systems.Naturally, Plot’s projection system is compatible with its faceting system. Below, a comic strip of sorts shows the locations of Walmart store openings in past decades.ForkjsPlot.plot({
  marginLeft: 0,
  marginRight: 0,
  projection: "albers",
  fx: {
    interval: "10 years",
    tickFormat: (d) => `${d.getUTCFullYear()}’s`,
    label: null
  },
  marks: [
    Plot.geo(statemesh, {strokeOpacity: 0.1}),
    Plot.geo(nation),
    Plot.dot(walmarts, {fx: "date", x: "longitude", y: "latitude", r: 1, fill: "currentColor"})
  ]
})INFOThis uses the interval scale option to bin temporal data into facets by decade.To learn more about mapping with Plot, see our hands-on tutorials:Build your first map with Observable PlotBuild your first choropleth map with Observable PlotProjection options ​The projection plot option applies a two-dimensional (often geographic) projection in place of x and y scales. It is typically used in conjunction with a geo mark to produce a map, but can be used with any mark that supports x and y channels, such as dot, text, arrow, and rect. For marks that use x1, y1, x2, and y2 channels, the two projected points are ⟨x1, y1⟩ and ⟨x2, y2⟩; otherwise, the projected point is ⟨x, y⟩.The following built-in named projections are supported:equirectangular - the equirectangular, or plate carrée, projectionorthographic - the orthographic projectionstereographic - the stereographic projectionmercator - the Mercator projectionequal-earth - the Equal Earth projection by Šavrič et al.azimuthal-equal-area - the azimuthal equal-area projectionazimuthal-equidistant - the azimuthal equidistant projectionconic-conformal - the conic conformal projectionconic-equal-area - the conic equal-area projectionconic-equidistant - the conic equidistant projectiongnomonic - the gnomonic projectiontransverse-mercator - the transverse Mercator projectionalbers - the Albers’ conic equal-area projectionalbers-usa - a composite Albers conic equal-area projection suitable for the United Statesidentity - the identity projection for planar geometryreflect-y - like the identity projection, but y points upnull (default) - the null projection for pre-projected geometry in screen coordinatesIn addition to these named projections, the projection option may be specified as a D3 projection, or any custom projection that implements projection.stream, or a function that receives a configuration object ({width, height, ...options}) and returns such a projection. In the last case, the width and height represent the frame dimensions minus any insets.If the projection option is specified as an object, the following additional projection options are supported:type - one of the projection names aboveparallels - the standard parallels (for conic projections only)precision - the sampling thresholdrotate - a two- or three- element array of Euler angles to rotate the spheredomain - a GeoJSON object to fit in the center of the (inset) frameinset - inset by the given amount in pixels when fitting to the frame (default zero)insetLeft - inset from the left edge of the frame (defaults to inset)insetRight - inset from the right edge of the frame (defaults to inset)insetTop - inset from the top edge of the frame (defaults to inset)insetBottom - inset from the bottom edge of the frame (defaults to inset)clip - the projection clipping methodThe following projection clipping methods are supported for clip:frame or true (default) - clip to the extent of the frame (including margins but not insets)a number - clip to a great circle of the given radius in degrees centered around the originnull or false - do not clipWhereas the clip mark option is implemented using SVG clipping, the clip projection option affects the generated geometry and typically produces smaller SVG output.\n\n\n\nChart cell ​NotebooksThe Chart cell provides a no-code option for building, exploring, and customizing charts with Observable Plot. With point-and-click menus for variable selection, aggregation (e.g. mean, sum, or count), faceting, color mapping, and more, the Chart cell makes it possible for anyone—regardless of programming experience—to quickly create and iterate on data visualizations.Add a Chart cell ​To add a Chart cell, open the add cell menu by clicking the gray plus sign () in the left margin of a notebook. From there, two things can happen:If the previous cell in your notebook contains data (including in a JavaScript, data table, or SQL cell), you will see a suggestion to “Create chart” in gold in the add cell menu. Click to insert a new Chart cell using the previous cell’s data.If the previous cell in your notebook does not contain data, search or navigate to “Chart” in the add cell menu. Click to insert an empty Chart cell, then choose an available data source (from a cell or attached file) using the drop down menu in the cell header.The two add cell menu scenarios for inserting a Chart cell are shown below:Add cell menus for inserting a Chart cell into an Observable notebook. Left: Add cell menu with suggestion to create a Chart cell from data in the previous cell (in this case, the data is named orders). Right: Add cell menu without suggestion, with the Chart cell option highlighted.Once selected, a Chart cell is inserted into the notebook. A new (blank) Chart cell is shown below:An example of a blank Chart cell with a data source.Choosing variables for X and/or Y reveals a chart above the cell:An example of a Chart cell with data source and chosen data dimensions for X and Y.To change the data source in the Chart cell, open the dropdown menu alongside the current data source and select an alternative source that exists in the notebook:Change the data source easily with the data source dropdown.Chart types ​Under the hood, the Chart cell employs Plot.auto—a special mark that automatically selects a mark type that best represents the given dimensions of the data according to some simple heuristics. Depending on selected variable types, the following chart types are currently possible in the Chart cell:When you pick a column for x or y, the Chart cell will show a histogram (or bar chart) of the frequencies of different values in that column. The Chart cell will automatically bin values if the data is numbers or dates, or group them by unique categories if they’re strings. The dropdowns will show the automatic selections that made the chart (like “Auto: count” and “Auto: bar”), which you can always override.Examples ​The screenshots of the charts below are created entirely using the Chart cell.Setting either x or y to a column of your data renders a histogram. Note that, below, the y reducer says “Auto: count” and the mark says “Auto: bar”, each of which you can override.A histogram is being autogenerated as the user has selected a value for the X axis.Selecting numeric columns of your data for x and y, then selecting a category for Facet X, renders a faceted scatterplot. Here we’ve also set color to species.Body mass to flipper length scatterplot faceted by island and colored according to species.Selecting an x and y where one of them (usually x) is continuous and sorted, e.g. by date, then updating the mark to line will produce a line chart. Here, we additionally choose color to visualize different series by location.A line chart using continuous data on the x axis.A stacked bar chart is rendered by selecting one column for x; then, for y, we’ve selected both a column (co2) and the sum reducer; we make it stacked by picking a categorical column for color, which segments the bars by that category.A stacked bar chart made with the Chart cell.Selecting columns for x and y, then choosing a “count” as the reducer for color, will produce a heatmap.A heatmap made using "count" as the reducer for color.Reducers ​For x, y, color, and size, you can pick a reducer from the  menu above the field dropdown. The following reducing functions can be applied: count, distinct, sum, min, max, mean, median and mode. For example, the Chart cell below produces an area chart of pizzeria revenue (sum of the revenue column on the y-axis) over time, with color indicating different days of the week.Pizza revenue by order date stacked by color for the revenue by day of the week.Setting a reducer on one channel (like setting “sum” on y above) implies grouping (for categorical data) or binning (for numeric or temporal data) one or two other channels:Setting a reducer onGroups or bins onTo make axyHorizontal histogramyxVertical histogramcolorx and yHeatmapsizex and yDot plotFields ​With the Chart cell added to a notebook and connected to a data source, you can update field selections using the dropdown menus to control the variables, chart type, color and size channels, and faceting. A long dash (—) in the dropdown menu of any field indicates that a variable has not been selected.FieldDescriptionXSelect the x-axis variable and an optional reducing function to apply (e.g. sum, mean, count). If only one variable is selected, a histogram or bar chart is created by default.YSelect the y-axis variable and an optional reducing function to apply (e.g. sum, mean, count). If only one variable is selected, a histogram or bar chart is created by default.ColorSelect either a single color to apply to all marks or a variable that is mapped to a color channel, and an optional reducing function to apply (e.g. sum, mean, count). Color updates the stroke color for line and scatterplot charts, and the fill color for area, bar, and heatmap charts.SizeSelect a variable that is mapped to dot size ®, and an optional reducing function to apply (e.g. sum, mean, count).Facet XSelect a faceting variable to split the chart into separate panels side-by-size horizontally (one for each distinct value in the faceting variable).Facet YSelect a faceting variable to split the chart into separate panels vertically (one for each distinct value in the faceting variable).MarkSelect a different Plot mark (auto, bar, dot, line, area, or rule).Buttons ​Iterate and explore charts further using other features of the Chart cell that let you clear selections (for one or all fields), swap x and y variable selections, and customize your chart.ButtonDescriptionClear selection for the given field Clear allClear selections for all fieldsSwap X/YSwap selected X and Y variables in chart CustomizeOpen customization pane (to update chart dimensions, margins, labels, gridlines, color scheme, scale types, reverse a scale, add or remove a legend, and add a caption)Data types ​The data type of a column (e.g. numeric, string, date, etc.) may determine what kinds of charts are possible. Icons to the left of the column names in the dropdowns show the data type for each.Data Type IconDescriptionNumericStringDate or datetimeBoolean (true/false)The Size field updates the radius for a dot mark, and can only be updated using quantitative data (i.e. continuous or discrete numeric values).Convert to JavaScript ​You can convert a Chart cell to JavaScript to create a new cell with the underlying, equivalent, Plot.auto code. It’s a regular Plot mark, so you can combine it with other marks or pass in any of the standard Plot options. For more information, see the Plot.auto documentation.One way to enact the conversion is to hit the ‘Convert to JavaScript’ button at the bottom-right corner of a focused Chart cell:The Convert to JavaScript button in a focused chart cell.You can also select the  add cell button below a Chart cell and you’ll see this suggestion:In the Add cell menu of the cell following a Chart cell you see 'Convert to JavaScript' as a menu item.\n\nSearchKobservablehq.com↗On this pageChart cell ​NotebooksThe Chart cell provides a no-code option for building, exploring, and customizing charts with Observable Plot. With point-and-click menus for variable selection, aggregation (e.g. mean, sum, or count), faceting, color mapping, and more, the Chart cell makes it possible for anyone—regardless of programming experience—to quickly create and iterate on data visualizations.Add a Chart cell ​To add a Chart cell, open the add cell menu by clicking the gray plus sign () in the left margin of a notebook. From there, two things can happen:If the previous cell in your notebook contains data (including in a JavaScript, data table, or SQL cell), you will see a suggestion to “Create chart” in gold in the add cell menu. Click to insert a new Chart cell using the previous cell’s data.If the previous cell in your notebook does not contain data, search or navigate to “Chart” in the add cell menu. Click to insert an empty Chart cell, then choose an available data source (from a cell or attached file) using the drop down menu in the cell header.The two add cell menu scenarios for inserting a Chart cell are shown below:Add cell menus for inserting a Chart cell into an Observable notebook. Left: Add cell menu with suggestion to create a Chart cell from data in the previous cell (in this case, the data is named orders). Right: Add cell menu without suggestion, with the Chart cell option highlighted.Once selected, a Chart cell is inserted into the notebook. A new (blank) Chart cell is shown below:An example of a blank Chart cell with a data source.Choosing variables for X and/or Y reveals a chart above the cell:An example of a Chart cell with data source and chosen data dimensions for X and Y.To change the data source in the Chart cell, open the dropdown menu alongside the current data source and select an alternative source that exists in the notebook:Change the data source easily with the data source dropdown.Chart types ​Under the hood, the Chart cell employs Plot.auto—a special mark that automatically selects a mark type that best represents the given dimensions of the data according to some simple heuristics. Depending on selected variable types, the following chart types are currently possible in the Chart cell:When you pick a column for x or y, the Chart cell will show a histogram (or bar chart) of the frequencies of different values in that column. The Chart cell will automatically bin values if the data is numbers or dates, or group them by unique categories if they’re strings. The dropdowns will show the automatic selections that made the chart (like “Auto: count” and “Auto: bar”), which you can always override.Examples ​The screenshots of the charts below are created entirely using the Chart cell.Setting either x or y to a column of your data renders a histogram. Note that, below, the y reducer says “Auto: count” and the mark says “Auto: bar”, each of which you can override.A histogram is being autogenerated as the user has selected a value for the X axis.Selecting numeric columns of your data for x and y, then selecting a category for Facet X, renders a faceted scatterplot. Here we’ve also set color to species.Body mass to flipper length scatterplot faceted by island and colored according to species.Selecting an x and y where one of them (usually x) is continuous and sorted, e.g. by date, then updating the mark to line will produce a line chart. Here, we additionally choose color to visualize different series by location.A line chart using continuous data on the x axis.A stacked bar chart is rendered by selecting one column for x; then, for y, we’ve selected both a column (co2) and the sum reducer; we make it stacked by picking a categorical column for color, which segments the bars by that category.A stacked bar chart made with the Chart cell.Selecting columns for x and y, then choosing a “count” as the reducer for color, will produce a heatmap.A heatmap made using "count" as the reducer for color.Reducers ​For x, y, color, and size, you can pick a reducer from the  menu above the field dropdown. The following reducing functions can be applied: count, distinct, sum, min, max, mean, median and mode. For example, the Chart cell below produces an area chart of pizzeria revenue (sum of the revenue column on the y-axis) over time, with color indicating different days of the week.Pizza revenue by order date stacked by color for the revenue by day of the week.Setting a reducer on one channel (like setting “sum” on y above) implies grouping (for categorical data) or binning (for numeric or temporal data) one or two other channels:Setting a reducer onGroups or bins onTo make axyHorizontal histogramyxVertical histogramcolorx and yHeatmapsizex and yDot plotFields ​With the Chart cell added to a notebook and connected to a data source, you can update field selections using the dropdown menus to control the variables, chart type, color and size channels, and faceting. A long dash (—) in the dropdown menu of any field indicates that a variable has not been selected.FieldDescriptionXSelect the x-axis variable and an optional reducing function to apply (e.g. sum, mean, count). If only one variable is selected, a histogram or bar chart is created by default.YSelect the y-axis variable and an optional reducing function to apply (e.g. sum, mean, count). If only one variable is selected, a histogram or bar chart is created by default.ColorSelect either a single color to apply to all marks or a variable that is mapped to a color channel, and an optional reducing function to apply (e.g. sum, mean, count). Color updates the stroke color for line and scatterplot charts, and the fill color for area, bar, and heatmap charts.SizeSelect a variable that is mapped to dot size ®, and an optional reducing function to apply (e.g. sum, mean, count).Facet XSelect a faceting variable to split the chart into separate panels side-by-size horizontally (one for each distinct value in the faceting variable).Facet YSelect a faceting variable to split the chart into separate panels vertically (one for each distinct value in the faceting variable).MarkSelect a different Plot mark (auto, bar, dot, line, area, or rule).Buttons ​Iterate and explore charts further using other features of the Chart cell that let you clear selections (for one or all fields), swap x and y variable selections, and customize your chart.ButtonDescriptionClear selection for the given field Clear allClear selections for all fieldsSwap X/YSwap selected X and Y variables in chart CustomizeOpen customization pane (to update chart dimensions, margins, labels, gridlines, color scheme, scale types, reverse a scale, add or remove a legend, and add a caption)Data types ​The data type of a column (e.g. numeric, string, date, etc.) may determine what kinds of charts are possible. Icons to the left of the column names in the dropdowns show the data type for each.Data Type IconDescriptionNumericStringDate or datetimeBoolean (true/false)The Size field updates the radius for a dot mark, and can only be updated using quantitative data (i.e. continuous or discrete numeric values).Convert to JavaScript ​You can convert a Chart cell to JavaScript to create a new cell with the underlying, equivalent, Plot.auto code. It’s a regular Plot mark, so you can combine it with other marks or pass in any of the standard Plot options. For more information, see the Plot.auto documentation.One way to enact the conversion is to hit the ‘Convert to JavaScript’ button at the bottom-right corner of a focused Chart cell:The Convert to JavaScript button in a focused chart cell.You can also select the  add cell button below a Chart cell and you’ll see this suggestion:In the Add cell menu of the cell following a Chart cell you see 'Convert to JavaScript' as a menu item.PagerPrevious pageData tableNext pageTeX\n\nChart cell ​NotebooksThe Chart cell provides a no-code option for building, exploring, and customizing charts with Observable Plot. With point-and-click menus for variable selection, aggregation (e.g. mean, sum, or count), faceting, color mapping, and more, the Chart cell makes it possible for anyone—regardless of programming experience—to quickly create and iterate on data visualizations.Add a Chart cell ​To add a Chart cell, open the add cell menu by clicking the gray plus sign () in the left margin of a notebook. From there, two things can happen:If the previous cell in your notebook contains data (including in a JavaScript, data table, or SQL cell), you will see a suggestion to “Create chart” in gold in the add cell menu. Click to insert a new Chart cell using the previous cell’s data.If the previous cell in your notebook does not contain data, search or navigate to “Chart” in the add cell menu. Click to insert an empty Chart cell, then choose an available data source (from a cell or attached file) using the drop down menu in the cell header.The two add cell menu scenarios for inserting a Chart cell are shown below:Add cell menus for inserting a Chart cell into an Observable notebook. Left: Add cell menu with suggestion to create a Chart cell from data in the previous cell (in this case, the data is named orders). Right: Add cell menu without suggestion, with the Chart cell option highlighted.Once selected, a Chart cell is inserted into the notebook. A new (blank) Chart cell is shown below:An example of a blank Chart cell with a data source.Choosing variables for X and/or Y reveals a chart above the cell:An example of a Chart cell with data source and chosen data dimensions for X and Y.To change the data source in the Chart cell, open the dropdown menu alongside the current data source and select an alternative source that exists in the notebook:Change the data source easily with the data source dropdown.Chart types ​Under the hood, the Chart cell employs Plot.auto—a special mark that automatically selects a mark type that best represents the given dimensions of the data according to some simple heuristics. Depending on selected variable types, the following chart types are currently possible in the Chart cell:When you pick a column for x or y, the Chart cell will show a histogram (or bar chart) of the frequencies of different values in that column. The Chart cell will automatically bin values if the data is numbers or dates, or group them by unique categories if they’re strings. The dropdowns will show the automatic selections that made the chart (like “Auto: count” and “Auto: bar”), which you can always override.Examples ​The screenshots of the charts below are created entirely using the Chart cell.Setting either x or y to a column of your data renders a histogram. Note that, below, the y reducer says “Auto: count” and the mark says “Auto: bar”, each of which you can override.A histogram is being autogenerated as the user has selected a value for the X axis.Selecting numeric columns of your data for x and y, then selecting a category for Facet X, renders a faceted scatterplot. Here we’ve also set color to species.Body mass to flipper length scatterplot faceted by island and colored according to species.Selecting an x and y where one of them (usually x) is continuous and sorted, e.g. by date, then updating the mark to line will produce a line chart. Here, we additionally choose color to visualize different series by location.A line chart using continuous data on the x axis.A stacked bar chart is rendered by selecting one column for x; then, for y, we’ve selected both a column (co2) and the sum reducer; we make it stacked by picking a categorical column for color, which segments the bars by that category.A stacked bar chart made with the Chart cell.Selecting columns for x and y, then choosing a “count” as the reducer for color, will produce a heatmap.A heatmap made using "count" as the reducer for color.Reducers ​For x, y, color, and size, you can pick a reducer from the  menu above the field dropdown. The following reducing functions can be applied: count, distinct, sum, min, max, mean, median and mode. For example, the Chart cell below produces an area chart of pizzeria revenue (sum of the revenue column on the y-axis) over time, with color indicating different days of the week.Pizza revenue by order date stacked by color for the revenue by day of the week.Setting a reducer on one channel (like setting “sum” on y above) implies grouping (for categorical data) or binning (for numeric or temporal data) one or two other channels:Setting a reducer onGroups or bins onTo make axyHorizontal histogramyxVertical histogramcolorx and yHeatmapsizex and yDot plotFields ​With the Chart cell added to a notebook and connected to a data source, you can update field selections using the dropdown menus to control the variables, chart type, color and size channels, and faceting. A long dash (—) in the dropdown menu of any field indicates that a variable has not been selected.FieldDescriptionXSelect the x-axis variable and an optional reducing function to apply (e.g. sum, mean, count). If only one variable is selected, a histogram or bar chart is created by default.YSelect the y-axis variable and an optional reducing function to apply (e.g. sum, mean, count). If only one variable is selected, a histogram or bar chart is created by default.ColorSelect either a single color to apply to all marks or a variable that is mapped to a color channel, and an optional reducing function to apply (e.g. sum, mean, count). Color updates the stroke color for line and scatterplot charts, and the fill color for area, bar, and heatmap charts.SizeSelect a variable that is mapped to dot size ®, and an optional reducing function to apply (e.g. sum, mean, count).Facet XSelect a faceting variable to split the chart into separate panels side-by-size horizontally (one for each distinct value in the faceting variable).Facet YSelect a faceting variable to split the chart into separate panels vertically (one for each distinct value in the faceting variable).MarkSelect a different Plot mark (auto, bar, dot, line, area, or rule).Buttons ​Iterate and explore charts further using other features of the Chart cell that let you clear selections (for one or all fields), swap x and y variable selections, and customize your chart.ButtonDescriptionClear selection for the given field Clear allClear selections for all fieldsSwap X/YSwap selected X and Y variables in chart CustomizeOpen customization pane (to update chart dimensions, margins, labels, gridlines, color scheme, scale types, reverse a scale, add or remove a legend, and add a caption)Data types ​The data type of a column (e.g. numeric, string, date, etc.) may determine what kinds of charts are possible. Icons to the left of the column names in the dropdowns show the data type for each.Data Type IconDescriptionNumericStringDate or datetimeBoolean (true/false)The Size field updates the radius for a dot mark, and can only be updated using quantitative data (i.e. continuous or discrete numeric values).Convert to JavaScript ​You can convert a Chart cell to JavaScript to create a new cell with the underlying, equivalent, Plot.auto code. It’s a regular Plot mark, so you can combine it with other marks or pass in any of the standard Plot options. For more information, see the Plot.auto documentation.One way to enact the conversion is to hit the ‘Convert to JavaScript’ button at the bottom-right corner of a focused Chart cell:The Convert to JavaScript button in a focused chart cell.You can also select the  add cell button below a Chart cell and you’ll see this suggestion:In the Add cell menu of the cell following a Chart cell you see 'Convert to JavaScript' as a menu item.\n\n\n\nPlatform Resources PricingSign inContact usNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demoProduct managerData analystNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demoIntroducing the collaborative data canvasGo faster together. Bring cross-functional stakeholders into the data workflow by exploring together in real-time. Increase data literacy, discover different perspectives, and uncover insights as a team.Watch the demoAnalyzeExplore and visualize dataQuery, filter, join, group, derive, and visualize data without hopping between tools. Discover and share insights faster than ever.RefineMake analysis crystal clearFearlessly explore and refine analysis on a spatial canvas. Add annotations as notes to self or others. Evolve ad hoc sketches into powerful interactive data apps.ExtendCode if you want toPoint-and-click, or SQL? It's your choice. Peruse queries with summary tables. Customize charts with JavaScript. All with deeply integrated, helpful AI.CollaborateWork together, smarterMultiplayer editing enables real-time collaboration with everyone — from data engineering to finance. It makes work easier and more fun.For data analystsFor business stakeholdersSpend less time going back-and-forth.Work more efficiently with your data team.Bring cross-functional team members into the data workflow.Make stronger decisions by gaining additional context.PresentShow off your workPresent charts in the canvas or create polished, stakeholder-friendly dashboards in just a few clicks.FEATURESBuild dashboardsCombine visualizations into a stakeholder-friendly dashboard.ShareSend a URL, export to PNG, or send to Slack.Interact with dataBrush and filter during data exploration.Connect to your databaseSupports Snowflake, DuckDB, and Postgres.Write codeUse SQL and build custom charts with code.Customize your workspaceCreate bespoke components for your team.Start conversationsLeave comments and ask questions.Use better defaultsBar charts, bubble maps, histograms, big numbers (and more!) are built-in!Observable opened up a new realm of possibilities for what we could do and offer. We created dynamic, interactive experiences that let users visualize and use climate change data in ways that we couldn’t easily support before.Kaitlyn TrudeauSenior Research Associate at Climate CentralGet started todaySign up for notebooksRequest a demoPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demoProduct managerData analystNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demoIntroducing the collaborative data canvasGo faster together. Bring cross-functional stakeholders into the data workflow by exploring together in real-time. Increase data literacy, discover different perspectives, and uncover insights as a team.Watch the demoAnalyzeExplore and visualize dataQuery, filter, join, group, derive, and visualize data without hopping between tools. Discover and share insights faster than ever.RefineMake analysis crystal clearFearlessly explore and refine analysis on a spatial canvas. Add annotations as notes to self or others. Evolve ad hoc sketches into powerful interactive data apps.ExtendCode if you want toPoint-and-click, or SQL? It's your choice. Peruse queries with summary tables. Customize charts with JavaScript. All with deeply integrated, helpful AI.CollaborateWork together, smarterMultiplayer editing enables real-time collaboration with everyone — from data engineering to finance. It makes work easier and more fun.For data analystsFor business stakeholdersSpend less time going back-and-forth.Work more efficiently with your data team.Bring cross-functional team members into the data workflow.Make stronger decisions by gaining additional context.PresentShow off your workPresent charts in the canvas or create polished, stakeholder-friendly dashboards in just a few clicks.FEATURESBuild dashboardsCombine visualizations into a stakeholder-friendly dashboard.ShareSend a URL, export to PNG, or send to Slack.Interact with dataBrush and filter during data exploration.Connect to your databaseSupports Snowflake, DuckDB, and Postgres.Write codeUse SQL and build custom charts with code.Customize your workspaceCreate bespoke components for your team.Start conversationsLeave comments and ask questions.Use better defaultsBar charts, bubble maps, histograms, big numbers (and more!) are built-in!Observable opened up a new realm of possibilities for what we could do and offer. We created dynamic, interactive experiences that let users visualize and use climate change data in ways that we couldn’t easily support before.Kaitlyn TrudeauSenior Research Associate at Climate CentralGet started todaySign up for notebooksRequest a demo\nNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demoProduct managerData analyst\nNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demoProduct managerData analyst\nNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demoProduct managerData analyst\nNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demoProduct managerData analyst\nNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demoProduct managerData analyst\nNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demo\nNow everyone’s on the data team.\nUse Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.\nGet early accessRequest a demo\nNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demo\nNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demo\nNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demo\nNow everyone’s on the data team.\nUse Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.\nGet early accessRequest a demo\nIntroducing the collaborative data canvasGo faster together. Bring cross-functional stakeholders into the data workflow by exploring together in real-time. Increase data literacy, discover different perspectives, and uncover insights as a team.Watch the demo\nIntroducing the collaborative data canvasGo faster together. Bring cross-functional stakeholders into the data workflow by exploring together in real-time. Increase data literacy, discover different perspectives, and uncover insights as a team.Watch the demo\nIntroducing the collaborative data canvasGo faster together. Bring cross-functional stakeholders into the data workflow by exploring together in real-time. Increase data literacy, discover different perspectives, and uncover insights as a team.\nIntroducing the collaborative data canvas\nGo faster together. Bring cross-functional stakeholders into the data workflow by exploring together in real-time. Increase data literacy, discover different perspectives, and uncover insights as a team.\nAnalyzeExplore and visualize dataQuery, filter, join, group, derive, and visualize data without hopping between tools. Discover and share insights faster than ever.\nAnalyzeExplore and visualize dataQuery, filter, join, group, derive, and visualize data without hopping between tools. Discover and share insights faster than ever.\nAnalyzeExplore and visualize dataQuery, filter, join, group, derive, and visualize data without hopping between tools. Discover and share insights faster than ever.\nAnalyzeExplore and visualize dataQuery, filter, join, group, derive, and visualize data without hopping between tools. Discover and share insights faster than ever.\nExplore and visualize data\nQuery, filter, join, group, derive, and visualize data without hopping between tools. Discover and share insights faster than ever.\nRefineMake analysis crystal clearFearlessly explore and refine analysis on a spatial canvas. Add annotations as notes to self or others. Evolve ad hoc sketches into powerful interactive data apps.\nRefineMake analysis crystal clearFearlessly explore and refine analysis on a spatial canvas. Add annotations as notes to self or others. Evolve ad hoc sketches into powerful interactive data apps.\nRefineMake analysis crystal clearFearlessly explore and refine analysis on a spatial canvas. Add annotations as notes to self or others. Evolve ad hoc sketches into powerful interactive data apps.\nRefineMake analysis crystal clearFearlessly explore and refine analysis on a spatial canvas. Add annotations as notes to self or others. Evolve ad hoc sketches into powerful interactive data apps.\nMake analysis crystal clear\nFearlessly explore and refine analysis on a spatial canvas. Add annotations as notes to self or others. Evolve ad hoc sketches into powerful interactive data apps.\nExtendCode if you want toPoint-and-click, or SQL? It's your choice. Peruse queries with summary tables. Customize charts with JavaScript. All with deeply integrated, helpful AI.\nExtendCode if you want toPoint-and-click, or SQL? It's your choice. Peruse queries with summary tables. Customize charts with JavaScript. All with deeply integrated, helpful AI.\nExtendCode if you want toPoint-and-click, or SQL? It's your choice. Peruse queries with summary tables. Customize charts with JavaScript. All with deeply integrated, helpful AI.\nExtendCode if you want toPoint-and-click, or SQL? It's your choice. Peruse queries with summary tables. Customize charts with JavaScript. All with deeply integrated, helpful AI.\nPoint-and-click, or SQL? It's your choice. Peruse queries with summary tables. Customize charts with JavaScript. All with deeply integrated, helpful AI.\nCollaborateWork together, smarterMultiplayer editing enables real-time collaboration with everyone — from data engineering to finance. It makes work easier and more fun.For data analystsFor business stakeholdersSpend less time going back-and-forth.Work more efficiently with your data team.Bring cross-functional team members into the data workflow.Make stronger decisions by gaining additional context.\nCollaborateWork together, smarterMultiplayer editing enables real-time collaboration with everyone — from data engineering to finance. It makes work easier and more fun.For data analystsFor business stakeholdersSpend less time going back-and-forth.Work more efficiently with your data team.Bring cross-functional team members into the data workflow.Make stronger decisions by gaining additional context.\nCollaborateWork together, smarterMultiplayer editing enables real-time collaboration with everyone — from data engineering to finance. It makes work easier and more fun.For data analystsFor business stakeholdersSpend less time going back-and-forth.Work more efficiently with your data team.Bring cross-functional team members into the data workflow.Make stronger decisions by gaining additional context.\nCollaborateWork together, smarterMultiplayer editing enables real-time collaboration with everyone — from data engineering to finance. It makes work easier and more fun.For data analystsFor business stakeholdersSpend less time going back-and-forth.Work more efficiently with your data team.Bring cross-functional team members into the data workflow.Make stronger decisions by gaining additional context.\nWork together, smarter\nMultiplayer editing enables real-time collaboration with everyone — from data engineering to finance. It makes work easier and more fun.\nFor data analystsFor business stakeholdersSpend less time going back-and-forth.Work more efficiently with your data team.Bring cross-functional team members into the data workflow.Make stronger decisions by gaining additional context.\nFor data analystsFor business stakeholdersSpend less time going back-and-forth.Work more efficiently with your data team.Bring cross-functional team members into the data workflow.Make stronger decisions by gaining additional context.\nFor business stakeholders\nFor business stakeholders\nFor business stakeholders\nSpend less time going back-and-forth.\nSpend less time going back-and-forth.\nWork more efficiently with your data team.\nWork more efficiently with your data team.\nBring cross-functional team members into the data workflow.\nBring cross-functional team members into the data workflow.\nMake stronger decisions by gaining additional context.\nMake stronger decisions by gaining additional context.\nPresentShow off your workPresent charts in the canvas or create polished, stakeholder-friendly dashboards in just a few clicks.\nPresentShow off your workPresent charts in the canvas or create polished, stakeholder-friendly dashboards in just a few clicks.\nPresentShow off your workPresent charts in the canvas or create polished, stakeholder-friendly dashboards in just a few clicks.\nPresentShow off your workPresent charts in the canvas or create polished, stakeholder-friendly dashboards in just a few clicks.\nPresent charts in the canvas or create polished, stakeholder-friendly dashboards in just a few clicks.\nFEATURESBuild dashboardsCombine visualizations into a stakeholder-friendly dashboard.ShareSend a URL, export to PNG, or send to Slack.Interact with dataBrush and filter during data exploration.Connect to your databaseSupports Snowflake, DuckDB, and Postgres.Write codeUse SQL and build custom charts with code.Customize your workspaceCreate bespoke components for your team.Start conversationsLeave comments and ask questions.Use better defaultsBar charts, bubble maps, histograms, big numbers (and more!) are built-in!\nFEATURESBuild dashboardsCombine visualizations into a stakeholder-friendly dashboard.ShareSend a URL, export to PNG, or send to Slack.Interact with dataBrush and filter during data exploration.Connect to your databaseSupports Snowflake, DuckDB, and Postgres.Write codeUse SQL and build custom charts with code.Customize your workspaceCreate bespoke components for your team.Start conversationsLeave comments and ask questions.Use better defaultsBar charts, bubble maps, histograms, big numbers (and more!) are built-in!\nFEATURESBuild dashboardsCombine visualizations into a stakeholder-friendly dashboard.ShareSend a URL, export to PNG, or send to Slack.Interact with dataBrush and filter during data exploration.Connect to your databaseSupports Snowflake, DuckDB, and Postgres.Write codeUse SQL and build custom charts with code.Customize your workspaceCreate bespoke components for your team.Start conversationsLeave comments and ask questions.Use better defaultsBar charts, bubble maps, histograms, big numbers (and more!) are built-in!\nBuild dashboardsCombine visualizations into a stakeholder-friendly dashboard.ShareSend a URL, export to PNG, or send to Slack.Interact with dataBrush and filter during data exploration.Connect to your databaseSupports Snowflake, DuckDB, and Postgres.Write codeUse SQL and build custom charts with code.Customize your workspaceCreate bespoke components for your team.Start conversationsLeave comments and ask questions.Use better defaultsBar charts, bubble maps, histograms, big numbers (and more!) are built-in!\nBuild dashboardsCombine visualizations into a stakeholder-friendly dashboard.\nBuild dashboardsCombine visualizations into a stakeholder-friendly dashboard.\nCombine visualizations into a stakeholder-friendly dashboard.\nShareSend a URL, export to PNG, or send to Slack.\nShareSend a URL, export to PNG, or send to Slack.\nSend a URL, export to PNG, or send to Slack.\nInteract with dataBrush and filter during data exploration.\nInteract with dataBrush and filter during data exploration.\nBrush and filter during data exploration.\nConnect to your databaseSupports Snowflake, DuckDB, and Postgres.\nConnect to your databaseSupports Snowflake, DuckDB, and Postgres.\nConnect to your database\nConnect to your database\nSupports Snowflake, DuckDB, and Postgres.\nWrite codeUse SQL and build custom charts with code.\nWrite codeUse SQL and build custom charts with code.\nUse SQL and build custom charts with code.\nCustomize your workspaceCreate bespoke components for your team.\nCustomize your workspaceCreate bespoke components for your team.\nCustomize your workspace\nCustomize your workspace\nCreate bespoke components for your team.\nStart conversationsLeave comments and ask questions.\nStart conversationsLeave comments and ask questions.\nLeave comments and ask questions.\nUse better defaultsBar charts, bubble maps, histograms, big numbers (and more!) are built-in!\nUse better defaultsBar charts, bubble maps, histograms, big numbers (and more!) are built-in!\nBar charts, bubble maps, histograms, big numbers (and more!) are built-in!\nObservable opened up a new realm of possibilities for what we could do and offer. We created dynamic, interactive experiences that let users visualize and use climate change data in ways that we couldn’t easily support before.Kaitlyn TrudeauSenior Research Associate at Climate Central\nObservable opened up a new realm of possibilities for what we could do and offer. We created dynamic, interactive experiences that let users visualize and use climate change data in ways that we couldn’t easily support before.Kaitlyn TrudeauSenior Research Associate at Climate Central\nObservable opened up a new realm of possibilities for what we could do and offer. We created dynamic, interactive experiences that let users visualize and use climate change data in ways that we couldn’t easily support before.Kaitlyn TrudeauSenior Research Associate at Climate Central\nObservable opened up a new realm of possibilities for what we could do and offer. We created dynamic, interactive experiences that let users visualize and use climate change data in ways that we couldn’t easily support before.\nKaitlyn TrudeauSenior Research Associate at Climate Central\nSenior Research Associate at Climate Central\nSenior Research Associate at Climate Central\nGet started todaySign up for notebooksRequest a demo\nGet started todaySign up for notebooksRequest a demo\nSign up for notebooksRequest a demo\nSign up for notebooksRequest a demo\nSign up for notebooks\nSign up for notebooks\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nPlatform Resources PricingSign inContact usNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demoProduct managerData analystNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demoIntroducing the collaborative data canvasGo faster together. Bring cross-functional stakeholders into the data workflow by exploring together in real-time. Increase data literacy, discover different perspectives, and uncover insights as a team.Watch the demoAnalyzeExplore and visualize dataQuery, filter, join, group, derive, and visualize data without hopping between tools. Discover and share insights faster than ever.RefineMake analysis crystal clearFearlessly explore and refine analysis on a spatial canvas. Add annotations as notes to self or others. Evolve ad hoc sketches into powerful interactive data apps.ExtendCode if you want toPoint-and-click, or SQL? It's your choice. Peruse queries with summary tables. Customize charts with JavaScript. All with deeply integrated, helpful AI.CollaborateWork together, smarterMultiplayer editing enables real-time collaboration with everyone — from data engineering to finance. It makes work easier and more fun.For data analystsFor business stakeholdersSpend less time going back-and-forth.Work more efficiently with your data team.Bring cross-functional team members into the data workflow.Make stronger decisions by gaining additional context.PresentShow off your workPresent charts in the canvas or create polished, stakeholder-friendly dashboards in just a few clicks.FEATURESBuild dashboardsCombine visualizations into a stakeholder-friendly dashboard.ShareSend a URL, export to PNG, or send to Slack.Interact with dataBrush and filter during data exploration.Connect to your databaseSupports Snowflake, DuckDB, and Postgres.Write codeUse SQL and build custom charts with code.Customize your workspaceCreate bespoke components for your team.Start conversationsLeave comments and ask questions.Use better defaultsBar charts, bubble maps, histograms, big numbers (and more!) are built-in!Observable opened up a new realm of possibilities for what we could do and offer. We created dynamic, interactive experiences that let users visualize and use climate change data in ways that we couldn’t easily support before.Kaitlyn TrudeauSenior Research Associate at Climate CentralGet started todaySign up for notebooksRequest a demoPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demoProduct managerData analystNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demoIntroducing the collaborative data canvasGo faster together. Bring cross-functional stakeholders into the data workflow by exploring together in real-time. Increase data literacy, discover different perspectives, and uncover insights as a team.Watch the demoAnalyzeExplore and visualize dataQuery, filter, join, group, derive, and visualize data without hopping between tools. Discover and share insights faster than ever.RefineMake analysis crystal clearFearlessly explore and refine analysis on a spatial canvas. Add annotations as notes to self or others. Evolve ad hoc sketches into powerful interactive data apps.ExtendCode if you want toPoint-and-click, or SQL? It's your choice. Peruse queries with summary tables. Customize charts with JavaScript. All with deeply integrated, helpful AI.CollaborateWork together, smarterMultiplayer editing enables real-time collaboration with everyone — from data engineering to finance. It makes work easier and more fun.For data analystsFor business stakeholdersSpend less time going back-and-forth.Work more efficiently with your data team.Bring cross-functional team members into the data workflow.Make stronger decisions by gaining additional context.PresentShow off your workPresent charts in the canvas or create polished, stakeholder-friendly dashboards in just a few clicks.FEATURESBuild dashboardsCombine visualizations into a stakeholder-friendly dashboard.ShareSend a URL, export to PNG, or send to Slack.Interact with dataBrush and filter during data exploration.Connect to your databaseSupports Snowflake, DuckDB, and Postgres.Write codeUse SQL and build custom charts with code.Customize your workspaceCreate bespoke components for your team.Start conversationsLeave comments and ask questions.Use better defaultsBar charts, bubble maps, histograms, big numbers (and more!) are built-in!Observable opened up a new realm of possibilities for what we could do and offer. We created dynamic, interactive experiences that let users visualize and use climate change data in ways that we couldn’t easily support before.Kaitlyn TrudeauSenior Research Associate at Climate CentralGet started todaySign up for notebooksRequest a demo\nNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demoProduct managerData analyst\nNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demoProduct managerData analyst\nNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demoProduct managerData analyst\nNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demoProduct managerData analyst\nNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demoProduct managerData analyst\nNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demo\nNow everyone’s on the data team.\nUse Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.\nGet early accessRequest a demo\nNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demo\nNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demo\nNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demo\nNow everyone’s on the data team.\nUse Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.\nGet early accessRequest a demo\nIntroducing the collaborative data canvasGo faster together. Bring cross-functional stakeholders into the data workflow by exploring together in real-time. Increase data literacy, discover different perspectives, and uncover insights as a team.Watch the demo\nIntroducing the collaborative data canvasGo faster together. Bring cross-functional stakeholders into the data workflow by exploring together in real-time. Increase data literacy, discover different perspectives, and uncover insights as a team.Watch the demo\nIntroducing the collaborative data canvasGo faster together. Bring cross-functional stakeholders into the data workflow by exploring together in real-time. Increase data literacy, discover different perspectives, and uncover insights as a team.\nIntroducing the collaborative data canvas\nGo faster together. Bring cross-functional stakeholders into the data workflow by exploring together in real-time. Increase data literacy, discover different perspectives, and uncover insights as a team.\nAnalyzeExplore and visualize dataQuery, filter, join, group, derive, and visualize data without hopping between tools. Discover and share insights faster than ever.\nAnalyzeExplore and visualize dataQuery, filter, join, group, derive, and visualize data without hopping between tools. Discover and share insights faster than ever.\nAnalyzeExplore and visualize dataQuery, filter, join, group, derive, and visualize data without hopping between tools. Discover and share insights faster than ever.\nAnalyzeExplore and visualize dataQuery, filter, join, group, derive, and visualize data without hopping between tools. Discover and share insights faster than ever.\nExplore and visualize data\nQuery, filter, join, group, derive, and visualize data without hopping between tools. Discover and share insights faster than ever.\nRefineMake analysis crystal clearFearlessly explore and refine analysis on a spatial canvas. Add annotations as notes to self or others. Evolve ad hoc sketches into powerful interactive data apps.\nRefineMake analysis crystal clearFearlessly explore and refine analysis on a spatial canvas. Add annotations as notes to self or others. Evolve ad hoc sketches into powerful interactive data apps.\nRefineMake analysis crystal clearFearlessly explore and refine analysis on a spatial canvas. Add annotations as notes to self or others. Evolve ad hoc sketches into powerful interactive data apps.\nRefineMake analysis crystal clearFearlessly explore and refine analysis on a spatial canvas. Add annotations as notes to self or others. Evolve ad hoc sketches into powerful interactive data apps.\nMake analysis crystal clear\nFearlessly explore and refine analysis on a spatial canvas. Add annotations as notes to self or others. Evolve ad hoc sketches into powerful interactive data apps.\nExtendCode if you want toPoint-and-click, or SQL? It's your choice. Peruse queries with summary tables. Customize charts with JavaScript. All with deeply integrated, helpful AI.\nExtendCode if you want toPoint-and-click, or SQL? It's your choice. Peruse queries with summary tables. Customize charts with JavaScript. All with deeply integrated, helpful AI.\nExtendCode if you want toPoint-and-click, or SQL? It's your choice. Peruse queries with summary tables. Customize charts with JavaScript. All with deeply integrated, helpful AI.\nExtendCode if you want toPoint-and-click, or SQL? It's your choice. Peruse queries with summary tables. Customize charts with JavaScript. All with deeply integrated, helpful AI.\nPoint-and-click, or SQL? It's your choice. Peruse queries with summary tables. Customize charts with JavaScript. All with deeply integrated, helpful AI.\nCollaborateWork together, smarterMultiplayer editing enables real-time collaboration with everyone — from data engineering to finance. It makes work easier and more fun.For data analystsFor business stakeholdersSpend less time going back-and-forth.Work more efficiently with your data team.Bring cross-functional team members into the data workflow.Make stronger decisions by gaining additional context.\nCollaborateWork together, smarterMultiplayer editing enables real-time collaboration with everyone — from data engineering to finance. It makes work easier and more fun.For data analystsFor business stakeholdersSpend less time going back-and-forth.Work more efficiently with your data team.Bring cross-functional team members into the data workflow.Make stronger decisions by gaining additional context.\nCollaborateWork together, smarterMultiplayer editing enables real-time collaboration with everyone — from data engineering to finance. It makes work easier and more fun.For data analystsFor business stakeholdersSpend less time going back-and-forth.Work more efficiently with your data team.Bring cross-functional team members into the data workflow.Make stronger decisions by gaining additional context.\nCollaborateWork together, smarterMultiplayer editing enables real-time collaboration with everyone — from data engineering to finance. It makes work easier and more fun.For data analystsFor business stakeholdersSpend less time going back-and-forth.Work more efficiently with your data team.Bring cross-functional team members into the data workflow.Make stronger decisions by gaining additional context.\nWork together, smarter\nMultiplayer editing enables real-time collaboration with everyone — from data engineering to finance. It makes work easier and more fun.\nFor data analystsFor business stakeholdersSpend less time going back-and-forth.Work more efficiently with your data team.Bring cross-functional team members into the data workflow.Make stronger decisions by gaining additional context.\nFor data analystsFor business stakeholdersSpend less time going back-and-forth.Work more efficiently with your data team.Bring cross-functional team members into the data workflow.Make stronger decisions by gaining additional context.\nFor business stakeholders\nFor business stakeholders\nFor business stakeholders\nSpend less time going back-and-forth.\nSpend less time going back-and-forth.\nWork more efficiently with your data team.\nWork more efficiently with your data team.\nBring cross-functional team members into the data workflow.\nBring cross-functional team members into the data workflow.\nMake stronger decisions by gaining additional context.\nMake stronger decisions by gaining additional context.\nPresentShow off your workPresent charts in the canvas or create polished, stakeholder-friendly dashboards in just a few clicks.\nPresentShow off your workPresent charts in the canvas or create polished, stakeholder-friendly dashboards in just a few clicks.\nPresentShow off your workPresent charts in the canvas or create polished, stakeholder-friendly dashboards in just a few clicks.\nPresentShow off your workPresent charts in the canvas or create polished, stakeholder-friendly dashboards in just a few clicks.\nPresent charts in the canvas or create polished, stakeholder-friendly dashboards in just a few clicks.\nFEATURESBuild dashboardsCombine visualizations into a stakeholder-friendly dashboard.ShareSend a URL, export to PNG, or send to Slack.Interact with dataBrush and filter during data exploration.Connect to your databaseSupports Snowflake, DuckDB, and Postgres.Write codeUse SQL and build custom charts with code.Customize your workspaceCreate bespoke components for your team.Start conversationsLeave comments and ask questions.Use better defaultsBar charts, bubble maps, histograms, big numbers (and more!) are built-in!\nFEATURESBuild dashboardsCombine visualizations into a stakeholder-friendly dashboard.ShareSend a URL, export to PNG, or send to Slack.Interact with dataBrush and filter during data exploration.Connect to your databaseSupports Snowflake, DuckDB, and Postgres.Write codeUse SQL and build custom charts with code.Customize your workspaceCreate bespoke components for your team.Start conversationsLeave comments and ask questions.Use better defaultsBar charts, bubble maps, histograms, big numbers (and more!) are built-in!\nFEATURESBuild dashboardsCombine visualizations into a stakeholder-friendly dashboard.ShareSend a URL, export to PNG, or send to Slack.Interact with dataBrush and filter during data exploration.Connect to your databaseSupports Snowflake, DuckDB, and Postgres.Write codeUse SQL and build custom charts with code.Customize your workspaceCreate bespoke components for your team.Start conversationsLeave comments and ask questions.Use better defaultsBar charts, bubble maps, histograms, big numbers (and more!) are built-in!\nBuild dashboardsCombine visualizations into a stakeholder-friendly dashboard.ShareSend a URL, export to PNG, or send to Slack.Interact with dataBrush and filter during data exploration.Connect to your databaseSupports Snowflake, DuckDB, and Postgres.Write codeUse SQL and build custom charts with code.Customize your workspaceCreate bespoke components for your team.Start conversationsLeave comments and ask questions.Use better defaultsBar charts, bubble maps, histograms, big numbers (and more!) are built-in!\nBuild dashboardsCombine visualizations into a stakeholder-friendly dashboard.\nBuild dashboardsCombine visualizations into a stakeholder-friendly dashboard.\nCombine visualizations into a stakeholder-friendly dashboard.\nShareSend a URL, export to PNG, or send to Slack.\nShareSend a URL, export to PNG, or send to Slack.\nSend a URL, export to PNG, or send to Slack.\nInteract with dataBrush and filter during data exploration.\nInteract with dataBrush and filter during data exploration.\nBrush and filter during data exploration.\nConnect to your databaseSupports Snowflake, DuckDB, and Postgres.\nConnect to your databaseSupports Snowflake, DuckDB, and Postgres.\nConnect to your database\nConnect to your database\nSupports Snowflake, DuckDB, and Postgres.\nWrite codeUse SQL and build custom charts with code.\nWrite codeUse SQL and build custom charts with code.\nUse SQL and build custom charts with code.\nCustomize your workspaceCreate bespoke components for your team.\nCustomize your workspaceCreate bespoke components for your team.\nCustomize your workspace\nCustomize your workspace\nCreate bespoke components for your team.\nStart conversationsLeave comments and ask questions.\nStart conversationsLeave comments and ask questions.\nLeave comments and ask questions.\nUse better defaultsBar charts, bubble maps, histograms, big numbers (and more!) are built-in!\nUse better defaultsBar charts, bubble maps, histograms, big numbers (and more!) are built-in!\nBar charts, bubble maps, histograms, big numbers (and more!) are built-in!\nObservable opened up a new realm of possibilities for what we could do and offer. We created dynamic, interactive experiences that let users visualize and use climate change data in ways that we couldn’t easily support before.Kaitlyn TrudeauSenior Research Associate at Climate Central\nObservable opened up a new realm of possibilities for what we could do and offer. We created dynamic, interactive experiences that let users visualize and use climate change data in ways that we couldn’t easily support before.Kaitlyn TrudeauSenior Research Associate at Climate Central\nObservable opened up a new realm of possibilities for what we could do and offer. We created dynamic, interactive experiences that let users visualize and use climate change data in ways that we couldn’t easily support before.Kaitlyn TrudeauSenior Research Associate at Climate Central\nObservable opened up a new realm of possibilities for what we could do and offer. We created dynamic, interactive experiences that let users visualize and use climate change data in ways that we couldn’t easily support before.\nKaitlyn TrudeauSenior Research Associate at Climate Central\nSenior Research Associate at Climate Central\nSenior Research Associate at Climate Central\nGet started todaySign up for notebooksRequest a demo\nGet started todaySign up for notebooksRequest a demo\nSign up for notebooksRequest a demo\nSign up for notebooksRequest a demo\nSign up for notebooks\nSign up for notebooks\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nCreate a new workspace\nCreate a new workspace\nProductPricingSupportDownload the Slack appSign inCreate a new workspace\nDownload the Slack app\nDownload the Slack app\nCreate a new workspace\nCreate a new workspace\nCreate a new workspace\nWe're very sorry, but your browser is not supported!Please upgrade to a supported browser, or try one of our apps.Desktop AppsMacSee system requirementsv4.43.52WindowsSee system requirementsv4.43.52LinuxSee system requirementsv4.43.51Mobile AppsiOSAndroidDon't see the platform you're looking for? Let us know.\nWe're very sorry, but your browser is not supported!Please upgrade to a supported browser, or try one of our apps.Desktop AppsMacSee system requirementsv4.43.52WindowsSee system requirementsv4.43.52LinuxSee system requirementsv4.43.51Mobile AppsiOSAndroidDon't see the platform you're looking for? Let us know.\nWe're very sorry, but your browser is not supported!Please upgrade to a supported browser, or try one of our apps.\nWe're very sorry, but your browser is not supported!\nPlease upgrade to a supported browser, or try one of our apps.\nMacSee system requirementsv4.43.52WindowsSee system requirementsv4.43.52LinuxSee system requirementsv4.43.51\nMacSee system requirementsv4.43.52\nSee system requirements\nSee system requirements\nWindowsSee system requirementsv4.43.52\nSee system requirements\nSee system requirements\nLinuxSee system requirementsv4.43.51\nSee system requirements\nSee system requirements\nDon't see the platform you're looking for? Let us know.\nUsing SlackProductEnterprisePricingSupportSlack GuidesSlack MarketplaceAPISlack JobsCustomersDevelopersEventsBlogLegalPrivacySecurityTerms of ServicePoliciesHandy LinksDownload desktop appDownload mobile appBrand GuidelinesSlack at WorkStatus\nUsing SlackProductEnterprisePricingSupportSlack GuidesSlack MarketplaceAPI\nSlack JobsCustomersDevelopersEventsBlog\nLegalPrivacySecurityTerms of ServicePolicies\nHandy LinksDownload desktop appDownload mobile appBrand GuidelinesSlack at WorkStatus\n\n\nPlatform Resources PricingSign inContact usNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demoProduct managerData analystNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demoIntroducing the collaborative data canvasGo faster together. Bring cross-functional stakeholders into the data workflow by exploring together in real-time. Increase data literacy, discover different perspectives, and uncover insights as a team.Watch the demoAnalyzeExplore and visualize dataQuery, filter, join, group, derive, and visualize data without hopping between tools. Discover and share insights faster than ever.RefineMake analysis crystal clearFearlessly explore and refine analysis on a spatial canvas. Add annotations as notes to self or others. Evolve ad hoc sketches into powerful interactive data apps.ExtendCode if you want toPoint-and-click, or SQL? It's your choice. Peruse queries with summary tables. Customize charts with JavaScript. All with deeply integrated, helpful AI.CollaborateWork together, smarterMultiplayer editing enables real-time collaboration with everyone — from data engineering to finance. It makes work easier and more fun.For data analystsFor business stakeholdersSpend less time going back-and-forth.Work more efficiently with your data team.Bring cross-functional team members into the data workflow.Make stronger decisions by gaining additional context.PresentShow off your workPresent charts in the canvas or create polished, stakeholder-friendly dashboards in just a few clicks.FEATURESBuild dashboardsCombine visualizations into a stakeholder-friendly dashboard.ShareSend a URL, export to PNG, or send to Slack.Interact with dataBrush and filter during data exploration.Connect to your databaseSupports Snowflake, DuckDB, and Postgres.Write codeUse SQL and build custom charts with code.Customize your workspaceCreate bespoke components for your team.Start conversationsLeave comments and ask questions.Use better defaultsBar charts, bubble maps, histograms, big numbers (and more!) are built-in!Observable opened up a new realm of possibilities for what we could do and offer. We created dynamic, interactive experiences that let users visualize and use climate change data in ways that we couldn’t easily support before.Kaitlyn TrudeauSenior Research Associate at Climate CentralGet started todaySign up for notebooksRequest a demoPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demoProduct managerData analystNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demoIntroducing the collaborative data canvasGo faster together. Bring cross-functional stakeholders into the data workflow by exploring together in real-time. Increase data literacy, discover different perspectives, and uncover insights as a team.Watch the demoAnalyzeExplore and visualize dataQuery, filter, join, group, derive, and visualize data without hopping between tools. Discover and share insights faster than ever.RefineMake analysis crystal clearFearlessly explore and refine analysis on a spatial canvas. Add annotations as notes to self or others. Evolve ad hoc sketches into powerful interactive data apps.ExtendCode if you want toPoint-and-click, or SQL? It's your choice. Peruse queries with summary tables. Customize charts with JavaScript. All with deeply integrated, helpful AI.CollaborateWork together, smarterMultiplayer editing enables real-time collaboration with everyone — from data engineering to finance. It makes work easier and more fun.For data analystsFor business stakeholdersSpend less time going back-and-forth.Work more efficiently with your data team.Bring cross-functional team members into the data workflow.Make stronger decisions by gaining additional context.PresentShow off your workPresent charts in the canvas or create polished, stakeholder-friendly dashboards in just a few clicks.FEATURESBuild dashboardsCombine visualizations into a stakeholder-friendly dashboard.ShareSend a URL, export to PNG, or send to Slack.Interact with dataBrush and filter during data exploration.Connect to your databaseSupports Snowflake, DuckDB, and Postgres.Write codeUse SQL and build custom charts with code.Customize your workspaceCreate bespoke components for your team.Start conversationsLeave comments and ask questions.Use better defaultsBar charts, bubble maps, histograms, big numbers (and more!) are built-in!Observable opened up a new realm of possibilities for what we could do and offer. We created dynamic, interactive experiences that let users visualize and use climate change data in ways that we couldn’t easily support before.Kaitlyn TrudeauSenior Research Associate at Climate CentralGet started todaySign up for notebooksRequest a demo\nNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demoProduct managerData analyst\nNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demoProduct managerData analyst\nNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demoProduct managerData analyst\nNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demoProduct managerData analyst\nNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demoProduct managerData analyst\nNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demo\nNow everyone’s on the data team.\nUse Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.\nGet early accessRequest a demo\nNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demo\nNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demo\nNow everyone’s on the data team.Use Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.Get early accessRequest a demo\nNow everyone’s on the data team.\nUse Observable’s collaborative data canvas to make sense of your business by exploring data together, conducting analysis, and building stunning charts and dashboards.\nGet early accessRequest a demo\nIntroducing the collaborative data canvasGo faster together. Bring cross-functional stakeholders into the data workflow by exploring together in real-time. Increase data literacy, discover different perspectives, and uncover insights as a team.Watch the demo\nIntroducing the collaborative data canvasGo faster together. Bring cross-functional stakeholders into the data workflow by exploring together in real-time. Increase data literacy, discover different perspectives, and uncover insights as a team.Watch the demo\nIntroducing the collaborative data canvasGo faster together. Bring cross-functional stakeholders into the data workflow by exploring together in real-time. Increase data literacy, discover different perspectives, and uncover insights as a team.\nIntroducing the collaborative data canvas\nGo faster together. Bring cross-functional stakeholders into the data workflow by exploring together in real-time. Increase data literacy, discover different perspectives, and uncover insights as a team.\nAnalyzeExplore and visualize dataQuery, filter, join, group, derive, and visualize data without hopping between tools. Discover and share insights faster than ever.\nAnalyzeExplore and visualize dataQuery, filter, join, group, derive, and visualize data without hopping between tools. Discover and share insights faster than ever.\nAnalyzeExplore and visualize dataQuery, filter, join, group, derive, and visualize data without hopping between tools. Discover and share insights faster than ever.\nAnalyzeExplore and visualize dataQuery, filter, join, group, derive, and visualize data without hopping between tools. Discover and share insights faster than ever.\nExplore and visualize data\nQuery, filter, join, group, derive, and visualize data without hopping between tools. Discover and share insights faster than ever.\nRefineMake analysis crystal clearFearlessly explore and refine analysis on a spatial canvas. Add annotations as notes to self or others. Evolve ad hoc sketches into powerful interactive data apps.\nRefineMake analysis crystal clearFearlessly explore and refine analysis on a spatial canvas. Add annotations as notes to self or others. Evolve ad hoc sketches into powerful interactive data apps.\nRefineMake analysis crystal clearFearlessly explore and refine analysis on a spatial canvas. Add annotations as notes to self or others. Evolve ad hoc sketches into powerful interactive data apps.\nRefineMake analysis crystal clearFearlessly explore and refine analysis on a spatial canvas. Add annotations as notes to self or others. Evolve ad hoc sketches into powerful interactive data apps.\nMake analysis crystal clear\nFearlessly explore and refine analysis on a spatial canvas. Add annotations as notes to self or others. Evolve ad hoc sketches into powerful interactive data apps.\nExtendCode if you want toPoint-and-click, or SQL? It's your choice. Peruse queries with summary tables. Customize charts with JavaScript. All with deeply integrated, helpful AI.\nExtendCode if you want toPoint-and-click, or SQL? It's your choice. Peruse queries with summary tables. Customize charts with JavaScript. All with deeply integrated, helpful AI.\nExtendCode if you want toPoint-and-click, or SQL? It's your choice. Peruse queries with summary tables. Customize charts with JavaScript. All with deeply integrated, helpful AI.\nExtendCode if you want toPoint-and-click, or SQL? It's your choice. Peruse queries with summary tables. Customize charts with JavaScript. All with deeply integrated, helpful AI.\nPoint-and-click, or SQL? It's your choice. Peruse queries with summary tables. Customize charts with JavaScript. All with deeply integrated, helpful AI.\nCollaborateWork together, smarterMultiplayer editing enables real-time collaboration with everyone — from data engineering to finance. It makes work easier and more fun.For data analystsFor business stakeholdersSpend less time going back-and-forth.Work more efficiently with your data team.Bring cross-functional team members into the data workflow.Make stronger decisions by gaining additional context.\nCollaborateWork together, smarterMultiplayer editing enables real-time collaboration with everyone — from data engineering to finance. It makes work easier and more fun.For data analystsFor business stakeholdersSpend less time going back-and-forth.Work more efficiently with your data team.Bring cross-functional team members into the data workflow.Make stronger decisions by gaining additional context.\nCollaborateWork together, smarterMultiplayer editing enables real-time collaboration with everyone — from data engineering to finance. It makes work easier and more fun.For data analystsFor business stakeholdersSpend less time going back-and-forth.Work more efficiently with your data team.Bring cross-functional team members into the data workflow.Make stronger decisions by gaining additional context.\nCollaborateWork together, smarterMultiplayer editing enables real-time collaboration with everyone — from data engineering to finance. It makes work easier and more fun.For data analystsFor business stakeholdersSpend less time going back-and-forth.Work more efficiently with your data team.Bring cross-functional team members into the data workflow.Make stronger decisions by gaining additional context.\nWork together, smarter\nMultiplayer editing enables real-time collaboration with everyone — from data engineering to finance. It makes work easier and more fun.\nFor data analystsFor business stakeholdersSpend less time going back-and-forth.Work more efficiently with your data team.Bring cross-functional team members into the data workflow.Make stronger decisions by gaining additional context.\nFor data analystsFor business stakeholdersSpend less time going back-and-forth.Work more efficiently with your data team.Bring cross-functional team members into the data workflow.Make stronger decisions by gaining additional context.\nFor business stakeholders\nFor business stakeholders\nFor business stakeholders\nSpend less time going back-and-forth.\nSpend less time going back-and-forth.\nWork more efficiently with your data team.\nWork more efficiently with your data team.\nBring cross-functional team members into the data workflow.\nBring cross-functional team members into the data workflow.\nMake stronger decisions by gaining additional context.\nMake stronger decisions by gaining additional context.\nPresentShow off your workPresent charts in the canvas or create polished, stakeholder-friendly dashboards in just a few clicks.\nPresentShow off your workPresent charts in the canvas or create polished, stakeholder-friendly dashboards in just a few clicks.\nPresentShow off your workPresent charts in the canvas or create polished, stakeholder-friendly dashboards in just a few clicks.\nPresentShow off your workPresent charts in the canvas or create polished, stakeholder-friendly dashboards in just a few clicks.\nPresent charts in the canvas or create polished, stakeholder-friendly dashboards in just a few clicks.\nFEATURESBuild dashboardsCombine visualizations into a stakeholder-friendly dashboard.ShareSend a URL, export to PNG, or send to Slack.Interact with dataBrush and filter during data exploration.Connect to your databaseSupports Snowflake, DuckDB, and Postgres.Write codeUse SQL and build custom charts with code.Customize your workspaceCreate bespoke components for your team.Start conversationsLeave comments and ask questions.Use better defaultsBar charts, bubble maps, histograms, big numbers (and more!) are built-in!\nFEATURESBuild dashboardsCombine visualizations into a stakeholder-friendly dashboard.ShareSend a URL, export to PNG, or send to Slack.Interact with dataBrush and filter during data exploration.Connect to your databaseSupports Snowflake, DuckDB, and Postgres.Write codeUse SQL and build custom charts with code.Customize your workspaceCreate bespoke components for your team.Start conversationsLeave comments and ask questions.Use better defaultsBar charts, bubble maps, histograms, big numbers (and more!) are built-in!\nFEATURESBuild dashboardsCombine visualizations into a stakeholder-friendly dashboard.ShareSend a URL, export to PNG, or send to Slack.Interact with dataBrush and filter during data exploration.Connect to your databaseSupports Snowflake, DuckDB, and Postgres.Write codeUse SQL and build custom charts with code.Customize your workspaceCreate bespoke components for your team.Start conversationsLeave comments and ask questions.Use better defaultsBar charts, bubble maps, histograms, big numbers (and more!) are built-in!\nBuild dashboardsCombine visualizations into a stakeholder-friendly dashboard.ShareSend a URL, export to PNG, or send to Slack.Interact with dataBrush and filter during data exploration.Connect to your databaseSupports Snowflake, DuckDB, and Postgres.Write codeUse SQL and build custom charts with code.Customize your workspaceCreate bespoke components for your team.Start conversationsLeave comments and ask questions.Use better defaultsBar charts, bubble maps, histograms, big numbers (and more!) are built-in!\nBuild dashboardsCombine visualizations into a stakeholder-friendly dashboard.\nBuild dashboardsCombine visualizations into a stakeholder-friendly dashboard.\nCombine visualizations into a stakeholder-friendly dashboard.\nShareSend a URL, export to PNG, or send to Slack.\nShareSend a URL, export to PNG, or send to Slack.\nSend a URL, export to PNG, or send to Slack.\nInteract with dataBrush and filter during data exploration.\nInteract with dataBrush and filter during data exploration.\nBrush and filter during data exploration.\nConnect to your databaseSupports Snowflake, DuckDB, and Postgres.\nConnect to your databaseSupports Snowflake, DuckDB, and Postgres.\nConnect to your database\nConnect to your database\nSupports Snowflake, DuckDB, and Postgres.\nWrite codeUse SQL and build custom charts with code.\nWrite codeUse SQL and build custom charts with code.\nUse SQL and build custom charts with code.\nCustomize your workspaceCreate bespoke components for your team.\nCustomize your workspaceCreate bespoke components for your team.\nCustomize your workspace\nCustomize your workspace\nCreate bespoke components for your team.\nStart conversationsLeave comments and ask questions.\nStart conversationsLeave comments and ask questions.\nLeave comments and ask questions.\nUse better defaultsBar charts, bubble maps, histograms, big numbers (and more!) are built-in!\nUse better defaultsBar charts, bubble maps, histograms, big numbers (and more!) are built-in!\nBar charts, bubble maps, histograms, big numbers (and more!) are built-in!\nObservable opened up a new realm of possibilities for what we could do and offer. We created dynamic, interactive experiences that let users visualize and use climate change data in ways that we couldn’t easily support before.Kaitlyn TrudeauSenior Research Associate at Climate Central\nObservable opened up a new realm of possibilities for what we could do and offer. We created dynamic, interactive experiences that let users visualize and use climate change data in ways that we couldn’t easily support before.Kaitlyn TrudeauSenior Research Associate at Climate Central\nObservable opened up a new realm of possibilities for what we could do and offer. We created dynamic, interactive experiences that let users visualize and use climate change data in ways that we couldn’t easily support before.Kaitlyn TrudeauSenior Research Associate at Climate Central\nObservable opened up a new realm of possibilities for what we could do and offer. We created dynamic, interactive experiences that let users visualize and use climate change data in ways that we couldn’t easily support before.\nKaitlyn TrudeauSenior Research Associate at Climate Central\nSenior Research Associate at Climate Central\nSenior Research Associate at Climate Central\nGet started todaySign up for notebooksRequest a demo\nGet started todaySign up for notebooksRequest a demo\nSign up for notebooksRequest a demo\nSign up for notebooksRequest a demo\nSign up for notebooks\nSign up for notebooks\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nMarksPlot doesn’t have chart types. Instead, it has layered geometric shapes such as bars, dots, and lines.ScalesScales map an abstract value such as time or temperature to a visual value such as position or color.TransformsDerive data on-the-fly while plotting, say to bin quantitative values or compute a rolling average.FacetsSmall multiples facilitate comparison by repeating a plot across partitions of data.ProjectionsPlot supports GeoJSON and D3’s spherical projection system for geographic maps.Built with D3Plot is built by the same team as D3. If you know some D3, you’ll be right at home with Plot.Visit D3 Plot without codeWith Observable’s chart cell, quickly create plots with a GUI, then eject to code to customize.Try chart cell Built by ObservablePlot is developed by Observable, the platform for collaborative data analysis.Visit Observable\n\nSearchK0.6.17GitHub️ 4.6k\n\nObservable PlotThe JavaScript library for exploratory data visualizationCreate expressive charts with concise codeGet startedWhat is Plot?Examples\n\n\n\n🖼️Observable Canvases[EARLY ACCESS] Collaborative whiteboards for analyzing data and presenting insights, combining queries, tables, charts, freehand sketches, highlights, notes, and moreLearn about Canvases 📓Observable NotebooksAd hoc data analysis and prototyping in the browser — with realtime multiplayer editing, integrated source control, and secure sharingLearn about Notebooks ⛅️Observable Cloud[DEPRECATED] The fastest hosting for Framework apps, with secure sharing and analytics, fully automated for continuous deploymentLearn about data apps 🏢WorkspacesShared spaces to host and manage data apps, create notebooks, and collaborate with team members in privateLearn about workspaces 🎨D3An open-source JavaScript library for custom dynamic visualizations with unparalleled flexibility and expressivenessLearn about D3 📊Observable PlotAn open-source JavaScript library for quickly creating expressive charts with concise codeLearn about Plot 🏗️Observable FrameworkAn open-source static-site generator for fast, beautiful data apps, dashboards, reports, and embedded analytics using any programming languageLearn about Framework 🎛️Observable InputsAn open-source JavaScript library for lightweight user interface components, including buttons, sliders, dropdowns, and tablesLearn about Inputs\n\nSearchKobservablehq.com↗\n\nObservable documentationNow everyone’s on the data team.\n\n\n\nPlatform Resources PricingSign inContact usPricingTeam$900/monthIdeal for teams who want to explore data, build charts, and collaborate.Includes 10 usersCreate and share unlimited canvases and dashboardsConnect to 1 data sourceUse AI to guide analysis, formulate queries, or create chartsCollaborate in real-timeGet started quickly with custom onboarding and trainingRequest a demoEnterpriseCustomIdeal for teams that are scaling dashboard production.Includes all features in TeamAdd as many users as neededConnect to multiple data sourcesUnlock workspace management featuresBring your own authenticationReceive a custom quota of AI queries to support your scaleAccess priority customer supportRequest a demoPlan detailsTeamEnterpriseObservable platformCreate visualizations and dashboards using canvasesAdd additional usersUp to 10 usersCustomBuild in notebooksCanvasesConnect to your data warehouse and other sources1 data connectorUnlimitedExplore your data and build visualizations with AICapped quotaCustom quotaCollaborate with team members in real-timeShare dashboards and visualizations in the browserCreate charts and dashboards with UI or codeWorkspace managementControl accessCreate and manage workspace user groupsManage workspace activity with audit logsSecurityAuthenticate via email, Google, GSuite, Microsoft, GitHubSSO through OpenID Connect (Okta, etc)Bring your own authentication and integrate with custom providersControl team access by authentication domainOnboarding and supportWork with a dedicated customer success managerSetup and onboardingSupport tierBasicPriorityFind the plan that works for youGet a demo and learn more about our licensing.Contact salesFrequently asked questionsDo you still offer notebook-only plans?Is AI included?PlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatform Resources PricingSign inContact us\nPlatform Resources PricingSign inContact us\nPlatform Resources Pricing\nPricingTeam$900/monthIdeal for teams who want to explore data, build charts, and collaborate.Includes 10 usersCreate and share unlimited canvases and dashboardsConnect to 1 data sourceUse AI to guide analysis, formulate queries, or create chartsCollaborate in real-timeGet started quickly with custom onboarding and trainingRequest a demoEnterpriseCustomIdeal for teams that are scaling dashboard production.Includes all features in TeamAdd as many users as neededConnect to multiple data sourcesUnlock workspace management featuresBring your own authenticationReceive a custom quota of AI queries to support your scaleAccess priority customer supportRequest a demoPlan detailsTeamEnterpriseObservable platformCreate visualizations and dashboards using canvasesAdd additional usersUp to 10 usersCustomBuild in notebooksCanvasesConnect to your data warehouse and other sources1 data connectorUnlimitedExplore your data and build visualizations with AICapped quotaCustom quotaCollaborate with team members in real-timeShare dashboards and visualizations in the browserCreate charts and dashboards with UI or codeWorkspace managementControl accessCreate and manage workspace user groupsManage workspace activity with audit logsSecurityAuthenticate via email, Google, GSuite, Microsoft, GitHubSSO through OpenID Connect (Okta, etc)Bring your own authentication and integrate with custom providersControl team access by authentication domainOnboarding and supportWork with a dedicated customer success managerSetup and onboardingSupport tierBasicPriorityFind the plan that works for youGet a demo and learn more about our licensing.Contact salesFrequently asked questionsDo you still offer notebook-only plans?Is AI included?\nPricingTeam$900/monthIdeal for teams who want to explore data, build charts, and collaborate.Includes 10 usersCreate and share unlimited canvases and dashboardsConnect to 1 data sourceUse AI to guide analysis, formulate queries, or create chartsCollaborate in real-timeGet started quickly with custom onboarding and trainingRequest a demoEnterpriseCustomIdeal for teams that are scaling dashboard production.Includes all features in TeamAdd as many users as neededConnect to multiple data sourcesUnlock workspace management featuresBring your own authenticationReceive a custom quota of AI queries to support your scaleAccess priority customer supportRequest a demo\nPricingTeam$900/monthIdeal for teams who want to explore data, build charts, and collaborate.Includes 10 usersCreate and share unlimited canvases and dashboardsConnect to 1 data sourceUse AI to guide analysis, formulate queries, or create chartsCollaborate in real-timeGet started quickly with custom onboarding and trainingRequest a demoEnterpriseCustomIdeal for teams that are scaling dashboard production.Includes all features in TeamAdd as many users as neededConnect to multiple data sourcesUnlock workspace management featuresBring your own authenticationReceive a custom quota of AI queries to support your scaleAccess priority customer supportRequest a demo\nTeam$900/monthIdeal for teams who want to explore data, build charts, and collaborate.Includes 10 usersCreate and share unlimited canvases and dashboardsConnect to 1 data sourceUse AI to guide analysis, formulate queries, or create chartsCollaborate in real-timeGet started quickly with custom onboarding and trainingRequest a demoEnterpriseCustomIdeal for teams that are scaling dashboard production.Includes all features in TeamAdd as many users as neededConnect to multiple data sourcesUnlock workspace management featuresBring your own authenticationReceive a custom quota of AI queries to support your scaleAccess priority customer supportRequest a demo\nTeam$900/monthIdeal for teams who want to explore data, build charts, and collaborate.Includes 10 usersCreate and share unlimited canvases and dashboardsConnect to 1 data sourceUse AI to guide analysis, formulate queries, or create chartsCollaborate in real-timeGet started quickly with custom onboarding and trainingRequest a demoEnterpriseCustomIdeal for teams that are scaling dashboard production.Includes all features in TeamAdd as many users as neededConnect to multiple data sourcesUnlock workspace management featuresBring your own authenticationReceive a custom quota of AI queries to support your scaleAccess priority customer supportRequest a demo\n$900/monthIdeal for teams who want to explore data, build charts, and collaborate.\nIdeal for teams who want to explore data, build charts, and collaborate.\nIncludes 10 usersCreate and share unlimited canvases and dashboardsConnect to 1 data sourceUse AI to guide analysis, formulate queries, or create chartsCollaborate in real-timeGet started quickly with custom onboarding and training\nCreate and share unlimited canvases and dashboards\nCreate and share unlimited canvases and dashboards\nConnect to 1 data source\nConnect to 1 data source\nUse AI to guide analysis, formulate queries, or create charts\nUse AI to guide analysis, formulate queries, or create charts\nCollaborate in real-time\nCollaborate in real-time\nGet started quickly with custom onboarding and training\nGet started quickly with custom onboarding and training\nCustomIdeal for teams that are scaling dashboard production.\nIdeal for teams that are scaling dashboard production.\nIncludes all features in TeamAdd as many users as neededConnect to multiple data sourcesUnlock workspace management featuresBring your own authenticationReceive a custom quota of AI queries to support your scaleAccess priority customer support\nIncludes all features in Team\nIncludes all features in Team\nAdd as many users as needed\nAdd as many users as needed\nConnect to multiple data sources\nConnect to multiple data sources\nUnlock workspace management features\nUnlock workspace management features\nBring your own authentication\nBring your own authentication\nReceive a custom quota of AI queries to support your scale\nReceive a custom quota of AI queries to support your scale\nAccess priority customer support\nAccess priority customer support\nPlan detailsTeamEnterpriseObservable platformCreate visualizations and dashboards using canvasesAdd additional usersUp to 10 usersCustomBuild in notebooksCanvasesConnect to your data warehouse and other sources1 data connectorUnlimitedExplore your data and build visualizations with AICapped quotaCustom quotaCollaborate with team members in real-timeShare dashboards and visualizations in the browserCreate charts and dashboards with UI or codeWorkspace managementControl accessCreate and manage workspace user groupsManage workspace activity with audit logsSecurityAuthenticate via email, Google, GSuite, Microsoft, GitHubSSO through OpenID Connect (Okta, etc)Bring your own authentication and integrate with custom providersControl team access by authentication domainOnboarding and supportWork with a dedicated customer success managerSetup and onboardingSupport tierBasicPriority\nPlan detailsTeamEnterpriseObservable platformCreate visualizations and dashboards using canvasesAdd additional usersUp to 10 usersCustomBuild in notebooksCanvasesConnect to your data warehouse and other sources1 data connectorUnlimitedExplore your data and build visualizations with AICapped quotaCustom quotaCollaborate with team members in real-timeShare dashboards and visualizations in the browserCreate charts and dashboards with UI or codeWorkspace managementControl accessCreate and manage workspace user groupsManage workspace activity with audit logsSecurityAuthenticate via email, Google, GSuite, Microsoft, GitHubSSO through OpenID Connect (Okta, etc)Bring your own authentication and integrate with custom providersControl team access by authentication domainOnboarding and supportWork with a dedicated customer success managerSetup and onboardingSupport tierBasicPriority\nTeamEnterpriseObservable platformCreate visualizations and dashboards using canvasesAdd additional usersUp to 10 usersCustomBuild in notebooksCanvasesConnect to your data warehouse and other sources1 data connectorUnlimitedExplore your data and build visualizations with AICapped quotaCustom quotaCollaborate with team members in real-timeShare dashboards and visualizations in the browserCreate charts and dashboards with UI or codeWorkspace managementControl accessCreate and manage workspace user groupsManage workspace activity with audit logsSecurityAuthenticate via email, Google, GSuite, Microsoft, GitHubSSO through OpenID Connect (Okta, etc)Bring your own authentication and integrate with custom providersControl team access by authentication domainOnboarding and supportWork with a dedicated customer success managerSetup and onboardingSupport tierBasicPriority\nObservable platformCreate visualizations and dashboards using canvasesAdd additional usersUp to 10 usersCustomBuild in notebooks\nCreate visualizations and dashboards using canvasesAdd additional usersUp to 10 usersCustomBuild in notebooks\nCreate visualizations and dashboards using canvases\nCreate visualizations and dashboards using canvases\nAdd additional usersUp to 10 usersCustom\nCanvasesConnect to your data warehouse and other sources1 data connectorUnlimitedExplore your data and build visualizations with AICapped quotaCustom quotaCollaborate with team members in real-timeShare dashboards and visualizations in the browserCreate charts and dashboards with UI or code\nConnect to your data warehouse and other sources1 data connectorUnlimitedExplore your data and build visualizations with AICapped quotaCustom quotaCollaborate with team members in real-timeShare dashboards and visualizations in the browserCreate charts and dashboards with UI or code\nConnect to your data warehouse and other sources1 data connectorUnlimited\nConnect to your data warehouse and other sources\nExplore your data and build visualizations with AICapped quotaCustom quota\nExplore your data and build visualizations with AI\nCollaborate with team members in real-time\nCollaborate with team members in real-time\nShare dashboards and visualizations in the browser\nShare dashboards and visualizations in the browser\nCreate charts and dashboards with UI or code\nCreate charts and dashboards with UI or code\nWorkspace managementControl accessCreate and manage workspace user groupsManage workspace activity with audit logs\nControl accessCreate and manage workspace user groupsManage workspace activity with audit logs\nCreate and manage workspace user groups\nCreate and manage workspace user groups\nManage workspace activity with audit logs\nManage workspace activity with audit logs\nSecurityAuthenticate via email, Google, GSuite, Microsoft, GitHubSSO through OpenID Connect (Okta, etc)Bring your own authentication and integrate with custom providersControl team access by authentication domain\nAuthenticate via email, Google, GSuite, Microsoft, GitHubSSO through OpenID Connect (Okta, etc)Bring your own authentication and integrate with custom providersControl team access by authentication domain\nAuthenticate via email, Google, GSuite, Microsoft, GitHub\nAuthenticate via email, Google, GSuite, Microsoft, GitHub\nSSO through OpenID Connect (Okta, etc)\nSSO through OpenID Connect (Okta, etc)\nBring your own authentication and integrate with custom providers\nBring your own authentication and integrate with custom providers\nControl team access by authentication domain\nControl team access by authentication domain\nOnboarding and supportWork with a dedicated customer success managerSetup and onboardingSupport tierBasicPriority\nOnboarding and support\nOnboarding and support\nOnboarding and support\nWork with a dedicated customer success managerSetup and onboardingSupport tierBasicPriority\nWork with a dedicated customer success manager\nWork with a dedicated customer success manager\nSupport tierBasicPriority\nFind the plan that works for youGet a demo and learn more about our licensing.Contact sales\nFind the plan that works for youGet a demo and learn more about our licensing.Contact sales\nFind the plan that works for youGet a demo and learn more about our licensing.Contact sales\nFind the plan that works for you\nGet a demo and learn more about our licensing.\nFrequently asked questionsDo you still offer notebook-only plans?Is AI included?\nFrequently asked questionsDo you still offer notebook-only plans?Is AI included?\nFrequently asked questions\nFrequently asked questions\nDo you still offer notebook-only plans?Is AI included?\nDo you still offer notebook-only plans?Is AI included?\nDo you still offer notebook-only plans?\nDo you still offer notebook-only plans?\nDo you still offer notebook-only plans?\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHubPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub© 2025 Observable, Inc.PrivacySecurityTerms of Service\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricingDocsObservableObservable FrameworkObservable PlotD3Release notesResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForumCompanyAboutCareersContact usNewsletter signupGitHub\nPlatformObservable CanvasesObservable NotebooksPricing\nDocsObservableObservable FrameworkObservable PlotD3Release notes\nResourcesBlogWebinarsVideosCustomer storiesCommunity SlackForum\nCompanyAboutCareersContact usNewsletter signupGitHub\n© 2025 Observable, Inc.PrivacySecurityTerms of Service\n© 2025 Observable, Inc.\n\n\nMarksPlot doesn’t have chart types. Instead, it has layered geometric shapes such as bars, dots, and lines.ScalesScales map an abstract value such as time or temperature to a visual value such as position or color.TransformsDerive data on-the-fly while plotting, say to bin quantitative values or compute a rolling average.FacetsSmall multiples facilitate comparison by repeating a plot across partitions of data.ProjectionsPlot supports GeoJSON and D3’s spherical projection system for geographic maps.Built with D3Plot is built by the same team as D3. If you know some D3, you’ll be right at home with Plot.Visit D3 Plot without codeWith Observable’s chart cell, quickly create plots with a GUI, then eject to code to customize.Try chart cell Built by ObservablePlot is developed by Observable, the platform for collaborative data analysis.Visit Observable\n\nSearchK0.6.17GitHub️ 4.6k\n\nObservable PlotThe JavaScript library for exploratory data visualizationCreate expressive charts with concise codeGet startedWhat is Plot?Examples\n\n\n\nGetting started ​Observable Plot supports a variety of environments.Try Plot online ​The fastest way to get started (and get help) with Observable Plot is on Observable! Plot is available by default in notebooks as part of Observable’s standard library. To use Plot, simply return the generated plot from a cell like so:ForkjsPlot.rectY({length: 10000}, Plot.binX({y: "count"}, {x: d3.randomNormal()})).plot()Observable includes a variety of Plot snippets when you click + to add a cell, as well as convenient sample datasets to try out Plot features. Or upload a CSV or JSON file to start playing with your data. You can even use Observable’s chart cell, which uses Plot’s auto mark under the hood, to create quick charts without writing code! You can then eject to JavaScript by clicking + to see the equivalent Plot code.Observable’s chart cell lets you quickly create charts and then eject to Plot code.Observable is free for public use. Sign up for a Pro account to connect to private databases, collaborate on private notebooks, and more.Plot in vanilla HTML ​In vanilla HTML, you can load Plot from a CDN such as jsDelivr or you can download it locally. We recommend using the CDN-hosted ES module bundle as it automatically loads Plot’s dependency on D3. But for those who need it, we also provide a UMD bundle that exports the Plot global when loaded as a plain script.ESM + CDNUMD + CDNUMD + localhtml<!DOCTYPE html>
<div id="myplot"></div>
<script type="module">

import * as Plot from "https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm";

const plot = Plot.rectY({length: 10000}, Plot.binX({y: "count"}, {x: Math.random})).plot();
const div = document.querySelector("#myplot");
div.append(plot);

</script>html<!DOCTYPE html>
<div id="myplot"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script src="https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6"></script>
<script type="module">

const plot = Plot.rectY({length: 10000}, Plot.binX({y: "count"}, {x: Math.random})).plot();
const div = document.querySelector("#myplot");
div.append(plot);

</script>html<!DOCTYPE html>
<div id="myplot"></div>
<script src="d3.js"></script>
<script src="plot.js"></script>
<script type="module">

const plot = Plot.rectY({length: 10000}, Plot.binX({y: "count"}, {x: Math.random})).plot();
const div = document.querySelector("#myplot");
div.append(plot);

</script>Plot returns a detached DOM element — either an SVG or HTML figure element. In vanilla web development, this means you need to insert the generated plot into the page to see it. Typically this is done by selecting a DOM element (such as a DIV with a unique identifier, like myplot above), and then calling element.append.If you’d prefer to run Plot locally (or entirely offline), you can download the UMD bundle of Plot along with its dependency, D3, here:d3.jsplot.jsThen, create an index.html file as shown above in the UMD + local tab. If you prefer smaller minified files, you can download d3.min.js and plot.min.js, and then update the src attributes above accordingly.Installing from npm ​If you’re developing a web application using Node, you can install Plot via yarn, npm, pnpm, or your preferred package manager.yarnnpmpnpmbashyarn add @observablehq/plotbashnpm install @observablehq/plotbashpnpm add @observablehq/plotYou can then load Plot into your app as:jsimport * as Plot from "@observablehq/plot";You can instead import specific symbols if you prefer:jsimport {barY, groupX} from "@observablehq/plot";Plot includes TypeScript declarations with extensive documentation. We highly recommend using an editor with enhanced code completion such as Visual Studio Code or Observable.Modern editors surface documentation and type hints as you write Plot code.Plot in React ​We recommend two approaches for Plot in React depending on your needs.The first is to server-side render (SSR) plots. This minimizes distracting reflow on page load, improving the user experience. For this approach, use the document plot option to tell Plot to render with React’s virtual DOM. For example, here is a PlotFigure component:PlotFigure.jsjsimport * as Plot from "@observablehq/plot";
import {createElement as h} from "react";

export default function PlotFigure({options}) {
  return Plot.plot({...options, document: new Document()}).toHyperScript();
}INFOFor brevity, the virtual Document implementation is not shown. You’ll find it linked below.Then, to use:App.jsxjsximport * as Plot from "@observablehq/plot";
import PlotFigure from "./PlotFigure.js";
import penguins from "./penguins.json";

export default function App() {
  return (
    <div>
      <h1>Penguins</h1>
      <PlotFigure
        options={{
          marks: [
            Plot.dot(penguins, {x: "culmen_length_mm", y: "culmen_depth_mm"})
          ]
        }}
      />
    </div>
  );
}See our Plot + React CodeSandbox for details.Server-side rendering is only practical for simple plots of small data; complex plots, such as geographic maps or charts with thousands of elements, are better rendered on the client because the serialized SVG is large. For this second approach, use useRef to get a reference to a DOM element, and then useEffect to generate and insert your plot.App.jsxjsximport * as Plot from "@observablehq/plot";
import * as d3 from "d3";
import {useEffect, useRef, useState} from "react";

export default function App() {
  const containerRef = useRef();
  const [data, setData] = useState();

  useEffect(() => {
    d3.csv("/gistemp.csv", d3.autoType).then(setData);
  }, []);

  useEffect(() => {
    if (data === undefined) return;
    const plot = Plot.plot({
      y: {grid: true},
      color: {scheme: "burd"},
      marks: [
        Plot.ruleY([0]),
        Plot.dot(data, {x: "Date", y: "Anomaly", stroke: "Anomaly"})
      ]
    });
    containerRef.current.append(plot);
    return () => plot.remove();
  }, [data]);

  return <div ref={containerRef} />;
}This example also demonstrates asynchronously loading CSV data with useState. If you want to update your plot, say because your data has changed, simply throw away the old plot using element.remove and then replace it with a new one. That’s done above in the useEffect’s cleanup function.Plot in Vue ​As with React, you can use either server- or client-side rendering with Plot and Vue.For server-side rendering (SSR), use the document plot option to render to Vue’s virtual DOM. For example, here is a PlotFigure component:PlotFigure.jsjsimport * as Plot from "@observablehq/plot";
import {h} from "vue";

export default {
  props: {
    options: Object
  },
  render() {
    return Plot.plot({
      ...this.options,
      document: new Document()
    }).toHyperScript();
  }
};INFOFor brevity, the virtual Document implementation is not shown. You’ll find it linked below.Then, to use:App.vuevue<script setup>
import * as Plot from "@observablehq/plot";
import PlotFigure from "./components/PlotFigure.js";
import penguins from "./assets/penguins.json";
</script>

<template>
  <h1>Plot + Vue</h1>
  <PlotFigure
    :options="{
      marks: [
        Plot.dot(penguins, {x: 'culmen_length_mm', y: 'culmen_depth_mm'}),
      ],
    }"
  />
</template>See our Plot + Vue CodeSandbox for details.For client-side rendering, use a render function with a mounted lifecycle directive. After the component mounts, render the plot and then insert it into the page.jsimport * as Plot from "@observablehq/plot";
import {h, withDirectives} from "vue";

export default {
  props: ["options"],
  render() {
    const {options} = this;
    return withDirectives(h("div"), [
      [
        {
          mounted(el) {
            el.append(Plot.plot(options));
          }
        }
      ]
    ]);
  }
};As with React, to update your plot for whatever reason, simply render a new one and replace the old one. You can find more examples on our GitHub as this documentation site is built with VitePress and uses both client- and server-side rendering for plots!Plot in Svelte ​Here’s an example of client-side rendering in Svelte. For server-side rendering, see #1759.App.sveltesvelte<script lang="ts">
  import * as Plot from '@observablehq/plot';
  import * as d3 from 'd3';

  let div: HTMLElement | undefined = $state();
  let data = $state(d3.ticks(-2, 2, 200).map(Math.sin));

  function onMousemove(event: MouseEvent) {
    const [x, y] = d3.pointer(event);
    data = data.slice(-200).concat(Math.atan2(x, y));
  }

  $effect(() => {
    div?.firstChild?.remove(); // remove old chart, if any
    div?.append(Plot.lineY(data).plot({ grid: true })); // add the new chart
  });
</script>

<div onmousemove={onMousemove} bind:this={div} role="img"></div>See our Plot + Svelte REPL for details.Plot in Node.js ​You can use Plot to server-side render SVG or PNG in Node.js. Use JSDOM for a DOM implementation via the document option, then serialize the generated plot using outerHTML.jsimport {readFile} from "node:fs/promises";
import * as Plot from "@observablehq/plot";
import * as d3 from "d3";
import {JSDOM} from "jsdom";

const penguins = d3.csvParse(await readFile("./penguins.csv", "utf-8"), d3.autoType);

const plot = Plot.plot({
  document: new JSDOM("").window.document,
  marks: [
    Plot.dot(penguins, {x: "culmen_length_mm", y: "culmen_depth_mm", stroke: "species"})
  ]
});

plot.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns", "http://www.w3.org/2000/svg");
plot.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");

process.stdout.write(plot.outerHTML);To rasterize SVG as PNG, you could use canvg and node-canvas, or sharp:jsprocess.stdout.write(await sharp(Buffer.from(plot.outerHTML, "utf-8")).png().toBuffer());For better font rendering, consider Puppeteer.\n\nSearchK0.6.17GitHub️ 4.6kOn this pageGetting started ​Observable Plot supports a variety of environments.Try Plot online ​The fastest way to get started (and get help) with Observable Plot is on Observable! Plot is available by default in notebooks as part of Observable’s standard library. To use Plot, simply return the generated plot from a cell like so:ForkjsPlot.rectY({length: 10000}, Plot.binX({y: "count"}, {x: d3.randomNormal()})).plot()Observable includes a variety of Plot snippets when you click + to add a cell, as well as convenient sample datasets to try out Plot features. Or upload a CSV or JSON file to start playing with your data. You can even use Observable’s chart cell, which uses Plot’s auto mark under the hood, to create quick charts without writing code! You can then eject to JavaScript by clicking + to see the equivalent Plot code.Observable’s chart cell lets you quickly create charts and then eject to Plot code.Observable is free for public use. Sign up for a Pro account to connect to private databases, collaborate on private notebooks, and more.Plot in vanilla HTML ​In vanilla HTML, you can load Plot from a CDN such as jsDelivr or you can download it locally. We recommend using the CDN-hosted ES module bundle as it automatically loads Plot’s dependency on D3. But for those who need it, we also provide a UMD bundle that exports the Plot global when loaded as a plain script.ESM + CDNUMD + CDNUMD + localhtml<!DOCTYPE html>
<div id="myplot"></div>
<script type="module">

import * as Plot from "https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm";

const plot = Plot.rectY({length: 10000}, Plot.binX({y: "count"}, {x: Math.random})).plot();
const div = document.querySelector("#myplot");
div.append(plot);

</script>html<!DOCTYPE html>
<div id="myplot"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script src="https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6"></script>
<script type="module">

const plot = Plot.rectY({length: 10000}, Plot.binX({y: "count"}, {x: Math.random})).plot();
const div = document.querySelector("#myplot");
div.append(plot);

</script>html<!DOCTYPE html>
<div id="myplot"></div>
<script src="d3.js"></script>
<script src="plot.js"></script>
<script type="module">

const plot = Plot.rectY({length: 10000}, Plot.binX({y: "count"}, {x: Math.random})).plot();
const div = document.querySelector("#myplot");
div.append(plot);

</script>Plot returns a detached DOM element — either an SVG or HTML figure element. In vanilla web development, this means you need to insert the generated plot into the page to see it. Typically this is done by selecting a DOM element (such as a DIV with a unique identifier, like myplot above), and then calling element.append.If you’d prefer to run Plot locally (or entirely offline), you can download the UMD bundle of Plot along with its dependency, D3, here:d3.jsplot.jsThen, create an index.html file as shown above in the UMD + local tab. If you prefer smaller minified files, you can download d3.min.js and plot.min.js, and then update the src attributes above accordingly.Installing from npm ​If you’re developing a web application using Node, you can install Plot via yarn, npm, pnpm, or your preferred package manager.yarnnpmpnpmbashyarn add @observablehq/plotbashnpm install @observablehq/plotbashpnpm add @observablehq/plotYou can then load Plot into your app as:jsimport * as Plot from "@observablehq/plot";You can instead import specific symbols if you prefer:jsimport {barY, groupX} from "@observablehq/plot";Plot includes TypeScript declarations with extensive documentation. We highly recommend using an editor with enhanced code completion such as Visual Studio Code or Observable.Modern editors surface documentation and type hints as you write Plot code.Plot in React ​We recommend two approaches for Plot in React depending on your needs.The first is to server-side render (SSR) plots. This minimizes distracting reflow on page load, improving the user experience. For this approach, use the document plot option to tell Plot to render with React’s virtual DOM. For example, here is a PlotFigure component:PlotFigure.jsjsimport * as Plot from "@observablehq/plot";
import {createElement as h} from "react";

export default function PlotFigure({options}) {
  return Plot.plot({...options, document: new Document()}).toHyperScript();
}INFOFor brevity, the virtual Document implementation is not shown. You’ll find it linked below.Then, to use:App.jsxjsximport * as Plot from "@observablehq/plot";
import PlotFigure from "./PlotFigure.js";
import penguins from "./penguins.json";

export default function App() {
  return (
    <div>
      <h1>Penguins</h1>
      <PlotFigure
        options={{
          marks: [
            Plot.dot(penguins, {x: "culmen_length_mm", y: "culmen_depth_mm"})
          ]
        }}
      />
    </div>
  );
}See our Plot + React CodeSandbox for details.Server-side rendering is only practical for simple plots of small data; complex plots, such as geographic maps or charts with thousands of elements, are better rendered on the client because the serialized SVG is large. For this second approach, use useRef to get a reference to a DOM element, and then useEffect to generate and insert your plot.App.jsxjsximport * as Plot from "@observablehq/plot";
import * as d3 from "d3";
import {useEffect, useRef, useState} from "react";

export default function App() {
  const containerRef = useRef();
  const [data, setData] = useState();

  useEffect(() => {
    d3.csv("/gistemp.csv", d3.autoType).then(setData);
  }, []);

  useEffect(() => {
    if (data === undefined) return;
    const plot = Plot.plot({
      y: {grid: true},
      color: {scheme: "burd"},
      marks: [
        Plot.ruleY([0]),
        Plot.dot(data, {x: "Date", y: "Anomaly", stroke: "Anomaly"})
      ]
    });
    containerRef.current.append(plot);
    return () => plot.remove();
  }, [data]);

  return <div ref={containerRef} />;
}This example also demonstrates asynchronously loading CSV data with useState. If you want to update your plot, say because your data has changed, simply throw away the old plot using element.remove and then replace it with a new one. That’s done above in the useEffect’s cleanup function.Plot in Vue ​As with React, you can use either server- or client-side rendering with Plot and Vue.For server-side rendering (SSR), use the document plot option to render to Vue’s virtual DOM. For example, here is a PlotFigure component:PlotFigure.jsjsimport * as Plot from "@observablehq/plot";
import {h} from "vue";

export default {
  props: {
    options: Object
  },
  render() {
    return Plot.plot({
      ...this.options,
      document: new Document()
    }).toHyperScript();
  }
};INFOFor brevity, the virtual Document implementation is not shown. You’ll find it linked below.Then, to use:App.vuevue<script setup>
import * as Plot from "@observablehq/plot";
import PlotFigure from "./components/PlotFigure.js";
import penguins from "./assets/penguins.json";
</script>

<template>
  <h1>Plot + Vue</h1>
  <PlotFigure
    :options="{
      marks: [
        Plot.dot(penguins, {x: 'culmen_length_mm', y: 'culmen_depth_mm'}),
      ],
    }"
  />
</template>See our Plot + Vue CodeSandbox for details.For client-side rendering, use a render function with a mounted lifecycle directive. After the component mounts, render the plot and then insert it into the page.jsimport * as Plot from "@observablehq/plot";
import {h, withDirectives} from "vue";

export default {
  props: ["options"],
  render() {
    const {options} = this;
    return withDirectives(h("div"), [
      [
        {
          mounted(el) {
            el.append(Plot.plot(options));
          }
        }
      ]
    ]);
  }
};As with React, to update your plot for whatever reason, simply render a new one and replace the old one. You can find more examples on our GitHub as this documentation site is built with VitePress and uses both client- and server-side rendering for plots!Plot in Svelte ​Here’s an example of client-side rendering in Svelte. For server-side rendering, see #1759.App.sveltesvelte<script lang="ts">
  import * as Plot from '@observablehq/plot';
  import * as d3 from 'd3';

  let div: HTMLElement | undefined = $state();
  let data = $state(d3.ticks(-2, 2, 200).map(Math.sin));

  function onMousemove(event: MouseEvent) {
    const [x, y] = d3.pointer(event);
    data = data.slice(-200).concat(Math.atan2(x, y));
  }

  $effect(() => {
    div?.firstChild?.remove(); // remove old chart, if any
    div?.append(Plot.lineY(data).plot({ grid: true })); // add the new chart
  });
</script>

<div onmousemove={onMousemove} bind:this={div} role="img"></div>See our Plot + Svelte REPL for details.Plot in Node.js ​You can use Plot to server-side render SVG or PNG in Node.js. Use JSDOM for a DOM implementation via the document option, then serialize the generated plot using outerHTML.jsimport {readFile} from "node:fs/promises";
import * as Plot from "@observablehq/plot";
import * as d3 from "d3";
import {JSDOM} from "jsdom";

const penguins = d3.csvParse(await readFile("./penguins.csv", "utf-8"), d3.autoType);

const plot = Plot.plot({
  document: new JSDOM("").window.document,
  marks: [
    Plot.dot(penguins, {x: "culmen_length_mm", y: "culmen_depth_mm", stroke: "species"})
  ]
});

plot.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns", "http://www.w3.org/2000/svg");
plot.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");

process.stdout.write(plot.outerHTML);To rasterize SVG as PNG, you could use canvg and node-canvas, or sharp:jsprocess.stdout.write(await sharp(Buffer.from(plot.outerHTML, "utf-8")).png().toBuffer());For better font rendering, consider Puppeteer.PagerPrevious pageWhy Plot?Next pagePlots\n\nGetting started ​Observable Plot supports a variety of environments.Try Plot online ​The fastest way to get started (and get help) with Observable Plot is on Observable! Plot is available by default in notebooks as part of Observable’s standard library. To use Plot, simply return the generated plot from a cell like so:ForkjsPlot.rectY({length: 10000}, Plot.binX({y: "count"}, {x: d3.randomNormal()})).plot()Observable includes a variety of Plot snippets when you click + to add a cell, as well as convenient sample datasets to try out Plot features. Or upload a CSV or JSON file to start playing with your data. You can even use Observable’s chart cell, which uses Plot’s auto mark under the hood, to create quick charts without writing code! You can then eject to JavaScript by clicking + to see the equivalent Plot code.Observable’s chart cell lets you quickly create charts and then eject to Plot code.Observable is free for public use. Sign up for a Pro account to connect to private databases, collaborate on private notebooks, and more.Plot in vanilla HTML ​In vanilla HTML, you can load Plot from a CDN such as jsDelivr or you can download it locally. We recommend using the CDN-hosted ES module bundle as it automatically loads Plot’s dependency on D3. But for those who need it, we also provide a UMD bundle that exports the Plot global when loaded as a plain script.ESM + CDNUMD + CDNUMD + localhtml<!DOCTYPE html>
<div id="myplot"></div>
<script type="module">

import * as Plot from "https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm";

const plot = Plot.rectY({length: 10000}, Plot.binX({y: "count"}, {x: Math.random})).plot();
const div = document.querySelector("#myplot");
div.append(plot);

</script>html<!DOCTYPE html>
<div id="myplot"></div>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script src="https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6"></script>
<script type="module">

const plot = Plot.rectY({length: 10000}, Plot.binX({y: "count"}, {x: Math.random})).plot();
const div = document.querySelector("#myplot");
div.append(plot);

</script>html<!DOCTYPE html>
<div id="myplot"></div>
<script src="d3.js"></script>
<script src="plot.js"></script>
<script type="module">

const plot = Plot.rectY({length: 10000}, Plot.binX({y: "count"}, {x: Math.random})).plot();
const div = document.querySelector("#myplot");
div.append(plot);

</script>Plot returns a detached DOM element — either an SVG or HTML figure element. In vanilla web development, this means you need to insert the generated plot into the page to see it. Typically this is done by selecting a DOM element (such as a DIV with a unique identifier, like myplot above), and then calling element.append.If you’d prefer to run Plot locally (or entirely offline), you can download the UMD bundle of Plot along with its dependency, D3, here:d3.jsplot.jsThen, create an index.html file as shown above in the UMD + local tab. If you prefer smaller minified files, you can download d3.min.js and plot.min.js, and then update the src attributes above accordingly.Installing from npm ​If you’re developing a web application using Node, you can install Plot via yarn, npm, pnpm, or your preferred package manager.yarnnpmpnpmbashyarn add @observablehq/plotbashnpm install @observablehq/plotbashpnpm add @observablehq/plotYou can then load Plot into your app as:jsimport * as Plot from "@observablehq/plot";You can instead import specific symbols if you prefer:jsimport {barY, groupX} from "@observablehq/plot";Plot includes TypeScript declarations with extensive documentation. We highly recommend using an editor with enhanced code completion such as Visual Studio Code or Observable.Modern editors surface documentation and type hints as you write Plot code.Plot in React ​We recommend two approaches for Plot in React depending on your needs.The first is to server-side render (SSR) plots. This minimizes distracting reflow on page load, improving the user experience. For this approach, use the document plot option to tell Plot to render with React’s virtual DOM. For example, here is a PlotFigure component:PlotFigure.jsjsimport * as Plot from "@observablehq/plot";
import {createElement as h} from "react";

export default function PlotFigure({options}) {
  return Plot.plot({...options, document: new Document()}).toHyperScript();
}INFOFor brevity, the virtual Document implementation is not shown. You’ll find it linked below.Then, to use:App.jsxjsximport * as Plot from "@observablehq/plot";
import PlotFigure from "./PlotFigure.js";
import penguins from "./penguins.json";

export default function App() {
  return (
    <div>
      <h1>Penguins</h1>
      <PlotFigure
        options={{
          marks: [
            Plot.dot(penguins, {x: "culmen_length_mm", y: "culmen_depth_mm"})
          ]
        }}
      />
    </div>
  );
}See our Plot + React CodeSandbox for details.Server-side rendering is only practical for simple plots of small data; complex plots, such as geographic maps or charts with thousands of elements, are better rendered on the client because the serialized SVG is large. For this second approach, use useRef to get a reference to a DOM element, and then useEffect to generate and insert your plot.App.jsxjsximport * as Plot from "@observablehq/plot";
import * as d3 from "d3";
import {useEffect, useRef, useState} from "react";

export default function App() {
  const containerRef = useRef();
  const [data, setData] = useState();

  useEffect(() => {
    d3.csv("/gistemp.csv", d3.autoType).then(setData);
  }, []);

  useEffect(() => {
    if (data === undefined) return;
    const plot = Plot.plot({
      y: {grid: true},
      color: {scheme: "burd"},
      marks: [
        Plot.ruleY([0]),
        Plot.dot(data, {x: "Date", y: "Anomaly", stroke: "Anomaly"})
      ]
    });
    containerRef.current.append(plot);
    return () => plot.remove();
  }, [data]);

  return <div ref={containerRef} />;
}This example also demonstrates asynchronously loading CSV data with useState. If you want to update your plot, say because your data has changed, simply throw away the old plot using element.remove and then replace it with a new one. That’s done above in the useEffect’s cleanup function.Plot in Vue ​As with React, you can use either server- or client-side rendering with Plot and Vue.For server-side rendering (SSR), use the document plot option to render to Vue’s virtual DOM. For example, here is a PlotFigure component:PlotFigure.jsjsimport * as Plot from "@observablehq/plot";
import {h} from "vue";

export default {
  props: {
    options: Object
  },
  render() {
    return Plot.plot({
      ...this.options,
      document: new Document()
    }).toHyperScript();
  }
};INFOFor brevity, the virtual Document implementation is not shown. You’ll find it linked below.Then, to use:App.vuevue<script setup>
import * as Plot from "@observablehq/plot";
import PlotFigure from "./components/PlotFigure.js";
import penguins from "./assets/penguins.json";
</script>

<template>
  <h1>Plot + Vue</h1>
  <PlotFigure
    :options="{
      marks: [
        Plot.dot(penguins, {x: 'culmen_length_mm', y: 'culmen_depth_mm'}),
      ],
    }"
  />
</template>See our Plot + Vue CodeSandbox for details.For client-side rendering, use a render function with a mounted lifecycle directive. After the component mounts, render the plot and then insert it into the page.jsimport * as Plot from "@observablehq/plot";
import {h, withDirectives} from "vue";

export default {
  props: ["options"],
  render() {
    const {options} = this;
    return withDirectives(h("div"), [
      [
        {
          mounted(el) {
            el.append(Plot.plot(options));
          }
        }
      ]
    ]);
  }
};As with React, to update your plot for whatever reason, simply render a new one and replace the old one. You can find more examples on our GitHub as this documentation site is built with VitePress and uses both client- and server-side rendering for plots!Plot in Svelte ​Here’s an example of client-side rendering in Svelte. For server-side rendering, see #1759.App.sveltesvelte<script lang="ts">
  import * as Plot from '@observablehq/plot';
  import * as d3 from 'd3';

  let div: HTMLElement | undefined = $state();
  let data = $state(d3.ticks(-2, 2, 200).map(Math.sin));

  function onMousemove(event: MouseEvent) {
    const [x, y] = d3.pointer(event);
    data = data.slice(-200).concat(Math.atan2(x, y));
  }

  $effect(() => {
    div?.firstChild?.remove(); // remove old chart, if any
    div?.append(Plot.lineY(data).plot({ grid: true })); // add the new chart
  });
</script>

<div onmousemove={onMousemove} bind:this={div} role="img"></div>See our Plot + Svelte REPL for details.Plot in Node.js ​You can use Plot to server-side render SVG or PNG in Node.js. Use JSDOM for a DOM implementation via the document option, then serialize the generated plot using outerHTML.jsimport {readFile} from "node:fs/promises";
import * as Plot from "@observablehq/plot";
import * as d3 from "d3";
import {JSDOM} from "jsdom";

const penguins = d3.csvParse(await readFile("./penguins.csv", "utf-8"), d3.autoType);

const plot = Plot.plot({
  document: new JSDOM("").window.document,
  marks: [
    Plot.dot(penguins, {x: "culmen_length_mm", y: "culmen_depth_mm", stroke: "species"})
  ]
});

plot.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns", "http://www.w3.org/2000/svg");
plot.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");

process.stdout.write(plot.outerHTML);To rasterize SVG as PNG, you could use canvg and node-canvas, or sharp:jsprocess.stdout.write(await sharp(Buffer.from(plot.outerHTML, "utf-8")).png().toBuffer());For better font rendering, consider Puppeteer.\n\n\n\nWhy Plot? ​Observable Plot is for exploratory data visualization. It’s for finding insights quickly. Its API, while expressive and configurable, optimizes for conciseness and memorability. We want the time to first chart to be as fast as possible.And the speed doesn’t stop there: Plot helps you quickly pivot and refine your views of data. Our hope with Plot is that you’ll spend less time reading the docs, searching for code to copy-paste, and debugging — and more time asking questions of data.Compared to other visualization tools, including low-level tools such as D3 and less expressive high-level tools such as chart templates, we think you’ll be more productive exploring data with Plot. You’ll spend more time “using vision to think” and less time wrangling the machinery of programming.Or put more simply: with Plot, you’ll see more charts.Plot is concise ​You can make a meaningful chart in Plot with as little as one line of code.ForkjsPlot.dot(penguins, {x: "culmen_length_mm", y: "culmen_depth_mm", stroke: "species"}).plot()What makes Plot concise? In a word: defaults. If you specify the semantics — your data and the desired encodings — Plot will figure out the rest.The beauty of defaults is that you can override them as needed. This is ideal for exploring: you invest minimally in the initial chart, and as you start to see something interesting, you progressively customize to improve the display. Perhaps the plot above would be easier to read with an aspect ratio proportional to the data, a grid, and a legend?AdelieChinstrapGentooForkjsPlot.plot({
  grid: true,
  aspectRatio: 1,
  inset: 10,
  x: {tickSpacing: 80, label: "Culmen length (mm)"},
  y: {tickSpacing: 80, label: "Culmen depth (mm)"},
  color: {legend: true},
  marks: [
    Plot.frame(),
    Plot.dot(penguins, {x: "culmen_length_mm", y: "culmen_depth_mm", stroke: "species"})
  ]
})Plot transforms data ​Munging data, not visualizing it, is often most of the work of data analysis. Plot’s transforms let you aggregate and derive data within your plot specification, reducing the time spent preparing data. For example, if you have a dataset of penguins, you can quickly count their frequency by species with the group transform.ForkjsPlot.plot({
  marginLeft: 80,
  marginRight: 80,
  marks: [
    Plot.barX(penguins, Plot.groupY({x: "count"}, {y: "species"})),
    Plot.ruleX([0])
  ]
})Because transforms are integrated into Plot, they work automatically with other Plot features such as faceting. For example, to breakdown the chart above by island, we just add the fy (vertical facet) option.ForkjsPlot.plot({
  marginLeft: 80,
  marginRight: 80,
  marks: [
    Plot.barX(penguins, Plot.groupY({x: "count"}, {fy: "island", y: "species"})),
    Plot.ruleX([0])
  ]
})And to color by sex, too? Add fill; the bar mark then applies an implicit stack transform.FEMALEMALEnullForkjsPlot.plot({
  marginLeft: 80,
  marginRight: 80,
  color: {legend: true},
  marks: [
    Plot.barX(penguins, Plot.groupY({x: "count"}, {fy: "island", y: "species", fill: "sex"})),
    Plot.ruleX([0])
  ]
})Plot’s transforms can do powerful things, including normalizing series, computing moving averages, laying out trees, dodging, and hexagonal binning.Plot is composable ​Simple components gain power through composition, such as layering multiple marks into a single plot. Plot makes it easy to define custom composite marks, such as this one comprising a rule, area, and line:jsfunction arealineY(data, {color, fillOpacity = 0.1, ...options} = {}) {
  return Plot.marks(
    Plot.ruleY([0]),
    Plot.areaY(data, {fill: color, fillOpacity, ...options}),
    Plot.lineY(data, {stroke: color, ...options})
  );
}You can use this composite mark like any built-in mark:ForkjsarealineY(aapl, {x: "Date", y: "Close", color: "blue"}).plot()Plot uses this technique internally: the axis mark and box mark are both composite marks.ForkjsPlot.boxX(penguins, {x: "body_mass_g", y: "species"}).plot({marginLeft: 60, y: {label: null}})Plot’s transforms are composable, too: to apply multiple transforms, you simply pass the options from one transform to the next. Some marks even apply implicit transforms, say for stacking or binning as shown above. Mark options are plain JavaScript objects, so you can also share options across marks and inspect them to debug.Plot is extensible ​Plot isn’t a new language; it’s “just” vanilla JavaScript. Plot embraces JavaScript, letting you plug in your own functions for accessors, reducers, transforms… even custom marks! And Plot generates SVG, so you can style it with CSS and manipulate it just like you do with D3. (See Mike Freeman’s tooltip plugin for a great example of extending Plot this way.)Plot builds on D3 ​Plot is informed by our more than ten years’ experience developing D3, the web’s most popular library for data visualization.Plot uses D3 to implement a wide variety of features:scales (ticks, color schemes, number formatting)shapes (areas, lines, curves, symbols, stacks)planar geometry (Delaunay, Voronoi, contours, density estimation)spherical geometry (geographic projections)data manipulation (group, rollup, bin, statistics)tree diagrams… and more!If you already know some D3, you’ll find many parts of Plot familiar.We’ve long said that D3 makes things possible, not necessarily easy. And that’s true regardless of the task at hand. D3 makes hard and amazing things possible, yes, but even simple things that should be easy are often not. To paraphrase Amanda Cox: “Use D3 if you think it’s perfectly normal to write a hundred lines of code for a bar chart.”Plot’s goal is to make the easy things easy, and fast, and then some.TIPWhether or not Plot succeeds at this goal is up to you — so we’d love your feedback on what you find easy or hard to do with Plot. And we encourage you to ask for help when you get stuck. We learn a lot from helping!Since Plot and D3 have different goals, they make different trade-offs. Plot is more efficient: you can make charts quickly. But it is also necessarily less expressive: bespoke visualizations with extensive animation and interaction, advanced techniques like force-directed graph layout, or even developing your own charting library, are better done with D3’s low-level API.We recommend D3 for bespoke data visualizations, if you decide the extra expressiveness of D3 is worth the time and effort. D3 makes sense for media organizations such as The New York Times or The Pudding, where a single graphic may be seen by a million readers, and where a team of editors can work together to advance the state of the art in visual communication; but is it the best tool for building your team’s private dashboard, or a one-off analysis? You may be surprised how far you can get with Plot.\n\nSearchK0.6.17GitHub️ 4.6kOn this pageWhy Plot? ​Observable Plot is for exploratory data visualization. It’s for finding insights quickly. Its API, while expressive and configurable, optimizes for conciseness and memorability. We want the time to first chart to be as fast as possible.And the speed doesn’t stop there: Plot helps you quickly pivot and refine your views of data. Our hope with Plot is that you’ll spend less time reading the docs, searching for code to copy-paste, and debugging — and more time asking questions of data.Compared to other visualization tools, including low-level tools such as D3 and less expressive high-level tools such as chart templates, we think you’ll be more productive exploring data with Plot. You’ll spend more time “using vision to think” and less time wrangling the machinery of programming.Or put more simply: with Plot, you’ll see more charts.Plot is concise ​You can make a meaningful chart in Plot with as little as one line of code.ForkjsPlot.dot(penguins, {x: "culmen_length_mm", y: "culmen_depth_mm", stroke: "species"}).plot()What makes Plot concise? In a word: defaults. If you specify the semantics — your data and the desired encodings — Plot will figure out the rest.The beauty of defaults is that you can override them as needed. This is ideal for exploring: you invest minimally in the initial chart, and as you start to see something interesting, you progressively customize to improve the display. Perhaps the plot above would be easier to read with an aspect ratio proportional to the data, a grid, and a legend?AdelieChinstrapGentooForkjsPlot.plot({
  grid: true,
  aspectRatio: 1,
  inset: 10,
  x: {tickSpacing: 80, label: "Culmen length (mm)"},
  y: {tickSpacing: 80, label: "Culmen depth (mm)"},
  color: {legend: true},
  marks: [
    Plot.frame(),
    Plot.dot(penguins, {x: "culmen_length_mm", y: "culmen_depth_mm", stroke: "species"})
  ]
})Plot transforms data ​Munging data, not visualizing it, is often most of the work of data analysis. Plot’s transforms let you aggregate and derive data within your plot specification, reducing the time spent preparing data. For example, if you have a dataset of penguins, you can quickly count their frequency by species with the group transform.ForkjsPlot.plot({
  marginLeft: 80,
  marginRight: 80,
  marks: [
    Plot.barX(penguins, Plot.groupY({x: "count"}, {y: "species"})),
    Plot.ruleX([0])
  ]
})Because transforms are integrated into Plot, they work automatically with other Plot features such as faceting. For example, to breakdown the chart above by island, we just add the fy (vertical facet) option.ForkjsPlot.plot({
  marginLeft: 80,
  marginRight: 80,
  marks: [
    Plot.barX(penguins, Plot.groupY({x: "count"}, {fy: "island", y: "species"})),
    Plot.ruleX([0])
  ]
})And to color by sex, too? Add fill; the bar mark then applies an implicit stack transform.FEMALEMALEnullForkjsPlot.plot({
  marginLeft: 80,
  marginRight: 80,
  color: {legend: true},
  marks: [
    Plot.barX(penguins, Plot.groupY({x: "count"}, {fy: "island", y: "species", fill: "sex"})),
    Plot.ruleX([0])
  ]
})Plot’s transforms can do powerful things, including normalizing series, computing moving averages, laying out trees, dodging, and hexagonal binning.Plot is composable ​Simple components gain power through composition, such as layering multiple marks into a single plot. Plot makes it easy to define custom composite marks, such as this one comprising a rule, area, and line:jsfunction arealineY(data, {color, fillOpacity = 0.1, ...options} = {}) {
  return Plot.marks(
    Plot.ruleY([0]),
    Plot.areaY(data, {fill: color, fillOpacity, ...options}),
    Plot.lineY(data, {stroke: color, ...options})
  );
}You can use this composite mark like any built-in mark:ForkjsarealineY(aapl, {x: "Date", y: "Close", color: "blue"}).plot()Plot uses this technique internally: the axis mark and box mark are both composite marks.ForkjsPlot.boxX(penguins, {x: "body_mass_g", y: "species"}).plot({marginLeft: 60, y: {label: null}})Plot’s transforms are composable, too: to apply multiple transforms, you simply pass the options from one transform to the next. Some marks even apply implicit transforms, say for stacking or binning as shown above. Mark options are plain JavaScript objects, so you can also share options across marks and inspect them to debug.Plot is extensible ​Plot isn’t a new language; it’s “just” vanilla JavaScript. Plot embraces JavaScript, letting you plug in your own functions for accessors, reducers, transforms… even custom marks! And Plot generates SVG, so you can style it with CSS and manipulate it just like you do with D3. (See Mike Freeman’s tooltip plugin for a great example of extending Plot this way.)Plot builds on D3 ​Plot is informed by our more than ten years’ experience developing D3, the web’s most popular library for data visualization.Plot uses D3 to implement a wide variety of features:scales (ticks, color schemes, number formatting)shapes (areas, lines, curves, symbols, stacks)planar geometry (Delaunay, Voronoi, contours, density estimation)spherical geometry (geographic projections)data manipulation (group, rollup, bin, statistics)tree diagrams… and more!If you already know some D3, you’ll find many parts of Plot familiar.We’ve long said that D3 makes things possible, not necessarily easy. And that’s true regardless of the task at hand. D3 makes hard and amazing things possible, yes, but even simple things that should be easy are often not. To paraphrase Amanda Cox: “Use D3 if you think it’s perfectly normal to write a hundred lines of code for a bar chart.”Plot’s goal is to make the easy things easy, and fast, and then some.TIPWhether or not Plot succeeds at this goal is up to you — so we’d love your feedback on what you find easy or hard to do with Plot. And we encourage you to ask for help when you get stuck. We learn a lot from helping!Since Plot and D3 have different goals, they make different trade-offs. Plot is more efficient: you can make charts quickly. But it is also necessarily less expressive: bespoke visualizations with extensive animation and interaction, advanced techniques like force-directed graph layout, or even developing your own charting library, are better done with D3’s low-level API.We recommend D3 for bespoke data visualizations, if you decide the extra expressiveness of D3 is worth the time and effort. D3 makes sense for media organizations such as The New York Times or The Pudding, where a single graphic may be seen by a million readers, and where a team of editors can work together to advance the state of the art in visual communication; but is it the best tool for building your team’s private dashboard, or a one-off analysis? You may be surprised how far you can get with Plot.PagerPrevious pageWhat is Plot?Next pageGetting started\n\nWhy Plot? ​Observable Plot is for exploratory data visualization. It’s for finding insights quickly. Its API, while expressive and configurable, optimizes for conciseness and memorability. We want the time to first chart to be as fast as possible.And the speed doesn’t stop there: Plot helps you quickly pivot and refine your views of data. Our hope with Plot is that you’ll spend less time reading the docs, searching for code to copy-paste, and debugging — and more time asking questions of data.Compared to other visualization tools, including low-level tools such as D3 and less expressive high-level tools such as chart templates, we think you’ll be more productive exploring data with Plot. You’ll spend more time “using vision to think” and less time wrangling the machinery of programming.Or put more simply: with Plot, you’ll see more charts.Plot is concise ​You can make a meaningful chart in Plot with as little as one line of code.ForkjsPlot.dot(penguins, {x: "culmen_length_mm", y: "culmen_depth_mm", stroke: "species"}).plot()What makes Plot concise? In a word: defaults. If you specify the semantics — your data and the desired encodings — Plot will figure out the rest.The beauty of defaults is that you can override them as needed. This is ideal for exploring: you invest minimally in the initial chart, and as you start to see something interesting, you progressively customize to improve the display. Perhaps the plot above would be easier to read with an aspect ratio proportional to the data, a grid, and a legend?AdelieChinstrapGentooForkjsPlot.plot({
  grid: true,
  aspectRatio: 1,
  inset: 10,
  x: {tickSpacing: 80, label: "Culmen length (mm)"},
  y: {tickSpacing: 80, label: "Culmen depth (mm)"},
  color: {legend: true},
  marks: [
    Plot.frame(),
    Plot.dot(penguins, {x: "culmen_length_mm", y: "culmen_depth_mm", stroke: "species"})
  ]
})Plot transforms data ​Munging data, not visualizing it, is often most of the work of data analysis. Plot’s transforms let you aggregate and derive data within your plot specification, reducing the time spent preparing data. For example, if you have a dataset of penguins, you can quickly count their frequency by species with the group transform.ForkjsPlot.plot({
  marginLeft: 80,
  marginRight: 80,
  marks: [
    Plot.barX(penguins, Plot.groupY({x: "count"}, {y: "species"})),
    Plot.ruleX([0])
  ]
})Because transforms are integrated into Plot, they work automatically with other Plot features such as faceting. For example, to breakdown the chart above by island, we just add the fy (vertical facet) option.ForkjsPlot.plot({
  marginLeft: 80,
  marginRight: 80,
  marks: [
    Plot.barX(penguins, Plot.groupY({x: "count"}, {fy: "island", y: "species"})),
    Plot.ruleX([0])
  ]
})And to color by sex, too? Add fill; the bar mark then applies an implicit stack transform.FEMALEMALEnullForkjsPlot.plot({
  marginLeft: 80,
  marginRight: 80,
  color: {legend: true},
  marks: [
    Plot.barX(penguins, Plot.groupY({x: "count"}, {fy: "island", y: "species", fill: "sex"})),
    Plot.ruleX([0])
  ]
})Plot’s transforms can do powerful things, including normalizing series, computing moving averages, laying out trees, dodging, and hexagonal binning.Plot is composable ​Simple components gain power through composition, such as layering multiple marks into a single plot. Plot makes it easy to define custom composite marks, such as this one comprising a rule, area, and line:jsfunction arealineY(data, {color, fillOpacity = 0.1, ...options} = {}) {
  return Plot.marks(
    Plot.ruleY([0]),
    Plot.areaY(data, {fill: color, fillOpacity, ...options}),
    Plot.lineY(data, {stroke: color, ...options})
  );
}You can use this composite mark like any built-in mark:ForkjsarealineY(aapl, {x: "Date", y: "Close", color: "blue"}).plot()Plot uses this technique internally: the axis mark and box mark are both composite marks.ForkjsPlot.boxX(penguins, {x: "body_mass_g", y: "species"}).plot({marginLeft: 60, y: {label: null}})Plot’s transforms are composable, too: to apply multiple transforms, you simply pass the options from one transform to the next. Some marks even apply implicit transforms, say for stacking or binning as shown above. Mark options are plain JavaScript objects, so you can also share options across marks and inspect them to debug.Plot is extensible ​Plot isn’t a new language; it’s “just” vanilla JavaScript. Plot embraces JavaScript, letting you plug in your own functions for accessors, reducers, transforms… even custom marks! And Plot generates SVG, so you can style it with CSS and manipulate it just like you do with D3. (See Mike Freeman’s tooltip plugin for a great example of extending Plot this way.)Plot builds on D3 ​Plot is informed by our more than ten years’ experience developing D3, the web’s most popular library for data visualization.Plot uses D3 to implement a wide variety of features:scales (ticks, color schemes, number formatting)shapes (areas, lines, curves, symbols, stacks)planar geometry (Delaunay, Voronoi, contours, density estimation)spherical geometry (geographic projections)data manipulation (group, rollup, bin, statistics)tree diagrams… and more!If you already know some D3, you’ll find many parts of Plot familiar.We’ve long said that D3 makes things possible, not necessarily easy. And that’s true regardless of the task at hand. D3 makes hard and amazing things possible, yes, but even simple things that should be easy are often not. To paraphrase Amanda Cox: “Use D3 if you think it’s perfectly normal to write a hundred lines of code for a bar chart.”Plot’s goal is to make the easy things easy, and fast, and then some.TIPWhether or not Plot succeeds at this goal is up to you — so we’d love your feedback on what you find easy or hard to do with Plot. And we encourage you to ask for help when you get stuck. We learn a lot from helping!Since Plot and D3 have different goals, they make different trade-offs. Plot is more efficient: you can make charts quickly. But it is also necessarily less expressive: bespoke visualizations with extensive animation and interaction, advanced techniques like force-directed graph layout, or even developing your own charting library, are better done with D3’s low-level API.We recommend D3 for bespoke data visualizations, if you decide the extra expressiveness of D3 is worth the time and effort. D3 makes sense for media organizations such as The New York Times or The Pudding, where a single graphic may be seen by a million readers, and where a team of editors can work together to advance the state of the art in visual communication; but is it the best tool for building your team’s private dashboard, or a one-off analysis? You may be surprised how far you can get with Plot.\n\n\n\nPlots ​To render a plot in Observable Plot, call plot (typically as Plot.plot), passing in the desired options. This function returns an SVG or HTML figure element.ForkjsPlot.plot({
  marks: [
    Plot.frame(),
    Plot.text(["Hello, world!"], {frameAnchor: "middle"})
  ]
})TIPThe returned plot element is detached; it must be inserted into the page to be visible. For help, see the getting started guide.Marks option ​The marks option specifies an array of marks to render. Above, there are two marks: a frame to draw the outline of the plot frame, and a text to say hello. 👋Each mark supplies its own tabular data. For example, the table below shows the first five rows of a daily dataset of Apple stock price (aapl).DateOpenHighLowCloseVolume2013-05-1364.50142765.41428464.50000064.962860792372002013-05-1464.83571665.02857263.16428863.4085731117795002013-05-1562.73714463.00000060.33714361.2642861854034002013-05-1660.46285662.54999959.84285762.0828591508010002013-05-1762.72142862.86999961.57285761.894287106976100In JavaScript, we can represent tabular data as an array of objects. Each object records a daily observation, with properties Date, Open, High, and so on. This is known as a “row-based” format since each object corresponds to a row in the table.jsaapl = [
  {Date: new Date("2013-05-13"), Open: 64.501427, High: 65.414284, Low: 64.500000, Close: 64.962860, Volume: 79237200},
  {Date: new Date("2013-05-14"), Open: 64.835716, High: 65.028572, Low: 63.164288, Close: 63.408573, Volume: 111779500},
  {Date: new Date("2013-05-15"), Open: 62.737144, High: 63.000000, Low: 60.337143, Close: 61.264286, Volume: 185403400},
  {Date: new Date("2013-05-16"), Open: 60.462856, High: 62.549999, Low: 59.842857, Close: 62.082859, Volume: 150801000},
  {Date: new Date("2013-05-17"), Open: 62.721428, High: 62.869999, Low: 61.572857, Close: 61.894287, Volume: 106976100}
]TIPRather than baking data into JavaScript, use JSON or CSV files to store data. You can use d3.json, d3.csv, or fetch to load a file. On Observable, you can also use a file attachment or SQL cell.To use data with Plot, pass the data as the first argument to the mark constructor. We can then assign columns of data such as Date and Close to visual properties of the mark (or “channels”) such as horizontal↔︎ position x and vertical↕︎ position y.ForkjsPlot.plot({
  marks: [
    Plot.lineY(aapl, {x: "Date", y: "Close"})
  ]
})A plot can have multiple marks, and each mark has its own data. For example, say we had a similar table goog representing the daily price of Google stock for the same period. Below, the red line represents Google stock, while the blue line represents Apple stock.ForkjsPlot.plot({
  marks: [
    Plot.ruleY([0]),
    Plot.lineY(goog, {x: "Date", y: "Close", stroke: "red"}),
    Plot.lineY(aapl, {x: "Date", y: "Close", stroke: "blue"})
  ]
})TIPWhen comparing the performance of different stocks, we typically want to normalize the return relative to a purchase price. See the normalize transform for an example.Alternatively, the tables can be combined, say with a Symbol column to distinguish AAPL from GOOG. This allows the use of a categorical color scale and legend.ForkjsPlot.plot({
  color: {legend: true},
  marks: [
    Plot.ruleY([0]),
    Plot.lineY(stocks, {x: "Date", y: "Close", stroke: "Symbol"})
  ]
})Each mark has its own options, and different mark types support different options. See the respective mark type (such as bar or dot) for details.Marks are drawn in the given order, with the last mark drawn on top. For example, below green bars are drawn on top of black bars.ForkjsPlot.plot({
  x: {padding: 0.4},
  marks: [
    Plot.barY(alphabet, {x: "letter", y: "frequency", dx: 2, dy: 2}),
    Plot.barY(alphabet, {x: "letter", y: "frequency", fill: "green", dx: -2, dy: -2})
  ]
})Layout options ​The layout options determine the overall size of the plot; all are specified as numbers in pixels:marginTop - the top marginmarginRight - the right marginmarginBottom - the bottom marginmarginLeft - the left marginmargin - shorthand for the four marginswidth - the outer width of the plot (including margins)height - the outer height of the plot (including margins)Experiment with the margins by adjusting the sliders below. Note that because the x scale is a band scale, the round option defaults to true, so the bars may jump when you adjust the horizontal margins to snap to crisp edges.marginTop:20marginRight:20marginBottom:30marginLeft:40jsPlot.plot({
  marginTop,
  marginRight,
  marginBottom,
  marginLeft,
  grid: true,
  marks: [
    Plot.frame({
      stroke: "var(--vp-c-text-2)",
      strokeOpacity: 0.5,
      insetTop: -marginTop,
      insetRight: -marginRight,
      insetBottom: -marginBottom,
      insetLeft: -marginLeft,
    }),
    Plot.barY(alphabet, {x: "letter", y: "frequency", fill: "green"}),
    Plot.frame()
  ]
})jsPlot.plot({
  marginTop: 20,
  marginRight: 20,
  marginBottom: 30,
  marginLeft: 40,
  grid: true,
  marks: [
    Plot.barY(alphabet, {x: "letter", y: "frequency", fill: "green"}),
    Plot.frame()
  ]
})INFOTo assist the explanation, the plot above is drawn with a light gray border.The default width is 640. On Observable, the width can be set to the standard width to make responsive plots. The default height is chosen automatically based on the plot’s associated scales; for example, if y is linear and there is no fy scale, it might be 396. The default margins depend on the maximum margins of the plot’s constituent marks. While most marks default to zero margins (because they are drawn inside the chart area), Plot’s axis mark has non-zero default margins.TIPPlot does not adjust margins automatically to make room for long tick labels. If your y axis labels are too long, you can increase the marginLeft to make more room. Also consider using a different tickFormat for short labels (e.g., s for SI prefix notation), or a scale transform (say to convert units to millions or billions).The aspectRatio option ^0.6.4, if not null, computes a default height such that a variation of one unit in the x dimension is represented by the corresponding number of pixels as a variation in the y dimension of one unit. The aspectRatio option is recommended only when x and y domains share the same units, such as millimeters. When a position scale is ordinal (point or band), consecutive domain values are treated as one unit length apart; for example, if both x and y are ordinal, then an aspect ratio of one produces a square grid. Use fixed aspect ratio: ForkjsPlot.plot({
  grid: true,
  inset: 10,
  aspectRatio: fixed ? 1 : undefined,
  color: {legend: true},
  marks: [
    Plot.frame(),
    Plot.dot(penguins, {x: "culmen_length_mm", y: "culmen_depth_mm", stroke: "species"})
  ]
})TIPWhen using facets, set the fx and fy scales’ round option to false if you need an exact aspect ratio.Other options ​By default, plot returns an SVG element; however, if the plot includes a title, subtitle, legend, or caption, plot wraps the SVG element with an HTML figure element. You can also force Plot to generate a figure element by setting the figure option ^0.6.10 to true.The title & subtitle options ^0.6.10 and the caption option accept either a string or an HTML element. If given an HTML element, say using the html tagged template literal, the title and subtitle are used as-is while the caption is wrapped in a figcaption element; otherwise, the specified text will be escaped and wrapped in an h2, h3, or figcaption, respectively.For charts, an informative titleSubtitle to follow with additional contextFigure 1. A chart with a title, subtitle, and caption.ForkjsPlot.plot({
  title: "For charts, an informative title",
  subtitle: "Subtitle to follow with additional context",
  caption: "Figure 1. A chart with a title, subtitle, and caption.",
  marks: [
    Plot.frame(),
    Plot.text(["Titles, subtitles, captions, and annotations assist inter­pretation by telling the reader what’s interesting. Don’t make the reader work to find what you already know."], {lineWidth: 30, frameAnchor: "middle"})
  ]
})The style option allows custom styles to override Plot’s defaults. It may be specified either as a string of inline styles (e.g., "color: red;", in the same fashion as assigning element.style) or an object of properties (e.g., {color: "red"}, in the same fashion as assigning element.style properties). By default, the returned plot has a max-width of 100%, and the system-ui font. Plot’s marks and axes default to currentColor, meaning that they will inherit the surrounding content’s color.CAUTIONUnitless numbers (quirky lengths) such as {padding: 20} are not supported by some browsers; you should instead specify a string with units such as {padding: "20px"}.The generated SVG element has a class name which applies a default stylesheet. Use the top-level className option to specify that class name.The clip option ^0.6.10 determines the default clipping behavior if the mark clip option is not specified; set it to true to enable clipping. This option does not affect axis, grid, and frame marks, whose clip option defaults to false.The document option specifies the document used to create plot elements. It defaults to window.document, but can be changed to another document, say when using a virtual DOM implementation for server-side rendering in Node.plot(options) ​jsPlot.plot({
  height: 200,
  marks: [
    Plot.barY(alphabet, {x: "letter", y: "frequency"})
  ]
})Renders a new plot with the specified options, returning a SVG or HTML figure element. This element can then be inserted into the page as described in the getting started guide.mark.plot(options) ​jsPlot.barY(alphabet, {x: "letter", y: "frequency"}).plot({height: 200})Given a mark, this is a convenience shorthand for calling plot where the marks option includes this mark. Any additional marks in options are drawn on top of this mark.plot.scale(name) ​jsconst plot = Plot.plot(options); // render a plot
const color = plot.scale("color"); // get the color scale
console.log(color.range); // inspect the scale’s rangeReturns the scale object for the scale with the specified name (such as x or color) on the given plot, where plot is a rendered plot element returned by plot. If the associated plot has no scale with the given name, returns undefined.plot.legend(name, options) ​jsconst plot = Plot.plot(options); // render a plot
const legend = plot.legend("color"); // render a color legendRenders a standalone legend for the scale with the specified name (such as x or color) on the given plot, where plot is a rendered plot element returned by plot, returning a SVG or HTML figure element. This element can then be inserted into the page as described in the getting started guide. If the associated plot has no scale with the given name, returns undefined. Legends are currently only supported for color, opacity, and symbol scales.\n\nSearchK0.6.17GitHub️ 4.6kOn this pagePlots ​To render a plot in Observable Plot, call plot (typically as Plot.plot), passing in the desired options. This function returns an SVG or HTML figure element.ForkjsPlot.plot({
  marks: [
    Plot.frame(),
    Plot.text(["Hello, world!"], {frameAnchor: "middle"})
  ]
})TIPThe returned plot element is detached; it must be inserted into the page to be visible. For help, see the getting started guide.Marks option ​The marks option specifies an array of marks to render. Above, there are two marks: a frame to draw the outline of the plot frame, and a text to say hello. 👋Each mark supplies its own tabular data. For example, the table below shows the first five rows of a daily dataset of Apple stock price (aapl).DateOpenHighLowCloseVolume2013-05-1364.50142765.41428464.50000064.962860792372002013-05-1464.83571665.02857263.16428863.4085731117795002013-05-1562.73714463.00000060.33714361.2642861854034002013-05-1660.46285662.54999959.84285762.0828591508010002013-05-1762.72142862.86999961.57285761.894287106976100In JavaScript, we can represent tabular data as an array of objects. Each object records a daily observation, with properties Date, Open, High, and so on. This is known as a “row-based” format since each object corresponds to a row in the table.jsaapl = [
  {Date: new Date("2013-05-13"), Open: 64.501427, High: 65.414284, Low: 64.500000, Close: 64.962860, Volume: 79237200},
  {Date: new Date("2013-05-14"), Open: 64.835716, High: 65.028572, Low: 63.164288, Close: 63.408573, Volume: 111779500},
  {Date: new Date("2013-05-15"), Open: 62.737144, High: 63.000000, Low: 60.337143, Close: 61.264286, Volume: 185403400},
  {Date: new Date("2013-05-16"), Open: 60.462856, High: 62.549999, Low: 59.842857, Close: 62.082859, Volume: 150801000},
  {Date: new Date("2013-05-17"), Open: 62.721428, High: 62.869999, Low: 61.572857, Close: 61.894287, Volume: 106976100}
]TIPRather than baking data into JavaScript, use JSON or CSV files to store data. You can use d3.json, d3.csv, or fetch to load a file. On Observable, you can also use a file attachment or SQL cell.To use data with Plot, pass the data as the first argument to the mark constructor. We can then assign columns of data such as Date and Close to visual properties of the mark (or “channels”) such as horizontal↔︎ position x and vertical↕︎ position y.ForkjsPlot.plot({
  marks: [
    Plot.lineY(aapl, {x: "Date", y: "Close"})
  ]
})A plot can have multiple marks, and each mark has its own data. For example, say we had a similar table goog representing the daily price of Google stock for the same period. Below, the red line represents Google stock, while the blue line represents Apple stock.ForkjsPlot.plot({
  marks: [
    Plot.ruleY([0]),
    Plot.lineY(goog, {x: "Date", y: "Close", stroke: "red"}),
    Plot.lineY(aapl, {x: "Date", y: "Close", stroke: "blue"})
  ]
})TIPWhen comparing the performance of different stocks, we typically want to normalize the return relative to a purchase price. See the normalize transform for an example.Alternatively, the tables can be combined, say with a Symbol column to distinguish AAPL from GOOG. This allows the use of a categorical color scale and legend.ForkjsPlot.plot({
  color: {legend: true},
  marks: [
    Plot.ruleY([0]),
    Plot.lineY(stocks, {x: "Date", y: "Close", stroke: "Symbol"})
  ]
})Each mark has its own options, and different mark types support different options. See the respective mark type (such as bar or dot) for details.Marks are drawn in the given order, with the last mark drawn on top. For example, below green bars are drawn on top of black bars.ForkjsPlot.plot({
  x: {padding: 0.4},
  marks: [
    Plot.barY(alphabet, {x: "letter", y: "frequency", dx: 2, dy: 2}),
    Plot.barY(alphabet, {x: "letter", y: "frequency", fill: "green", dx: -2, dy: -2})
  ]
})Layout options ​The layout options determine the overall size of the plot; all are specified as numbers in pixels:marginTop - the top marginmarginRight - the right marginmarginBottom - the bottom marginmarginLeft - the left marginmargin - shorthand for the four marginswidth - the outer width of the plot (including margins)height - the outer height of the plot (including margins)Experiment with the margins by adjusting the sliders below. Note that because the x scale is a band scale, the round option defaults to true, so the bars may jump when you adjust the horizontal margins to snap to crisp edges.marginTop:20marginRight:20marginBottom:30marginLeft:40jsPlot.plot({
  marginTop,
  marginRight,
  marginBottom,
  marginLeft,
  grid: true,
  marks: [
    Plot.frame({
      stroke: "var(--vp-c-text-2)",
      strokeOpacity: 0.5,
      insetTop: -marginTop,
      insetRight: -marginRight,
      insetBottom: -marginBottom,
      insetLeft: -marginLeft,
    }),
    Plot.barY(alphabet, {x: "letter", y: "frequency", fill: "green"}),
    Plot.frame()
  ]
})jsPlot.plot({
  marginTop: 20,
  marginRight: 20,
  marginBottom: 30,
  marginLeft: 40,
  grid: true,
  marks: [
    Plot.barY(alphabet, {x: "letter", y: "frequency", fill: "green"}),
    Plot.frame()
  ]
})INFOTo assist the explanation, the plot above is drawn with a light gray border.The default width is 640. On Observable, the width can be set to the standard width to make responsive plots. The default height is chosen automatically based on the plot’s associated scales; for example, if y is linear and there is no fy scale, it might be 396. The default margins depend on the maximum margins of the plot’s constituent marks. While most marks default to zero margins (because they are drawn inside the chart area), Plot’s axis mark has non-zero default margins.TIPPlot does not adjust margins automatically to make room for long tick labels. If your y axis labels are too long, you can increase the marginLeft to make more room. Also consider using a different tickFormat for short labels (e.g., s for SI prefix notation), or a scale transform (say to convert units to millions or billions).The aspectRatio option ^0.6.4, if not null, computes a default height such that a variation of one unit in the x dimension is represented by the corresponding number of pixels as a variation in the y dimension of one unit. The aspectRatio option is recommended only when x and y domains share the same units, such as millimeters. When a position scale is ordinal (point or band), consecutive domain values are treated as one unit length apart; for example, if both x and y are ordinal, then an aspect ratio of one produces a square grid. Use fixed aspect ratio: ForkjsPlot.plot({
  grid: true,
  inset: 10,
  aspectRatio: fixed ? 1 : undefined,
  color: {legend: true},
  marks: [
    Plot.frame(),
    Plot.dot(penguins, {x: "culmen_length_mm", y: "culmen_depth_mm", stroke: "species"})
  ]
})TIPWhen using facets, set the fx and fy scales’ round option to false if you need an exact aspect ratio.Other options ​By default, plot returns an SVG element; however, if the plot includes a title, subtitle, legend, or caption, plot wraps the SVG element with an HTML figure element. You can also force Plot to generate a figure element by setting the figure option ^0.6.10 to true.The title & subtitle options ^0.6.10 and the caption option accept either a string or an HTML element. If given an HTML element, say using the html tagged template literal, the title and subtitle are used as-is while the caption is wrapped in a figcaption element; otherwise, the specified text will be escaped and wrapped in an h2, h3, or figcaption, respectively.For charts, an informative titleSubtitle to follow with additional contextFigure 1. A chart with a title, subtitle, and caption.ForkjsPlot.plot({
  title: "For charts, an informative title",
  subtitle: "Subtitle to follow with additional context",
  caption: "Figure 1. A chart with a title, subtitle, and caption.",
  marks: [
    Plot.frame(),
    Plot.text(["Titles, subtitles, captions, and annotations assist inter­pretation by telling the reader what’s interesting. Don’t make the reader work to find what you already know."], {lineWidth: 30, frameAnchor: "middle"})
  ]
})The style option allows custom styles to override Plot’s defaults. It may be specified either as a string of inline styles (e.g., "color: red;", in the same fashion as assigning element.style) or an object of properties (e.g., {color: "red"}, in the same fashion as assigning element.style properties). By default, the returned plot has a max-width of 100%, and the system-ui font. Plot’s marks and axes default to currentColor, meaning that they will inherit the surrounding content’s color.CAUTIONUnitless numbers (quirky lengths) such as {padding: 20} are not supported by some browsers; you should instead specify a string with units such as {padding: "20px"}.The generated SVG element has a class name which applies a default stylesheet. Use the top-level className option to specify that class name.The clip option ^0.6.10 determines the default clipping behavior if the mark clip option is not specified; set it to true to enable clipping. This option does not affect axis, grid, and frame marks, whose clip option defaults to false.The document option specifies the document used to create plot elements. It defaults to window.document, but can be changed to another document, say when using a virtual DOM implementation for server-side rendering in Node.plot(options) ​jsPlot.plot({
  height: 200,
  marks: [
    Plot.barY(alphabet, {x: "letter", y: "frequency"})
  ]
})Renders a new plot with the specified options, returning a SVG or HTML figure element. This element can then be inserted into the page as described in the getting started guide.mark.plot(options) ​jsPlot.barY(alphabet, {x: "letter", y: "frequency"}).plot({height: 200})Given a mark, this is a convenience shorthand for calling plot where the marks option includes this mark. Any additional marks in options are drawn on top of this mark.plot.scale(name) ​jsconst plot = Plot.plot(options); // render a plot
const color = plot.scale("color"); // get the color scale
console.log(color.range); // inspect the scale’s rangeReturns the scale object for the scale with the specified name (such as x or color) on the given plot, where plot is a rendered plot element returned by plot. If the associated plot has no scale with the given name, returns undefined.plot.legend(name, options) ​jsconst plot = Plot.plot(options); // render a plot
const legend = plot.legend("color"); // render a color legendRenders a standalone legend for the scale with the specified name (such as x or color) on the given plot, where plot is a rendered plot element returned by plot, returning a SVG or HTML figure element. This element can then be inserted into the page as described in the getting started guide. If the associated plot has no scale with the given name, returns undefined. Legends are currently only supported for color, opacity, and symbol scales.PagerPrevious pageGetting startedNext pageMarks\n\nPlots ​To render a plot in Observable Plot, call plot (typically as Plot.plot), passing in the desired options. This function returns an SVG or HTML figure element.ForkjsPlot.plot({
  marks: [
    Plot.frame(),
    Plot.text(["Hello, world!"], {frameAnchor: "middle"})
  ]
})TIPThe returned plot element is detached; it must be inserted into the page to be visible. For help, see the getting started guide.Marks option ​The marks option specifies an array of marks to render. Above, there are two marks: a frame to draw the outline of the plot frame, and a text to say hello. 👋Each mark supplies its own tabular data. For example, the table below shows the first five rows of a daily dataset of Apple stock price (aapl).DateOpenHighLowCloseVolume2013-05-1364.50142765.41428464.50000064.962860792372002013-05-1464.83571665.02857263.16428863.4085731117795002013-05-1562.73714463.00000060.33714361.2642861854034002013-05-1660.46285662.54999959.84285762.0828591508010002013-05-1762.72142862.86999961.57285761.894287106976100In JavaScript, we can represent tabular data as an array of objects. Each object records a daily observation, with properties Date, Open, High, and so on. This is known as a “row-based” format since each object corresponds to a row in the table.jsaapl = [
  {Date: new Date("2013-05-13"), Open: 64.501427, High: 65.414284, Low: 64.500000, Close: 64.962860, Volume: 79237200},
  {Date: new Date("2013-05-14"), Open: 64.835716, High: 65.028572, Low: 63.164288, Close: 63.408573, Volume: 111779500},
  {Date: new Date("2013-05-15"), Open: 62.737144, High: 63.000000, Low: 60.337143, Close: 61.264286, Volume: 185403400},
  {Date: new Date("2013-05-16"), Open: 60.462856, High: 62.549999, Low: 59.842857, Close: 62.082859, Volume: 150801000},
  {Date: new Date("2013-05-17"), Open: 62.721428, High: 62.869999, Low: 61.572857, Close: 61.894287, Volume: 106976100}
]TIPRather than baking data into JavaScript, use JSON or CSV files to store data. You can use d3.json, d3.csv, or fetch to load a file. On Observable, you can also use a file attachment or SQL cell.To use data with Plot, pass the data as the first argument to the mark constructor. We can then assign columns of data such as Date and Close to visual properties of the mark (or “channels”) such as horizontal↔︎ position x and vertical↕︎ position y.ForkjsPlot.plot({
  marks: [
    Plot.lineY(aapl, {x: "Date", y: "Close"})
  ]
})A plot can have multiple marks, and each mark has its own data. For example, say we had a similar table goog representing the daily price of Google stock for the same period. Below, the red line represents Google stock, while the blue line represents Apple stock.ForkjsPlot.plot({
  marks: [
    Plot.ruleY([0]),
    Plot.lineY(goog, {x: "Date", y: "Close", stroke: "red"}),
    Plot.lineY(aapl, {x: "Date", y: "Close", stroke: "blue"})
  ]
})TIPWhen comparing the performance of different stocks, we typically want to normalize the return relative to a purchase price. See the normalize transform for an example.Alternatively, the tables can be combined, say with a Symbol column to distinguish AAPL from GOOG. This allows the use of a categorical color scale and legend.ForkjsPlot.plot({
  color: {legend: true},
  marks: [
    Plot.ruleY([0]),
    Plot.lineY(stocks, {x: "Date", y: "Close", stroke: "Symbol"})
  ]
})Each mark has its own options, and different mark types support different options. See the respective mark type (such as bar or dot) for details.Marks are drawn in the given order, with the last mark drawn on top. For example, below green bars are drawn on top of black bars.ForkjsPlot.plot({
  x: {padding: 0.4},
  marks: [
    Plot.barY(alphabet, {x: "letter", y: "frequency", dx: 2, dy: 2}),
    Plot.barY(alphabet, {x: "letter", y: "frequency", fill: "green", dx: -2, dy: -2})
  ]
})Layout options ​The layout options determine the overall size of the plot; all are specified as numbers in pixels:marginTop - the top marginmarginRight - the right marginmarginBottom - the bottom marginmarginLeft - the left marginmargin - shorthand for the four marginswidth - the outer width of the plot (including margins)height - the outer height of the plot (including margins)Experiment with the margins by adjusting the sliders below. Note that because the x scale is a band scale, the round option defaults to true, so the bars may jump when you adjust the horizontal margins to snap to crisp edges.marginTop:20marginRight:20marginBottom:30marginLeft:40jsPlot.plot({
  marginTop,
  marginRight,
  marginBottom,
  marginLeft,
  grid: true,
  marks: [
    Plot.frame({
      stroke: "var(--vp-c-text-2)",
      strokeOpacity: 0.5,
      insetTop: -marginTop,
      insetRight: -marginRight,
      insetBottom: -marginBottom,
      insetLeft: -marginLeft,
    }),
    Plot.barY(alphabet, {x: "letter", y: "frequency", fill: "green"}),
    Plot.frame()
  ]
})jsPlot.plot({
  marginTop: 20,
  marginRight: 20,
  marginBottom: 30,
  marginLeft: 40,
  grid: true,
  marks: [
    Plot.barY(alphabet, {x: "letter", y: "frequency", fill: "green"}),
    Plot.frame()
  ]
})INFOTo assist the explanation, the plot above is drawn with a light gray border.The default width is 640. On Observable, the width can be set to the standard width to make responsive plots. The default height is chosen automatically based on the plot’s associated scales; for example, if y is linear and there is no fy scale, it might be 396. The default margins depend on the maximum margins of the plot’s constituent marks. While most marks default to zero margins (because they are drawn inside the chart area), Plot’s axis mark has non-zero default margins.TIPPlot does not adjust margins automatically to make room for long tick labels. If your y axis labels are too long, you can increase the marginLeft to make more room. Also consider using a different tickFormat for short labels (e.g., s for SI prefix notation), or a scale transform (say to convert units to millions or billions).The aspectRatio option ^0.6.4, if not null, computes a default height such that a variation of one unit in the x dimension is represented by the corresponding number of pixels as a variation in the y dimension of one unit. The aspectRatio option is recommended only when x and y domains share the same units, such as millimeters. When a position scale is ordinal (point or band), consecutive domain values are treated as one unit length apart; for example, if both x and y are ordinal, then an aspect ratio of one produces a square grid. Use fixed aspect ratio: ForkjsPlot.plot({
  grid: true,
  inset: 10,
  aspectRatio: fixed ? 1 : undefined,
  color: {legend: true},
  marks: [
    Plot.frame(),
    Plot.dot(penguins, {x: "culmen_length_mm", y: "culmen_depth_mm", stroke: "species"})
  ]
})TIPWhen using facets, set the fx and fy scales’ round option to false if you need an exact aspect ratio.Other options ​By default, plot returns an SVG element; however, if the plot includes a title, subtitle, legend, or caption, plot wraps the SVG element with an HTML figure element. You can also force Plot to generate a figure element by setting the figure option ^0.6.10 to true.The title & subtitle options ^0.6.10 and the caption option accept either a string or an HTML element. If given an HTML element, say using the html tagged template literal, the title and subtitle are used as-is while the caption is wrapped in a figcaption element; otherwise, the specified text will be escaped and wrapped in an h2, h3, or figcaption, respectively.For charts, an informative titleSubtitle to follow with additional contextFigure 1. A chart with a title, subtitle, and caption.ForkjsPlot.plot({
  title: "For charts, an informative title",
  subtitle: "Subtitle to follow with additional context",
  caption: "Figure 1. A chart with a title, subtitle, and caption.",
  marks: [
    Plot.frame(),
    Plot.text(["Titles, subtitles, captions, and annotations assist inter­pretation by telling the reader what’s interesting. Don’t make the reader work to find what you already know."], {lineWidth: 30, frameAnchor: "middle"})
  ]
})The style option allows custom styles to override Plot’s defaults. It may be specified either as a string of inline styles (e.g., "color: red;", in the same fashion as assigning element.style) or an object of properties (e.g., {color: "red"}, in the same fashion as assigning element.style properties). By default, the returned plot has a max-width of 100%, and the system-ui font. Plot’s marks and axes default to currentColor, meaning that they will inherit the surrounding content’s color.CAUTIONUnitless numbers (quirky lengths) such as {padding: 20} are not supported by some browsers; you should instead specify a string with units such as {padding: "20px"}.The generated SVG element has a class name which applies a default stylesheet. Use the top-level className option to specify that class name.The clip option ^0.6.10 determines the default clipping behavior if the mark clip option is not specified; set it to true to enable clipping. This option does not affect axis, grid, and frame marks, whose clip option defaults to false.The document option specifies the document used to create plot elements. It defaults to window.document, but can be changed to another document, say when using a virtual DOM implementation for server-side rendering in Node.plot(options) ​jsPlot.plot({
  height: 200,
  marks: [
    Plot.barY(alphabet, {x: "letter", y: "frequency"})
  ]
})Renders a new plot with the specified options, returning a SVG or HTML figure element. This element can then be inserted into the page as described in the getting started guide.mark.plot(options) ​jsPlot.barY(alphabet, {x: "letter", y: "frequency"}).plot({height: 200})Given a mark, this is a convenience shorthand for calling plot where the marks option includes this mark. Any additional marks in options are drawn on top of this mark.plot.scale(name) ​jsconst plot = Plot.plot(options); // render a plot
const color = plot.scale("color"); // get the color scale
console.log(color.range); // inspect the scale’s rangeReturns the scale object for the scale with the specified name (such as x or color) on the given plot, where plot is a rendered plot element returned by plot. If the associated plot has no scale with the given name, returns undefined.plot.legend(name, options) ​jsconst plot = Plot.plot(options); // render a plot
const legend = plot.legend("color"); // render a color legendRenders a standalone legend for the scale with the specified name (such as x or color) on the given plot, where plot is a rendered plot element returned by plot, returning a SVG or HTML figure element. This element can then be inserted into the page as described in the getting started guide. If the associated plot has no scale with the given name, returns undefined. Legends are currently only supported for color, opacity, and symbol scales.\n\n\n\nInteractions ​Interaction allows reading values out of a plot (details on demand), or fluidly changing a view of data without editing code (zoom and filter). There are a variety of ways to achieve interaction with Plot, including built-in interaction features and development techniques with frameworks such as Observable and React.Pointing ​When looking at a scatterplot, the reader may wonder, what abstract values does this dot represent?The pointer transform can provide an answer: it dynamically filters a mark such that only the data closest to the pointer (such as the mouse) is rendered. The pointer transform is often paired with the tip mark for interactive tooltips, revealing exact values as the pointer moves over the plot. The tip can show additional fields not otherwise visible, such as the name and sport of Olympic athletes below.ForkjsPlot.dot(olympians, {
  x: "weight",
  y: "height",
  stroke: "sex",
  channels: {name: "name", sport: "sport"},
  tip: true
}).plot()The crosshair mark uses the pointer transform internally to display a rule and a text showing the x (horizontal↔︎ position) and y (vertical↕︎ position) value of the nearest data.ForkjsPlot.plot({
  marks: [
    Plot.dot(olympians, {x: "weight", y: "height", stroke: "sex"}),
    Plot.crosshair(olympians, {x: "weight", y: "height"})
  ]
})These values are displayed atop the axes on the edge of the frame; unlike the tip mark, the crosshair mark will not obscure other marks in the plot.Selecting ​Support for selecting points within a plot through direct manipulation is under development. If you are interested in this feature, please upvote #5. See #721 for some early work on brushing.Zooming ​Support for interactive panning and zooming is planned for a future release. If you are interested in this feature, please upvote #1590.Animation ​Support for declarative animation is planned for a future release. If you are interested in this feature, please upvote #166. See #995 for some early work on a time channel.Custom reactivity ​With the exception of render transforms (see the pointer transform implementation), Plot does not currently provide incremental re-rendering (partial updates to previously-rendered plots) or animated transitions between views.That said, you can simply throw away an old plot and replace it with a new one! This allows plotting of dynamic data: data which can change in real-time as it streams in, or because it is derived in response to external inputs such as range sliders and search boxes.On Observable, you can use viewof in conjunction with Observable Inputs (or other plots!) for interactivity. If your cell references another cell, it will automatically re-run whenever the upstream cell’s value changes. For example, try dragging the slider in this hexbin example. In React, use useEffect and useRef to re-render the plot when data changes. In Vue, use ref. For more, see our getting started guide.You can also manipulate the SVG that Plot creates, if you are comfortable using lower-level APIs; see examples by Mike Freeman and Philippe Rivière.\n\nSearchK0.6.17GitHub️ 4.6kOn this pageInteractions ​Interaction allows reading values out of a plot (details on demand), or fluidly changing a view of data without editing code (zoom and filter). There are a variety of ways to achieve interaction with Plot, including built-in interaction features and development techniques with frameworks such as Observable and React.Pointing ​When looking at a scatterplot, the reader may wonder, what abstract values does this dot represent?The pointer transform can provide an answer: it dynamically filters a mark such that only the data closest to the pointer (such as the mouse) is rendered. The pointer transform is often paired with the tip mark for interactive tooltips, revealing exact values as the pointer moves over the plot. The tip can show additional fields not otherwise visible, such as the name and sport of Olympic athletes below.ForkjsPlot.dot(olympians, {
  x: "weight",
  y: "height",
  stroke: "sex",
  channels: {name: "name", sport: "sport"},
  tip: true
}).plot()The crosshair mark uses the pointer transform internally to display a rule and a text showing the x (horizontal↔︎ position) and y (vertical↕︎ position) value of the nearest data.ForkjsPlot.plot({
  marks: [
    Plot.dot(olympians, {x: "weight", y: "height", stroke: "sex"}),
    Plot.crosshair(olympians, {x: "weight", y: "height"})
  ]
})These values are displayed atop the axes on the edge of the frame; unlike the tip mark, the crosshair mark will not obscure other marks in the plot.Selecting ​Support for selecting points within a plot through direct manipulation is under development. If you are interested in this feature, please upvote #5. See #721 for some early work on brushing.Zooming ​Support for interactive panning and zooming is planned for a future release. If you are interested in this feature, please upvote #1590.Animation ​Support for declarative animation is planned for a future release. If you are interested in this feature, please upvote #166. See #995 for some early work on a time channel.Custom reactivity ​With the exception of render transforms (see the pointer transform implementation), Plot does not currently provide incremental re-rendering (partial updates to previously-rendered plots) or animated transitions between views.That said, you can simply throw away an old plot and replace it with a new one! This allows plotting of dynamic data: data which can change in real-time as it streams in, or because it is derived in response to external inputs such as range sliders and search boxes.On Observable, you can use viewof in conjunction with Observable Inputs (or other plots!) for interactivity. If your cell references another cell, it will automatically re-run whenever the upstream cell’s value changes. For example, try dragging the slider in this hexbin example. In React, use useEffect and useRef to re-render the plot when data changes. In Vue, use ref. For more, see our getting started guide.You can also manipulate the SVG that Plot creates, if you are comfortable using lower-level APIs; see examples by Mike Freeman and Philippe Rivière.PagerPrevious pageTransformsNext pageFacets\n\nInteractions ​Interaction allows reading values out of a plot (details on demand), or fluidly changing a view of data without editing code (zoom and filter). There are a variety of ways to achieve interaction with Plot, including built-in interaction features and development techniques with frameworks such as Observable and React.Pointing ​When looking at a scatterplot, the reader may wonder, what abstract values does this dot represent?The pointer transform can provide an answer: it dynamically filters a mark such that only the data closest to the pointer (such as the mouse) is rendered. The pointer transform is often paired with the tip mark for interactive tooltips, revealing exact values as the pointer moves over the plot. The tip can show additional fields not otherwise visible, such as the name and sport of Olympic athletes below.ForkjsPlot.dot(olympians, {
  x: "weight",
  y: "height",
  stroke: "sex",
  channels: {name: "name", sport: "sport"},
  tip: true
}).plot()The crosshair mark uses the pointer transform internally to display a rule and a text showing the x (horizontal↔︎ position) and y (vertical↕︎ position) value of the nearest data.ForkjsPlot.plot({
  marks: [
    Plot.dot(olympians, {x: "weight", y: "height", stroke: "sex"}),
    Plot.crosshair(olympians, {x: "weight", y: "height"})
  ]
})These values are displayed atop the axes on the edge of the frame; unlike the tip mark, the crosshair mark will not obscure other marks in the plot.Selecting ​Support for selecting points within a plot through direct manipulation is under development. If you are interested in this feature, please upvote #5. See #721 for some early work on brushing.Zooming ​Support for interactive panning and zooming is planned for a future release. If you are interested in this feature, please upvote #1590.Animation ​Support for declarative animation is planned for a future release. If you are interested in this feature, please upvote #166. See #995 for some early work on a time channel.Custom reactivity ​With the exception of render transforms (see the pointer transform implementation), Plot does not currently provide incremental re-rendering (partial updates to previously-rendered plots) or animated transitions between views.That said, you can simply throw away an old plot and replace it with a new one! This allows plotting of dynamic data: data which can change in real-time as it streams in, or because it is derived in response to external inputs such as range sliders and search boxes.On Observable, you can use viewof in conjunction with Observable Inputs (or other plots!) for interactivity. If your cell references another cell, it will automatically re-run whenever the upstream cell’s value changes. For example, try dragging the slider in this hexbin example. In React, use useEffect and useRef to re-render the plot when data changes. In Vue, use ref. For more, see our getting started guide.You can also manipulate the SVG that Plot creates, if you are comfortable using lower-level APIs; see examples by Mike Freeman and Philippe Rivière.\n\n\n\nLegends ^0.3.0 ​Plot can generate legends for color, opacity, and symbol scales. For example, the scatterplot below of body measurements of Olympic athletes includes a legend for its color scale, allowing the meaning of color to be interpreted by the reader. (The axes similarly document the meaning of the x and y position scales.)ForkjsPlot.plot({
  color: {legend: true},
  marks: [
    Plot.dot(olympians, {x: "weight", y: "height", stroke: "sex"})
  ]
})The legend above is a swatches legend because the color scale is ordinal (with a categorical scheme). When the color scale is continuous, a ramp legend with a smooth gradient is generated instead. The plot below of global average surface temperature (GISTEMP) uses a diverging color scale to indicate the deviation from the 1951–1980 average in degrees Celsius.ForkjsPlot.plot({
  color: {
    scheme: "BuRd",
    legend: true
  },
  marks: [
    Plot.ruleY([0]),
    Plot.dot(gistemp, {x: "Date", y: "Anomaly", stroke: "Anomaly"})
  ]
})When an ordinal color scale is used redundantly with a symbol scale, the symbol legend will incorporate the color encoding. This is more accessible than using color alone, particularly for readers with color vision deficiency.ForkjsPlot.plot({
  grid: true,
  x: {label: "Body mass (g)"},
  y: {label: "Flipper length (mm)"},
  symbol: {legend: true},
  marks: [
    Plot.dot(penguins, {x: "body_mass_g", y: "flipper_length_mm", stroke: "species", symbol: "species"})
  ]
})Plot does not yet generate legends for the r (radius) scale or the length scale. If you are interested in this feature, please upvote #236. In the meantime, you can implement a legend using marks as demonstrated in the spike map example.Legend options ​If the legend scale option is true, the default legend will be produced for the scale; otherwise, the meaning of the legend option depends on the scale: for quantitative color scales, it defaults to ramp but may be set to swatches for a discrete scale (most commonly for threshold color scales); for ordinal color scales and symbol scales, only the swatches value is supported. If the *legend scale option is undefined, it will be inherited from the top-level legend plot option. prereleaseCategorical and ordinal color legends are rendered as swatches, unless the legend option is set to ramp. The swatches can be configured with the following options:tickFormat - a format function for the labelsswatchSize - the size of the swatch (if square)swatchWidth - the swatches’ widthswatchHeight - the swatches’ heightcolumns - the number of swatches per rowmarginLeft - the legend’s left marginclassName - a class name, that defaults to a randomly generated string scoping the stylesopacity - the swatch fill opacity ^0.6.5width - the legend’s width (in pixels)Symbol legends are rendered as swatches and support the options above in addition to the following options:fill - the symbol fill colorfillOpacity - the symbol fill opacity; defaults to 1stroke - the symbol stroke colorstrokeOpacity - the symbol stroke opacity; defaults to 1strokeWidth - the symbol stroke width; defaults to 1.5r - the symbol radius; defaults to 4.5 pixelsThe fill and stroke symbol legend options can be specified as “color” to apply the color scale when the symbol scale is a redundant encoding. The fill defaults to none. The stroke defaults to currentColor if the fill is none, and to none otherwise. The fill and stroke options may also be inherited from the corresponding options on an associated dot mark.Continuous color legends are rendered as a ramp, and can be configured with the following options:label - the scale’s labelticks - the desired number of ticks, or an array of tick valuestickFormat - a format function for the legend’s tickstickSize - the tick sizeround - if true (default), round tick positions to pixelswidth - the legend’s widthheight - the legend’s heightmarginTop - the legend’s top marginmarginRight - the legend’s right marginmarginBottom - the legend’s bottom marginmarginLeft - the legend’s left marginopacity - the ramp’s fill opacityThe style legend option allows custom styles to override Plot’s defaults; it has the same behavior as in Plot’s top-level plot options. The className option is suffixed with -ramp or -swatches, reflecting the legend type.legend(options) ​Renders a standalone legend for the scale defined by the given options object, returning a SVG or HTML figure element. This element can then be inserted into the page as described in the getting started guide. The options object must define at least one scale; see scale options for how to define a scale.For example, here is a ramp legend of a linear color scale with the default domain of [0, 1] and default scheme turbo:jsPlot.legend({color: {type: "linear"}})The options object may also include any additional legend options described in the previous section. For example, to make the above legend slightly wider:jsPlot.legend({width: 320, color: {type: "linear"}})\n\nSearchK0.6.17GitHub️ 4.6kOn this pageLegends ^0.3.0 ​Plot can generate legends for color, opacity, and symbol scales. For example, the scatterplot below of body measurements of Olympic athletes includes a legend for its color scale, allowing the meaning of color to be interpreted by the reader. (The axes similarly document the meaning of the x and y position scales.)ForkjsPlot.plot({
  color: {legend: true},
  marks: [
    Plot.dot(olympians, {x: "weight", y: "height", stroke: "sex"})
  ]
})The legend above is a swatches legend because the color scale is ordinal (with a categorical scheme). When the color scale is continuous, a ramp legend with a smooth gradient is generated instead. The plot below of global average surface temperature (GISTEMP) uses a diverging color scale to indicate the deviation from the 1951–1980 average in degrees Celsius.ForkjsPlot.plot({
  color: {
    scheme: "BuRd",
    legend: true
  },
  marks: [
    Plot.ruleY([0]),
    Plot.dot(gistemp, {x: "Date", y: "Anomaly", stroke: "Anomaly"})
  ]
})When an ordinal color scale is used redundantly with a symbol scale, the symbol legend will incorporate the color encoding. This is more accessible than using color alone, particularly for readers with color vision deficiency.ForkjsPlot.plot({
  grid: true,
  x: {label: "Body mass (g)"},
  y: {label: "Flipper length (mm)"},
  symbol: {legend: true},
  marks: [
    Plot.dot(penguins, {x: "body_mass_g", y: "flipper_length_mm", stroke: "species", symbol: "species"})
  ]
})Plot does not yet generate legends for the r (radius) scale or the length scale. If you are interested in this feature, please upvote #236. In the meantime, you can implement a legend using marks as demonstrated in the spike map example.Legend options ​If the legend scale option is true, the default legend will be produced for the scale; otherwise, the meaning of the legend option depends on the scale: for quantitative color scales, it defaults to ramp but may be set to swatches for a discrete scale (most commonly for threshold color scales); for ordinal color scales and symbol scales, only the swatches value is supported. If the *legend scale option is undefined, it will be inherited from the top-level legend plot option. prereleaseCategorical and ordinal color legends are rendered as swatches, unless the legend option is set to ramp. The swatches can be configured with the following options:tickFormat - a format function for the labelsswatchSize - the size of the swatch (if square)swatchWidth - the swatches’ widthswatchHeight - the swatches’ heightcolumns - the number of swatches per rowmarginLeft - the legend’s left marginclassName - a class name, that defaults to a randomly generated string scoping the stylesopacity - the swatch fill opacity ^0.6.5width - the legend’s width (in pixels)Symbol legends are rendered as swatches and support the options above in addition to the following options:fill - the symbol fill colorfillOpacity - the symbol fill opacity; defaults to 1stroke - the symbol stroke colorstrokeOpacity - the symbol stroke opacity; defaults to 1strokeWidth - the symbol stroke width; defaults to 1.5r - the symbol radius; defaults to 4.5 pixelsThe fill and stroke symbol legend options can be specified as “color” to apply the color scale when the symbol scale is a redundant encoding. The fill defaults to none. The stroke defaults to currentColor if the fill is none, and to none otherwise. The fill and stroke options may also be inherited from the corresponding options on an associated dot mark.Continuous color legends are rendered as a ramp, and can be configured with the following options:label - the scale’s labelticks - the desired number of ticks, or an array of tick valuestickFormat - a format function for the legend’s tickstickSize - the tick sizeround - if true (default), round tick positions to pixelswidth - the legend’s widthheight - the legend’s heightmarginTop - the legend’s top marginmarginRight - the legend’s right marginmarginBottom - the legend’s bottom marginmarginLeft - the legend’s left marginopacity - the ramp’s fill opacityThe style legend option allows custom styles to override Plot’s defaults; it has the same behavior as in Plot’s top-level plot options. The className option is suffixed with -ramp or -swatches, reflecting the legend type.legend(options) ​Renders a standalone legend for the scale defined by the given options object, returning a SVG or HTML figure element. This element can then be inserted into the page as described in the getting started guide. The options object must define at least one scale; see scale options for how to define a scale.For example, here is a ramp legend of a linear color scale with the default domain of [0, 1] and default scheme turbo:jsPlot.legend({color: {type: "linear"}})The options object may also include any additional legend options described in the previous section. For example, to make the above legend slightly wider:jsPlot.legend({width: 320, color: {type: "linear"}})PagerPrevious pageFacetsNext pageCurves\n\nLegends ^0.3.0 ​Plot can generate legends for color, opacity, and symbol scales. For example, the scatterplot below of body measurements of Olympic athletes includes a legend for its color scale, allowing the meaning of color to be interpreted by the reader. (The axes similarly document the meaning of the x and y position scales.)ForkjsPlot.plot({
  color: {legend: true},
  marks: [
    Plot.dot(olympians, {x: "weight", y: "height", stroke: "sex"})
  ]
})The legend above is a swatches legend because the color scale is ordinal (with a categorical scheme). When the color scale is continuous, a ramp legend with a smooth gradient is generated instead. The plot below of global average surface temperature (GISTEMP) uses a diverging color scale to indicate the deviation from the 1951–1980 average in degrees Celsius.ForkjsPlot.plot({
  color: {
    scheme: "BuRd",
    legend: true
  },
  marks: [
    Plot.ruleY([0]),
    Plot.dot(gistemp, {x: "Date", y: "Anomaly", stroke: "Anomaly"})
  ]
})When an ordinal color scale is used redundantly with a symbol scale, the symbol legend will incorporate the color encoding. This is more accessible than using color alone, particularly for readers with color vision deficiency.ForkjsPlot.plot({
  grid: true,
  x: {label: "Body mass (g)"},
  y: {label: "Flipper length (mm)"},
  symbol: {legend: true},
  marks: [
    Plot.dot(penguins, {x: "body_mass_g", y: "flipper_length_mm", stroke: "species", symbol: "species"})
  ]
})Plot does not yet generate legends for the r (radius) scale or the length scale. If you are interested in this feature, please upvote #236. In the meantime, you can implement a legend using marks as demonstrated in the spike map example.Legend options ​If the legend scale option is true, the default legend will be produced for the scale; otherwise, the meaning of the legend option depends on the scale: for quantitative color scales, it defaults to ramp but may be set to swatches for a discrete scale (most commonly for threshold color scales); for ordinal color scales and symbol scales, only the swatches value is supported. If the *legend scale option is undefined, it will be inherited from the top-level legend plot option. prereleaseCategorical and ordinal color legends are rendered as swatches, unless the legend option is set to ramp. The swatches can be configured with the following options:tickFormat - a format function for the labelsswatchSize - the size of the swatch (if square)swatchWidth - the swatches’ widthswatchHeight - the swatches’ heightcolumns - the number of swatches per rowmarginLeft - the legend’s left marginclassName - a class name, that defaults to a randomly generated string scoping the stylesopacity - the swatch fill opacity ^0.6.5width - the legend’s width (in pixels)Symbol legends are rendered as swatches and support the options above in addition to the following options:fill - the symbol fill colorfillOpacity - the symbol fill opacity; defaults to 1stroke - the symbol stroke colorstrokeOpacity - the symbol stroke opacity; defaults to 1strokeWidth - the symbol stroke width; defaults to 1.5r - the symbol radius; defaults to 4.5 pixelsThe fill and stroke symbol legend options can be specified as “color” to apply the color scale when the symbol scale is a redundant encoding. The fill defaults to none. The stroke defaults to currentColor if the fill is none, and to none otherwise. The fill and stroke options may also be inherited from the corresponding options on an associated dot mark.Continuous color legends are rendered as a ramp, and can be configured with the following options:label - the scale’s labelticks - the desired number of ticks, or an array of tick valuestickFormat - a format function for the legend’s tickstickSize - the tick sizeround - if true (default), round tick positions to pixelswidth - the legend’s widthheight - the legend’s heightmarginTop - the legend’s top marginmarginRight - the legend’s right marginmarginBottom - the legend’s bottom marginmarginLeft - the legend’s left marginopacity - the ramp’s fill opacityThe style legend option allows custom styles to override Plot’s defaults; it has the same behavior as in Plot’s top-level plot options. The className option is suffixed with -ramp or -swatches, reflecting the legend type.legend(options) ​Renders a standalone legend for the scale defined by the given options object, returning a SVG or HTML figure element. This element can then be inserted into the page as described in the getting started guide. The options object must define at least one scale; see scale options for how to define a scale.For example, here is a ramp legend of a linear color scale with the default domain of [0, 1] and default scheme turbo:jsPlot.legend({color: {type: "linear"}})The options object may also include any additional legend options described in the previous section. For example, to make the above legend slightly wider:jsPlot.legend({width: 320, color: {type: "linear"}})\n\n\n\nCurves ​A curve defines how to turn a discrete representation of a line as a sequence of points [[x₀, y₀], [x₁, y₁], [x₂, y₂], …] into a continuous path; i.e., how to interpolate between points. Curves are used by the line, area, and link marks, and are implemented by d3-shape. Curve: basisbasis-openbasis-closedbump-xbump-ybundlecardinalcardinal-opencardinal-closedcatmull-romcatmull-rom-opencatmull-rom-closedlinearlinear-closedmonotone-xmonotone-ynaturalstepstep-afterstep-beforeForkjsPlot.plot({
  marks: [
    Plot.lineY(numbers, {curve: "catmull-rom"}),
    Plot.dotY(numbers, {x: (d, i) => i})
  ]
})The supported curve options are:curve - the curve method, either a string or a functiontension - the curve tension (for fine-tuning)The following named curve methods are supported:basis - a cubic basis spline (repeating the end points)basis-open - an open cubic basis splinebasis-closed - a closed cubic basis splinebump-x - a Bézier curve with horizontal tangentsbump-y - a Bézier curve with vertical tangentsbundle - a straightened cubic basis spline (suitable for lines only, not areas)cardinal - a cubic cardinal spline (with one-sided differences at the ends)cardinal-open - an open cubic cardinal splinecardinal-closed - an closed cubic cardinal splinecatmull-rom - a cubic Catmull–Rom spline (with one-sided differences at the ends)catmull-rom-open - an open cubic Catmull–Rom splinecatmull-rom-closed - a closed cubic Catmull–Rom splinelinear - a piecewise linear curve (i.e., straight line segments)linear-closed - a closed piecewise linear curve (i.e., straight line segments)monotone-x - a cubic spline that preserves monotonicity in xmonotone-y - a cubic spline that preserves monotonicity in ynatural - a natural cubic splinestep - a piecewise constant function where y changes at the midpoint of xstep-after - a piecewise constant function where y changes after xstep-before - a piecewise constant function where x changes after yauto - like linear, but use the (possibly spherical) projection, if any ^0.6.1If curve is a function, it will be invoked with a given context in the same fashion as a D3 curve factory. The auto curve is only available for the line mark and link mark and is typically used in conjunction with a spherical projection to interpolate along geodesics.The tension option only has an effect on bundle, cardinal and Catmull–Rom splines (bundle, cardinal, cardinal-open, cardinal-closed, catmull-rom, catmull-rom-open, and catmull-rom-closed). For bundle splines, it corresponds to beta; for cardinal splines, tension; for Catmull–Rom splines, alpha.\n\nSearchK0.6.17GitHub️ 4.6kOn this pageCurves ​A curve defines how to turn a discrete representation of a line as a sequence of points [[x₀, y₀], [x₁, y₁], [x₂, y₂], …] into a continuous path; i.e., how to interpolate between points. Curves are used by the line, area, and link marks, and are implemented by d3-shape. Curve: basisbasis-openbasis-closedbump-xbump-ybundlecardinalcardinal-opencardinal-closedcatmull-romcatmull-rom-opencatmull-rom-closedlinearlinear-closedmonotone-xmonotone-ynaturalstepstep-afterstep-beforeForkjsPlot.plot({
  marks: [
    Plot.lineY(numbers, {curve: "catmull-rom"}),
    Plot.dotY(numbers, {x: (d, i) => i})
  ]
})The supported curve options are:curve - the curve method, either a string or a functiontension - the curve tension (for fine-tuning)The following named curve methods are supported:basis - a cubic basis spline (repeating the end points)basis-open - an open cubic basis splinebasis-closed - a closed cubic basis splinebump-x - a Bézier curve with horizontal tangentsbump-y - a Bézier curve with vertical tangentsbundle - a straightened cubic basis spline (suitable for lines only, not areas)cardinal - a cubic cardinal spline (with one-sided differences at the ends)cardinal-open - an open cubic cardinal splinecardinal-closed - an closed cubic cardinal splinecatmull-rom - a cubic Catmull–Rom spline (with one-sided differences at the ends)catmull-rom-open - an open cubic Catmull–Rom splinecatmull-rom-closed - a closed cubic Catmull–Rom splinelinear - a piecewise linear curve (i.e., straight line segments)linear-closed - a closed piecewise linear curve (i.e., straight line segments)monotone-x - a cubic spline that preserves monotonicity in xmonotone-y - a cubic spline that preserves monotonicity in ynatural - a natural cubic splinestep - a piecewise constant function where y changes at the midpoint of xstep-after - a piecewise constant function where y changes after xstep-before - a piecewise constant function where x changes after yauto - like linear, but use the (possibly spherical) projection, if any ^0.6.1If curve is a function, it will be invoked with a given context in the same fashion as a D3 curve factory. The auto curve is only available for the line mark and link mark and is typically used in conjunction with a spherical projection to interpolate along geodesics.The tension option only has an effect on bundle, cardinal and Catmull–Rom splines (bundle, cardinal, cardinal-open, cardinal-closed, catmull-rom, catmull-rom-open, and catmull-rom-closed). For bundle splines, it corresponds to beta; for cardinal splines, tension; for Catmull–Rom splines, alpha.PagerPrevious pageLegendsNext pageFormats\n\nCurves ​A curve defines how to turn a discrete representation of a line as a sequence of points [[x₀, y₀], [x₁, y₁], [x₂, y₂], …] into a continuous path; i.e., how to interpolate between points. Curves are used by the line, area, and link marks, and are implemented by d3-shape. Curve: basisbasis-openbasis-closedbump-xbump-ybundlecardinalcardinal-opencardinal-closedcatmull-romcatmull-rom-opencatmull-rom-closedlinearlinear-closedmonotone-xmonotone-ynaturalstepstep-afterstep-beforeForkjsPlot.plot({
  marks: [
    Plot.lineY(numbers, {curve: "catmull-rom"}),
    Plot.dotY(numbers, {x: (d, i) => i})
  ]
})The supported curve options are:curve - the curve method, either a string or a functiontension - the curve tension (for fine-tuning)The following named curve methods are supported:basis - a cubic basis spline (repeating the end points)basis-open - an open cubic basis splinebasis-closed - a closed cubic basis splinebump-x - a Bézier curve with horizontal tangentsbump-y - a Bézier curve with vertical tangentsbundle - a straightened cubic basis spline (suitable for lines only, not areas)cardinal - a cubic cardinal spline (with one-sided differences at the ends)cardinal-open - an open cubic cardinal splinecardinal-closed - an closed cubic cardinal splinecatmull-rom - a cubic Catmull–Rom spline (with one-sided differences at the ends)catmull-rom-open - an open cubic Catmull–Rom splinecatmull-rom-closed - a closed cubic Catmull–Rom splinelinear - a piecewise linear curve (i.e., straight line segments)linear-closed - a closed piecewise linear curve (i.e., straight line segments)monotone-x - a cubic spline that preserves monotonicity in xmonotone-y - a cubic spline that preserves monotonicity in ynatural - a natural cubic splinestep - a piecewise constant function where y changes at the midpoint of xstep-after - a piecewise constant function where y changes after xstep-before - a piecewise constant function where x changes after yauto - like linear, but use the (possibly spherical) projection, if any ^0.6.1If curve is a function, it will be invoked with a given context in the same fashion as a D3 curve factory. The auto curve is only available for the line mark and link mark and is typically used in conjunction with a spherical projection to interpolate along geodesics.The tension option only has an effect on bundle, cardinal and Catmull–Rom splines (bundle, cardinal, cardinal-open, cardinal-closed, catmull-rom, catmull-rom-open, and catmull-rom-closed). For bundle splines, it corresponds to beta; for cardinal splines, tension; for Catmull–Rom splines, alpha.\n\n\n\nFormats ​These helper functions are provided for convenience as a tickFormat option for the axis mark, as the text option for a text mark, or other use. See also d3-format, d3-time-format, and JavaScript’s built-in date formatting and number formatting.formatNumber(locale) ^0.6.15 ​jsPlot.formatNumber("en-US")(Math.PI) // "3.142"Returns a function that formats a given number according to the specified locale. The locale is a BCP 47 language tag and defaults to U.S. English.formatIsoDate(date) ​jsPlot.formatIsoDate(new Date("2020-01-01T00:00:00.000Z")) // "2020-01-01"Given a date, returns the shortest equivalent ISO 8601 UTC string. If the given date is not valid, returns "Invalid Date". See isoformat.formatWeekday(locale, format) ​ForkjsPlot.textX(d3.range(7)).plot({x: {tickFormat: Plot.formatWeekday()}})jsPlot.formatWeekday("es-MX", "long")(0) // "domingo"Returns a function that formats a given week day number (from 0 = Sunday to 6 = Saturday) according to the specified locale and format. The locale is a BCP 47 language tag and defaults to U.S. English. The format is a weekday format: either narrow, short, or long; if not specified, it defaults to short.formatMonth(locale, format) ​ForkjsPlot.textX(d3.range(12)).plot({x: {tickFormat: Plot.formatMonth(), ticks: 12}})jsPlot.formatMonth("es-MX", "long")(0) // "enero"Returns a function that formats a given month number (from 0 = January to 11 = December) according to the specified locale and format. The locale is a BCP 47 language tag and defaults to U.S. English. The format is a month format: either 2-digit, numeric, narrow, short, long; if not specified, it defaults to short.\n\nSearchK0.6.17GitHub️ 4.6kOn this pageFormats ​These helper functions are provided for convenience as a tickFormat option for the axis mark, as the text option for a text mark, or other use. See also d3-format, d3-time-format, and JavaScript’s built-in date formatting and number formatting.formatNumber(locale) ^0.6.15 ​jsPlot.formatNumber("en-US")(Math.PI) // "3.142"Returns a function that formats a given number according to the specified locale. The locale is a BCP 47 language tag and defaults to U.S. English.formatIsoDate(date) ​jsPlot.formatIsoDate(new Date("2020-01-01T00:00:00.000Z")) // "2020-01-01"Given a date, returns the shortest equivalent ISO 8601 UTC string. If the given date is not valid, returns "Invalid Date". See isoformat.formatWeekday(locale, format) ​ForkjsPlot.textX(d3.range(7)).plot({x: {tickFormat: Plot.formatWeekday()}})jsPlot.formatWeekday("es-MX", "long")(0) // "domingo"Returns a function that formats a given week day number (from 0 = Sunday to 6 = Saturday) according to the specified locale and format. The locale is a BCP 47 language tag and defaults to U.S. English. The format is a weekday format: either narrow, short, or long; if not specified, it defaults to short.formatMonth(locale, format) ​ForkjsPlot.textX(d3.range(12)).plot({x: {tickFormat: Plot.formatMonth(), ticks: 12}})jsPlot.formatMonth("es-MX", "long")(0) // "enero"Returns a function that formats a given month number (from 0 = January to 11 = December) according to the specified locale and format. The locale is a BCP 47 language tag and defaults to U.S. English. The format is a month format: either 2-digit, numeric, narrow, short, long; if not specified, it defaults to short.PagerPrevious pageCurvesNext pageIntervals\n\nFormats ​These helper functions are provided for convenience as a tickFormat option for the axis mark, as the text option for a text mark, or other use. See also d3-format, d3-time-format, and JavaScript’s built-in date formatting and number formatting.formatNumber(locale) ^0.6.15 ​jsPlot.formatNumber("en-US")(Math.PI) // "3.142"Returns a function that formats a given number according to the specified locale. The locale is a BCP 47 language tag and defaults to U.S. English.formatIsoDate(date) ​jsPlot.formatIsoDate(new Date("2020-01-01T00:00:00.000Z")) // "2020-01-01"Given a date, returns the shortest equivalent ISO 8601 UTC string. If the given date is not valid, returns "Invalid Date". See isoformat.formatWeekday(locale, format) ​ForkjsPlot.textX(d3.range(7)).plot({x: {tickFormat: Plot.formatWeekday()}})jsPlot.formatWeekday("es-MX", "long")(0) // "domingo"Returns a function that formats a given week day number (from 0 = Sunday to 6 = Saturday) according to the specified locale and format. The locale is a BCP 47 language tag and defaults to U.S. English. The format is a weekday format: either narrow, short, or long; if not specified, it defaults to short.formatMonth(locale, format) ​ForkjsPlot.textX(d3.range(12)).plot({x: {tickFormat: Plot.formatMonth(), ticks: 12}})jsPlot.formatMonth("es-MX", "long")(0) // "enero"Returns a function that formats a given month number (from 0 = January to 11 = December) according to the specified locale and format. The locale is a BCP 47 language tag and defaults to U.S. English. The format is a month format: either 2-digit, numeric, narrow, short, long; if not specified, it defaults to short.\n\n\n\nIntervals ^0.6.15 ​Plot provides several built-in interval implementations for use with the tick option for scales, as the thresholds option for a bin transform, or other use. See also d3-time. You can also implement custom intervals.At a minimum, intervals implement interval.floor and interval.offset. Range intervals additionally implement interval.range, and nice intervals additionally implement interval.ceil. These latter implementations are required in some contexts; see Plot’s TypeScript definitions for details.The interval.floor method takes a value and returns the corresponding value representing the greatest interval boundary less than or equal to the specified value. For example, for the “day” time interval, it returns the preceding midnight:jsPlot.utcInterval("day").floor(new Date("2013-04-12T12:34:56Z")) // 2013-04-12The interval.offset method takes a value and returns the corresponding value equal to value plus step intervals. If step is not specified it defaults to 1. If step is negative, then the returned value will be less than the specified value. For example:jsPlot.utcInterval("day").offset(new Date("2013-04-12T12:34:56Z"), 1) // 2013-04-13T12:34:56Z
Plot.utcInterval("day").offset(new Date("2013-04-12T12:34:56Z"), -2) // 2013-04-10T12:34:56ZThe interval.range method returns an array of values representing every interval boundary greater than or equal to start (inclusive) and less than stop (exclusive). The first value in the returned array is the least boundary greater than or equal to start; subsequent values are offset by intervals and floored.jsPlot.utcInterval("week").range(new Date("2013-04-12T12:34:56Z"), new Date("2013-05-12T12:34:56Z")) // [2013-04-14, 2013-04-21, 2013-04-28, 2013-05-05, 2013-05-12]The interval.ceil method returns the value representing the least interval boundary value greater than or equal to the specified value. For example, for the “day” time interval, it returns the preceding midnight:jsPlot.utcInterval("day").ceil(new Date("2013-04-12T12:34:56Z")) // 2013-04-13numberInterval(period) ​jsPlot.numberInterval(2)Given a number period, returns a corresponding range interval implementation. If period is a negative number, the resulting interval uses 1 / -period; this allows more precise results when period is a negative integer. The returned interval implements the interval.range, interval.floor, and interval.offset methods.timeInterval(period) ​jsPlot.timeInterval("2 days")Given a string period describing a local time interval, returns a corresponding nice interval implementation. The period can be second, minute, hour, day, week, month, quarter, half, year, monday, tuesday, wednesday, thursday, friday, saturday, or sunday, or a skip interval consisting of a number followed by the interval name (possibly pluralized), such as 3 months or 10 years. The returned interval implements the interval.range, interval.floor, interval.ceil, and interval.offset methods.utcInterval(period) ​jsPlot.utcInterval("2 days")Given a string period describing a UTC time interval, returns a corresponding nice interval implementation. The period can be second, minute, hour, day, week, month, quarter, half, year, monday, tuesday, wednesday, thursday, friday, saturday, or sunday, or a skip interval consisting of a number followed by the interval name (possibly pluralized), such as 3 months or 10 years. The returned interval implements the interval.range, interval.floor, interval.ceil, and interval.offset methods.\n\nSearchK0.6.17GitHub️ 4.6kOn this pageIntervals ^0.6.15 ​Plot provides several built-in interval implementations for use with the tick option for scales, as the thresholds option for a bin transform, or other use. See also d3-time. You can also implement custom intervals.At a minimum, intervals implement interval.floor and interval.offset. Range intervals additionally implement interval.range, and nice intervals additionally implement interval.ceil. These latter implementations are required in some contexts; see Plot’s TypeScript definitions for details.The interval.floor method takes a value and returns the corresponding value representing the greatest interval boundary less than or equal to the specified value. For example, for the “day” time interval, it returns the preceding midnight:jsPlot.utcInterval("day").floor(new Date("2013-04-12T12:34:56Z")) // 2013-04-12The interval.offset method takes a value and returns the corresponding value equal to value plus step intervals. If step is not specified it defaults to 1. If step is negative, then the returned value will be less than the specified value. For example:jsPlot.utcInterval("day").offset(new Date("2013-04-12T12:34:56Z"), 1) // 2013-04-13T12:34:56Z
Plot.utcInterval("day").offset(new Date("2013-04-12T12:34:56Z"), -2) // 2013-04-10T12:34:56ZThe interval.range method returns an array of values representing every interval boundary greater than or equal to start (inclusive) and less than stop (exclusive). The first value in the returned array is the least boundary greater than or equal to start; subsequent values are offset by intervals and floored.jsPlot.utcInterval("week").range(new Date("2013-04-12T12:34:56Z"), new Date("2013-05-12T12:34:56Z")) // [2013-04-14, 2013-04-21, 2013-04-28, 2013-05-05, 2013-05-12]The interval.ceil method returns the value representing the least interval boundary value greater than or equal to the specified value. For example, for the “day” time interval, it returns the preceding midnight:jsPlot.utcInterval("day").ceil(new Date("2013-04-12T12:34:56Z")) // 2013-04-13numberInterval(period) ​jsPlot.numberInterval(2)Given a number period, returns a corresponding range interval implementation. If period is a negative number, the resulting interval uses 1 / -period; this allows more precise results when period is a negative integer. The returned interval implements the interval.range, interval.floor, and interval.offset methods.timeInterval(period) ​jsPlot.timeInterval("2 days")Given a string period describing a local time interval, returns a corresponding nice interval implementation. The period can be second, minute, hour, day, week, month, quarter, half, year, monday, tuesday, wednesday, thursday, friday, saturday, or sunday, or a skip interval consisting of a number followed by the interval name (possibly pluralized), such as 3 months or 10 years. The returned interval implements the interval.range, interval.floor, interval.ceil, and interval.offset methods.utcInterval(period) ​jsPlot.utcInterval("2 days")Given a string period describing a UTC time interval, returns a corresponding nice interval implementation. The period can be second, minute, hour, day, week, month, quarter, half, year, monday, tuesday, wednesday, thursday, friday, saturday, or sunday, or a skip interval consisting of a number followed by the interval name (possibly pluralized), such as 3 months or 10 years. The returned interval implements the interval.range, interval.floor, interval.ceil, and interval.offset methods.PagerPrevious pageFormatsNext pageMarkers\n\nIntervals ^0.6.15 ​Plot provides several built-in interval implementations for use with the tick option for scales, as the thresholds option for a bin transform, or other use. See also d3-time. You can also implement custom intervals.At a minimum, intervals implement interval.floor and interval.offset. Range intervals additionally implement interval.range, and nice intervals additionally implement interval.ceil. These latter implementations are required in some contexts; see Plot’s TypeScript definitions for details.The interval.floor method takes a value and returns the corresponding value representing the greatest interval boundary less than or equal to the specified value. For example, for the “day” time interval, it returns the preceding midnight:jsPlot.utcInterval("day").floor(new Date("2013-04-12T12:34:56Z")) // 2013-04-12The interval.offset method takes a value and returns the corresponding value equal to value plus step intervals. If step is not specified it defaults to 1. If step is negative, then the returned value will be less than the specified value. For example:jsPlot.utcInterval("day").offset(new Date("2013-04-12T12:34:56Z"), 1) // 2013-04-13T12:34:56Z
Plot.utcInterval("day").offset(new Date("2013-04-12T12:34:56Z"), -2) // 2013-04-10T12:34:56ZThe interval.range method returns an array of values representing every interval boundary greater than or equal to start (inclusive) and less than stop (exclusive). The first value in the returned array is the least boundary greater than or equal to start; subsequent values are offset by intervals and floored.jsPlot.utcInterval("week").range(new Date("2013-04-12T12:34:56Z"), new Date("2013-05-12T12:34:56Z")) // [2013-04-14, 2013-04-21, 2013-04-28, 2013-05-05, 2013-05-12]The interval.ceil method returns the value representing the least interval boundary value greater than or equal to the specified value. For example, for the “day” time interval, it returns the preceding midnight:jsPlot.utcInterval("day").ceil(new Date("2013-04-12T12:34:56Z")) // 2013-04-13numberInterval(period) ​jsPlot.numberInterval(2)Given a number period, returns a corresponding range interval implementation. If period is a negative number, the resulting interval uses 1 / -period; this allows more precise results when period is a negative integer. The returned interval implements the interval.range, interval.floor, and interval.offset methods.timeInterval(period) ​jsPlot.timeInterval("2 days")Given a string period describing a local time interval, returns a corresponding nice interval implementation. The period can be second, minute, hour, day, week, month, quarter, half, year, monday, tuesday, wednesday, thursday, friday, saturday, or sunday, or a skip interval consisting of a number followed by the interval name (possibly pluralized), such as 3 months or 10 years. The returned interval implements the interval.range, interval.floor, interval.ceil, and interval.offset methods.utcInterval(period) ​jsPlot.utcInterval("2 days")Given a string period describing a UTC time interval, returns a corresponding nice interval implementation. The period can be second, minute, hour, day, week, month, quarter, half, year, monday, tuesday, wednesday, thursday, friday, saturday, or sunday, or a skip interval consisting of a number followed by the interval name (possibly pluralized), such as 3 months or 10 years. The returned interval implements the interval.range, interval.floor, interval.ceil, and interval.offset methods.\n\n\n\nMarkers ​A marker defines a graphic drawn on vertices of a line or link mark. Marker: nonearrowarrow-reversedotcirclecircle-stroketicktick-xtick-yForkjsPlot.plot({
  marks: [
    Plot.ruleY([0]),
    Plot.lineY(crimea, {x: "date", y: "deaths", stroke: "cause", marker: "circle"})
  ]
})The supported marker options are:markerStart - the marker for the starting point of a line segmentmarkerMid - the marker for any intermediate point of a line segmentmarkerEnd - the marker for the end point of a line segmentmarker - shorthand for setting the marker on all pointsThe following named markers are supported:none (default) - no markerarrow - an arrowhead with auto orientationarrow-reverse - an arrowhead with auto-start-reverse orientationdot - a filled circle without a stroke and 2.5px radiuscircle, equivalent to circle-fill - a filled circle with a white stroke and 3px radiuscircle-stroke - a hollow circle with a colored stroke and a white fill and 3px radiustick ^0.6.12 - a small opposing linetick-x ^0.6.12 - a small horizontal linetick-y ^0.6.12 - a small vertical lineIf marker is true, it defaults to circle. If marker is a function, it will be called with a given color and must return an SVG marker element.The primary color of a marker is inherited from the stroke of the associated mark. The arrow marker is automatically oriented such that it points in the tangential direction of the path at the position the marker is placed. The circle markers are centered around the given vertex.For lines whose curve is not linear, markers are not necessarily drawn at the data positions given by x and y; marker placement is determined by the (possibly Bézier) path segments generated by the curve. To ensure that symbols are drawn at a given x and y position, consider using a dot mark instead.\n\nSearchK0.6.17GitHub️ 4.6kOn this pageMarkers ​A marker defines a graphic drawn on vertices of a line or link mark. Marker: nonearrowarrow-reversedotcirclecircle-stroketicktick-xtick-yForkjsPlot.plot({
  marks: [
    Plot.ruleY([0]),
    Plot.lineY(crimea, {x: "date", y: "deaths", stroke: "cause", marker: "circle"})
  ]
})The supported marker options are:markerStart - the marker for the starting point of a line segmentmarkerMid - the marker for any intermediate point of a line segmentmarkerEnd - the marker for the end point of a line segmentmarker - shorthand for setting the marker on all pointsThe following named markers are supported:none (default) - no markerarrow - an arrowhead with auto orientationarrow-reverse - an arrowhead with auto-start-reverse orientationdot - a filled circle without a stroke and 2.5px radiuscircle, equivalent to circle-fill - a filled circle with a white stroke and 3px radiuscircle-stroke - a hollow circle with a colored stroke and a white fill and 3px radiustick ^0.6.12 - a small opposing linetick-x ^0.6.12 - a small horizontal linetick-y ^0.6.12 - a small vertical lineIf marker is true, it defaults to circle. If marker is a function, it will be called with a given color and must return an SVG marker element.The primary color of a marker is inherited from the stroke of the associated mark. The arrow marker is automatically oriented such that it points in the tangential direction of the path at the position the marker is placed. The circle markers are centered around the given vertex.For lines whose curve is not linear, markers are not necessarily drawn at the data positions given by x and y; marker placement is determined by the (possibly Bézier) path segments generated by the curve. To ensure that symbols are drawn at a given x and y position, consider using a dot mark instead.PagerPrevious pageIntervalsNext pageShorthand\n\nMarkers ​A marker defines a graphic drawn on vertices of a line or link mark. Marker: nonearrowarrow-reversedotcirclecircle-stroketicktick-xtick-yForkjsPlot.plot({
  marks: [
    Plot.ruleY([0]),
    Plot.lineY(crimea, {x: "date", y: "deaths", stroke: "cause", marker: "circle"})
  ]
})The supported marker options are:markerStart - the marker for the starting point of a line segmentmarkerMid - the marker for any intermediate point of a line segmentmarkerEnd - the marker for the end point of a line segmentmarker - shorthand for setting the marker on all pointsThe following named markers are supported:none (default) - no markerarrow - an arrowhead with auto orientationarrow-reverse - an arrowhead with auto-start-reverse orientationdot - a filled circle without a stroke and 2.5px radiuscircle, equivalent to circle-fill - a filled circle with a white stroke and 3px radiuscircle-stroke - a hollow circle with a colored stroke and a white fill and 3px radiustick ^0.6.12 - a small opposing linetick-x ^0.6.12 - a small horizontal linetick-y ^0.6.12 - a small vertical lineIf marker is true, it defaults to circle. If marker is a function, it will be called with a given color and must return an SVG marker element.The primary color of a marker is inherited from the stroke of the associated mark. The arrow marker is automatically oriented such that it points in the tangential direction of the path at the position the marker is placed. The circle markers are centered around the given vertex.For lines whose curve is not linear, markers are not necessarily drawn at the data positions given by x and y; marker placement is determined by the (possibly Bézier) path segments generated by the curve. To ensure that symbols are drawn at a given x and y position, consider using a dot mark instead.\n\n\n\nShorthand ^0.4.2 ​The most concise form of Plot is its shorthand syntax where no options are specified — only data. To use this shorthand, the data must have a specific structure: either a one-dimensional array of values [v₀, v₁, v₂, …] or a two-dimensional array of tuples [[x₀, y₀], [x₁, y₁], [x₂, y₂], …].While none of these charts are particularly groundbreaking, we hope you find this shorthand convenient the next time you want a quick look at some data. And if the shorthand view is useful, you can then enhance it by adding options!One dimension ​Let’s start with the one-dimensional form: an array of numbers.jsnumbers = [
  170.16, 172.53, 172.54, 173.44, 174.35, 174.55, 173.16, 174.59, 176.18, 177.90,
  176.15, 179.37, 178.61, 177.30, 177.30, 177.25, 174.51, 172.00, 170.16, 165.53,
  166.87, 167.17, 166.00, 159.10, 154.83, 163.09, 160.29, 157.07, 158.50, 161.95,
  163.04, 169.79, 172.36, 172.05, 172.83, 171.80, 173.67, 176.35, 179.10, 179.26
]These numbers represent the daily opening price of Apple stock starting on January 1, 2018. For a simple line chart, we can pass the data to Plot.lineY to construct a line mark, and then call line.plot.ForkjsPlot.lineY(numbers).plot()The y-axis above represents price in U.S. dollars. The x-axis represents the index of the data: the first value 170.16 is shown at x = 0, the second value 172.53 at x = 1, and so on. In other words, x represents the number of (trading) days since January 1, 2018. It’d be nicer to have an x-axis that shows dates here, but it’s still convenient to see the trend in stock price quickly.If we pass the numbers to Plot.areaY instead, we’ll get a simple area chart with a baseline implicitly at y = 0.ForkjsPlot.areaY(numbers).plot()Similarly if we use Plot.rectY, we’ll get a series of vertical bars. This implicitly uses the interval transform such that the first rect spans from x = 0 to x = 1, the second from x = 1 to x = 2, and so on, with a horizontal inset to separate adjacent rects.ForkjsPlot.rectY(numbers).plot()Plot.barY produces a visually similar result but with different semantics: x is now ordinal (a band scale) rather than quantitative (linear). An ordinal axis labels every tick, which appear at the middle of each bar rather than between rects.ForkjsPlot.barY(numbers).plot()Like Plot.barY, Plot.cellX implies that x is ordinal. But now instead of a y channel the numeric value is encoded as the fill color. The default quantitative color scheme is turbo; higher values are reddish, and lower values blueish.ForkjsPlot.cellX(numbers).plot()If we don’t care about the order of our data and we instead just want to look at the one-dimensional distribution of values, we can use Plot.dotX.ForkjsPlot.dotX(numbers).plot()Alternatively, we can use Plot.ruleX to draw a vertical rule at each value. In this case, Plot.ruleX behaves identically to Plot.tickX. (If there were a y channel, then Plot.tickX would imply that y is ordinal whereas Plot.ruleX would imply that y is quantitative.) It is common to use the rule shorthand to annotate special x or y values in plots, such as y = 0, in conjunction with other marks.ForkjsPlot.ruleX(numbers).plot()ForkjsPlot.tickX(numbers).plot()We could even use Plot.vectorX here to draw little up-pointing arrows. (Typically the vector mark is used in conjunction with the rotate and length options to control the direction and magnitude of each vector.)ForkjsPlot.vectorX(numbers).plot()While not particularly readable due to occlusion, we can use Plot.textX to draw a label at each value, too.ForkjsPlot.textX(numbers).plot()For a more formal method of summarizing a one-dimensional distribution, we can use Plot.boxX to create a horizontal boxplot. The gray band represents the interquartile range; the black whiskers show the extrema (not including outliers); and the thick black stroke represents the median; any outliers (none in this dataset) are drawn as dots.ForkjsPlot.boxX(numbers).plot()Some of Plot’s transforms support shorthand syntax, too. For example, we can use Plot.rectY with Plot.binX to generate a histogram — another common way to visualize a one-dimensional distribution.ForkjsPlot.rectY(numbers, Plot.binX()).plot()Similarly Plot.groupX can be used to group and count ordinal data, such as the frequency of bases in a random DNA sequence.jsgene = "AAAAGAGTGAAGATGCTGGAGACGAGTGAAGCATTCACTTTAGGGAAAGCGAGGCAAGAGCGTTTCAGAAGACGAAACCTGGTAGGTGCACTCACCACAG"ForkjsPlot.barY(gene, Plot.groupX()).plot()And here’s the dodge transform for a beeswarm plot:ForkjsPlot.dotX(numbers, Plot.dodgeY()).plot()Two dimensions ​Now let’s switch to a two-dimensional array of tuples [[x₀, y₀], [x₁, y₁], [x₂, y₂], …]. The x-values here are times (Date instances at UTC midnight); the y-values again are the daily opening price of Apple stock.jstimeSeries = [
  [new Date("2018-01-02"), 170.160004],
  [new Date("2018-01-03"), 172.529999],
  [new Date("2018-01-04"), 172.539993],
  [new Date("2018-01-05"), 173.440002],
  [new Date("2018-01-08"), 174.350006],
  [new Date("2018-01-09"), 174.550003],
  [new Date("2018-01-10"), 173.160004],
  [new Date("2018-01-11"), 174.589996],
  [new Date("2018-01-12"), 176.179993],
  [new Date("2018-01-16"), 177.899994],
  [new Date("2018-01-17"), 176.149994],
  [new Date("2018-01-18"), 179.369995],
  [new Date("2018-01-19"), 178.610001],
  [new Date("2018-01-22"), 177.300003],
  [new Date("2018-01-23"), 177.300003],
  [new Date("2018-01-24"), 177.250000],
  [new Date("2018-01-25"), 174.509995],
  [new Date("2018-01-26"), 172.000000],
  [new Date("2018-01-29"), 170.160004],
  [new Date("2018-01-30"), 165.529999],
  [new Date("2018-01-31"), 166.869995],
  [new Date("2018-02-01"), 167.169998],
  [new Date("2018-02-02"), 166.000000],
  [new Date("2018-02-05"), 159.100006],
  [new Date("2018-02-06"), 154.830002],
  [new Date("2018-02-07"), 163.089996],
  [new Date("2018-02-08"), 160.289993],
  [new Date("2018-02-09"), 157.070007],
  [new Date("2018-02-12"), 158.500000],
  [new Date("2018-02-13"), 161.949997],
  [new Date("2018-02-14"), 163.039993],
  [new Date("2018-02-15"), 169.789993],
  [new Date("2018-02-16"), 172.360001],
  [new Date("2018-02-20"), 172.050003],
  [new Date("2018-02-21"), 172.830002],
  [new Date("2018-02-22"), 171.800003],
  [new Date("2018-02-23"), 173.669998],
  [new Date("2018-02-26"), 176.350006],
  [new Date("2018-02-27"), 179.100006],
  [new Date("2018-02-28"), 179.259995]
]If we pass this to Plot.line (not Plot.lineY as before), we’ll get another line chart, but now the x-axis shows the date rather than the zero-based index. Also, the x-values are no longer uniformly spaced, as there are gaps on the weekends and holidays when the markets are closed.ForkjsPlot.line(timeSeries).plot()Similarly Plot.area will produce the equivalent area chart, again with an implicit baseline at y = 0.ForkjsPlot.area(timeSeries).plot()There’s currently no two-dimensional shorthand for rect or bar, though you can use these marks to display time series data with options.Plot.dot will produce a scatterplot…ForkjsPlot.dot(timeSeries).plot()As will Plot.vector…ForkjsPlot.vector(timeSeries).plot()Plot.text also produces a scatterplot with labels showing the zero-based index of the data. Perhaps not very useful, but it at least shows the data’s order.ForkjsPlot.text(timeSeries).plot()Plot.cell also supports two-dimensional shorthand. As we saw above, Plot.cell implies that x and y are ordinal, so we shouldn’t pass temporal (dates) and quantitative (numbers) data; here’s a matrix diagram that shows which pairs exist in the dataset. You might use this, for example, to visualize who reviewed whose code.jsmatrix = [
  ["Jacob", "Olivia"],
  ["Mia", "Noah"],
  ["Noah", "Ava"],
  ["Ava", "Mason"],
  ["Olivia", "Noah"],
  ["Jacob", "Emma"],
  ["Ava", "Noah"],
  ["Noah", "Jacob"],
  ["Olivia", "Ava"],
  ["Mason", "Emma"],
  ["Jacob", "Mia"],
  ["Mia", "Jacob"],
  ["Emma", "Jacob"]
]ForkjsPlot.cell(matrix).plot()Caveats ​Plot has a few marks that don’t currently provide meaningful shorthand. The arrow and link marks both require a start (x1, y1) and end (x2, y2) point; and the image mark requires a source URL (src).\n\nSearchK0.6.17GitHub️ 4.6kOn this pageShorthand ^0.4.2 ​The most concise form of Plot is its shorthand syntax where no options are specified — only data. To use this shorthand, the data must have a specific structure: either a one-dimensional array of values [v₀, v₁, v₂, …] or a two-dimensional array of tuples [[x₀, y₀], [x₁, y₁], [x₂, y₂], …].While none of these charts are particularly groundbreaking, we hope you find this shorthand convenient the next time you want a quick look at some data. And if the shorthand view is useful, you can then enhance it by adding options!One dimension ​Let’s start with the one-dimensional form: an array of numbers.jsnumbers = [
  170.16, 172.53, 172.54, 173.44, 174.35, 174.55, 173.16, 174.59, 176.18, 177.90,
  176.15, 179.37, 178.61, 177.30, 177.30, 177.25, 174.51, 172.00, 170.16, 165.53,
  166.87, 167.17, 166.00, 159.10, 154.83, 163.09, 160.29, 157.07, 158.50, 161.95,
  163.04, 169.79, 172.36, 172.05, 172.83, 171.80, 173.67, 176.35, 179.10, 179.26
]These numbers represent the daily opening price of Apple stock starting on January 1, 2018. For a simple line chart, we can pass the data to Plot.lineY to construct a line mark, and then call line.plot.ForkjsPlot.lineY(numbers).plot()The y-axis above represents price in U.S. dollars. The x-axis represents the index of the data: the first value 170.16 is shown at x = 0, the second value 172.53 at x = 1, and so on. In other words, x represents the number of (trading) days since January 1, 2018. It’d be nicer to have an x-axis that shows dates here, but it’s still convenient to see the trend in stock price quickly.If we pass the numbers to Plot.areaY instead, we’ll get a simple area chart with a baseline implicitly at y = 0.ForkjsPlot.areaY(numbers).plot()Similarly if we use Plot.rectY, we’ll get a series of vertical bars. This implicitly uses the interval transform such that the first rect spans from x = 0 to x = 1, the second from x = 1 to x = 2, and so on, with a horizontal inset to separate adjacent rects.ForkjsPlot.rectY(numbers).plot()Plot.barY produces a visually similar result but with different semantics: x is now ordinal (a band scale) rather than quantitative (linear). An ordinal axis labels every tick, which appear at the middle of each bar rather than between rects.ForkjsPlot.barY(numbers).plot()Like Plot.barY, Plot.cellX implies that x is ordinal. But now instead of a y channel the numeric value is encoded as the fill color. The default quantitative color scheme is turbo; higher values are reddish, and lower values blueish.ForkjsPlot.cellX(numbers).plot()If we don’t care about the order of our data and we instead just want to look at the one-dimensional distribution of values, we can use Plot.dotX.ForkjsPlot.dotX(numbers).plot()Alternatively, we can use Plot.ruleX to draw a vertical rule at each value. In this case, Plot.ruleX behaves identically to Plot.tickX. (If there were a y channel, then Plot.tickX would imply that y is ordinal whereas Plot.ruleX would imply that y is quantitative.) It is common to use the rule shorthand to annotate special x or y values in plots, such as y = 0, in conjunction with other marks.ForkjsPlot.ruleX(numbers).plot()ForkjsPlot.tickX(numbers).plot()We could even use Plot.vectorX here to draw little up-pointing arrows. (Typically the vector mark is used in conjunction with the rotate and length options to control the direction and magnitude of each vector.)ForkjsPlot.vectorX(numbers).plot()While not particularly readable due to occlusion, we can use Plot.textX to draw a label at each value, too.ForkjsPlot.textX(numbers).plot()For a more formal method of summarizing a one-dimensional distribution, we can use Plot.boxX to create a horizontal boxplot. The gray band represents the interquartile range; the black whiskers show the extrema (not including outliers); and the thick black stroke represents the median; any outliers (none in this dataset) are drawn as dots.ForkjsPlot.boxX(numbers).plot()Some of Plot’s transforms support shorthand syntax, too. For example, we can use Plot.rectY with Plot.binX to generate a histogram — another common way to visualize a one-dimensional distribution.ForkjsPlot.rectY(numbers, Plot.binX()).plot()Similarly Plot.groupX can be used to group and count ordinal data, such as the frequency of bases in a random DNA sequence.jsgene = "AAAAGAGTGAAGATGCTGGAGACGAGTGAAGCATTCACTTTAGGGAAAGCGAGGCAAGAGCGTTTCAGAAGACGAAACCTGGTAGGTGCACTCACCACAG"ForkjsPlot.barY(gene, Plot.groupX()).plot()And here’s the dodge transform for a beeswarm plot:ForkjsPlot.dotX(numbers, Plot.dodgeY()).plot()Two dimensions ​Now let’s switch to a two-dimensional array of tuples [[x₀, y₀], [x₁, y₁], [x₂, y₂], …]. The x-values here are times (Date instances at UTC midnight); the y-values again are the daily opening price of Apple stock.jstimeSeries = [
  [new Date("2018-01-02"), 170.160004],
  [new Date("2018-01-03"), 172.529999],
  [new Date("2018-01-04"), 172.539993],
  [new Date("2018-01-05"), 173.440002],
  [new Date("2018-01-08"), 174.350006],
  [new Date("2018-01-09"), 174.550003],
  [new Date("2018-01-10"), 173.160004],
  [new Date("2018-01-11"), 174.589996],
  [new Date("2018-01-12"), 176.179993],
  [new Date("2018-01-16"), 177.899994],
  [new Date("2018-01-17"), 176.149994],
  [new Date("2018-01-18"), 179.369995],
  [new Date("2018-01-19"), 178.610001],
  [new Date("2018-01-22"), 177.300003],
  [new Date("2018-01-23"), 177.300003],
  [new Date("2018-01-24"), 177.250000],
  [new Date("2018-01-25"), 174.509995],
  [new Date("2018-01-26"), 172.000000],
  [new Date("2018-01-29"), 170.160004],
  [new Date("2018-01-30"), 165.529999],
  [new Date("2018-01-31"), 166.869995],
  [new Date("2018-02-01"), 167.169998],
  [new Date("2018-02-02"), 166.000000],
  [new Date("2018-02-05"), 159.100006],
  [new Date("2018-02-06"), 154.830002],
  [new Date("2018-02-07"), 163.089996],
  [new Date("2018-02-08"), 160.289993],
  [new Date("2018-02-09"), 157.070007],
  [new Date("2018-02-12"), 158.500000],
  [new Date("2018-02-13"), 161.949997],
  [new Date("2018-02-14"), 163.039993],
  [new Date("2018-02-15"), 169.789993],
  [new Date("2018-02-16"), 172.360001],
  [new Date("2018-02-20"), 172.050003],
  [new Date("2018-02-21"), 172.830002],
  [new Date("2018-02-22"), 171.800003],
  [new Date("2018-02-23"), 173.669998],
  [new Date("2018-02-26"), 176.350006],
  [new Date("2018-02-27"), 179.100006],
  [new Date("2018-02-28"), 179.259995]
]If we pass this to Plot.line (not Plot.lineY as before), we’ll get another line chart, but now the x-axis shows the date rather than the zero-based index. Also, the x-values are no longer uniformly spaced, as there are gaps on the weekends and holidays when the markets are closed.ForkjsPlot.line(timeSeries).plot()Similarly Plot.area will produce the equivalent area chart, again with an implicit baseline at y = 0.ForkjsPlot.area(timeSeries).plot()There’s currently no two-dimensional shorthand for rect or bar, though you can use these marks to display time series data with options.Plot.dot will produce a scatterplot…ForkjsPlot.dot(timeSeries).plot()As will Plot.vector…ForkjsPlot.vector(timeSeries).plot()Plot.text also produces a scatterplot with labels showing the zero-based index of the data. Perhaps not very useful, but it at least shows the data’s order.ForkjsPlot.text(timeSeries).plot()Plot.cell also supports two-dimensional shorthand. As we saw above, Plot.cell implies that x and y are ordinal, so we shouldn’t pass temporal (dates) and quantitative (numbers) data; here’s a matrix diagram that shows which pairs exist in the dataset. You might use this, for example, to visualize who reviewed whose code.jsmatrix = [
  ["Jacob", "Olivia"],
  ["Mia", "Noah"],
  ["Noah", "Ava"],
  ["Ava", "Mason"],
  ["Olivia", "Noah"],
  ["Jacob", "Emma"],
  ["Ava", "Noah"],
  ["Noah", "Jacob"],
  ["Olivia", "Ava"],
  ["Mason", "Emma"],
  ["Jacob", "Mia"],
  ["Mia", "Jacob"],
  ["Emma", "Jacob"]
]ForkjsPlot.cell(matrix).plot()Caveats ​Plot has a few marks that don’t currently provide meaningful shorthand. The arrow and link marks both require a start (x1, y1) and end (x2, y2) point; and the image mark requires a source URL (src).PagerPrevious pageMarkersNext pageAccessibility\n\nShorthand ^0.4.2 ​The most concise form of Plot is its shorthand syntax where no options are specified — only data. To use this shorthand, the data must have a specific structure: either a one-dimensional array of values [v₀, v₁, v₂, …] or a two-dimensional array of tuples [[x₀, y₀], [x₁, y₁], [x₂, y₂], …].While none of these charts are particularly groundbreaking, we hope you find this shorthand convenient the next time you want a quick look at some data. And if the shorthand view is useful, you can then enhance it by adding options!One dimension ​Let’s start with the one-dimensional form: an array of numbers.jsnumbers = [
  170.16, 172.53, 172.54, 173.44, 174.35, 174.55, 173.16, 174.59, 176.18, 177.90,
  176.15, 179.37, 178.61, 177.30, 177.30, 177.25, 174.51, 172.00, 170.16, 165.53,
  166.87, 167.17, 166.00, 159.10, 154.83, 163.09, 160.29, 157.07, 158.50, 161.95,
  163.04, 169.79, 172.36, 172.05, 172.83, 171.80, 173.67, 176.35, 179.10, 179.26
]These numbers represent the daily opening price of Apple stock starting on January 1, 2018. For a simple line chart, we can pass the data to Plot.lineY to construct a line mark, and then call line.plot.ForkjsPlot.lineY(numbers).plot()The y-axis above represents price in U.S. dollars. The x-axis represents the index of the data: the first value 170.16 is shown at x = 0, the second value 172.53 at x = 1, and so on. In other words, x represents the number of (trading) days since January 1, 2018. It’d be nicer to have an x-axis that shows dates here, but it’s still convenient to see the trend in stock price quickly.If we pass the numbers to Plot.areaY instead, we’ll get a simple area chart with a baseline implicitly at y = 0.ForkjsPlot.areaY(numbers).plot()Similarly if we use Plot.rectY, we’ll get a series of vertical bars. This implicitly uses the interval transform such that the first rect spans from x = 0 to x = 1, the second from x = 1 to x = 2, and so on, with a horizontal inset to separate adjacent rects.ForkjsPlot.rectY(numbers).plot()Plot.barY produces a visually similar result but with different semantics: x is now ordinal (a band scale) rather than quantitative (linear). An ordinal axis labels every tick, which appear at the middle of each bar rather than between rects.ForkjsPlot.barY(numbers).plot()Like Plot.barY, Plot.cellX implies that x is ordinal. But now instead of a y channel the numeric value is encoded as the fill color. The default quantitative color scheme is turbo; higher values are reddish, and lower values blueish.ForkjsPlot.cellX(numbers).plot()If we don’t care about the order of our data and we instead just want to look at the one-dimensional distribution of values, we can use Plot.dotX.ForkjsPlot.dotX(numbers).plot()Alternatively, we can use Plot.ruleX to draw a vertical rule at each value. In this case, Plot.ruleX behaves identically to Plot.tickX. (If there were a y channel, then Plot.tickX would imply that y is ordinal whereas Plot.ruleX would imply that y is quantitative.) It is common to use the rule shorthand to annotate special x or y values in plots, such as y = 0, in conjunction with other marks.ForkjsPlot.ruleX(numbers).plot()ForkjsPlot.tickX(numbers).plot()We could even use Plot.vectorX here to draw little up-pointing arrows. (Typically the vector mark is used in conjunction with the rotate and length options to control the direction and magnitude of each vector.)ForkjsPlot.vectorX(numbers).plot()While not particularly readable due to occlusion, we can use Plot.textX to draw a label at each value, too.ForkjsPlot.textX(numbers).plot()For a more formal method of summarizing a one-dimensional distribution, we can use Plot.boxX to create a horizontal boxplot. The gray band represents the interquartile range; the black whiskers show the extrema (not including outliers); and the thick black stroke represents the median; any outliers (none in this dataset) are drawn as dots.ForkjsPlot.boxX(numbers).plot()Some of Plot’s transforms support shorthand syntax, too. For example, we can use Plot.rectY with Plot.binX to generate a histogram — another common way to visualize a one-dimensional distribution.ForkjsPlot.rectY(numbers, Plot.binX()).plot()Similarly Plot.groupX can be used to group and count ordinal data, such as the frequency of bases in a random DNA sequence.jsgene = "AAAAGAGTGAAGATGCTGGAGACGAGTGAAGCATTCACTTTAGGGAAAGCGAGGCAAGAGCGTTTCAGAAGACGAAACCTGGTAGGTGCACTCACCACAG"ForkjsPlot.barY(gene, Plot.groupX()).plot()And here’s the dodge transform for a beeswarm plot:ForkjsPlot.dotX(numbers, Plot.dodgeY()).plot()Two dimensions ​Now let’s switch to a two-dimensional array of tuples [[x₀, y₀], [x₁, y₁], [x₂, y₂], …]. The x-values here are times (Date instances at UTC midnight); the y-values again are the daily opening price of Apple stock.jstimeSeries = [
  [new Date("2018-01-02"), 170.160004],
  [new Date("2018-01-03"), 172.529999],
  [new Date("2018-01-04"), 172.539993],
  [new Date("2018-01-05"), 173.440002],
  [new Date("2018-01-08"), 174.350006],
  [new Date("2018-01-09"), 174.550003],
  [new Date("2018-01-10"), 173.160004],
  [new Date("2018-01-11"), 174.589996],
  [new Date("2018-01-12"), 176.179993],
  [new Date("2018-01-16"), 177.899994],
  [new Date("2018-01-17"), 176.149994],
  [new Date("2018-01-18"), 179.369995],
  [new Date("2018-01-19"), 178.610001],
  [new Date("2018-01-22"), 177.300003],
  [new Date("2018-01-23"), 177.300003],
  [new Date("2018-01-24"), 177.250000],
  [new Date("2018-01-25"), 174.509995],
  [new Date("2018-01-26"), 172.000000],
  [new Date("2018-01-29"), 170.160004],
  [new Date("2018-01-30"), 165.529999],
  [new Date("2018-01-31"), 166.869995],
  [new Date("2018-02-01"), 167.169998],
  [new Date("2018-02-02"), 166.000000],
  [new Date("2018-02-05"), 159.100006],
  [new Date("2018-02-06"), 154.830002],
  [new Date("2018-02-07"), 163.089996],
  [new Date("2018-02-08"), 160.289993],
  [new Date("2018-02-09"), 157.070007],
  [new Date("2018-02-12"), 158.500000],
  [new Date("2018-02-13"), 161.949997],
  [new Date("2018-02-14"), 163.039993],
  [new Date("2018-02-15"), 169.789993],
  [new Date("2018-02-16"), 172.360001],
  [new Date("2018-02-20"), 172.050003],
  [new Date("2018-02-21"), 172.830002],
  [new Date("2018-02-22"), 171.800003],
  [new Date("2018-02-23"), 173.669998],
  [new Date("2018-02-26"), 176.350006],
  [new Date("2018-02-27"), 179.100006],
  [new Date("2018-02-28"), 179.259995]
]If we pass this to Plot.line (not Plot.lineY as before), we’ll get another line chart, but now the x-axis shows the date rather than the zero-based index. Also, the x-values are no longer uniformly spaced, as there are gaps on the weekends and holidays when the markets are closed.ForkjsPlot.line(timeSeries).plot()Similarly Plot.area will produce the equivalent area chart, again with an implicit baseline at y = 0.ForkjsPlot.area(timeSeries).plot()There’s currently no two-dimensional shorthand for rect or bar, though you can use these marks to display time series data with options.Plot.dot will produce a scatterplot…ForkjsPlot.dot(timeSeries).plot()As will Plot.vector…ForkjsPlot.vector(timeSeries).plot()Plot.text also produces a scatterplot with labels showing the zero-based index of the data. Perhaps not very useful, but it at least shows the data’s order.ForkjsPlot.text(timeSeries).plot()Plot.cell also supports two-dimensional shorthand. As we saw above, Plot.cell implies that x and y are ordinal, so we shouldn’t pass temporal (dates) and quantitative (numbers) data; here’s a matrix diagram that shows which pairs exist in the dataset. You might use this, for example, to visualize who reviewed whose code.jsmatrix = [
  ["Jacob", "Olivia"],
  ["Mia", "Noah"],
  ["Noah", "Ava"],
  ["Ava", "Mason"],
  ["Olivia", "Noah"],
  ["Jacob", "Emma"],
  ["Ava", "Noah"],
  ["Noah", "Jacob"],
  ["Olivia", "Ava"],
  ["Mason", "Emma"],
  ["Jacob", "Mia"],
  ["Mia", "Jacob"],
  ["Emma", "Jacob"]
]ForkjsPlot.cell(matrix).plot()Caveats ​Plot has a few marks that don’t currently provide meaningful shorthand. The arrow and link marks both require a start (x1, y1) and end (x2, y2) point; and the image mark requires a source URL (src).\n\n\n\nAccessibility ​Plot uses ARIA to make plots more accessible through assistive technology such as screen readers, browser add-ons, and browser developer tools.The aria-label and aria-description attributes on the root SVG element can be set via the top-level ariaLabel and ariaDescription plot options. These default to null.Marks automatically generate an aria-label attribute on the rendered SVG G element; this attribute includes the mark’s type, such as “dot”. The axis mark and grid mark also include the associated scale’s name, such as “y-axis tick”, “y-axis label”, or “x-grid”.Use the ariaLabel mark option to apply per-instance aria-label attributes (e.g., on individual dots in a scatterplot), say for a short, human-readable textual representation of each displayed data point. Use the ariaDescription mark option for a longer description; this is applied to the mark’s G element. These options both default to null.Setting the ariaHidden mark option to true hides the mark from the accessibility tree. This is useful for decorative or redundant marks (such as rules or lines between dots).\n\nSearchK0.6.17GitHub️ 4.6kOn this pageAccessibility ​Plot uses ARIA to make plots more accessible through assistive technology such as screen readers, browser add-ons, and browser developer tools.The aria-label and aria-description attributes on the root SVG element can be set via the top-level ariaLabel and ariaDescription plot options. These default to null.Marks automatically generate an aria-label attribute on the rendered SVG G element; this attribute includes the mark’s type, such as “dot”. The axis mark and grid mark also include the associated scale’s name, such as “y-axis tick”, “y-axis label”, or “x-grid”.Use the ariaLabel mark option to apply per-instance aria-label attributes (e.g., on individual dots in a scatterplot), say for a short, human-readable textual representation of each displayed data point. Use the ariaDescription mark option for a longer description; this is applied to the mark’s G element. These options both default to null.Setting the ariaHidden mark option to true hides the mark from the accessibility tree. This is useful for decorative or redundant marks (such as rules or lines between dots).PagerPrevious pageShorthandNext pageArea\n\nAccessibility ​Plot uses ARIA to make plots more accessible through assistive technology such as screen readers, browser add-ons, and browser developer tools.The aria-label and aria-description attributes on the root SVG element can be set via the top-level ariaLabel and ariaDescription plot options. These default to null.Marks automatically generate an aria-label attribute on the rendered SVG G element; this attribute includes the mark’s type, such as “dot”. The axis mark and grid mark also include the associated scale’s name, such as “y-axis tick”, “y-axis label”, or “x-grid”.Use the ariaLabel mark option to apply per-instance aria-label attributes (e.g., on individual dots in a scatterplot), say for a short, human-readable textual representation of each displayed data point. Use the ariaDescription mark option for a longer description; this is applied to the mark’s G element. These options both default to null.Setting the ariaHidden mark option to true hides the mark from the accessibility tree. This is useful for decorative or redundant marks (such as rules or lines between dots).\n\n\n\nArea mark ​The area mark draws the region between a baseline (x1, y1) and a topline (x2, y2) as in an area chart. Often the baseline represents y = 0, and because the area mark interpolates between adjacent data points, typically both the x and y scales are quantitative or temporal.ForkjsPlot.areaY(aapl, {x: "Date", y: "Close"}).plot()The area mark has three constructors: areaY for when the baseline and topline share x values, as in a time-series area chart where time goes right→ (or ←left); areaX for when the baseline and topline share y values, as in a time-series area chart where time goes up↑ (or down↓); and lastly the rarely-used area where the baseline and topline share neither x nor y values.The area mark is often paired with a line and rule mark to accentuate the topline and baseline.ForkjsPlot.plot({
  y: {
    grid: true
  },
  marks: [
    Plot.areaY(aapl, {x: "Date", y: "Close", fillOpacity: 0.3}),
    Plot.lineY(aapl, {x: "Date", y: "Close"}),
    Plot.ruleY([0])
  ]
})With the default definitions of x = index and y = identity, you can pass an array of numbers as data. Below, a random walk is constructed with d3.cumsum and d3.randomNormal.ForkjsPlot.areaY(d3.cumsum({length: 600}, d3.randomNormal())).plot()As with lines, points in areas are connected in input order: the first point is connected to the second point, the second is connected to the third, and so on. Area data is typically in chronological order. Unsorted data may produce gibberish.ForkjsPlot.areaY(d3.shuffle(aapl.slice()), {x: "Date", y: "Close"}).plot() // 🌶️If your data isn’t sorted, use the sort transform.ForkjsPlot.areaY(d3.shuffle(aapl.slice()), {x: "Date", y: "Close", sort: "Date"}).plot()When the baseline is not y = 0 but instead represents another dimension of data as in a band chart, specify y1 and y2 instead of y.ForkjsPlot.plot({
  y: {
    label: "Temperature (°F)",
    grid: true
  },
  marks: [
    Plot.areaY(sftemp, {x: "date", y1: "low", y2: "high"})
  ]
})TIPSince y1 and y2 refer to different fields here, a y-scale label is specified to improve readability. Also, the band above is spiky; you can smooth it by applying a window transform.While charts typically put y = 0 on the bottom edge, such that the area grows up↑, this is not required; reversing the y scale will produce a “hanging” area that grows down↓.ForkjsPlot.plot({
  x: {
    label: null
  },
  y: {
    grid: true,
    reverse: true
  },
  marks: [
    Plot.areaY(aapl, {x: "Date", y: "Close", fillOpacity: 0.3}),
    Plot.lineY(aapl, {x: "Date", y: "Close"}),
    Plot.ruleY([0])
  ]
})For a vertically-oriented baseline and topline, such as when time goes up↑ instead of right→, use areaX instead of areaY and swap x and y.ForkjsPlot.plot({
  x: {
    grid: true
  },
  marks: [
    Plot.areaX(aapl, {y: "Date", x: "Close", fillOpacity: 0.3}),
    Plot.lineX(aapl, {y: "Date", x: "Close"}),
    Plot.ruleX([0])
  ]
})If some channel values are undefined (or null or NaN), gaps will appear between adjacent points. To demonstrate, below we set the y value to NaN for the first three months of each year.ForkjsPlot.plot({
  y: {
    grid: true
  },
  marks: [
    Plot.areaY(aapl, {x: "Date", y: (d) => d.Date.getUTCMonth() < 3 ? NaN : d.Close, fillOpacity: 0.3}),
    Plot.lineY(aapl, {x: "Date", y: (d) => d.Date.getUTCMonth() < 3 ? NaN : d.Close}),
    Plot.ruleY([0])
  ]
})Supplying undefined values is not the same as filtering the data: the latter will interpolate between the data points. Observe the conspicuous straight lines below!jsPlot.plot({
  y: {
    grid: true
  },
  marks: [
    Plot.areaY(aapl, {filter: (d) => d.Date.getUTCMonth() >= 3, x: "Date", y: "Close", fillOpacity: 0.3}),
    Plot.lineY(aapl, {x: "Date", y: (d) => d.Date.getUTCMonth() < 3 ? NaN : d.Close}),
    Plot.ruleY([0])
  ]
})If a fill channel is specified, it is assumed to be ordinal or nominal; data is grouped into series and then implicitly stacked.ForkjsPlot.plot({
  y: {
    transform: (d) => d / 1000,
    label: "Unemployed (thousands)"
  },
  marks: [
    Plot.areaY(industries, {x: "date", y: "unemployed", fill: "industry"}),
    Plot.ruleY([0])
  ]
})CAUTIONThis area chart uses color but does not include a legend. This should usually be avoided because color cannot be interpreted without a legend, titles, or labels.Or, as a streamgraph with the offset stack transform option:ForkjsPlot.plot({
  y: {
    transform: (d) => d / 1000,
    label: "Unemployed (thousands)"
  },
  marks: [
    Plot.areaY(industries, {x: "date", y: "unemployed", fill: "industry", offset: "wiggle"}),
  ]
})The z channel determines how data is grouped: if the z channel is not specified, but a varying fill channel is, the fill channel is used for z; the z channel will further fallback to a varying stroke channel if needed.The z channel (either implicitly or explicitly) is typically used with the stack transform for a stacked area chart or streamgraph. You can disable the implicit stack transform and produce overlapping areas by setting y2 instead of y.ForkjsPlot.plot({
  marks: [
    Plot.areaY(industries, {x: "date", y2: "unemployed", z: "industry", fillOpacity: 0.1}),
    Plot.lineY(industries, {x: "date", y: "unemployed", z: "industry", strokeWidth: 1})
  ]
})To vary fill within a single series, set the z option to null.ForkjsPlot.plot({
  color: {
    type: "log",
    legend: true
  },
  marks: [
    Plot.areaY(aapl, {x: "Date", y: "Close", fill: "Volume", z: null}),
    Plot.ruleY([0])
  ]
})As an alternative to overlapping or stacking, faceting will produce small multiples, here arranged vertically with a shared x-axis.ForkjsPlot.plot({
  height: 720,
  axis: null,
  marks: [
    Plot.areaY(industries, {x: "date", y: "unemployed", fy: "industry"}),
    Plot.text(industries, Plot.selectFirst({text: "industry", fy: "industry", frameAnchor: "top-left", dx: 6, dy: 6})),
    Plot.frame()
  ]
})TIPAbove, smaller industries such as agriculture and mining & extraction are dwarfed by larger industries such as wholesale & retail trade. To emphasize each industry’s trend, instead of comparing absolute numbers across industries, you could use the normalize transform.Or, as a horizon chart, where the area is repeated at different scales with different colors, showing both small-scale variation in position and large-scale variation in color:ForkjsPlot.plot((() => {
  const bands = 7;
  const step = d3.max(industries, (d) => d.unemployed) / bands;
  return {
    height: 720,
    axis: null,
    y: {domain: [0, step]},
    color: {scheme: "YlGnBu"},
    facet: {data: industries, y: "industry"},
    marks: [
      d3.range(bands).map((i) => Plot.areaY(industries, {x: "date", y: (d) => d.unemployed - i * step, fill: i, clip: true})),
      Plot.text(industries, Plot.selectFirst({text: "industry", frameAnchor: "top-left", dx: 6, dy: 6})),
      Plot.frame()
    ]
  };
})())See also the ridgeline chart example.Interpolation is controlled by the curve option. The default curve is linear, which draws straight line segments between pairs of adjacent points. A step curve is nice for emphasizing when the value changes, while basis and catmull–rom are nice for smoothing.Area options ​The following channels are required:x1 - the horizontal position of the baseline; bound to the x scaley1 - the vertical position of the baseline; bound to the y scaleIn addition to the standard mark options, the following optional channels are supported:x2 - the horizontal position of the topline; bound to the x scaley2 - the vertical position of the topline; bound to the y scalez - a categorical value to group data into seriesIf x2 is not specified, it defaults to x1. If y2 is not specified, it defaults to y1. These defaults facilitate sharing x or y coordinates between the baseline and topline. See also the implicit stack transform and shorthand x and y options supported by areaY and areaX.By default, the data is assumed to represent a single series (i.e., a single value that varies over time). If the z channel is specified, data is grouped by z to form separate series. Typically z is a categorical value such as a series name. If z is not specified, it defaults to fill if a channel, or stroke if a channel.The stroke defaults to none. The fill defaults to currentColor if the stroke is none, and to none otherwise. If the fill is defined as a channel, the area will be broken into contiguous overlapping segments when the fill color changes; the fill color will apply to the interval spanning the current data point and the following data point. This behavior also applies to the fillOpacity, stroke, strokeOpacity, strokeWidth, opacity, href, title, and ariaLabel channels. When any of these channels are used, setting an explicit z channel (possibly to null) is strongly recommended. The strokeLinecap and strokeLinejoin default to round, and the strokeMiterlimit defaults to 1.Points along the baseline and topline are connected in input order. Likewise, if there are multiple series via the z, fill, or stroke channel, the series are drawn in input order such that the last series is drawn on top. Typically, the data is already in sorted order, such as chronological for time series; if sorting is needed, consider a sort transform.The area mark supports curve options to control interpolation between points. If any of the x1, y1, x2, or y2 values are invalid (undefined, null, or NaN), the baseline and topline will be interrupted, resulting in a break that divides the area shape into multiple segments. (See d3-shape’s area.defined for more.) If an area segment consists of only a single point, it may appear invisible unless rendered with rounded or square line caps. In addition, some curves such as cardinal-open only render a visible segment if it contains multiple points.areaY(data, options) ​jsPlot.areaY(aapl, {x: "Date", y: "Close"})Returns a new area with the given data and options. This constructor is used when the baseline and topline share x values, as in a time-series area chart where time goes right→. If neither the y1 nor y2 option is specified, the y option may be specified as shorthand to apply an implicit stackY transform; this is the typical configuration for an area chart with a baseline at y = 0. If the y option is not specified, it defaults to the identity function. The x option specifies the x1 channel; and the x1 and x2 options are ignored.If the interval option is specified, the binX transform is implicitly applied to the specified options. The reducer of the output y channel may be specified via the reduce option, which defaults to first. To default to zero instead of showing gaps in data, as when the observed value represents a quantity, use the sum reducer.jsPlot.areaY(observations, {x: "date", y: "temperature", interval: "day"})The interval option is recommended to “regularize” sampled data; for example, if your data represents timestamped temperature measurements and you expect one sample per day, use "day" as the interval.The areaY mark draws the region between a baseline (y1) and a topline (y2) as in an area chart. When the baseline is y = 0, the y channel can be specified instead of y1 and y2.areaX(data, options) ​jsPlot.areaX(aapl, {y: "Date", x: "Close"})Returns a new area with the given data and options. This constructor is used when the baseline and topline share y values, as in a time-series area chart where time goes up↑. If neither the x1 nor x2 option is specified, the x option may be specified as shorthand to apply an implicit stackX transform; this is the typical configuration for an area chart with a baseline at x = 0. If the x option is not specified, it defaults to the identity function. The y option specifies the y1 channel; and the y1 and y2 options are ignored.If the interval option is specified, the binY transform is implicitly applied to the specified options. The reducer of the output x channel may be specified via the reduce option, which defaults to first. To default to zero instead of showing gaps in data, as when the observed value represents a quantity, use the sum reducer.jsPlot.areaX(observations, {y: "date", x: "temperature", interval: "day"})The interval option is recommended to “regularize” sampled data; for example, if your data represents timestamped temperature measurements and you expect one sample per day, use "day" as the interval.area(data, options) ​jsPlot.area(aapl, {x1: "Date", y1: 0, y2: "Close"})Returns a new area with the given data and options. This method is rarely used directly; it is only needed when the baseline and topline have neither common x nor y values. areaY is used in the common horizontal orientation where the baseline and topline share x values, while areaX is used in the vertical orientation where the baseline and topline share y values.\n\nSearchK0.6.17GitHub️ 4.6kOn this pageArea mark ​The area mark draws the region between a baseline (x1, y1) and a topline (x2, y2) as in an area chart. Often the baseline represents y = 0, and because the area mark interpolates between adjacent data points, typically both the x and y scales are quantitative or temporal.ForkjsPlot.areaY(aapl, {x: "Date", y: "Close"}).plot()The area mark has three constructors: areaY for when the baseline and topline share x values, as in a time-series area chart where time goes right→ (or ←left); areaX for when the baseline and topline share y values, as in a time-series area chart where time goes up↑ (or down↓); and lastly the rarely-used area where the baseline and topline share neither x nor y values.The area mark is often paired with a line and rule mark to accentuate the topline and baseline.ForkjsPlot.plot({
  y: {
    grid: true
  },
  marks: [
    Plot.areaY(aapl, {x: "Date", y: "Close", fillOpacity: 0.3}),
    Plot.lineY(aapl, {x: "Date", y: "Close"}),
    Plot.ruleY([0])
  ]
})With the default definitions of x = index and y = identity, you can pass an array of numbers as data. Below, a random walk is constructed with d3.cumsum and d3.randomNormal.ForkjsPlot.areaY(d3.cumsum({length: 600}, d3.randomNormal())).plot()As with lines, points in areas are connected in input order: the first point is connected to the second point, the second is connected to the third, and so on. Area data is typically in chronological order. Unsorted data may produce gibberish.ForkjsPlot.areaY(d3.shuffle(aapl.slice()), {x: "Date", y: "Close"}).plot() // 🌶️If your data isn’t sorted, use the sort transform.ForkjsPlot.areaY(d3.shuffle(aapl.slice()), {x: "Date", y: "Close", sort: "Date"}).plot()When the baseline is not y = 0 but instead represents another dimension of data as in a band chart, specify y1 and y2 instead of y.ForkjsPlot.plot({
  y: {
    label: "Temperature (°F)",
    grid: true
  },
  marks: [
    Plot.areaY(sftemp, {x: "date", y1: "low", y2: "high"})
  ]
})TIPSince y1 and y2 refer to different fields here, a y-scale label is specified to improve readability. Also, the band above is spiky; you can smooth it by applying a window transform.While charts typically put y = 0 on the bottom edge, such that the area grows up↑, this is not required; reversing the y scale will produce a “hanging” area that grows down↓.ForkjsPlot.plot({
  x: {
    label: null
  },
  y: {
    grid: true,
    reverse: true
  },
  marks: [
    Plot.areaY(aapl, {x: "Date", y: "Close", fillOpacity: 0.3}),
    Plot.lineY(aapl, {x: "Date", y: "Close"}),
    Plot.ruleY([0])
  ]
})For a vertically-oriented baseline and topline, such as when time goes up↑ instead of right→, use areaX instead of areaY and swap x and y.ForkjsPlot.plot({
  x: {
    grid: true
  },
  marks: [
    Plot.areaX(aapl, {y: "Date", x: "Close", fillOpacity: 0.3}),
    Plot.lineX(aapl, {y: "Date", x: "Close"}),
    Plot.ruleX([0])
  ]
})If some channel values are undefined (or null or NaN), gaps will appear between adjacent points. To demonstrate, below we set the y value to NaN for the first three months of each year.ForkjsPlot.plot({
  y: {
    grid: true
  },
  marks: [
    Plot.areaY(aapl, {x: "Date", y: (d) => d.Date.getUTCMonth() < 3 ? NaN : d.Close, fillOpacity: 0.3}),
    Plot.lineY(aapl, {x: "Date", y: (d) => d.Date.getUTCMonth() < 3 ? NaN : d.Close}),
    Plot.ruleY([0])
  ]
})Supplying undefined values is not the same as filtering the data: the latter will interpolate between the data points. Observe the conspicuous straight lines below!jsPlot.plot({
  y: {
    grid: true
  },
  marks: [
    Plot.areaY(aapl, {filter: (d) => d.Date.getUTCMonth() >= 3, x: "Date", y: "Close", fillOpacity: 0.3}),
    Plot.lineY(aapl, {x: "Date", y: (d) => d.Date.getUTCMonth() < 3 ? NaN : d.Close}),
    Plot.ruleY([0])
  ]
})If a fill channel is specified, it is assumed to be ordinal or nominal; data is grouped into series and then implicitly stacked.ForkjsPlot.plot({
  y: {
    transform: (d) => d / 1000,
    label: "Unemployed (thousands)"
  },
  marks: [
    Plot.areaY(industries, {x: "date", y: "unemployed", fill: "industry"}),
    Plot.ruleY([0])
  ]
})CAUTIONThis area chart uses color but does not include a legend. This should usually be avoided because color cannot be interpreted without a legend, titles, or labels.Or, as a streamgraph with the offset stack transform option:ForkjsPlot.plot({
  y: {
    transform: (d) => d / 1000,
    label: "Unemployed (thousands)"
  },
  marks: [
    Plot.areaY(industries, {x: "date", y: "unemployed", fill: "industry", offset: "wiggle"}),
  ]
})The z channel determines how data is grouped: if the z channel is not specified, but a varying fill channel is, the fill channel is used for z; the z channel will further fallback to a varying stroke channel if needed.The z channel (either implicitly or explicitly) is typically used with the stack transform for a stacked area chart or streamgraph. You can disable the implicit stack transform and produce overlapping areas by setting y2 instead of y.ForkjsPlot.plot({
  marks: [
    Plot.areaY(industries, {x: "date", y2: "unemployed", z: "industry", fillOpacity: 0.1}),
    Plot.lineY(industries, {x: "date", y: "unemployed", z: "industry", strokeWidth: 1})
  ]
})To vary fill within a single series, set the z option to null.ForkjsPlot.plot({
  color: {
    type: "log",
    legend: true
  },
  marks: [
    Plot.areaY(aapl, {x: "Date", y: "Close", fill: "Volume", z: null}),
    Plot.ruleY([0])
  ]
})As an alternative to overlapping or stacking, faceting will produce small multiples, here arranged vertically with a shared x-axis.ForkjsPlot.plot({
  height: 720,
  axis: null,
  marks: [
    Plot.areaY(industries, {x: "date", y: "unemployed", fy: "industry"}),
    Plot.text(industries, Plot.selectFirst({text: "industry", fy: "industry", frameAnchor: "top-left", dx: 6, dy: 6})),
    Plot.frame()
  ]
})TIPAbove, smaller industries such as agriculture and mining & extraction are dwarfed by larger industries such as wholesale & retail trade. To emphasize each industry’s trend, instead of comparing absolute numbers across industries, you could use the normalize transform.Or, as a horizon chart, where the area is repeated at different scales with different colors, showing both small-scale variation in position and large-scale variation in color:ForkjsPlot.plot((() => {
  const bands = 7;
  const step = d3.max(industries, (d) => d.unemployed) / bands;
  return {
    height: 720,
    axis: null,
    y: {domain: [0, step]},
    color: {scheme: "YlGnBu"},
    facet: {data: industries, y: "industry"},
    marks: [
      d3.range(bands).map((i) => Plot.areaY(industries, {x: "date", y: (d) => d.unemployed - i * step, fill: i, clip: true})),
      Plot.text(industries, Plot.selectFirst({text: "industry", frameAnchor: "top-left", dx: 6, dy: 6})),
      Plot.frame()
    ]
  };
})())See also the ridgeline chart example.Interpolation is controlled by the curve option. The default curve is linear, which draws straight line segments between pairs of adjacent points. A step curve is nice for emphasizing when the value changes, while basis and catmull–rom are nice for smoothing.Area options ​The following channels are required:x1 - the horizontal position of the baseline; bound to the x scaley1 - the vertical position of the baseline; bound to the y scaleIn addition to the standard mark options, the following optional channels are supported:x2 - the horizontal position of the topline; bound to the x scaley2 - the vertical position of the topline; bound to the y scalez - a categorical value to group data into seriesIf x2 is not specified, it defaults to x1. If y2 is not specified, it defaults to y1. These defaults facilitate sharing x or y coordinates between the baseline and topline. See also the implicit stack transform and shorthand x and y options supported by areaY and areaX.By default, the data is assumed to represent a single series (i.e., a single value that varies over time). If the z channel is specified, data is grouped by z to form separate series. Typically z is a categorical value such as a series name. If z is not specified, it defaults to fill if a channel, or stroke if a channel.The stroke defaults to none. The fill defaults to currentColor if the stroke is none, and to none otherwise. If the fill is defined as a channel, the area will be broken into contiguous overlapping segments when the fill color changes; the fill color will apply to the interval spanning the current data point and the following data point. This behavior also applies to the fillOpacity, stroke, strokeOpacity, strokeWidth, opacity, href, title, and ariaLabel channels. When any of these channels are used, setting an explicit z channel (possibly to null) is strongly recommended. The strokeLinecap and strokeLinejoin default to round, and the strokeMiterlimit defaults to 1.Points along the baseline and topline are connected in input order. Likewise, if there are multiple series via the z, fill, or stroke channel, the series are drawn in input order such that the last series is drawn on top. Typically, the data is already in sorted order, such as chronological for time series; if sorting is needed, consider a sort transform.The area mark supports curve options to control interpolation between points. If any of the x1, y1, x2, or y2 values are invalid (undefined, null, or NaN), the baseline and topline will be interrupted, resulting in a break that divides the area shape into multiple segments. (See d3-shape’s area.defined for more.) If an area segment consists of only a single point, it may appear invisible unless rendered with rounded or square line caps. In addition, some curves such as cardinal-open only render a visible segment if it contains multiple points.areaY(data, options) ​jsPlot.areaY(aapl, {x: "Date", y: "Close"})Returns a new area with the given data and options. This constructor is used when the baseline and topline share x values, as in a time-series area chart where time goes right→. If neither the y1 nor y2 option is specified, the y option may be specified as shorthand to apply an implicit stackY transform; this is the typical configuration for an area chart with a baseline at y = 0. If the y option is not specified, it defaults to the identity function. The x option specifies the x1 channel; and the x1 and x2 options are ignored.If the interval option is specified, the binX transform is implicitly applied to the specified options. The reducer of the output y channel may be specified via the reduce option, which defaults to first. To default to zero instead of showing gaps in data, as when the observed value represents a quantity, use the sum reducer.jsPlot.areaY(observations, {x: "date", y: "temperature", interval: "day"})The interval option is recommended to “regularize” sampled data; for example, if your data represents timestamped temperature measurements and you expect one sample per day, use "day" as the interval.The areaY mark draws the region between a baseline (y1) and a topline (y2) as in an area chart. When the baseline is y = 0, the y channel can be specified instead of y1 and y2.areaX(data, options) ​jsPlot.areaX(aapl, {y: "Date", x: "Close"})Returns a new area with the given data and options. This constructor is used when the baseline and topline share y values, as in a time-series area chart where time goes up↑. If neither the x1 nor x2 option is specified, the x option may be specified as shorthand to apply an implicit stackX transform; this is the typical configuration for an area chart with a baseline at x = 0. If the x option is not specified, it defaults to the identity function. The y option specifies the y1 channel; and the y1 and y2 options are ignored.If the interval option is specified, the binY transform is implicitly applied to the specified options. The reducer of the output x channel may be specified via the reduce option, which defaults to first. To default to zero instead of showing gaps in data, as when the observed value represents a quantity, use the sum reducer.jsPlot.areaX(observations, {y: "date", x: "temperature", interval: "day"})The interval option is recommended to “regularize” sampled data; for example, if your data represents timestamped temperature measurements and you expect one sample per day, use "day" as the interval.area(data, options) ​jsPlot.area(aapl, {x1: "Date", y1: 0, y2: "Close"})Returns a new area with the given data and options. This method is rarely used directly; it is only needed when the baseline and topline have neither common x nor y values. areaY is used in the common horizontal orientation where the baseline and topline share x values, while areaX is used in the vertical orientation where the baseline and topline share y values.PagerPrevious pageAccessibilityNext pageArrow\n\nArea mark ​The area mark draws the region between a baseline (x1, y1) and a topline (x2, y2) as in an area chart. Often the baseline represents y = 0, and because the area mark interpolates between adjacent data points, typically both the x and y scales are quantitative or temporal.ForkjsPlot.areaY(aapl, {x: "Date", y: "Close"}).plot()The area mark has three constructors: areaY for when the baseline and topline share x values, as in a time-series area chart where time goes right→ (or ←left); areaX for when the baseline and topline share y values, as in a time-series area chart where time goes up↑ (or down↓); and lastly the rarely-used area where the baseline and topline share neither x nor y values.The area mark is often paired with a line and rule mark to accentuate the topline and baseline.ForkjsPlot.plot({
  y: {
    grid: true
  },
  marks: [
    Plot.areaY(aapl, {x: "Date", y: "Close", fillOpacity: 0.3}),
    Plot.lineY(aapl, {x: "Date", y: "Close"}),
    Plot.ruleY([0])
  ]
})With the default definitions of x = index and y = identity, you can pass an array of numbers as data. Below, a random walk is constructed with d3.cumsum and d3.randomNormal.ForkjsPlot.areaY(d3.cumsum({length: 600}, d3.randomNormal())).plot()As with lines, points in areas are connected in input order: the first point is connected to the second point, the second is connected to the third, and so on. Area data is typically in chronological order. Unsorted data may produce gibberish.ForkjsPlot.areaY(d3.shuffle(aapl.slice()), {x: "Date", y: "Close"}).plot() // 🌶️If your data isn’t sorted, use the sort transform.ForkjsPlot.areaY(d3.shuffle(aapl.slice()), {x: "Date", y: "Close", sort: "Date"}).plot()When the baseline is not y = 0 but instead represents another dimension of data as in a band chart, specify y1 and y2 instead of y.ForkjsPlot.plot({
  y: {
    label: "Temperature (°F)",
    grid: true
  },
  marks: [
    Plot.areaY(sftemp, {x: "date", y1: "low", y2: "high"})
  ]
})TIPSince y1 and y2 refer to different fields here, a y-scale label is specified to improve readability. Also, the band above is spiky; you can smooth it by applying a window transform.While charts typically put y = 0 on the bottom edge, such that the area grows up↑, this is not required; reversing the y scale will produce a “hanging” area that grows down↓.ForkjsPlot.plot({
  x: {
    label: null
  },
  y: {
    grid: true,
    reverse: true
  },
  marks: [
    Plot.areaY(aapl, {x: "Date", y: "Close", fillOpacity: 0.3}),
    Plot.lineY(aapl, {x: "Date", y: "Close"}),
    Plot.ruleY([0])
  ]
})For a vertically-oriented baseline and topline, such as when time goes up↑ instead of right→, use areaX instead of areaY and swap x and y.ForkjsPlot.plot({
  x: {
    grid: true
  },
  marks: [
    Plot.areaX(aapl, {y: "Date", x: "Close", fillOpacity: 0.3}),
    Plot.lineX(aapl, {y: "Date", x: "Close"}),
    Plot.ruleX([0])
  ]
})If some channel values are undefined (or null or NaN), gaps will appear between adjacent points. To demonstrate, below we set the y value to NaN for the first three months of each year.ForkjsPlot.plot({
  y: {
    grid: true
  },
  marks: [
    Plot.areaY(aapl, {x: "Date", y: (d) => d.Date.getUTCMonth() < 3 ? NaN : d.Close, fillOpacity: 0.3}),
    Plot.lineY(aapl, {x: "Date", y: (d) => d.Date.getUTCMonth() < 3 ? NaN : d.Close}),
    Plot.ruleY([0])
  ]
})Supplying undefined values is not the same as filtering the data: the latter will interpolate between the data points. Observe the conspicuous straight lines below!jsPlot.plot({
  y: {
    grid: true
  },
  marks: [
    Plot.areaY(aapl, {filter: (d) => d.Date.getUTCMonth() >= 3, x: "Date", y: "Close", fillOpacity: 0.3}),
    Plot.lineY(aapl, {x: "Date", y: (d) => d.Date.getUTCMonth() < 3 ? NaN : d.Close}),
    Plot.ruleY([0])
  ]
})If a fill channel is specified, it is assumed to be ordinal or nominal; data is grouped into series and then implicitly stacked.ForkjsPlot.plot({
  y: {
    transform: (d) => d / 1000,
    label: "Unemployed (thousands)"
  },
  marks: [
    Plot.areaY(industries, {x: "date", y: "unemployed", fill: "industry"}),
    Plot.ruleY([0])
  ]
})CAUTIONThis area chart uses color but does not include a legend. This should usually be avoided because color cannot be interpreted without a legend, titles, or labels.Or, as a streamgraph with the offset stack transform option:ForkjsPlot.plot({
  y: {
    transform: (d) => d / 1000,
    label: "Unemployed (thousands)"
  },
  marks: [
    Plot.areaY(industries, {x: "date", y: "unemployed", fill: "industry", offset: "wiggle"}),
  ]
})The z channel determines how data is grouped: if the z channel is not specified, but a varying fill channel is, the fill channel is used for z; the z channel will further fallback to a varying stroke channel if needed.The z channel (either implicitly or explicitly) is typically used with the stack transform for a stacked area chart or streamgraph. You can disable the implicit stack transform and produce overlapping areas by setting y2 instead of y.ForkjsPlot.plot({
  marks: [
    Plot.areaY(industries, {x: "date", y2: "unemployed", z: "industry", fillOpacity: 0.1}),
    Plot.lineY(industries, {x: "date", y: "unemployed", z: "industry", strokeWidth: 1})
  ]
})To vary fill within a single series, set the z option to null.ForkjsPlot.plot({
  color: {
    type: "log",
    legend: true
  },
  marks: [
    Plot.areaY(aapl, {x: "Date", y: "Close", fill: "Volume", z: null}),
    Plot.ruleY([0])
  ]
})As an alternative to overlapping or stacking, faceting will produce small multiples, here arranged vertically with a shared x-axis.ForkjsPlot.plot({
  height: 720,
  axis: null,
  marks: [
    Plot.areaY(industries, {x: "date", y: "unemployed", fy: "industry"}),
    Plot.text(industries, Plot.selectFirst({text: "industry", fy: "industry", frameAnchor: "top-left", dx: 6, dy: 6})),
    Plot.frame()
  ]
})TIPAbove, smaller industries such as agriculture and mining & extraction are dwarfed by larger industries such as wholesale & retail trade. To emphasize each industry’s trend, instead of comparing absolute numbers across industries, you could use the normalize transform.Or, as a horizon chart, where the area is repeated at different scales with different colors, showing both small-scale variation in position and large-scale variation in color:ForkjsPlot.plot((() => {
  const bands = 7;
  const step = d3.max(industries, (d) => d.unemployed) / bands;
  return {
    height: 720,
    axis: null,
    y: {domain: [0, step]},
    color: {scheme: "YlGnBu"},
    facet: {data: industries, y: "industry"},
    marks: [
      d3.range(bands).map((i) => Plot.areaY(industries, {x: "date", y: (d) => d.unemployed - i * step, fill: i, clip: true})),
      Plot.text(industries, Plot.selectFirst({text: "industry", frameAnchor: "top-left", dx: 6, dy: 6})),
      Plot.frame()
    ]
  };
})())See also the ridgeline chart example.Interpolation is controlled by the curve option. The default curve is linear, which draws straight line segments between pairs of adjacent points. A step curve is nice for emphasizing when the value changes, while basis and catmull–rom are nice for smoothing.Area options ​The following channels are required:x1 - the horizontal position of the baseline; bound to the x scaley1 - the vertical position of the baseline; bound to the y scaleIn addition to the standard mark options, the following optional channels are supported:x2 - the horizontal position of the topline; bound to the x scaley2 - the vertical position of the topline; bound to the y scalez - a categorical value to group data into seriesIf x2 is not specified, it defaults to x1. If y2 is not specified, it defaults to y1. These defaults facilitate sharing x or y coordinates between the baseline and topline. See also the implicit stack transform and shorthand x and y options supported by areaY and areaX.By default, the data is assumed to represent a single series (i.e., a single value that varies over time). If the z channel is specified, data is grouped by z to form separate series. Typically z is a categorical value such as a series name. If z is not specified, it defaults to fill if a channel, or stroke if a channel.The stroke defaults to none. The fill defaults to currentColor if the stroke is none, and to none otherwise. If the fill is defined as a channel, the area will be broken into contiguous overlapping segments when the fill color changes; the fill color will apply to the interval spanning the current data point and the following data point. This behavior also applies to the fillOpacity, stroke, strokeOpacity, strokeWidth, opacity, href, title, and ariaLabel channels. When any of these channels are used, setting an explicit z channel (possibly to null) is strongly recommended. The strokeLinecap and strokeLinejoin default to round, and the strokeMiterlimit defaults to 1.Points along the baseline and topline are connected in input order. Likewise, if there are multiple series via the z, fill, or stroke channel, the series are drawn in input order such that the last series is drawn on top. Typically, the data is already in sorted order, such as chronological for time series; if sorting is needed, consider a sort transform.The area mark supports curve options to control interpolation between points. If any of the x1, y1, x2, or y2 values are invalid (undefined, null, or NaN), the baseline and topline will be interrupted, resulting in a break that divides the area shape into multiple segments. (See d3-shape’s area.defined for more.) If an area segment consists of only a single point, it may appear invisible unless rendered with rounded or square line caps. In addition, some curves such as cardinal-open only render a visible segment if it contains multiple points.areaY(data, options) ​jsPlot.areaY(aapl, {x: "Date", y: "Close"})Returns a new area with the given data and options. This constructor is used when the baseline and topline share x values, as in a time-series area chart where time goes right→. If neither the y1 nor y2 option is specified, the y option may be specified as shorthand to apply an implicit stackY transform; this is the typical configuration for an area chart with a baseline at y = 0. If the y option is not specified, it defaults to the identity function. The x option specifies the x1 channel; and the x1 and x2 options are ignored.If the interval option is specified, the binX transform is implicitly applied to the specified options. The reducer of the output y channel may be specified via the reduce option, which defaults to first. To default to zero instead of showing gaps in data, as when the observed value represents a quantity, use the sum reducer.jsPlot.areaY(observations, {x: "date", y: "temperature", interval: "day"})The interval option is recommended to “regularize” sampled data; for example, if your data represents timestamped temperature measurements and you expect one sample per day, use "day" as the interval.The areaY mark draws the region between a baseline (y1) and a topline (y2) as in an area chart. When the baseline is y = 0, the y channel can be specified instead of y1 and y2.areaX(data, options) ​jsPlot.areaX(aapl, {y: "Date", x: "Close"})Returns a new area with the given data and options. This constructor is used when the baseline and topline share y values, as in a time-series area chart where time goes up↑. If neither the x1 nor x2 option is specified, the x option may be specified as shorthand to apply an implicit stackX transform; this is the typical configuration for an area chart with a baseline at x = 0. If the x option is not specified, it defaults to the identity function. The y option specifies the y1 channel; and the y1 and y2 options are ignored.If the interval option is specified, the binY transform is implicitly applied to the specified options. The reducer of the output x channel may be specified via the reduce option, which defaults to first. To default to zero instead of showing gaps in data, as when the observed value represents a quantity, use the sum reducer.jsPlot.areaX(observations, {y: "date", x: "temperature", interval: "day"})The interval option is recommended to “regularize” sampled data; for example, if your data represents timestamped temperature measurements and you expect one sample per day, use "day" as the interval.area(data, options) ​jsPlot.area(aapl, {x1: "Date", y1: 0, y2: "Close"})Returns a new area with the given data and options. This method is rarely used directly; it is only needed when the baseline and topline have neither common x nor y values. areaY is used in the common horizontal orientation where the baseline and topline share x values, while areaX is used in the vertical orientation where the baseline and topline share y values.\n\n\n\nArrow mark ^0.4.0 ​TIPSee also the vector mark, which draws arrows of a given length and direction.The arrow mark draws arrows between two points [x1, y1] and [x2, y2] in quantitative dimensions. It is similar to the link mark, except it draws an arrowhead and is suitable for directed edges. With the bend option, it can be swoopy.⤵︎For example, below we show the rising inequality (and population) in various U.S. cities from 1980 to 2015. Each arrow represents two observations of a city: the city’s population (x) and inequality (y) in 1980, and the same in 2015. The arrow’s stroke redundantly encodes the change in inequality: red indicates rising inequality, while blue (there are only four) indicates declining inequality.ForkjsPlot.plot({
  grid: true,
  inset: 10,
  x: {
    type: "log",
    label: "Population"
  },
  y: {
    label: "Inequality",
    ticks: 4
  },
  color: {
    scheme: "BuRd",
    label: "Change in inequality from 1980 to 2015",
    legend: true,
    tickFormat: "+f"
  },
  marks: [
    Plot.arrow(metros, {
      x1: "POP_1980",
      y1: "R90_10_1980",
      x2: "POP_2015",
      y2: "R90_10_2015",
      bend: true,
      stroke: (d) => d.R90_10_2015 - d.R90_10_1980
    }),
    Plot.text(metros, {
      x: "POP_2015",
      y: "R90_10_2015",
      filter: "highlight",
      text: "nyt_display",
      fill: "currentColor",
      stroke: "white",
      dy: -6
    })
  ]
})The arrow mark is also useful for drawing directed graph edges, say representing transition frequencies in a finite state machine.ForkjsPlot.plot({
  inset: 60,
  aspectRatio: 1,
  axis: null,
  marks: [
    Plot.dot(markov.nodes, {r: 40}),
    Plot.arrow(markov.edges, {
      x1: ([[x1]]) => x1,
      y1: ([[, y1]]) => y1,
      x2: ([, [x2]]) => x2,
      y2: ([, [, y2]]) => y2,
      bend: true,
      strokeWidth: ([,, value]) => value,
      strokeLinejoin: "miter",
      headLength: 24,
      inset: 48
    }),
    Plot.text(markov.nodes, {text: ["A", "B", "C"], dy: 12}),
    Plot.text(markov.edges, {
      x: ([[x1, y1], [x2, y2]]) => (x1 + x2) / 2 + (y1 - y2) * 0.15,
      y: ([[x1, y1], [x2, y2]]) => (y1 + y2) / 2 - (x1 - x2) * 0.15,
      text: ([,, value]) => value
    })
  ]
})For undirected edges, as in the arc diagram of character co-occurrence in Les Misérables below, set the sweep option to the desired orientation: -y for right-bulging links whose endpoints are vertically separated.ForkjsPlot.plot({
  height: 1080,
  marginLeft: 100,
  axis: null,
  x: {domain: [0, 1]}, // see https://github.com/observablehq/plot/issues/1541
  color: {domain: d3.range(10), unknown: "#ccc"},
  marks: [
    Plot.dot(miserables.nodes, {x: 0, y: "id", fill: "group", sort: {y: "fill"}}),
    Plot.text(miserables.nodes, {x: 0, y: "id", text: "id", textAnchor: "end", dx: -6, fill: "group"}),
    Plot.arrow(miserables.links, {x: 0, y1: "source", y2: "target", sweep: "-y", bend: 90, headLength: 0, stroke: samegroup, sort: samegroup, reverse: true})
  ]
})Arrow options ​The following channels are required:x1 - the starting horizontal position; bound to the x scaley1 - the starting vertical position; bound to the y scalex2 - the ending horizontal position; bound to the x scaley2 - the ending vertical position; bound to the y scaleFor vertical or horizontal arrows, the x option can be specified as shorthand for x1 and x2, and the y option can be specified as shorthand for y1 and y2, respectively.The arrow mark supports the standard mark options. The stroke defaults to currentColor. The fill defaults to none. The strokeWidth defaults to 1.5, and the strokeMiterlimit defaults to 1. The following additional options are supported:bend - the bend angle, in degrees; defaults to 0°; true for 22.5°headAngle - the arrowhead angle, in degrees; defaults to 60°headLength - the arrowhead scale; defaults to 8insetEnd - inset at the end of the arrow (useful if the arrow points to a dot)insetStart - inset at the start of the arrowinset - shorthand for the two insetssweep - the sweep orderThe bend option sets the angle between the straight line connecting the two points and the outgoing direction of the arrow from the start point. It must be within ±90°. A positive angle will produce a clockwise curve; a negative angle will produce a counterclockwise curve; zero will produce a straight line. The headAngle determines how pointy the arrowhead is; it is typically between 0° and 180°. The headLength determines the scale of the arrowhead relative to the stroke width. Assuming the default of stroke width 1.5px, the headLength is the length of the arrowhead’s side in pixels.The sweep option ^0.6.10 controls the bend orientation. It defaults to 1 indicating a positive (clockwise) bend angle; -1 indicates a negative (anticlockwise) bend angle; 0 effectively clears the bend angle. If -x, the bend angle is flipped when the ending point is to the left of the starting point — ensuring all arrows bulge up (down if bend is negative); if -y, the bend angle is flipped when the ending point is above the starting point — ensuring all arrows bulge right (left if bend is negative); the sign is negated for +x and +y.arrow(data, options) ​jsPlot.arrow(inequality, {x1: "POP_1980", y1: "R90_10_1980", x2: "POP_2015", y2: "R90_10_2015", bend: true})Returns a new arrow with the given data and options.\n\nSearchK0.6.17GitHub️ 4.6kOn this pageArrow mark ^0.4.0 ​TIPSee also the vector mark, which draws arrows of a given length and direction.The arrow mark draws arrows between two points [x1, y1] and [x2, y2] in quantitative dimensions. It is similar to the link mark, except it draws an arrowhead and is suitable for directed edges. With the bend option, it can be swoopy.⤵︎For example, below we show the rising inequality (and population) in various U.S. cities from 1980 to 2015. Each arrow represents two observations of a city: the city’s population (x) and inequality (y) in 1980, and the same in 2015. The arrow’s stroke redundantly encodes the change in inequality: red indicates rising inequality, while blue (there are only four) indicates declining inequality.ForkjsPlot.plot({
  grid: true,
  inset: 10,
  x: {
    type: "log",
    label: "Population"
  },
  y: {
    label: "Inequality",
    ticks: 4
  },
  color: {
    scheme: "BuRd",
    label: "Change in inequality from 1980 to 2015",
    legend: true,
    tickFormat: "+f"
  },
  marks: [
    Plot.arrow(metros, {
      x1: "POP_1980",
      y1: "R90_10_1980",
      x2: "POP_2015",
      y2: "R90_10_2015",
      bend: true,
      stroke: (d) => d.R90_10_2015 - d.R90_10_1980
    }),
    Plot.text(metros, {
      x: "POP_2015",
      y: "R90_10_2015",
      filter: "highlight",
      text: "nyt_display",
      fill: "currentColor",
      stroke: "white",
      dy: -6
    })
  ]
})The arrow mark is also useful for drawing directed graph edges, say representing transition frequencies in a finite state machine.ForkjsPlot.plot({
  inset: 60,
  aspectRatio: 1,
  axis: null,
  marks: [
    Plot.dot(markov.nodes, {r: 40}),
    Plot.arrow(markov.edges, {
      x1: ([[x1]]) => x1,
      y1: ([[, y1]]) => y1,
      x2: ([, [x2]]) => x2,
      y2: ([, [, y2]]) => y2,
      bend: true,
      strokeWidth: ([,, value]) => value,
      strokeLinejoin: "miter",
      headLength: 24,
      inset: 48
    }),
    Plot.text(markov.nodes, {text: ["A", "B", "C"], dy: 12}),
    Plot.text(markov.edges, {
      x: ([[x1, y1], [x2, y2]]) => (x1 + x2) / 2 + (y1 - y2) * 0.15,
      y: ([[x1, y1], [x2, y2]]) => (y1 + y2) / 2 - (x1 - x2) * 0.15,
      text: ([,, value]) => value
    })
  ]
})For undirected edges, as in the arc diagram of character co-occurrence in Les Misérables below, set the sweep option to the desired orientation: -y for right-bulging links whose endpoints are vertically separated.ForkjsPlot.plot({
  height: 1080,
  marginLeft: 100,
  axis: null,
  x: {domain: [0, 1]}, // see https://github.com/observablehq/plot/issues/1541
  color: {domain: d3.range(10), unknown: "#ccc"},
  marks: [
    Plot.dot(miserables.nodes, {x: 0, y: "id", fill: "group", sort: {y: "fill"}}),
    Plot.text(miserables.nodes, {x: 0, y: "id", text: "id", textAnchor: "end", dx: -6, fill: "group"}),
    Plot.arrow(miserables.links, {x: 0, y1: "source", y2: "target", sweep: "-y", bend: 90, headLength: 0, stroke: samegroup, sort: samegroup, reverse: true})
  ]
})Arrow options ​The following channels are required:x1 - the starting horizontal position; bound to the x scaley1 - the starting vertical position; bound to the y scalex2 - the ending horizontal position; bound to the x scaley2 - the ending vertical position; bound to the y scaleFor vertical or horizontal arrows, the x option can be specified as shorthand for x1 and x2, and the y option can be specified as shorthand for y1 and y2, respectively.The arrow mark supports the standard mark options. The stroke defaults to currentColor. The fill defaults to none. The strokeWidth defaults to 1.5, and the strokeMiterlimit defaults to 1. The following additional options are supported:bend - the bend angle, in degrees; defaults to 0°; true for 22.5°headAngle - the arrowhead angle, in degrees; defaults to 60°headLength - the arrowhead scale; defaults to 8insetEnd - inset at the end of the arrow (useful if the arrow points to a dot)insetStart - inset at the start of the arrowinset - shorthand for the two insetssweep - the sweep orderThe bend option sets the angle between the straight line connecting the two points and the outgoing direction of the arrow from the start point. It must be within ±90°. A positive angle will produce a clockwise curve; a negative angle will produce a counterclockwise curve; zero will produce a straight line. The headAngle determines how pointy the arrowhead is; it is typically between 0° and 180°. The headLength determines the scale of the arrowhead relative to the stroke width. Assuming the default of stroke width 1.5px, the headLength is the length of the arrowhead’s side in pixels.The sweep option ^0.6.10 controls the bend orientation. It defaults to 1 indicating a positive (clockwise) bend angle; -1 indicates a negative (anticlockwise) bend angle; 0 effectively clears the bend angle. If -x, the bend angle is flipped when the ending point is to the left of the starting point — ensuring all arrows bulge up (down if bend is negative); if -y, the bend angle is flipped when the ending point is above the starting point — ensuring all arrows bulge right (left if bend is negative); the sign is negated for +x and +y.arrow(data, options) ​jsPlot.arrow(inequality, {x1: "POP_1980", y1: "R90_10_1980", x2: "POP_2015", y2: "R90_10_2015", bend: true})Returns a new arrow with the given data and options.PagerPrevious pageAreaNext pageAuto\n\nArrow mark ^0.4.0 ​TIPSee also the vector mark, which draws arrows of a given length and direction.The arrow mark draws arrows between two points [x1, y1] and [x2, y2] in quantitative dimensions. It is similar to the link mark, except it draws an arrowhead and is suitable for directed edges. With the bend option, it can be swoopy.⤵︎For example, below we show the rising inequality (and population) in various U.S. cities from 1980 to 2015. Each arrow represents two observations of a city: the city’s population (x) and inequality (y) in 1980, and the same in 2015. The arrow’s stroke redundantly encodes the change in inequality: red indicates rising inequality, while blue (there are only four) indicates declining inequality.ForkjsPlot.plot({
  grid: true,
  inset: 10,
  x: {
    type: "log",
    label: "Population"
  },
  y: {
    label: "Inequality",
    ticks: 4
  },
  color: {
    scheme: "BuRd",
    label: "Change in inequality from 1980 to 2015",
    legend: true,
    tickFormat: "+f"
  },
  marks: [
    Plot.arrow(metros, {
      x1: "POP_1980",
      y1: "R90_10_1980",
      x2: "POP_2015",
      y2: "R90_10_2015",
      bend: true,
      stroke: (d) => d.R90_10_2015 - d.R90_10_1980
    }),
    Plot.text(metros, {
      x: "POP_2015",
      y: "R90_10_2015",
      filter: "highlight",
      text: "nyt_display",
      fill: "currentColor",
      stroke: "white",
      dy: -6
    })
  ]
})The arrow mark is also useful for drawing directed graph edges, say representing transition frequencies in a finite state machine.ForkjsPlot.plot({
  inset: 60,
  aspectRatio: 1,
  axis: null,
  marks: [
    Plot.dot(markov.nodes, {r: 40}),
    Plot.arrow(markov.edges, {
      x1: ([[x1]]) => x1,
      y1: ([[, y1]]) => y1,
      x2: ([, [x2]]) => x2,
      y2: ([, [, y2]]) => y2,
      bend: true,
      strokeWidth: ([,, value]) => value,
      strokeLinejoin: "miter",
      headLength: 24,
      inset: 48
    }),
    Plot.text(markov.nodes, {text: ["A", "B", "C"], dy: 12}),
    Plot.text(markov.edges, {
      x: ([[x1, y1], [x2, y2]]) => (x1 + x2) / 2 + (y1 - y2) * 0.15,
      y: ([[x1, y1], [x2, y2]]) => (y1 + y2) / 2 - (x1 - x2) * 0.15,
      text: ([,, value]) => value
    })
  ]
})For undirected edges, as in the arc diagram of character co-occurrence in Les Misérables below, set the sweep option to the desired orientation: -y for right-bulging links whose endpoints are vertically separated.ForkjsPlot.plot({
  height: 1080,
  marginLeft: 100,
  axis: null,
  x: {domain: [0, 1]}, // see https://github.com/observablehq/plot/issues/1541
  color: {domain: d3.range(10), unknown: "#ccc"},
  marks: [
    Plot.dot(miserables.nodes, {x: 0, y: "id", fill: "group", sort: {y: "fill"}}),
    Plot.text(miserables.nodes, {x: 0, y: "id", text: "id", textAnchor: "end", dx: -6, fill: "group"}),
    Plot.arrow(miserables.links, {x: 0, y1: "source", y2: "target", sweep: "-y", bend: 90, headLength: 0, stroke: samegroup, sort: samegroup, reverse: true})
  ]
})Arrow options ​The following channels are required:x1 - the starting horizontal position; bound to the x scaley1 - the starting vertical position; bound to the y scalex2 - the ending horizontal position; bound to the x scaley2 - the ending vertical position; bound to the y scaleFor vertical or horizontal arrows, the x option can be specified as shorthand for x1 and x2, and the y option can be specified as shorthand for y1 and y2, respectively.The arrow mark supports the standard mark options. The stroke defaults to currentColor. The fill defaults to none. The strokeWidth defaults to 1.5, and the strokeMiterlimit defaults to 1. The following additional options are supported:bend - the bend angle, in degrees; defaults to 0°; true for 22.5°headAngle - the arrowhead angle, in degrees; defaults to 60°headLength - the arrowhead scale; defaults to 8insetEnd - inset at the end of the arrow (useful if the arrow points to a dot)insetStart - inset at the start of the arrowinset - shorthand for the two insetssweep - the sweep orderThe bend option sets the angle between the straight line connecting the two points and the outgoing direction of the arrow from the start point. It must be within ±90°. A positive angle will produce a clockwise curve; a negative angle will produce a counterclockwise curve; zero will produce a straight line. The headAngle determines how pointy the arrowhead is; it is typically between 0° and 180°. The headLength determines the scale of the arrowhead relative to the stroke width. Assuming the default of stroke width 1.5px, the headLength is the length of the arrowhead’s side in pixels.The sweep option ^0.6.10 controls the bend orientation. It defaults to 1 indicating a positive (clockwise) bend angle; -1 indicates a negative (anticlockwise) bend angle; 0 effectively clears the bend angle. If -x, the bend angle is flipped when the ending point is to the left of the starting point — ensuring all arrows bulge up (down if bend is negative); if -y, the bend angle is flipped when the ending point is above the starting point — ensuring all arrows bulge right (left if bend is negative); the sign is negated for +x and +y.arrow(data, options) ​jsPlot.arrow(inequality, {x1: "POP_1980", y1: "R90_10_1980", x2: "POP_2015", y2: "R90_10_2015", bend: true})Returns a new arrow with the given data and options.\n\n\n\nAuto mark ^0.6.3 ​The magic ✨ auto mark automatically selects a mark type that best represents the given dimensions of the data according to some simple heuristics. The auto mark — which powers Observable’s chart cell — is intended to support fast exploratory analysis where the goal is to get a useful plot as quickly as possible. For example, two quantitative dimensions make a scatterplot:ForkjsPlot.auto(penguins, {x: "body_mass_g", y: "flipper_length_mm"}).plot()TIPThe auto mark is supposed to be fast and fluid, so don’t overthink it. If you need precise control, use explicit marks instead.CAUTIONWhile the auto mark will respect the options you provide, you shouldn’t rely on its behavior being stable over time. The auto mark may get smarter and take advantage of new features. Because its heuristics are likely to evolve, they are not explicitly documented; see the source code for details.A monotonically increasing dimension (here Date, as the data is ordered chronologically), paired with a numeric column (Close), makes a line chart:ForkjsPlot.auto(aapl, {x: "Date", y: "Close"}).plot()Given only one dimension of data, it makes a histogram:ForkjsPlot.auto(olympians, {x: "weight"}).plot()ForkjsPlot.auto(penguins, {x: "island"}).plot()This is easier than deciding whether to use bin and rect, or group and bar: the auto mark chooses the right one based on whether the data is quantitative or ordinal.If you’d like to explicitly avoid grouping the data, you can opt out of the reducer, and get a one-dimensional plot:ForkjsPlot.auto(penguins, {x: "body_mass_g", y: {reduce: null}}).plot()As you can see from that reduce property, the auto mark has some special syntax that lets you specify a reducer without explicitly specifying a transform. For example, the scatterplot above can be made into a heatmap by adding a color reducer. You can pass the name of a reducer to that property, or pass a shorthand string:ForkjsPlot.auto(olympians, {x: "weight", y: "height", color: "count"}).plot()That’s equivalent to this:jsPlot.rect(olympians, Plot.bin({fill: "count"}, {x: "weight", y: "height"})).plot()Notice that the code above makes you think about nested functions and two different options objects, which the auto mark flattens. The auto mark infers that it should use a rect; that it should bin on x and y; that the kind of color should be a fill; and that fill is an “output” of the reducer, whereas x and y are “inputs”.This saves you a little bit of typing, but, more importantly, it means that switching from showing one dimension to another only involves changing one thing. In the code above, if you change y from weight to sex, it’ll break, because sex is ordinal instead of quantitative. (You’d also have to change rect to barX, and bin to binX.) With the auto mark, it just works:ForkjsPlot.auto(olympians, {x: "weight", y: "sex", color: "count"}).plot()Similarly, with explicit marks and transforms, changing a vertical histogram to a horizontal histogram involves switching rectY to rectX, binX to binY, x to y, and y to x. With the auto mark, just specify y instead of x:ForkjsPlot.auto(penguins, {y: "island"}).plot()For the sake of seamless switching, the auto mark has just one color channel, which it assigns to either fill or stroke depending on the mark. We can see that clearly by overriding a line chart with the mark option to make an area chart:ForkjsPlot.auto(industries, {x: "date", y: "unemployed", color: "industry"}).plot()jsPlot.auto(industries, {x: "date", y: "unemployed", color: "industry", mark: "area"}).plot()The mark override option supports dot, line, area, rule, and bar (which automatically chooses among barX, barY, rectX, rectY, rect, and cell).You can get a more elaborate aggregated chart by passing an object with both a value (the input dimension) and a reduce (the reducer). For example, here’s the average heights of Olympians over time by sex:ForkjsPlot
  .auto(olympians, {x: "date_of_birth", y: {value: "height", reduce: "mean"}, color: "sex", mark: "line"})
  .plot({color: {legend: true}})You can similarly pass a zero option to indicate that zero is meaningful for either x or y. This adds a corresponding rule to the returned mark.ForkjsPlot.auto(industries, {x: "date", y: {value: "unemployed", zero: true}, color: "industry"}).plot()The auto mark has a size channel, which (currently) always results in a dot. For now, it’s an alias for the dot’s r channel; in the future it will also represent a vector’s length channel.ForkjsPlot.auto(aapl, {x: "Date", y: "Close", size: "Volume"}).plot()Like with any other mark, you can also use fx or fy, and pass additional global options in the plot method.ForkjsPlot.auto(penguins, {
  x: "body_mass_g",
  y: "culmen_length_mm",
  fx: "island",
  fy: "species"
}).plot({
  grid: true,
  x: {ticks: 5},
  marginRight: 70
})CautionYou can combine the auto mark with other marks, but the combination may be brittle because the auto mark may pick encodings that don’t play well with others.Auto options ​The auto mark currently supports only a subset of the standard mark options. You must provide at least one position channel:x - horizontal positiony - vertical positionYou may also provide one or more visual encoding channels:color - corresponds to stroke or fill (depending on the chosen mark type)size - corresponds to r (and in future, possibly length)And you may specify the standard mark-level facet channels:fx - horizontal facet position (column)fy - vertical facet position (row)In addition to channel values, the x, y, color, and size options may specify reducers. Setting a reducer on x implicitly groups or bins on y, and likewise setting a reducer on y implicitly groups or bins on x. Setting a reducer on color or size groups or bins in both x and y. Setting a reducer on both x and y throws an error. To specify a reducer, simply pass the reducer name to the corresponding option. For example:jsPlot.auto(penguins, {x: "body_mass_g", y: "count"})To pass both a value and a reducer, or to disambiguate whether the given string represents a field name or a reducer name, the x, y, color, and size options can also be specified as an object with separate value and reduce properties. For example, to compute the total weight of the penguins in each bin:jsPlot.auto(penguins, {x: "body_mass_g", y: {value: "body_mass_g", reduce: "sum"}})If the color channel is specified as a string that is also a valid CSS color, it is interpreted as a constant color. For example, for red bars:jsPlot.auto(penguins, {x: "body_mass_g", color: "red"})This is shorthand for:jsPlot.auto(penguins, {x: "body_mass_g", color: {color: "red"}})To reference a field name instead as a variable color encoding, specify the color option as an object with a value property:jsPlot.auto(penguins, {x: "body_mass_g", color: {value: "red"}})Alternatively, you can specify a function of data or an array of values, as with a standard mark channel.The auto mark chooses the mark type automatically based on several simple heuristics. For more control, you can specify the desired mark type using the mark option, which supports the following names:area - areaY or areaX (or sometimes area)bar - barY or barX; or rectY, rectX, or rect; or celldot - dotline - lineY or lineX (or sometimes line)rule - ruleY or ruleXThe chosen mark type depends both on the options you provide (e.g., whether you specified x or y or both) and the inferred type of the corresponding data values (whether the associated dimension of data is quantitative, categorical, monotonic, etc.).auto(data, options) ​jsPlot.auto(olympians, {x: "weight", y: "height", color: "count"}) // equivalent to rect + bin, sayReturns an automatically-chosen mark with the given data and options, suitable for a quick view of the data.autoSpec(data, options) ^0.6.4 ​jsPlot.autoSpec(olympians, {x: "weight", y: "height", color: "count"})Returns an auto mark options object with no option undefined; the mark type, reducers, and other options are all populated.\n\nSearchK0.6.17GitHub️ 4.6kOn this pageAuto mark ^0.6.3 ​The magic ✨ auto mark automatically selects a mark type that best represents the given dimensions of the data according to some simple heuristics. The auto mark — which powers Observable’s chart cell — is intended to support fast exploratory analysis where the goal is to get a useful plot as quickly as possible. For example, two quantitative dimensions make a scatterplot:ForkjsPlot.auto(penguins, {x: "body_mass_g", y: "flipper_length_mm"}).plot()TIPThe auto mark is supposed to be fast and fluid, so don’t overthink it. If you need precise control, use explicit marks instead.CAUTIONWhile the auto mark will respect the options you provide, you shouldn’t rely on its behavior being stable over time. The auto mark may get smarter and take advantage of new features. Because its heuristics are likely to evolve, they are not explicitly documented; see the source code for details.A monotonically increasing dimension (here Date, as the data is ordered chronologically), paired with a numeric column (Close), makes a line chart:ForkjsPlot.auto(aapl, {x: "Date", y: "Close"}).plot()Given only one dimension of data, it makes a histogram:ForkjsPlot.auto(olympians, {x: "weight"}).plot()ForkjsPlot.auto(penguins, {x: "island"}).plot()This is easier than deciding whether to use bin and rect, or group and bar: the auto mark chooses the right one based on whether the data is quantitative or ordinal.If you’d like to explicitly avoid grouping the data, you can opt out of the reducer, and get a one-dimensional plot:ForkjsPlot.auto(penguins, {x: "body_mass_g", y: {reduce: null}}).plot()As you can see from that reduce property, the auto mark has some special syntax that lets you specify a reducer without explicitly specifying a transform. For example, the scatterplot above can be made into a heatmap by adding a color reducer. You can pass the name of a reducer to that property, or pass a shorthand string:ForkjsPlot.auto(olympians, {x: "weight", y: "height", color: "count"}).plot()That’s equivalent to this:jsPlot.rect(olympians, Plot.bin({fill: "count"}, {x: "weight", y: "height"})).plot()Notice that the code above makes you think about nested functions and two different options objects, which the auto mark flattens. The auto mark infers that it should use a rect; that it should bin on x and y; that the kind of color should be a fill; and that fill is an “output” of the reducer, whereas x and y are “inputs”.This saves you a little bit of typing, but, more importantly, it means that switching from showing one dimension to another only involves changing one thing. In the code above, if you change y from weight to sex, it’ll break, because sex is ordinal instead of quantitative. (You’d also have to change rect to barX, and bin to binX.) With the auto mark, it just works:ForkjsPlot.auto(olympians, {x: "weight", y: "sex", color: "count"}).plot()Similarly, with explicit marks and transforms, changing a vertical histogram to a horizontal histogram involves switching rectY to rectX, binX to binY, x to y, and y to x. With the auto mark, just specify y instead of x:ForkjsPlot.auto(penguins, {y: "island"}).plot()For the sake of seamless switching, the auto mark has just one color channel, which it assigns to either fill or stroke depending on the mark. We can see that clearly by overriding a line chart with the mark option to make an area chart:ForkjsPlot.auto(industries, {x: "date", y: "unemployed", color: "industry"}).plot()jsPlot.auto(industries, {x: "date", y: "unemployed", color: "industry", mark: "area"}).plot()The mark override option supports dot, line, area, rule, and bar (which automatically chooses among barX, barY, rectX, rectY, rect, and cell).You can get a more elaborate aggregated chart by passing an object with both a value (the input dimension) and a reduce (the reducer). For example, here’s the average heights of Olympians over time by sex:ForkjsPlot
  .auto(olympians, {x: "date_of_birth", y: {value: "height", reduce: "mean"}, color: "sex", mark: "line"})
  .plot({color: {legend: true}})You can similarly pass a zero option to indicate that zero is meaningful for either x or y. This adds a corresponding rule to the returned mark.ForkjsPlot.auto(industries, {x: "date", y: {value: "unemployed", zero: true}, color: "industry"}).plot()The auto mark has a size channel, which (currently) always results in a dot. For now, it’s an alias for the dot’s r channel; in the future it will also represent a vector’s length channel.ForkjsPlot.auto(aapl, {x: "Date", y: "Close", size: "Volume"}).plot()Like with any other mark, you can also use fx or fy, and pass additional global options in the plot method.ForkjsPlot.auto(penguins, {
  x: "body_mass_g",
  y: "culmen_length_mm",
  fx: "island",
  fy: "species"
}).plot({
  grid: true,
  x: {ticks: 5},
  marginRight: 70
})CautionYou can combine the auto mark with other marks, but the combination may be brittle because the auto mark may pick encodings that don’t play well with others.Auto options ​The auto mark currently supports only a subset of the standard mark options. You must provide at least one position channel:x - horizontal positiony - vertical positionYou may also provide one or more visual encoding channels:color - corresponds to stroke or fill (depending on the chosen mark type)size - corresponds to r (and in future, possibly length)And you may specify the standard mark-level facet channels:fx - horizontal facet position (column)fy - vertical facet position (row)In addition to channel values, the x, y, color, and size options may specify reducers. Setting a reducer on x implicitly groups or bins on y, and likewise setting a reducer on y implicitly groups or bins on x. Setting a reducer on color or size groups or bins in both x and y. Setting a reducer on both x and y throws an error. To specify a reducer, simply pass the reducer name to the corresponding option. For example:jsPlot.auto(penguins, {x: "body_mass_g", y: "count"})To pass both a value and a reducer, or to disambiguate whether the given string represents a field name or a reducer name, the x, y, color, and size options can also be specified as an object with separate value and reduce properties. For example, to compute the total weight of the penguins in each bin:jsPlot.auto(penguins, {x: "body_mass_g", y: {value: "body_mass_g", reduce: "sum"}})If the color channel is specified as a string that is also a valid CSS color, it is interpreted as a constant color. For example, for red bars:jsPlot.auto(penguins, {x: "body_mass_g", color: "red"})This is shorthand for:jsPlot.auto(penguins, {x: "body_mass_g", color: {color: "red"}})To reference a field name instead as a variable color encoding, specify the color option as an object with a value property:jsPlot.auto(penguins, {x: "body_mass_g", color: {value: "red"}})Alternatively, you can specify a function of data or an array of values, as with a standard mark channel.The auto mark chooses the mark type automatically based on several simple heuristics. For more control, you can specify the desired mark type using the mark option, which supports the following names:area - areaY or areaX (or sometimes area)bar - barY or barX; or rectY, rectX, or rect; or celldot - dotline - lineY or lineX (or sometimes line)rule - ruleY or ruleXThe chosen mark type depends both on the options you provide (e.g., whether you specified x or y or both) and the inferred type of the corresponding data values (whether the associated dimension of data is quantitative, categorical, monotonic, etc.).auto(data, options) ​jsPlot.auto(olympians, {x: "weight", y: "height", color: "count"}) // equivalent to rect + bin, sayReturns an automatically-chosen mark with the given data and options, suitable for a quick view of the data.autoSpec(data, options) ^0.6.4 ​jsPlot.autoSpec(olympians, {x: "weight", y: "height", color: "count"})Returns an auto mark options object with no option undefined; the mark type, reducers, and other options are all populated.PagerPrevious pageArrowNext pageAxis\n\nAuto mark ^0.6.3 ​The magic ✨ auto mark automatically selects a mark type that best represents the given dimensions of the data according to some simple heuristics. The auto mark — which powers Observable’s chart cell — is intended to support fast exploratory analysis where the goal is to get a useful plot as quickly as possible. For example, two quantitative dimensions make a scatterplot:ForkjsPlot.auto(penguins, {x: "body_mass_g", y: "flipper_length_mm"}).plot()TIPThe auto mark is supposed to be fast and fluid, so don’t overthink it. If you need precise control, use explicit marks instead.CAUTIONWhile the auto mark will respect the options you provide, you shouldn’t rely on its behavior being stable over time. The auto mark may get smarter and take advantage of new features. Because its heuristics are likely to evolve, they are not explicitly documented; see the source code for details.A monotonically increasing dimension (here Date, as the data is ordered chronologically), paired with a numeric column (Close), makes a line chart:ForkjsPlot.auto(aapl, {x: "Date", y: "Close"}).plot()Given only one dimension of data, it makes a histogram:ForkjsPlot.auto(olympians, {x: "weight"}).plot()ForkjsPlot.auto(penguins, {x: "island"}).plot()This is easier than deciding whether to use bin and rect, or group and bar: the auto mark chooses the right one based on whether the data is quantitative or ordinal.If you’d like to explicitly avoid grouping the data, you can opt out of the reducer, and get a one-dimensional plot:ForkjsPlot.auto(penguins, {x: "body_mass_g", y: {reduce: null}}).plot()As you can see from that reduce property, the auto mark has some special syntax that lets you specify a reducer without explicitly specifying a transform. For example, the scatterplot above can be made into a heatmap by adding a color reducer. You can pass the name of a reducer to that property, or pass a shorthand string:ForkjsPlot.auto(olympians, {x: "weight", y: "height", color: "count"}).plot()That’s equivalent to this:jsPlot.rect(olympians, Plot.bin({fill: "count"}, {x: "weight", y: "height"})).plot()Notice that the code above makes you think about nested functions and two different options objects, which the auto mark flattens. The auto mark infers that it should use a rect; that it should bin on x and y; that the kind of color should be a fill; and that fill is an “output” of the reducer, whereas x and y are “inputs”.This saves you a little bit of typing, but, more importantly, it means that switching from showing one dimension to another only involves changing one thing. In the code above, if you change y from weight to sex, it’ll break, because sex is ordinal instead of quantitative. (You’d also have to change rect to barX, and bin to binX.) With the auto mark, it just works:ForkjsPlot.auto(olympians, {x: "weight", y: "sex", color: "count"}).plot()Similarly, with explicit marks and transforms, changing a vertical histogram to a horizontal histogram involves switching rectY to rectX, binX to binY, x to y, and y to x. With the auto mark, just specify y instead of x:ForkjsPlot.auto(penguins, {y: "island"}).plot()For the sake of seamless switching, the auto mark has just one color channel, which it assigns to either fill or stroke depending on the mark. We can see that clearly by overriding a line chart with the mark option to make an area chart:ForkjsPlot.auto(industries, {x: "date", y: "unemployed", color: "industry"}).plot()jsPlot.auto(industries, {x: "date", y: "unemployed", color: "industry", mark: "area"}).plot()The mark override option supports dot, line, area, rule, and bar (which automatically chooses among barX, barY, rectX, rectY, rect, and cell).You can get a more elaborate aggregated chart by passing an object with both a value (the input dimension) and a reduce (the reducer). For example, here’s the average heights of Olympians over time by sex:ForkjsPlot
  .auto(olympians, {x: "date_of_birth", y: {value: "height", reduce: "mean"}, color: "sex", mark: "line"})
  .plot({color: {legend: true}})You can similarly pass a zero option to indicate that zero is meaningful for either x or y. This adds a corresponding rule to the returned mark.ForkjsPlot.auto(industries, {x: "date", y: {value: "unemployed", zero: true}, color: "industry"}).plot()The auto mark has a size channel, which (currently) always results in a dot. For now, it’s an alias for the dot’s r channel; in the future it will also represent a vector’s length channel.ForkjsPlot.auto(aapl, {x: "Date", y: "Close", size: "Volume"}).plot()Like with any other mark, you can also use fx or fy, and pass additional global options in the plot method.ForkjsPlot.auto(penguins, {
  x: "body_mass_g",
  y: "culmen_length_mm",
  fx: "island",
  fy: "species"
}).plot({
  grid: true,
  x: {ticks: 5},
  marginRight: 70
})CautionYou can combine the auto mark with other marks, but the combination may be brittle because the auto mark may pick encodings that don’t play well with others.Auto options ​The auto mark currently supports only a subset of the standard mark options. You must provide at least one position channel:x - horizontal positiony - vertical positionYou may also provide one or more visual encoding channels:color - corresponds to stroke or fill (depending on the chosen mark type)size - corresponds to r (and in future, possibly length)And you may specify the standard mark-level facet channels:fx - horizontal facet position (column)fy - vertical facet position (row)In addition to channel values, the x, y, color, and size options may specify reducers. Setting a reducer on x implicitly groups or bins on y, and likewise setting a reducer on y implicitly groups or bins on x. Setting a reducer on color or size groups or bins in both x and y. Setting a reducer on both x and y throws an error. To specify a reducer, simply pass the reducer name to the corresponding option. For example:jsPlot.auto(penguins, {x: "body_mass_g", y: "count"})To pass both a value and a reducer, or to disambiguate whether the given string represents a field name or a reducer name, the x, y, color, and size options can also be specified as an object with separate value and reduce properties. For example, to compute the total weight of the penguins in each bin:jsPlot.auto(penguins, {x: "body_mass_g", y: {value: "body_mass_g", reduce: "sum"}})If the color channel is specified as a string that is also a valid CSS color, it is interpreted as a constant color. For example, for red bars:jsPlot.auto(penguins, {x: "body_mass_g", color: "red"})This is shorthand for:jsPlot.auto(penguins, {x: "body_mass_g", color: {color: "red"}})To reference a field name instead as a variable color encoding, specify the color option as an object with a value property:jsPlot.auto(penguins, {x: "body_mass_g", color: {value: "red"}})Alternatively, you can specify a function of data or an array of values, as with a standard mark channel.The auto mark chooses the mark type automatically based on several simple heuristics. For more control, you can specify the desired mark type using the mark option, which supports the following names:area - areaY or areaX (or sometimes area)bar - barY or barX; or rectY, rectX, or rect; or celldot - dotline - lineY or lineX (or sometimes line)rule - ruleY or ruleXThe chosen mark type depends both on the options you provide (e.g., whether you specified x or y or both) and the inferred type of the corresponding data values (whether the associated dimension of data is quantitative, categorical, monotonic, etc.).auto(data, options) ​jsPlot.auto(olympians, {x: "weight", y: "height", color: "count"}) // equivalent to rect + bin, sayReturns an automatically-chosen mark with the given data and options, suitable for a quick view of the data.autoSpec(data, options) ^0.6.4 ​jsPlot.autoSpec(olympians, {x: "weight", y: "height", color: "count"})Returns an auto mark options object with no option undefined; the mark type, reducers, and other options are all populated.\n\n\n\n